PR: https://github.com/odoo/odoo/pull/72239

From: 1e25946a76efe5c6634167f0cf3a39f74692a9fa
From: Aur√©lien Warnon
Date: 2021-11-23 11:12:04

Structural Changes: 3
Total Changes: 50

[IMP] utm: globally improve UTM records management across all apps

PURPOSE

This commit consolidates UTM usage across all applications.

Global purpose is to avoid having undesired side-effects, such as unlinking an
utm.source/utm.medium/utm.campaign and at the same time cascading the deletion
to various records without noticing.

SPECS

ALLOW MORE PEOPLE TO CLEAN UTM RECORDS

Currently, not even the system administrator can delete utm.mediums and
utm.sources (he can only delete campaigns).

These were considered as "technical records", but allowing some cleanup is
a good idea since these records are often automatically generated and can
create a lot of unnecessary noise in the database.

That's why we now allow the following groups to delete all UTM records
(sources, mediums and campaigns):
- group_system
- group_mass_mailing_user
- group_social_manager (enterprise)

PREVENT DELETION

For some use cases, removing an utm.source/utm.medium/utm.campaign would
cascade delete the related record, which was unintended / hidden side effect.

These combinations were secured by preventing to unlink:
- mailing.mailing source_id field
  Trying to delete the utm.source will throw an error message
- mailing.mailing medium_id field
  Trying to delete the utm.medium will throw an error message
- hr.recruitment.source source_id field
  Trying to delete the utm.source will throw an error message

ADDING CLEAN ERROR MESSAGES

When trying to delete an UTM record that is linked with ondelete="restrict", we
improved the error message to give a clear explication to the user, e.g:

"You can't delete these UTM sources as they are linked to the following
mailings in the Mass Mailing APP, and deleting the source would break the
statistics: Newsletter"

SPECIFY 'ondelete' strategy

For a lot of uses of sources/mediums/campaigns, the 'ondelete' strategy was not
specified, leading to the confusion of "is this really how we want to handle
this?".

A lot of ondelete="set null" have been added in various field definitions to
ensure that this is the desired and logical strategy we want for that
specific model.

PREVENT REMOVING HARDCODED UTM RECORDS

In some functional flows, UTM records are hardcoded using their direct
record reference.
This is notably the case for the recruitment process and its creation of
aliases, and for the Email / SMS Marketing flows.

As deleting them would break these flows, we prevent their deletion in a
"api.ondelete" method.

ENFORCE NEW RULES WITH TESTS

A lot of python tests have been added to make sure we enforce the decisions
taken here above.

LINKS

ENT PR odoo/enterprise#19048
Task-2459480

closes odoo/odoo#72239

Signed-off-by: Thibault Delavallee (tde) <tde@openerp.com>

================================= pseudo patch: =================================

--- a/addons/hr_recruitment/models/__init__.py
+++ b/addons/hr_recruitment/models/__init__.py
@@ -5,3 +5,5 @@ from . import hr_job
 from . import res_config_settings
 from . import calendar
 from . import digest
+from . import utm_campaign
+from . import utm_source

--- a/addons/hr_recruitment/models/hr_recruitment.py
+++ b/addons/hr_recruitment/models/hr_recruitment.py
@@ -23,7 +23,7 @@ class RecruitmentSource(models.Model):
     _description = "Source of Applicants"
     _inherits = {"utm.source": "source_id"}
 
-    source_id = fields.Many2one('utm.source', "Source", ondelete='cascade', required=True)
+    source_id = fields.Many2one('utm.source', "Source", ondelete='restrict', required=True)
     email = fields.Char(related='alias_id.display_name', string="Email", readonly=True)
     job_id = fields.Many2one('hr.job', "Job", ondelete='cascade')
     alias_id = fields.Many2one('mail.alias', "Alias ID")
@@ -173,6 +173,10 @@ class Applicant(models.Model):
     meeting_ids = fields.One2many('calendar.event', 'applicant_id', 'Meetings')
     meeting_display_text = fields.Char(compute='_compute_meeting_display')
     meeting_display_date = fields.Date(compute='_compute_meeting_display')
+    # UTMs - enforcing the fact that we want to 'set null' when relation is unlinked
+    campaign_id = fields.Many2one(ondelete='set null')
+    medium_id = fields.Many2one(ondelete='set null')
+    source_id = fields.Many2one(ondelete='set null')
 
     @api.depends('date_open', 'date_closed')
     def _compute_day(self):

--- a/None
+++ b/addons/hr_recruitment/models/utm_campaign.py
@@ -0,0 +1,19 @@
+# -*- coding:utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from odoo import _, api, models
+
+from odoo.exceptions import UserError
+
+
+class UtmCampaign(models.Model):
+    _inherit = 'utm.campaign'
+
+    @api.ondelete(at_uninstall=False)
+    def _unlink_except_utm_campaign_job(self):
+        utm_campaign_job = self.env.ref('hr_recruitment.utm_campaign_job', raise_if_not_found=False)
+        if utm_campaign_job and utm_campaign_job in self:
+            raise UserError(_(
+                "The UTM campaign '%s' cannot be deleted as it is used in the recruitment process.",
+                utm_campaign_job.name
+            ))

--- a/None
+++ b/addons/hr_recruitment/models/utm_source.py
@@ -0,0 +1,23 @@
+# -*- coding:utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from odoo import _, api, models
+
+from odoo.exceptions import UserError
+
+
+class UtmSource(models.Model):
+    _inherit = 'utm.source'
+
+    @api.ondelete(at_uninstall=False)
+    def _unlink_except_linked_recruitment_sources(self):
+        """ Already handled by ondelete='restrict', but let's show a nice error message """
+        linked_recruitment_sources = self.env['hr.recruitment.source'].sudo().search([
+            ('source_id', 'in', self.ids)
+        ])
+
+        if linked_recruitment_sources:
+            raise UserError(_(
+                "You cannot delete these UTM Sources as they are linked to the following recruitment sources in "
+                "Recruitment:\n%(recruitment_sources)s",
+                recruitment_sources=', '.join(['"%s"' % name for name in linked_recruitment_sources.job_id.mapped('name')])))
