PR: https://github.com/odoo/odoo/pull/

From: ddf2b21bdf38492ce075d4ae96bb9323c6ef59dd
From: Simon Lejeune
Date: 2017-07-14 15:08:22

Breaking data model changes scores: del:7 + add:3, change matches:
-    pack_operation_ids = fields.One2many('stock.pack.operation', 'move_id')
-    pack_operation_nosuggest_ids = fields.One2many('stock.pack.operation', 'move_id', domain=[('product_qty', '=', 0.0)])
+    move_line_ids = fields.One2many('stock.move.line', 'move_id')
+    move_line_nosuggest_ids = fields.One2many('stock.move.line', 'move_id', domain=[('product_qty', '=', 0.0)])
-    pack_operation_ids = fields.One2many(
+    move_line_ids = fields.One2many(
-    pack_operation_exist = fields.Boolean(

Total Changes: 204

[REF] stock: adapt to rename of stock.pack.operation into stock.mode.line

================================= pseudo patch: =================================

--- a/addons/stock/models/__init__.py
+++ b/addons/stock/models/__init__.py
@@ -12,7 +12,7 @@ from . import stock_incoterms
 from . import stock_inventory
 from . import stock_location
 from . import stock_move
-from . import stock_pack_operation
+from . import stock_move_line
 from . import stock_production_lot
 from . import stock_picking
 from . import stock_quant

--- a/addons/stock/models/stock_inventory.py
+++ b/addons/stock/models/stock_inventory.py
@@ -412,7 +412,7 @@ class InventoryLine(models.Model):
             'restrict_partner_id': self.partner_id.id,
             'location_id': location_id,
             'location_dest_id': location_dest_id,
-            'pack_operation_ids': [(0, 0, {'product_id': self.product_id.id,
+            'move_line_ids': [(0, 0, {'product_id': self.product_id.id,
                                            'lot_id': self.prod_lot_id.id, 
                                            'product_uom_qty': 0,  # bypass reservation here
                                            'product_uom_id': self.product_uom_id.id,

--- a/addons/stock/models/stock_move.py
+++ b/addons/stock/models/stock_move.py
@@ -130,8 +130,8 @@ class StockMove(models.Model):
         help='If checked, when this move is cancelled, cancel the linked move too')
     picking_type_id = fields.Many2one('stock.picking.type', 'Operation Type')
     inventory_id = fields.Many2one('stock.inventory', 'Inventory')
-    pack_operation_ids = fields.One2many('stock.pack.operation', 'move_id')
-    pack_operation_nosuggest_ids = fields.One2many('stock.pack.operation', 'move_id', domain=[('product_qty', '=', 0.0)])
+    move_line_ids = fields.One2many('stock.move.line', 'move_id')
+    move_line_nosuggest_ids = fields.One2many('stock.move.line', 'move_id', domain=[('product_qty', '=', 0.0)])
     origin_returned_move_id = fields.Many2one('stock.move', 'Origin return move', copy=False, help='Move that created the return move')
     returned_move_ids = fields.One2many('stock.move', 'origin_returned_move_id', 'All returned moves', help='Optional: all returned moves created from this move')
     reserved_availability = fields.Float(
@@ -161,7 +161,7 @@ class StockMove(models.Model):
     is_initial_demand_editable = fields.Boolean('Is initial demand editable', compute='_compute_is_initial_demand_editable')
 
     @api.multi
-    @api.depends('has_tracking', 'pack_operation_ids', 'location_id', 'location_dest_id', 'is_editable')
+    @api.depends('has_tracking', 'move_line_ids', 'location_id', 'location_dest_id', 'is_editable')
     def _compute_show_details_visible(self):
         """ According to this field, the button that calls `action_show_details` will be displayed
         to work on a move from its picking form view, or not.
@@ -178,10 +178,10 @@ class StockMove(models.Model):
             multi_locations_enabled = False
             if self.user_has_groups('stock.group_stock_multi_locations'):
                 multi_locations_enabled = move.location_id.child_ids or move.location_dest_id.child_ids
-            has_package = move.pack_operation_ids.mapped('package_id') | move.pack_operation_ids.mapped('result_package_id')
+            has_package = move.move_line_ids.mapped('package_id') | move.move_line_ids.mapped('result_package_id')
             if move.picking_id.picking_type_id.show_operations is False\
                     and move.state not in ['cancel', 'draft', 'confirmed']\
-                    and (multi_locations_enabled or move.has_tracking != 'none' or len(move.pack_operation_ids) > 1 or has_package):
+                    and (multi_locations_enabled or move.has_tracking != 'none' or len(move.move_line_ids) > 1 or has_package):
                 move.show_details_visible = True
             else:
                 move.show_details_visible = False
@@ -216,10 +216,10 @@ class StockMove(models.Model):
         """ This will return the move lines to consider when applying _quantity_done_compute on a stock.move. 
         In some context, such as MRP, it is necessary to compute quantity_done on filtered sock.move.line."""
         self.ensure_one()
-        return self.pack_operation_ids
+        return self.move_line_ids
 
     @api.multi
-    @api.depends('pack_operation_ids.qty_done', 'pack_operation_ids.product_uom_id')
+    @api.depends('move_line_ids.qty_done', 'move_line_ids.product_uom_id')
     def _quantity_done_compute(self):
         for move in self:
             for move_line in move._get_move_lines():
@@ -234,8 +234,8 @@ class StockMove(models.Model):
             if not move_lines:
                 if quantity_done:
                     # do not impact reservation here
-                    move_line = self.env['stock.pack.operation'].create(dict(move._prepare_move_line_vals(), qty_done=quantity_done))
-                    move.write({'pack_operation_ids': [(4, move_line.id)]})
+                    move_line = self.env['stock.move.line'].create(dict(move._prepare_move_line_vals(), qty_done=quantity_done))
+                    move.write({'move_line_ids': [(4, move_line.id)]})
             elif len(move_lines) == 1:
                 move_lines[0].qty_done = quantity_done
             else:
@@ -250,13 +250,13 @@ class StockMove(models.Model):
 
 
     @api.one
-    @api.depends('pack_operation_ids.product_qty')
+    @api.depends('move_line_ids.product_qty')
     def _compute_reserved_availability(self):
         """ Fill the `availability` field on a stock move, which is the actual reserved quantity
         and is represented by the aggregated `product_qty` on the linked move lines. If the move
         is force assigned, the value will be 0.
         """
-        self.reserved_availability = self.product_id.uom_id._compute_quantity(sum(self.pack_operation_ids.mapped('product_qty')), self.product_uom, rounding_method='HALF-UP')
+        self.reserved_availability = self.product_id.uom_id._compute_quantity(sum(self.move_line_ids.mapped('product_qty')), self.product_uom, rounding_method='HALF-UP')
 
     @api.one
     @api.depends('state', 'product_id', 'product_qty', 'location_id')
@@ -407,7 +407,7 @@ class StockMove(models.Model):
         self.ensure_one()
 
         # If "show suggestions" is not checked on the picking type, we have to filter out the
-        # reserved move lines. We do this by displaying `pack_operation_nosuggest_ids`. We use
+        # reserved move lines. We do this by displaying `move_line_nosuggest_ids`. We use
         # different views to display one field or another so that the webclient doesn't have to
         # fetch both.
         if self.picking_id.picking_type_id.show_reserved:
@@ -639,14 +639,14 @@ class StockMove(models.Model):
             move.write({'state': 'assigned'})
 
     @api.multi
-    def check_tracking(self, pack_operation):
+    def check_tracking(self, move_line):
         """ Checks if serial number is assigned to stock move or not and raise an error if it had to. """
         # TDE FIXME: I cannot able to understand
         for move in self:
             if move.picking_id and \
                     (move.picking_id.picking_type_id.use_existing_lots or move.picking_id.picking_type_id.use_create_lots) and \
                     move.product_id.tracking != 'none' and \
-                    not (move.restrict_lot_id or (pack_operation and (pack_operation.product_id and pack_operation.pack_lot_ids)) or (pack_operation and not pack_operation.product_id)):
+                    not (move.restrict_lot_id or (move_line and (move_line.product_id and move_line.pack_lot_ids)) or (move_line and not move_line.product_id)):
                 raise UserError(_('You need to provide a Lot/Serial Number for product %s') % move.product_id.name)
 
     def _prepare_move_line_vals(self, quantity=None, reserved_quant=None):
@@ -694,15 +694,15 @@ class StockMove(models.Model):
             package_id=package_id, owner_id=owner_id, strict=strict
         )
         for reserved_quant, quantity in quants:
-            to_update = self.pack_operation_ids.filtered(lambda m: m.location_id.id == reserved_quant.location_id.id and m.lot_id.id == reserved_quant.lot_id.id and m.package_id.id == reserved_quant.package_id.id and m.owner_id.id == reserved_quant.owner_id.id)
+            to_update = self.move_line_ids.filtered(lambda m: m.location_id.id == reserved_quant.location_id.id and m.lot_id.id == reserved_quant.lot_id.id and m.package_id.id == reserved_quant.package_id.id and m.owner_id.id == reserved_quant.owner_id.id)
             if to_update:
                 to_update[0].with_context(bypass_reservation_update=True).product_uom_qty += self.product_id.uom_id._compute_quantity(taken_quantity, self.product_uom, rounding_method='HALF-UP')
             else:
                 if self.product_id.tracking == 'serial':
                     for i in range(0, int(quantity)):
-                        self.env['stock.pack.operation'].create(self._prepare_move_line_vals(quantity=1, reserved_quant=reserved_quant))
+                        self.env['stock.move.line'].create(self._prepare_move_line_vals(quantity=1, reserved_quant=reserved_quant))
                 else:
-                    self.env['stock.pack.operation'].create(self._prepare_move_line_vals(quantity=quantity, reserved_quant=reserved_quant))
+                    self.env['stock.move.line'].create(self._prepare_move_line_vals(quantity=quantity, reserved_quant=reserved_quant))
         return taken_quantity
 
     @api.multi
@@ -718,11 +718,11 @@ class StockMove(models.Model):
                 # create the move line(s) but do not impact quants
                 if move.product_id.tracking == 'serial':
                     for i in range(0, int(move.product_qty)):
-                        move_line_id = self.env['stock.pack.operation'].create(move._prepare_move_line_vals(quantity=1))
-                        move.write({'pack_operation_ids': [(4, move_line_id.id, 0)]})
+                        move_line_id = self.env['stock.move.line'].create(move._prepare_move_line_vals(quantity=1))
+                        move.write({'move_line_ids': [(4, move_line_id.id, 0)]})
                 else:
-                    move_line_id = self.env['stock.pack.operation'].create(move._prepare_move_line_vals(quantity=move.product_qty))
-                    move.write({'pack_operation_ids': [(4, move_line_id.id, 0)]})
+                    move_line_id = self.env['stock.move.line'].create(move._prepare_move_line_vals(quantity=move.product_qty))
+                    move.write({'move_line_ids': [(4, move_line_id.id, 0)]})
                 move.write({'state': 'assigned'})
             else:
                 if not move.move_orig_ids:
@@ -741,24 +741,24 @@ class StockMove(models.Model):
                 else:
                     # Check what our parents brought and what our siblings took in order to
                     # determine what we can distribute.
-                    move_lines_in = move.move_orig_ids.filtered(lambda m: m.state == 'done').mapped('pack_operation_ids')
+                    move_lines_in = move.move_orig_ids.filtered(lambda m: m.state == 'done').mapped('move_line_ids')
                     keys_in = ['location_dest_id', 'lot_id', 'result_package_id', 'owner_id']
                     grouped_move_lines_in = {}
                     for k, g in groupby(sorted(move_lines_in, key=itemgetter(*keys_in)), key=itemgetter(*keys_in)):
-                        grouped_move_lines_in[k] = sum(self.env['stock.pack.operation'].concat(*list(g)).mapped('qty_done'))
+                        grouped_move_lines_in[k] = sum(self.env['stock.move.line'].concat(*list(g)).mapped('qty_done'))
 
                     move_lines_out_done = (move.move_orig_ids.mapped('move_dest_ids') - move)\
                         .filtered(lambda m: m.state in ['done'])\
-                        .mapped('pack_operation_ids')
+                        .mapped('move_line_ids')
                     move_lines_out_reserved = (move.move_orig_ids.mapped('move_dest_ids') - move)\
                         .filtered(lambda m: m.state in ['partially_available', 'assigned'])\
-                        .mapped('pack_operation_ids')
+                        .mapped('move_line_ids')
                     keys_out = ['location_id', 'lot_id', 'package_id', 'owner_id']
                     grouped_move_lines_out = {}
                     for k, g in groupby(sorted(move_lines_out_done, key=itemgetter(*keys_out)), key=itemgetter(*keys_out)):
-                        grouped_move_lines_out[k] = sum(self.env['stock.pack.operation'].concat(*list(g)).mapped('qty_done'))
+                        grouped_move_lines_out[k] = sum(self.env['stock.move.line'].concat(*list(g)).mapped('qty_done'))
                     for k, g in groupby(sorted(move_lines_out_reserved, key=itemgetter(*keys_out)), key=itemgetter(*keys_out)):
-                        grouped_move_lines_out[k] = sum(self.env['stock.pack.operation'].concat(*list(g)).mapped('product_qty'))
+                        grouped_move_lines_out[k] = sum(self.env['stock.move.line'].concat(*list(g)).mapped('product_qty'))
                     available_move_lines = {key: grouped_move_lines_in[key] - grouped_move_lines_out.get(key, 0) for key in grouped_move_lines_in.keys()}
                     # pop key if the quantity available amount to 0
                     available_move_lines = dict((k, v) for k, v in available_move_lines.iteritems() if v)
@@ -769,7 +769,7 @@ class StockMove(models.Model):
                         if available_move_lines.get((move_line.location_id, move_line.lot_id, move_line.result_package_id, move_line.owner_id)):
                             available_move_lines[(move_line.location_id, move_line.lot_id, move_line.result_package_id, move_line.owner_id)] -= move_line.product_qty
                     for (location_id, lot_id, package_id, owner_id), quantity in available_move_lines.items():
-                        need = move.product_qty - sum(move.pack_operation_ids.mapped('product_qty'))
+                        need = move.product_qty - sum(move.move_line_ids.mapped('product_qty'))
                         taken_quantity = move._increase_reserved_quantity(need, quantity, location_id, lot_id, package_id, owner_id)
                         if need - taken_quantity == 0.0:
                             move.state = 'assigned'
@@ -827,7 +827,7 @@ class StockMove(models.Model):
             extra_move = self.copy(default=extra_move_vals).action_confirm()
 
             # link it to some move lines
-            for move_line in self.pack_operation_ids.filtered(lambda ml: ml.qty_done):
+            for move_line in self.move_line_ids.filtered(lambda ml: ml.qty_done):
                 if float_compare(move_line.qty_done, extra_move_quantity, precision_rounding=rounding) <= 0:
                     # move this move line to our extra move
                     move_line.move_id = extra_move.id
@@ -872,7 +872,7 @@ class StockMove(models.Model):
                 # Need to do some kind of conversion here
                 qty_split = move.product_uom._compute_quantity(move.product_uom_qty - move.quantity_done, move.product_id.uom_id)
                 new_move = move.split(qty_split)
-                for move_line in move.pack_operation_ids:
+                for move_line in move.move_line_ids:
                     if move_line.product_qty:
                         # FIXME: there will be an issue if the move was partially available
                         # By decreasing `product_qty`, we free the reservation.
@@ -883,9 +883,9 @@ class StockMove(models.Model):
                             pass
 
                 # If you were already putting stock.move.lots on the next one in the work order, transfer those to the new move
-                move.pack_operation_ids.filtered(lambda x: x.qty_done == 0.0).write({'move_id': new_move})
+                move.move_line_ids.filtered(lambda x: x.qty_done == 0.0).write({'move_id': new_move})
                 self.browse(new_move).quantity_done = 0.0
-            for packop in move.pack_operation_ids:
+            for packop in move.move_line_ids:
                 if float_compare(packop.qty_done, 0, precision_rounding=rounding) > 0:
                     if move.has_tracking != 'none' and (move.picking_type_id.use_create_lots or move.picking_type_id.use_existing_lots):
                         if packop.lot_name and not packop.lot_id:
@@ -905,7 +905,7 @@ class StockMove(models.Model):
                 backorder_picking = picking.copy({
                         'name': '/',
                         'move_lines': [],
-                        'pack_operation_ids': [],
+                        'move_line_ids': [],
                         'backorder_id': picking.id
                     })
                 picking.message_post('Backorder Created') #message needs to be improved

--- a/addons/stock/models/stock_move_line.py
+++ b/addons/stock/models/stock_move_line.py
@@ -9,8 +9,8 @@ from odoo.tools.pycompat import izip
 from odoo.tools.float_utils import float_round, float_compare, float_is_zero
 
 
-class PackOperation(models.Model):
-    _name = "stock.pack.operation" #TODO: change to stock.move.operation
+class StockMoveLine(models.Model):
+    _name = "stock.move.line"
     _description = "Packing Operation"
     _order = "result_package_id desc, id"
 
@@ -94,7 +94,7 @@ class PackOperation(models.Model):
     @api.model
     def create(self, vals):
         vals['ordered_qty'] = vals.get('product_uom_qty')
-        ml = super(PackOperation, self).create(vals)
+        ml = super(StockMoveLine, self).create(vals)
         if ml.state == 'done':
             Quant = self.env['stock.quant']
             quantity = ml.product_uom_id._compute_quantity(ml.qty_done, ml.move_id.product_id.uom_id,rounding_method='HALF-UP')
@@ -121,7 +121,7 @@ class PackOperation(models.Model):
         the old quants and allocate the new ones.
         """
         if self.env.context.get('bypass_reservation_update'):
-            return super(PackOperation, self).write(vals)
+            return super(StockMoveLine, self).write(vals)
 
         Quant = self.env['stock.quant']
         # We forbid to change the reserved quantity in the interace, but it is needed in the
@@ -219,7 +219,7 @@ class PackOperation(models.Model):
                     Quant._increase_available_quantity(product_id, location_dest_id, quantity, lot_id=lot_id, package_id=result_package_id, owner_id=owner_id)
                 # Unreserve and reserve following move in order to have the real reserved quantity on move_line.
                 next_moves |= ml.move_id.move_dest_ids.filtered(lambda move: move.state not in ('done', 'cancel'))
-        res = super(PackOperation, self).write(vals)
+        res = super(StockMoveLine, self).write(vals)
         next_moves.do_unreserve()
         next_moves.action_assign()
         return res
@@ -234,7 +234,7 @@ class PackOperation(models.Model):
             if ml.location_id.should_impact_quants() and ml.product_id.type == 'product' and not float_is_zero(ml.product_qty, precision_digits=precision):
                 self.env['stock.quant']._decrease_reserved_quantity(ml.product_id, ml.location_id, ml.product_qty, lot_id=ml.lot_id,
                                                                    package_id=ml.package_id, owner_id=ml.owner_id)
-        return super(PackOperation, self).unlink()
+        return super(StockMoveLine, self).unlink()
 
     def action_done(self):
         """ This method will finalize the work with a move line by "moving" quants to the
@@ -296,7 +296,7 @@ class PackOperation(models.Model):
                 ('qty_done', '=', 0.0),
                 ('id', '!=', self.id),
             ]
-            oudated_candidates = self.env['stock.pack.operation'].search(oudated_move_lines_domain)
+            oudated_candidates = self.env['stock.move.line'].search(oudated_move_lines_domain)
 
             # As the move's state is not computed over the move lines, we'll have to manually
             # recompute the moves which we adapted their lines.

--- a/addons/stock/models/stock_picking.py
+++ b/addons/stock/models/stock_picking.py
@@ -268,12 +268,12 @@ class Picking(models.Model):
         index=True, required=True,
         states={'done': [('readonly', True)], 'cancel': [('readonly', True)]})
 
-    pack_operation_ids = fields.One2many(
-        'stock.pack.operation', 'picking_id', 'Operations',
+    move_line_ids = fields.One2many(
+        'stock.move.line', 'picking_id', 'Operations',
         states={'done': [('readonly', True)], 'cancel': [('readonly', True)]})
 
-    pack_operation_exist = fields.Boolean(
-        'Has Pack Operations', compute='_compute_pack_operation_exist',
+    move_line_exist = fields.Boolean(
+        'Has Pack Operations', compute='_compute_move_line_exist',
         help='Check the existence of pack operation on the picking')
 
     has_packages = fields.Boolean(
@@ -370,13 +370,13 @@ class Picking(models.Model):
         self.has_scrap_move = bool(self.env['stock.move'].search_count([('picking_id', '=', self.id), ('scrapped', '=', True)]))
 
     @api.one
-    def _compute_pack_operation_exist(self):
-        self.pack_operation_exist = bool(self.pack_operation_ids)
+    def _compute_move_line_exist(self):
+        self.move_line_exist = bool(self.move_line_ids)
 
     @api.one
     def _compute_has_packages(self):
         has_packages = False
-        for pack_op in self.pack_operation_ids:
+        for pack_op in self.move_line_ids:
             if pack_op.result_package_id:
                 has_packages = True
                 break
@@ -458,7 +458,7 @@ class Picking(models.Model):
 
     @api.one
     def action_assign_owner(self):
-        self.pack_operation_ids.write({'owner_id': self.owner_id.id})
+        self.move_line_ids.write({'owner_id': self.owner_id.id})
 
     @api.multi
     def do_print_picking(self):
@@ -518,9 +518,9 @@ class Picking(models.Model):
         # Check if there are ops not linked to moves yet
         for pick in self:
             # # Explode manually added packages
-            # for ops in pick.pack_operation_ids.filtered(lambda x: not x.move_id and not x.product_id):
+            # for ops in pick.move_line_ids.filtered(lambda x: not x.move_id and not x.product_id):
             #     for quant in ops.package_id.quant_ids: #Or use get_content for multiple levels
-            #         self.pack_operation_ids.create({'product_id': quant.product_id.id,
+            #         self.move_line_ids.create({'product_id': quant.product_id.id,
             #                                    'package_id': quant.package_id.id,
             #                                    'result_package_id': ops.result_package_id,
             #                                    'lot_id': quant.lot_id.id,
@@ -533,7 +533,7 @@ class Picking(models.Model):
             #                                    'picking_id': pick.id
             #                                    }) # Might change first element
             # # Link existing moves or add moves when no one is related
-            for ops in pick.pack_operation_ids.filtered(lambda x: not x.move_id):
+            for ops in pick.move_line_ids.filtered(lambda x: not x.move_id):
                 # Search move with this product
                 moves = pick.move_lines.filtered(lambda x: x.product_id == ops.product_id) 
                 if moves: #could search move that needs it the most (that has some quantities left)
@@ -561,10 +561,10 @@ class Picking(models.Model):
     def _check_entire_pack(self):
         """ This function check if entire packs are moved in the picking"""
         for picking in self:
-            origin_packages = picking.pack_operation_ids.mapped("package_id")
+            origin_packages = picking.move_line_ids.mapped("package_id")
             for pack in origin_packages:
                 all_in = True
-                packops = picking.pack_operation_ids.filtered(lambda x: x.package_id == pack)
+                packops = picking.move_line_ids.filtered(lambda x: x.package_id == pack)
                 keys = ['product_id', 'lot_id']
 
                 grouped_quants = {}
@@ -573,7 +573,7 @@ class Picking(models.Model):
 
                 grouped_ops = {}
                 for k, g in groupby(sorted(packops, key=itemgetter(*keys)), key=itemgetter(*keys)):
-                    grouped_ops[k] = sum(self.env['stock.pack.operation'].concat(*list(g)).mapped('product_qty'))
+                    grouped_ops[k] = sum(self.env['stock.move.line'].concat(*list(g)).mapped('product_qty'))
                 if any(grouped_quants[key] - grouped_ops.get(key, 0) != 0 for key in grouped_quants)\
                         or any(grouped_ops[key] - grouped_quants[key] != 0 for key in grouped_ops):
                     all_in = False
@@ -590,15 +590,15 @@ class Picking(models.Model):
     @api.multi
     def button_validate(self):
         self.ensure_one()
-        pack_operations_delete = self.env['stock.pack.operation']
-        if not self.move_lines and not self.pack_operation_ids:
+        move_line_delete = self.env['stock.move.line']
+        if not self.move_lines and not self.move_line_ids:
             raise UserError(_('Please add some lines to move'))
         # In draft or with no pack operations edited yet, ask if we can just do everything
-        if self.state == 'draft' or all([x.qty_done == 0.0 for x in self.pack_operation_ids]):
+        if self.state == 'draft' or all([x.qty_done == 0.0 for x in self.move_line_ids]):
             # If no lots when needed, raise error
             picking_type = self.picking_type_id
             if (picking_type.use_create_lots or picking_type.use_existing_lots):
-                for pack in self.pack_operation_ids:
+                for pack in self.move_line_ids:
                     if pack.product_id and pack.product_id.tracking != 'none':
                         raise UserError(_('Some products require lots/serial numbers, so you need to specify those first!'))
             view = self.env.ref('stock.view_immediate_transfer')
@@ -632,16 +632,16 @@ class Picking(models.Model):
                 'res_id': wiz.id,
                 'context': self.env.context,
             }
-        for operation in self.pack_operation_ids:
+        for operation in self.move_line_ids:
             if operation.qty_done < 0:
                 raise UserError(_('No negative quantities allowed'))
             if operation.qty_done > 0:
                 pass
                 #operation.write({'product_qty': operation.qty_done})
             else:
-                pack_operations_delete |= operation
-        if pack_operations_delete:
-            pack_operations_delete.unlink()
+                move_line_delete |= operation
+        if move_line_delete:
+            move_line_delete.unlink()
         self.action_done()
         return
 
@@ -656,11 +656,11 @@ class Picking(models.Model):
             quantity_done.setdefault(move.product_id.id, 0)
             quantity_todo[move.product_id.id] += move.product_qty
             quantity_done[move.product_id.id] += move.quantity_done #TODO: convert to base units
-        for ops in self.pack_operation_ids.filtered(lambda x: x.package_id and not x.product_id and not x.move_id):
+        for ops in self.move_line_ids.filtered(lambda x: x.package_id and not x.product_id and not x.move_id):
             for quant in ops.package_id.quant_ids:
                 quantity_done.setdefault(quant.product_id.id, 0)
                 quantity_done[quant.product_id.id] += quant.qty
-        for pack in self.pack_operation_ids.filtered(lambda x: x.product_id and not x.move_id):
+        for pack in self.move_line_ids.filtered(lambda x: x.product_id and not x.move_id):
             quantity_done.setdefault(pack.product_id.id, 0)
             quantity_done[pack.product_id.id] += pack.qty_done
         return any(quantity_done[x] < quantity_todo.get(x, 0) for x in quantity_done)
@@ -672,10 +672,10 @@ class Picking(models.Model):
         # TDE FIXME: move to batch
         self.ensure_one()
         moves = self.env['stock.move']
-        for pack_operation in self.pack_operation_ids:
-            for product, remaining_qty in pycompat.items(pack_operation._get_remaining_prod_quantities()):
+        for move_line in self.move_line_ids:
+            for product, remaining_qty in pycompat.items(move_line._get_remaining_prod_quantities()):
                 if float_compare(remaining_qty, 0, precision_rounding=product.uom_id.rounding) > 0:
-                    vals = self._prepare_values_extra_move(pack_operation, product, remaining_qty)
+                    vals = self._prepare_values_extra_move(move_line, product, remaining_qty)
                     moves |= moves.create(vals)
         if moves:
             moves.with_context(skip_check=True).action_confirm()
@@ -733,7 +733,7 @@ class Picking(models.Model):
             backorder_picking = picking.copy({
                 'name': '/',
                 'move_lines': [],
-                'pack_operation_ids': [],
+                'move_line_ids': [],
                 'backorder_id': picking.id
             })
             picking.message_post(body=_("Back order <em>%s</em> <b>created</b>.") % (backorder_picking.name))
@@ -749,8 +749,8 @@ class Picking(models.Model):
     def _put_in_pack(self):
         package = False
         for pick in self:
-            operations = pick.pack_operation_ids.filtered(lambda o: o.qty_done > 0 and not o.result_package_id)
-            operation_ids = self.env['stock.pack.operation']
+            operations = pick.move_line_ids.filtered(lambda o: o.qty_done > 0 and not o.result_package_id)
+            operation_ids = self.env['stock.move.line']
             if operations:
                 package = self.env['stock.quant.package'].create({})
                 for operation in operations:
@@ -779,7 +779,7 @@ class Picking(models.Model):
     def button_scrap(self):
         self.ensure_one()
         # only stockable products are scrapeable
-        scrapeable_products = self.pack_operation_ids.mapped('product_id').filtered(lambda p: p.type == 'product')
+        scrapeable_products = self.move_line_ids.mapped('product_id').filtered(lambda p: p.type == 'product')
         return {
             'name': _('Scrap'),
             'view_type': 'form',
@@ -803,7 +803,7 @@ class Picking(models.Model):
     def action_see_packages(self):
         self.ensure_one()
         action = self.env.ref('stock.action_package_view').read()[0]
-        packages = self.pack_operation_ids.mapped('result_package_id')
+        packages = self.move_line_ids.mapped('result_package_id')
         action['domain'] = [('id', 'in', packages.ids)]
         action['context'] = {'picking_id': self.id}
         return action

--- a/addons/stock/models/stock_production_lot.py
+++ b/addons/stock/models/stock_production_lot.py
@@ -32,7 +32,7 @@ class ProductionLot(models.Model):
     def create(self, vals):
         pack_id = self.env.context.get('active_pack_operation', False)
         if pack_id:
-            pack = self.env['stock.pack.operation'].browse(pack_id)
+            pack = self.env['stock.move.line'].browse(pack_id)
             if pack.picking_id and not pack.picking_id.picking_type_id.use_create_lots:
                 raise UserError(_("You are not allowed to create a lot for this picking type"))
         return super(ProductionLot, self).create(vals)

--- a/addons/stock/models/stock_quant.py
+++ b/addons/stock/models/stock_quant.py
@@ -245,8 +245,8 @@ class QuantPackage(models.Model):
     owner_id = fields.Many2one(
         'res.partner', 'Owner', compute='_compute_package_info', search='_search_owner',
         index=True, readonly=True)
-    move_line_ids = fields.One2many('stock.pack.operation', 'result_package_id')
-    current_picking_move_line_ids = fields.One2many('stock.pack.operation', compute="_compute_current_picking_info")
+    move_line_ids = fields.One2many('stock.move.line', 'result_package_id')
+    current_picking_move_line_ids = fields.One2many('stock.move.line', compute="_compute_current_picking_info")
     current_picking_id = fields.Boolean(compute="_compute_current_picking_info")
 
     @api.depends('quant_ids.package_id', 'quant_ids.location_id', 'quant_ids.company_id', 'quant_ids.owner_id')
@@ -331,7 +331,7 @@ class QuantPackage(models.Model):
 
     def action_view_picking(self):
         action = self.env.ref('stock.action_picking_tree_all').read()[0]
-        pickings = self.env['stock.pack.operation'].search([('result_package_id', 'in', self.ids)]).mapped('picking_id')
+        pickings = self.env['stock.move.line'].search([('result_package_id', 'in', self.ids)]).mapped('picking_id')
         action['domain'] = [('id', 'in', pickings.ids)]
         return action
 

--- a/addons/stock/models/stock_scrap.py
+++ b/addons/stock/models/stock_scrap.py
@@ -101,7 +101,7 @@ class StockScrap(models.Model):
             'location_id': self.location_id.id,
             'scrapped': True,
             'location_dest_id': self.scrap_location_id.id,
-            'pack_operation_ids': [(0, 0, {'product_id': self.product_id.id,
+            'move_line_ids': [(0, 0, {'product_id': self.product_id.id,
                                            'product_uom_id': self.product_uom_id.id, 
                                            'qty_done': self.scrap_qty,
                                            'location_id': self.location_id.id, 

--- a/addons/stock/models/stock_traceability.py
+++ b/addons/stock/models/stock_traceability.py
@@ -21,16 +21,16 @@ class MrpStockReport(models.TransientModel):
 
     @api.model
     def get_move_lines_upstream(self, move_lines):
-        res = self.env['stock.pack.operation']
+        res = self.env['stock.move.line']
         for move_line in move_lines:
             # if MTO
             if move_line.move_id.move_orig_ids:
-                res |= move_line.move_id.move_orig_ids.mapped('pack_operation_ids').filtered(
+                res |= move_line.move_id.move_orig_ids.mapped('move_line_ids').filtered(
                     lambda m: m.lot_id.id == move_line.lot_id.id)
             # if MTS
             else:
                 if move_line.location_id.usage == 'internal':
-                    res |= self.env['stock.pack.operation'].search([
+                    res |= self.env['stock.move.line'].search([
                         ('product_id', '=', move_line.product_id.id),
                         ('lot_id', '=', move_line.lot_id.id),
                         ('location_dest_id', '=', move_line.location_id.id),
@@ -42,16 +42,16 @@ class MrpStockReport(models.TransientModel):
 
     @api.model
     def get_move_lines_downstream(self, move_lines):
-        res = self.env['stock.pack.operation']
+        res = self.env['stock.move.line']
         for move_line in move_lines:
             # if MTO
             if move_line.move_id.move_dest_ids:
-                res |= move_line.move_id.move_dest_ids.mapped('pack_operation_ids').filtered(
+                res |= move_line.move_id.move_dest_ids.mapped('move_line_ids').filtered(
                     lambda m: m.lot_id.id == move_line.lot_id.id)
             # if MTS
             else:
                 if move_line.location_dest_id.usage == 'internal':
-                    res |= self.env['stock.pack.operation'].search([
+                    res |= self.env['stock.move.line'].search([
                         ('product_id', '=', move_line.product_id.id),
                         ('lot_id', '=', move_line.lot_id.id),
                         ('location_id', '=', move_line.location_dest_id.id),
@@ -77,12 +77,12 @@ class MrpStockReport(models.TransientModel):
         res = []
         if context.get('active_id') and not context.get('model') or context.get('model') == 'stock.production.lot':
             if stream == "downstream":
-                move_ids = self.env['stock.pack.operation'].search([
+                move_ids = self.env['stock.move.line'].search([
                     ('lot_id', '=', context.get('active_id')),
                     ('location_id.usage', '=', 'supplier'),
                     ('state', '=', 'done'),
                 ])
-                res += self._lines(line_id, model_id=model_id, model='stock.pack.operation', level=level, parent_quant=parent_quant,
+                res += self._lines(line_id, model_id=model_id, model='stock.move.line', level=level, parent_quant=parent_quant,
                                   stream=stream, obj_ids=move_ids)
                 quant_ids = self.env['stock.quant'].search([
                     ('lot_id', '=', context.get('active_id')),
@@ -91,12 +91,12 @@ class MrpStockReport(models.TransientModel):
                 res += self._lines(line_id, model_id=model_id, model='stock.quant', level=level,
                                    parent_quant=parent_quant, stream=stream, obj_ids=quant_ids)
             else:
-                move_ids = self.env['stock.pack.operation'].search([
+                move_ids = self.env['stock.move.line'].search([
                     ('lot_id', '=', context.get('active_id')),
                     ('location_dest_id.usage', '=', 'customer'),
                     ('state', '=', 'done'),
                 ])
-                res += self._lines(line_id, model_id=model_id, model='stock.pack.operation', level=level, parent_quant=parent_quant,
+                res += self._lines(line_id, model_id=model_id, model='stock.move.line', level=level, parent_quant=parent_quant,
                                   stream=stream, obj_ids=move_ids)
                 quant_ids = self.env['stock.quant'].search([
                     ('lot_id', '=', context.get('active_id')),
@@ -105,10 +105,10 @@ class MrpStockReport(models.TransientModel):
                 res += self._lines(line_id, model_id=model_id, model='stock.quant', level=level,
                                    parent_quant=parent_quant, stream=stream, obj_ids=quant_ids)
         elif context.get('active_id') and context.get('model') == 'stock.picking':
-            move_ids = self.env['stock.picking'].browse(context['active_id']).move_lines.mapped('pack_operation_ids').filtered(lambda m: m.lot_id and m.state == 'done')
-            res = self._lines(line_id, model_id=model_id, model='stock.pack.operation', level=level, parent_quant=parent_quant, stream=stream, obj_ids=move_ids)
-        elif context.get('active_id') and context.get('model') == 'stock.pack.operation':
-            move_line_ids = self.env['stock.pack.operation'].browse(context.get('active_id'))
+            move_ids = self.env['stock.picking'].browse(context['active_id']).move_lines.mapped('move_line_ids').filtered(lambda m: m.lot_id and m.state == 'done')
+            res = self._lines(line_id, model_id=model_id, model='stock.move.line', level=level, parent_quant=parent_quant, stream=stream, obj_ids=move_ids)
+        elif context.get('active_id') and context.get('model') == 'stock.move.line':
+            move_line_ids = self.env['stock.move.line'].browse(context.get('active_id'))
             res = self._lines(line_id, model_id=context.get('active_id'), model=context.get('model'), level=level, parent_quant=parent_quant, stream=stream, obj_ids=move_line_ids)
         else:
             res = self._lines(line_id,  model_id=model_id, model=model, level=level, parent_quant=parent_quant, stream=stream)
@@ -137,7 +137,7 @@ class MrpStockReport(models.TransientModel):
             'date': move_line.move_id.date,
             'parent_id': parent_id,
             'model_id': move_line.id,
-            'model':'stock.pack.operation',
+            'model':'stock.move.line',
             'product_id': move_line.product_id.display_name,
             'product_qty_uom': str(move_line.qty_done) + ' ' + move_line.product_id.uom_id.name,
             'location_source': move_line.location_id.name,
@@ -150,14 +150,14 @@ class MrpStockReport(models.TransientModel):
 
     def make_dict_head(self, level, parent_id, model=False, stream=False, move_line=False):
         data = []
-        if model == 'stock.pack.operation':
+        if model == 'stock.move.line':
             data = [{
                 'level': level,
                 'unfoldable': True,
                 'date': move_line.move_id.date,
                 'model_id': move_line.id,
                 'parent_id': parent_id,
-                'model': model or 'stock.pack.operation',
+                'model': model or 'stock.move.line',
                 'product_id': move_line.product_id.display_name+' ('+move_line.lot_id.name+')',
                 'product_qty_uom': str(move_line.qty_done) + ' ' + move_line.product_id.uom_id.name,
                 'location_source': move_line.location_id.name,
@@ -183,12 +183,12 @@ class MrpStockReport(models.TransientModel):
     def upstream_traceability(self, level, stream=False, line_id=False, model=False, model_id=False, parent_quant=False):
         model_obj = self.env[model].browse(model_id)
         final_vals =[]
-        if model == 'stock.pack.operation':
+        if model == 'stock.move.line':
             moves = self.get_move_lines_upstream(model_obj)
             for move in moves.sorted(key=lambda m: m.date, reverse=True):
                 final_vals += self.make_dict_move(level, stream=stream, parent_id=line_id, move_line=move)
         elif model == 'stock.quant':
-            moves = self.env['stock.pack.operation'].search([
+            moves = self.env['stock.move.line'].search([
                 ('location_dest_id', '=', model_obj.location_id.id),
                 ('lot_id', '=', model_obj.lot_id.id),
                 ('date', '<=', model_obj.write_date),
@@ -203,12 +203,12 @@ class MrpStockReport(models.TransientModel):
     def downstream_traceability(self, level, stream=False, line_id=False, model=False, model_id=False, parent_quant=False):
         model_obj = self.env[model].browse(model_id)
         final_vals = []
-        if model == 'stock.pack.operation':
+        if model == 'stock.move.line':
             moves = self.get_move_lines_downstream(model_obj)
             for move in moves.sorted(key=lambda r: r.date):
                 final_vals += self.make_dict_move(level, stream=stream, parent_id=line_id, move_line=move)
         elif model == 'stock.quant':
-            moves = self.env['stock.pack.operation'].search([
+            moves = self.env['stock.move.line'].search([
                 ('location_id', '=', model_obj.location_id.id),
                 ('lot_id', '=', model_obj.lot_id.id),
                 ('date', '>=', model_obj.write_date),
@@ -230,7 +230,7 @@ class MrpStockReport(models.TransientModel):
                 final_vals += self.upstream_traceability(level, stream='upstream', line_id=line_id, model=model, model_id=model_id, parent_quant=parent_quant)
         else:
             for move_line in obj_ids:
-                final_vals += self.make_dict_head(level, stream=stream, parent_id=line_id, model=model or 'stock.pack.operation', move_line=move_line)
+                final_vals += self.make_dict_head(level, stream=stream, parent_id=line_id, model=model or 'stock.move.line', move_line=move_line)
         for data in final_vals:
             lines.append({
                 'id': autoIncrement(),
@@ -263,7 +263,7 @@ class MrpStockReport(models.TransientModel):
             if line.get('unfoldable'):
                     final_vals += self.make_dict_head(line['level'], model=line['model_name'], parent_id=line['id'], move_line=model)
             else:
-                if line['model_name'] == 'stock.pack.operation':
+                if line['model_name'] == 'stock.move.line':
                     final_vals += self.make_dict_move(line['level'], parent_id=line['id'], move_line=model)
         for data in final_vals:
             lines.append({
