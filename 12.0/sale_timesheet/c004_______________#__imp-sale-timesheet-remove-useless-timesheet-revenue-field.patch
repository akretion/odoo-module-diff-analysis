PR: https://github.com/odoo/odoo/pull/

From: 9429a0683d30464748c70652a2551e26f359787d
From: jem-odoo
Date: 2018-08-02 14:12:39

Structural Changes: 1
Total Changes: 148

[IMP] sale_timesheet: remove useless timesheet_revenue field

The timesheet revenue is a field introduces for 11.0, as a field
computed on the fly (not a computed one). Its goal was to estimate
the theorical (and effective) revenue (amuont of money received when
selling the timesheet), depending of the invoice policy, the quantity
really invoiced, ...
Its computation is quite complex, and is not working perfectly as it
is difficult to determine how much is already invoiced in case of
selling time in ordered quantity.
Also, this field is not used anymore in the project overview, removing
it will reduce code size and complexity. Soon, the amount to invoice and
invoiced coming from the SO lines replaced the timesheet revenue.

This commit removes the field, and its related tests.

Task #1857652

================================= pseudo patch: =================================

--- a/addons/sale_timesheet/models/account.py
+++ b/addons/sale_timesheet/models/account.py
@@ -19,7 +19,6 @@ class AccountAnalyticLine(models.Model):
         ('non_billable', 'Non Billable'),
         ('non_billable_project', 'No task found')], string="Billable Type", compute='_compute_timesheet_invoice_type', store=True, readonly=True)
     timesheet_invoice_id = fields.Many2one('account.invoice', string="Invoice", readonly=True, copy=False, help="Invoice created from the timesheet")
-    timesheet_revenue = fields.Monetary("Revenue", default=0.0, readonly=True, copy=False)
 
     @api.multi
     @api.depends('so_line.product_id', 'project_id', 'task_id')
@@ -41,7 +40,7 @@ class AccountAnalyticLine(models.Model):
     def write(self, values):
         # prevent to update invoiced timesheets if one line is of type delivery
         if self.sudo().filtered(lambda aal: aal.so_line.product_id.invoice_policy == "delivery") and self.filtered(lambda timesheet: timesheet.timesheet_invoice_id):
-            if any([field_name in values for field_name in ['unit_amount', 'employee_id', 'task_id', 'timesheet_revenue', 'so_line', 'amount', 'date']]):
+            if any([field_name in values for field_name in ['unit_amount', 'employee_id', 'task_id', 'so_line', 'amount', 'date']]):
                 raise UserError(_('You can not modify already invoiced timesheets (linked to a Sales order items invoiced on Time and material).'))
         result = super(AccountAnalyticLine, self).write(values)
         return result
@@ -70,77 +69,4 @@ class AccountAnalyticLine(models.Model):
                 result[timesheet.id].update({
                     'product_uom_id': uom.id,
                 })
-        # (re)compute the theorical revenue
-        if any([field_name in values for field_name in ['so_line', 'unit_amount', 'account_id']]):
-            for timesheet in self:
-                values_to_write = timesheet._timesheet_compute_theorical_revenue_values()
-                if values_to_write:
-                    result[timesheet.id].update(values_to_write)
         return result
-
-    @api.multi
-    def _timesheet_compute_theorical_revenue_values(self):
-        """ This method set the theorical revenue on the current timesheet lines.
-
-            If invoice on delivered quantity:
-                timesheet hours * (SO Line Price) * (1- discount),
-            elif invoice on ordered quantities & create task:
-                min (
-                    timesheet hours * (SO Line unit price) * (1- discount),
-                    TOTAL SO - TOTAL INVOICED - sum(timesheet revenues with invoice_id=False)
-                )
-            else:
-                0
-
-            :return: a dictionary mapping each record id to its corresponding
-                dictionnary values to write (may be empty).
-        """
-        self.ensure_one()
-        timesheet = self
-
-        # find the timesheet UoM
-        timesheet_uom = timesheet.product_uom_id
-        if not timesheet_uom:  # fallback on default company timesheet UoM
-            timesheet_uom = self.env.user.company_id.project_time_mode_id
-
-        # default values
-        unit_amount = timesheet.unit_amount
-        so_line = timesheet.so_line
-        values = {
-            'timesheet_revenue': 0.0,
-        }
-        # set the revenue and billable type according to the product and the SO line
-        if timesheet.task_id and so_line.product_id.type == 'service':
-            # find the analytic account to convert revenue into its currency
-            analytic_account = timesheet.account_id
-            # convert the unit of mesure into hours
-            sale_price_hour = so_line.product_uom._compute_price(so_line.price_unit, timesheet_uom)
-            sale_price = so_line.currency_id._convert(
-                sale_price_hour, analytic_account.currency_id, so_line.company_id, fields.Date.today())  # amount from SO should be convert into analytic account currency
-
-            # calculate the revenue on the timesheet
-            if so_line.product_id.invoice_policy == 'delivery':
-                values['timesheet_revenue'] = analytic_account.currency_id.round(unit_amount * sale_price * (1-(so_line.discount/100)))
-            elif so_line.product_id.invoice_policy == 'order' and so_line.product_id.service_type == 'timesheet':
-                quantity_hour = unit_amount
-                if so_line.product_uom.category_id == timesheet_uom.category_id:
-                    quantity_hour = so_line.product_uom._compute_quantity(so_line.product_uom_qty, timesheet_uom)
-                # compute the total revenue the SO since we are in fixed price
-                total_revenue_so = analytic_account.currency_id.round(quantity_hour * sale_price * (1-(so_line.discount/100)))
-                # compute the total revenue already existing (without the current timesheet line)
-                domain = [('so_line', '=', so_line.id)]
-                if timesheet.ids:
-                    domain += [('id', 'not in', timesheet.ids)]
-                analytic_lines = timesheet.search(domain)
-                total_revenue_invoiced = sum(analytic_lines.mapped('timesheet_revenue'))
-                # compute (new) revenue of current timesheet line
-                values['timesheet_revenue'] = min(
-                    analytic_account.currency_id.round(unit_amount * so_line.currency_id._convert(
-                        so_line.price_unit, analytic_account.currency_id, so_line.company_id, fields.Date.today()) * (1-so_line.discount)),
-                    total_revenue_so - total_revenue_invoiced
-                )
-                # if the so line is already invoiced, and the delivered qty is still smaller than the ordered, then link the timesheet to the invoice
-                if so_line.invoice_status == 'invoiced':
-                    values['timesheet_invoice_id'] = so_line.invoice_lines and so_line.invoice_lines[0].invoice_id.id
-
-        return values

--- a/addons/sale_timesheet/models/account_invoice.py
+++ b/addons/sale_timesheet/models/account_invoice.py
@@ -48,10 +48,7 @@ class AccountInvoice(models.Model):
     @api.multi
     def invoice_validate(self):
         result = super(AccountInvoice, self).invoice_validate()
-        self._compute_timesheet_revenue()
-        return result
-
-    def _compute_timesheet_revenue(self):
+        # associate the invoice to the timesheet on validation
         for invoice in self:
             for invoice_line in invoice.invoice_line_ids.filtered(lambda line: line.product_id.type == 'service').sorted(key=lambda inv_line: (inv_line.invoice_id, inv_line.id)):
                 uninvoiced_timesheet_lines = self.env['account.analytic.line'].sudo().search([
@@ -60,68 +57,5 @@ class AccountInvoice(models.Model):
                     ('timesheet_invoice_id', '=', False),
                     ('timesheet_invoice_type', 'in', ['billable_time', 'billable_fixed'])
                 ])
-
-                # NOTE JEM : changing quantity (or unit price) of invoice line does not impact the revenue calculation. (FP specs)
-                if uninvoiced_timesheet_lines:
-                    # delivered : update revenue with the prorata of number of hours on the timesheet line
-                    if invoice_line.product_id.invoice_policy == 'delivery':
-                        invoiced_price_per_hour = invoice_line.currency_id.round(invoice_line.price_subtotal / float(sum(uninvoiced_timesheet_lines.mapped('unit_amount'))))
-                        # invoicing analytic lines of different currency
-                        total_revenue_per_currency = dict.fromkeys(uninvoiced_timesheet_lines.mapped('currency_id').ids, 0.0)
-                        for index, timesheet_line in enumerate(uninvoiced_timesheet_lines.sorted(key=lambda ts: (ts.date, ts.id))):
-                            if index+1 != len(uninvoiced_timesheet_lines):
-                                line_revenue = invoice_line.currency_id._convert(
-                                    invoiced_price_per_hour, timesheet_line.currency_id,
-                                    self.env.user.company_id, fields.Date.today()) * timesheet_line.unit_amount
-                                total_revenue_per_currency[timesheet_line.currency_id.id] += line_revenue
-                            else:  # last line: add the difference to avoid rounding problem
-                                total_revenue = sum([self.env['res.currency'].browse(currency_id)._convert(
-                                    amount, timesheet_line.currency_id,
-                                    self.env.user.company_id, fields.Date.today()
-                                ) for currency_id, amount in total_revenue_per_currency.items()])
-                                line_revenue = invoice_line.currency_id._convert(
-                                    invoice_line.price_subtotal, timesheet_line.currency_id,
-                                    self.env.user.company_id, fields.Date.today()
-                                ) - total_revenue
-                            timesheet_line.write({
-                                'timesheet_invoice_id': invoice.id,
-                                'timesheet_revenue': timesheet_line.currency_id.round(line_revenue),
-                            })
-
-                    # ordered : update revenue with the prorata of theorical revenue
-                    elif invoice_line.product_id.invoice_policy == 'order':
-                        zero_timesheet_revenue = uninvoiced_timesheet_lines.filtered(lambda line: line.timesheet_revenue == 0.0)
-                        no_zero_timesheet_revenue = uninvoiced_timesheet_lines.filtered(lambda line: line.timesheet_revenue != 0.0)
-
-                        # timesheet with zero theorical revenue keep the same revenue, but become invoiced (invoice_id set)
-                        zero_timesheet_revenue.write({'timesheet_invoice_id': invoice.id})
-
-                        # invoicing analytic lines of different currency
-                        total_revenue_per_currency = dict.fromkeys(no_zero_timesheet_revenue.mapped('currency_id').ids, 0.0)
-
-                        for index, timesheet_line in enumerate(no_zero_timesheet_revenue.sorted(key=lambda ts: (ts.date, ts.id))):
-                            if index+1 != len(no_zero_timesheet_revenue):
-                                price_subtotal_inv = invoice_line.currency_id._convert(
-                                    invoice_line.price_subtotal, timesheet_line.currency_id, self.env.user.company_id, fields.Date.today())
-                                price_subtotal_sol = timesheet_line.so_line.currency_id._convert(
-                                    timesheet_line.so_line.price_subtotal, timesheet_line.currency_id, self.env.user.company_id, fields.Date.today())
-                                if not float_is_zero(price_subtotal_sol, precision_rounding=timesheet_line.currency_id.rounding):
-                                    line_revenue = timesheet_line.timesheet_revenue * price_subtotal_inv / price_subtotal_sol
-                                    total_revenue_per_currency[timesheet_line.currency_id.id] += line_revenue
-                                else:
-                                    line_revenue = timesheet_line.timesheet_revenue
-                                    total_revenue_per_currency[timesheet_line.currency_id.id] += line_revenue
-                            else:  # last line: add the difference to avoid rounding problem
-                                last_price_subtotal_inv = invoice_line.currency_id._convert(
-                                    invoice_line.price_subtotal, timesheet_line.currency_id,
-                                    self.env.user.company_id, fields.Date.today())
-                                total_revenue = sum([self.env['res.currency'].browse(currency_id)._convert(
-                                    amount, timesheet_line.currency_id,
-                                    self.env.user.company_id, fields.Date.today()
-                                ) for currency_id, amount in total_revenue_per_currency.items()])
-                                line_revenue = last_price_subtotal_inv - total_revenue
-
-                            timesheet_line.write({
-                                'timesheet_invoice_id': invoice.id,
-                                'timesheet_revenue': timesheet_line.currency_id.round(line_revenue),
-                            })
+                uninvoiced_timesheet_lines.write({'timesheet_invoice_id': invoice.id})
+        return result
