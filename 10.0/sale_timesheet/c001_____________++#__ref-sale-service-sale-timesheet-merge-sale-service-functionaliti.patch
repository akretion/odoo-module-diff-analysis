PR: https://github.com/odoo/odoo/pull/

From: 234f88a6afe3f2f0dba62d9d01de48442477a428
From: Tanguy Charlier
Date: 2016-03-11 15:30:50

Structural Changes: 8
Total Changes: 175

[REF] sale_service,sale_timesheet: Merge sale_service functionalities into sale_timesheet.

    * Since the last timesheets refactoring, timesheet entries are always linked to a project, and sale_service had the same dependencies as sale_timesheet.
    * This commit simplifies the modules hierarchy by merging two modules that have a close functionality and that were both always installed after timesheets and sales.

================================= pseudo patch: =================================

--- a/addons/sale_timesheet/models/__init__.py
+++ b/addons/sale_timesheet/models/__init__.py
@@ -2,3 +2,4 @@
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
 import sale_timesheet
+import sale_service

--- a/None
+++ b/addons/sale_timesheet/models/sale_service.py
@@ -0,0 +1,123 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from openerp import api, models
+from openerp.osv import fields, osv
+from openerp.exceptions import UserError
+from openerp.tools.translate import _
+
+
+class procurement_order(osv.osv):
+    _name = "procurement.order"
+    _inherit = "procurement.order"
+    _columns = {
+        'task_id': fields.many2one('project.task', 'Task', copy=False),
+    }
+
+    def _is_procurement_task(self, cr, uid, procurement, context=None):
+        return procurement.product_id.type == 'service' and procurement.product_id.track_service=='task' or False
+
+    def _assign(self, cr, uid, procurement, context=None):
+        res = super(procurement_order, self)._assign(cr, uid, procurement, context=context)
+        if not res:
+            #if there isn't any specific procurement.rule defined for the product, we may want to create a task
+            return self._is_procurement_task(cr, uid, procurement, context=context)
+        return res
+
+    def _run(self, cr, uid, procurement, context=None):
+        if self._is_procurement_task(cr, uid, procurement, context=context) and not procurement.task_id:
+            #create a task for the procurement
+            return self._create_service_task(cr, uid, procurement, context=context)
+        return super(procurement_order, self)._run(cr, uid, procurement, context=context)
+
+    def _convert_qty_company_hours(self, cr, uid, procurement, context=None):
+        product_uom = self.pool.get('product.uom')
+        company_time_uom_id = self.pool.get('res.users').browse(cr, uid, uid).company_id.project_time_mode_id
+        if procurement.product_uom.id != company_time_uom_id.id and procurement.product_uom.category_id.id == company_time_uom_id.category_id.id:
+            planned_hours = product_uom._compute_qty(cr, uid, procurement.product_uom.id, procurement.product_qty, company_time_uom_id.id)
+        else:
+            planned_hours = procurement.product_qty
+        return planned_hours
+
+    def _get_project(self, cr, uid, procurement, context=None):
+        project_project = self.pool.get('project.project')
+        project = procurement.product_id.project_id
+        if not project and procurement.sale_line_id:
+            # find the project corresponding to the analytic account of the sales order
+            account = procurement.sale_line_id.order_id.project_id
+            if not account:
+                procurement.sale_line_id.order_id._create_analytic_account()
+                account = procurement.sale_line_id.order_id.project_id
+            project_ids = project_project.search(cr, uid, [('analytic_account_id', '=', account.id)])
+            projects = project_project.browse(cr, uid, project_ids, context=context)
+            project = projects and projects[0]
+            if not project:
+                project_id = account.project_create({'name': account.name, 'use_tasks': True})
+                project = project_project.browse(cr, uid, project_id, context=context)
+        return project
+
+    def _create_service_task(self, cr, uid, procurement, context=None):
+        project_task = self.pool.get('project.task')
+        project = self._get_project(cr, uid, procurement, context=context)
+        planned_hours = self._convert_qty_company_hours(cr, uid, procurement, context=context)
+        task_id = project_task.create(cr, uid, {
+            'name': '%s:%s' % (procurement.origin or '', procurement.product_id.name),
+            'date_deadline': procurement.date_planned,
+            'planned_hours': planned_hours,
+            'remaining_hours': planned_hours,
+            'partner_id': procurement.sale_line_id and procurement.sale_line_id.order_id.partner_id.id or procurement.partner_dest_id.id,
+            'user_id': procurement.product_id.product_manager.id,
+            'procurement_id': procurement.id,
+            'description': procurement.name + '\n',
+            'project_id': project and project.id or False,
+            'company_id': procurement.company_id.id,
+        },context=context)
+        self.write(cr, uid, [procurement.id], {'task_id': task_id}, context=context)
+        self.project_task_create_note(cr, uid, [procurement.id], context=context)
+        return task_id
+
+    def project_task_create_note(self, cr, uid, ids, context=None):
+        for procurement in self.browse(cr, uid, ids, context=context):
+            body = _("Task created")
+            self.message_post(cr, uid, [procurement.id], body=body, context=context)
+            if procurement.sale_line_id and procurement.sale_line_id.order_id:
+                procurement.sale_line_id.order_id.message_post(body=body)
+
+
+class project_task(osv.osv):
+    _name = "project.task"
+    _inherit = "project.task"
+    _columns = {
+        'procurement_id': fields.many2one('procurement.order', 'Procurement', ondelete='set null'),
+        'sale_line_id': fields.related('procurement_id', 'sale_line_id', type='many2one', relation='sale.order.line', store=True, string='Sales Order Line'),
+    }
+
+    def unlink(self, cr, uid, ids, context=None):
+        if context is None:
+            context = {}
+        for task in self.browse(cr, uid, ids, context=context):
+            if task.sale_line_id:
+                raise UserError(_('You cannot delete a task related to a Sale Order. You can only archive this task.'))
+        res = super(project_task, self).unlink(cr, uid, ids, context)
+        return res
+
+    def action_view_so(self, cr, uid, ids, context=None):
+        task = self.browse(cr, uid, ids, context=context)[0]
+        return {
+            "type": "ir.actions.act_window",
+            "res_model": "sale.order",
+            "views": [[False, "form"]],
+            "res_id": task.sale_line_id.order_id.id,
+            "context": {"create": False, "show_sale": True},
+        }
+
+
+class ProductProduct(models.Model):
+    _inherit = 'product.product'
+
+    @api.multi
+    def _need_procurement(self):
+        for product in self:
+            if product.type == 'service' and product.track_service == 'task':
+                return True
+        return super(ProductProduct, self)._need_procurement()

--- a/addons/sale_timesheet/models/sale_timesheet.py
+++ b/addons/sale_timesheet/models/sale_timesheet.py
@@ -27,7 +27,9 @@ class HrEmployee(models.Model):
 
 class ProductTemplate(models.Model):
     _inherit = 'product.template'
-    track_service = fields.Selection(selection_add=[('timesheet', 'Timesheets on project')])
+    track_service = fields.Selection(selection_add=[('timesheet', 'Timesheets on project'), ('task', 'Create a task and track hours')])
+    project_id = fields.Many2one('project.project', string='Project', help='Create a task under this project on sale order validation.',
+                             ondelete='set null')
 
     @api.onchange('type', 'invoice_policy')
     def onchange_type_timesheet(self):
@@ -83,22 +85,34 @@ class AccountAnalyticLine(models.Model):
             )
         return result
 
+    @api.model
+    def _update_values(self, values):
+        if values.get('task_id', False):
+            task = self.env['project.task'].browse(values['task_id'])
+            values['so_line'] = task.sale_line_id and task.sale_line_id.id or values.get('so_line', False)
+
     @api.multi
     def write(self, values):
+        self._update_values(values)
         values = self._get_timesheet_cost(vals=values)
         return super(AccountAnalyticLine, self).write(values)
 
     @api.model
     def create(self, values):
+        self._update_values(values)
         values = self._get_timesheet_cost(vals=values)
         return super(AccountAnalyticLine, self).create(values)
 
+
 class SaleOrder(models.Model):
     _inherit = 'sale.order'
 
     timesheet_ids = fields.Many2many('account.analytic.line', compute='_compute_timesheet_ids', string='Timesheet activities associated to this sale')
     timesheet_count = fields.Float(string='Timesheet activities', compute='_compute_timesheet_ids')
 
+    tasks_ids = fields.Many2many('project.task', compute='_compute_tasks_ids', string='Tasks associated to this sale')
+    tasks_count = fields.Integer(string='Tasks', compute='_compute_tasks_ids')
+
     project_project_id = fields.Many2one('project.project', compute='_compute_project_project_id', string='Project associated to this sale')
 
     @api.multi
@@ -120,6 +134,39 @@ class SaleOrder(models.Model):
                     raise UserError(_("You can use only one product on timesheet within the same sale order. You should split your order to include only one contract based on time and material."))
         return {}
 
+    @api.multi
+    @api.depends('order_line.product_id.project_id')
+    def _compute_tasks_ids(self):
+        for order in self:
+            order.tasks_ids = self.env['project.task'].search([('sale_line_id', 'in', order.order_line.ids)])
+            order.tasks_count = len(order.tasks_ids)
+
+    @api.multi
+    def action_view_task(self):
+        self.ensure_one()
+        imd = self.env['ir.model.data']
+        action = imd.xmlid_to_object('project.action_view_task')
+        list_view_id = imd.xmlid_to_res_id('project.view_task_tree2')
+        form_view_id = imd.xmlid_to_res_id('project.view_task_form2')
+
+        result = {
+            'name': action.name,
+            'help': action.help,
+            'type': action.type,
+            'views': [[list_view_id, 'tree'], [False, 'kanban'], [form_view_id, 'form'], [False, 'graph'], [False, 'calendar'], [False, 'pivot'], [False, 'graph']],
+            'target': action.target,
+            'context': action.context,
+            'res_model': action.res_model,
+        }
+        if len(self.tasks_ids) > 1:
+            result['domain'] = "[('id','in',%s)]" % self.tasks_ids.ids
+        elif len(self.tasks_ids) == 1:
+            result['views'] = [(form_view_id, 'form')]
+            result['res_id'] = self.tasks_ids.id
+        else:
+            result = {'type': 'ir.actions.act_window_close'}
+        return result
+
     @api.multi
     @api.depends('project_id.project_ids')
     def _compute_project_project_id(self):
@@ -194,4 +241,4 @@ class SaleOrderLine(models.Model):
 
     @api.model
     def _get_analytic_track_service(self):
-        return super(SaleOrderLine, self)._get_analytic_track_service() + ['timesheet']
+        return super(SaleOrderLine, self)._get_analytic_track_service() + ['timesheet', 'task']
