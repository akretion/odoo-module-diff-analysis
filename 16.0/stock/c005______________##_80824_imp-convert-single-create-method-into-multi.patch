PR: https://github.com/odoo/odoo/pull/80824

From: 18952cdc76070f2a70789f2fa25e4fa0d546d470
From: Yannick Tivisse
Date: 2021-12-14 19:13:18

Structural Changes: 2
Total Changes: 254

[IMP] *: Convert single create method into multi

Taskid: 2703085
Part-of: odoo/odoo#80824
Co-authored-by: Victor Feyens <vfe@odoo.com>

================================= pseudo patch: =================================

--- a/addons/stock/models/res_company.py
+++ b/addons/stock/models/res_company.py
@@ -191,17 +191,18 @@ class Company(models.Model):
     def _create_per_company_rules(self):
         self.ensure_one()
 
-    @api.model
-    def create(self, vals):
-        company = super(Company, self).create(vals)
-        company.sudo()._create_per_company_locations()
-        company.sudo()._create_per_company_sequences()
-        company.sudo()._create_per_company_picking_types()
-        company.sudo()._create_per_company_rules()
-        self.env['stock.warehouse'].sudo().create({
+    @api.model_create_multi
+    def create(self, vals_list):
+        companies = super().create(vals_list)
+        for company in companies:
+            company.sudo()._create_per_company_locations()
+            company.sudo()._create_per_company_sequences()
+            company.sudo()._create_per_company_picking_types()
+            company.sudo()._create_per_company_rules()
+        self.env['stock.warehouse'].sudo().create([{
             'name': company.name,
             'code': self.env.context.get('default_code') or company.name[:5],
             'company_id': company.id,
             'partner_id': company.partner_id.id
-        })
-        return company
+        } for company in companies])
+        return companies

--- a/addons/stock/models/stock_package_level.py
+++ b/addons/stock/models/stock_package_level.py
@@ -139,13 +139,14 @@ class StockPackageLevel(models.Model):
                         'company_id': package_level.company_id.id,
                     })
 
-    @api.model
-    def create(self, vals):
-        result = super(StockPackageLevel, self).create(vals)
-        if vals.get('location_dest_id'):
-            result.mapped('move_line_ids').write({'location_dest_id': vals['location_dest_id']})
-            result.mapped('move_ids').write({'location_dest_id': vals['location_dest_id']})
-        return result
+    @api.model_create_multi
+    def create(self, vals_list):
+        package_levels = super().create(vals_list)
+        for package_level, vals in zip(package_levels, vals_list):
+            if vals.get('location_dest_id'):
+                package_level.move_line_ids.write({'location_dest_id': vals['location_dest_id']})
+                package_level.move_ids.write({'location_dest_id': vals['location_dest_id']})
+        return package_levels
 
     def write(self, vals):
         result = super(StockPackageLevel, self).write(vals)

--- a/addons/stock/models/stock_picking.py
+++ b/addons/stock/models/stock_picking.py
@@ -88,25 +88,24 @@ class PickingType(models.Model):
         'res.company', 'Company', required=True,
         default=lambda s: s.env.company.id, index=True)
 
-    @api.model
-    def create(self, vals):
-        if 'sequence_id' not in vals or not vals['sequence_id']:
-            if vals['warehouse_id']:
-                wh = self.env['stock.warehouse'].browse(vals['warehouse_id'])
-                vals['sequence_id'] = self.env['ir.sequence'].sudo().create({
-                    'name': wh.name + ' ' + _('Sequence') + ' ' + vals['sequence_code'],
-                    'prefix': wh.code + '/' + vals['sequence_code'] + '/', 'padding': 5,
-                    'company_id': wh.company_id.id,
-                }).id
-            else:
-                vals['sequence_id'] = self.env['ir.sequence'].sudo().create({
-                    'name': _('Sequence') + ' ' + vals['sequence_code'],
-                    'prefix': vals['sequence_code'], 'padding': 5,
-                    'company_id': vals.get('company_id') or self.env.company.id,
-                }).id
-
-        picking_type = super(PickingType, self).create(vals)
-        return picking_type
+    @api.model_create_multi
+    def create(self, vals_list):
+        for vals in vals_list:
+            if 'sequence_id' not in vals or not vals['sequence_id']:
+                if vals['warehouse_id']:
+                    wh = self.env['stock.warehouse'].browse(vals['warehouse_id'])
+                    vals['sequence_id'] = self.env['ir.sequence'].sudo().create({
+                        'name': wh.name + ' ' + _('Sequence') + ' ' + vals['sequence_code'],
+                        'prefix': wh.code + '/' + vals['sequence_code'] + '/', 'padding': 5,
+                        'company_id': wh.company_id.id,
+                    }).id
+                else:
+                    vals['sequence_id'] = self.env['ir.sequence'].sudo().create({
+                        'name': _('Sequence') + ' ' + vals['sequence_code'],
+                        'prefix': vals['sequence_code'], 'padding': 5,
+                        'company_id': vals.get('company_id') or self.env.company.id,
+                    }).id
+        return super().create(vals_list)
 
     def write(self, vals):
         if 'company_id' in vals:
@@ -724,32 +723,37 @@ class Picking(models.Model):
             "location_dest_id": self.location_dest_id
         })
 
-    @api.model
-    def create(self, vals):
-        defaults = self.default_get(['name', 'picking_type_id'])
-        picking_type = self.env['stock.picking.type'].browse(vals.get('picking_type_id', defaults.get('picking_type_id')))
-        if vals.get('name', '/') == '/' and defaults.get('name', '/') == '/' and vals.get('picking_type_id', defaults.get('picking_type_id')):
-            if picking_type.sequence_id:
-                vals['name'] = picking_type.sequence_id.next_by_id()
-
-        # make sure to write `schedule_date` *after* the `stock.move` creation in
-        # order to get a determinist execution of `_set_scheduled_date`
-        scheduled_date = vals.pop('scheduled_date', False)
-        res = super(Picking, self).create(vals)
-        if scheduled_date:
-            res.with_context(mail_notrack=True).write({'scheduled_date': scheduled_date})
-        res._autoconfirm_picking()
-
-        # set partner as follower
-        if vals.get('partner_id'):
-            for picking in res.filtered(lambda p: p.location_id.usage == 'supplier' or p.location_dest_id.usage == 'customer'):
-                picking.message_subscribe([vals.get('partner_id')])
-        if vals.get('picking_type_id'):
-            for move in res.move_ids:
-                if not move.description_picking:
-                    move.description_picking = move.product_id.with_context(lang=move._get_lang())._get_description(move.picking_id.picking_type_id)
-
-        return res
+    @api.model_create_multi
+    def create(self, vals_list):
+        scheduled_dates = []
+        for vals in vals_list:
+            defaults = self.default_get(['name', 'picking_type_id'])
+            picking_type = self.env['stock.picking.type'].browse(vals.get('picking_type_id', defaults.get('picking_type_id')))
+            if vals.get('name', '/') == '/' and defaults.get('name', '/') == '/' and vals.get('picking_type_id', defaults.get('picking_type_id')):
+                if picking_type.sequence_id:
+                    vals['name'] = picking_type.sequence_id.next_by_id()
+
+            # make sure to write `schedule_date` *after* the `stock.move` creation in
+            # order to get a determinist execution of `_set_scheduled_date`
+            scheduled_dates.append(vals.pop('scheduled_date', False))
+
+        pickings = super().create(vals_list)
+
+        for picking, scheduled_date in zip(pickings, scheduled_dates):
+            if scheduled_date:
+                picking.with_context(mail_notrack=True).write({'scheduled_date': scheduled_date})
+        pickings._autoconfirm_picking()
+
+        for picking, vals in zip(pickings, vals_list):
+            # set partner as follower
+            if vals.get('partner_id'):
+                if picking.location_id.usage == 'supplier' or picking.location_dest_id.usage == 'customer':
+                    picking.message_subscribe([vals.get('partner_id')])
+            if vals.get('picking_type_id'):
+                for move in picking.move_ids:
+                    if not move.description_picking:
+                        move.description_picking = move.product_id.with_context(lang=move._get_lang())._get_description(move.picking_id.picking_type_id)
+        return pickings
 
     def write(self, vals):
         if vals.get('picking_type_id') and any(picking.state != 'draft' for picking in self):

--- a/addons/stock/models/stock_quant.py
+++ b/addons/stock/models/stock_quant.py
@@ -170,40 +170,43 @@ class StockQuant(models.Model):
             domain_operator = 'in'
         return [('id', domain_operator, quant_query)]
 
-    @api.model
-    def create(self, vals):
+    @api.model_create_multi
+    def create(self, vals_list):
         """ Override to handle the "inventory mode" and create a quant as
         superuser the conditions are met.
         """
-        if self._is_inventory_mode() and any(f in vals for f in ['inventory_quantity', 'inventory_quantity_auto_apply']):
-            allowed_fields = self._get_inventory_fields_create()
-            if any(field for field in vals.keys() if field not in allowed_fields):
-                raise UserError(_("Quant's creation is restricted, you can't do this operation."))
-
-            inventory_quantity = vals.pop('inventory_quantity', False) or vals.pop(
-                'inventory_quantity_auto_apply', False) or 0
-            # Create an empty quant or write on a similar one.
-            product = self.env['product.product'].browse(vals['product_id'])
-            location = self.env['stock.location'].browse(vals['location_id'])
-            lot_id = self.env['stock.lot'].browse(vals.get('lot_id'))
-            package_id = self.env['stock.quant.package'].browse(vals.get('package_id'))
-            owner_id = self.env['res.partner'].browse(vals.get('owner_id'))
-            quant = self._gather(product, location, lot_id=lot_id, package_id=package_id, owner_id=owner_id, strict=True)
-
-            if quant:
-                quant = quant[0].sudo()
+        quants = self.env['stock.quant']
+        is_inventory_mode = self._is_inventory_mode()
+        allowed_fields = self._get_inventory_fields_create()
+        for vals in vals_list:
+            if is_inventory_mode and any(f in vals for f in ['inventory_quantity', 'inventory_quantity_auto_apply']):
+                if any(field for field in vals.keys() if field not in allowed_fields):
+                    raise UserError(_("Quant's creation is restricted, you can't do this operation."))
+                inventory_quantity = vals.pop('inventory_quantity', False) or vals.pop(
+                    'inventory_quantity_auto_apply', False) or 0
+                # Create an empty quant or write on a similar one.
+                product = self.env['product.product'].browse(vals['product_id'])
+                location = self.env['stock.location'].browse(vals['location_id'])
+                lot_id = self.env['stock.lot'].browse(vals.get('lot_id'))
+                package_id = self.env['stock.quant.package'].browse(vals.get('package_id'))
+                owner_id = self.env['res.partner'].browse(vals.get('owner_id'))
+                quant = self._gather(product, location, lot_id=lot_id, package_id=package_id, owner_id=owner_id, strict=True)
+
+                if quant:
+                    quant = quant[0].sudo()
+                else:
+                    quant = self.sudo().create(vals)
+                # Set the `inventory_quantity` field to create the necessary move.
+                quant.inventory_quantity = inventory_quantity
+                quant.user_id = vals.get('user_id', self.env.user.id)
+                quant.inventory_date = fields.Date.today()
+                quants |= quant
             else:
-                quant = self.sudo().create(vals)
-            # Set the `inventory_quantity` field to create the necessary move.
-            quant.inventory_quantity = inventory_quantity
-            quant.user_id = vals.get('user_id', self.env.user.id)
-            quant.inventory_date = fields.Date.today()
-
-            return quant
-        res = super(StockQuant, self).create(vals)
-        if self._is_inventory_mode():
-            res._check_company()
-        return res
+                quant = super().create(vals)
+                quants |= quant
+                if self._is_inventory_mode():
+                    quant._check_company()
+        return quants
 
     def _load_records_create(self, values):
         """ Add default location if import file did not fill it"""

--- a/addons/stock/models/stock_warehouse.py
+++ b/addons/stock/models/stock_warehouse.py
@@ -106,44 +106,47 @@ class Warehouse(models.Model):
                 }
             }
 
-    @api.model
-    def create(self, vals):
-        # create view location for warehouse then create all locations
-        loc_vals = {'name': vals.get('code'), 'usage': 'view',
-                    'location_id': self.env.ref('stock.stock_location_locations').id}
-        if vals.get('company_id'):
-            loc_vals['company_id'] = vals.get('company_id')
-        vals['view_location_id'] = self.env['stock.location'].create(loc_vals).id
-        sub_locations = self._get_locations_values(vals)
-
-        for field_name, values in sub_locations.items():
-            values['location_id'] = vals['view_location_id']
+    @api.model_create_multi
+    def create(self, vals_list):
+        for vals in vals_list:
+            # create view location for warehouse then create all locations
+            loc_vals = {'name': vals.get('code'), 'usage': 'view',
+                        'location_id': self.env.ref('stock.stock_location_locations').id}
             if vals.get('company_id'):
-                values['company_id'] = vals.get('company_id')
-            vals[field_name] = self.env['stock.location'].with_context(active_test=False).create(values).id
+                loc_vals['company_id'] = vals.get('company_id')
+            vals['view_location_id'] = self.env['stock.location'].create(loc_vals).id
+            sub_locations = self._get_locations_values(vals)
+
+            for field_name, values in sub_locations.items():
+                values['location_id'] = vals['view_location_id']
+                if vals.get('company_id'):
+                    values['company_id'] = vals.get('company_id')
+                vals[field_name] = self.env['stock.location'].with_context(active_test=False).create(values).id
 
         # actually create WH
-        warehouse = super(Warehouse, self).create(vals)
-        # create sequences and operation types
-        new_vals = warehouse._create_or_update_sequences_and_picking_types()
-        warehouse.write(new_vals)  # TDE FIXME: use super ?
-        # create routes and push/stock rules
-        route_vals = warehouse._create_or_update_route()
-        warehouse.write(route_vals)
+        warehouses = super().create(vals_list)
 
-        # Update global route with specific warehouse rule.
-        warehouse._create_or_update_global_routes_rules()
+        for warehouse, vals in zip(warehouses, vals_list):
+            # create sequences and operation types
+            new_vals = warehouse._create_or_update_sequences_and_picking_types()
+            warehouse.write(new_vals)  # TDE FIXME: use super ?
+            # create routes and push/stock rules
+            route_vals = warehouse._create_or_update_route()
+            warehouse.write(route_vals)
 
-        # create route selectable on the product to resupply the warehouse from another one
-        warehouse.create_resupply_routes(warehouse.resupply_wh_ids)
+            # Update global route with specific warehouse rule.
+            warehouse._create_or_update_global_routes_rules()
 
-        # update partner data if partner assigned
-        if vals.get('partner_id'):
-            self._update_partner_data(vals['partner_id'], vals.get('company_id'))
+            # create route selectable on the product to resupply the warehouse from another one
+            warehouse.create_resupply_routes(warehouse.resupply_wh_ids)
+
+            # update partner data if partner assigned
+            if vals.get('partner_id'):
+                self._update_partner_data(vals['partner_id'], vals.get('company_id'))
 
         self._check_multiwarehouse_group()
 
-        return warehouse
+        return warehouses
 
     def write(self, vals):
         if 'company_id' in vals:
