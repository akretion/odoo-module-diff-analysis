PR: https://github.com/odoo/odoo/pull/151469

From: 9719a148cb6e7fd9fe307fa19bd587e50b94fb99
From: aliya
Date: 2024-01-27 04:15:58

Structural Changes: 1
Total Changes: 83

[FIX] account_peppol: improve verification, handle existing participants

- Currently, once the SMS code has been created, it's valid forever,
which is not very secure. Verification codes should expire after some time
and users should have an opportunity to request a new one after
some time elapses instead of having to cancel the registration and retry.
- We've had several cases where users tried to register while having
an active registration somewhere else. In that case, we cannot register them
and we have to reach out to the user asking to deregister from the other service.
It is better to catch that instantly.

task-3677877

closes odoo/odoo#151469

X-original-commit: 61bfa935e15064bc3b5326e1c67e556f17ed185f
Signed-off-by: Laurent Smet (las) <las@odoo.com>
Signed-off-by: Aliya Tastemirova (alta) <alta@odoo.com>

================================= pseudo patch: =================================

--- a/addons/account_peppol/models/account_move.py
+++ b/addons/account_peppol/models/account_move.py
@@ -38,6 +38,19 @@ class AccountMove(models.Model):
             self.env.registry.clear_cache()
         return res
 
+    def _need_ubl_cii_xml(self):
+        self.ensure_one()
+
+        res = super()._need_ubl_cii_xml()
+        partner = self.partner_id
+        if partner.ubl_cii_format in {False, 'facturx', 'oioubl_201'}:
+            return res
+        if not partner.peppol_eas or not partner.peppol_endpoint:
+            return False
+        if partner.account_peppol_verification_label == 'not_verified':
+            partner.button_account_peppol_check_partner_endpoint()
+        return res and partner.account_peppol_is_endpoint_valid
+
     def action_cancel_peppol_documents(self):
         # if the peppol_move_state is processing/done
         # then it means it has been already sent to peppol proxy and we can't cancel

--- a/addons/account_peppol/models/res_config_settings.py
+++ b/addons/account_peppol/models/res_config_settings.py
@@ -55,6 +55,12 @@ class ResConfigSettings(models.TransientModel):
     # -------------------------------------------------------------------------
 
     def _call_peppol_proxy(self, endpoint, params=None, edi_user=None):
+        errors = {
+            'code_incorrect': _('The verification code is not correct'),
+            'code_expired': _('This verification code has expired. Please request a new one.'),
+            'too_many_attempts': _('Too many attempts to request an SMS code. Please try again later.'),
+        }
+
         if not edi_user:
             edi_user = self.company_id.account_edi_proxy_client_ids.filtered(lambda u: u.proxy_type == 'peppol')
 
@@ -68,7 +74,9 @@ class ResConfigSettings(models.TransientModel):
             raise UserError(e.message)
 
         if 'error' in response:
-            raise UserError(response['error'].get('message') or response['error']['data']['message'])
+            error_code = response['error'].get('code')
+            error_message = response['error'].get('message') or response['error'].get('data', {}).get('message')
+            raise UserError(errors.get(error_code) or error_message or _('Connection error, please try again later.'))
         return response
 
     # -------------------------------------------------------------------------
@@ -137,6 +145,13 @@ class ResConfigSettings(models.TransientModel):
 
         company = self.company_id
         edi_proxy_client = self.env['account_edi_proxy_client.user']
+        edi_identification = edi_proxy_client._get_proxy_identification(company, 'peppol')
+        if company.partner_id._check_peppol_participant_exists(edi_identification) and not self.account_peppol_migration_key:
+            raise UserError(
+                _("A participant with these details has already been registered on the network. "
+                  "If you have previously registered to an alternative Peppol service, please deregister from that service, "
+                  "or request a migration key before trying again."))
+
         edi_user = edi_proxy_client.sudo()._register_proxy_user(company, 'peppol', self.account_peppol_edi_mode)
         self.account_peppol_proxy_state = 'not_verified'
 
@@ -227,6 +242,8 @@ class ResConfigSettings(models.TransientModel):
         )
         self.account_peppol_proxy_state = 'pending'
         self.account_peppol_verification_code = False
+        # in case they have already been activated on the IAP side
+        self.env.ref('account_peppol.ir_cron_peppol_get_participant_status')._trigger()
 
     def button_cancel_peppol_registration(self):
         """

--- a/addons/account_peppol/models/res_partner.py
+++ b/addons/account_peppol/models/res_partner.py
@@ -52,6 +52,32 @@ class ResPartner(models.Model):
             else:
                 partner.account_peppol_verification_label = 'not_valid'
 
+    @api.model
+    def _check_peppol_participant_exists(self, edi_identification):
+        hash_participant = md5(edi_identification.lower().encode()).hexdigest()
+        endpoint_participant = parse.quote_plus(f"iso6523-actorid-upis::{edi_identification}")
+        peppol_param = self.env['ir.config_parameter'].sudo().get_param('account_peppol.edi.mode', False)
+        sml_zone = 'acc.edelivery' if peppol_param == 'test' else 'edelivery'
+        smp_url = f"http://B-{hash_participant}.iso6523-actorid-upis.{sml_zone}.tech.ec.europa.eu/{endpoint_participant}"
+
+        try:
+            response = requests.get(smp_url, timeout=TIMEOUT)
+        except requests.exceptions.ConnectionError:
+            return False
+        if response.status_code != 200:
+            return False
+        participant_info = etree.XML(response.content)
+        participant_identifier = participant_info.findtext('{*}ParticipantIdentifier')
+        service_metadata = participant_info.find('.//{*}ServiceMetadataReference')
+        service_href = ''
+        if service_metadata is not None:
+            service_href = service_metadata.attrib.get('href', '')
+        if edi_identification != participant_identifier or 'hermes-belgium' in service_href:
+            # all Belgian companies are pre-registered on hermes-belgium, so they will
+            # technically have an existing SMP url but they are not real Peppol participants
+            return False
+        return True
+
     @handle_demo
     def button_account_peppol_check_partner_endpoint(self):
         """ A basic check for whether a participant is reachable at the given
@@ -64,26 +90,7 @@ class ResPartner(models.Model):
         """
         self.ensure_one()
 
-        participant = f'{self.peppol_eas}:{self.peppol_endpoint}'.lower()
-        hash_participant = md5(participant.lower().encode()).hexdigest()
-        endpoint_participant = parse.quote_plus(f"iso6523-actorid-upis::{participant}")
-        peppol_param = self.env['ir.config_parameter'].sudo().get_param('account_peppol.edi.mode', False)
-        sml_zone = 'acc.edelivery' if peppol_param == 'test' else 'edelivery'
-        smp_url = f"http://B-{hash_participant}.iso6523-actorid-upis.{sml_zone}.tech.ec.europa.eu/{endpoint_participant}"
+        edi_identification = f'{self.peppol_eas}:{self.peppol_endpoint}'.lower()
         self.account_peppol_validity_last_check = fields.Date.context_today(self)
-        try:
-            response = requests.get(smp_url, timeout=TIMEOUT)
-        except requests.exceptions.ConnectionError:
-            self.account_peppol_is_endpoint_valid = False
-        else:
-            if response.status_code != 200:
-                self.account_peppol_is_endpoint_valid = False
-                return
-
-            participant_info = etree.XML(response.content)
-            participant_identifier = participant_info.find('{*}ParticipantIdentifier').text
-            if participant != participant_identifier:
-                self.account_peppol_is_endpoint_valid = False
-                return
-
-            self.account_peppol_is_endpoint_valid = True
+        self.account_peppol_is_endpoint_valid = self._check_peppol_participant_exists(edi_identification)
+        return True
