PR: https://github.com/odoo/odoo/pull/151628

From: 7af878d1212e9b249eb9b2278769265ec7cbfa13
From: Florian Damhaut
Date: 2024-05-27 11:48:22

Structural Changes: 5
Total Changes: 821

[IMP] base: ir_cron failure mechanism

- Remove multiple calls and number of calls mechanism.
- Add failure detection and archive after 5 successive failures which span over
at least 7 days.
- Add cron progress notification mechanism:
 - Cron can now notify how much records have been processed and
   how much still need to be processed.
 - Cron timeout/exception will resume if progress has been made
 - Retrigger if progress has been made and some records still
   need to be processed.

This PR will also serve as the base to enforce new CRON guidelines:
- CRONs should receive an argument to indicate how many records they can
  process in one call.
- CRONs should log their progress using method _notify_progress()
  or storing a tuple `(done, remaining)` in the variable `action`.
- CRONs should avoid retriggering themselves.
- CRONs should have a non-default priority.

Task-id: 3687442
Part-of: odoo/odoo#151628

================================= pseudo patch: =================================

--- a/odoo/addons/base/models/ir_cron.py
+++ b/odoo/addons/base/models/ir_cron.py
@@ -17,6 +17,11 @@ _logger = logging.getLogger(__name__)
 
 BASE_VERSION = odoo.modules.get_manifest('base')['version']
 MAX_FAIL_TIME = timedelta(hours=5)  # chosen with a fair roll of the dice
+MAX_BATCH_PER_CRON_JOB = 10
+CONSECUTIVE_TIMEOUT_FOR_FAILURE = 3
+MIN_FAILURE_COUNT_BEFORE_DEACTIVATION = 5
+MIN_DELTA_BEFORE_DEACTIVATION = timedelta(days=7)
+# crons must satisfy both minimum thresholds before deactivation
 
 # custom function to call instead of default PostgreSQL's `pg_notify`
 ODOO_NOTIFY_FUNCTION = os.getenv('ODOO_NOTIFY_FUNCTION', 'pg_notify')
@@ -38,6 +43,12 @@ _intervalTypes = {
 }
 
 
+class CompletionStatus:  # inherit from enum.StrEnum in 3.11
+    FULLY_DONE = 'fully done'
+    PARTIALLY_DONE = 'partially done'
+    FAILED = 'failed'
+
+
 class ir_cron(models.Model):
     """ Model describing cron jobs (also called actions or tasks).
     """
@@ -67,6 +78,8 @@ class ir_cron(models.Model):
     nextcall = fields.Datetime(string='Next Execution Date', required=True, default=fields.Datetime.now, help="Next planned execution date for this job.")
     lastcall = fields.Datetime(string='Last Execution Date', help="Previous time the cron ran successfully, provided to the job through the context on the `lastcall` key")
     priority = fields.Integer(default=5, help='The priority of the job, as an integer: 0 means higher priority, 10 means lower priority.')
+    failure_count = fields.Integer(default=0, help="The number of consecutive failures of this job. It is automatically reset on success.")
+    first_failure_date = fields.Datetime(string='First Failure Date', help="The first time the cron failed. It is automatically reset on success.")
 
     _sql_constraints = [
         (
@@ -101,10 +114,11 @@ class ir_cron(models.Model):
         self.check_access_rights('write')
         self._try_lock()
         _logger.info('Manually starting job `%s`.', self.name)
-        self.with_user(self.user_id).with_context({'lastcall': self.lastcall}).ir_actions_server_id.run()
+        self, _ = self.with_user(self.user_id).with_context({'lastcall': self.lastcall})._add_progress()  # noqa: PLW0642
+        self.ir_actions_server_id.run()
+        self.lastcall = fields.Datetime.now()
         self.env.flush_all()
         _logger.info('Job `%s` done.', self.name)
-        self.lastcall = fields.Datetime.now()
         return True
 
     @classmethod
@@ -122,7 +136,7 @@ class ir_cron(models.Model):
 
                 for job_id in (job['id'] for job in jobs):
                     try:
-                        job = cls._acquire_one_job(cron_cr, (job_id,))
+                        job = cls._acquire_one_job(cron_cr, job_id)
                     except psycopg2.extensions.TransactionRollbackError:
                         cron_cr.rollback()
                         _logger.debug("job %s has been processed by another worker, skip", job_id)
@@ -202,7 +216,6 @@ class ir_cron(models.Model):
             SELECT *
             FROM ir_cron
             WHERE active = true
-              AND numbercall != 0
               AND (nextcall <= (now() at time zone 'UTC')
                 OR id in (
                     SELECT cron_id
@@ -210,48 +223,45 @@ class ir_cron(models.Model):
                     WHERE call_at <= (now() at time zone 'UTC')
                 )
               )
-            ORDER BY priority
+            ORDER BY failure_count, priority, id
         """)
         return cr.dictfetchall()
 
     @classmethod
-    def _acquire_one_job(cls, cr, job_ids):
+    def _acquire_one_job(cls, cr, job_id):
         """
-        Acquire for update one job that is ready from the job_ids tuple.
-
-        The jobs that have already been processed in this worker should
-        be excluded from the tuple.
-
-        This function raises a ``psycopg2.errors.SerializationFailure``
-        when the ``nextcall`` of one of the job_ids is modified in
-        another transaction. You should rollback the transaction and try
-        again later.
+        Acquire for update the job with id ``job_id``.
+
+        The job should not have been processed yet by the current
+        worker. Another worker may process the job again, may that job
+        become ready again quickly enough (e.g. self-triggering, high
+        frequency, or partially done jobs).
+
+        Note: It is possible that this function raises a
+              ``psycopg2.errors.SerializationFailure`` in case the job
+              has been processed in another worker. In such case it is
+              advised to roll back the transaction and to go on with the
+              other jobs.
         """
 
-        # We have to make sure ALL jobs are executed ONLY ONCE no matter
-        # how many cron workers may process them. The exlusion mechanism
-        # is twofold: (i) prevent parallel processing of the same job,
-        # and (ii) prevent re-processing jobs that have been processed
-        # already.
+        # The query must make sure that (i) two cron workers cannot
+        # process a given job at a same time. The query must also make
+        # sure that (ii) a job already processed in another worker
+        # should not be processed again by this one (or at least not
+        # before the job becomes ready again).
         #
-        # (i) is implemented via `LIMIT 1 FOR UPDATE SKIP LOCKED`, each
+        # (i) is implemented via `FOR NO KEY UPDATE SKIP LOCKED`, each
         # worker just acquire one available job at a time and lock it so
         # the other workers don't select it too.
         # (ii) is implemented via the `WHERE` statement, when a job has
-        # been processed, its nextcall is updated to a date in the
-        # future and the optional triggers are removed.
-        #
-        # Note about (ii): it is possible that a job becomes available
-        # again quickly (e.g. high frequency or self-triggering cron).
-        # This function doesn't prevent from acquiring that job multiple
-        # times at different moments. This can block a worker on
-        # executing a same job in loop. To prevent this problem, the
-        # callee is responsible of providing a `job_ids` tuple without
-        # the jobs it has executed already.
+        # been processed and is fully done, its nextcall is updated to a
+        # date in the future and the optional triggers are removed. In
+        # case a job has only been partially done, the job is left ready
+        # to be acquired again by another cron worker.
         #
         # An `UPDATE` lock type is the strongest row lock, it conflicts
         # with ALL other lock types. Among them the `KEY SHARE` row lock
-        # which is implicitely aquired by foreign keys to prevent the
+        # which is implicitly acquired by foreign keys to prevent the
         # referenced record from being removed while in use. Because we
         # never delete acquired cron jobs, foreign keys are safe to
         # concurrently reference cron jobs. Hence, the `NO KEY UPDATE`
@@ -261,10 +271,17 @@ class ir_cron(models.Model):
         # Learn more: https://www.postgresql.org/docs/current/explicit-locking.html#LOCKING-ROWS
 
         query = """
+            WITH last_cron_progress AS (
+                SELECT id as progress_id, cron_id, timed_out_counter, done, remaining
+                FROM ir_cron_progress
+                WHERE cron_id = %s
+                ORDER BY id DESC
+                LIMIT 1
+            )
             SELECT *
             FROM ir_cron
-            WHERE active = true
-              AND numbercall != 0
+            LEFT JOIN last_cron_progress lcp ON lcp.cron_id = ir_cron.id
+            WHERE ir_cron.active = true
               AND (nextcall <= (now() at time zone 'UTC')
                 OR EXISTS (
                     SELECT cron_id
@@ -273,12 +290,12 @@ class ir_cron(models.Model):
                       AND cron_id = ir_cron.id
                 )
               )
-              AND id in %s
+              AND id = %s
             ORDER BY priority
-            LIMIT 1 FOR NO KEY UPDATE SKIP LOCKED
+            FOR NO KEY UPDATE SKIP LOCKED
         """
         try:
-            cr.execute(query, [job_ids], log_exceptions=False)
+            cr.execute(query, [job_id, job_id], log_exceptions=False)
         except psycopg2.extensions.TransactionRollbackError:
             # A serialization error can occur when another cron worker
             # commits the new `nextcall` value of a cron it just ran and
@@ -288,91 +305,247 @@ class ir_cron(models.Model):
         except Exception as exc:
             _logger.error("bad query: %s\nERROR: %s", query, exc)
             raise
-        return cr.dictfetchone()
+
+        job = cr.dictfetchone()
+        for field_name in ('done', 'remaining', 'timed_out_counter'):
+            job[field_name] = job[field_name] or 0
+        return job
+
+    def _notify_admin(self, message):
+        """
+        Notify ``message`` to some administrator.
+
+        The base implementation of this method does nothing. It is
+        supposed to be overridden with some actual communication
+        mechanism.
+        """
+        _logger.warning(message)
 
     @classmethod
     def _process_job(cls, db, cron_cr, job):
-        """ Execute a cron job and re-schedule a call for later. """
+        """
+        Execute the cron's server action in a dedicated transaction.
 
-        # Compute how many calls were missed and at what time we should
-        # recall the cron next. In the example bellow, we fake a cron
-        # with an interval of 30 (starting at 0) that was last executed
-        # at 15 and that is executed again at 135.
-        #
-        #    0          60          120         180
-        #  --|-----|-----|-----|-----|-----|-----|----> time
-        #    1     2*    *     *     *  3  4
-        #
-        # 1: lastcall, the last time the cron was executed
-        # 2: past_nextcall, the cron nextcall as seen from lastcall
-        # *: missed_call, a total of 4 calls are missing
-        # 3: now
-        # 4: future_nextcall, the cron nextcall as seen from now
+        In case the previous process actually timed out, the cron's
+        server action is not executed and the cron is considered
+        ``'failed'``.
+
+        The server action can use the progress API via the method
+        :meth:`_notify_progress` to report processing progress, i.e. how
+        many records are done and how many records are remaining to
+        process.
+
+        Those progress notifications are used to determine the job's
+        ``CompletionStatus`` and to determine the next time the cron
+        will be executed:
+
+        - ``'fully done'``: the cron is rescheduled later, it'll be
+          executed again after its regular time interval or upon a new
+          trigger.
+
+        - ``'partially done'``: the cron is rescheduled ASAP, it'll be
+          executed again by this or another cron worker once the other
+          ready cron jobs have been executed.
+
+        - ``'failed'``: the cron is deactivated if it failed too many
+          times over a given time span; otherwise it is rescheduled
+          later.
+        """
+        env = api.Environment(cron_cr, job['user_id'], {})
+        ir_cron = env[cls._name]
+
+        failed_by_timeout = (
+            job['timed_out_counter'] >= CONSECUTIVE_TIMEOUT_FOR_FAILURE
+            and not job['done']
+        )
+
+        if not failed_by_timeout:
+            status = cls._run_job(job)
+        else:
+            status = CompletionStatus.FAILED
+            cron_cr.execute("""
+                UPDATE ir_cron_progress
+                SET timed_out_counter = 0
+                WHERE id = %s
+            """, (job['progress_id'],))
+            _logger.error("Job %r (%s) timed out", job['cron_name'], job['id'])
+
+        ir_cron._update_failure_count(job, status)
+
+        if status in (CompletionStatus.FULLY_DONE, CompletionStatus.FAILED):
+            ir_cron._reschedule_later(job)
+        elif status == CompletionStatus.PARTIALLY_DONE:
+            ir_cron._reschedule_asap(job)
+            if os.getenv('ODOO_NOTIFY_CRON_CHANGES'):
+                cron_cr.postcommit.add(ir_cron._notifydb)  # See: `_notifydb`
+        else:
+            raise RuntimeError("unreachable")
+
+        cron_cr.commit()
+
+    @classmethod
+    def _run_job(cls, job):
+        """
+        Execute the job's server action multiple times until it
+        completes. The completion status is returned.
+
+        It is considered completed when either:
+
+        - the server action doesn't use the progress API, or returned
+          and notified that all records has been processed: ``'fully done'``;
+
+        - the server action returned and notified that there are
+          remaining records to process, but this cron worker ran this
+          server action 10 times already: ``'partially done'``;
+
+        - the server action was able to commit and notify some work done,
+          but later crashed due to an exception: ``'partially done'``;
+
+        - the server action failed due to an exception and no progress
+          was notified: ``'failed'``.
+        """
+        timed_out_counter = job['timed_out_counter']
 
         with cls.pool.cursor() as job_cr:
-            lastcall = fields.Datetime.to_datetime(job['lastcall'])
-            interval = _intervalTypes[job['interval_type']](job['interval_number'])
-            env = api.Environment(job_cr, job['user_id'], {'lastcall': lastcall})
-            ir_cron = env[cls._name]
-
-            # Use the user's timezone to compare and compute datetimes,
-            # otherwise unexpected results may appear. For instance, adding
-            # 1 month in UTC to July 1st at midnight in GMT+2 gives July 30
-            # instead of August 1st!
-            now = fields.Datetime.context_timestamp(ir_cron, datetime.utcnow())
-            past_nextcall = fields.Datetime.context_timestamp(
-                ir_cron, fields.Datetime.to_datetime(job['nextcall']))
-
-            # Compute how many call were missed
-            missed_call = past_nextcall
-            missed_call_count = 0
-            while missed_call <= now:
-                missed_call += interval
-                missed_call_count += 1
-            future_nextcall = missed_call
-
-            # Compute how many time we should run the cron
-            effective_call_count = (
-                     1 if not missed_call_count                    # run at least once
-                else 1 if not job['doall']                         # run once for all
-                else missed_call_count if job['numbercall'] == -1  # run them all
-                else min(missed_call_count, job['numbercall'])     # run maximum numbercall times
-            )
-            call_count_left = max(job['numbercall'] - effective_call_count, -1)
+            env = api.Environment(job_cr, job['user_id'], {
+                'lastcall': job['lastcall'],
+                'cron_id': job['id'],
+            })
+            cron = env[cls._name].browse(job['id'])
+
+            status = None
+            for i in range(MAX_BATCH_PER_CRON_JOB):
+                cron, progress = cron._add_progress(timed_out_counter=timed_out_counter)
+                job_cr.commit()
+
+                try:
+                    cron._callback(job['cron_name'], job['ir_actions_server_id'])
+                except Exception:  # noqa: BLE001
+                    if progress.done and progress.remaining:
+                        # we do not consider it a failure if some progress has
+                        # been committed
+                        status = CompletionStatus.PARTIALLY_DONE
+                    else:
+                        status = CompletionStatus.FAILED
+                else:
+                    if not progress.remaining:
+                        status = CompletionStatus.FULLY_DONE
+                    elif not progress.done:
+                        # assume the server action doesn't use the progress API
+                        # and that there is nothing left to process
+                        status = CompletionStatus.FULLY_DONE
+                    else:
+                        status = CompletionStatus.PARTIALLY_DONE
+                finally:
+                    progress.timed_out_counter = 0
+                    timed_out_counter = 0
+                    job_cr.commit()
+                _logger.info('Job `%s`: %s records processed and %s records remaining.',
+                             job['cron_name'], progress.done, progress.remaining)
+                if status in (CompletionStatus.FULLY_DONE, CompletionStatus.FAILED):
+                    break
+
+        return status
+
+    def _update_failure_count(self, job, status):
+        """
+        Update cron ``failure_count`` and ``first_failure_date`` given
+        the job's completion status. Deactivate the cron when BOTH the
+        counter reaches ``MIN_FAILURE_COUNT_BEFORE_DEACTIVATION`` AND
+        the time delta reaches ``MIN_DELTA_BEFORE_DEACTIVATION``.
+
+        On ``'fully done'`` and ``'partially done'``, the counter and
+        failure date are reset. ``active`` is always left unmodified.
+
+        On ``'failed'`` the counter is increased and the first failure
+        date is set if the counter was 0. In case both thresholds are
+        reached, ``active`` is set to ``False`` and both values are
+        reset.
+        """
+        now = fields.Datetime.context_timestamp(self, datetime.utcnow())
+
+        if status == CompletionStatus.FAILED:
+            failure_count = job['failure_count'] + 1
+            first_failure_date = job['first_failure_date'] or now
+            active = job['active']
+            if (
+                failure_count >= MIN_FAILURE_COUNT_BEFORE_DEACTIVATION
+                and fields.Datetime.context_timestamp(self, first_failure_date) + MIN_DELTA_BEFORE_DEACTIVATION < now
+            ):
+                failure_count = 0
+                first_failure_date = None
+                active = False
+                self._notify_admin(_(
+                    "Cron job %(name)s (%(id)s) has been deactivated after failing %(count)s times. "
+                    "More information can be found in the server logs around %(time)s.",
+                    name=repr(job['cron_name']),
+                    id=job['id'],
+                    count=MIN_FAILURE_COUNT_BEFORE_DEACTIVATION,
+                    time=datetime.replace(datetime.utcnow(), microsecond=0),
+                ))
+        else:
+            failure_count = 0
+            first_failure_date = None
+            active = job['active']
 
-            # The actual cron execution
-            for call in range(effective_call_count):
-                ir_cron._callback(job['cron_name'], job['ir_actions_server_id'], job['id'])
+        self.env.cr.execute("""
+            UPDATE ir_cron
+            SET failure_count = %s,
+                first_failure_date = %s,
+                active = %s
+            WHERE id = %s
+        """, [
+            failure_count,
+            first_failure_date,
+            active,
+            job['id'],
+        ])
 
-        # Update the cron with the information computed above
-        cron_cr.execute("""
+    def _reschedule_later(self, job):
+        """
+        Reschedule the job to be executed later, after its regular
+        interval or upon a trigger.
+        """
+        # Use the user's timezone to compare and compute datetimes, otherwise unexpected results may appear.
+        # For instance, adding 1 month in UTC to July 1st at midnight in GMT+2 gives July 30 instead of August 1st!
+        now = fields.Datetime.context_timestamp(self, datetime.utcnow())
+        nextcall = fields.Datetime.context_timestamp(self, job['nextcall'])
+        interval = _intervalTypes[job['interval_type']](job['interval_number'])
+        while nextcall <= now:
+            nextcall += interval
+
+        _logger.info('Job `%s` (%s): .',
+                     job['cron_name'], job['id'])
+        self.env.cr.execute("""
             UPDATE ir_cron
-            SET nextcall=%s,
-                numbercall=%s,
-                lastcall=%s,
-                active=%s
-            WHERE id=%s
+            SET nextcall = %s,
+                lastcall = %s
+            WHERE id = %s
         """, [
-            fields.Datetime.to_string(future_nextcall.astimezone(pytz.UTC)),
-            call_count_left,
+            fields.Datetime.to_string(nextcall.astimezone(pytz.UTC)),
             fields.Datetime.to_string(now.astimezone(pytz.UTC)),
-            job['active'] and bool(call_count_left),
             job['id'],
         ])
 
-        cron_cr.execute("""
+        self.env.cr.execute("""
             DELETE FROM ir_cron_trigger
             WHERE cron_id = %s
               AND call_at < (now() at time zone 'UTC')
         """, [job['id']])
 
-        cron_cr.commit()
+    def _reschedule_asap(self, job):
+        """
+        Reschedule the job to be executed ASAP, after the other cron
+        jobs had a chance to run.
+        """
+        # leave the existing nextcall and triggers, this leave the job "ready"
+        pass
 
-    @api.model
-    def _callback(self, cron_name, server_action_id, job_id):
+    def _callback(self, cron_name, server_action_id):
         """ Run the method associated to a given job. It takes care of logging
         and exception handling. Note that the user running the server action
         is the user calling this method. """
+        self.ensure_one()
         try:
             if self.pool != self.pool.check_signaling():
                 # the registry has changed, reload self in the new registry
@@ -390,18 +563,12 @@ class ir_cron(models.Model):
             if start_time and _logger.isEnabledFor(logging.DEBUG):
                 _logger.debug('%.3fs (cron %s, server action %d with uid %d)', end_time - start_time, cron_name, server_action_id, self.env.uid)
             self.pool.signal_changes()
-        except Exception as e:
+        except Exception:
             self.pool.reset_changes()
             _logger.exception("Call from cron %s for server action #%s failed in Job #%s",
                               cron_name, server_action_id, job_id)
-            self._handle_callback_exception(cron_name, server_action_id, job_id, e)
-
-    @api.model
-    def _handle_callback_exception(self, cron_name, server_action_id, job_id, job_exception):
-        """ Method called when an exception is raised by a job.
-
-        Simply logs the exception and rollback the transaction. """
-        self._cr.rollback()
+            self.env.cr.rollback()
+            raise
 
     def _try_lock(self, lockfk=False):
         """Try to grab a dummy exclusive write-lock to the rows with the given ids,
@@ -409,7 +576,7 @@ class ir_cron(models.Model):
            to a process currently executing those cron tasks.
 
            :param lockfk: acquire a strong row lock which conflicts with
-                          the lock aquired by foreign keys when they
+                          the lock acquired by foreign keys when they
                           reference this row.
         """
         if not self:
@@ -468,17 +635,18 @@ class ir_cron(models.Model):
         Schedule a cron job to be executed soon independently of its
         ``nextcall`` field value.
 
-        By default the cron is scheduled to be executed in the next batch but
-        the optional `at` argument may be given to delay the execution later
-        with a precision down to 1 minute.
+        By default, the cron is scheduled to be executed the next time
+        the cron worker wakes up, but the optional `at` argument may be
+        given to delay the execution later, with a precision down to 1
+        minute.
 
-        The method may be called with a datetime or an iterable of datetime.
-        The actual implementation is in :meth:`~._trigger_list`, which is the
-        recommended method for overrides.
+        The method may be called with a datetime or an iterable of
+        datetime. The actual implementation is in :meth:`~._trigger_list`,
+        which is the recommended method for overrides.
 
         :param Optional[Union[datetime.datetime, list[datetime.datetime]]] at:
-            When to execute the cron, at one or several moments in time instead
-            of as soon as possible.
+            When to execute the cron, at one or several moments in time
+            instead of as soon as possible.
         :return: the created triggers records
         :rtype: recordset
         """
@@ -533,6 +701,42 @@ class ir_cron(models.Model):
             cr.execute(query, [self.env.cr.dbname])
         _logger.debug("cron workers notified")
 
+    def _add_progress(self, *, timed_out_counter=None):
+        """
+        Create a progress record for the given cron and add it to its
+        context.
+
+        :param int timed_out_counter: the number of times the cron has
+            consecutively timed out
+        :return: a pair ``(cron, progress)``, where the progress has
+            been injected inside the cron's context
+        """
+        progress = self.env['ir.cron.progress'].create([{
+            'cron_id': self.id,
+            'remaining': 0,
+            'done': 0,
+            # we use timed_out_counter + 1 so that if the current execution
+            # times out, the counter already takes it into account
+            'timed_out_counter': 0 if timed_out_counter is None else timed_out_counter + 1,
+        }])
+        return self.with_context(ir_cron_progress_id=progress.id), progress
+
+    def _notify_progress(self, *, done, remaining):
+        """
+        Log the progress of the cron job.
+
+        :param int done: the number of tasks already processed
+        :param int remaining: the number of tasks left to process
+        """
+        if not (progress_id := self.env.context.get('ir_cron_progress_id')):
+            return
+        if done < 0 or remaining < 0:
+            raise ValueError("`done` and `remaining` must be positive integers.")
+        self.env['ir.cron.progress'].browse(progress_id).write({
+            'remaining': remaining,
+            'done': done,
+        })
+
 
 class ir_cron_trigger(models.Model):
     _name = 'ir.cron.trigger'
@@ -546,3 +750,18 @@ class ir_cron_trigger(models.Model):
     @api.autovacuum
     def _gc_cron_triggers(self):
         self.search([('call_at', '<', datetime.now() + relativedelta(weeks=-1))]).unlink()
+
+
+class ir_cron_progress(models.Model):
+    _name = 'ir.cron.progress'
+    _description = 'Progress of Scheduled Actions'
+    _rec_name = 'cron_id'
+
+    cron_id = fields.Many2one("ir.cron", required=True, index=True)
+    remaining = fields.Integer(default=0)
+    done = fields.Integer(default=0)
+    timed_out_counter = fields.Integer(default=0)
+
+    @api.autovacuum
+    def _gc_cron_progress(self):
+        self.search([('create_date', '<', datetime.now() - relativedelta(weeks=1))]).unlink()

--- a/odoo/addons/base/security/ir.model.access.csv
+++ b/odoo/addons/base/security/ir.model.access.csv
@@ -3,6 +3,7 @@
 "access_ir_attachment_group_user","ir_attachment group_user","model_ir_attachment","group_user",1,1,1,1
 "access_ir_attachment_group_portal_public","ir_attachment group_portal_public","model_ir_attachment",,0,0,0,0
 "access_ir_cron_group_cron","ir_cron group_cron","model_ir_cron","group_system",1,1,1,1
+"access_ir_cron_progress_group_cron","ir_cron_progress group_cron","model_ir_cron_progress","group_system",1,1,1,1
 "access_ir_cron_trigger_group_cron","ir_cron_trigger group_cron","model_ir_cron_trigger","group_system",1,1,1,1
 "access_ir_exports_group_system","ir_exports group_system","model_ir_exports","base.group_allow_export",1,1,1,1
 "access_ir_exports_line_group_system","ir_exports_line group_system","model_ir_exports_line","base.group_user",1,1,1,1

--- a/odoo/addons/base/tests/test_ir_cron.py
+++ b/odoo/addons/base/tests/test_ir_cron.py
@@ -1,11 +1,14 @@
 # -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
+# ruff: noqa: E201, E272, E301, E306
+
 import collections
 import secrets
 import textwrap
 import threading
 from concurrent.futures import ThreadPoolExecutor
+from contextlib import closing
 from datetime import timedelta
 from unittest.mock import call, patch
 from freezegun import freeze_time
@@ -14,6 +17,7 @@ import odoo
 from odoo import api, fields
 from odoo.tests.common import BaseCase, TransactionCase, RecordCapturer, get_db_name, tagged
 from odoo.tools import mute_logger
+from odoo.addons.base.models.ir_cron import MIN_FAILURE_COUNT_BEFORE_DEACTIVATION, MIN_DELTA_BEFORE_DEACTIVATION
 
 
 class CronMixinCase:
@@ -51,8 +55,6 @@ class CronMixinCase:
             'active': True,
             'interval_number': 1,
             'interval_type': 'days',
-            'numbercall': -1,
-            'doall': False,
             'nextcall': fields.Datetime.now() + timedelta(hours=1),
             'lastcall': False,
             'priority': priority,
@@ -122,19 +124,7 @@ class TestIrCron(TransactionCase, CronMixinCase):
     def test_cron_unactive_never_ready(self):
         self.cron.active = False
         self.cron.nextcall = fields.Datetime.now()
-        self.cron._trigger()
-        self.cron.flush_recordset()
-        self.env['ir.cron.trigger'].flush_model()
-
-        ready_jobs = self.registry['ir.cron']._get_all_ready_jobs(self.cr)
-        self.assertNotIn(self.cron.id, [job['id'] for job in ready_jobs])
-
-    def test_cron_numbercall0_never_ready(self):
-        self.cron.numbercall = 0
-        self.cron.nextcall = fields.Datetime.now()
-        self.cron._trigger()
-        self.cron.flush_recordset()
-        self.env['ir.cron.trigger'].flush_model()
+        self.env.flush_all()
 
         ready_jobs = self.registry['ir.cron']._get_all_ready_jobs(self.cr)
         self.assertNotIn(self.cron.id, [job['id'] for job in ready_jobs])
@@ -205,61 +195,332 @@ class TestIrCron(TransactionCase, CronMixinCase):
         self.assertTrue(capture.records, "trigger should has been kept")
 
     def test_cron_process_job(self):
-
-        Setup = collections.namedtuple('Setup', ['doall', 'numbercall', 'missedcall', 'trigger'])
-        Expect = collections.namedtuple('Expect', ['call_count', 'call_left', 'active'])
-
-        matrix = [
-            (Setup(doall=False, numbercall=-1, missedcall=2, trigger=False),
-             Expect(call_count=1, call_left=-1, active=True)),
-            (Setup(doall=True, numbercall=-1, missedcall=2, trigger=False),
-             Expect(call_count=2, call_left=-1, active=True)),
-            (Setup(doall=False, numbercall=3, missedcall=2, trigger=False),
-             Expect(call_count=1, call_left=2, active=True)),
-            (Setup(doall=True, numbercall=3, missedcall=2, trigger=False),
-             Expect(call_count=2, call_left=1, active=True)),
-            (Setup(doall=True, numbercall=3, missedcall=4, trigger=False),
-             Expect(call_count=3, call_left=0, active=False)),
-            (Setup(doall=True, numbercall=3, missedcall=0, trigger=True),
-             Expect(call_count=1, call_left=2, active=True)),
+        Progress = self.env['ir.cron.progress']
+        default_progress_values = {'done': 0, 'remaining': 0, 'timed_out_counter': 0}
+        ten_days_ago = fields.Datetime.now() - MIN_DELTA_BEFORE_DEACTIVATION - timedelta(days=2)
+        almost_failed = MIN_FAILURE_COUNT_BEFORE_DEACTIVATION - 1
+
+        def nothing(cron):
+            state = {'call_count': 0}
+            def f(self):
+                state['call_count'] += 1
+            return f, state
+
+        def eleven_success(cron):
+            state = {'call_count': 0}
+            CALL_TARGET = 11
+            def f(self):
+                state['call_count'] += 1
+                self.env['ir.cron']._notify_progress(
+                    done=1,
+                    remaining=CALL_TARGET - state['call_count']
+                )
+            return f, state
+
+        def five_success(cron):
+            state = {'call_count': 0}
+            CALL_TARGET = 5
+            def f(self):
+                state['call_count'] += 1
+                self.env['ir.cron']._notify_progress(
+                    done=1,
+                    remaining=CALL_TARGET - state['call_count']
+                )
+            return f, state
+
+        def failure(cron):
+            state = {'call_count': 0}
+            def f(self):
+                state['call_count'] += 1
+                raise ValueError
+            return f, state
+
+        def failure_partial(cron):
+            state = {'call_count': 0}
+            CALL_TARGET = 5
+            def f(self):
+                state['call_count'] += 1
+                self.env['ir.cron']._notify_progress(
+                    done=1,
+                    remaining=CALL_TARGET - state['call_count']
+                )
+                self.env.cr.commit()
+                raise ValueError
+            return f, state
+
+        def failure_fully(cron):
+            state = {'call_count': 0}
+            def f(self):
+                state['call_count'] += 1
+                self.env['ir.cron']._notify_progress(done=1, remaining=0)
+                self.env.cr.commit()
+                raise ValueError
+            return f, state
+
+        CASES = [
+            #                 IN          |                 OUT
+            #       callback, curr_failures, trigger, call_count, done_count, fail_count, active,
+            (        nothing,             0,   False,          1,          0,          0,  True),
+            (        nothing, almost_failed,   False,          1,          0,          0,  True),
+            ( eleven_success,             0,    True,         10,         10,          0,  True),
+            ( eleven_success, almost_failed,    True,         10,         10,          0,  True),
+            (   five_success,             0,   False,          5,          5,          0,  True),
+            (   five_success, almost_failed,   False,          5,          5,          0,  True),
+            (        failure,             0,   False,          1,          0,          1,  True),
+            (        failure, almost_failed,   False,          1,          0,          0, False),
+            (failure_partial,             0,   False,          5,          5,          1,  True),
+            (failure_partial, almost_failed,   False,          5,          5,          0, False),
+            (  failure_fully,             0,   False,          1,          1,          1,  True),
+            (  failure_fully, almost_failed,   False,          1,          1,          0, False),
         ]
 
-        for setup, expect in matrix:
-            with self.subTest(setup=setup, expect=expect):
+        for cb, curr_failures, trigger, call_count, done_count, fail_count, active in CASES:
+            with self.subTest(cb=cb, failure=curr_failures), closing(self.cr.savepoint()):
                 self.cron.write({
                     'active': True,
-                    'doall': setup.doall,
-                    'numbercall': setup.numbercall,
-                    'nextcall': fields.Datetime.now() - timedelta(days=setup.missedcall - 1),
+                    'failure_count': curr_failures,
+                    'first_failure_date': ten_days_ago if curr_failures else None
                 })
                 with self.capture_triggers(self.cron.id) as capture:
-                    if setup.trigger:
+                    if trigger:
                         self.cron._trigger()
 
-                self.cron.flush_recordset()
-                capture.records.flush_recordset()
+                self.env.flush_all()
                 self.registry.enter_test_mode(self.cr)
+                cb, state = cb(self.cron)
                 try:
-                    with patch.object(self.registry['ir.cron'], '_callback') as callback:
+                    with mute_logger('odoo.addons.base.models.ir_cron'),\
+                            patch.object(self.registry['ir.actions.server'], 'run', cb):
                         self.registry['ir.cron']._process_job(
                             self.registry.db_name,
                             self.registry.cursor(),
-                            self.cron.read(load=None)[0]
+                            {**self.cron.read(load=None)[0], **default_progress_values}
                         )
                 finally:
                     self.registry.leave_test_mode()
                 self.cron.invalidate_recordset()
                 capture.records.invalidate_recordset()
 
-                self.assertEqual(callback.call_count, expect.call_count)
-                self.assertEqual(self.cron.numbercall, expect.call_left)
-                self.assertEqual(self.cron.active, expect.active)
-                self.assertEqual(self.cron.lastcall, fields.Datetime.now())
-                self.assertEqual(self.cron.nextcall, fields.Datetime.now() + timedelta(days=1))
-                self.assertEqual(self.env['ir.cron.trigger'].search_count([
-                    ('cron_id', '=', self.cron.id),
-                    ('call_at', '<=', fields.Datetime.now())]
-                ), 0)
+                self.assertEqual(self.cron.id in [job['id'] for job in self.cron._get_all_ready_jobs(self.env.cr)], trigger)
+                self.assertEqual(state['call_count'], call_count)
+                self.assertEqual(Progress.search_count([('cron_id', '=', self.cron.id), ('done', '=', 1)]), done_count)
+                self.assertEqual(self.cron.failure_count, fail_count)
+                self.assertEqual(self.cron.active, active)
+
+    def test_cron_retrigger(self):
+        Trigger = self.env['ir.cron.trigger']
+        Progress = self.env['ir.cron.progress']
+        default_progress_values = {'done': 0, 'remaining': 0, 'timed_out_counter': 0}
+
+        def make_run(cron):
+            state = {'call_count': 0}
+            CALL_TARGET = 11
+
+            def run(self):
+                state['call_count'] += 1
+                self.env['ir.cron']._notify_progress(done=1, remaining=CALL_TARGET - state['call_count'])
+            return run, state
+
+        self.cron._trigger()
+        self.env.flush_all()
+        self.registry.enter_test_mode(self.cr)
+        mocked_run, mocked_run_state = make_run(self.cron)
+        try:
+            with patch.object(self.registry['ir.actions.server'], 'run', mocked_run):
+                self.registry['ir.cron']._process_job(
+                    self.registry.db_name,
+                    self.registry.cursor(),
+                    {**self.cron.read(load=None)[0], **default_progress_values}
+                )
+        finally:
+            self.registry.leave_test_mode()
+
+        self.assertEqual(
+            mocked_run_state['call_count'], 10,
+            '`run` should have been called ten times',
+        )
+        self.assertEqual(
+            Progress.search_count([('done', '=', 1), ('cron_id', '=', self.cron.id)]), 10,
+            'There should be 10 progress log for this cron',
+        )
+        self.assertEqual(
+            Trigger.search_count([('cron_id', '=', self.cron.id)]), 1,
+            "One trigger should have been kept",
+        )
+
+        self.env.flush_all()
+        self.registry.enter_test_mode(self.cr)
+        try:
+            with patch.object(self.registry['ir.actions.server'], 'run', mocked_run):
+                self.registry['ir.cron']._process_job(
+                    self.registry.db_name,
+                    self.registry.cursor(),
+                    {**self.cron.read(load=None)[0], **default_progress_values}
+                )
+        finally:
+            self.registry.leave_test_mode()
+
+        ready_jobs = self.registry['ir.cron']._get_all_ready_jobs(self.cr)
+        self.assertNotIn(
+            self.cron.id, [job['id'] for job in ready_jobs],
+            'The cron has finished executing'
+        )
+        self.assertEqual(
+            mocked_run_state['call_count'], 10 + 1,
+            '`run` should have been called one additional time',
+        )
+        self.assertEqual(
+            Progress.search_count([('done', '=', 1), ('cron_id', '=', self.cron.id)]), 11,
+            'There should be 11 progress log for this cron',
+        )
+
+    def test_cron_failed_increase(self):
+        self.cron._trigger()
+        self.env.flush_all()
+        self.registry.enter_test_mode(self.cr)
+        default_progress = {'done': 0, 'remaining': 0, 'timed_out_counter': 0}
+        try:
+            with (
+                patch.object(self.registry['ir.cron'], '_callback', side_effect=Exception),
+                patch.object(self.registry['ir.cron'], '_notify_admin') as notify,
+            ):
+                self.registry['ir.cron']._process_job(
+                    self.registry.db_name,
+                    self.registry.cursor(),
+                    {**self.cron.read(load=None)[0], **default_progress}
+                )
+        finally:
+            self.registry.leave_test_mode()
+
+        self.env.invalidate_all()
+        self.assertEqual(self.cron.failure_count, 1, 'The cron should have failed once')
+        self.assertEqual(self.cron.active, True, 'The cron should still be active')
+        self.assertFalse(notify.called)
+
+        self.cron.failure_count = 4
+
+        self.cron._trigger()
+        self.env.flush_all()
+        self.registry.enter_test_mode(self.cr)
+        try:
+            with (
+                patch.object(self.registry['ir.cron'], '_callback', side_effect=Exception),
+                patch.object(self.registry['ir.cron'], '_notify_admin') as notify,
+            ):
+                self.registry['ir.cron']._process_job(
+                    self.registry.db_name,
+                    self.registry.cursor(),
+                    {**self.cron.read(load=None)[0], **default_progress}
+                )
+        finally:
+            self.registry.leave_test_mode()
+
+        self.env.invalidate_all()
+        self.assertEqual(self.cron.failure_count, 5, 'The cron should have failed one more time but not reset (due to time)')
+        self.assertEqual(self.cron.active, True, 'The cron should not have been deactivated due to time constraint')
+        self.assertFalse(notify.called)
+
+        self.cron.failure_count = 4
+        self.cron.first_failure_date = fields.Datetime.now() - timedelta(days=8)
+
+        self.cron._trigger()
+        self.env.flush_all()
+        self.registry.enter_test_mode(self.cr)
+        try:
+            with (
+                patch.object(self.registry['ir.cron'], '_callback', side_effect=Exception),
+                patch.object(self.registry['ir.cron'], '_notify_admin') as notify,
+            ):
+                self.registry['ir.cron']._process_job(
+                    self.registry.db_name,
+                    self.registry.cursor(),
+                    {**self.cron.read(load=None)[0], **default_progress}
+                )
+        finally:
+            self.registry.leave_test_mode()
+
+        self.env.invalidate_all()
+        self.assertEqual(self.cron.failure_count, 0, 'The cron should have failed one more time and reset to 0')
+        self.assertEqual(self.cron.active, False, 'The cron should have been deactivated after 5 failures')
+        self.assertTrue(notify.called)
+
+    def test_cron_timeout_failure(self):
+        self.cron._trigger()
+        progress = self.env['ir.cron.progress'].create([{
+                'cron_id': self.cron.id,
+                'remaining': 0,
+                'done': 0,
+                'timed_out_counter': 3,
+        }])
+        self.env.flush_all()
+        self.registry.enter_test_mode(self.cr)
+
+        try:
+            with mute_logger('odoo.addons.base.models.ir_cron'):
+                self.registry['ir.cron']._process_job(
+                    self.registry.db_name,
+                    self.registry.cursor(),
+                    {**progress.read(fields=['done', 'remaining', 'timed_out_counter'], load=None)[0], 'progress_id': progress.id, **self.cron.read(load=None)[0]}
+                )
+        finally:
+            self.registry.leave_test_mode()
+
+        self.env.invalidate_all()
+        self.assertEqual(self.cron.failure_count, 1, 'The cron should have failed once')
+        self.assertEqual(self.cron.active, True, 'The cron should still be active')
+
+        self.cron._trigger()
+        self.registry.enter_test_mode(self.cr)
+        try:
+            self.registry['ir.cron']._process_job(
+                self.registry.db_name,
+                self.registry.cursor(),
+                {**progress.read(fields=['done', 'remaining', 'timed_out_counter'], load=None)[0], 'progress_id': progress.id, **self.cron.read(load=None)[0]}
+            )
+        finally:
+            self.registry.leave_test_mode()
+
+        self.env.invalidate_all()
+        self.assertEqual(self.cron.failure_count, 0, 'The cron should have succeeded and reset the counter')
+
+    def test_cron_timeout_success(self):
+        self.cron._trigger()
+        progress = self.env['ir.cron.progress'].create([{
+                'cron_id': self.cron.id,
+                'remaining': 0,
+                'done': 0,
+                'timed_out_counter': 3,
+        }])
+        self.env.flush_all()
+        self.registry.enter_test_mode(self.cr)
+
+        try:
+            with mute_logger('odoo.addons.base.models.ir_cron'):
+                self.registry['ir.cron']._process_job(
+                    self.registry.db_name,
+                    self.registry.cursor(),
+                    {**progress.read(fields=['done', 'remaining', 'timed_out_counter'], load=None)[0], 'progress_id': progress.id, **self.cron.read(load=None)[0]}
+                )
+        finally:
+            self.registry.leave_test_mode()
+
+        self.env.invalidate_all()
+        self.assertEqual(self.cron.failure_count, 1, 'The cron should have failed once')
+        self.assertEqual(self.cron.active, True, 'The cron should still be active')
+
+        self.cron._trigger()
+        self.registry.enter_test_mode(self.cr)
+        try:
+            self.registry['ir.cron']._process_job(
+                self.registry.db_name,
+                self.registry.cursor(),
+                {**progress.read(fields=['done', 'remaining', 'timed_out_counter'], load=None)[0], 'progress_id': progress.id, **self.cron.read(load=None)[0]}
+            )
+        finally:
+            self.registry.leave_test_mode()
+
+        self.env.invalidate_all()
+        self.assertEqual(self.cron.failure_count, 0, 'The cron should have succeeded and reset the counter')
 
 
 @tagged('-standard', '-at_install', 'post_install', 'database_breaking')

--- a/odoo/addons/base/views/ir_actions_views.xml
+++ b/odoo/addons/base/views/ir_actions_views.xml
@@ -418,6 +418,7 @@
                                     <li><code>UserError</code>: exception class for raising user-facing warning messages</li>
                                     <li><code>Command</code>: x2many commands namespace</li>
                                     <li>To return an action, assign: <code>action = {...}</code></li>
+                                    <li>To notify progress for CRON call and re-trigger a call if there is remaining tasks, use <code>env['ir.cron']._notify_progress(done=task_done_count, remaining=task_remaining_count)</code></li>
                                 </ul>
                                 <div >
                                     <p>Example of Python code:</p>

--- a/odoo/addons/base/views/ir_cron_views.xml
+++ b/odoo/addons/base/views/ir_cron_views.xml
@@ -23,9 +23,7 @@
                     </div>
                     <field name="active" widget="boolean_toggle"/>
                     <field name="nextcall"/>
-                    <field name="numbercall"/>
                     <field name="priority"/>
-                    <field name="doall"/>
                 </xpath>
                 <field name="state" position="attributes">
                     <attribute name="invisible">1</attribute>
@@ -43,7 +41,6 @@
                     <field name="nextcall"/>
                     <field name="interval_number"/>
                     <field name="interval_type"/>
-                    <field name="numbercall"/>
                     <field name="active"/>
                 </tree>
             </field>
