PR: https://github.com/odoo/odoo/pull/35942

From: 46e48055edf1141f7b49989e6e3e9faf246fefd0
From: Lucas LefÃ¨vre
Date: 2019-08-22 09:29:26

Structural Changes: 3
Total Changes: 99

[IMP] account: Store customer/supplier rank on partners

Purpose
=======

To correctly choose in which account a line should be posted,
we have to know if the partner is a customer or a supplier.

Specification
=============

Keep track of the number of account moves "in" and "out"
a partner has. These counts should be based on the posted
account moves. A customer that has been created from the
'Customer' menuitem will have a rank=1. When a customer
invoice will be created for him, the generated account moves
will be taken into account to compute its rank. The most
invoices we have for a partner, the higher his rank is.

Note: To avoid any concurrent update failures on the partner,
if one transaction has already locked a partner row, the count
update will be skipped that time.

This means the values may be approximative in the database!
The exact values will eventually be correctly computed at
the next successfull try.

Known limitation of this approach: The computation ignores
the set of currently selected companies. Actually, storing
context dependent values in the database is a bad practice,
and is avoided in that case by taking all the companies into
account.

Use the stored fields `customer_rank` and `supplier_rank`
to order partners when searching by name. This allows to show
best customers or best suppliers on top.

To choose if best customer or supplier are shown on top,
the context key `res_partner_search_mode` is used.
The context key can take two values: 'customer' or 'supplier'.
This decision partially reverts/revamps 8766f38 to only use
account moves instead of PO and SO

On actions showing partners, set a default filters to menus to
only display customers (customer_rank > 0) if the string is
"Customers", and only suppliers if the string is "Vendors" or
"Suppliers".

TaskID: 2049131

closes odoo/odoo#35942

Signed-off-by: Yannick Tivisse (yti) <yti@odoo.com>

================================= pseudo patch: =================================

--- a/addons/account/models/partner.py
+++ b/addons/account/models/partner.py
@@ -1,14 +1,17 @@
 # -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
 
-from ast import literal_eval
-from operator import itemgetter
 import time
+import psycopg2
+import logging
 
 from odoo import api, fields, models, _
 from odoo.tools import DEFAULT_SERVER_DATETIME_FORMAT
 from odoo.exceptions import ValidationError
 from odoo.addons.base.models.res_partner import WARNING_MESSAGE, WARNING_HELP
 
+_logger = logging.getLogger(__name__)
+
 class AccountFiscalPosition(models.Model):
     _name = 'account.fiscal.position'
     _description = 'Fiscal Position'
@@ -434,6 +437,85 @@ class ResPartner(models.Model):
     trust = fields.Selection([('good', 'Good Debtor'), ('normal', 'Normal Debtor'), ('bad', 'Bad Debtor')], string='Degree of trust you have in this debtor', default='normal', company_dependent=True)
     invoice_warn = fields.Selection(WARNING_MESSAGE, 'Invoice', help=WARNING_HELP, default="no-message")
     invoice_warn_msg = fields.Text('Message for Invoice')
+    # Computed fields to order the partners as suppliers/customers according to the
+    # amount of their generated incoming/outgoing account moves 
+    supplier_rank = fields.Integer(compute='_compute_rank', store=True)
+    customer_rank = fields.Integer(compute='_compute_rank', store=True)
+
+    def _get_name_search_order_by_fields(self):
+        res = super()._get_name_search_order_by_fields()
+        partner_search_mode = self.env.context.get('res_partner_search_mode')
+        if not partner_search_mode in ('customer', 'supplier'):
+            return res
+        order_by_field = 'COALESCE(res_partner.%s, 0) DESC,'
+        if partner_search_mode == 'customer':
+            field = 'customer_rank'
+        else:
+            field = 'supplier_rank'
+
+        order_by_field = order_by_field % field
+        return '%s, %s' % (res, order_by_field % field) if res else order_by_field
+
+    @api.depends('invoice_ids', 'invoice_ids.state')
+    def _compute_rank(self):
+        """
+        The two field values may not be exact in the database!
+        To avoid any concurrent update failure while writing on the partner,
+        the count is not updated if the lock cannot be directly acquired.
+        The count will eventually be correctly computed, at the next successfull try.
+        """
+        types_in = ('in_invoice', 'in_refund', 'in_receipt')
+        types_out = ('out_invoice', 'out_refund', 'out_receipt')
+        partner_ids = tuple(self.ids)
+        queries_params = {
+            'supplier_rank': {
+                'partner_id': partner_ids,
+                'move_types': types_in
+            },
+            'customer_rank': {
+                'partner_id': partner_ids,
+                'move_types': types_out
+            },
+        }
+
+        # Update database in case an invoice is just created
+        self.flush()
+        for field, params in queries_params.items():
+            try:
+                with self.env.cr.savepoint():
+                    # Check if rows are not locked
+                    # Take this opportunity to retrieve the current partner ranks
+                    # If a customer has been created from the "Customer" menuitem
+                    # his rank should be equal to 1, even if no invoice has been
+                    # created for him yet
+                    self.env.cr.execute("""
+                        SELECT id, COALESCE({}, 0)
+                        FROM res_partner
+                        WHERE id IN %(partner_id)s
+                        FOR UPDATE NOWAIT
+                    """.format(field), params, log_exceptions=False)
+                    current_counts = dict(self.env.cr.fetchall())
+                    # Compute the real ranks, based on the posted
+                    # account moves generated from the invoices
+                    self.env.cr.execute("""
+                        SELECT m.partner_id, COUNT(*) AS move_count
+                        FROM account_move AS m
+                        WHERE
+                            type in %(move_types)s
+                            AND state = 'posted'
+                            AND partner_id IN %(partner_id)s
+                        GROUP BY m.partner_id
+                    """, params)
+                    counts = dict(self.env.cr.fetchall())
+                    # Update all ranks
+                    for partner in self:
+                        partner[field] = max(counts.get(partner.id, 0), current_counts[partner.id])
+            except psycopg2.DatabaseError as e:
+                if e.pgcode == '55P03':
+                    _logger.debug('Another transaction already locked partner rows. Cannot update partner ranks now.')
+                    continue
+                else:
+                    raise e
 
     def _compute_bank_count(self):
         bank_data = self.env['res.partner.bank'].read_group([('partner_id', 'in', self.ids)], ['partner_id'], ['partner_id'])
@@ -481,3 +563,16 @@ class ResPartner(models.Model):
             ('state', '=', 'posted')
         ], limit=1)
         return can_edit_vat and not (bool(has_invoice))
+
+    @api.model_create_multi
+    def create(self, vals_list):
+        search_partner_mode = self.env.context.get('res_partner_search_mode')
+        is_customer = search_partner_mode == 'customer'
+        is_supplier = search_partner_mode == 'supplier'
+        if search_partner_mode:
+            for vals in vals_list:
+                if is_customer and 'customer_rank' not in vals:
+                    vals['customer_rank'] = 1
+                elif is_supplier and 'supplier_rank' not in vals:
+                    vals['supplier_rank'] = 1
+        return super().create(vals_list)
