PR: https://github.com/odoo/odoo/pull/

From: c407d9afb94003898cb24041da3cbbf7311a40de
From: Arnold Moyaux
Date: 2018-11-27 11:56:56

Breaking data model changes score: 4, change matches:
-    state = fields.Selection([
-    availability = fields.Selection([
-    check_to_done = fields.Boolean(compute="_get_produced_qty", string="Check Produced Qty",
-    has_moves = fields.Boolean(compute='_has_moves')

Total Changes: 149

[REF] mrp: compute state for production

Refactor production order state:
* Directly have an idea of linked workorders's state
* Computed in order to manage it in a single method
* Add tooltips for each state

Remove the None in availability selection field instead use a False

Also refactor the ready_to_produce field in order to only set as
assigned a production order that have the component for its first
workorder.

================================= pseudo patch: =================================

--- a/addons/mrp/models/mrp_production.py
+++ b/addons/mrp/models/mrp_production.py
@@ -98,6 +98,34 @@ class MrpProduction(models.Model):
         help="The list of operations (list of work centers) to produce the finished product. The routing "
              "is mainly used to compute work center costs during operations and to plan future loads on "
              "work centers based on production planning.")
+
+    state = fields.Selection([
+        ('confirmed', 'Confirmed'),
+        ('planned', 'Planned'),
+        ('progress', 'In Progress'),
+        ('to_close', 'To Close'),
+        ('done', 'Done'),
+        ('cancel', 'Cancelled')], string='State',
+        compute='_compute_state', copy=False, index=True, readonly=True,
+        store=True, track_visibility='onchange',
+        help=" * Confirmed: The MO is confirmed, the stock rules and the reordering of the components are trigerred.\n"
+             " * Planned: The WO are planned.\n"
+             " * In Progress: The production has started (on the MO or on the WO).\n"
+             " * To Close: The production is done, the MO has to be closed.\n"
+             " * Done: The MO is closed, the stock moves are posted. \n"
+             " * Cancelled: The MO has been cancelled, can't be confirmed anymore.")
+    reservation_state = fields.Selection([
+        ('confirmed', 'Waiting'),
+        ('assigned', 'Ready'),
+        ('waiting', 'Waiting Another Operation')],
+        string='Material Availability',
+        compute='_compute_state', copy=False, index=True, readonly=True,
+        store=True, track_visibility='onchange', oldname='availability',
+        help=" * Ready: The material is available to start the production.\n\
+            * Waiting: The material is not available to start the production.\n\
+            The material availability is impacted by the manufacturing readiness\
+            defined on the BoM.")
+
     move_raw_ids = fields.One2many(
         'stock.move', 'raw_material_production_id', 'Raw Materials', oldname='move_lines',
         copy=False, states={'done': [('readonly', True)], 'cancel': [('readonly', True)]},
@@ -117,20 +145,6 @@ class MrpProduction(models.Model):
     move_dest_ids = fields.One2many('stock.move', 'created_production_id',
         string="Stock Movements of Produced Goods")
 
-    state = fields.Selection([
-        ('confirmed', 'Confirmed'),
-        ('planned', 'Planned'),
-        ('progress', 'In Progress'),
-        ('done', 'Done'),
-        ('cancel', 'Cancelled')], string='State',
-        copy=False, default='confirmed', track_visibility='onchange')
-    availability = fields.Selection([
-        ('assigned', 'Available'),
-        ('partially_available', 'Partially Available'),
-        ('waiting', 'Waiting'),
-        ('none', 'None')], string='Materials Availability',
-        compute='_compute_availability', store=True)
-
     unreserve_visible = fields.Boolean(
         'Allowed to Unreserve Inventory', compute='_compute_unreserve_visible',
         help='Technical field to check when we can unreserve')
@@ -147,8 +161,6 @@ class MrpProduction(models.Model):
         default=lambda self: self.env['res.company']._company_default_get('mrp.production'),
         required=True)
 
-    check_to_done = fields.Boolean(compute="_get_produced_qty", string="Check Produced Qty",
-        help="Technical Field to see if we can show 'Mark as Done' button")
     qty_produced = fields.Float(compute="_get_produced_qty", string="Quantity Produced")
     procurement_group_id = fields.Many2one(
         'procurement.group', 'Procurement Group',
@@ -156,7 +168,6 @@ class MrpProduction(models.Model):
     propagate = fields.Boolean(
         'Propagate cancel and split',
         help='If checked, when the previous move of the move (which was generated by a next procurement) is cancelled or split, the move generated by this move will too')
-    has_moves = fields.Boolean(compute='_has_moves')
     scrap_ids = fields.One2many('stock.scrap', 'production_id', 'Scraps')
     scrap_count = fields.Integer(compute='_compute_scrap_move_count', string='Scrap Move')
     priority = fields.Selection([('0', 'Not urgent'), ('1', 'Normal'), ('2', 'Urgent'), ('3', 'Very Urgent')], 'Priority',
@@ -240,19 +251,51 @@ class MrpProduction(models.Model):
             production.workorder_done_count = count_data.get(production.id, 0)
 
     @api.multi
-    @api.depends('move_raw_ids.state', 'workorder_ids.move_raw_ids', 'bom_id.ready_to_produce')
-    def _compute_availability(self):
-        for order in self:
-            if not order.move_raw_ids:
-                order.availability = 'none'
-                continue
-            if order.bom_id.ready_to_produce == 'all_available':
-                order.availability = any(move.state not in ('assigned', 'done', 'cancel') for move in order.move_raw_ids) and 'waiting' or 'assigned'
+    @api.depends('move_raw_ids.state', 'move_finished_ids.state', 'workorder_ids', 'workorder_ids.state', 'qty_produced', 'move_raw_ids.quantity_done', 'product_qty')
+    def _compute_state(self):
+        """ Compute the production state. It use the same process than stock
+        picking. It exists 3 extra steps for production:
+        - planned: Workorder has been launched (workorders only)
+        - progress: At least one item is produced.
+        - to_close: The quantity produced is greater than the quantity to
+        produce and all work orders has been finished.
+        """
+        # TODO: duplicated code with stock_picking.py
+        for production in self:
+            if not production.move_raw_ids:
+                production.state = 'confirmed'
+            elif all(move.state == 'draft' for move in production.move_raw_ids):
+                production.state = 'confirmed'
+            elif all(move.state == 'cancel' for move in production.move_raw_ids):
+                production.state = 'cancel'
+            elif all(move.state in ['cancel', 'done'] for move in production.move_raw_ids):
+                production.state = 'done'
+            elif production.move_finished_ids.filtered(lambda m: m.state not in ('cancel', 'done') and m.product_id.id == production.product_id.id)\
+                 and (production.qty_produced >= production.product_qty)\
+                 and (not production.routing_id or all(wo_state in ('cancel', 'done') for wo_state in production.workorder_ids.mapped('state'))):
+                production.state = 'to_close'
+            elif production.workorder_ids and any(wo_state in ('progress') for wo_state in production.workorder_ids.mapped('state'))\
+                 or production.qty_produced > 0 and production.qty_produced < production.product_uom_qty:
+                production.state = 'progress'
+            elif production.workorder_ids:
+                production.state = 'planned'
+            else:
+                production.state = 'confirmed'
+
+            # Compute reservation state
+            # State where the reservation does not matter.
+            if production.state in ('done', 'cancel'):
+                production.reservation_state = False
+            # Compute reservation state according to its component's moves.
             else:
-                move_raw_ids = order.move_raw_ids.filtered(lambda m: m.product_qty)
-                partial_list = [x.state in ('partially_available', 'assigned') for x in move_raw_ids]
-                assigned_list = [x.state in ('assigned', 'done', 'cancel') for x in move_raw_ids]
-                order.availability = (all(assigned_list) and 'assigned') or (any(partial_list) and 'partially_available') or 'waiting'
+                relevant_move_state = production.move_raw_ids._get_relevant_state_among_moves()
+                if relevant_move_state == 'partially_available':
+                    if production.routing_id and production.routing_id.operation_ids and production.bom_id.ready_to_produce == 'asap':
+                        production.reservation_state = production._get_ready_to_produce_state()
+                    else:
+                        production.reservation_state = 'confirmed'
+                elif relevant_move_state != 'draft':
+                    production.reservation_state = relevant_move_state
 
     @api.depends('move_raw_ids', 'is_locked', 'state', 'move_raw_ids.quantity_done')
     def _compute_unreserve_visible(self):
@@ -273,6 +316,9 @@ class MrpProduction(models.Model):
     @api.multi
     @api.depends('move_raw_ids.quantity_done', 'move_raw_ids.product_uom_qty')
     def _compute_consumed_less_than_planned(self):
+        """ Display a warning to the user if a component of the BoM has less
+        quantity than planned.
+        """
         for order in self:
             order.consumed_less_than_planned = any(order.move_raw_ids.filtered(
                 lambda move: float_compare(move.quantity_done,
@@ -281,24 +327,14 @@ class MrpProduction(models.Model):
             )
 
     @api.multi
-    @api.depends('workorder_ids.state', 'move_finished_ids', 'is_locked')
+    @api.depends('workorder_ids.state', 'move_finished_ids', 'move_finished_ids.quantity_done', 'is_locked')
     def _get_produced_qty(self):
         for production in self:
             done_moves = production.move_finished_ids.filtered(lambda x: x.state != 'cancel' and x.product_id.id == production.product_id.id)
             qty_produced = sum(done_moves.mapped('quantity_done'))
-            wo_done = True
-            if any([x.state not in ('done', 'cancel') for x in production.workorder_ids]):
-                wo_done = False
-            production.check_to_done = production.is_locked and done_moves and (qty_produced >= production.product_qty) and (production.state not in ('done', 'cancel')) and wo_done
             production.qty_produced = qty_produced
         return True
 
-    @api.multi
-    @api.depends('move_raw_ids')
-    def _has_moves(self):
-        for mo in self:
-            mo.has_moves = any(mo.move_raw_ids)
-
     @api.multi
     def _compute_scrap_move_count(self):
         data = self.env['stock.scrap'].read_group([('production_id', 'in', self.ids)], ['production_id'], ['production_id'])
@@ -497,6 +533,26 @@ class MrpProduction(models.Model):
             move = self._generate_raw_move(bom_line, line_data)
             return move, 0, quantity
 
+    def _get_ready_to_produce_state(self):
+        """ returns 'assigned' if enough components are reserved in order to complete
+        the first operation in the routing. If not returns 'waiting'
+        """
+        self.ensure_one()
+        first_operation = self.routing_id.operation_ids[0]
+        # Get BoM line related to first opeation in rounting. If there is only
+        # one opeation in the routing then it will need all BoM lines.
+        bom_line_ids = self.env['mrp.bom.line']
+        if len(self.routing_id.operation_ids) == 1:
+            bom_line_ids = self.bom_id.bom_line_ids
+        else:
+            bom_line_ids = self.bom_id.bom_line_ids.filtered(lambda bl: bl.operation_id == first_operation)
+        bom_line_ids = bom_line_ids.filtered(lambda bl: not bl._skip_bom_line(self.product_id))
+
+        moves_in_first_operation = self.move_raw_ids.filtered(lambda m: m.bom_line_id in bom_line_ids)
+        if all(move.state == 'assigned' for move in moves_in_first_operation):
+            return 'assigned'
+        return 'confirmed'
+
     @api.multi
     def action_assign(self):
         for production in self:
@@ -517,7 +573,7 @@ class MrpProduction(models.Model):
             quantity = order.product_uom_id._compute_quantity(order.product_qty, order.bom_id.product_uom_id) / order.bom_id.product_qty
             boms, lines = order.bom_id.explode(order.product_id, quantity, picking_type=order.bom_id.picking_type_id)
             order._generate_workorders(boms)
-        return orders_to_plan.write({'state': 'planned'})
+        return True
 
     @api.multi
     def _generate_workorders(self, exploded_boms):
@@ -620,7 +676,7 @@ class MrpProduction(models.Model):
             (finish_moves | raw_moves)._action_cancel()
             picking_ids = production.picking_ids.filtered(lambda x: x.state not in ('done', 'cancel'))
             picking_ids.action_cancel()
-        self.write({'state': 'cancel', 'is_locked': True})
+
         if documents:
             filtered_documents = {}
             for (parent, responsible), rendering_context in documents.items():
@@ -673,8 +729,8 @@ class MrpProduction(models.Model):
         self.post_inventory()
         moves_to_cancel = (self.move_raw_ids | self.move_finished_ids).filtered(lambda x: x.state not in ('done', 'cancel'))
         moves_to_cancel._action_cancel()
-        self.write({'state': 'done', 'date_finished': fields.Datetime.now()})
-        return self.write({'state': 'done'})
+        self.write({'date_finished': fields.Datetime.now()})
+        return True
 
     @api.multi
     def do_unreserve(self):

--- a/addons/mrp/models/mrp_workorder.py
+++ b/addons/mrp/models/mrp_workorder.py
@@ -40,7 +40,7 @@ class MrpWorkorder(models.Model):
         help='Technical: used in views only.')
     production_availability = fields.Selection(
         'Stock Availability', readonly=True,
-        related='production_id.availability', store=True,
+        related='production_id.reservation_state', store=True,
         help='Technical: used in views and domains only.')
     production_state = fields.Selection(
         'Production State', readonly=True,
@@ -428,7 +428,6 @@ class MrpWorkorder(models.Model):
                 raise UserError(_("You need to define at least one productivity loss in the category 'Performance'. Create one from the Manufacturing app, menu: Configuration / Productivity Losses."))
         if self.production_id.state != 'progress':
             self.production_id.write({
-                'state': 'progress',
                 'date_start': datetime.now(),
             })
         timeline.create({

--- a/addons/mrp/models/stock_picking.py
+++ b/addons/mrp/models/stock_picking.py
@@ -20,8 +20,8 @@ class StockPickingType(models.Model):
         if not mrp_picking_types:
             return
         domains = {
-            'count_mo_waiting': [('availability', '=', 'waiting')],
             'count_mo_todo': [('state', 'in', ('confirmed', 'planned', 'progress'))],
+            'count_mo_waiting': [('reservation_state', '=', 'waiting')],
             'count_mo_late': [('date_planned_start', '<', fields.Date.today()), ('state', '=', 'confirmed')],
         }
         for field in domains:
