PR: https://github.com/odoo/odoo/pull/62568

From: 86fa372f95561939c064a83291394c9963ef476a
From: fw-bot
Date: 2020-11-30 09:12:07

Structural Changes: 6
Total Changes: 74

[FIX] project,sale_*: changes various issues in behaviour

This commit is mainly a revert to 13 functionalities in project_*
modules as functional changes introduced in 14 do not seem to be well
accepted by users.

Details:

- sale_timesheet: rename 'Ordered quantities' service_policy into 'Prepaid' project, sale_project, sale_timesheet: refactor task form view
- sale_timesheet: modify sale_line_employee_ids many2one widget on project form
- sale_timesheet: add link between ticket and sale order
- sale_timesheet: remove the option 'link to an existing SOL'
- sale_timesheet: remove the warning messages in project.task
- sale_timesheet: reword labels in customer_type and pricing
- sale_timesheet: adapt timesheet section on invoices in portal
- sale_timesheet: add timesheet section on orders in portal
- sale_timesheet: remove employee rate related warning on projects in Kanban view
- sale_timesheet: update sale_line_id of all the not invoiced timesheets accordingly to the employee mappings
- sale_timesheet: timesheet entries for employees that have no mapped SOL in project get the sol of the task or project

task-2388500

closes odoo/odoo#62568

Related: odoo/enterprise#15040
Signed-off-by: Yannick Tivisse (yti) <yti@odoo.com>

================================= pseudo patch: =================================

--- a/addons/sale_timesheet/models/account.py
+++ b/addons/sale_timesheet/models/account.py
@@ -123,6 +123,8 @@ class AccountAnalyticLine(models.Model):
                 map_entry = self.env['project.sale.line.employee.map'].search([('project_id', '=', task.project_id.id), ('employee_id', '=', employee.id)])
                 if map_entry:
                     return map_entry.sale_line_id
+                if task.sale_line_id or project.sale_line_id:
+                    return task.sale_line_id or project.sale_line_id
         return self.env['sale.order.line']
 
     def _timesheet_get_portal_domain(self):
@@ -139,7 +141,7 @@ class AccountAnalyticLine(models.Model):
             '|',
             '&',
             ('timesheet_invoice_id', 'in', invoice_ids.ids),
-            #TODO Question to Reviewer: non_billable was part of domain in _timesheet_get_portal_domain so I kept it here, does this make sense?
+            # TODO : Master: Check if non_billable should be removed ?
             ('timesheet_invoice_type', 'in', ['billable_time', 'non_billable']),
             '&',
             ('timesheet_invoice_type', '=', 'billable_fixed'),

--- a/addons/sale_timesheet/models/product.py
+++ b/addons/sale_timesheet/models/product.py
@@ -11,7 +11,7 @@ class ProductTemplate(models.Model):
     _inherit = 'product.template'
 
     service_policy = fields.Selection([
-        ('ordered_timesheet', 'Ordered quantities'),
+        ('ordered_timesheet', 'Prepaid'),
         ('delivered_timesheet', 'Timesheets on tasks'),
         ('delivered_manual', 'Milestones (manually set quantities on order)')
     ], string="Service Invoicing Policy", compute='_compute_service_policy', inverse='_inverse_service_policy')

--- a/addons/sale_timesheet/models/project.py
+++ b/addons/sale_timesheet/models/project.py
@@ -25,12 +25,12 @@ class Project(models.Model):
         return self.env.ref('sale_timesheet.time_product', False)
 
     bill_type = fields.Selection([
-        ('customer_task', 'Invoice tasks separately to different customers'),
-        ('customer_project', 'Invoice all tasks to a single customer')
-    ], string="Customer Type", default="customer_task",
+        ('customer_task', 'Different customers'),
+        ('customer_project', 'A unique customer')
+    ], string="Invoice Tasks to", default="customer_task",
         help='When billing tasks individually, a Sales Order will be created from each task. It is perfect if you would like to bill different services to different customers at different rates. \n When billing the whole project, a Sales Order will be created from the project instead. This option is better if you would like to bill all the tasks of a given project to a specific customer either at a fixed rate, or at an employee rate.')
     pricing_type = fields.Selection([
-        ('fixed_rate', 'Fixed rate'),
+        ('fixed_rate', 'Project rate'),
         ('employee_rate', 'Employee rate')
     ], string="Pricing", default="fixed_rate",
         help='The fixed rate is perfect if you bill a service at a fixed rate per hour or day worked regardless of the employee who performed it. The employee rate is preferable if your employees deliver the same service at a different rate. For instance, junior and senior consultants would deliver the same service (= consultancy), but at a different rate because of their level of seniority.')
@@ -40,7 +40,7 @@ class Project(models.Model):
     allow_billable = fields.Boolean("Billable", help="Invoice your time and material from tasks.")
     display_create_order = fields.Boolean(compute='_compute_display_create_order')
     timesheet_product_id = fields.Many2one(
-        'product.product', string='Timesheet Product', 
+        'product.product', string='Timesheet Product',
         domain="""[
             ('type', '=', 'service'),
             ('invoice_policy', '=', 'delivery'),
@@ -83,7 +83,7 @@ class Project(models.Model):
     def _compute_warning_employee_rate(self):
         projects = self.filtered(lambda p: p.allow_billable and p.allow_timesheets and p.bill_type == 'customer_project' and p.pricing_type == 'employee_rate')
         tasks = projects.task_ids.filtered(lambda t: not t.non_allow_billable)
-        employees = self.env['account.analytic.line'].read_group([('task_id', 'in', tasks.ids), ('non_allow_billable', '=', False)], ['employee_id', 'project_id'], ['employee_id', 'project_id'], lazy=False)
+        employees = self.env['account.analytic.line'].read_group([('task_id', 'in', tasks.ids), ('non_allow_billable', '=', False)], ['employee_id', 'project_id'], ['employee_id', 'project_id'], ['employee_id', 'project_id'], lazy=False)
         dict_project_employee = defaultdict(list)
         for line in employees:
             dict_project_employee[line['project_id'][0]] += [line['employee_id'][0]]
@@ -92,7 +92,6 @@ class Project(models.Model):
 
         (self - projects).warning_employee_rate = False
 
-
     @api.constrains('sale_line_id', 'pricing_type')
     def _check_sale_line_type(self):
         for project in self:
@@ -119,6 +118,19 @@ class Project(models.Model):
             })
         return res
 
+    def _get_not_billed_timesheets(self):
+        return self.mapped('timesheet_ids').filtered(
+            lambda t: not t.timesheet_invoice_id or t.timesheet_invoice_id.state == 'cancel')
+
+    def _update_timesheets_sale_line_id(self):
+        for project in self.filtered(lambda p: p.allow_billable and p.allow_timesheets):
+            timesheet_ids = project._get_not_billed_timesheets()
+            if not timesheet_ids:
+                continue
+            for employee_id in project.sale_line_employee_ids.filtered(lambda l: l.project_id == project).employee_id:
+                sale_line_id = project.sale_line_employee_ids.filtered(lambda l: l.project_id == project and l.employee_id == employee_id).sale_line_id
+                timesheet_ids.filtered(lambda t: t.employee_id == employee_id).so_line = sale_line_id
+
     def action_view_timesheet(self):
         self.ensure_one()
         if self.allow_timesheets:
@@ -217,6 +229,7 @@ class ProjectTask(models.Model):
             '|', ('company_id', '=', False), ('company_id', '=', company_id)]""",
         help='Select a Service product with which you would like to bill your time spent on this task.')
 
+    # TODO: [XBO] remove me in master
     non_allow_billable = fields.Boolean("Non-Billable", help="Your timesheets linked to this task will not be billed.")
 
     @api.depends(
@@ -232,29 +245,13 @@ class ProjectTask(models.Model):
 
     @api.onchange('sale_line_id')
     def _onchange_sale_line_id(self):
-        if self._get_timesheet() and self.allow_timesheets:
-            if self.sale_line_id:
-                if self.sale_line_id.product_id.service_policy == 'delivered_timesheet' and self._origin.sale_line_id.product_id.service_policy == 'delivered_timesheet':
-                    message = _("All timesheet hours that are not yet invoiced will be assigned to the selected Sales Order Item on save. Discard to avoid the change.")
-                else:
-                    message = _("All timesheet hours will be assigned to the selected Sales Order Item on save. Discard to avoid the change.")
-            else:
-                message = _("All timesheet hours that are not yet invoiced will be removed from the selected Sales Order Item on save. Discard to avoid the change.")
-
-            return {'warning': {
-                'title': _("Warning"),
-                'message': message
-            }}
+        # TODO: remove me in master
+        return
 
     @api.onchange('project_id')
     def _onchange_project_id(self):
-        if self._origin.allow_timesheets and self._get_timesheet():
-            message = _("All timesheet hours that are not yet invoiced will be assigned to the selected Project on save. Discard to avoid the change.")
-
-            return {'warning': {
-                'title': _("Warning"),
-                'message': message
-            }}
+        # TODO: remove me in master
+        return
 
     @api.depends('analytic_account_id.active')
     def _compute_analytic_account_active(self):

--- a/addons/sale_timesheet/models/project_sale_line_employee_map.py
+++ b/addons/sale_timesheet/models/project_sale_line_employee_map.py
@@ -19,7 +19,7 @@ class ProjectProductEmployeeMap(models.Model):
             ('invoice_policy', '=', 'delivery'),
             ('service_type', '=', 'timesheet'),
             '|', ('company_id', '=', False), ('company_id', '=', company_id)]""")
-    price_unit = fields.Float("Unit Price", compute='_compute_price_unit', store=True, readonly=False)
+    price_unit = fields.Float("Unit Price", compute='_compute_price_unit', store=True, readonly=True)
     currency_id = fields.Many2one('res.currency', string="Currency", compute='_compute_price_unit', store=True, readonly=False)
 
     _sql_constraints = [
@@ -49,10 +49,13 @@ class ProjectProductEmployeeMap(models.Model):
     @api.model
     def create(self, values):
         res = super(ProjectProductEmployeeMap, self).create(values)
-        for project_id in res.filtered(lambda l: l.sale_line_id).project_id:
-            if project_id.allow_timesheets and project_id.allow_billable and project_id.task_ids._get_timesheet():
-                timesheet_ids = project_id.task_ids._get_timesheet()
-                for employee_id in res.filtered(lambda l: l.project_id == project_id).employee_id:
-                    sale_line_id = res.filtered(lambda l: l.project_id == project_id and l.employee_id == employee_id).sale_line_id
-                    timesheet_ids.filtered(lambda t: t.employee_id == employee_id).so_line = sale_line_id
+        res._update_project_timesheet()
         return res
+
+    def write(self, values):
+        res = super(ProjectProductEmployeeMap, self).write(values)
+        self._update_project_timesheet()
+        return res
+
+    def _update_project_timesheet(self):
+        self.filtered(lambda l: l.sale_line_id).project_id._update_timesheets_sale_line_id()
