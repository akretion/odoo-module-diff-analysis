PR: https://github.com/odoo/odoo/pull/182639

From: 5620a16d55091b0ed74feee694a02252e3d13c17
From: David Monnom (moda)
Date: 2024-10-16 07:50:26

Breaking data model changes scores: del:12 + add:0, change matches:
-    _inherit = ['product.template']
-    _inherit = ['product.product', 'pos.load.mixin']
-    _inherit = ['product.attribute', 'pos.load.mixin']
-    _inherit = ["product.attribute.custom.value", "pos.load.mixin"]
-    _inherit = ['product.template.attribute.line', 'pos.load.mixin']
-    _inherit = ['product.template.attribute.value', 'pos.load.mixin']
-    _inherit = ['product.packaging', 'pos.load.mixin']
-    _inherit = ['uom.category', 'pos.load.mixin']
-    _inherit = ['uom.uom', 'pos.load.mixin']
-    _inherit = ['product.pricelist', 'pos.load.mixin']
-    _inherit = ['product.pricelist.item', 'pos.load.mixin']
-    _inherit = ['product.category', 'pos.load.mixin']

Total Changes: 901

[REF] point_of_sale, pos_*: replace product.product by product.template

Historically, the point of sale module used the product.product model to
represent products cards in PoS. A workaround has been done to handle
variants, attributes and pricelist.

Now the fact that we miss the product.template model in the PoS module
is a blocker for the future of the PoS module. Causing a lot of
performance issues and limitations.

This commit replace the use of product.product as product card by the
product.template model. This will allow us to use the product.template
with pricelist, attributes, variants and other features.

The old product.product models has been proxied to the product.template
each variable that isn't on the product.product model will be taken from
the product.template model.

closes odoo/odoo#182639

Taskid: 4134659
Related: odoo/enterprise#71752
Signed-off-by: Joseph Caburnay (jcb) <jcb@odoo.com>

================================= pseudo patch: =================================

--- a/addons/point_of_sale/models/__init__.py
+++ b/addons/point_of_sale/models/__init__.py
@@ -17,7 +17,13 @@ from . import pos_category
 from . import pos_config
 from . import pos_order
 from . import pos_session
-from . import product
+from . import product_pricelist
+from . import product_attribute
+from . import product_category
+from . import product_packaging
+from . import product_product
+from . import product_template
+from . import uom
 from . import product_combo
 from . import product_combo_item
 from . import res_partner

--- a/addons/point_of_sale/models/pos_category.py
+++ b/addons/point_of_sale/models/pos_category.py
@@ -34,8 +34,12 @@ class PosCategory(models.Model):
 
     @api.model
     def _load_pos_data_domain(self, data):
-        config_id = self.env['pos.config'].browse(data['pos.config']['data'][0]['id'])
-        domain = [('id', 'in', config_id._get_available_categories().ids)] if config_id.limit_categories and config_id.iface_available_categ_ids else []
+        domain = []
+        limited_categories = data['pos.config']['data'][0]['limit_categories']
+        if limited_categories:
+            available_category_ids = data['pos.config']['data'][0]['iface_available_categ_ids']
+            category_ids = self.env['pos.category'].browse(available_category_ids)._get_descendants().ids
+            domain += [('id', 'in', category_ids)]
         return domain
 
     @api.model

--- a/addons/point_of_sale/models/pos_config.py
+++ b/addons/point_of_sale/models/pos_config.py
@@ -679,32 +679,6 @@ class PosConfig(models.Model):
                 'type': 'ir.actions.act_window',
             }
 
-    def _get_available_categories(self):
-        return (
-            self.env["pos.category"]
-            .search(
-                [
-                    *(
-                        self.limit_categories
-                        and self.iface_available_categ_ids
-                        and [("id", "in", self.iface_available_categ_ids._get_descendants().ids)]
-                        or []
-                    ),
-                ],
-                order="sequence",
-            )
-        )
-
-    def _get_available_product_domain(self):
-        domain = [
-            *self.env['product.product']._check_company_domain(self.company_id),
-            ('available_in_pos', '=', True),
-            ('sale_ok', '=', True),
-        ]
-        if self.limit_categories and self.iface_available_categ_ids:
-            domain.append(('pos_categ_ids', 'in', self._get_available_categories().ids))
-        return domain
-
     def _link_same_non_cash_payment_methods(self, source_config):
         pms = source_config.payment_method_ids.filtered(lambda pm: not pm.is_cash_count)
         if pms:
@@ -739,40 +713,6 @@ class PosConfig(models.Model):
             'company_id': company_id,
         }).id
 
-    def get_limited_products_loading(self, fields):
-        query = self.env['product.product']._where_calc(
-            self._get_available_product_domain()
-        )
-        sql = SQL(
-            """
-            WITH pm AS (
-                  SELECT product_id,
-                         MAX(write_date) date
-                    FROM stock_move_line
-                GROUP BY product_id
-            )
-               SELECT product_product.id
-                 FROM %s
-            LEFT JOIN pm ON product_product.id=pm.product_id
-                WHERE %s
-             ORDER BY product_product__product_tmpl_id.is_favorite DESC,
-                      CASE WHEN product_product__product_tmpl_id.type = 'service' THEN 1 ELSE 0 END DESC,
-                      pm.date DESC NULLS LAST,
-                      product_product.write_date DESC
-                LIMIT %s
-            """,
-            query.from_clause,
-            query.where_clause or SQL("TRUE"),
-            self.get_limited_product_count(),
-        )
-        product_ids = [r[0] for r in self.env.execute_query(sql)]
-        product_ids.extend(self._get_special_products().ids)
-        products = self.env['product.product'].browse(product_ids)
-        product_combo = products.filtered(lambda p: p['type'] == 'combo')
-        product_in_combo = product_combo.combo_ids.combo_item_ids.product_id
-        products_available = products | product_in_combo
-        return products_available.read(fields, load=False)
-
     def get_limited_product_count(self):
         default_limit = 20000
         config_param = self.env['ir.config_parameter'].sudo().get_param('point_of_sale.limited_product_count', default_limit)

--- a/addons/point_of_sale/models/pos_session.py
+++ b/addons/point_of_sale/models/pos_session.py
@@ -129,7 +129,7 @@ class PosSession(models.Model):
     @api.model
     def _load_pos_data_models(self, config_id):
         return ['pos.config', 'pos.order', 'pos.order.line', 'pos.pack.operation.lot', 'pos.payment', 'pos.payment.method', 'pos.printer',
-            'pos.category', 'pos.bill', 'res.company', 'account.tax', 'account.tax.group', 'product.product', 'product.attribute', 'product.attribute.custom.value',
+            'pos.category', 'pos.bill', 'res.company', 'account.tax', 'account.tax.group', 'product.template', 'product.product', 'product.attribute', 'product.attribute.custom.value',
             'product.template.attribute.line', 'product.template.attribute.value', 'product.combo', 'product.combo.item', 'product.packaging', 'res.users', 'res.partner',
             'decimal.precision', 'uom.uom', 'uom.category', 'res.country', 'res.country.state', 'res.lang', 'product.pricelist', 'product.pricelist.item', 'product.category',
             'account.cash.rounding', 'account.fiscal.position', 'account.fiscal.position.tax', 'stock.picking.type', 'res.currency', 'pos.note', 'ir.ui.view']
@@ -195,14 +195,16 @@ class PosSession(models.Model):
     def get_pos_ui_product_pricelist_item_by_product(self, product_tmpl_ids, product_ids, config_id):
         pricelist_fields = self.env['product.pricelist']._load_pos_data_fields(config_id)
         pricelist_item_fields = self.env['product.pricelist.item']._load_pos_data_fields(config_id)
-
+        today = fields.Date.today()
         pricelist_item_domain = [
             '|',
             ('company_id', '=', False),
             ('company_id', '=', self.company_id.id),
             '|',
             '&', ('product_id', '=', False), ('product_tmpl_id', 'in', product_tmpl_ids),
-            ('product_id', 'in', product_ids)]
+            ('product_id', 'in', product_ids),
+            '|', ('date_start', '=', False), ('date_start', '<=', today),
+            '|', ('date_end', '=', False), ('date_end', '>=', today)]
 
         pricelist_item = self.env['product.pricelist.item'].search(pricelist_item_domain)
         pricelist = pricelist_item.pricelist_id
@@ -1803,6 +1805,7 @@ class PosSession(models.Model):
 
     def find_product_by_barcode(self, barcode, config_id):
         product_fields = self.env['product.product']._load_pos_data_fields(config_id)
+        product_template_fields = self.env['product.template']._load_pos_data_fields(config_id)
         product_packaging_fields = self.env['product.packaging']._load_pos_data_fields(config_id)
         product = self.env['product.product'].search([
             ('barcode', '=', barcode),
@@ -1810,7 +1813,11 @@ class PosSession(models.Model):
             ('available_in_pos', '=', True),
         ])
         if product:
-            return {'product.product': product.with_context({'display_default_code': False}).read(product_fields, load=False)}
+            product = product.with_context({'display_default_code': False})
+            return {
+                'product.product': product.read(product_fields, load=False),
+                'product.template': product.product_tmpl_id.read(product_template_fields, load=False)
+            }
 
         domain = [('barcode', 'not in', ['', False])]
         loaded_data = self._context.get('loaded_data')
@@ -1826,14 +1833,13 @@ class PosSession(models.Model):
         }
         packaging_params['search_params']['domain'] = [['barcode', '=', barcode]]
         packaging = self.env['product.packaging'].search(packaging_params['search_params']['domain'])
-
-        if packaging and packaging.product_id:
-            return {'product.product': packaging.product_id.with_context({'display_default_code': False}).read(product_fields, load=False), 'product.packaging': packaging.read(product_packaging_fields, load=False)}
-        else:
-            return {
-                'product.product': [],
-                'product.packaging': [],
-            }
+        product = packaging.product_id.with_context({'display_default_code': False})
+        condition = packaging and packaging.product_id
+        return {
+            'product.product': product.read(product_fields, load=False) if condition else [],
+            'product.template': product.product_tmpl_id.read(product_template_fields, load=False) if condition else [],
+            'product.packaging': packaging.read(product_packaging_fields, load=False) if condition else [],
+        }
 
     def get_total_discount(self):
         amount = 0

--- a/addons/point_of_sale/models/product.py
+++ b/None
@@ -1,371 +0,0 @@
-# Part of Odoo. See LICENSE file for full copyright and licensing details.
-from odoo import api, fields, models, _
-from odoo.exceptions import UserError
-from collections import defaultdict
-from itertools import groupby
-from operator import itemgetter
-from datetime import date
-from odoo.osv.expression import AND
-
-
-class ProductTemplate(models.Model):
-    _inherit = ['product.template']
-
-    available_in_pos = fields.Boolean(string='Available in POS', help='Check if you want this product to appear in the Point of Sale.', default=False)
-    to_weight = fields.Boolean(string='To Weigh With Scale', help="Check if the product should be weighted using the hardware scale integration.")
-    pos_categ_ids = fields.Many2many(
-        'pos.category', string='Point of Sale Category',
-        help="Category used in the Point of Sale.")
-    public_description = fields.Html(
-        string="Product Description",
-        translate=True
-    )
-
-    @api.ondelete(at_uninstall=False)
-    def _unlink_except_open_session(self):
-        product_ctx = dict(self.env.context or {}, active_test=False)
-        if self.with_context(product_ctx).search_count([('id', 'in', self.ids), ('available_in_pos', '=', True)]):
-            if self.env['pos.session'].sudo().search_count([('state', '!=', 'closed')]):
-                raise UserError(_("To delete a product, make sure all point of sale sessions are closed.\n\n"
-                    "Deleting a product available in a session would be like attempting to snatch a"
-                    "hamburger from a customer’s hand mid-bite; chaos will ensue as ketchup and mayo go flying everywhere!"))
-
-    @api.onchange('sale_ok')
-    def _onchange_sale_ok(self):
-        if not self.sale_ok:
-            self.available_in_pos = False
-
-    @api.onchange('available_in_pos')
-    def _onchange_available_in_pos(self):
-        if self.available_in_pos and not self.sale_ok:
-            self.sale_ok = True
-
-    @api.constrains('available_in_pos')
-    def _check_combo_inclusions(self):
-        for product in self:
-            if not product.available_in_pos:
-                combo_name = self.env['product.combo.item'].sudo().search([('product_id', 'in', product.product_variant_ids.ids)], limit=1).combo_id.name
-                if combo_name:
-                    raise UserError(_('You must first remove this product from the %s combo', combo_name))
-
-
-class ProductProduct(models.Model):
-    _inherit = ['product.product', 'pos.load.mixin']
-
-    @api.model
-    def _load_pos_data_domain(self, data):
-        config_id = self.env['pos.config'].browse(data['pos.config']['data'][0]['id'])
-        return config_id._get_available_product_domain()
-
-    @api.model
-    def _load_pos_data_fields(self, config_id):
-        return [
-            'id', 'display_name', 'lst_price', 'standard_price', 'categ_id', 'pos_categ_ids', 'taxes_id', 'barcode', 'name',
-            'default_code', 'to_weight', 'uom_id', 'description_sale', 'description', 'product_tmpl_id', 'tracking', 'type', 'service_tracking', 'is_storable',
-            'write_date', 'available_in_pos', 'attribute_line_ids', 'active', 'image_128', 'combo_ids', 'product_template_variant_value_ids',
-        ]
-
-    def _load_pos_data(self, data):
-        # Add custom fields for 'formula' taxes.
-        fields = set(self._load_pos_data_fields(data['pos.config']['data'][0]['id']))
-        taxes = self.env['account.tax'].search(self.env['account.tax']._load_pos_data_domain(data))
-        product_fields = taxes._eval_taxes_computation_prepare_product_fields()
-        fields = list(fields.union(product_fields))
-
-        config = self.env['pos.config'].browse(data['pos.config']['data'][0]['id'])
-        limit_count = config.get_limited_product_count()
-        if limit_count:
-            products = config.with_context(display_default_code=False).get_limited_products_loading(fields)
-        else:
-            domain = self._load_pos_data_domain(data)
-            products = self._load_product_with_domain(domain, config.id)
-
-        self._add_missing_products(products, config.id, data)
-
-        data['pos.config']['data'][0]['_product_default_values'] = \
-            self.env['account.tax']._eval_taxes_computation_prepare_product_default_values(product_fields)
-
-        self._process_pos_ui_product_product(products, config)
-        return {
-            'data': products,
-            'fields': fields,
-        }
-
-    def _add_missing_products(self, products, config_id, data):
-        product_ids_in_loaded_lines = {line['product_id'] for line in data['pos.order.line']['data']}
-        not_loaded_product_ids = product_ids_in_loaded_lines - {product['id'] for product in products}
-        products.extend(self._load_product_with_domain([('id', 'in', list(not_loaded_product_ids))], config_id, True))
-
-    def _load_product_with_domain(self, domain, config_id, load_archived=False):
-        fields = self._load_pos_data_fields(config_id)
-        context = {**self.env.context, 'display_default_code': False, 'active_test': not load_archived}
-        return self.with_context(context).search_read(
-            domain,
-            fields,
-            order='sequence,default_code,name',
-            load=False)
-
-    def _process_pos_ui_product_product(self, products, config_id):
-
-        def filter_taxes_on_company(product_taxes, taxes_by_company):
-            """
-            Filter the list of tax ids on a single company starting from the current one.
-            If there is no tax in the result, it's filtered on the parent company and so
-            on until a non empty result is found.
-            """
-            taxes, comp = None, self.env.company
-            while not taxes and comp:
-                taxes = list(set(product_taxes) & set(taxes_by_company[comp.id]))
-                comp = comp.parent_id
-            return taxes
-
-        taxes = self.env['account.tax'].search(self.env['account.tax']._check_company_domain(self.env.company))
-        # group all taxes by company in a dict where:
-        # - key: ID of the company
-        # - values: list of tax ids
-        taxes_by_company = defaultdict(set)
-        if self.env.company.parent_id:
-            for tax in taxes:
-                taxes_by_company[tax.company_id.id].add(tax.id)
-
-        loaded_product_tmpl_ids = list({p['product_tmpl_id'] for p in products})
-        archived_combinations = self._get_archived_combinations_per_product_tmpl_id(loaded_product_tmpl_ids)
-        different_currency = config_id.currency_id != self.env.company.currency_id
-        for product in products:
-            if different_currency:
-                product['lst_price'] = self.env.company.currency_id._convert(product['lst_price'], config_id.currency_id, self.env.company, fields.Date.today())
-            product['image_128'] = bool(product['image_128'])
-
-            if len(taxes_by_company) > 1 and len(product['taxes_id']) > 1:
-                product['taxes_id'] = filter_taxes_on_company(product['taxes_id'], taxes_by_company)
-
-            if archived_combinations.get(product['product_tmpl_id']):
-                product['_archived_combinations'] = archived_combinations[product['product_tmpl_id']]
-
-    def _get_archived_combinations_per_product_tmpl_id(self, product_tmpl_ids):
-        archived_combinations = {}
-        for product in self.env['product.product'].with_context(active_test=False).search([('product_tmpl_id', 'in', product_tmpl_ids), ('active', '=', False)]):
-            if not archived_combinations.get(product.product_tmpl_id.id):
-                archived_combinations[product.product_tmpl_id.id] = []
-            archived_combinations[product.product_tmpl_id.id].append(product.product_template_attribute_value_ids.ids)
-        return archived_combinations
-
-    @api.ondelete(at_uninstall=False)
-    def _unlink_except_active_pos_session(self):
-        product_ctx = dict(self.env.context or {}, active_test=False)
-        if self.env['pos.session'].sudo().search_count([('state', '!=', 'closed')]):
-            if self.with_context(product_ctx).search_count([('id', 'in', self.ids), ('product_tmpl_id.available_in_pos', '=', True)]):
-                raise UserError(_("To delete a product, make sure all point of sale sessions are closed.\n\n"
-                    "Deleting a product available in a session would be like attempting to snatch a"
-                    "hamburger from a customer’s hand mid-bite; chaos will ensue as ketchup and mayo go flying everywhere!"))
-
-    def get_product_info_pos(self, price, quantity, pos_config_id):
-        self.ensure_one()
-        config = self.env['pos.config'].browse(pos_config_id)
-
-        # Tax related
-        taxes = self.taxes_id.compute_all(price, config.currency_id, quantity, self)
-        grouped_taxes = {}
-        for tax in taxes['taxes']:
-            if tax['id'] in grouped_taxes:
-                grouped_taxes[tax['id']]['amount'] += tax['amount']/quantity if quantity else 0
-            else:
-                grouped_taxes[tax['id']] = {
-                    'name': tax['name'],
-                    'amount': tax['amount']/quantity if quantity else 0
-                }
-
-        all_prices = {
-            'price_without_tax': taxes['total_excluded']/quantity if quantity else 0,
-            'price_with_tax': taxes['total_included']/quantity if quantity else 0,
-            'tax_details': list(grouped_taxes.values()),
-        }
-
-        # Pricelists
-        if config.use_pricelist:
-            pricelists = config.available_pricelist_ids
-        else:
-            pricelists = config.pricelist_id
-        price_per_pricelist_id = pricelists._price_get(self, quantity) if pricelists else False
-        pricelist_list = [{'name': pl.name, 'price': price_per_pricelist_id[pl.id]} for pl in pricelists]
-
-        # Warehouses
-        warehouse_list = [
-            {'id': w.id,
-            'name': w.name,
-            'available_quantity': self.with_context({'warehouse_id': w.id}).qty_available,
-            'forecasted_quantity': self.with_context({'warehouse_id': w.id}).virtual_available,
-            'uom': self.uom_name}
-            for w in self.env['stock.warehouse'].search([('company_id', '=', config.company_id.id)])]
-
-        if config.picking_type_id.warehouse_id:
-            # Sort the warehouse_list, prioritizing config.picking_type_id.warehouse_id
-            warehouse_list = sorted(
-                warehouse_list,
-                key=lambda w: w['id'] != config.picking_type_id.warehouse_id.id
-            )
-
-        # Suppliers
-        key = itemgetter('partner_id')
-        supplier_list = []
-        for key, group in groupby(sorted(self.seller_ids, key=key), key=key):
-            for s in list(group):
-                if not((s.date_start and s.date_start > date.today()) or (s.date_end and s.date_end < date.today()) or (s.min_qty > quantity)):
-                    supplier_list.append({
-                        'name': s.partner_id.name,
-                        'delay': s.delay,
-                        'price': s.price
-                    })
-                    break
-
-        # Variants
-        variant_list = [{'name': attribute_line.attribute_id.name,
-                         'values': list(map(lambda attr_name: {'name': attr_name, 'search': '%s %s' % (self.name, attr_name)}, attribute_line.value_ids.mapped('name')))}
-                        for attribute_line in self.attribute_line_ids]
-
-        return {
-            'all_prices': all_prices,
-            'pricelists': pricelist_list,
-            'warehouses': warehouse_list,
-            'suppliers': supplier_list,
-            'variants': variant_list
-        }
-
-
-class ProductAttribute(models.Model):
-    _inherit = ['product.attribute', 'pos.load.mixin']
-
-    @api.model
-    def _load_pos_data_fields(self, config_id):
-        return ['name', 'display_type', 'template_value_ids', 'attribute_line_ids', 'create_variant']
-
-
-class ProductAttributeCustomValue(models.Model):
-    _inherit = ["product.attribute.custom.value", "pos.load.mixin"]
-
-    pos_order_line_id = fields.Many2one('pos.order.line', string="PoS Order Line", ondelete='cascade')
-
-    @api.model
-    def _load_pos_data_domain(self, data):
-        return [('pos_order_line_id', 'in', [line['id'] for line in data['pos.order.line']['data']])]
-
-    @api.model
-    def _load_pos_data_fields(self, config_id):
-        return ['custom_value', 'custom_product_template_attribute_value_id', 'pos_order_line_id']
-
-
-class ProductTemplateAttributeLine(models.Model):
-    _inherit = ['product.template.attribute.line', 'pos.load.mixin']
-
-    @api.model
-    def _load_pos_data_fields(self, config_id):
-        return ['display_name', 'attribute_id', 'product_template_value_ids']
-
-    @api.model
-    def _load_pos_data_domain(self, data):
-        loaded_product_tmpl_ids = list({p['product_tmpl_id'] for p in data['product.product']['data']})
-        return [('product_tmpl_id', 'in', loaded_product_tmpl_ids)]
-
-
-class ProductTemplateAttributeValue(models.Model):
-    _inherit = ['product.template.attribute.value', 'pos.load.mixin']
-
-    @api.model
-    def _load_pos_data_domain(self, data):
-        loaded_product_tmpl_ids = list({p['product_tmpl_id'] for p in data['product.product']['data']})
-        return AND([
-            [('ptav_active', '=', True)],
-            [('attribute_id', 'in', [attr['id'] for attr in data['product.attribute']['data']])],
-            [('product_tmpl_id', 'in', loaded_product_tmpl_ids)]
-        ])
-
-    @api.model
-    def _load_pos_data_fields(self, config_id):
-        return ['attribute_id', 'attribute_line_id', 'product_attribute_value_id', 'price_extra', 'name', 'is_custom', 'html_color', 'image']
-
-
-class ProductPackaging(models.Model):
-    _inherit = ['product.packaging', 'pos.load.mixin']
-
-    @api.model
-    def _load_pos_data_domain(self, data):
-        return AND([[('barcode', 'not in', ['', False])], [('product_id', 'in', [x['id'] for x in data['product.product']['data']])] if data else []])
-
-    @api.model
-    def _load_pos_data_fields(self, config_id):
-        return ['id', 'name', 'barcode', 'product_id', 'qty']
-
-
-class UomCategory(models.Model):
-    _inherit = ['uom.category', 'pos.load.mixin']
-
-    is_pos_groupable = fields.Boolean(string='Group Products in POS',
-        help="Check if you want to group products of this category in point of sale orders")
-
-    @api.model
-    def _load_pos_data_domain(self, data):
-        return [('uom_ids', 'in', [uom['category_id'] for uom in data['uom.uom']['data']])]
-
-    @api.model
-    def _load_pos_data_fields(self, config_id):
-        return ['id', 'name', 'uom_ids']
-
-
-class UomUom(models.Model):
-    _inherit = ['uom.uom', 'pos.load.mixin']
-
-    is_pos_groupable = fields.Boolean(related='category_id.is_pos_groupable', readonly=False)
-
-    @api.model
-    def _load_pos_data_fields(self, config_id):
-        return ['id', 'name', 'category_id', 'factor_inv', 'factor', 'is_pos_groupable', 'uom_type', 'rounding']
-
-    def _load_pos_data(self, data):
-        domain = self._load_pos_data_domain(data)
-        fields = self._load_pos_data_fields(data['pos.config']['data'][0]['id'])
-        return {
-            'data': self.with_context({**self.env.context}).search_read(domain, fields, load=False),
-            'fields': fields,
-        }
-
-
-class ProductPricelist(models.Model):
-    _inherit = ['product.pricelist', 'pos.load.mixin']
-
-    @api.model
-    def _load_pos_data_domain(self, data):
-        config_id = self.env['pos.config'].browse(data['pos.config']['data'][0]['id'])
-        return [('id', 'in', config_id.available_pricelist_ids.ids)] if config_id.use_pricelist else [('id', '=', config_id.pricelist_id.id)]
-
-    @api.model
-    def _load_pos_data_fields(self, config_id):
-        return ['id', 'name', 'display_name', 'item_ids']
-
-
-class ProductPricelistItem(models.Model):
-    _inherit = ['product.pricelist.item', 'pos.load.mixin']
-
-    @api.model
-    def _load_pos_data_domain(self, data):
-        product_tmpl_ids = [p['product_tmpl_id'] for p in data['product.product']['data']]
-        product_ids = [p['id'] for p in data['product.product']['data']]
-        pricelist_ids = [p['id'] for p in data['product.pricelist']['data']]
-        return [
-            ('pricelist_id', 'in', pricelist_ids),
-            '|', ('product_tmpl_id', '=', False), ('product_tmpl_id', 'in', product_tmpl_ids),
-            '|', ('product_id', '=', False), ('product_id', 'in', product_ids),
-        ]
-
-    @api.model
-    def _load_pos_data_fields(self, config_id):
-        return ['product_tmpl_id', 'product_id', 'pricelist_id', 'price_surcharge', 'price_discount', 'price_round',
-                'price_min_margin', 'price_max_margin', 'company_id', 'currency_id', 'date_start', 'date_end', 'compute_price',
-                'fixed_price', 'percent_price', 'base_pricelist_id', 'base', 'categ_id', 'min_quantity']
-
-
-class ProductCategory(models.Model):
-    _inherit = ['product.category', 'pos.load.mixin']
-
-    @api.model
-    def _load_pos_data_fields(self, config_id):
-        return ['id', 'name', 'parent_id']

--- a/None
+++ b/addons/point_of_sale/models/product_attribute.py
@@ -0,0 +1,54 @@
+from odoo import api, fields, models
+from odoo.osv.expression import AND
+
+
+class ProductAttribute(models.Model):
+    _inherit = ['product.attribute', 'pos.load.mixin']
+
+    @api.model
+    def _load_pos_data_fields(self, config_id):
+        return ['name', 'display_type', 'template_value_ids', 'attribute_line_ids', 'create_variant']
+
+
+class ProductAttributeCustomValue(models.Model):
+    _inherit = ["product.attribute.custom.value", "pos.load.mixin"]
+
+    pos_order_line_id = fields.Many2one('pos.order.line', string="PoS Order Line", ondelete='cascade')
+
+    @api.model
+    def _load_pos_data_domain(self, data):
+        return [('pos_order_line_id', 'in', [line['id'] for line in data['pos.order.line']['data']])]
+
+    @api.model
+    def _load_pos_data_fields(self, config_id):
+        return ['custom_value', 'custom_product_template_attribute_value_id', 'pos_order_line_id']
+
+
+class ProductTemplateAttributeLine(models.Model):
+    _inherit = ['product.template.attribute.line', 'pos.load.mixin']
+
+    @api.model
+    def _load_pos_data_fields(self, config_id):
+        return ['display_name', 'attribute_id', 'product_template_value_ids']
+
+    @api.model
+    def _load_pos_data_domain(self, data):
+        loaded_product_tmpl_ids = list({p['product_tmpl_id'] for p in data['product.product']['data']})
+        return [('product_tmpl_id', 'in', loaded_product_tmpl_ids)]
+
+
+class ProductTemplateAttributeValue(models.Model):
+    _inherit = ['product.template.attribute.value', 'pos.load.mixin']
+
+    @api.model
+    def _load_pos_data_domain(self, data):
+        loaded_product_tmpl_ids = list({p['product_tmpl_id'] for p in data['product.product']['data']})
+        return AND([
+            [('ptav_active', '=', True)],
+            [('attribute_id', 'in', [attr['id'] for attr in data['product.attribute']['data']])],
+            [('product_tmpl_id', 'in', loaded_product_tmpl_ids)]
+        ])
+
+    @api.model
+    def _load_pos_data_fields(self, config_id):
+        return ['attribute_id', 'attribute_line_id', 'product_attribute_value_id', 'price_extra', 'name', 'is_custom', 'html_color', 'image']

--- a/None
+++ b/addons/point_of_sale/models/product_category.py
@@ -0,0 +1,10 @@
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+from odoo import api, models
+
+
+class ProductCategory(models.Model):
+    _inherit = ['product.category', 'pos.load.mixin']
+
+    @api.model
+    def _load_pos_data_fields(self, config_id):
+        return ['id', 'name', 'parent_id']

--- a/addons/point_of_sale/models/product_combo.py
+++ b/addons/point_of_sale/models/product_combo.py
@@ -8,7 +8,7 @@ class ProductCombo(models.Model):
 
     @api.model
     def _load_pos_data_domain(self, data):
-        return [('id', 'in', list(set().union(*[product.get('combo_ids') for product in data['product.product']['data']])))]
+        return [('id', 'in', list(set().union(*[product.get('combo_ids') for product in data['product.template']['data']])))]
 
     @api.model
     def _load_pos_data_fields(self, config_id):

--- a/None
+++ b/addons/point_of_sale/models/product_packaging.py
@@ -0,0 +1,14 @@
+from odoo import api, models
+from odoo.osv.expression import AND
+
+
+class ProductPackaging(models.Model):
+    _inherit = ['product.packaging', 'pos.load.mixin']
+
+    @api.model
+    def _load_pos_data_domain(self, data):
+        return AND([[('barcode', 'not in', ['', False])], [('product_id', 'in', [x['id'] for x in data['product.product']['data']])] if data else []])
+
+    @api.model
+    def _load_pos_data_fields(self, config_id):
+        return ['id', 'name', 'barcode', 'product_id', 'qty']

--- a/None
+++ b/addons/point_of_sale/models/product_pricelist.py
@@ -0,0 +1,39 @@
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+from odoo import api, fields, models
+
+
+class ProductPricelist(models.Model):
+    _inherit = ['product.pricelist', 'pos.load.mixin']
+
+    @api.model
+    def _load_pos_data_domain(self, data):
+        config_id = self.env['pos.config'].browse(data['pos.config']['data'][0]['id'])
+        return [('id', 'in', config_id.available_pricelist_ids.ids)] if config_id.use_pricelist else [('id', '=', config_id.pricelist_id.id)]
+
+    @api.model
+    def _load_pos_data_fields(self, config_id):
+        return ['id', 'name', 'display_name', 'item_ids']
+
+
+class ProductPricelistItem(models.Model):
+    _inherit = ['product.pricelist.item', 'pos.load.mixin']
+
+    @api.model
+    def _load_pos_data_domain(self, data):
+        product_tmpl_ids = [p['product_tmpl_id'] for p in data['product.product']['data']]
+        product_ids = [p['id'] for p in data['product.product']['data']]
+        pricelist_ids = [p['id'] for p in data['product.pricelist']['data']]
+        today = fields.Date.today()
+        return [
+            ('pricelist_id', 'in', pricelist_ids),
+            '|', ('product_tmpl_id', '=', False), ('product_tmpl_id', 'in', product_tmpl_ids),
+            '|', ('product_id', '=', False), ('product_id', 'in', product_ids),
+            '|', ('date_start', '=', False), ('date_start', '<=', today),
+            '|', ('date_end', '=', False), ('date_end', '>=', today)
+        ]
+
+    @api.model
+    def _load_pos_data_fields(self, config_id):
+        return ['product_tmpl_id', 'product_id', 'pricelist_id', 'price_surcharge', 'price_discount', 'price_round',
+                'price_min_margin', 'price_max_margin', 'company_id', 'currency_id', 'date_start', 'date_end', 'compute_price',
+                'fixed_price', 'percent_price', 'base_pricelist_id', 'base', 'categ_id', 'min_quantity']

--- a/None
+++ b/addons/point_of_sale/models/product_product.py
@@ -0,0 +1,99 @@
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+from odoo import api, models, _
+from odoo.exceptions import UserError
+from itertools import groupby
+from operator import itemgetter
+from datetime import date
+
+
+class ProductProduct(models.Model):
+    _inherit = ['product.product', 'pos.load.mixin']
+
+    @api.model
+    def _load_pos_data_domain(self, data):
+        return [('product_tmpl_id', 'in', [p['id'] for p in data['product.template']['data']])]
+
+    @api.model
+    def _load_pos_data_fields(self, config_id):
+        return ['id', 'lst_price', 'display_name', 'product_tmpl_id', 'product_template_variant_value_ids', 'barcode']
+
+    @api.ondelete(at_uninstall=False)
+    def _unlink_except_active_pos_session(self):
+        product_ctx = dict(self.env.context or {}, active_test=False)
+        if self.env['pos.session'].sudo().search_count([('state', '!=', 'closed')]):
+            if self.with_context(product_ctx).search_count([('id', 'in', self.ids), ('product_tmpl_id.available_in_pos', '=', True)]):
+                raise UserError(_("To delete a product, make sure all point of sale sessions are closed.\n\n"
+                    "Deleting a product available in a session would be like attempting to snatch a"
+                    "hamburger from a customer’s hand mid-bite; chaos will ensue as ketchup and mayo go flying everywhere!"))
+
+    def get_product_info_pos(self, price, quantity, pos_config_id):
+        self.ensure_one()
+        config = self.env['pos.config'].browse(pos_config_id)
+
+        # Tax related
+        taxes = self.taxes_id.compute_all(price, config.currency_id, quantity, self)
+        grouped_taxes = {}
+        for tax in taxes['taxes']:
+            if tax['id'] in grouped_taxes:
+                grouped_taxes[tax['id']]['amount'] += tax['amount'] / quantity if quantity else 0
+            else:
+                grouped_taxes[tax['id']] = {
+                    'name': tax['name'],
+                    'amount': tax['amount'] / quantity if quantity else 0
+                }
+
+        all_prices = {
+            'price_without_tax': taxes['total_excluded'] / quantity if quantity else 0,
+            'price_with_tax': taxes['total_included'] / quantity if quantity else 0,
+            'tax_details': list(grouped_taxes.values()),
+        }
+
+        # Pricelists
+        if config.use_pricelist:
+            pricelists = config.available_pricelist_ids
+        else:
+            pricelists = config.pricelist_id
+        price_per_pricelist_id = pricelists._price_get(self, quantity) if pricelists else False
+        pricelist_list = [{'name': pl.name, 'price': price_per_pricelist_id[pl.id]} for pl in pricelists]
+
+        # Warehouses
+        warehouse_list = [
+            {'id': w.id,
+            'name': w.name,
+            'available_quantity': self.with_context({'warehouse_id': w.id}).qty_available,
+            'forecasted_quantity': self.with_context({'warehouse_id': w.id}).virtual_available,
+            'uom': self.uom_name}
+            for w in self.env['stock.warehouse'].search([('company_id', '=', config.company_id.id)])]
+
+        if config.picking_type_id.warehouse_id:
+            # Sort the warehouse_list, prioritizing config.picking_type_id.warehouse_id
+            warehouse_list = sorted(
+                warehouse_list,
+                key=lambda w: w['id'] != config.picking_type_id.warehouse_id.id
+            )
+
+        # Suppliers
+        key = itemgetter('partner_id')
+        supplier_list = []
+        for key, group in groupby(sorted(self.seller_ids, key=key), key=key):
+            for s in list(group):
+                if not ((s.date_start and s.date_start > date.today()) or (s.date_end and s.date_end < date.today()) or (s.min_qty > quantity)):
+                    supplier_list.append({
+                        'name': s.partner_id.name,
+                        'delay': s.delay,
+                        'price': s.price
+                    })
+                    break
+
+        # Variants
+        variant_list = [{'name': attribute_line.attribute_id.name,
+                         'values': [{'name': attr_name, 'search': f'{self.name} {attr_name}'} for attr_name in attribute_line.value_ids.mapped('name')]}
+                        for attribute_line in self.attribute_line_ids]
+
+        return {
+            'all_prices': all_prices,
+            'pricelists': pricelist_list,
+            'warehouses': warehouse_list,
+            'suppliers': supplier_list,
+            'variants': variant_list
+        }

--- a/None
+++ b/addons/point_of_sale/models/product_template.py
@@ -0,0 +1,172 @@
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+from odoo import api, fields, models, _
+from odoo.exceptions import UserError
+from collections import defaultdict
+from odoo.tools import SQL
+
+
+class ProductTemplate(models.Model):
+    _inherit = ['product.template', 'pos.load.mixin']
+
+    available_in_pos = fields.Boolean(string='Available in POS', help='Check if you want this product to appear in the Point of Sale.', default=False)
+    to_weight = fields.Boolean(string='To Weigh With Scale', help="Check if the product should be weighted using the hardware scale integration.")
+    pos_categ_ids = fields.Many2many(
+        'pos.category', string='Point of Sale Category',
+        help="Category used in the Point of Sale.")
+    public_description = fields.Html(
+        string="Product Description",
+        translate=True
+    )
+
+    @api.model
+    def _load_pos_data_domain(self, data):
+        domain = [
+            *self.env['product.template']._check_company_domain(data['pos.config']['data'][0]['company_id']),
+            ('available_in_pos', '=', True),
+            ('sale_ok', '=', True),
+            ('product_variant_ids', '!=', False),
+        ]
+        limited_categories = data['pos.config']['data'][0]['limit_categories']
+        if limited_categories:
+            available_category_ids = data['pos.config']['data'][0]['iface_available_categ_ids']
+            category_ids = self.env['pos.category'].browse(available_category_ids)._get_descendants().ids
+            domain += [('pos_categ_ids', 'in', category_ids)]
+        return domain
+
+    @api.model
+    def _load_pos_data_fields(self, config_id):
+        return [
+            'id', 'display_name', 'standard_price', 'categ_id', 'pos_categ_ids', 'taxes_id', 'barcode', 'name', 'list_price',
+            'default_code', 'to_weight', 'uom_id', 'description_sale', 'description', 'tracking', 'type', 'service_tracking', 'is_storable',
+            'write_date', 'available_in_pos', 'attribute_line_ids', 'active', 'image_128', 'combo_ids', 'product_variant_ids',
+        ]
+
+    def _load_pos_data(self, data):
+        # Add custom fields for 'formula' taxes.
+        fields = set(self._load_pos_data_fields(data['pos.config']['data'][0]['id']))
+        taxes = self.env['account.tax'].search(self.env['account.tax']._load_pos_data_domain(data))
+        product_fields = taxes._eval_taxes_computation_prepare_product_fields()
+        fields = list(fields.union(product_fields))
+
+        config = self.env['pos.config'].browse(data['pos.config']['data'][0]['id'])
+        limit_count = config.get_limited_product_count()
+        if limit_count:
+            query = self._where_calc(self._load_pos_data_domain(data))
+            sql = SQL(
+                """
+                    WITH pm AS (
+                        SELECT pp.product_tmpl_id,
+                            MAX(sml.write_date) date
+                        FROM stock_move_line sml
+                        JOIN product_product pp ON sml.product_id = pp.id
+                        GROUP BY pp.product_tmpl_id
+                    )
+                    SELECT product_template.id
+                        FROM %s
+                    LEFT JOIN pm ON product_template.id = pm.product_tmpl_id
+                        WHERE %s
+                    ORDER BY product_template.is_favorite DESC,
+                        CASE WHEN product_template.type = 'service' THEN 1 ELSE 0 END DESC,
+                        pm.date DESC NULLS LAST,
+                        product_template.write_date DESC
+                    LIMIT %s
+                """,
+                query.from_clause,
+                query.where_clause or SQL("TRUE"),
+                self.get_limited_product_count(),
+            )
+            product_tmpl_ids = [r[0] for r in self.env.execute_query(sql)]
+            products = self._load_product_with_domain([('id', 'in', product_tmpl_ids)])
+            product_combo = products.filtered(lambda p: p['type'] == 'combo')
+            products += product_combo.combo_ids.combo_item_ids.product_id.product_tmpl_id
+        else:
+            domain = self._load_pos_data_domain(data)
+            products = self._load_product_with_domain(domain)
+
+        data['pos.config']['data'][0]['_product_default_values'] = \
+            self.env['account.tax']._eval_taxes_computation_prepare_product_default_values(product_fields)
+
+        products += config._get_special_products().product_tmpl_id
+        if config.tip_product_id:
+            products += config.tip_product_id.product_tmpl_id
+
+        fields = self._load_pos_data_fields(config.id)
+        available_products = products.read(fields, load=False)
+        self._process_pos_ui_product_product(available_products, config)
+        return {
+            'data': available_products,
+            'fields': fields,
+        }
+
+    def _load_product_with_domain(self, domain, load_archived=False):
+        context = {**self.env.context, 'display_default_code': False, 'active_test': not load_archived}
+        return self.with_context(context).search(
+            domain,
+            order='sequence,default_code,name')
+
+    def get_limited_product_count(self):
+        default_limit = 20000
+        config_param = self.env['ir.config_parameter'].sudo().get_param('point_of_sale.limited_product_count', default_limit)
+        try:
+            return int(config_param)
+        except (TypeError, ValueError, OverflowError):
+            return default_limit
+
+    def _process_pos_ui_product_product(self, products, config_id):
+
+        def filter_taxes_on_company(product_taxes, taxes_by_company):
+            """
+            Filter the list of tax ids on a single company starting from the current one.
+            If there is no tax in the result, it's filtered on the parent company and so
+            on until a non empty result is found.
+            """
+            taxes, comp = None, self.env.company
+            while not taxes and comp:
+                taxes = list(set(product_taxes) & set(taxes_by_company[comp.id]))
+                comp = comp.parent_id
+            return taxes
+
+        taxes = self.env['account.tax'].search(self.env['account.tax']._check_company_domain(self.env.company))
+        # group all taxes by company in a dict where:
+        # - key: ID of the company
+        # - values: list of tax ids
+        taxes_by_company = defaultdict(set)
+        if self.env.company.parent_id:
+            for tax in taxes:
+                taxes_by_company[tax.company_id.id].add(tax.id)
+
+        different_currency = config_id.currency_id != self.env.company.currency_id
+        for product in products:
+            if different_currency:
+                product['lst_price'] = self.env.company.currency_id._convert(product['lst_price'], config_id.currency_id, self.env.company, fields.Date.today())
+            product['image_128'] = bool(product['image_128'])
+
+            if len(taxes_by_company) > 1 and len(product['taxes_id']) > 1:
+                product['taxes_id'] = filter_taxes_on_company(product['taxes_id'], taxes_by_company)
+
+    @api.ondelete(at_uninstall=False)
+    def _unlink_except_open_session(self):
+        product_ctx = dict(self.env.context or {}, active_test=False)
+        if self.with_context(product_ctx).search_count([('id', 'in', self.ids), ('available_in_pos', '=', True)]):
+            if self.env['pos.session'].sudo().search_count([('state', '!=', 'closed')]):
+                raise UserError(_("To delete a product, make sure all point of sale sessions are closed.\n\n"
+                    "Deleting a product available in a session would be like attempting to snatch a"
+                    "hamburger from a customer’s hand mid-bite; chaos will ensue as ketchup and mayo go flying everywhere!"))
+
+    @api.onchange('sale_ok')
+    def _onchange_sale_ok(self):
+        if not self.sale_ok:
+            self.available_in_pos = False
+
+    @api.onchange('available_in_pos')
+    def _onchange_available_in_pos(self):
+        if self.available_in_pos and not self.sale_ok:
+            self.sale_ok = True
+
+    @api.constrains('available_in_pos')
+    def _check_combo_inclusions(self):
+        for product in self:
+            if not product.available_in_pos:
+                combo_name = self.env['product.combo.item'].sudo().search([('product_id', 'in', product.product_variant_ids.ids)], limit=1).combo_id.name
+                if combo_name:
+                    raise UserError(_('You must first remove this product from the %s combo', combo_name))

--- a/None
+++ b/addons/point_of_sale/models/uom.py
@@ -0,0 +1,34 @@
+from odoo import api, fields, models
+
+
+class UomCategory(models.Model):
+    _inherit = ['uom.category', 'pos.load.mixin']
+
+    is_pos_groupable = fields.Boolean(string='Group Products in POS',
+        help="Check if you want to group products of this category in point of sale orders")
+
+    @api.model
+    def _load_pos_data_domain(self, data):
+        return [('uom_ids', 'in', [uom['category_id'] for uom in data['uom.uom']['data']])]
+
+    @api.model
+    def _load_pos_data_fields(self, config_id):
+        return ['id', 'name', 'uom_ids']
+
+
+class UomUom(models.Model):
+    _inherit = ['uom.uom', 'pos.load.mixin']
+
+    is_pos_groupable = fields.Boolean(related='category_id.is_pos_groupable', readonly=False)
+
+    @api.model
+    def _load_pos_data_fields(self, config_id):
+        return ['id', 'name', 'category_id', 'factor_inv', 'factor', 'is_pos_groupable', 'uom_type', 'rounding']
+
+    def _load_pos_data(self, data):
+        domain = self._load_pos_data_domain(data)
+        fields = self._load_pos_data_fields(data['pos.config']['data'][0]['id'])
+        return {
+            'data': self.with_context({**self.env.context}).search_read(domain, fields, load=False),
+            'fields': fields,
+        }
