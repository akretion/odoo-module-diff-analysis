PR: https://github.com/odoo/odoo/pull/83465

From: 99b56ec7069b4d34ae1fc04305d3876c98648f51
From: Nicolas Pierre
Date: 2022-04-11 09:01:50

Structural Changes: 10
Total Changes: 118

[IMP] mrp_subcontracting: subcontracting portal

Creation of a subcontracting portal to let the subcontractor register himself
all the components that were used for the production. The portal is
reusing the backend view of the stock picking where components were
registered before.

closes odoo/odoo#83465

Task: 2645298
Community-pr:  https://github.com/odoo/odoo/pull/83465
Enterprise-pr: https://github.com/odoo/enterprise/pull/24647
Related: odoo/upgrade#3402
Related: odoo/enterprise#24647
Signed-off-by: Arnold Moyaux <arm@odoo.com>

================================= pseudo patch: =================================

--- a/addons/mrp_subcontracting/models/__init__.py
+++ b/addons/mrp_subcontracting/models/__init__.py
@@ -4,6 +4,7 @@ from . import mrp_bom
 from . import product
 from . import res_company
 from . import res_partner
+from . import stock_location
 from . import stock_move
 from . import stock_move_line
 from . import stock_picking

--- a/addons/mrp_subcontracting/models/mrp_production.py
+++ b/addons/mrp_subcontracting/models/mrp_production.py
@@ -3,7 +3,7 @@
 
 from collections import defaultdict
 from odoo import fields, models, _, api
-from odoo.exceptions import UserError, ValidationError
+from odoo.exceptions import UserError, ValidationError, AccessError
 from odoo.tools.float_utils import float_compare, float_is_zero
 
 
@@ -16,6 +16,8 @@ class MrpProduction(models.Model):
         inverse='_inverse_move_line_raw_ids', compute='_compute_move_line_raw_ids'
     )
     subcontracting_has_been_recorded = fields.Boolean("Has been recorded?", copy=False)
+    subcontractor_id = fields.Many2one('res.partner', string="Subcontractor", help="Used to restrict access to the portal user through Record Rules")
+    bom_product_ids = fields.Many2many('product.product', compute="_compute_bom_product_ids", help="List of Products used in the BoM, used to filter the list of products in the subcontracting portal view")
 
     incoming_picking = fields.Many2one(related='move_finished_ids.move_dest_ids.picking_id')
 
@@ -31,6 +33,10 @@ class MrpProduction(models.Model):
         for production in self:
             production.move_line_raw_ids = production.move_raw_ids.move_line_ids
 
+    def _compute_bom_product_ids(self):
+        for production in self:
+            production.bom_product_ids = production.bom_id.bom_line_ids.product_id
+
     def _inverse_move_line_raw_ids(self):
         for production in self:
             line_by_product = defaultdict(lambda: self.env['stock.move.line'])
@@ -45,6 +51,13 @@ class MrpProduction(models.Model):
                 production.move_raw_ids = [(0, 0, move)]
                 production.move_raw_ids.filtered(lambda m: m.product_id == product_id)[:1].move_line_ids = lines
 
+    def write(self, vals):
+        if self.env.user.has_group('base.group_portal') and not self.env.su:
+            unauthorized_fields = set(vals.keys()) - set(self._get_writeable_fields_portal_user())
+            if unauthorized_fields:
+                raise AccessError(_("You cannot write on fields %s in mrp.production.", ', '.join(unauthorized_fields)))
+        return super().write(vals)
+
     def action_merge(self):
         if any(production._get_subcontract_move() for production in self):
             raise ValidationError(_("Subcontracted manufacturing orders cannot be merged."))
@@ -72,7 +85,7 @@ class MrpProduction(models.Model):
 
         quantity_issues = self._get_quantity_produced_issues()
         if quantity_issues:
-            backorder = self._split_productions()[1:]
+            backorder = self.sudo()._split_productions()[1:]
             # No qty to consume to avoid propagate additional move
             # TODO avoid : stock move created in backorder with 0 as qty
             backorder.move_raw_ids.filtered(lambda m: m.additional).product_uom_qty = 0.0
@@ -175,5 +188,14 @@ class MrpProduction(models.Model):
     def _has_tracked_component(self):
         return any(m.has_tracking != 'none' for m in self.move_raw_ids)
 
+    def _has_workorders(self):
+        if self.subcontractor_id:
+            return False
+        else:
+            return super()._has_workorders()
+
     def _get_subcontract_move(self):
         return self.move_finished_ids.move_dest_ids.filtered(lambda m: m.is_subcontract)
+
+    def _get_writeable_fields_portal_user(self):
+        return ['move_line_raw_ids', 'lot_producing_id', 'subcontracting_has_been_recorded', 'qty_producing', 'product_qty']

--- a/addons/mrp_subcontracting/models/res_partner.py
+++ b/addons/mrp_subcontracting/models/res_partner.py
@@ -1,7 +1,7 @@
 # -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
-from odoo import fields, models
+from odoo import api, fields, models
 
 
 class ResPartner(models.Model):
@@ -12,7 +12,37 @@ class ResPartner(models.Model):
         help="The stock location used as source and destination when sending\
         goods to this contact during a subcontracting process.")
     is_subcontractor = fields.Boolean(
-        string="Subcontractor", store=False, search="_search_is_subcontractor")
+        string="Subcontractor", store=False, search="_search_is_subcontractor", compute="_compute_is_subcontractor")
+    bom_ids = fields.Many2many('mrp.bom', compute='_compute_bom_ids', string="BoMs for which the Partner is one of the subcontractors")
+    production_ids = fields.Many2many('mrp.production', compute='_compute_production_ids', string="MRP Productions for which the Partner is the subcontractor")
+    picking_ids = fields.Many2many('stock.picking', compute='_compute_picking_ids', string="Stock Pickings for which the Partner is the subcontractor")
+
+    def _compute_bom_ids(self):
+        results = self.env['mrp.bom'].read_group([('subcontractor_ids.commercial_partner_id', 'in', self.commercial_partner_id.ids)], ['ids:array_agg(id)', 'subcontractor_ids'], ['subcontractor_ids'])
+        for partner in self:
+            bom_ids = []
+            for res in results:
+                if partner.id == res['subcontractor_ids'][0] or res['subcontractor_ids'][0] in partner.child_ids.ids:
+                    bom_ids += res['ids']
+            partner.bom_ids = bom_ids
+
+    def _compute_production_ids(self):
+        results = self.env['mrp.production'].read_group([('subcontractor_id.commercial_partner_id', 'in', self.commercial_partner_id.ids)], ['ids:array_agg(id)'], ['subcontractor_id'])
+        for partner in self:
+            production_ids = []
+            for res in results:
+                if partner.id == res['subcontractor_id'][0] or res['subcontractor_id'][0] in partner.child_ids.ids:
+                    production_ids += res['ids']
+            partner.production_ids = production_ids
+
+    def _compute_picking_ids(self):
+        results = self.env['stock.picking'].read_group([('partner_id.commercial_partner_id', 'in', self.commercial_partner_id.ids)], ['ids:array_agg(id)'], ['partner_id'])
+        for partner in self:
+            picking_ids = []
+            for res in results:
+                if partner.id == res['partner_id'][0] or res['partner_id'][0] in partner.child_ids.ids:
+                    picking_ids += res['ids']
+            partner.picking_ids = picking_ids
 
     def _search_is_subcontractor(self, operator, value):
         assert operator in ('=', '!=', '<>') and value in (True, False), 'Operation not supported'
@@ -23,3 +53,13 @@ class ResPartner(models.Model):
         else:
             search_operator = 'not in'
         return [('id', search_operator, subcontractor_ids)]
+
+    @api.depends_context('uid')
+    def _compute_is_subcontractor(self):
+        """ Check if the user is a subcontractor before giving sudo access
+        """
+        for partner in self:
+            partner.is_subcontractor = (partner.user_has_groups('base.group_portal') and partner.env['mrp.bom'].search_count([
+                ('type', '=', 'subcontract'),
+                ('subcontractor_ids', 'in', (partner.env.user.partner_id | partner.env.user.partner_id.commercial_partner_id).ids),
+            ]))

--- a/None
+++ b/addons/mrp_subcontracting/models/stock_location.py
@@ -0,0 +1,15 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from odoo import models
+
+
+class StockLocation(models.Model):
+    _inherit = 'stock.location'
+
+    def _check_access_putaway(self):
+        """ Use sudo mode for subcontractor """
+        if self.env.user.partner_id.is_subcontractor:
+            return self.sudo()
+        else:
+            return super()._check_access_putaway()

--- a/addons/mrp_subcontracting/models/stock_move.py
+++ b/addons/mrp_subcontracting/models/stock_move.py
@@ -3,8 +3,8 @@
 
 from collections import defaultdict
 
-from odoo import fields, models, _
-from odoo.exceptions import UserError
+from odoo import fields, models, api, _
+from odoo.exceptions import UserError, AccessError
 from odoo.tools.float_utils import float_compare, float_is_zero
 
 
@@ -37,6 +37,9 @@ class StockMove(models.Model):
         for move in self:
             if not move.is_subcontract:
                 continue
+            if self.env.user.has_group('base.group_portal'):
+                move.show_details_visible = any(not p._has_been_recorded() for p in move._get_subcontract_production())
+                continue
             if not move._get_subcontract_production()._has_tracked_component():
                 continue
             move.show_details_visible = True
@@ -55,6 +58,7 @@ class StockMove(models.Model):
         """ If the initial demand is updated then also update the linked
         subcontract order to the new quantity.
         """
+        self._check_access_if_subcontractor(values)
         if 'product_uom_qty' in values and self.env.context.get('cancel_backorder') is not False:
             self.filtered(lambda m: m.is_subcontract and m.state not in ['draft', 'cancel', 'done'])._update_subcontract_order_qty(values['product_uom_qty'])
         res = super().write(values)
@@ -68,6 +72,12 @@ class StockMove(models.Model):
                 })
         return res
 
+    @api.model_create_multi
+    def create(self, vals_list):
+        for vals in vals_list:
+            self._check_access_if_subcontractor(vals)
+        return super().create(vals_list)
+
     def action_show_details(self):
         """ Open the produce wizard in order to register tracked components for
         subcontracted product. Otherwise use standard behavior.
@@ -82,6 +92,11 @@ class StockMove(models.Model):
                 'show_lots_m2o': self.has_tracking != 'none',
                 'show_lots_text': False,
             })
+        elif self.env.user.has_group('base.group_portal'):
+            if self.picking_type_id.show_reserved:
+                action['views'] = [(self.env.ref('mrp_subcontracting.mrp_subcontracting_view_stock_move_operations').id, 'form')]
+            else:
+                action['views'] = [(self.env.ref('mrp_subcontracting.mrp_subcontracting_view_stock_move_nosuggest_operations').id, 'form')]
         return action
 
     def action_show_subcontract_details(self):
@@ -90,6 +105,9 @@ class StockMove(models.Model):
         tree_view = self.env.ref('mrp_subcontracting.mrp_subcontracting_move_tree_view')
         form_view = self.env.ref('mrp_subcontracting.mrp_subcontracting_move_form_view')
         ctx = dict(self._context, search_default_by_product=True)
+        if self.env.user.has_group('base.group_portal'):
+            form_view = self.env.ref('mrp_subcontracting.mrp_subcontracting_portal_move_form_view')
+            ctx.update(no_breadcrumbs=False)
         return {
             'name': _('Raw Materials for %s') % (self.product_id.display_name),
             'type': 'ir.actions.act_window',
@@ -147,6 +165,8 @@ class StockMove(models.Model):
         self.ensure_one()
         production = self._get_subcontract_production()[-1:]
         view = self.env.ref('mrp_subcontracting.mrp_production_subcontracting_form_view')
+        if self.env.user.has_group('base.group_portal'):
+            view = self.env.ref('mrp_subcontracting.mrp_production_subcontracting_portal_form_view')
         return {
             'name': _('Subcontract'),
             'type': 'ir.actions.act_window',
@@ -221,3 +241,8 @@ class StockMove(models.Model):
                         'mo_id': production.id,
                         'product_qty': production.product_uom_qty - quantity_to_remove
                     }).change_prod_qty()
+
+    def _check_access_if_subcontractor(self, vals):
+        if self.env.user.has_group('base.group_portal') and not self.env.su:
+            if vals.get('state') == 'done':
+                raise AccessError(_("Portal users cannot create a stock move with a state 'Done' or change the current state to 'Done'."))

--- a/addons/mrp_subcontracting/models/stock_picking.py
+++ b/addons/mrp_subcontracting/models/stock_picking.py
@@ -10,6 +10,7 @@ from dateutil.relativedelta import relativedelta
 
 
 class StockPicking(models.Model):
+    _name = 'stock.picking'
     _inherit = 'stock.picking'
 
     display_action_record_components = fields.Selection(
@@ -123,6 +124,8 @@ class StockPicking(models.Model):
         vals = {
             'company_id': subcontract_move.company_id.id,
             'procurement_group_id': group.id,
+            'subcontractor_id': subcontract_move.picking_id.partner_id.commercial_partner_id.id,
+            'picking_ids': [subcontract_move.picking_id.id],
             'product_id': product.id,
             'product_uom_id': subcontract_move.product_uom.id,
             'bom_id': bom.id,
