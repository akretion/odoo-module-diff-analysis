PR: https://github.com/odoo/odoo/pull/78705

From: b1d185624599b9e4a5457399a99525a04de9d9bb
From: Florian Charlier
Date: 2023-01-10 17:54:28

Structural Changes: 3
Total Changes: 50

[IMP] survey, web: enable chaining question creation

## Survey
Due to the behavior of X2Many fields, the questions created when editing
a survey were not usable immediately after creation to be conditional
triggers for new questions. The whole survey had to be saved first, which
wasn't a smooth experience for the user.

This commit will save the survey and question at several times:

### For each new question added

Similarly to what was implemented for chatbot scripts, enables the
immediate computation of allowed question/answer triggers, permitting their
use when chaining question creation.

This also enables to check the answers "validation" fields immediately, and
activating scoring and add scores to question/answers without requiring the
extra steps of saving and re-entering edit mode for the survey.

### When rows are deleted

This will trigger the immediate removal of the triggers icons on
questions that were triggered by an answer to the deleted question.

### NOT when questions are moved

As there is no convenient way to ensure questions are properly ordered with
respect to their triggers (order dependency) without popping error messages
at every step when reordering questions, we chose to mark the misplaced lines,
missing trigger records or triggers that will be ignored (with the new
`trigger` widget).

This could have been done entirely with 'server' logic, but that would have
required additional saves and cleaning fields even more often, even during a
temporary reordering step, which isn't convenient.

### Misc
Finally, note the extra fields added on the question_and_page_ids field of the
survey form view, required to trigger these fields' update consistently
(required after reordering or removing records which sometimes doesn't occur
without these).

Tests ensuring the behavior of the X2Many (saving parent on open/edit and show
notifications on error) and the trigger widget are included.

## web
To support the functionality described above, we need to allow the caller of
'save' to catch errors to prevent default handling (here to use a notification
instead of an additional Dialog).

Task-2623482
Part of odoo#78705

Part-of: odoo/odoo#78705

================================= pseudo patch: =================================

--- a/addons/survey/models/survey_question.py
+++ b/addons/survey/models/survey_question.py
@@ -144,6 +144,11 @@ class SurveyQuestion(models.Model):
                  '|', \
                      ('sequence', '<', sequence), \
                      '&', ('sequence', '=', sequence), ('id', '<', id)]")
+    allowed_triggering_question_ids = fields.Many2many(
+        'survey.question', string="Allowed Triggering Questions", copy=False, compute="_compute_allowed_triggering_question_ids")
+    is_placed_before_trigger = fields.Boolean(
+        string='Is misplaced?', help="Is this question placed before its trigger question?",
+        compute="_compute_allowed_triggering_question_ids")
     triggering_answer_id = fields.Many2one(
         'survey.question.answer', string="Triggering Answer", copy=False, compute="_compute_triggering_answer_id",
         store=True, readonly=False, help="Answer that will trigger the display of the current question.",
@@ -275,6 +280,51 @@ class SurveyQuestion(models.Model):
             if not question.validation_required or question.question_type not in ['char_box', 'numerical_box', 'date', 'datetime']:
                 question.validation_required = False
 
+    @api.depends('is_conditional', 'survey_id', 'survey_id.question_ids', 'triggering_question_id')
+    def _compute_allowed_triggering_question_ids(self):
+        """ Although the question (and possible trigger questions) sequence
+        is used here, we do not add these fields to the dependency list to
+        avoid cascading rpc calls when reordering questions via the webclient.
+        """
+        conditional_questions = self.filtered(lambda q: q.is_conditional)
+        non_conditional_questions = self - conditional_questions
+        non_conditional_questions.allowed_triggering_question_ids = False
+        non_conditional_questions.is_placed_before_trigger = False
+        if not conditional_questions:
+            return
+
+        possible_trigger_questions = self.search([
+            ('is_page', '=', False),
+            ('question_type', 'in', ['simple_choice', 'multiple_choice']),
+            ('suggested_answer_ids', '!=', False),
+            ('survey_id', 'in', self.survey_id.ids)
+        ])
+        # Using the sequence stored in db is necessary for existing questions that are passed as
+        # NewIds because the sequence provided by the JS client can be incorrect.
+        (conditional_questions | possible_trigger_questions).flush_recordset()
+        self.env.cr.execute(
+            "SELECT id, sequence FROM survey_question WHERE id =ANY(%s)",
+            [conditional_questions.ids]
+        )
+        conditional_questions_sequences = dict(self.env.cr.fetchall())  # id: sequence mapping
+
+        for question in conditional_questions:
+            question_id = question._origin.id
+            if not question_id:  # New question
+                conditional_questions.allowed_triggering_question_ids = possible_trigger_questions
+                question.is_placed_before_trigger = False
+                continue
+
+            question_sequence = conditional_questions_sequences[question_id]
+
+            question.allowed_triggering_question_ids = possible_trigger_questions.filtered(
+                lambda q: q.survey_id.id == question.survey_id._origin.id
+                and (q.sequence < question_sequence or q.sequence == question_sequence and q.id < question_id)
+            )
+            question.is_placed_before_trigger = (
+                question.triggering_question_id
+                and question.triggering_question_id.id not in question.allowed_triggering_question_ids.ids)
+
     @api.depends('is_conditional')
     def _compute_triggering_question_id(self):
         """ Used as an 'onchange' : Reset the triggering question if user uncheck 'Conditional Display'
