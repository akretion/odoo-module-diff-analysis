PR: https://github.com/odoo/odoo/pull/

From: edcb318a8e2563bdcbde4141d3c8319a001e83d5
From: Ravi Gohil
Date: 2016-07-11 08:19:49

Structural Changes: 101
Total Changes: 1150

[MIG] hr_payroll: migration of all directories in new API, except report

================================= pseudo patch: =================================

--- a/addons/hr_payroll/models/hr_payroll.py
+++ b/addons/hr_payroll/models/hr_payroll.py
@@ -2,395 +2,321 @@
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
 import time
-from datetime import date
-from datetime import datetime
-from datetime import timedelta
+from datetime import datetime, timedelta
 from dateutil import relativedelta
 
-from openerp import api, tools
-from openerp.osv import fields, osv
-from openerp.tools.translate import _
-import openerp.addons.decimal_precision as dp
+from odoo import api, fields, models, tools, _
+from odoo.exceptions import UserError, ValidationError
+from odoo.tools.safe_eval import safe_eval as eval
 
-from openerp.tools.safe_eval import safe_eval as eval
-from openerp.exceptions import UserError
+from odoo.addons import decimal_precision as dp
 
-class hr_payroll_structure(osv.osv):
+
+class HrPayrollStructure(models.Model):
     """
     Salary structure used to defined
     - Basic
     - Allowances
     - Deductions
     """
-
     _name = 'hr.payroll.structure'
     _description = 'Salary Structure'
-    _columns = {
-        'name':fields.char('Name', required=True),
-        'code':fields.char('Reference', size=64, required=True),
-        'company_id':fields.many2one('res.company', 'Company', required=True, copy=False),
-        'note': fields.text('Description'),
-        'parent_id':fields.many2one('hr.payroll.structure', 'Parent'),
-        'children_ids':fields.one2many('hr.payroll.structure', 'parent_id', 'Children', copy=True),
-        'rule_ids':fields.many2many('hr.salary.rule', 'hr_structure_salary_rule_rel', 'struct_id', 'rule_id', 'Salary Rules'),
-    }
-
-    def _get_parent(self, cr, uid, context=None):
-        obj_model = self.pool.get('ir.model.data')
-        res = False
-        data_id = obj_model.search(cr, uid, [('model', '=', 'hr.payroll.structure'), ('name', '=', 'structure_base')])
-        if data_id:
-            res = obj_model.browse(cr, uid, data_id[0], context=context).res_id
-        return res
 
-    _defaults = {
-        'company_id': lambda self, cr, uid, context: \
-                self.pool.get('res.users').browse(cr, uid, uid,
-                    context=context).company_id.id,
-        'parent_id': _get_parent,
-    }
-
-    _constraints = [
-        (osv.osv._check_recursion, 'Error ! You cannot create a recursive Salary Structure.', ['parent_id']) 
-    ]
-        
-    def copy(self, cr, uid, id, default=None, context=None):
-        default = dict(default or {},
-                       code=_("%s (copy)") % (self.browse(cr, uid, id, context=context).code))
-        return super(hr_payroll_structure, self).copy(cr, uid, id, default, context=context)
-
-    @api.cr_uid_ids_context
-    def get_all_rules(self, cr, uid, structure_ids, context=None):
+    @api.model
+    def _get_parent(self):
+        return self.env.ref('hr_payroll.structure_base', False)
+
+    name = fields.Char(required=True)
+    code = fields.Char(string='Reference', required=True)
+    company_id = fields.Many2one('res.company', string='Company', required=True,
+        copy=False, default=lambda self: self.env['res.company']._company_default_get())
+    note = fields.Text(string='Description')
+    parent_id = fields.Many2one('hr.payroll.structure', string='Parent', default=_get_parent)
+    children_ids = fields.One2many('hr.payroll.structure', 'parent_id', string='Children', copy=True)
+    rule_ids = fields.Many2many('hr.salary.rule', 'hr_structure_salary_rule_rel', 'struct_id', 'rule_id', string='Salary Rules')
+
+    @api.constrains('parent_id')
+    def _check_parent_id(self):
+        if not self._check_recursion():
+            raise ValidationError(_('Error ! You cannot create a recursive Salary Structure.'))
+
+    @api.multi
+    def copy(self, default=None):
+        self.ensure_one()
+        default = dict(default or {}, code=_("%s (copy)") % (self.code))
+        return super(HrPayrollStructure, self).copy(default)
+
+    @api.multi
+    def get_all_rules(self):
         """
-        @param structure_ids: list of structure
         @return: returns a list of tuple (id, sequence) of rules that are maybe to apply
         """
-
         all_rules = []
-        for struct in self.browse(cr, uid, structure_ids, context=context):
-            all_rules += self.pool.get('hr.salary.rule')._recursive_search_of_rules(cr, uid, struct.rule_ids, context=context)
+        for struct in self:
+            all_rules += struct.rule_ids._recursive_search_of_rules()
         return all_rules
 
-    @api.cr_uid_ids_context
-    def _get_parent_structure(self, cr, uid, struct_ids, context=None):
-        if not struct_ids:
-            return []
-        parent = []
-        for struct in self.browse(cr, uid, struct_ids, context=context):
-            if struct.parent_id:
-                parent.append(struct.parent_id.id)
+    @api.multi
+    def _get_parent_structure(self):
+        parent = self.mapped('parent_id')
         if parent:
-            parent = self._get_parent_structure(cr, uid, parent, context)
-        return parent + struct_ids
+            parent = parent._get_parent_structure()
+        return parent + self
 
 
-class hr_contract(osv.osv):
+class HrContract(models.Model):
     """
     Employee contract based on the visa, work permits
     allows to configure different Salary structure
     """
-
     _inherit = 'hr.contract'
     _description = 'Employee Contract'
-    _columns = {
-        'struct_id': fields.many2one('hr.payroll.structure', 'Salary Structure'),
-        'schedule_pay': fields.selection([
-            ('monthly', 'Monthly'),
-            ('quarterly', 'Quarterly'),
-            ('semi-annually', 'Semi-annually'),
-            ('annually', 'Annually'),
-            ('weekly', 'Weekly'),
-            ('bi-weekly', 'Bi-weekly'),
-            ('bi-monthly', 'Bi-monthly'),
-            ], 'Scheduled Pay', select=True),
-    }
-
-    _defaults = {
-        'schedule_pay': 'monthly',
-    }
-
-    @api.cr_uid_ids_context
-    def get_all_structures(self, cr, uid, contract_ids, context=None):
+
+    struct_id = fields.Many2one('hr.payroll.structure', string='Salary Structure')
+    schedule_pay = fields.Selection([
+        ('monthly', 'Monthly'),
+        ('quarterly', 'Quarterly'),
+        ('semi-annually', 'Semi-annually'),
+        ('annually', 'Annually'),
+        ('weekly', 'Weekly'),
+        ('bi-weekly', 'Bi-weekly'),
+        ('bi-monthly', 'Bi-monthly'),
+    ], string='Scheduled Pay', index=True, default='monthly')
+
+    @api.multi
+    def get_all_structures(self):
         """
-        @param contract_ids: list of contracts
-        @return: the structures linked to the given contracts, ordered by hierachy (parent=False first, then first level children and so on) and without duplicata
+        @return: the structures linked to the given contracts, ordered by hierachy (parent=False first,
+                 then first level children and so on) and without duplicata
         """
-        structure_ids = [contract.struct_id.id for contract in self.browse(cr, uid, contract_ids, context=context) if contract.struct_id]
-        if not structure_ids:
+        structures = self.mapped('struct_id')
+        if not structures:
             return []
-        return list(set(self.pool.get('hr.payroll.structure')._get_parent_structure(cr, uid, structure_ids, context=context)))
-
+        # YTI TODO return browse records
+        return list(set(structures._get_parent_structure().ids))
 
-class contrib_register(osv.osv):
-    '''
-    Contribution Register
-    '''
 
+class HrContributionRegister(models.Model):
     _name = 'hr.contribution.register'
     _description = 'Contribution Register'
 
-    _columns = {
-        'company_id':fields.many2one('res.company', 'Company'),
-        'partner_id':fields.many2one('res.partner', 'Partner'),
-        'name':fields.char('Name', required=True, readonly=False),
-        'register_line_ids':fields.one2many('hr.payslip.line', 'register_id', 'Register Line', readonly=True),
-        'note': fields.text('Description'),
-    }
-    _defaults = {
-        'company_id': lambda self, cr, uid, context: \
-                self.pool.get('res.users').browse(cr, uid, uid,
-                    context=context).company_id.id,
-    }
-
-
-class hr_salary_rule_category(osv.osv):
-    """
-    HR Salary Rule Category
-    """
+    company_id = fields.Many2one('res.company', string='Company',
+        default=lambda self: self.env['res.company']._company_default_get())
+    partner_id = fields.Many2one('res.partner', string='Partner')
+    name = fields.Char(required=True)
+    register_line_ids = fields.One2many('hr.payslip.line', 'register_id',
+        string='Register Line', readonly=True)
+    note = fields.Text(string='Description')
 
+
+class HrSalaryRuleCategory(models.Model):
     _name = 'hr.salary.rule.category'
     _description = 'Salary Rule Category'
-    _columns = {
-        'name':fields.char('Name', required=True, readonly=False),
-        'code':fields.char('Code', size=64, required=True, readonly=False),
-        'parent_id':fields.many2one('hr.salary.rule.category', 'Parent', help="Linking a salary category to its parent is used only for the reporting purpose."),
-        'children_ids': fields.one2many('hr.salary.rule.category', 'parent_id', 'Children'),
-        'note': fields.text('Description'),
-        'company_id':fields.many2one('res.company', 'Company', required=False),
-    }
-
-    _defaults = {
-        'company_id': lambda self, cr, uid, context: \
-                self.pool.get('res.users').browse(cr, uid, uid,
-                    context=context).company_id.id,
-    }
-
-
-class one2many_mod2(fields.one2many):
-
-    def get(self, cr, obj, ids, name, user=None, offset=0, context=None, values=None):
-        if context is None:
-            context = {}
-        if not values:
-            values = {}
-        res = {}
-        for id in ids:
-            res[id] = []
-        ids2 = obj.pool[self._obj].search(cr, user, [(self._fields_id,'in',ids), ('appears_on_payslip', '=', True)], limit=self._limit)
-        for r in obj.pool[self._obj].read(cr, user, ids2, [self._fields_id], context=context, load='_classic_write'):
-            key = r[self._fields_id]
-            if isinstance(key, tuple):
-                # Read return a tuple in the case where the field is a many2one
-                # but we want to get the id of this field.
-                key = key[0]
-
-            res[key].append( r['id'] )
-        return res
 
-class hr_payslip_run(osv.osv):
+    name = fields.Char(required=True)
+    code = fields.Char(required=True)
+    parent_id = fields.Many2one('hr.salary.rule.category', string='Parent',
+        help="Linking a salary category to its parent is used only for the reporting purpose.")
+    children_ids = fields.One2many('hr.salary.rule.category', 'parent_id', string='Children')
+    note = fields.Text(string='Description')
+    company_id = fields.Many2one('res.company', string='Company',
+        default=lambda self: self.env['res.company']._company_default_get())
+
 
+class HrPayslipRun(models.Model):
     _name = 'hr.payslip.run'
     _description = 'Payslip Batches'
-    _columns = {
-        'name': fields.char('Name', required=True, readonly=True, states={'draft': [('readonly', False)]}),
-        'slip_ids': fields.one2many('hr.payslip', 'payslip_run_id', 'Payslips', required=False, readonly=True, states={'draft': [('readonly', False)]}),
-        'state': fields.selection([
-            ('draft', 'Draft'),
-            ('close', 'Close'),
-        ], 'Status', select=True, readonly=True, copy=False),
-        'date_start': fields.date('Date From', required=True, readonly=True, states={'draft': [('readonly', False)]}),
-        'date_end': fields.date('Date To', required=True, readonly=True, states={'draft': [('readonly', False)]}),
-        'credit_note': fields.boolean('Credit Note', readonly=True, states={'draft': [('readonly', False)]}, help="If its checked, indicates that all payslips generated from here are refund payslips."),
-    }
-    _defaults = {
-        'state': 'draft',
-        'date_start': lambda *a: time.strftime('%Y-%m-01'),
-        'date_end': lambda *a: str(datetime.now() + relativedelta.relativedelta(months=+1, day=1, days=-1))[:10],
-    }
-
-    def draft_payslip_run(self, cr, uid, ids, context=None):
-        return self.write(cr, uid, ids, {'state': 'draft'}, context=context)
-
-    def close_payslip_run(self, cr, uid, ids, context=None):
-        return self.write(cr, uid, ids, {'state': 'close'}, context=context)
-
-
-class hr_payslip(osv.osv):
-    '''
-    Pay Slip
-    '''
 
+    name = fields.Char(required=True, readonly=True, states={'draft': [('readonly', False)]})
+    slip_ids = fields.One2many('hr.payslip', 'payslip_run_id', string='Payslips', readonly=True,
+        states={'draft': [('readonly', False)]})
+    state = fields.Selection([
+        ('draft', 'Draft'),
+        ('close', 'Close'),
+    ], string='Status', index=True, readonly=True, copy=False, default='draft')
+    date_start = fields.Date(string='Date From', required=True, readonly=True,
+        states={'draft': [('readonly', False)]}, default=time.strftime('%Y-%m-01'))
+    date_end = fields.Date(string='Date To', required=True, readonly=True,
+        states={'draft': [('readonly', False)]},
+        default=str(datetime.now() + relativedelta.relativedelta(months=+1, day=1, days=-1))[:10])
+    credit_note = fields.Boolean(string='Credit Note', readonly=True,
+        states={'draft': [('readonly', False)]},
+        help="If its checked, indicates that all payslips generated from here are refund payslips.")
+
+    @api.multi
+    def draft_payslip_run(self):
+        return self.write({'state': 'draft'})
+
+    @api.multi
+    def close_payslip_run(self):
+        return self.write({'state': 'close'})
+
+
+class HrPayslip(models.Model):
     _name = 'hr.payslip'
     _description = 'Pay Slip'
 
-    def _get_lines_salary_rule_category(self, cr, uid, ids, field_names, arg=None, context=None):
-        result = {}
-        if not ids: return result
-        for id in ids:
-            result.setdefault(id, [])
-        cr.execute('''SELECT pl.slip_id, pl.id FROM hr_payslip_line AS pl \
-                    LEFT JOIN hr_salary_rule_category AS sh on (pl.category_id = sh.id) \
-                    WHERE pl.slip_id in %s \
-                    GROUP BY pl.slip_id, pl.sequence, pl.id ORDER BY pl.sequence''',(tuple(ids),))
-        res = cr.fetchall()
-        for r in res:
-            result[r[0]].append(r[1])
-        return result
-    
-    def _count_detail_payslip(self, cr, uid, ids, field_name, arg, context=None):
-        res = {}
-        for details in self.browse(cr, uid, ids, context=context):
-            res[details.id] = len(details.line_ids)
-        return res
-
-    _columns = {
-        'struct_id': fields.many2one('hr.payroll.structure', 'Structure', readonly=True, states={'draft': [('readonly', False)]}, help='Defines the rules that have to be applied to this payslip, accordingly to the contract chosen. If you let empty the field contract, this field isn\'t mandatory anymore and thus the rules applied will be all the rules set on the structure of all contracts of the employee valid for the chosen period'),
-        'name': fields.char('Payslip Name', required=False, readonly=True, states={'draft': [('readonly', False)]}),
-        'number': fields.char('Reference', required=False, readonly=True, states={'draft': [('readonly', False)]}, copy=False),
-        'employee_id': fields.many2one('hr.employee', 'Employee', required=True, readonly=True, states={'draft': [('readonly', False)]}),
-        'date_from': fields.date('Date From', readonly=True, states={'draft': [('readonly', False)]}, required=True),
-        'date_to': fields.date('Date To', readonly=True, states={'draft': [('readonly', False)]}, required=True),
-        'state': fields.selection([
-            ('draft', 'Draft'),
-            ('verify', 'Waiting'),
-            ('done', 'Done'),
-            ('cancel', 'Rejected'),
-        ], 'Status', select=True, readonly=True, copy=False,
-            help='* When the payslip is created the status is \'Draft\'.\
-            \n* If the payslip is under verification, the status is \'Waiting\'. \
-            \n* If the payslip is confirmed then status is set to \'Done\'.\
-            \n* When user cancel payslip the status is \'Rejected\'.'),
-        'line_ids': one2many_mod2('hr.payslip.line', 'slip_id', 'Payslip Lines', readonly=True, states={'draft':[('readonly',False)]}),
-        'company_id': fields.many2one('res.company', 'Company', required=False, readonly=True, states={'draft': [('readonly', False)]}, copy=False),
-        'worked_days_line_ids': fields.one2many('hr.payslip.worked_days', 'payslip_id', 'Payslip Worked Days', copy=True, required=False, readonly=True, states={'draft': [('readonly', False)]}),
-        'input_line_ids': fields.one2many('hr.payslip.input', 'payslip_id', 'Payslip Inputs', required=False, readonly=True, states={'draft': [('readonly', False)]}),
-        'paid': fields.boolean('Made Payment Order ? ', required=False, readonly=True, states={'draft': [('readonly', False)]}, copy=False),
-        'note': fields.text('Internal Note', readonly=True, states={'draft':[('readonly',False)]}),
-        'contract_id': fields.many2one('hr.contract', 'Contract', required=False, readonly=True, states={'draft': [('readonly', False)]}),
-        'details_by_salary_rule_category': fields.function(_get_lines_salary_rule_category, method=True, type='one2many', relation='hr.payslip.line', string='Details by Salary Rule Category'),
-        'credit_note': fields.boolean('Credit Note', help="Indicates this payslip has a refund of another", readonly=True, states={'draft': [('readonly', False)]}),
-        'payslip_run_id': fields.many2one('hr.payslip.run', 'Payslip Batches', readonly=True, states={'draft': [('readonly', False)]}, copy=False),
-        'payslip_count': fields.function(_count_detail_payslip, type='integer', string="Payslip Computation Details"),
-    }
-    _defaults = {
-        'date_from': lambda *a: time.strftime('%Y-%m-01'),
-        'date_to': lambda *a: str(datetime.now() + relativedelta.relativedelta(months=+1, day=1, days=-1))[:10],
-        'state': 'draft',
-        'credit_note': False,
-        'company_id': lambda self, cr, uid, context: \
-                self.pool.get('res.users').browse(cr, uid, uid,
-                    context=context).company_id.id,
-    }
-
-    def _check_dates(self, cr, uid, ids, context=None):
-        for payslip in self.browse(cr, uid, ids, context=context):
-            if payslip.date_from > payslip.date_to:
-                return False
-        return True
-
-    _constraints = [(_check_dates, "Payslip 'Date From' must be before 'Date To'.", ['date_from', 'date_to'])]
-
-    def cancel_sheet(self, cr, uid, ids, context=None):
-        return self.write(cr, uid, ids, {'state': 'cancel'}, context=context)
-
-    def process_sheet(self, cr, uid, ids, context=None):
-        return self.write(cr, uid, ids, {'paid': True, 'state': 'done'}, context=context)
-
-    def hr_verify_sheet(self, cr, uid, ids, context=None):
-        self.compute_sheet(cr, uid, ids, context)
-        return self.write(cr, uid, ids, {'state': 'verify'}, context=context)
-
-    def refund_sheet(self, cr, uid, ids, context=None):
-        mod_obj = self.pool.get('ir.model.data')
-        for payslip in self.browse(cr, uid, ids, context=context):
-            id_copy = self.copy(cr, uid, payslip.id, {'credit_note': True, 'name': _('Refund: ')+payslip.name}, context=context)
-            self.signal_workflow(cr, uid, [id_copy], 'hr_verify_sheet')
-            self.signal_workflow(cr, uid, [id_copy], 'process_sheet')
-            
-        form_id = mod_obj.get_object_reference(cr, uid, 'hr_payroll', 'view_hr_payslip_form')
-        form_res = form_id and form_id[1] or False
-        tree_id = mod_obj.get_object_reference(cr, uid, 'hr_payroll', 'view_hr_payslip_tree')
-        tree_res = tree_id and tree_id[1] or False
+    struct_id = fields.Many2one('hr.payroll.structure', string='Structure',
+        readonly=True, states={'draft': [('readonly', False)]},
+        help='Defines the rules that have to be applied to this payslip, accordingly '
+             'to the contract chosen. If you let empty the field contract, this field isn\'t '
+             'mandatory anymore and thus the rules applied will be all the rules set on the '
+             'structure of all contracts of the employee valid for the chosen period')
+    name = fields.Char(string='Payslip Name', readonly=True,
+        states={'draft': [('readonly', False)]})
+    number = fields.Char(string='Reference', readonly=True, copy=False,
+        states={'draft': [('readonly', False)]})
+    employee_id = fields.Many2one('hr.employee', string='Employee', required=True, readonly=True,
+        states={'draft': [('readonly', False)]})
+    date_from = fields.Date(string='Date From', readonly=True, required=True,
+        default=time.strftime('%Y-%m-01'), states={'draft': [('readonly', False)]})
+    date_to = fields.Date(string='Date To', readonly=True, required=True,
+        default=str(datetime.now() + relativedelta.relativedelta(months=+1, day=1, days=-1))[:10],
+        states={'draft': [('readonly', False)]})
+    state = fields.Selection([
+        ('draft', 'Draft'),
+        ('verify', 'Waiting'),
+        ('done', 'Done'),
+        ('cancel', 'Rejected'),
+    ], string='Status', index=True, readonly=True, copy=False, default='draft',
+        help="""* When the payslip is created the status is \'Draft\'
+                \n* If the payslip is under verification, the status is \'Waiting\'.
+                \n* If the payslip is confirmed then status is set to \'Done\'.
+                \n* When user cancel payslip the status is \'Rejected\'.""")
+    line_ids = fields.One2many('hr.payslip.line', 'slip_id', string='Payslip Lines', readonly=True,
+        states={'draft': [('readonly', False)]}, domain=[('appears_on_payslip', '=', True)])
+    company_id = fields.Many2one('res.company', string='Company', readonly=True, copy=False,
+        default=lambda self: self.env['res.company']._company_default_get(),
+        states={'draft': [('readonly', False)]})
+    worked_days_line_ids = fields.One2many('hr.payslip.worked_days', 'payslip_id',
+        string='Payslip Worked Days', copy=True, readonly=True,
+        states={'draft': [('readonly', False)]})
+    input_line_ids = fields.One2many('hr.payslip.input', 'payslip_id', string='Payslip Inputs',
+        readonly=True, states={'draft': [('readonly', False)]})
+    paid = fields.Boolean(string='Made Payment Order ? ', readonly=True, copy=False,
+        states={'draft': [('readonly', False)]})
+    note = fields.Text(string='Internal Note', readonly=True, states={'draft': [('readonly', False)]})
+    contract_id = fields.Many2one('hr.contract', string='Contract', readonly=True,
+        states={'draft': [('readonly', False)]})
+    details_by_salary_rule_category = fields.One2many('hr.payslip.line',
+        compute='_compute_details_by_salary_rule_category', string='Details by Salary Rule Category')
+    credit_note = fields.Boolean(string='Credit Note', readonly=True,
+        states={'draft': [('readonly', False)]},
+        help="Indicates this payslip has a refund of another")
+    payslip_run_id = fields.Many2one('hr.payslip.run', string='Payslip Batches', readonly=True,
+        copy=False, states={'draft': [('readonly', False)]})
+    payslip_count = fields.Integer(compute='_compute_payslip_count', string="Payslip Computation Details")
+
+    @api.multi
+    def _compute_details_by_salary_rule_category(self):
+        for payslip in self:
+            payslip.details_by_salary_rule_category = payslip.mapped('line_ids').filtered(lambda line: line.category_id)
+
+    @api.multi
+    def _compute_payslip_count(self):
+        for payslip in self:
+            payslip.payslip_count = len(payslip.line_ids)
+
+    @api.constrains('date_from', 'date_to')
+    def _check_dates(self):
+        if any(self.filtered(lambda payslip: payslip.date_from > payslip.date_to)):
+            raise ValidationError(_("Payslip 'Date From' must be before 'Date To'."))
+
+    @api.multi
+    def cancel_sheet(self):
+        return self.write({'state': 'cancel'})
+
+    @api.multi
+    def process_sheet(self):
+        return self.write({'paid': True, 'state': 'done'})
+
+    @api.multi
+    def hr_verify_sheet(self):
+        self.compute_sheet()
+        return self.write({'state': 'verify'})
+
+    @api.multi
+    def refund_sheet(self):
+        for payslip in self:
+            copied_payslip = payslip.copy({'credit_note': True, 'name': _('Refund: ') + payslip.name})
+            copied_payslip.signal_workflow('hr_verify_sheet')
+            copied_payslip.signal_workflow('process_sheet')
+        formview_ref = self.env.ref('hr_payroll.view_hr_payslip_form', False)
+        treeview_ref = self.env.ref('hr_payroll.view_hr_payslip_tree', False)
         return {
-            'name':_("Refund Payslip"),
+            'name': ("Refund Payslip"),
             'view_mode': 'tree, form',
             'view_id': False,
             'view_type': 'form',
             'res_model': 'hr.payslip',
             'type': 'ir.actions.act_window',
             'target': 'current',
-            'domain': "[('id', 'in', %s)]" % [id_copy],
-            'views': [(tree_res, 'tree'), (form_res, 'form')],
+            'domain': "[('id', 'in', %s)]" % copied_payslip.ids,
+            'views': [(treeview_ref and treeview_ref.id or False, 'tree'), (formview_ref and formview_ref.id or False, 'form')],
             'context': {}
         }
 
-    def check_done(self, cr, uid, ids, context=None):
+    @api.multi
+    def check_done(self):
         return True
 
-    def unlink(self, cr, uid, ids, context=None):
-        for payslip in self.browse(cr, uid, ids, context=context):
-            if payslip.state not in  ['draft','cancel']:
-                raise UserError(_('You cannot delete a payslip which is not draft or cancelled!'))
-        return super(hr_payslip, self).unlink(cr, uid, ids, context)
+    @api.multi
+    def unlink(self):
+        if any(self.filtered(lambda payslip: payslip.state not in ('draft', 'cancel'))):
+            raise UserError(_('You cannot delete a payslip which is not draft or cancelled!'))
+        return super(HrPayslip, self).unlink()
 
     #TODO move this function into hr_contract module, on hr.employee object
-    def get_contract(self, cr, uid, employee, date_from, date_to, context=None):
+    @api.model
+    def get_contract(self, employee, date_from, date_to):
         """
-        @param employee: browse record of employee
+        @param employee: recordset of employee
         @param date_from: date field
         @param date_to: date field
         @return: returns the ids of all the contracts for the given employee that need to be considered for the given dates
         """
-        contract_obj = self.pool.get('hr.contract')
-        clause = []
         #a contract is valid if it ends between the given dates
-        clause_1 = ['&',('date_end', '<=', date_to),('date_end','>=', date_from)]
+        clause_1 = ['&', ('date_end', '<=', date_to), ('date_end', '>=', date_from)]
         #OR if it starts between the given dates
-        clause_2 = ['&',('date_start', '<=', date_to),('date_start','>=', date_from)]
+        clause_2 = ['&', ('date_start', '<=', date_to), ('date_start', '>=', date_from)]
         #OR if it starts before the date_from and finish after the date_end (or never finish)
-        clause_3 = ['&',('date_start','<=', date_from),'|',('date_end', '=', False),('date_end','>=', date_to)]
-        clause_final =  [('employee_id', '=', employee.id),'|','|'] + clause_1 + clause_2 + clause_3
-        contract_ids = contract_obj.search(cr, uid, clause_final, context=context)
-        return contract_ids
-
-    def compute_sheet(self, cr, uid, ids, context=None):
-        slip_line_pool = self.pool.get('hr.payslip.line')
-        sequence_obj = self.pool.get('ir.sequence')
-        for payslip in self.browse(cr, uid, ids, context=context):
-            number = payslip.number or sequence_obj.next_by_code(cr, uid, 'salary.slip')
+        clause_3 = ['&', ('date_start', '<=', date_from), '|', ('date_end', '=', False), ('date_end', '>=', date_to)]
+        clause_final = [('employee_id', '=', employee.id), '|', '|'] + clause_1 + clause_2 + clause_3
+        return self.env['hr.contract'].search(clause_final).ids
+
+    @api.multi
+    def compute_sheet(self):
+        for payslip in self:
+            number = payslip.number or self.env['ir.sequence'].next_by_code('salary.slip')
             #delete old payslip lines
-            old_slipline_ids = slip_line_pool.search(cr, uid, [('slip_id', '=', payslip.id)], context=context)
-#            old_slipline_ids
-            if old_slipline_ids:
-                slip_line_pool.unlink(cr, uid, old_slipline_ids, context=context)
-            if payslip.contract_id:
-                #set the list of contract for which the rules have to be applied
-                contract_ids = [payslip.contract_id.id]
-            else:
-                #if we don't give the contract, then the rules to apply should be for all current contracts of the employee
-                contract_ids = self.get_contract(cr, uid, payslip.employee_id, payslip.date_from, payslip.date_to, context=context)
-            lines = [(0,0,line) for line in self.pool.get('hr.payslip').get_payslip_lines(cr, uid, contract_ids, payslip.id, context=context)]
-            self.write(cr, uid, [payslip.id], {'line_ids': lines, 'number': number,}, context=context)
+            payslip.line_ids.unlink()
+            # set the list of contract for which the rules have to be applied
+            # if we don't give the contract, then the rules to apply should be for all current contracts of the employee
+            contract_ids = payslip.contract_id.ids or \
+                self.get_contract(payslip.employee_id, payslip.date_from, payslip.date_to)
+            lines = [(0, 0, line) for line in self.get_payslip_lines(contract_ids, payslip.id)]
+            payslip.write({'line_ids': lines, 'number': number})
         return True
 
-    def get_worked_day_lines(self, cr, uid, contract_ids, date_from, date_to, context=None):
+    @api.model
+    def get_worked_day_lines(self, contract_ids, date_from, date_to):
         """
         @param contract_ids: list of contract id
         @return: returns a list of dict containing the input that should be applied for the given contract between date_from and date_to
         """
-        def was_on_leave(employee_id, datetime_day, context=None):
-            res = False
-            day = datetime_day.strftime("%Y-%m-%d")
-            holiday_ids = self.pool.get('hr.holidays').search(cr, uid, [('state','=','validate'),('employee_id','=',employee_id),('type','=','remove'),('date_from','<=',day),('date_to','>=',day)])
-            if holiday_ids:
-                res = self.pool.get('hr.holidays').browse(cr, uid, holiday_ids, context=context)[0].holiday_status_id.name
-            return res
+        def was_on_leave(employee_id, datetime_day):
+            day = fields.Date.to_string(datetime_day)
+            return self.env['hr.holidays'].search([
+                ('state', '=', 'validate'),
+                ('employee_id', '=', employee_id),
+                ('type', '=', 'remove'),
+                ('date_from', '<=', day),
+                ('date_to', '>=', day)
+            ], limit=1).holiday_status_id.name
 
         res = []
-        for contract in self.pool.get('hr.contract').browse(cr, uid, contract_ids, context=context):
-            if not contract.working_hours:
-                #fill only if the contract as a working schedule linked
-                continue
+        #fill only if the contract as a working schedule linked
+        for contract in self.env['hr.contract'].browse(contract_ids).filtered(lambda contract: contract.working_hours):
             attendances = {
                  'name': _("Normal Working Days paid at 100%"),
                  'sequence': 1,
@@ -400,14 +326,14 @@ class hr_payslip(osv.osv):
                  'contract_id': contract.id,
             }
             leaves = {}
-            day_from = datetime.strptime(date_from,"%Y-%m-%d")
-            day_to = datetime.strptime(date_to,"%Y-%m-%d")
+            day_from = fields.Datetime.from_string(date_from)
+            day_to = fields.Datetime.from_string(date_to)
             nb_of_days = (day_to - day_from).days + 1
             for day in range(0, nb_of_days):
-                working_hours_on_day = self.pool.get('resource.calendar').working_hours_on_day(cr, uid, contract.working_hours, day_from + timedelta(days=day), context)
+                working_hours_on_day = self.env['resource.calendar'].working_hours_on_day(contract.working_hours, day_from + timedelta(days=day))
                 if working_hours_on_day:
                     #the employee had to work
-                    leave_type = was_on_leave(contract.employee_id.id, day_from + timedelta(days=day), context=context)
+                    leave_type = was_on_leave(contract.employee_id.id, day_from + timedelta(days=day))
                     if leave_type:
                         #if he was on leave, fill the leaves dict
                         if leave_type in leaves:
@@ -426,32 +352,33 @@ class hr_payslip(osv.osv):
                         #add the input vals to tmp (increment if existing)
                         attendances['number_of_days'] += 1.0
                         attendances['number_of_hours'] += working_hours_on_day
-            leaves = [value for key,value in leaves.items()]
+            leaves = [value for key, value in leaves.items()]
             res += [attendances] + leaves
         return res
 
-    def get_inputs(self, cr, uid, contract_ids, date_from, date_to, context=None):
+    # YTI TODO contract_ids should be a browse record
+    @api.model
+    def get_inputs(self, contract_ids, date_from, date_to):
         res = []
-        contract_obj = self.pool.get('hr.contract')
-        rule_obj = self.pool.get('hr.salary.rule')
 
-        structure_ids = contract_obj.get_all_structures(cr, uid, contract_ids, context=context)
-        rule_ids = self.pool.get('hr.payroll.structure').get_all_rules(cr, uid, structure_ids, context=context)
+        contracts = self.env['hr.contract'].browse(contract_ids)
+        structure_ids = contracts.get_all_structures()
+        rule_ids = self.env['hr.payroll.structure'].browse(structure_ids).get_all_rules()
         sorted_rule_ids = [id for id, sequence in sorted(rule_ids, key=lambda x:x[1])]
-
-        for contract in contract_obj.browse(cr, uid, contract_ids, context=context):
-            for rule in rule_obj.browse(cr, uid, sorted_rule_ids, context=context):
-                if rule.input_ids:
-                    for input in rule.input_ids:
-                        inputs = {
-                             'name': input.name,
-                             'code': input.code,
-                             'contract_id': contract.id,
-                        }
-                        res += [inputs]
+        inputs = self.env['hr.salary.rule'].browse(sorted_rule_ids).mapped('input_ids')
+
+        for contract in contracts:
+            for input in inputs:
+                input_data = {
+                    'name': input.name,
+                    'code': input.code,
+                    'contract_id': contract.id,
+                }
+                res += [input_data]
         return res
 
-    def get_payslip_lines(self, cr, uid, contract_ids, payslip_id, context):
+    @api.model
+    def get_payslip_lines(self, contract_ids, payslip_id):
         def _sum_salary_rule_category(localdict, category, amount):
             if category.parent_id:
                 localdict = _sum_salary_rule_category(localdict, category.parent_id, amount)
@@ -459,10 +386,7 @@ class hr_payslip(osv.osv):
             return localdict
 
         class BrowsableObject(object):
-            def __init__(self, pool, cr, uid, employee_id, dict):
-                self.pool = pool
-                self.cr = cr
-                self.uid = uid
+            def __init__(self, employee_id, dict):
                 self.employee_id = employee_id
                 self.dict = dict
 
@@ -473,28 +397,27 @@ class hr_payslip(osv.osv):
             """a class that will be used into the python code, mainly for usability purposes"""
             def sum(self, code, from_date, to_date=None):
                 if to_date is None:
-                    to_date = datetime.now().strftime('%Y-%m-%d')
-                result = 0.0
-                self.cr.execute("SELECT sum(amount) as sum\
-                            FROM hr_payslip as hp, hr_payslip_input as pi \
-                            WHERE hp.employee_id = %s AND hp.state = 'done' \
-                            AND hp.date_from >= %s AND hp.date_to <= %s AND hp.id = pi.payslip_id AND pi.code = %s",
-                           (self.employee_id, from_date, to_date, code))
-                res = self.cr.fetchone()[0]
-                return res or 0.0
+                    to_date = fields.Date.today()
+                self.env.cr.execute("""
+                    SELECT sum(amount) as sum
+                    FROM hr_payslip as hp, hr_payslip_input as pi
+                    WHERE hp.employee_id = %s AND hp.state = 'done'
+                    AND hp.date_from >= %s AND hp.date_to <= %s AND hp.id = pi.payslip_id AND pi.code = %s""",
+                    (self.employee_id, from_date, to_date, code))
+                return self.env.cr.fetchone()[0] or 0.0
 
         class WorkedDays(BrowsableObject):
             """a class that will be used into the python code, mainly for usability purposes"""
             def _sum(self, code, from_date, to_date=None):
                 if to_date is None:
-                    to_date = datetime.now().strftime('%Y-%m-%d')
-                result = 0.0
-                self.cr.execute("SELECT sum(number_of_days) as number_of_days, sum(number_of_hours) as number_of_hours\
-                            FROM hr_payslip as hp, hr_payslip_worked_days as pi \
-                            WHERE hp.employee_id = %s AND hp.state = 'done'\
-                            AND hp.date_from >= %s AND hp.date_to <= %s AND hp.id = pi.payslip_id AND pi.code = %s",
-                           (self.employee_id, from_date, to_date, code))
-                return self.cr.fetchone()
+                    to_date = fields.Date.today()
+                self.env.cr.execute("""
+                    SELECT sum(number_of_days) as number_of_days, sum(number_of_hours) as number_of_hours
+                    FROM hr_payslip as hp, hr_payslip_worked_days as pi
+                    WHERE hp.employee_id = %s AND hp.state = 'done'
+                    AND hp.date_from >= %s AND hp.date_to <= %s AND hp.id = pi.payslip_id AND pi.code = %s""",
+                    (self.employee_id, from_date, to_date, code))
+                return self.env.cr.fetchone()
 
             def sum(self, code, from_date, to_date=None):
                 res = self._sum(code, from_date, to_date)
@@ -509,63 +432,61 @@ class hr_payslip(osv.osv):
 
             def sum(self, code, from_date, to_date=None):
                 if to_date is None:
-                    to_date = datetime.now().strftime('%Y-%m-%d')
-                self.cr.execute("SELECT sum(case when hp.credit_note = False then (pl.total) else (-pl.total) end)\
-                            FROM hr_payslip as hp, hr_payslip_line as pl \
-                            WHERE hp.employee_id = %s AND hp.state = 'done' \
-                            AND hp.date_from >= %s AND hp.date_to <= %s AND hp.id = pl.slip_id AND pl.code = %s",
+                    to_date = fields.Date.today()
+                self.env.cr.execute("""SELECT sum(case when hp.credit_note = False then (pl.total) else (-pl.total) end)
+                            FROM hr_payslip as hp, hr_payslip_line as pl
+                            WHERE hp.employee_id = %s AND hp.state = 'done'
+                            AND hp.date_from >= %s AND hp.date_to <= %s AND hp.id = pl.slip_id AND pl.code = %s""",
                             (self.employee_id, from_date, to_date, code))
-                res = self.cr.fetchone()
+                res = self.env.cr.fetchone()
                 return res and res[0] or 0.0
 
         #we keep a dict with the result because a value can be overwritten by another rule with the same code
         result_dict = {}
-        rules = {}
-        categories_dict = {}
+        rules_dict = {}
+        worked_days_dict = {}
+        inputs_dict = {}
         blacklist = []
-        payslip_obj = self.pool.get('hr.payslip')
-        inputs_obj = self.pool.get('hr.payslip.worked_days')
-        obj_rule = self.pool.get('hr.salary.rule')
-        payslip = payslip_obj.browse(cr, uid, payslip_id, context=context)
-        worked_days = {}
+        payslip = self.env['hr.payslip'].browse(payslip_id)
         for worked_days_line in payslip.worked_days_line_ids:
-            worked_days[worked_days_line.code] = worked_days_line
-        inputs = {}
+            worked_days_dict[worked_days_line.code] = worked_days_line
         for input_line in payslip.input_line_ids:
-            inputs[input_line.code] = input_line
+            inputs_dict[input_line.code] = input_line
 
-        categories_obj = BrowsableObject(self.pool, cr, uid, payslip.employee_id.id, categories_dict)
-        input_obj = InputLine(self.pool, cr, uid, payslip.employee_id.id, inputs)
-        worked_days_obj = WorkedDays(self.pool, cr, uid, payslip.employee_id.id, worked_days)
-        payslip_obj = Payslips(self.pool, cr, uid, payslip.employee_id.id, payslip)
-        rules_obj = BrowsableObject(self.pool, cr, uid, payslip.employee_id.id, rules)
+        categories = BrowsableObject(payslip.employee_id.id, {})
+        inputs = InputLine(payslip.employee_id.id, inputs_dict)
+        worked_days = WorkedDays(payslip.employee_id.id, worked_days_dict)
+        payslips = Payslips(payslip.employee_id.id, payslip)
+        rules = BrowsableObject(payslip.employee_id.id, rules_dict)
 
-        baselocaldict = {'categories': categories_obj, 'rules': rules_obj, 'payslip': payslip_obj, 'worked_days': worked_days_obj, 'inputs': input_obj}
+        baselocaldict = {'categories': categories, 'rules': rules, 'payslip': payslips, 'worked_days': worked_days, 'inputs': inputs}
         #get the ids of the structures on the contracts and their parent id as well
-        structure_ids = self.pool.get('hr.contract').get_all_structures(cr, uid, contract_ids, context=context)
+        contracts = self.env['hr.contract'].browse(contract_ids)
+        structure_ids = contracts.get_all_structures()
         #get the rules of the structure and thier children
-        rule_ids = self.pool.get('hr.payroll.structure').get_all_rules(cr, uid, structure_ids, context=context)
+        rule_ids = self.env['hr.payroll.structure'].browse(structure_ids).get_all_rules()
         #run the rules by sequence
         sorted_rule_ids = [id for id, sequence in sorted(rule_ids, key=lambda x:x[1])]
+        sorted_rules = self.env['hr.salary.rule'].browse(sorted_rule_ids)
 
-        for contract in self.pool.get('hr.contract').browse(cr, uid, contract_ids, context=context):
+        for contract in contracts:
             employee = contract.employee_id
             localdict = dict(baselocaldict, employee=employee, contract=contract)
-            for rule in obj_rule.browse(cr, uid, sorted_rule_ids, context=context):
+            for rule in sorted_rules:
                 key = rule.code + '-' + str(contract.id)
                 localdict['result'] = None
                 localdict['result_qty'] = 1.0
                 localdict['result_rate'] = 100
                 #check if the rule can be applied
-                if obj_rule.satisfy_condition(cr, uid, rule.id, localdict, context=context) and rule.id not in blacklist:
+                if rule.satisfy_condition(localdict) and rule.id not in blacklist:
                     #compute the amount of the rule
-                    amount, qty, rate = obj_rule.compute_rule(cr, uid, rule.id, localdict, context=context)
+                    amount, qty, rate = rule.compute_rule(localdict)
                     #check if there is already a rule computed with that code
                     previous_amount = rule.code in localdict and localdict[rule.code] or 0.0
                     #set/overwrite the amount computed for this rule in the localdict
                     tot_rule = amount * qty * rate / 100.0
                     localdict[rule.code] = tot_rule
-                    rules[rule.code] = rule
+                    rules_dict[rule.code] = rule
                     #sum the amount for its salary category
                     localdict = _sum_salary_rule_category(localdict, rule.category_id, tot_rule - previous_amount)
                     #create/overwrite the rule in the temporary results
@@ -595,95 +516,83 @@ class hr_payslip(osv.osv):
                     }
                 else:
                     #blacklist this rule and its children
-                    blacklist += [id for id, seq in self.pool.get('hr.salary.rule')._recursive_search_of_rules(cr, uid, [rule], context=context)]
-
-        result = [value for code, value in result_dict.items()]
-        return result
-
-    def onchange_employee_id(self, cr, uid, ids, date_from, date_to, employee_id=False, contract_id=False, context=None):
-        empolyee_obj = self.pool.get('hr.employee')
-        contract_obj = self.pool.get('hr.contract')
-        worked_days_obj = self.pool.get('hr.payslip.worked_days')
-        input_obj = self.pool.get('hr.payslip.input')
-
-        if context is None:
-            context = {}
-        #delete old worked days lines
-        worked_days_ids_to_remove=[]
-        old_worked_days_ids = ids and worked_days_obj.search(cr, uid, [('payslip_id', '=', ids[0])], context=context) or False
-        if old_worked_days_ids:
-            worked_days_ids_to_remove = map(lambda x: (2, x,),old_worked_days_ids)
-
-        #delete old input lines
-        input_line_ids_to_remove=[]
-        old_input_ids = ids and input_obj.search(cr, uid, [('payslip_id', '=', ids[0])], context=context) or False
-        if old_input_ids:
-            input_line_ids_to_remove = map(lambda x: (2,x,), old_input_ids)
+                    blacklist += [id for id, seq in rule._recursive_search_of_rules()]
 
+        return [value for code, value in result_dict.items()]
 
+    # YTI TODO To rename. This method is not really an onchange, as it is not in any view
+    # employee_id and contract_id could be browse records
+    @api.multi
+    def onchange_employee_id(self, date_from, date_to, employee_id=False, contract_id=False):
         #defaults
-        res = {'value':{
-                      'line_ids':[],
-                      'input_line_ids': input_line_ids_to_remove,
-                      'worked_days_line_ids': worked_days_ids_to_remove,
-                      #'details_by_salary_head':[], TODO put me back
-                      'name':'',
-                      'contract_id': False,
-                      'struct_id': False,
-                      }
+        res = {
+            'value': {
+                'line_ids': [],
+                #delete old input lines
+                'input_line_ids': map(lambda x: (2, x,), self.input_line_ids.ids),
+                #delete old worked days lines
+                'worked_days_line_ids': map(lambda x: (2, x,), self.worked_days_line_ids.ids),
+                #'details_by_salary_head':[], TODO put me back
+                'name': '',
+                'contract_id': False,
+                'struct_id': False,
             }
+        }
         if (not employee_id) or (not date_from) or (not date_to):
             return res
         ttyme = datetime.fromtimestamp(time.mktime(time.strptime(date_from, "%Y-%m-%d")))
-        employee_id = empolyee_obj.browse(cr, uid, employee_id, context=context)
+        employee = self.env['hr.employee'].browse(employee_id)
         res['value'].update({
-                    'name': _('Salary Slip of %s for %s') % (employee_id.name, tools.ustr(ttyme.strftime('%B-%Y'))),
-                    'company_id': employee_id.company_id.id
+                    'name': _('Salary Slip of %s for %s') % (employee.name, tools.ustr(ttyme.strftime('%B-%Y'))),
+                    'company_id': employee.company_id.id
         })
 
-        if not context.get('contract', False):
+        if not self.env.context.get('contract'):
             #fill with the first contract of the employee
-            contract_ids = self.get_contract(cr, uid, employee_id, date_from, date_to, context=context)
+            contract_ids = self.get_contract(employee, date_from, date_to)
         else:
             if contract_id:
                 #set the list of contract for which the input have to be filled
                 contract_ids = [contract_id]
             else:
                 #if we don't give the contract, then the input to fill should be for all current contracts of the employee
-                contract_ids = self.get_contract(cr, uid, employee_id, date_from, date_to, context=context)
+                contract_ids = self.get_contract(employee, date_from, date_to)
 
         if not contract_ids:
             return res
-        contract_record = contract_obj.browse(cr, uid, contract_ids[0], context=context)
+        contract = self.env['hr.contract'].browse(contract_ids[0])
         res['value'].update({
-                    'contract_id': contract_record and contract_record.id or False
+            'contract_id': contract.id
         })
-        struct_record = contract_record and contract_record.struct_id or False
-        if not struct_record:
+        struct = contract.struct_id
+        if not struct:
             return res
         res['value'].update({
-                    'struct_id': struct_record.id,
+            'struct_id': struct.id,
         })
         #computation of the salary input
-        worked_days_line_ids = self.get_worked_day_lines(cr, uid, contract_ids, date_from, date_to, context=context)
-        input_line_ids = self.get_inputs(cr, uid, contract_ids, date_from, date_to, context=context)
+        worked_days_line_ids = self.get_worked_day_lines(contract_ids, date_from, date_to)
+        input_line_ids = self.get_inputs(contract_ids, date_from, date_to)
         res['value'].update({
-                    'worked_days_line_ids': worked_days_line_ids,
-                    'input_line_ids': input_line_ids,
+            'worked_days_line_ids': worked_days_line_ids,
+            'input_line_ids': input_line_ids,
         })
         return res
 
-    def onchange_contract_id(self, cr, uid, ids, date_from, date_to, employee_id=False, contract_id=False, context=None):
-#TODO it seems to be the mess in the onchanges, we should have onchange_employee => onchange_contract => doing all the things
-        res = {'value':{
-                 'line_ids': [],
-                 'name': '',
-                 }
-              }
-        context = dict(context or {}, contract=True)
+    # YTO TODO: employee_id and contract_id could be browse records
+    @api.multi
+    def onchange_contract_id(self, date_from, date_to, employee_id=False, contract_id=False):
+        # TODO it seems to be the mess in the onchanges
+        # we should have onchange_employee => onchange_contract => doing all the things
+        res = {
+            'value': {
+                'line_ids': [],
+                'name': '',
+            }
+        }
         if not contract_id:
             res['value'].update({'struct_id': False})
-        return self.onchange_employee_id(cr, uid, ids, date_from=date_from, date_to=date_to, employee_id=employee_id, contract_id=contract_id, context=context)
+        return self.with_context(contract=True).onchange_employee_id(date_from=date_from, date_to=date_to, employee_id=employee_id, contract_id=contract_id)
 
     @api.onchange('employee_id', 'date_from')
     def onchange_employee(self):
@@ -691,19 +600,19 @@ class hr_payslip(osv.osv):
         if (not self.employee_id) or (not self.date_from) or (not self.date_to):
             return
 
-        employee_id = self.employee_id
+        employee = self.employee_id
         date_from = self.date_from
         date_to = self.date_to
 
         ttyme = datetime.fromtimestamp(time.mktime(time.strptime(date_from, "%Y-%m-%d")))
-        self.name = _('Salary Slip of %s for %s') % (employee_id.name, tools.ustr(ttyme.strftime('%B-%Y')))
-        self.company_id = employee_id.company_id
+        self.name = _('Salary Slip of %s for %s') % (employee.name, tools.ustr(ttyme.strftime('%B-%Y')))
+        self.company_id = employee.company_id
 
         if not self.env.context.get('contract') or not self.contract_id:
-            contract_ids = self.get_contract(employee_id, date_from, date_to)
+            contract_ids = self.get_contract(employee, date_from, date_to)
             if not contract_ids:
                 return
-            self.contract_id = self.contract_id.browse(contract_ids[0])
+            self.contract_id = self.env['hr.contract'].browse(contract_ids[0])
 
         if not self.contract_id.struct_id:
             return
@@ -730,254 +639,217 @@ class hr_payslip(osv.osv):
         self.with_context(contract=True).onchange_employee()
         return
 
-class hr_payslip_worked_days(osv.osv):
-    '''
-    Payslip Worked Days
-    '''
 
+class HrPayslipWorkedDays(models.Model):
     _name = 'hr.payslip.worked_days'
     _description = 'Payslip Worked Days'
-    _columns = {
-        'name': fields.char('Description', required=True),
-        'payslip_id': fields.many2one('hr.payslip', 'Pay Slip', required=True, ondelete='cascade', select=True),
-        'sequence': fields.integer('Sequence', required=True, select=True),
-        'code': fields.char('Code', size=52, required=True, help="The code that can be used in the salary rules"),
-        'number_of_days': fields.float('Number of Days'),
-        'number_of_hours': fields.float('Number of Hours'),
-        'contract_id': fields.many2one('hr.contract', 'Contract', required=True, help="The contract for which applied this input"),
-    }
     _order = 'payslip_id, sequence'
-    _defaults = {
-        'sequence': 10,
-    }
 
-class hr_payslip_input(osv.osv):
-    '''
-    Payslip Input
-    '''
+    name = fields.Char(string='Description', required=True)
+    payslip_id = fields.Many2one('hr.payslip', string='Pay Slip', required=True, ondelete='cascade', index=True)
+    sequence = fields.Integer(required=True, index=True, default=10)
+    code = fields.Char(required=True, help="The code that can be used in the salary rules")
+    number_of_days = fields.Float(string='Number of Days')
+    number_of_hours = fields.Float(string='Number of Hours')
+    contract_id = fields.Many2one('hr.contract', string='Contract', required=True,
+        help="The contract for which applied this input")
 
+
+class HrPayslipInput(models.Model):
     _name = 'hr.payslip.input'
     _description = 'Payslip Input'
-    _columns = {
-        'name': fields.char('Description', required=True),
-        'payslip_id': fields.many2one('hr.payslip', 'Pay Slip', required=True, ondelete='cascade', select=True),
-        'sequence': fields.integer('Sequence', required=True, select=True),
-        'code': fields.char('Code', size=52, required=True, help="The code that can be used in the salary rules"),
-        'amount': fields.float('Amount', help="It is used in computation. For e.g. A rule for sales having 1% commission of basic salary for per product can defined in expression like result = inputs.SALEURO.amount * contract.wage*0.01."),
-        'contract_id': fields.many2one('hr.contract', 'Contract', required=True, help="The contract for which applied this input"),
-    }
     _order = 'payslip_id, sequence'
-    _defaults = {
-        'sequence': 10,
-        'amount': 0.0,
-    }
 
+    name = fields.Char(string='Description', required=True)
+    payslip_id = fields.Many2one('hr.payslip', string='Pay Slip', required=True, ondelete='cascade', index=True)
+    sequence = fields.Integer(required=True, index=True, default=10)
+    code = fields.Char(required=True, help="The code that can be used in the salary rules")
+    amount = fields.Float(help="It is used in computation. For e.g. A rule for sales having "
+                               "1% commission of basic salary for per product can defined in expression "
+                               "like result = inputs.SALEURO.amount * contract.wage*0.01.")
+    contract_id = fields.Many2one('hr.contract', string='Contract', required=True,
+        help="The contract for which applied this input")
 
-class hr_salary_rule(osv.osv):
 
+class HrSalaryRule(models.Model):
     _name = 'hr.salary.rule'
-    _columns = {
-        'name':fields.char('Name', required=True, readonly=False),
-        'code':fields.char('Code', size=64, required=True, help="The code of salary rules can be used as reference in computation of other rules. In that case, it is case sensitive."),
-        'sequence': fields.integer('Sequence', required=True, help='Use to arrange calculation sequence', select=True),
-        'quantity': fields.char('Quantity', help=u"It is used in computation for percentage and fixed amount.For e.g. A rule for Meal Voucher having fixed amount of 1 per worked day can have its quantity defined in expression like worked_days.WORK100.number_of_days."),
-        'category_id':fields.many2one('hr.salary.rule.category', 'Category', required=True),
-        'active':fields.boolean('Active', help="If the active field is set to false, it will allow you to hide the salary rule without removing it."),
-        'appears_on_payslip': fields.boolean('Appears on Payslip', help="Used to display the salary rule on payslip."),
-        'parent_rule_id':fields.many2one('hr.salary.rule', 'Parent Salary Rule', select=True),
-        'company_id':fields.many2one('res.company', 'Company', required=False),
-        'condition_select': fields.selection([('none', 'Always True'),('range', 'Range'), ('python', 'Python Expression')], "Condition Based on", required=True),
-        'condition_range':fields.char('Range Based on', readonly=False, help='This will be used to compute the % fields values; in general it is on basic, but you can also use categories code fields in lowercase as a variable names (hra, ma, lta, etc.) and the variable basic.'),
-        'condition_python':fields.text('Python Condition', required=True, readonly=False, help='Applied this rule for calculation if condition is true. You can specify condition like basic > 1000.'),
-        'condition_range_min': fields.float('Minimum Range', required=False, help="The minimum amount, applied for this rule."),
-        'condition_range_max': fields.float('Maximum Range', required=False, help="The maximum amount, applied for this rule."),
-        'amount_select':fields.selection([
-            ('percentage','Percentage (%)'),
-            ('fix','Fixed Amount'),
-            ('code','Python Code'),
-        ],'Amount Type', select=True, required=True, help="The computation method for the rule amount."),
-        'amount_fix': fields.float('Fixed Amount', digits_compute=dp.get_precision('Payroll'),),
-        'amount_percentage': fields.float('Percentage (%)', digits_compute=dp.get_precision('Payroll Rate'), help='For example, enter 50.0 to apply a percentage of 50%'),
-        'amount_python_compute':fields.text('Python Code'),
-        'amount_percentage_base': fields.char('Percentage based on', required=False, readonly=False, help='result will be affected to a variable'),
-        'child_ids':fields.one2many('hr.salary.rule', 'parent_rule_id', 'Child Salary Rule', copy=True),
-        'register_id':fields.many2one('hr.contribution.register', 'Contribution Register', help="Eventual third party involved in the salary payment of the employees."),
-        'input_ids': fields.one2many('hr.rule.input', 'input_id', 'Inputs', copy=True),
-        'note':fields.text('Description'),
-     }
-    _defaults = {
-        'amount_python_compute': '''
-# Available variables:
-#----------------------
-# payslip: object containing the payslips
-# employee: hr.employee object
-# contract: hr.contract object
-# rules: object containing the rules code (previously computed)
-# categories: object containing the computed salary rule categories (sum of amount of all rules belonging to that category).
-# worked_days: object containing the computed worked days.
-# inputs: object containing the computed inputs.
-
-# Note: returned value have to be set in the variable 'result'
-
-result = contract.wage * 0.10''',
-        'condition_python':
-'''
-# Available variables:
-#----------------------
-# payslip: object containing the payslips
-# employee: hr.employee object
-# contract: hr.contract object
-# rules: object containing the rules code (previously computed)
-# categories: object containing the computed salary rule categories (sum of amount of all rules belonging to that category).
-# worked_days: object containing the computed worked days
-# inputs: object containing the computed inputs
-
-# Note: returned value have to be set in the variable 'result'
-
-result = rules.NET > categories.NET * 0.10''',
-        'condition_range': 'contract.wage',
-        'sequence': 5,
-        'appears_on_payslip': True,
-        'active': True,
-        'company_id': lambda self, cr, uid, context: \
-                self.pool.get('res.users').browse(cr, uid, uid,
-                    context=context).company_id.id,
-        'condition_select': 'none',
-        'amount_select': 'fix',
-        'amount_fix': 0.0,
-        'amount_percentage': 0.0,
-        'quantity': '1.0',
-     }
-
-    @api.cr_uid_records_context
-    def _recursive_search_of_rules(self, cr, uid, rule_ids, context=None):
+
+    name = fields.Char(required=True)
+    code = fields.Char(required=True,
+        help="The code of salary rules can be used as reference in computation of other rules. "
+             "In that case, it is case sensitive.")
+    sequence = fields.Integer(required=True, index=True, default=5,
+        help='Use to arrange calculation sequence')
+    quantity = fields.Char(default='1.0',
+        help="It is used in computation for percentage and fixed amount. "
+             "For e.g. A rule for Meal Voucher having fixed amount of "
+             u"1 per worked day can have its quantity defined in expression "
+             "like worked_days.WORK100.number_of_days.")
+    category_id = fields.Many2one('hr.salary.rule.category', string='Category', required=True)
+    active = fields.Boolean(default=True,
+        help="If the active field is set to false, it will allow you to hide the salary rule without removing it.")
+    appears_on_payslip = fields.Boolean(string='Appears on Payslip', default=True,
+        help="Used to display the salary rule on payslip.")
+    parent_rule_id = fields.Many2one('hr.salary.rule', string='Parent Salary Rule', index=True)
+    company_id = fields.Many2one('res.company', string='Company',
+        default=lambda self: self.env['res.company']._company_default_get())
+    condition_select = fields.Selection([
+        ('none', 'Always True'),
+        ('range', 'Range'),
+        ('python', 'Python Expression')
+    ], string="Condition Based on", default='none', required=True)
+    condition_range = fields.Char(string='Range Based on', default='contract.wage',
+        help='This will be used to compute the % fields values; in general it is on basic, '
+             'but you can also use categories code fields in lowercase as a variable names '
+             '(hra, ma, lta, etc.) and the variable basic.')
+    condition_python = fields.Text(string='Python Condition', required=True,
+        default='''
+                    # Available variables:
+                    #----------------------
+                    # payslip: object containing the payslips
+                    # employee: hr.employee object
+                    # contract: hr.contract object
+                    # rules: object containing the rules code (previously computed)
+                    # categories: object containing the computed salary rule categories (sum of amount of all rules belonging to that category).
+                    # worked_days: object containing the computed worked days
+                    # inputs: object containing the computed inputs
+
+                    # Note: returned value have to be set in the variable 'result'
+
+                    result = rules.NET > categories.NET * 0.10''',
+        help='Applied this rule for calculation if condition is true. You can specify condition like basic > 1000.')
+    condition_range_min = fields.Float(string='Minimum Range', help="The minimum amount, applied for this rule.")
+    condition_range_max = fields.Float(string='Maximum Range', help="The maximum amount, applied for this rule.")
+    amount_select = fields.Selection([
+        ('percentage', 'Percentage (%)'),
+        ('fix', 'Fixed Amount'),
+        ('code', 'Python Code'),
+    ], string='Amount Type', index=True, required=True, default='fix', help="The computation method for the rule amount.")
+    amount_fix = fields.Float(string='Fixed Amount', digits_compute=dp.get_precision('Payroll'))
+    amount_percentage = fields.Float(string='Percentage (%)', digits_compute=dp.get_precision('Payroll Rate'),
+        help='For example, enter 50.0 to apply a percentage of 50%')
+    amount_python_compute = fields.Text(string='Python Code',
+        default='''
+                    # Available variables:
+                    #----------------------
+                    # payslip: object containing the payslips
+                    # employee: hr.employee object
+                    # contract: hr.contract object
+                    # rules: object containing the rules code (previously computed)
+                    # categories: object containing the computed salary rule categories (sum of amount of all rules belonging to that category).
+                    # worked_days: object containing the computed worked days.
+                    # inputs: object containing the computed inputs.
+
+                    # Note: returned value have to be set in the variable 'result'
+
+                    result = contract.wage * 0.10''')
+    amount_percentage_base = fields.Char(string='Percentage based on', help='result will be affected to a variable')
+    child_ids = fields.One2many('hr.salary.rule', 'parent_rule_id', string='Child Salary Rule', copy=True)
+    register_id = fields.Many2one('hr.contribution.register', string='Contribution Register',
+        help="Eventual third party involved in the salary payment of the employees.")
+    input_ids = fields.One2many('hr.rule.input', 'input_id', string='Inputs', copy=True)
+    note = fields.Text(string='Description')
+
+    @api.multi
+    def _recursive_search_of_rules(self):
         """
-        @param rule_ids: list of browse record
         @return: returns a list of tuple (id, sequence) which are all the children of the passed rule_ids
         """
         children_rules = []
-        for rule in rule_ids:
-            if rule.child_ids:
-                children_rules += self._recursive_search_of_rules(cr, uid, rule.child_ids, context=context)
-        return [(r.id, r.sequence) for r in rule_ids] + children_rules
+        for rule in self.filtered(lambda rule: rule.child_ids):
+            children_rules += rule.child_ids._recursive_search_of_rules()
+        return [(rule.id, rule.sequence) for rule in self] + children_rules
 
     #TODO should add some checks on the type of result (should be float)
-    def compute_rule(self, cr, uid, rule_id, localdict, context=None):
+    @api.multi
+    def compute_rule(self, localdict):
         """
-        :param rule_id: id of rule to compute
         :param localdict: dictionary containing the environement in which to compute the rule
         :return: returns a tuple build as the base/amount computed, the quantity and the rate
         :rtype: (float, float, float)
         """
-        rule = self.browse(cr, uid, rule_id, context=context)
-        if rule.amount_select == 'fix':
+        self.ensure_one()
+        if self.amount_select == 'fix':
             try:
-                return rule.amount_fix, float(eval(rule.quantity, localdict)), 100.0
+                return self.amount_fix, float(eval(self.quantity, localdict)), 100.0
             except:
-                raise UserError(_('Wrong quantity defined for salary rule %s (%s).') % (rule.name, rule.code))
-        elif rule.amount_select == 'percentage':
+                raise UserError(_('Wrong quantity defined for salary rule %s (%s).') % (self.name, self.code))
+        elif self.amount_select == 'percentage':
             try:
-                return (float(eval(rule.amount_percentage_base, localdict)),
-                        float(eval(rule.quantity, localdict)),
-                        rule.amount_percentage)
+                return (float(eval(self.amount_percentage_base, localdict)),
+                        float(eval(self.quantity, localdict)),
+                        self.amount_percentage)
             except:
-                raise UserError(_('Wrong percentage base or quantity defined for salary rule %s (%s).') % (rule.name, rule.code))
+                raise UserError(_('Wrong percentage base or quantity defined for salary rule %s (%s).') % (self.name, self.code))
         else:
             try:
-                eval(rule.amount_python_compute, localdict, mode='exec', nocopy=True)
+                eval(self.amount_python_compute, localdict, mode='exec', nocopy=True)
                 return float(localdict['result']), 'result_qty' in localdict and localdict['result_qty'] or 1.0, 'result_rate' in localdict and localdict['result_rate'] or 100.0
             except:
-                raise UserError(_('Wrong python code defined for salary rule %s (%s).') % (rule.name, rule.code))
+                raise UserError(_('Wrong python code defined for salary rule %s (%s).') % (self.name, self.code))
 
-    def satisfy_condition(self, cr, uid, rule_id, localdict, context=None):
+    @api.multi
+    def satisfy_condition(self, localdict):
         """
-        @param rule_id: id of hr.salary.rule to be tested
         @param contract_id: id of hr.contract to be tested
         @return: returns True if the given rule match the condition for the given contract. Return False otherwise.
         """
-        rule = self.browse(cr, uid, rule_id, context=context)
+        self.ensure_one()
 
-        if rule.condition_select == 'none':
+        if self.condition_select == 'none':
             return True
-        elif rule.condition_select == 'range':
+        elif self.condition_select == 'range':
             try:
-                result = eval(rule.condition_range, localdict)
-                return rule.condition_range_min <=  result and result <= rule.condition_range_max or False
+                result = eval(self.condition_range, localdict)
+                return self.condition_range_min <= result and result <= self.condition_range_max or False
             except:
-                raise UserError(_('Wrong range condition defined for salary rule %s (%s).') % (rule.name, rule.code))
-        else: #python code
+                raise UserError(_('Wrong range condition defined for salary rule %s (%s).') % (self.name, self.code))
+        else:  # python code
             try:
-                eval(rule.condition_python, localdict, mode='exec', nocopy=True)
+                eval(self.condition_python, localdict, mode='exec', nocopy=True)
                 return 'result' in localdict and localdict['result'] or False
             except:
-                raise UserError(_('Wrong python condition defined for salary rule %s (%s).') % (rule.name, rule.code))
-
+                raise UserError(_('Wrong python condition defined for salary rule %s (%s).') % (self.name, self.code))
 
-class hr_rule_input(osv.osv):
-    '''
-    Salary Rule Input
-    '''
 
+class HrRuleInput(models.Model):
     _name = 'hr.rule.input'
     _description = 'Salary Rule Input'
-    _columns = {
-        'name': fields.char('Description', required=True),
-        'code': fields.char('Code', size=52, required=True, help="The code that can be used in the salary rules"),
-        'input_id': fields.many2one('hr.salary.rule', 'Salary Rule Input', required=True)
-    }
 
+    name = fields.Char(string='Description', required=True)
+    code = fields.Char(required=True, help="The code that can be used in the salary rules")
+    input_id = fields.Many2one('hr.salary.rule', string='Salary Rule Input', required=True)
 
-class hr_payslip_line(osv.osv):
-    '''
-    Payslip Line
-    '''
 
+class HrPayslipLine(models.Model):
     _name = 'hr.payslip.line'
     _inherit = 'hr.salary.rule'
     _description = 'Payslip Line'
     _order = 'contract_id, sequence'
 
-    def _calculate_total(self, cr, uid, ids, name, args, context):
-        if not ids: return {}
-        res = {}
-        for line in self.browse(cr, uid, ids, context=context):
-            res[line.id] = float(line.quantity) * line.amount * line.rate / 100
-        return res
-
-    _columns = {
-        'slip_id':fields.many2one('hr.payslip', 'Pay Slip', required=True, ondelete='cascade'),
-        'salary_rule_id':fields.many2one('hr.salary.rule', 'Rule', required=True),
-        'employee_id':fields.many2one('hr.employee', 'Employee', required=True),
-        'contract_id':fields.many2one('hr.contract', 'Contract', required=True, select=True),
-        'rate': fields.float('Rate (%)', digits_compute=dp.get_precision('Payroll Rate')),
-        'amount': fields.float('Amount', digits_compute=dp.get_precision('Payroll')),
-        'quantity': fields.float('Quantity', digits_compute=dp.get_precision('Payroll')),
-        'total': fields.function(_calculate_total, method=True, type='float', string='Total', digits_compute=dp.get_precision('Payroll'),store=True ),
-    }
+    slip_id = fields.Many2one('hr.payslip', string='Pay Slip', required=True, ondelete='cascade')
+    salary_rule_id = fields.Many2one('hr.salary.rule', string='Rule', required=True)
+    employee_id = fields.Many2one('hr.employee', string='Employee', required=True)
+    contract_id = fields.Many2one('hr.contract', string='Contract', required=True, index=True)
+    rate = fields.Float(string='Rate (%)', digits_compute=dp.get_precision('Payroll Rate'), default=100.0)
+    amount = fields.Float(digits_compute=dp.get_precision('Payroll'))
+    quantity = fields.Float(digits_compute=dp.get_precision('Payroll'), default=1.0)
+    total = fields.Float(compute='_compute_total', string='Total', digits_compute=dp.get_precision('Payroll'), store=True)
 
-    _defaults = {
-        'quantity': 1.0,
-        'rate': 100.0,
-    }
+    @api.depends('quantity', 'amount', 'rate')
+    def _compute_total(self):
+        for line in self:
+            line.total = float(line.quantity) * line.amount * line.rate / 100
 
 
-
-class hr_employee(osv.osv):
-    '''
-    Employee
-    '''
-
+class HrEmployee(models.Model):
     _inherit = 'hr.employee'
     _description = 'Employee'
 
-    def _payslip_count(self, cr, uid, ids, field_name, arg, context=None):
-        Payslip = self.pool['hr.payslip']
-        return {
-            employee_id: Payslip.search_count(cr,uid, [('employee_id', '=', employee_id)], context=context)
-            for employee_id in ids
-        }
+    slip_ids = fields.One2many('hr.payslip', 'employee_id', string='Payslips', readonly=True)
+    payslip_count = fields.Integer(compute='_compute_payslip_count', string='Payslips', groups="base.group_hr_user")
 
-    _columns = {
-        'slip_ids':fields.one2many('hr.payslip', 'employee_id', 'Payslips', required=False, readonly=True),
-        'payslip_count': fields.function(_payslip_count, type='integer', string='Payslips', groups="base.group_hr_user"),
-    }
+    @api.multi
+    def _compute_payslip_count(self):
+        for employee in self:
+            employee.payslip_count = len(employee.slip_ids)

--- a/addons/hr_payroll/models/res_config.py
+++ b/addons/hr_payroll/models/res_config.py
@@ -1,12 +1,12 @@
 # -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
-from openerp.osv import fields, osv
+from odoo import fields, models
 
-class hr_payroll_configuration(osv.osv_memory):
+
+class HrPayrollConfigSettings(models.TransientModel):
     _name = 'hr.payroll.config.settings'
     _inherit = 'res.config.settings'
-    _columns = {
-        'module_hr_payroll_account': fields.boolean('Link your payroll to accounting system',
-            help ="""Create journal entries from payslips"""),
-    }
+
+    module_hr_payroll_account = fields.Boolean(string='Link your payroll to accounting system',
+        help="Create journal entries from payslips")
