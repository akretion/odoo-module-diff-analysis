PR: https://github.com/odoo/odoo/pull/98441

From: 2f5da9729adbb64f48a596a5c1bcea1d1a3b7661
From: Tommy (tong)
Date: 2022-08-30 18:22:44

Structural Changes: 8
Total Changes: 286

[ADD] payment_asiapay: add an integration to AsiaPay

task-2845428

closes odoo/odoo#98441

Related: odoo/documentation#2628
Signed-off-by: Antoine Vandevenne (anv) <anv@odoo.com>
Co-authored-by: Antoine Vandevenne (anv) <anv@odoo.com>

================================= pseudo patch: =================================

--- a/None
+++ b/addons/payment_asiapay/models/__init__.py
@@ -0,0 +1,5 @@
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from . import account_payment_method
+from . import payment_acquirer
+from . import payment_transaction

--- a/None
+++ b/addons/payment_asiapay/models/account_payment_method.py
@@ -0,0 +1,13 @@
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from odoo import api, models
+
+
+class AccountPaymentMethod(models.Model):
+    _inherit = 'account.payment.method'
+
+    @api.model
+    def _get_payment_method_information(self):
+        res = super()._get_payment_method_information()
+        res['asiapay'] = {'mode': 'unique', 'domain': [('type', '=', 'bank')]}
+        return res

--- a/None
+++ b/addons/payment_asiapay/models/payment_acquirer.py
@@ -0,0 +1,102 @@
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from hashlib import new as hashnew
+
+from odoo import api, fields, models
+
+from odoo.addons.payment_asiapay import const
+
+
+class PaymentAcquirer(models.Model):
+    _inherit = 'payment.acquirer'
+
+    def _domain_asiapay_currency_id(self):
+        currency_xmlids = [f'base.{key}' for key in const.CURRENCY_MAPPING]
+        return [('id', 'in', [self.env.ref(xmlid).id for xmlid in currency_xmlids])]
+
+    provider = fields.Selection(
+        selection_add=[('asiapay', "AsiaPay")], ondelete={'asiapay': 'set default'}
+    )
+    asiapay_merchant_id = fields.Char(
+        string="AsiaPay Merchant ID",
+        help="The Merchant ID solely used to identify your AsiaPay account.",
+        required_if_provider='asiapay',
+    )
+    asiapay_currency_id = fields.Many2one(
+        string="AsiaPay Currency",
+        help="The currency associated to your AsiaPay account.",
+        comodel_name='res.currency',
+        domain=_domain_asiapay_currency_id,
+        required_if_provider='asiapay',
+    )
+    asiapay_secure_hash_secret = fields.Char(
+        string="AsiaPay Secure Hash Secret",
+        required_if_provider='asiapay',
+        groups='base.group_system',
+    )
+    asiapay_secure_hash_function = fields.Selection(
+        string="AsiaPay Secure Hash Function",
+        help="The secure hash function associated to your AsiaPay account.",
+        selection=[('sha1', "SHA1"), ('sha256', "SHA256"), ('sha512', 'SHA512')],
+        default='sha1',
+        required_if_provider='asiapay',
+    )
+
+    # === BUSINESS METHODS ===#
+
+    @api.model
+    def _get_compatible_acquirers(self, *args, currency_id=None, **kwargs):
+        """ Override of `payment` to filter out AsiaPay acquirers for unsupported currencies. """
+        acquirers = super()._get_compatible_acquirers(*args, currency_id=currency_id, **kwargs)
+
+        currency = self.env['res.currency'].browse(currency_id).exists()
+        if currency:
+            acquirers = acquirers.filtered(
+                lambda a: a.provider != 'asiapay' or currency == a.asiapay_currency_id
+            )
+
+        return acquirers
+
+    def _asiapay_get_api_url(self):
+        """ Return the URL of the API corresponding to the acquirer's state.
+
+        :return: The API URL.
+        :rtype: str
+        """
+        self.ensure_one()
+
+        if self.state == 'enabled':
+            return 'https://www.paydollar.com/b2c2/eng/payment/payForm.jsp'
+        else:  # 'test'
+            return 'https://test.paydollar.com/b2cDemo/eng/payment/payForm.jsp'
+
+    def _asiapay_calculate_signature(self, data, incoming=True):
+        """ Compute the signature for the provided data according to the AsiaPay documentation.
+
+        :param dict data: The data to sign.
+        :param bool incoming: Whether the signature must be generated for an incoming (AsiaPay to
+                              Odoo) or outgoing (Odoo to AsiaPay) communication.
+        :return: The calculated signature.
+        :rtype: str
+        """
+        signature_keys = const.SIGNATURE_KEYS['incoming' if incoming else 'outgoing']
+        data_to_sign = [str(data[k]) for k in signature_keys] + [self.asiapay_secure_hash_secret]
+        signing_string = '|'.join(data_to_sign)
+        shasign = hashnew(self.asiapay_secure_hash_function)
+        shasign.update(signing_string.encode())
+        return shasign.hexdigest()
+
+    def _get_default_payment_method_id(self):
+        self.ensure_one()
+        if self.provider != 'asiapay':
+            return super()._get_default_payment_method_id()
+        return self.env.ref('payment_asiapay.payment_method_asiapay').id
+
+    def _neutralize(self):
+        super()._neutralize()
+        self._neutralize_fields('asiapay', [
+            'asiapay_merchant_id',
+            'asiapay_currency_id',
+            'asiapay_secure_hash_secret',
+            'asiapay_secure_hash_function',
+        ])

--- a/None
+++ b/addons/payment_asiapay/models/payment_transaction.py
@@ -0,0 +1,166 @@
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+import logging
+
+from werkzeug import urls
+
+from odoo import _, api, models
+from odoo.exceptions import ValidationError
+
+from odoo.addons.payment import utils as payment_utils
+from odoo.addons.payment_asiapay import const
+from odoo.addons.payment_asiapay.controllers.main import AsiaPayController
+
+
+_logger = logging.getLogger(__name__)
+
+
+class PaymentTransaction(models.Model):
+    _inherit = 'payment.transaction'
+
+    @api.model
+    def _compute_reference(self, provider, prefix=None, separator='-', **kwargs):
+        """ Override of `payment` to ensure that AsiaPay requirements for references are satisfied.
+
+        AsiaPay requirements for references are as follows:
+        - References must be unique at provider level for a given merchant account.
+          This is satisfied by singularizing the prefix with the current datetime. If two
+          transactions are created simultaneously, `_compute_reference` ensures the uniqueness of
+          references by suffixing a sequence number.
+        - References must be at most 35 characters long.
+
+        :param str provider: The provider of the acquirer handling the transaction.
+        :param str prefix: The custom prefix used to compute the full reference.
+        :param str separator: The custom separator used to separate the prefix from the suffix.
+        :return: The unique reference for the transaction.
+        :rtype: str
+        """
+        if provider != 'asiapay':
+            return super()._compute_reference(provider, prefix=prefix, **kwargs)
+
+        if not prefix:
+            # If no prefix is provided, it could mean that a module has passed a kwarg intended for
+            # the `_compute_reference_prefix` method, as it is only called if the prefix is empty.
+            # We call it manually here because singularizing the prefix would generate a default
+            # value if it was empty, hence preventing the method from ever being called and the
+            # transaction from received a reference named after the related document.
+            prefix = self.sudo()._compute_reference_prefix(provider, separator, **kwargs) or None
+        prefix = payment_utils.singularize_reference_prefix(prefix=prefix, max_length=35)
+        return super()._compute_reference(provider, prefix=prefix, **kwargs)
+
+    def _get_specific_rendering_values(self, processing_values):
+        """ Override of `payment` to return AsiaPay-specific rendering values.
+
+        Note: self.ensure_one() from `_get_processing_values`.
+
+        :param dict processing_values: The generic and specific processing values of the
+                                       transaction.
+        :return: The dict of acquirer-specific processing values.
+        :rtype: dict
+        """
+        def get_language_code(lang_):
+            """ Return the language code corresponding to the provided lang.
+
+            If the lang is not mapped to any language code, the country code is used instead. In
+            case the country code has no match either, we fall back to English.
+
+            :param str lang_: The lang, in IETF language tag format.
+            :return: The corresponding language code.
+            :rtype: str
+            """
+            language_code_ = const.LANGUAGE_CODES_MAPPING.get(lang_)
+            if not language_code_:
+                country_code_ = lang_.split('_')[0]
+                language_code_ = const.LANGUAGE_CODES_MAPPING.get(country_code_)
+            if not language_code_:
+                language_code_ = const.LANGUAGE_CODES_MAPPING['en']
+            return language_code_
+
+        res = super()._get_specific_rendering_values(processing_values)
+        if self.provider != 'asiapay':
+            return res
+
+        base_url = self.acquirer_id.get_base_url()
+        # The lang is taken from the context rather than from the partner because it is not required
+        # to be logged in to make a payment, and because the lang is not always set on the partner.
+        lang = self._context.get('lang') or 'en_US'
+        rendering_values = {
+            'merchant_id': self.acquirer_id.asiapay_merchant_id,
+            'amount': self.amount,
+            'reference': self.reference,
+            'currency_code': const.CURRENCY_MAPPING[self.acquirer_id.asiapay_currency_id.name],
+            'mps_mode': 'SCP',
+            'return_url': urls.url_join(base_url, AsiaPayController._return_url),
+            'payment_type': 'N',
+            'language': get_language_code(lang),
+            'payment_method': 'ALL',
+        }
+        rendering_values.update({
+            'secure_hash': self.acquirer_id._asiapay_calculate_signature(
+                rendering_values, incoming=False
+            ),
+            'api_url': self.acquirer_id._asiapay_get_api_url()
+        })
+        return rendering_values
+
+    def _get_tx_from_notification_data(self, provider, notification_data):
+        """ Override of `payment` to find the transaction based on AsiaPay data.
+
+        :param str provider: The provider of the acquirer that handled the transaction.
+        :param dict notification_data: The notification data sent by the provider.
+        :return: The transaction if found.
+        :rtype: recordset of `payment.transaction`
+        :raise ValidationError: If inconsistent data are received.
+        :raise ValidationError: If the data match no transaction.
+        """
+        tx = super()._get_tx_from_notification_data(provider, notification_data)
+        if provider != 'asiapay' or len(tx) == 1:
+            return tx
+
+        reference = notification_data.get('Ref')
+        if not reference:
+            raise ValidationError(
+                "AsiaPay: " + _("Received data with missing reference %(ref)s.", ref=reference)
+            )
+
+        tx = self.search([('reference', '=', reference), ('provider', '=', 'asiapay')])
+        if not tx:
+            raise ValidationError(
+                "AsiaPay: " + _("No transaction found matching reference %s.", reference)
+            )
+
+        return tx
+
+    def _process_notification_data(self, notification_data):
+        """ Override of `payment' to process the transaction based on AsiaPay data.
+
+        Note: self.ensure_one()
+
+        :param dict notification_data: The notification data sent by the provider.
+        :return: None
+        :raise ValidationError: If inconsistent data are received.
+        """
+        super()._process_notification_data(notification_data)
+        if self.provider != 'asiapay':
+            return
+
+        self.acquirer_reference = notification_data.get('PayRef')
+
+        success_code = notification_data.get('successcode')
+        primary_response_code = notification_data.get('prc')
+        if not success_code:
+            raise ValidationError("AsiaPay: " + _("Received data with missing success code."))
+
+        if success_code in const.SUCCESS_CODE_MAPPING['done']:
+            self._set_done()
+        elif success_code in const.SUCCESS_CODE_MAPPING['error']:
+            self._set_error(_(
+                "An error occurred during the processing of your payment (success code %s; primary "
+                "response code %s). Please try again.", success_code, primary_response_code
+            ))
+        else:
+            _logger.warning(
+                "Received data with invalid success code (%s) for transaction with primary response "
+                "code %s and reference %s.", success_code, primary_response_code, self.reference
+            )
+            self._set_error("AsiaPay: " + _("Unknown success code: %s", success_code))
