PR: https://github.com/odoo/odoo/pull/

From: bdebcab0cea467e070c1936fed16173247abafdd
From: Thibault Delavallée
Date: 2019-07-12 14:54:11

Structural Changes: 14
Total Changes: 444

[REF] sms: refactor message_post using SMS notifications

Purpose of this commit is to better include SMS notifications when posting a
message. SMS is now just another way of notifying people along with Inbox and
email. Following recent mail merge improving notification mechanism [1] we
have to define a _notify_record_by_sms method on mail.thread.

When a message_post is done using message_type being ``sms`` notification type
of customers is set to sms. Customers can be computed on model (generally based
on partner_id field) or directly set usign partner°ids. Notification model is
updated to store this information directly inside the notification itself.

An new ``_message_sms`` helper method is introduced in SMS module allowing
to send messages using sms type and notification with a reduced parameters
number. It is just a shortcut to message_post, easier to use. Either it
computes default recipients on the record set, either it is based on given
partners and numbers to notify.

The following use cases are notably supported

  * default computation: find customer, notify by sms;
  * force recipients to notify by sms (partner_ids);
  * give a set of numbers to notify by sms (sms_nubmers), not necessarily
    linked to existing partners;
  * force number / customer relationship independently of mobile number defined
    on customer (for example when sending an SMS directly from a mobile field
    on a lead linked to a customer);

Tests are updated accordingly. Performance tests are added in order to have
some insights on queries generated when sending SMS, like already done for
mail.thread alone.

Related to task 1922163
Linked to PR #33510

[1] see be2795513644f09f6b443f462bb67cc5a0762e8d: performance and notification code improvements

Co-Authored-By: Thibault Delavallee <tde@odoo.com>
Co-Authored-By: Pierre Rousseau <pro@odoo.com>

================================= pseudo patch: =================================

--- a/addons/sms/models/__init__.py
+++ b/addons/sms/models/__init__.py
@@ -1,6 +1,10 @@
 # -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
+from . import mail_followers
+from . import mail_message
+from . import mail_notification
 from . import mail_thread
 from . import res_partner
 from . import sms_api
+from . import sms_sms

--- a/None
+++ b/addons/sms/models/mail_followers.py
@@ -0,0 +1,24 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from odoo import api, fields, models
+
+
+class Followers(models.Model):
+    _inherit = ['mail.followers']
+
+    def _get_recipient_data(self, records, message_type, subtype_id, pids=None, cids=None):
+        if message_type == 'sms':
+            if pids is None:
+                sms_pids = records._sms_get_default_partners().ids
+            else:
+                sms_pids = pids
+            res = super(Followers, self)._get_recipient_data(records, message_type, subtype_id, pids=pids, cids=cids)
+            new_res = []
+            for pid, cid, pactive, pshare, ctype, notif, groups in res:
+                if pid and pid in sms_pids:
+                    notif = 'sms'
+                new_res.append((pid, cid, pactive, pshare, ctype, notif, groups))
+            return new_res
+        else:
+            return super(Followers, self)._get_recipient_data(records, message_type, subtype_id, pids=pids, cids=cids)

--- a/None
+++ b/addons/sms/models/mail_message.py
@@ -0,0 +1,13 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from odoo import api, fields, models
+
+
+class MailMessage(models.Model):
+    """ Override MailMessage class in order to add a new type: SMS messages.
+    Those messages comes with their own notification method, using SMS
+    gateway. """
+    _inherit = 'mail.message'
+
+    message_type = fields.Selection(selection_add=[('sms', 'SMS')])

--- a/None
+++ b/addons/sms/models/mail_notification.py
@@ -0,0 +1,18 @@
+# -*- coding: utf-8 -*-
+
+from odoo import api, fields, models
+from odoo.tools.translate import _
+
+
+class Notification(models.Model):
+    _inherit = 'mail.notification'
+
+    notification_type = fields.Selection(selection_add=[('sms', 'SMS')])
+    sms_id = fields.Many2one('sms.sms', string='SMS', index=True, ondelete='set null')
+    sms_number = fields.Char('SMS Number')
+    failure_type = fields.Selection(selection_add=[
+        ('sms_number_missing', 'Missing Number'),
+        ('sms_number_format', 'Wrong Number Format'),
+        ('sms_credit', 'Insufficient Credit'),
+        ('sms_server', 'Server Error')]
+    )

--- a/addons/sms/models/mail_thread.py
+++ b/addons/sms/models/mail_thread.py
@@ -3,9 +3,9 @@
 
 import logging
 
-from odoo import models, _
-
-from odoo.addons.iap.models.iap import InsufficientCreditError
+from odoo import api, models
+from odoo.addons.phone_validation.tools import phone_validation
+from odoo.tools import html2plaintext
 
 _logger = logging.getLogger(__name__)
 
@@ -13,7 +13,7 @@ _logger = logging.getLogger(__name__)
 class MailThread(models.AbstractModel):
     _inherit = 'mail.thread'
 
-    def _get_default_sms_recipients(self):
+    def _sms_get_default_partners(self):
         """ This method will likely need to be overriden by inherited models.
                :returns partners: recordset of res.partner
         """
@@ -24,36 +24,210 @@ class MailThread(models.AbstractModel):
             partners |= self.mapped('partner_ids')
         return partners
 
-    def message_post_send_sms(self, sms_message, numbers=None, partners=None, note_msg=None, log_error=False):
-        """ Send an SMS text message and post an internal note in the chatter if successfull
-            :param sms_message: plaintext message to send by sms
-            :param partners: the numbers to send to, if none are given it will take those
-                                from partners or _get_default_sms_recipients
-            :param partners: the recipients partners, if none are given it will take those
-                                from _get_default_sms_recipients, this argument
-                                is ignored if numbers is defined
-            :param note_msg: message to log in the chatter, if none is given a default one
-                             containing the sms_message is logged
+    def _sms_get_number_fields(self):
+        """ This method returns the fields to use to find the number to use to
+        send an SMS on a record. """
+        return ['mobile']
+
+    def _sms_get_recipients_info(self, force_field=False):
+        """" Get SMS recipient information on current record set. This method
+        checks for numbers and sanitation in order to centralize computation.
+
+        Example of use cases
+
+          * click on a field -> number is actually forced from field, find customer
+            linked to record, force its number to field or fallback on customer fields;
+          * contact -> find numbers from all possible phone fields on record, find
+            customer, force its number to found field number or fallback on customer fields;
+
+        :return dict: record.id: {
+            'partner': a res.partner recordset that is the customer (void or singleton);
+            'sanitized': sanitized number to use (coming from record's field or partner's mobile
+              or phone). Set to False is number impossible to parse and format;
+            'number': original number before sanitation;
+        } for each record in self
+        """
+        result = dict.fromkeys(self.ids, False)
+        number_fields = self._sms_get_number_fields()
+        for record in self:
+            tocheck_fields = [force_field] if force_field else number_fields
+            all_numbers = [record[fname] for fname in tocheck_fields if fname in record]
+            all_partners = record._sms_get_default_partners()
+
+            valid_number = False
+            for fname in [f for f in tocheck_fields if f in record]:
+                valid_number = phone_validation.phone_get_sanitized_record_number(record, number_fname=fname)
+                if valid_number:
+                    break
+
+            if valid_number:
+                result[record.id] = {
+                    'partner': all_partners[0] if all_partners else self.env['res.partner'],
+                    'sanitized': valid_number, 'number': valid_number,
+                }
+            elif all_partners:
+                partner_number, partner = False, self.env['res.partner']
+                for partner in all_partners:
+                    partner_number = partner.mobile or partner.phone
+                    if partner_number:
+                        partner_number = phone_validation.phone_sanitize_numbers_string_w_record(partner_number, record)[partner_number]['sanitized']
+                    if partner_number:
+                        break
+
+                if partner_number:
+                    result[record.id] = {'partner': partner, 'sanitized': partner_number, 'number': partner_number}
+                else:
+                    result[record.id] = {'partner': partner, 'sanitized': False, 'number': partner.mobile or partner.phone}
+            elif all_numbers:
+                result[record.id] = {'partner': self.env['res.partner'], 'sanitized': False, 'number': all_numbers[0]}
+            else:
+                result[record.id] = {'partner': self.env['res.partner'], 'sanitized': False, 'number': False}
+        return result
+
+    def _message_sms(self, body, subtype_id=False, partner_ids=False, number_field=False,
+                     sms_numbers=None, sms_pid_to_number=None, **kwargs):
+        """ Main method to post a message on a record using SMS-based notification
+        method.
+
+        :param body: content of SMS;
+        :param subtype_id: mail.message.subtype used in mail.message associated
+          to the sms notification process;
+        :param partner_ids: if set is a record set of partners to notify;
+        :param number_field: if set is a name of field to use on current record
+          to compute a number to notify;
+        :param sms_numbers: see ``_notify_record_by_sms``;
+        :param sms_pid_to_number: see ``_notify_record_by_sms``;
+        """
+        self.ensure_one()
+        sms_pid_to_number = sms_pid_to_number if sms_pid_to_number is not None else {}
+
+        if number_field or (partner_ids is False and sms_numbers is None):
+            info = self._sms_get_recipients_info(force_field=number_field)[self.id]
+            info_partner_ids = info['partner'].ids if info['partner'] else False
+            info_number = info['sanitized'] if info['sanitized'] else info['number']
+            if info_partner_ids and info_number:
+                sms_pid_to_number[info_partner_ids[0]] = info_number
+            if info_partner_ids:
+                partner_ids = info_partner_ids + (partner_ids or [])
+            if info_number and not info_partner_ids:
+                sms_numbers = [info_number] + (sms_numbers or [])
+
+        if subtype_id is False:
+            subtype_id = self.env['ir.model.data'].xmlid_to_res_id('mail.mt_comment')
+
+        return self.message_post(
+            body=body, partner_ids=partner_ids or [],  # TDE FIXME: temp fix otherwise crash mail_thread.py
+            message_type='sms', subtype_id=subtype_id,
+            sms_numbers=sms_numbers, sms_pid_to_number=sms_pid_to_number,
+            **kwargs
+        )
+
+    @api.multi
+    def _notify_thread(self, message, msg_vals=False, **kwargs):
+        recipients_data = super(MailThread, self)._notify_thread(message, msg_vals=msg_vals, **kwargs)
+        self._notify_record_by_sms(message, recipients_data, msg_vals=msg_vals, **kwargs)
+        return recipients_data
+
+    @api.multi
+    def _notify_record_by_sms(self, message, recipients_data, msg_vals=False,
+                              sms_numbers=None, sms_pid_to_number=None,
+                              check_existing=False, put_in_queue=False, **kwargs):
+        """ Notification method: by SMS.
+
+        :param message: mail.message record to notify;
+        :param recipients_data: see ``_notify_thread``;
+        :param msg_vals: see ``_notify_thread``;
+
+        :param sms_numbers: additional numbers to notify in addition to partners
+          and classic recipients;
+        :param pid_to_number: force a number to notify for a given partner ID
+              instead of taking its mobile / phone number;
+        :param check_existing: check for existing notifications to update based on
+          mailed recipient, otherwise create new notifications;
+        :param put_in_queue: use cron to send queued SMS instead of sending them
+          directly;
         """
-        if not numbers:
-            if not partners:
-                partners = self._get_default_sms_recipients()
-
-            # Collect numbers, we will consider the message to be sent if at least one number can be found
-            numbers = list(set([i.mobile for i in partners if i.mobile]))
-
-        if numbers:
-            try:
-                self.env['sms.api']._send_sms(numbers, sms_message)
-                mail_message = note_msg or _('SMS message sent: %s') % sms_message
-
-            except InsufficientCreditError as e:
-                if not log_error:
-                    raise e
-                mail_message = _('Insufficient credit, unable to send SMS message: %s') % sms_message
-        else:
-            mail_message = _('No mobile number defined, unable to send SMS message: %s') % sms_message
-
-        for thread in self:
-            thread.message_post(body=mail_message)
-        return False
+        sms_pid_to_number = sms_pid_to_number if sms_pid_to_number is not None else {}
+        sms_numbers = sms_numbers if sms_numbers is not None else []
+        sms_create_vals = []
+        sms_all = self.env['sms.sms'].sudo()
+
+        # pre-compute SMS data
+        body = msg_vals['body'] if msg_vals and msg_vals.get('body') else message.body
+        sms_base_vals = {
+            'body': html2plaintext(body).rstrip('\n'),
+            'mail_message_id': message.id,
+            'state': 'outgoing',
+        }
+
+        # notify from computed recipients_data (followers, specific recipients)
+        partners_data = [r for r in recipients_data['partners'] if r['notif'] == 'sms']
+        partner_ids = [r['id'] for r in partners_data]
+        if partner_ids:
+            for partner in self.env['res.partner'].sudo().browse(partner_ids):
+                number = sms_pid_to_number.get(partner.id) or partner.mobile or partner.phone
+                sanitize_res = phone_validation.phone_sanitize_numbers_string_w_record(number, partner)[number]
+                number = sanitize_res['sanitized'] or number
+                sms_create_vals.append(dict(
+                    sms_base_vals,
+                    partner_id=partner.id,
+                    number=number
+                ))
+
+        # notify from additional numbers
+        if sms_numbers:
+            sanitized = phone_validation.phone_sanitize_numbers_w_record(sms_numbers, self)
+            tocreate_numbers = [
+                value['sanitized'] or original
+                for original, value in sanitized.items()
+                if value['code'] != 'empty'
+            ]
+            sms_create_vals += [dict(sms_base_vals, partner_id=False, number=n) for n in tocreate_numbers]
+
+        # create sms and notification
+        existing_pids, existing_numbers = [], []
+        if sms_create_vals:
+            sms_all |= self.env['sms.sms'].sudo().create(sms_create_vals)
+
+            if check_existing:
+                existing = self.env['mail.notification'].sudo().search([
+                    '|', ('res_partner_id', 'in', partner_ids),
+                    '&', ('res_partner_id', '=', False), ('sms_number', 'in', sms_numbers),
+                    ('notification_type', '=', 'sms'),
+                    ('mail_message_id', '=', message.id)
+                ])
+                for n in existing:
+                    if n.res_partner_id.id in partner_ids and n.mail_message_id == message:
+                        existing_pids.append(n.res_partner_id.id)
+                    if not n.res_partner_id and n.sms_number in sms_numbers and n.mail_message_id == message:
+                        existing_numbers.append(n.sms_number)
+
+            notif_create_values = [{
+                'mail_message_id': message.id,
+                'res_partner_id': sms.partner_id.id,
+                'sms_number': sms.number,
+                'notification_type': 'sms',
+                'sms_id': sms.id,
+                'is_read': True,  # discard Inbox notification
+                'notification_status': 'ready',
+            } for sms in sms_all if (sms.partner_id and sms.partner_id.id not in existing_pids) or (not sms.partner_id and sms.number not in existing_numbers)]
+            if notif_create_values:
+                self.env['mail.notification'].sudo().create(notif_create_values)
+
+            if existing_pids or existing_numbers:
+                for sms in sms_all:
+                    notif = next((n for n in existing if
+                                 (n.res_partner_id.id in existing_pids and n.res_partner_id.id == sms.partner_id.id) or
+                                 (not n.res_partner_id and n.sms_number in existing_numbers and n.sms_number == sms.number)), False)
+                    if notif:
+                        notif.write({
+                            'notification_type': 'sms',
+                            'notification_status': 'ready',
+                            'sms_id': sms.id,
+                            'sms_number': sms.number,
+                        })
+
+        if sms_all and not put_in_queue:
+            sms_all.send(auto_commit=False, raise_exception=False)
+
+        return True

--- a/addons/sms/models/res_partner.py
+++ b/addons/sms/models/res_partner.py
@@ -7,7 +7,7 @@ from odoo import models
 class ResPartner(models.Model):
     _inherit = 'res.partner'
 
-    def _get_default_sms_recipients(self):
+    def _sms_get_default_partners(self):
         """ Override of mail.thread method.
             SMS recipients on partners are the partners themselves.
         """

--- a/None
+++ b/addons/sms/models/sms_sms.py
@@ -0,0 +1,137 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+import logging
+import threading
+
+from odoo import api, fields, models, tools
+
+_logger = logging.getLogger(__name__)
+
+
+class SmsSms(models.Model):
+    _name = 'sms.sms'
+    _description = 'Outgoing SMS'
+    _rec_name = 'number'
+
+    number = fields.Char('Number', required=True)
+    body = fields.Text()
+    partner_id = fields.Many2one('res.partner', 'Customer')
+    mail_message_id = fields.Many2one('mail.message', index=True)
+    state = fields.Selection([
+        ('outgoing', 'In Queue'),
+        ('sent', 'Sent'),
+        ('error', 'Error'),
+        ('canceled', 'Canceled')
+    ], 'SMS Status', readonly=True, copy=False, default='outgoing', required=True)
+    error_code = fields.Selection([
+        ('sms_number_missing', 'Missing Number'),
+        ('sms_number_format', 'Wrong Number Format'),
+        ('sms_credit', 'Insufficient Credit'),
+        ('sms_server', 'Server Error')
+    ])
+
+    @api.multi
+    def send(self, delete_all=False, auto_commit=False, raise_exception=False):
+        """ Main API method to send SMS.
+
+          :param delete_all: delete all SMS (sent or not); otherwise delete only
+            sent SMS;
+          :param auto_commit: commit after each batch of SMS;
+          :param raise_exception: raise if there is an issue contacting IAP;
+        """
+        for batch_ids in self._split_batch():
+            self.browse(batch_ids)._send(delete_all=delete_all, raise_exception=raise_exception)
+            if auto_commit is True:
+                self._cr.commit()
+
+    @api.model
+    def _process_queue(self, ids=None):
+        """ Send immediately queued messages, committing after each message is sent.
+        This is not transactional and should not be called during another transaction!
+
+       :param list ids: optional list of emails ids to send. If passed no search
+         is performed, and these ids are used instead.
+        """
+        domain = [('state', '=', 'outgoing')]
+
+        filtered_ids = self.search(domain, limit=10000).ids  # TDE note: arbitrary limit we might have to update
+        if ids:
+            ids = list(set(filtered_ids) & set(ids))
+        else:
+            ids = filtered_ids
+        ids.sort()
+
+        res = None
+        try:
+            # auto-commit except in testing mode
+            auto_commit = not getattr(threading.currentThread(), 'testing', False)
+            res = self.browse(ids).send(delete_all=False, auto_commit=auto_commit, raise_exception=False)
+        except Exception:
+            _logger.exception("Failed processing SMS queue")
+        return res
+
+    def _split_batch(self):
+        batch_size = int(self.env['ir.config_parameter'].sudo().get_param('sms.session.batch.size', 10))
+        for sms_batch in tools.split_every(batch_size, self.ids):
+            yield sms_batch
+
+    @api.multi
+    def _send(self, delete_all=False, raise_exception=False):
+        """ This method tries to send SMS after checking the number (presence and
+        formatting). """
+        iap_data = [{
+            'res_id': record.id,
+            'number': record.number,
+            'content': record.body,
+        } for record in self]
+
+        try:
+            iap_results = self.env['sms.api']._send_sms_batch(iap_data)
+        except Exception as e:
+            _logger.info('Sent batch %s SMS: %s: failed with exception %s', len(self.ids), self.ids, e)
+            if raise_exception:
+                raise
+            self._postprocess_sent_sms([{'res_id': sms.id, 'state': 'server_error'} for sms in self], delete_all=delete_all)
+        else:
+            _logger.info('Send batch %s SMS: %s: gave %s', len(self.ids), self.ids, iap_results)
+            self._postprocess_sent_sms(iap_results, delete_all=delete_all)
+
+    def _postprocess_sent_sms(self, iap_results, failure_reason=None, delete_all=False):
+        sms_to_notif_status = {
+            'success': False, 'insufficient_credit': 'sms_credit',
+            'wrong_format_number': 'sms_number_format', 'server_error': 'sms_server'}
+        if delete_all:
+            todelete_sms_ids = [item['res_id'] for item in iap_results]
+        else:
+            todelete_sms_ids = [item['res_id'] for item in iap_results if item['state'] == 'success']
+
+        for state in sms_to_notif_status.keys():
+            sms_ids = [item['res_id'] for item in iap_results if item['state'] == state]
+            if sms_ids:
+                if not delete_all and state != 'success':
+                    self.env['sms.sms'].sudo().browse(sms_ids).write({
+                        'state': 'error',
+                        'error_code': sms_to_notif_status[state],
+                    })
+                notifications = self.env['mail.notification'].sudo().search([
+                    ('notification_type', '=', 'sms'),
+                    ('sms_id', 'in', sms_ids),
+                    ('notification_status', 'not in', ('sent', 'canceled'))]
+                )
+                if notifications:
+                    notifications.write({
+                        'notification_status': 'sent' if state == 'success' else 'exception',
+                        'failure_type': sms_to_notif_status[state],
+                        'failure_reason': failure_reason if failure_reason else False,
+                    })
+
+        if todelete_sms_ids:
+            self.browse(todelete_sms_ids).sudo().unlink()
+
+    @api.multi
+    def cancel(self):
+        self.write({
+            'state': 'canceled',
+            'error_code': False
+        })
