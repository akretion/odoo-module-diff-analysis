PR: https://github.com/odoo/odoo/pull/

From: f61687a4cdb0e22df19568c9b4ac3dbb579ca062
From: RomainLibert
Date: 2018-01-15 09:38:31

Structural Changes: 25
Total Changes: 486

[IMP] hr_holidays : split hr.holidays into hr.leave and hr.leave.allocation

Purpose
=======

Have a clear distinction between leave and allocation requests instead of
using the same model to mix 2 different concepts.

Splitting the model will allow different business code to be run on each
model as allocations and leaves are not exactly the same thing; this
will add some code but simplify future improvements

Specification
=============

1/ Completely separate the models

Model hr.holidays has been split into leave.request and
leave.allocation.

2/ Make reporting working again by using an SQL view aggregating data
from leaves and allocations

A new report has been added in order to aggregate
datas from both allocations and requests. The views have been modified
accordingly.

================================= pseudo patch: =================================

--- a/addons/hr_holidays/models/hr.py
+++ b/addons/hr_holidays/models/hr.py
@@ -23,22 +23,23 @@ class Department(models.Model):
 
     @api.multi
     def _compute_leave_count(self):
-        Holiday = self.env['hr.holidays']
+        Requests = self.env['hr.leave']
+        Allocations = self.env['hr.leave.allocation']
         today_date = datetime.datetime.utcnow().date()
         today_start = fields.Datetime.to_string(today_date)  # get the midnight of the current utc day
         today_end = fields.Datetime.to_string(today_date + relativedelta(hours=23, minutes=59, seconds=59))
 
-        leave_data = Holiday.read_group(
+        leave_data = Requests.read_group(
             [('department_id', 'in', self.ids),
-             ('state', '=', 'confirm'), ('type', '=', 'remove')],
+             ('state', '=', 'confirm')],
             ['department_id'], ['department_id'])
-        allocation_data = Holiday.read_group(
+        allocation_data = Allocations.read_group(
             [('department_id', 'in', self.ids),
-             ('state', '=', 'confirm'), ('type', '=', 'add')],
+             ('state', '=', 'confirm')],
             ['department_id'], ['department_id'])
-        absence_data = Holiday.read_group(
+        absence_data = Requests.read_group(
             [('department_id', 'in', self.ids), ('state', 'not in', ['cancel', 'refuse']),
-             ('date_from', '<=', today_end), ('date_to', '>=', today_start), ('type', '=', 'remove')],
+             ('date_from', '<=', today_end), ('date_to', '>=', today_start)],
             ['department_id'], ['department_id'])
 
         res_leave = dict((data['department_id'][0], data['department_id_count']) for data in leave_data)
@@ -74,7 +75,7 @@ class Employee(models.Model):
             ('validate', 'Approved'),
             ('cancel', 'Cancelled')
         ])
-    current_leave_id = fields.Many2one('hr.holidays.status', compute='_compute_leave_status', string="Current Leave Type")
+    current_leave_id = fields.Many2one('hr.leave.type', compute='_compute_leave_status', string="Current Leave Type")
     leave_date_from = fields.Date('From Date', compute='_compute_leave_status')
     leave_date_to = fields.Date('To Date', compute='_compute_leave_status')
     leaves_count = fields.Float('Number of Leaves', compute='_compute_leaves_count')
@@ -90,8 +91,16 @@ class Employee(models.Model):
                 sum(h.number_of_days) AS days,
                 h.employee_id
             FROM
-                hr_holidays h
-                join hr_holidays_status s ON (s.id=h.holiday_status_id)
+                (
+                    SELECT holiday_status_id, number_of_days,
+                        state, employee_id
+                    FROM hr_leave_allocation
+                    UNION
+                    SELECT holiday_status_id, number_of_days,
+                        state, employee_id
+                    FROM hr_leave
+                ) h
+                join hr_leave_type s ON (s.id=h.holiday_status_id)
             WHERE
                 h.state='validate' AND
                 s.limit=False AND
@@ -107,7 +116,7 @@ class Employee(models.Model):
 
     @api.multi
     def _inverse_remaining_leaves(self):
-        status_list = self.env['hr.holidays.status'].search([('limit', '=', False)])
+        status_list = self.env['hr.leave.type'].search([('limit', '=', False)])
         # Create leaves (adding remaining leaves) or raise (reducing remaining leaves)
         actual_remaining = self._get_remaining_leaves()
         for employee in self.filtered(lambda employee: employee.remaining_leaves):
@@ -125,11 +134,10 @@ class Employee(models.Model):
             # if a status is found, then compute remaing leave for current employee
             difference = employee.remaining_leaves - actual_remaining.get(employee.id, 0)
             if difference > 0:
-                leave = self.env['hr.holidays'].create({
+                leave = self.env['hr.leave.allocation'].create({
                     'name': _('Allocation for %s') % employee.name,
                     'employee_id': employee.id,
                     'holiday_status_id': status.id,
-                    'type': 'add',
                     'holiday_type': 'employee',
                     'number_of_days_temp': difference
                 })
@@ -142,11 +150,10 @@ class Employee(models.Model):
     @api.multi
     def _compute_leave_status(self):
         # Used SUPERUSER_ID to forcefully get status of other user's leave, to bypass record rule
-        holidays = self.env['hr.holidays'].sudo().search([
+        holidays = self.env['hr.leave'].sudo().search([
             ('employee_id', 'in', self.ids),
             ('date_from', '<=', fields.Datetime.now()),
             ('date_to', '>=', fields.Datetime.now()),
-            ('type', '=', 'remove'),
             ('state', 'not in', ('cancel', 'refuse'))
         ])
         leave_data = {}
@@ -165,12 +172,12 @@ class Employee(models.Model):
 
     @api.multi
     def _compute_leaves_count(self):
-        leaves = self.env['hr.holidays'].read_group([
+        all_leaves = self.env['hr.leave.report'].read_group([
             ('employee_id', 'in', self.ids),
             ('holiday_status_id.limit', '=', False),
             ('state', '=', 'validate')
         ], fields=['number_of_days', 'employee_id'], groupby=['employee_id'])
-        mapping = dict([(leave['employee_id'][0], leave['number_of_days']) for leave in leaves])
+        mapping = dict([(leave['employee_id'][0], leave['number_of_days']) for leave in all_leaves])
         for employee in self:
             employee.leaves_count = mapping.get(employee.id)
 
@@ -188,12 +195,11 @@ class Employee(models.Model):
         today_date = datetime.datetime.utcnow().date()
         today_start = fields.Datetime.to_string(today_date)  # get the midnight of the current utc day
         today_end = fields.Datetime.to_string(today_date + relativedelta(hours=23, minutes=59, seconds=59))
-        data = self.env['hr.holidays'].read_group([
+        data = self.env['hr.leave'].read_group([
             ('employee_id', 'in', self.ids),
             ('state', 'not in', ['cancel', 'refuse']),
             ('date_from', '<=', today_end),
-            ('date_to', '>=', today_start),
-            ('type', '=', 'remove')
+            ('date_to', '>=', today_start)
         ], ['employee_id'], ['employee_id'])
         result = dict.fromkeys(self.ids, False)
         for item in data:
@@ -207,11 +213,10 @@ class Employee(models.Model):
         today_date = datetime.datetime.utcnow().date()
         today_start = fields.Datetime.to_string(today_date)  # get the midnight of the current utc day
         today_end = fields.Datetime.to_string(today_date + relativedelta(hours=23, minutes=59, seconds=59))
-        holidays = self.env['hr.holidays'].sudo().search([
+        holidays = self.env['hr.leave'].sudo().search([
             ('employee_id', '!=', False),
             ('state', 'not in', ['cancel', 'refuse']),
             ('date_from', '<=', today_end),
-            ('date_to', '>=', today_start),
-            ('type', '=', 'remove')
+            ('date_to', '>=', today_start)
         ])
         return [('id', 'in', holidays.mapped('employee_id').ids)]

--- a/addons/hr_holidays/models/hr_holidays.py
+++ b/addons/hr_holidays/models/hr_holidays.py
@@ -19,7 +19,7 @@ HOURS_PER_DAY = 8
 
 
 class HolidaysType(models.Model):
-    _name = "hr.holidays.status"
+    _name = "hr.leave.type"
     _description = "Leave Type"
 
     name = fields.Char('Leave Type', required=True, translate=True)
@@ -68,27 +68,35 @@ class HolidaysType(models.Model):
         # need to use `dict` constructor to create a dict per id
         result = dict((id, dict(max_leaves=0, leaves_taken=0, remaining_leaves=0, virtual_remaining_leaves=0)) for id in self.ids)
 
-        holidays = self.env['hr.holidays'].search([
+        requests = self.env['hr.leave'].search([
             ('employee_id', '=', employee_id),
             ('state', 'in', ['confirm', 'validate1', 'validate']),
             ('holiday_status_id', 'in', self.ids)
         ])
 
-        for holiday in holidays:
-            status_dict = result[holiday.holiday_status_id.id]
-            if holiday.type == 'add':
-                if holiday.state == 'validate':
-                    # note: add only validated allocation even for the virtual
-                    # count; otherwise pending then refused allocation allow
-                    # the employee to create more leaves than possible
-                    status_dict['virtual_remaining_leaves'] += holiday.number_of_days_temp
-                    status_dict['max_leaves'] += holiday.number_of_days_temp
-                    status_dict['remaining_leaves'] += holiday.number_of_days_temp
-            elif holiday.type == 'remove':  # number of days is negative
-                status_dict['virtual_remaining_leaves'] -= holiday.number_of_days_temp
-                if holiday.state == 'validate':
-                    status_dict['leaves_taken'] += holiday.number_of_days_temp
-                    status_dict['remaining_leaves'] -= holiday.number_of_days_temp
+        allocations = self.env['hr.leave.allocation'].search([
+            ('employee_id', '=', employee_id),
+            ('state', 'in', ['confirm', 'validate1', 'validate']),
+            ('holiday_status_id', 'in', self.ids)
+        ])
+
+        for request in requests:
+            status_dict = result[request.holiday_status_id.id]
+            status_dict['virtual_remaining_leaves'] -= request.number_of_days_temp
+            if request.state == 'validate':
+                status_dict['leaves_taken'] += request.number_of_days_temp
+                status_dict['remaining_leaves'] -= request.number_of_days_temp
+
+        for allocation in allocations:
+            status_dict = result[allocation.holiday_status_id.id]
+            if allocation.state == 'validate':
+                # note: add only validated allocation even for the virtual
+                # count; otherwise pending then refused allocation allow
+                # the employee to create more leaves than possible
+                status_dict['virtual_remaining_leaves'] += allocation.number_of_days_temp
+                status_dict['max_leaves'] += allocation.number_of_days_temp
+                status_dict['remaining_leaves'] += allocation.number_of_days_temp
+
         return result
 
     @api.multi
@@ -146,10 +154,10 @@ class HolidaysType(models.Model):
         return leave_ids
 
 
-class Holidays(models.Model):
-    _name = "hr.holidays"
+class HolidaysRequest(models.Model):
+    _name = "hr.leave"
     _description = "Leave"
-    _order = "type desc, date_from desc"
+    _order = "date_from desc"
     _inherit = ['mail.thread']
 
     def _default_employee(self):
@@ -172,11 +180,11 @@ class Holidays(models.Model):
         help='Green this button when the leave has been taken into account in the payslip.')
     report_note = fields.Text('HR Comments')
     user_id = fields.Many2one('res.users', string='User', related='employee_id.user_id', related_sudo=True, store=True, default=lambda self: self.env.uid, readonly=True)
-    date_from = fields.Datetime('Start Date', readonly=True, index=True, copy=False,
+    date_from = fields.Datetime('Start Date', readonly=True, index=True, copy=False, required=True,
         states={'draft': [('readonly', False)], 'confirm': [('readonly', False)]}, track_visibility='onchange')
-    date_to = fields.Datetime('End Date', readonly=True, copy=False,
+    date_to = fields.Datetime('End Date', readonly=True, copy=False, required=True,
         states={'draft': [('readonly', False)], 'confirm': [('readonly', False)]}, track_visibility='onchange')
-    holiday_status_id = fields.Many2one("hr.holidays.status", string="Leave Type", required=True, readonly=True,
+    holiday_status_id = fields.Many2one("hr.leave.type", string="Leave Type", required=True, readonly=True,
         states={'draft': [('readonly', False)], 'confirm': [('readonly', False)]})
     employee_id = fields.Many2one('hr.employee', string='Employee', index=True, readonly=True,
         states={'draft': [('readonly', False)], 'confirm': [('readonly', False)]}, default=_default_employee, track_visibility='onchange')
@@ -188,15 +196,9 @@ class Holidays(models.Model):
         help='Number of days of the leave request according to your working schedule.')
     number_of_days = fields.Float('Number of Days', compute='_compute_number_of_days', store=True, track_visibility='onchange')
     meeting_id = fields.Many2one('calendar.event', string='Meeting')
-    type = fields.Selection([
-            ('remove', 'Leave Request'),
-            ('add', 'Allocation Request')
-        ], string='Request Type', required=True, readonly=True, index=True, track_visibility='always', default='remove',
-        states={'draft': [('readonly', False)], 'confirm': [('readonly', False)]},
-        help="Choose 'Leave Request' if someone wants to take an off-day. "
-             "\nChoose 'Allocation Request' if you want to increase the number of leaves available for someone")
-    parent_id = fields.Many2one('hr.holidays', string='Parent')
-    linked_request_ids = fields.One2many('hr.holidays', 'parent_id', string='Linked Requests')
+
+    parent_id = fields.Many2one('hr.leave', string='Parent')
+    linked_request_ids = fields.One2many('hr.leave', 'parent_id', string='Linked Requests')
     department_id = fields.Many2one('hr.department', string='Department', readonly=True, states={'draft': [('readonly', False)], 'confirm': [('readonly', False)]})
     category_id = fields.Many2one('hr.employee.category', string='Employee Tag', readonly=True,
         states={'draft': [('readonly', False)], 'confirm': [('readonly', False)]}, help='Category of Employee')
@@ -215,13 +217,10 @@ class Holidays(models.Model):
     can_reset = fields.Boolean('Can reset', compute='_compute_can_reset')
 
     @api.multi
-    @api.depends('number_of_days_temp', 'type')
+    @api.depends('number_of_days_temp')
     def _compute_number_of_days(self):
         for holiday in self:
-            if holiday.type == 'remove':
-                holiday.number_of_days = -holiday.number_of_days_temp
-            else:
-                holiday.number_of_days = holiday.number_of_days_temp
+            holiday.number_of_days = -holiday.number_of_days_temp
 
     @api.multi
     def _compute_can_reset(self):
@@ -242,7 +241,6 @@ class Holidays(models.Model):
                 ('date_to', '>=', holiday.date_from),
                 ('employee_id', '=', holiday.employee_id.id),
                 ('id', '!=', holiday.id),
-                ('type', '=', holiday.type),
                 ('state', 'not in', ['cancel', 'refuse']),
             ]
             nholidays = self.search_count(domain)
@@ -252,7 +250,7 @@ class Holidays(models.Model):
     @api.constrains('state', 'number_of_days_temp')
     def _check_holidays(self):
         for holiday in self:
-            if holiday.holiday_type != 'employee' or holiday.type != 'remove' or not holiday.employee_id or holiday.holiday_status_id.limit:
+            if holiday.holiday_type != 'employee' or not holiday.employee_id or holiday.holiday_status_id.limit:
                 continue
             leave_days = holiday.holiday_status_id.get_days(holiday.employee_id.id)[holiday.holiday_status_id.id]
             if float_compare(leave_days['remaining_leaves'], 0, precision_digits=2) == -1 or \
@@ -263,7 +261,7 @@ class Holidays(models.Model):
     _sql_constraints = [
         ('type_value', "CHECK( (holiday_type='employee' AND employee_id IS NOT NULL) or (holiday_type='category' AND category_id IS NOT NULL) or (holiday_type='department' AND department_id IS NOT NULL) )",
          "The employee, department or employee category of this request is missing. Please make sure that your user login is linked to an employee."),
-        ('date_check2', "CHECK ( (type='add') OR (date_from <= date_to))", "The start date must be anterior to the end date."),
+        ('date_check2', "CHECK ((date_from <= date_to))", "The start date must be anterior to the end date."),
         ('date_check', "CHECK ( number_of_days_temp >= 0 )", "The number of days must be greater than 0."),
     ]
 
@@ -336,20 +334,12 @@ class Holidays(models.Model):
     def name_get(self):
         res = []
         for leave in self:
-            if leave.type == 'remove':
-                if self.env.context.get('short_name'):
-                    res.append((leave.id, _("%s : %.2f day(s)") % (leave.name or leave.holiday_status_id.name, leave.number_of_days_temp)))
-                else:
-                    res.append((leave.id, _("%s on %s : %.2f day(s)") % (leave.employee_id.name or leave.category_id.name, leave.holiday_status_id.name, leave.number_of_days_temp)))
+            if self.env.context.get('short_name'):
+                res.append((leave.id, _("%s : %.2f day(s)") % (leave.name or leave.holiday_status_id.name, leave.number_of_days_temp)))
             else:
-                res.append((leave.id, _("Allocation of %s : %.2f day(s) To %s") % (leave.holiday_status_id.name, leave.number_of_days_temp, leave.employee_id.name)))
+                res.append((leave.id, _("%s on %s : %.2f day(s)") % (leave.employee_id.name or leave.category_id.name, leave.holiday_status_id.name, leave.number_of_days_temp)))
         return res
 
-    def _check_state_access_right(self, vals):
-        if vals.get('state') and vals['state'] not in ['draft', 'confirm', 'cancel'] and not self.env['res.users'].has_group('hr_holidays.group_hr_holidays_user'):
-            return False
-        return True
-
     @api.multi
     def add_follower(self, employee_id):
         employee = self.env['hr.employee'].browse(employee_id)
@@ -360,20 +350,16 @@ class Holidays(models.Model):
     def create(self, values):
         """ Override to avoid automatic logging of creation """
         employee_id = values.get('employee_id', False)
-        if not self._check_state_access_right(values):
-            raise AccessError(_('You cannot set a leave request as \'%s\'. Contact a human resource manager.') % values.get('state'))
         if not values.get('department_id'):
             values.update({'department_id': self.env['hr.employee'].browse(employee_id).department_id.id})
-        holiday = super(Holidays, self.with_context(mail_create_nolog=True, mail_create_nosubscribe=True)).create(values)
+        holiday = super(HolidaysRequest, self.with_context(mail_create_nolog=True, mail_create_nosubscribe=True)).create(values)
         holiday.add_follower(employee_id)
         return holiday
 
     @api.multi
     def write(self, values):
         employee_id = values.get('employee_id', False)
-        if not self._check_state_access_right(values):
-            raise AccessError(_('You cannot set a leave request as \'%s\'. Contact a human resource manager.') % values.get('state'))
-        result = super(Holidays, self).write(values)
+        result = super(HolidaysRequest, self).write(values)
         self.add_follower(employee_id)
         return result
 
@@ -381,7 +367,7 @@ class Holidays(models.Model):
     def unlink(self):
         for holiday in self.filtered(lambda holiday: holiday.state not in ['draft', 'cancel', 'confirm']):
             raise UserError(_('You cannot delete a leave which is in %s state.') % (holiday.state,))
-        return super(Holidays, self).unlink()
+        return super(HolidaysRequest, self).unlink()
 
     @api.multi
     def copy_data(self, default=None):
@@ -434,6 +420,7 @@ class Holidays(models.Model):
             raise UserError(_('Leave request must be in Draft state ("To Submit") in order to confirm it.'))
         return self.write({'state': 'confirm'})
 
+    # TODO: Do we have to remove this method?
     @api.multi
     def _check_security_action_approve(self):
         if not self.env.user.has_group('hr_holidays.group_hr_holidays_user'):
@@ -458,7 +445,6 @@ class Holidays(models.Model):
         self.ensure_one()
         values = {
             'name': self.name,
-            'type': self.type,
             'holiday_type': 'employee',
             'holiday_status_id': self.holiday_status_id.id,
             'date_from': self.date_from,
@@ -491,10 +477,10 @@ class Holidays(models.Model):
                 holiday.write({'second_approver_id': current_employee.id})
             else:
                 holiday.write({'first_approver_id': current_employee.id})
-            if holiday.holiday_type == 'employee' and holiday.type == 'remove':
+            if holiday.holiday_type == 'employee':
                 holiday._validate_leave_request()
             elif holiday.holiday_type in ['category', 'department']:
-                leaves = self.env['hr.holidays']
+                leaves = self.env['hr.leave']
                 employees = holiday.category_id.employee_ids if holiday.holiday_type == 'category' else holiday.department_id.member_ids
                 for employee in employees:
                     values = holiday._prepare_holiday_values(employee)
@@ -506,9 +492,9 @@ class Holidays(models.Model):
         return True
 
     def _validate_leave_request(self):
-        """ Validate leave requests (holiday_type='employee' and holiday.type='remove')
+        """ Validate leave requests (holiday_type='employee')
         by creating a calendar event and a resource leaves. """
-        for holiday in self.filtered(lambda request: request.type == 'remove' and request.holiday_type == 'employee'):
+        for holiday in self.filtered(lambda request: request.holiday_type == 'employee'):
             meeting_values = holiday._prepare_holidays_meeting_values()
             meeting = self.env['calendar.event'].with_context(no_mail_to_attendees=True).create(meeting_values)
             holiday.write({'meeting_id': meeting.id})
@@ -576,21 +562,329 @@ class Holidays(models.Model):
             return 'hr_holidays.mt_holidays_confirmed'
         elif 'state' in init_values and self.state == 'refuse':
             return 'hr_holidays.mt_holidays_refused'
-        return super(Holidays, self)._track_subtype(init_values)
+        return super(HolidaysRequest, self)._track_subtype(init_values)
+
+    @api.multi
+    def _notification_recipients(self, message, groups):
+        """ Handle HR users and officers recipients that can validate or refuse holidays
+        directly from email. """
+        groups = super(HolidaysRequest, self)._notification_recipients(message, groups)
+
+        self.ensure_one()
+        hr_actions = []
+        if self.state == 'confirm':
+            app_action = self._notification_link_helper('controller', controller='/hr_holidays_request/validate')
+            hr_actions += [{'url': app_action, 'title': _('Approve')}]
+        if self.state in ['confirm', 'validate', 'validate1']:
+            ref_action = self._notification_link_helper('controller', controller='/hr_holidays_request/refuse')
+            hr_actions += [{'url': ref_action, 'title': _('Refuse')}]
+
+        new_group = (
+            'group_hr_holidays_user', lambda partner: bool(partner.user_ids) and any(user.has_group('hr_holidays.group_hr_holidays_user') for user in partner.user_ids), {
+                'actions': hr_actions,
+            })
+
+        return [new_group] + groups
+
+    @api.multi
+    def _message_notification_recipients(self, message, recipients):
+        result = super(HolidaysRequest, self)._message_notification_recipients(message, recipients)
+        title = _("See Leave")
+        for res in result:
+            if result[res].get('button_access'):
+                result[res]['button_access']['title'] = title
+        return result
+
+
+class HolidaysAllocation(models.Model):
+    _name = "hr.leave.allocation"
+    _description = "Allocation"
+    _inherit = ['mail.thread']
+
+    def _default_employee(self):
+        return self.env.context.get('default_employee_id') or self.env['hr.employee'].search([('user_id', '=', self.env.uid)], limit=1)
+
+    name = fields.Char('Description')
+    state = fields.Selection([
+        ('draft', 'To Submit'),
+        ('cancel', 'Cancelled'),
+        ('confirm', 'To Approve'),
+        ('refuse', 'Refused'),
+        ('validate1', 'Second Approval'),
+        ('validate', 'Approved')
+        ], string='Status', readonly=True, track_visibility='onchange', copy=False, default='confirm',
+            help="The status is set to 'To Submit', when a leave request is created." +
+            "\nThe status is 'To Approve', when leave request is confirmed by user." +
+            "\nThe status is 'Refused', when leave request is refused by manager." +
+            "\nThe status is 'Approved', when leave request is approved by manager.")
+    holiday_status_id = fields.Many2one("hr.leave.type", string="Leave Type", required=True, readonly=True,
+        states={'draft': [('readonly', False)], 'confirm': [('readonly', False)]})
+    employee_id = fields.Many2one('hr.employee', string='Employee', index=True, readonly=True,
+        states={'draft': [('readonly', False)], 'confirm': [('readonly', False)]}, default=_default_employee, track_visibility='onchange')
+    notes = fields.Text('Reasons', readonly=True, states={'draft': [('readonly', False)], 'confirm': [('readonly', False)]})
+    number_of_days_temp = fields.Float(
+        'Allocation', copy=False, readonly=True,
+        states={'draft': [('readonly', False)], 'confirm': [('readonly', False)]},
+        help='Number of days of the leave request according to your working schedule.')
+    number_of_days = fields.Float('Number of Days', compute='_compute_number_of_days', store=True, track_visibility='onchange')
+    parent_id = fields.Many2one('hr.leave.allocation', string='Parent')
+    linked_request_ids = fields.One2many('hr.leave.allocation', 'parent_id', string='Linked Requests')
+    department_id = fields.Many2one('hr.department', string='Department', readonly=True, states={'draft': [('readonly', False)], 'confirm': [('readonly', False)]})
+    category_id = fields.Many2one('hr.employee.category', string='Employee Tag', readonly=True,
+        states={'draft': [('readonly', False)], 'confirm': [('readonly', False)]}, help='Category of Employee')
+    holiday_type = fields.Selection([
+        ('employee', 'By Employee'),
+        ('department', 'By Department'),
+        ('category', 'By Employee Tag')
+    ], string='Allocation Mode', readonly=True, required=True, default='employee',
+        states={'draft': [('readonly', False)], 'confirm': [('readonly', False)]},
+        help='By Employee: Allocation for individual Employee, By Employee Tag: Allocation for group of employees in category')
+    first_approver_id = fields.Many2one('hr.employee', string='First Approval', readonly=True, copy=False,
+        help='This area is automatically filled by the user who validate the leave', oldname='manager_id')
+    second_approver_id = fields.Many2one('hr.employee', string='Second Approval', readonly=True, copy=False, oldname='manager_id2',
+        help='This area is automaticly filled by the user who validate the leave with second level (If Leave type need second validation)')
+    double_validation = fields.Boolean('Apply Double Validation', related='holiday_status_id.double_validation')
+    can_reset = fields.Boolean('Can reset', compute='_compute_can_reset')
+
+    @api.multi
+    @api.depends('number_of_days_temp')
+    def _compute_number_of_days(self):
+        for holiday in self:
+            holiday.number_of_days = holiday.number_of_days_temp
+
+    @api.multi
+    def _compute_can_reset(self):
+        """ User can reset a leave request if it is its own leave request
+            or if he is an Hr Manager.
+        """
+        user = self.env.user
+        group_hr_manager = self.env.ref('hr_holidays.group_hr_holidays_manager')
+        for holiday in self:
+            if group_hr_manager in user.groups_id or holiday.employee_id and holiday.employee_id.user_id == user:
+                holiday.can_reset = True
+
+    _sql_constraints = [
+        ('type_value', "CHECK( (holiday_type='employee' AND employee_id IS NOT NULL) or (holiday_type='category' AND category_id IS NOT NULL) or (holiday_type='department' AND department_id IS NOT NULL) )",
+         "The employee, department or employee category of this request is missing. Please make sure that your user login is linked to an employee."),
+        ('date_check', "CHECK ( number_of_days_temp >= 0 )", "The number of days must be greater than 0."),
+    ]
+
+    @api.onchange('holiday_type')
+    def _onchange_type(self):
+        if self.holiday_type == 'employee' and not self.employee_id:
+            if self.env.user.employee_ids:
+                self.employee_id = self.env.user.employee_ids[0]
+        elif self.holiday_type == 'department':
+            if self.env.user.employee_ids:
+                self.department_id = self.department_id or self.env.user.employee_ids[0].department_id
+            self.employee_id = None
+        elif self.holiday_type == 'category':
+            self.employee_id = None
+            self.department_id = None
+
+    @api.onchange('employee_id')
+    def _onchange_employee(self):
+        if self.holiday_type == 'employee':
+            self.department_id = self.employee_id.department_id
+
+    ####################################################
+    # ORM Overrides methods
+    ####################################################
+
+    @api.multi
+    def name_get(self):
+        res = []
+        for leave in self:
+            res.append((leave.id, _("Allocation of %s : %.2f day(s) To %s") % (leave.holiday_status_id.name, leave.number_of_days_temp, leave.employee_id.name)))
+        return res
+
+    def _check_state_access_right(self, vals):
+        if vals.get('state') and vals['state'] not in ['draft', 'confirm', 'cancel'] and not self.env['res.users'].has_group('hr_holidays.group_hr_holidays_user'):
+            return False
+        return True
+
+    @api.multi
+    def add_follower(self, employee_id):
+        employee = self.env['hr.employee'].browse(employee_id)
+        if employee.user_id:
+            self.message_subscribe_users(user_ids=employee.user_id.ids)
+
+    @api.model
+    def create(self, values):
+        """ Override to avoid automatic logging of creation """
+        employee_id = values.get('employee_id', False)
+        if not self._check_state_access_right(values):
+            raise AccessError(_('You cannot set a leave request as \'%s\'. Contact a human resource manager.') % values.get('state'))
+        if not values.get('department_id'):
+            values.update({'department_id': self.env['hr.employee'].browse(employee_id).department_id.id})
+        holiday = super(HolidaysAllocation, self.with_context(mail_create_nolog=True, mail_create_nosubscribe=True)).create(values)
+        holiday.add_follower(employee_id)
+        return holiday
+
+    @api.multi
+    def write(self, values):
+        employee_id = values.get('employee_id', False)
+        if not self._check_state_access_right(values):
+            raise AccessError(_('You cannot set a leave request as \'%s\'. Contact a human resource manager.') % values.get('state'))
+        result = super(HolidaysAllocation, self).write(values)
+        self.add_follower(employee_id)
+        return result
+
+    @api.multi
+    def unlink(self):
+        for holiday in self.filtered(lambda holiday: holiday.state not in ['draft', 'cancel', 'confirm']):
+            raise UserError(_('You cannot delete a leave which is in %s state.') % (holiday.state,))
+        return super(HolidaysAllocation, self).unlink()
+
+    @api.multi
+    def copy_data(self, default=None):
+        raise UserError(_('A leave cannot be duplicated.'))
+
+    ####################################################
+    # Business methods
+    ####################################################
+
+    @api.multi
+    def action_draft(self):
+        for holiday in self:
+            if not holiday.can_reset:
+                raise UserError(_('Only an HR Manager or the concerned employee can reset to draft.'))
+            if holiday.state not in ['confirm', 'refuse']:
+                raise UserError(_('Leave request state must be "Refused" or "To Approve" in order to reset to Draft.'))
+            holiday.write({
+                'state': 'draft',
+                'first_approver_id': False,
+                'second_approver_id': False,
+            })
+            linked_requests = holiday.mapped('linked_request_ids')
+            for linked_request in linked_requests:
+                linked_request.action_draft()
+            linked_requests.unlink()
+        return True
+
+    @api.multi
+    def action_confirm(self):
+        if self.filtered(lambda holiday: holiday.state != 'draft'):
+            raise UserError(_('Leave request must be in Draft state ("To Submit") in order to confirm it.'))
+        return self.write({'state': 'confirm'})
+
+    @api.multi
+    def _check_security_action_approve(self):
+        if not self.env.user.has_group('hr_holidays.group_hr_holidays_user'):
+            raise UserError(_('Only an HR Officer or Manager can approve leave requests.'))
+
+    @api.multi
+    def action_approve(self):
+        # if double_validation: this method is the first approval approval
+        # if not double_validation: this method calls action_validate() below
+        self._check_security_action_approve()
+
+        current_employee = self.env['hr.employee'].search([('user_id', '=', self.env.uid)], limit=1)
+        if any(holiday.state != 'confirm' for holiday in self):
+            raise UserError(_('Leave request must be confirmed ("To Approve") in order to approve it.'))
+
+        self.filtered(lambda hol: hol.double_validation).write({'state': 'validate1', 'first_approver_id': current_employee.id})
+        self.filtered(lambda hol: not hol.double_validation).action_validate()
+        return True
+
+    @api.multi
+    def _prepare_holiday_values(self, employee):
+        self.ensure_one()
+        values = {
+            'name': self.name,
+            'holiday_type': 'employee',
+            'holiday_status_id': self.holiday_status_id.id,
+            'notes': self.notes,
+            'number_of_days_temp': self.number_of_days_temp,
+            'parent_id': self.id,
+            'employee_id': employee.id
+        }
+        return values
+
+    @api.multi
+    def _check_security_action_validate(self):
+        if not self.env.user.has_group('hr_holidays.group_hr_holidays_user'):
+            raise UserError(_('Only an HR Officer or Manager can approve leave requests.'))
+
+    @api.multi
+    def action_validate(self):
+        self._check_security_action_validate()
+
+        current_employee = self.env['hr.employee'].search([('user_id', '=', self.env.uid)], limit=1)
+        for holiday in self:
+            if holiday.state not in ['confirm', 'validate1']:
+                raise UserError(_('Leave request must be confirmed in order to approve it.'))
+            if holiday.state == 'validate1' and not holiday.env.user.has_group('hr_holidays.group_hr_holidays_manager'):
+                raise UserError(_('Only an HR Manager can apply the second approval on leave requests.'))
+
+            holiday.write({'state': 'validate'})
+            if holiday.double_validation:
+                holiday.write({'second_approver_id': current_employee.id})
+            else:
+                holiday.write({'first_approver_id': current_employee.id})
+            if holiday.holiday_type in ['category', 'department']:
+                leaves = self.env['hr.leave.allocation']
+                employees = holiday.category_id.employee_ids if holiday.holiday_type == 'category' else holiday.department_id.member_ids
+                for employee in employees:
+                    values = holiday._prepare_holiday_values(employee)
+                    leaves += self.with_context(mail_notify_force_send=False).create(values)
+                # TODO is it necessary to interleave the calls?
+                leaves.action_approve()
+                if leaves and leaves[0].double_validation:
+                    leaves.action_validate()
+        return True
+
+    @api.multi
+    def action_refuse(self):
+        self._check_security_action_refuse()
+
+        current_employee = self.env['hr.employee'].search([('user_id', '=', self.env.uid)], limit=1)
+        for holiday in self:
+            if holiday.state not in ['confirm', 'validate', 'validate1']:
+                raise UserError(_('Leave request must be confirmed or validated in order to refuse it.'))
+
+            if holiday.state == 'validate1':
+                holiday.write({'state': 'refuse', 'first_approver_id': current_employee.id})
+            else:
+                holiday.write({'state': 'refuse', 'second_approver_id': current_employee.id})
+            # If a category that created several holidays, cancel all related
+            holiday.linked_request_ids.action_refuse()
+        return True
+
+    @api.multi
+    def _check_security_action_refuse(self):
+        if not self.env.user.has_group('hr_holidays.group_hr_holidays_user'):
+            raise UserError(_('Only an HR Officer or Manager can refuse leave requests.'))
+
+    ####################################################
+    # Messaging methods
+    ####################################################
+
+    @api.multi
+    def _track_subtype(self, init_values):
+        if 'state' in init_values and self.state == 'validate':
+            return 'hr_holidays.mt_holidays_approved'
+        elif 'state' in init_values and self.state == 'validate1':
+            return 'hr_holidays.mt_holidays_first_validated'
+        elif 'state' in init_values and self.state == 'confirm':
+            return 'hr_holidays.mt_holidays_confirmed'
+        elif 'state' in init_values and self.state == 'refuse':
+            return 'hr_holidays.mt_holidays_refused'
+        return super(HolidaysAllocation, self)._track_subtype(init_values)
 
     @api.multi
     def _notification_recipients(self, message, groups):
         """ Handle HR users and officers recipients that can validate or refuse holidays
         directly from email. """
-        groups = super(Holidays, self)._notification_recipients(message, groups)
+        groups = super(HolidaysAllocation, self)._notification_recipients(message, groups)
 
         self.ensure_one()
         hr_actions = []
         if self.state == 'confirm':
-            app_action = self._notification_link_helper('controller', controller='/hr_holidays/validate')
+            app_action = self._notification_link_helper('controller', controller='/hr_holidays_allocation/validate')
             hr_actions += [{'url': app_action, 'title': _('Approve')}]
         if self.state in ['confirm', 'validate', 'validate1']:
-            ref_action = self._notification_link_helper('controller', controller='/hr_holidays/refuse')
+            ref_action = self._notification_link_helper('controller', controller='/hr_holidays_allocation/refuse')
             hr_actions += [{'url': ref_action, 'title': _('Refuse')}]
 
         new_group = (
@@ -602,9 +896,8 @@ class Holidays(models.Model):
 
     @api.multi
     def _message_notification_recipients(self, message, recipients):
-        result = super(Holidays, self)._message_notification_recipients(message, recipients)
-        leave_type = self.env[message.model].browse(message.res_id).type
-        title = _("See Leave") if leave_type == 'remove' else _("See Allocation")
+        result = super(HolidaysAllocation, self)._message_notification_recipients(message, recipients)
+        title = _("See Allocation")
         for res in result:
             if result[res].get('button_access'):
                 result[res]['button_access']['title'] = title

--- a/addons/hr_holidays/models/resource.py
+++ b/addons/hr_holidays/models/resource.py
@@ -9,4 +9,4 @@ class CalendarLeaves(models.Model):
     _inherit = "resource.calendar.leaves"
     _description = "Leave Detail"
 
-    holiday_id = fields.Many2one("hr.holidays", string='Leave Request')
+    holiday_id = fields.Many2one("hr.leave", string='Leave Request')
