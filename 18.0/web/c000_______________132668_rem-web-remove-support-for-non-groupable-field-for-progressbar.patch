PR: https://github.com/odoo/odoo/pull/132668

From: 62f2cd008700c3879c2a9c61340db91cdbb5f8cb
From: Rémy Voet (ryv)
Date: 2024-03-08 18:29:37

Structural Changes: 1
Total Changes: 63

[REM] web: remove support for non-groupable field for progressbar

It was possible to use a non-groupable field (e.g. non store compute)
in a progressbar because of an inefficient fallback in
_read_progress_bar(). This fallback isn't scalable because it does the
job of _read_group() in Python.

Also, it is easy to extend groupable fields with the new
_read_group_groupby() hook.

Then remove the inefficient fallback of _read_progress_bar(). Also,
make activity_state (from hr.contract.history) groupable and remove
the unused kanban_state field from crm.lead.

closes odoo/odoo#132668

Related: odoo/upgrade#5772
Signed-off-by: Rémy Voet (ryv) <ryv@odoo.com>

================================= pseudo patch: =================================

--- a/addons/web/models/models.py
+++ b/addons/web/models/models.py
@@ -289,7 +289,7 @@ class Base(models.AbstractModel):
             return value
 
         result = {}
-        for group in self._read_progress_bar(domain, group_by, progress_bar):
+        for group in self.read_group(domain, ['__count'], [group_by, progress_bar['field']], lazy=False):
             group_by_value = str(adapt(group[group_by]))
             field_value = group[progress_bar['field']]
             if group_by_value not in result:
@@ -298,67 +298,6 @@ class Base(models.AbstractModel):
                 result[group_by_value][field_value] += group['__count']
         return result
 
-    def _read_progress_bar(self, domain, group_by, progress_bar):
-        """ Implementation of read_progress_bar() that returns results in the
-            format of read_group().
-        """
-        try:
-            fname = progress_bar['field']
-            return self.read_group(domain, [fname], [group_by, fname], lazy=False)
-        except ValueError:
-            # possibly failed because of grouping on or aggregating non-stored
-            # field; fallback on alternative implementation
-            pass
-
-        # Workaround to match read_group's infrastructure
-        # TO DO in master: harmonize this function and readgroup to allow factorization
-        group_by_fullname = group_by.partition(':')[0]
-        group_by_fieldname = group_by_fullname.split(".")[0]  # split on "." in case we group on a property
-        group_by_modifier = group_by.partition(':')[2] or 'month'
-
-        records_values = self.search_read(domain or [], [progress_bar['field'], group_by_fieldname])
-        field_type = self._fields[group_by_fieldname].type
-
-        for record_values in records_values:
-            group_by_value = record_values.pop(group_by_fieldname)
-            property_name = group_by_fullname.partition('.')[2]
-            if field_type == "properties" and group_by_value:
-                group_by_value = next(
-                    (definition['value'] for definition in group_by_value
-                     if definition['name'] == property_name),
-                    False,
-                )
-
-            # Again, imitating what _read_group_format_result and _read_group_prepare_data do
-            if group_by_value and field_type in ['date', 'datetime']:
-                locale = get_lang(self.env).code
-                group_by_value = fields.Datetime.to_datetime(group_by_value)
-                if group_by_modifier != 'week':
-                    # start_of(v, 'week') does not take into account the locale
-                    # to determine the first day of the week; this part is not
-                    # necessary, since the formatting below handles the locale
-                    # as expected, and outputs correct results
-                    group_by_value = date_utils.start_of(group_by_value, group_by_modifier)
-                group_by_value = pytz.timezone('UTC').localize(group_by_value)
-                tz_info = None
-                if field_type == 'datetime' and self._context.get('tz') in pytz.all_timezones:
-                    tz_info = self._context.get('tz')
-                    group_by_value = babel.dates.format_datetime(
-                        group_by_value, format=DISPLAY_DATE_FORMATS[group_by_modifier],
-                        tzinfo=tz_info, locale=locale)
-                else:
-                    group_by_value = babel.dates.format_date(
-                        group_by_value, format=DISPLAY_DATE_FORMATS[group_by_modifier],
-                        locale=locale)
-
-            if field_type == 'many2many' and isinstance(group_by_value, list):
-                group_by_value = str(tuple(group_by_value)) or False
-
-            record_values[group_by] = group_by_value
-            record_values['__count'] = 1
-
-        return records_values
-
     @api.model
     def _search_panel_field_image(self, field_name, **kwargs):
         """
