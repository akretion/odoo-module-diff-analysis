PR: https://github.com/odoo/odoo/pull/

From: 2d1b8e9f3445ab0e1c1ac4683b7b5a25c867b2de
From: Olivier Colson
Date: 2017-08-31 13:58:22

Structural Changes: 15
Total Changes: 360

[IMP] account: new setup bar

    Add a setup bar on account's dashboard, so that the user can more easily enter the initial data of his Odoo installation, following the steps that are proposed to him.

Was PR #16864
Was task 32119

================================= pseudo patch: =================================

--- a/addons/account/models/account.py
+++ b/addons/account/models/account.py
@@ -77,10 +77,75 @@ class AccountAccount(models.Model):
     tag_ids = fields.Many2many('account.account.tag', 'account_account_account_tag', string='Tags', help="Optional tags you may want to assign for custom reporting")
     group_id = fields.Many2one('account.group')
 
+    opening_debit = fields.Monetary(string="Opening debit", compute='_compute_opening_debit_credit', inverse='_set_opening_debit', help="Opening debit value for this account.")
+    opening_credit = fields.Monetary(string="Opening credit", compute='_compute_opening_debit_credit', inverse='_set_opening_credit', help="Opening credit value for this account.")
+
     _sql_constraints = [
         ('code_company_uniq', 'unique (code,company_id)', 'The code of the account must be unique per company !')
     ]
 
+    def _compute_opening_debit_credit(self):
+        for record in self:
+            opening_debit = opening_credit = 0.0
+            if record.company_id.account_opening_move_id:
+                for line in self.env['account.move.line'].search([('account_id', '=', record.id),
+                                                                 ('move_id','=', record.company_id.account_opening_move_id.id)]):
+                    #could be executed at most twice: once for credit, once for debit
+                    if line.debit:
+                        opening_debit = line.debit
+                    elif line.credit:
+                        opening_credit = line.credit
+            record.opening_debit = opening_debit
+            record.opening_credit = opening_credit
+
+    def _set_opening_debit(self):
+        self._set_opening_debit_credit(self.opening_debit, 'debit')
+
+    def _set_opening_credit(self):
+        self._set_opening_debit_credit(self.opening_credit, 'credit')
+
+    def _set_opening_debit_credit(self, amount, field):
+        """ Generic function called by both opening_debit and opening_credit's
+        inverse function. 'Amount' parameter is the value to be set, and field
+        either 'debit' or 'credit', depending on wich one of these two fields
+        got assigned.
+        """
+        opening_move = self.company_id.account_opening_move_id
+
+        if not opening_move:
+            raise UserError(_("No opening move defined !"))
+
+        if opening_move.state == 'draft':
+            # check whether we should create a new move line or modify an existing one
+            opening_move_line = self.env['account.move.line'].search([('account_id', '=', self.id),
+                                                                      ('move_id','=', opening_move.id),
+                                                                      (field,'!=', False),
+                                                                      (field,'!=', 0.0)]) # 0.0 condition important for import
+
+            counter_part_map = {'debit': opening_move_line.credit, 'credit': opening_move_line.debit}
+            # No typo here! We want the credit value when treating debit and debit value when treating credit
+
+            if opening_move_line:
+                if amount:
+                    # modify the line
+                    setattr(opening_move_line.with_context({'check_move_validity': False}), field, amount)
+                elif counter_part_map[field]:
+                    # delete the line (no need to keep a line with value = 0)
+                    opening_move_line.with_context({'check_move_validity': False}).unlink()
+            elif amount:
+                # create a new line, as none existed before
+                self.env['account.move.line'].with_context({'check_move_validity': False}).create({
+                        'name': _('Opening balance'),
+                        field: amount,
+                        'move_id': opening_move.id,
+                        'account_id': self.id,
+                })
+
+            # Then, we automatically balance the opening move, to make sure it stays valid
+            if not 'import_file' in self.env.context:
+                # When importing a file, avoid recomputing the opening move for each account and do it at the end, for better performances
+                self.company_id._auto_balance_opening_move()
+
     @api.model
     def default_get(self, default_fields):
         """If we're creating a new account through a many2one, there are chances that we typed the account code
@@ -146,6 +211,20 @@ class AccountAccount(models.Model):
         default.setdefault('code', _("%s (copy)") % (self.code or ''))
         return super(AccountAccount, self).copy(default)
 
+    @api.model
+    def load(self, fields, data):
+        """ Overridden for better performances when importing a list of account
+        with opening debit/credit. In that case, the auto-balance is postpone
+        untill the whole file has been imported.
+        """
+        rslt = super(AccountAccount, self).load(fields, data)
+
+        if 'import_file' in self.env.context:
+            companies = self.search([('id', 'in', rslt['ids'])]).mapped('company_id')
+            for company in companies:
+                company._auto_balance_opening_move()
+        return rslt
+
     @api.multi
     def write(self, vals):
         # Dont allow changing the company_id when account_move_line already exist
@@ -304,7 +383,6 @@ class AccountJournal(models.Model):
     bank_acc_number = fields.Char(related='bank_account_id.acc_number')
     bank_id = fields.Many2one('res.bank', related='bank_account_id.bank_id')
 
-    color = fields.Integer("Color Index", default=1)
     _sql_constraints = [
         ('code_company_uniq', 'unique (code, name, company_id)', 'The code and name of the journal must be unique per company !'),
     ]

--- a/addons/account/models/account_config_settings.py
+++ b/addons/account/models/account_config_settings.py
@@ -64,6 +64,7 @@ class AccountConfigSettings(models.TransientModel):
     module_account_taxcloud = fields.Boolean(string="Account TaxCloud")
     tax_exigibility = fields.Boolean(string='Cash Basis', related='company_id.tax_exigibility')
     tax_cash_basis_journal_id = fields.Many2one('account.journal', related='company_id.tax_cash_basis_journal_id', string="Tax Cash Basis Journal")
+    account_hide_setup_bar = fields.Boolean(string='Hide Setup Bar', related='company_id.account_setup_bar_closed',help="Tick if you wish to hide the setup bar on the dashboard")
 
     @api.model
     def get_values(self):

--- a/addons/account/models/account_journal_dashboard.py
+++ b/addons/account/models/account_journal_dashboard.py
@@ -25,6 +25,8 @@ class account_journal(models.Model):
     kanban_dashboard = fields.Text(compute='_kanban_dashboard')
     kanban_dashboard_graph = fields.Text(compute='_kanban_dashboard_graph')
     show_on_dashboard = fields.Boolean(string='Show journal on dashboard', help="Whether this journal should be displayed on the dashboard or not", default=True)
+    color = fields.Integer("Color Index", default=1)
+    account_setup_bank_data_done = fields.Boolean(string='Bank setup marked as done', related='company_id.account_setup_bank_data_done', help="Technical field used in the special view for the setup bar step.")
 
     def _graph_title_and_key(self):
         if self.type == 'sale':
@@ -414,3 +416,27 @@ class account_journal(models.Model):
             'context': "{'default_journal_id': " + str(self.id) + "}",
         })
         return action
+
+    #####################
+    # Setup Steps Stuff #
+    #####################
+    @api.model
+    def retrieve_account_dashboard_setup_bar(self):
+        """ Returns the data used by the setup bar on the Accounting app dashboard."""
+        company = self.env.user.company_id
+        return {
+            'show_setup_bar': not company.account_setup_bar_closed,
+            'company': company.account_setup_company_data_done,
+            'bank': company.account_setup_bank_data_done,
+            'fiscal_year': company.account_setup_fy_data_done,
+            'chart_of_accounts': company.account_setup_coa_done,
+            'initial_balance': company.opening_move_posted(),
+        }
+
+    def mark_bank_setup_as_done_action(self):
+        """ Marks the 'bank setup' step as done in the setup bar and in the company."""
+        self.company_id.account_setup_bank_data_done = True
+
+    def unmark_bank_setup_as_done_action(self):
+        """ Marks the 'bank setup' step as not done in the setup bar and in the company."""
+        self.company_id.account_setup_bank_data_done = False

--- a/addons/account/models/account_move.py
+++ b/addons/account/models/account_move.py
@@ -15,7 +15,6 @@ from lxml import etree
 # Entries
 #----------------------------------------------------------
 
-
 class AccountMove(models.Model):
     _name = "account.move"
     _description = "Account Entry"
@@ -455,6 +454,9 @@ class AccountMoveLine(models.Model):
         help="Technical field used to mark a tax line as exigible in the vat report or not (only exigible journal items are displayed). By default all new journal items are directly exigible, but with the feature cash_basis on taxes, some will become exigible only when the payment is recorded.")
     parent_state = fields.Char(compute="_compute_parent_state", help="State of the parent account.move")
 
+    #Needed for setup, as a decoration attribute needs to know that for a tree view in one of the popups, and there's no way to reference directly a xml id from there
+    is_unaffected_earnings_line = fields.Boolean(string="Is Unaffected Earnings Line", compute="_compute_is_unaffected_earnings_line", help="Tells whether or not this line belongs to an unaffected earnings account")
+
     _sql_constraints = [
         ('credit_debit1', 'CHECK (credit*debit=0)', 'Wrong credit or debit value in accounting entry !'),
         ('credit_debit2', 'CHECK (credit+debit>=0)', 'Wrong credit or debit value in accounting entry !'),
@@ -501,6 +503,12 @@ class AccountMoveLine(models.Model):
                 if (line.amount_currency > 0.0 and line.credit > 0.0) or (line.amount_currency < 0.0 and line.debit > 0.0):
                     raise ValidationError(_('The amount expressed in the secondary currency must be positive when account is debited and negative when account is credited.'))
 
+    @api.depends('account_id.user_type_id')
+    def _compute_is_unaffected_earnings_line(self):
+        for record in self:
+            unaffected_earnings_type = self.env.ref("account.data_unaffected_earnings")
+            record.is_unaffected_earnings_line = unaffected_earnings_type == record.account_id.user_type_id
+
     @api.onchange('amount_currency', 'currency_id')
     def _onchange_amount_currency(self):
         '''Recompute the debit/credit based on amount_currency/currency_id and date.

--- a/addons/account/models/chart_template.py
+++ b/addons/account/models/chart_template.py
@@ -350,7 +350,7 @@ class AccountChartTemplate(models.Model):
 
     @api.multi
     def create_record_with_xmlid(self, company, template, model, vals):
-        # Create a record for the given model with the given vals and 
+        # Create a record for the given model with the given vals and
         # also create an entry in ir_model_data to have an xmlid for the newly created record
         # xmlid is the concatenation of company_id and template_xml_id
         ir_model_data = self.env['ir.model.data']
@@ -912,14 +912,7 @@ class WizardMultiChartsAccounts(models.TransientModel):
         self._create_bank_journals_from_o2m(company, acc_template_ref)
 
         # Create the current year earning account if it wasn't present in the CoA
-        account_obj = self.env['account.account']
-        unaffected_earnings_xml = self.env.ref("account.data_unaffected_earnings")
-        if unaffected_earnings_xml and not account_obj.search([('company_id', '=', company.id), ('user_type_id', '=', unaffected_earnings_xml.id)]):
-            account_obj.create({
-                'code': '999999',
-                'name': _('Undistributed Profits/Losses'),
-                'user_type_id': unaffected_earnings_xml.id,
-                'company_id': company.id,})
+        company.get_unaffected_earnings_account()
         return {}
 
     @api.multi

--- a/addons/account/models/company.py
+++ b/addons/account/models/company.py
@@ -1,8 +1,11 @@
 # -*- coding: utf-8 -*-
 
+from datetime import timedelta
+
 from odoo import fields, models, api, _
 from odoo.exceptions import ValidationError
-from datetime import timedelta
+from odoo.exceptions import UserError
+from odoo.tools.float_utils import float_round, float_is_zero
 
 
 class ResCompany(models.Model):
@@ -46,6 +49,18 @@ Thank you in advance for your cooperation.
 Best Regards,''')
     tax_exigibility = fields.Boolean(string='Use Cash Basis')
 
+    #Fields of the setup step for opening move
+    account_opening_move_id = fields.Many2one(string='Opening Journal Entry', comodel_name='account.move', help="The journal entry containing the initial balance of all this company's accounts.")
+    account_opening_journal_id = fields.Many2one(string='Opening Journal', comodel_name='account.journal', related='account_opening_move_id.journal_id', help="Journal where the opening entry of this company's accounting has been posted.")
+    account_opening_date = fields.Date(string='Opening Date', related='account_opening_move_id.date', help="Date at which the opening entry of this company's accounting has been posted.")
+
+    #Fields marking the completion of a setup step
+    account_setup_company_data_done = fields.Boolean(string='Company Setup Marked As Done', help="Technical field holding the status of the company setup step.")
+    account_setup_bank_data_done = fields.Boolean('Bank Setup Marked As Done', help="Technical field holding the status of the bank setup step.")
+    account_setup_fy_data_done = fields.Boolean('Financial Year Setup Marked As Done', help="Technical field holding the status of the financial year setup step.")
+    account_setup_coa_done = fields.Boolean(string='Chart of Account Checked', help="Technical field holding the status of the chart of account setup step.")
+    account_setup_bar_closed = fields.Boolean(string='Setup Bar Closed', help="Technical field set to True when setup bar has been closed by the user.")
+
     @api.multi
     def compute_fiscalyear_dates(self, date):
         """ Computes the start and end dates of the fiscalyear where the given 'date' belongs to
@@ -112,3 +127,218 @@ Best Regards,''')
             if values.get('accounts_code_digits'):
                 company.reflect_code_digits_change(digits)
         return super(ResCompany, self).write(values)
+
+    @api.model
+    def setting_init_company_action(self):
+        """ Called by the 'Company Data' button of the setup bar."""
+        company = self.env.user.company_id
+        view_id = self.env.ref('account.setup_view_company_form').id
+        return {'type': 'ir.actions.act_window',
+                'name': _('Company Data'),
+                'res_model': 'res.company',
+                'target': 'new',
+                'view_mode': 'form',
+                'res_id': company.id,
+                'views': [[view_id, 'form']],
+        }
+
+    @api.model
+    def setting_init_bank_account_action(self):
+        """ Called by the 'Bank Accounts' button of the setup bar."""
+        company = self.env.user.company_id
+        view_id = self.env.ref('account.setup_bank_journal_form').id
+
+        res = {
+            'type': 'ir.actions.act_window',
+            'name': _('Bank Account'),
+            'view_mode': 'form',
+            'res_model': 'account.journal',
+            'target': 'new',
+            'views': [[view_id, 'form']],
+        }
+
+        # If some bank journal already exists, we open it in the form, so the user can edit it.
+        # Otherwise, we just open the form in creation mode.
+        bank_journal = self.env['account.journal'].search([('company_id','=', company.id), ('type','=','bank')], limit=1)
+        if bank_journal:
+            res['res_id'] = bank_journal.id
+        else:
+            res['context'] = {'default_type': 'bank'}
+        return res
+
+    @api.model
+    def setting_init_fiscal_year_action(self):
+        """ Called by the 'Fiscal Year Opening' button of the setup bar."""
+        company = self.env.user.company_id
+        company.create_op_move_if_non_existant()
+        new_wizard = self.env['account.financial.year.op'].create({'company_id': company.id})
+        view_id = self.env.ref('account.setup_financial_year_opening_form').id
+
+        return {
+            'type': 'ir.actions.act_window',
+            'name': _('Fiscal Year'),
+            'view_mode': 'form',
+            'res_model': 'account.financial.year.op',
+            'target': 'new',
+            'res_id': new_wizard.id,
+            'views': [[view_id, 'form']],
+        }
+
+    @api.model
+    def setting_chart_of_accounts_action(self):
+        """ Called by the 'Chart of Accounts' button of the setup bar."""
+        company = self.env.user.company_id
+        company.account_setup_coa_done = True
+
+        # If an opening move has already been posted, we open the tree view showing all the accounts
+        if company.opening_move_posted():
+            return 'account.action_account_form'
+
+        # Otherwise, we create the opening move
+        company.create_op_move_if_non_existant()
+
+        # Then, we open will open a custom tree view allowing to edit opening balances of the account
+        view_id = self.env.ref('account.init_accounts_tree').id
+        # Hide the current year earnings account as it is automatically computed
+        domain = [('user_type_id', '!=', self.env.ref('account.data_unaffected_earnings').id), ('company_id','=', company.id)]
+        return {
+            'type': 'ir.actions.act_window',
+            'name': _('Chart of Accounts'),
+            'res_model': 'account.account',
+            'view_mode': 'tree',
+            'search_view_id': self.env.ref('account.view_account_search').id,
+            'views': [[view_id, 'list']],
+            'domain': domain,
+        }
+
+    @api.model
+    def setting_opening_move_action(self):
+        """ Called by the 'Initial Balances' button of the setup bar."""
+        company = self.env.user.company_id
+
+        # If the opening move has already been posted, we open its form view
+        if company.opening_move_posted():
+            form_view_id = self.env.ref('account.setup_posted_move_form').id
+            return {
+                'type': 'ir.actions.act_window',
+                'name': _('Initial Balances'),
+                'view_mode': 'form',
+                'res_model': 'account.move',
+                'target': 'new',
+                'res_id': company.account_opening_move_id.id,
+                'views': [[form_view_id, 'form']],
+            }
+
+        # Otherwise, we open a custom wizard to post it.
+        company.create_op_move_if_non_existant()
+        new_wizard = self.env['account.opening'].create({'company_id': company.id})
+        view_id = self.env.ref('account.setup_opening_move_wizard_form').id
+
+        return {
+            'type': 'ir.actions.act_window',
+            'name': _('Initial Balances'),
+            'view_mode': 'form',
+            'res_model': 'account.opening',
+            'target': 'new',
+            'res_id': new_wizard.id,
+            'views': [[view_id, 'form']],
+            'context': {'check_move_validity': False},
+        }
+
+    @api.model
+    def setting_hide_setup_bar(self):
+        """ Called by the cross button of the setup bar, to close it."""
+        self.env.user.company_id.account_setup_bar_closed = True
+
+    @api.model
+    def create_op_move_if_non_existant(self):
+        """ Creates an empty opening move in 'draft' state for the current company
+        if there wasn't already one defined. For this, the function needs at least
+        one journal of type 'general' to exist (required by account.move).
+        """
+        self.ensure_one()
+        if not self.account_opening_move_id:
+            default_journal = self.env['account.journal'].search([('type', '=', 'general'), ('company_id', '=', self.id)], limit=1)
+
+            if not default_journal:
+                raise UserError(_("No miscellanous journal could be found. Please create one before proceeding."))
+
+            self.account_opening_move_id = self.env['account.move'].create({
+                'name': _('Opening Journal Entry'),
+                'company_id': self.id,
+                'journal_id': default_journal.id,
+            })
+
+    def mark_company_setup_as_done_action(self):
+        """ Marks the 'company' setup step as completed."""
+        self.account_setup_company_data_done = True
+
+    def unmark_company_setup_as_done_action(self):
+        """ Marks the 'company' setup step as uncompleted."""
+        self.account_setup_company_data_done = False
+
+    def opening_move_posted(self):
+        """ Returns true if this company has an opening account move and this move is posted."""
+        return bool(self.account_opening_move_id) and self.account_opening_move_id.state == 'posted'
+
+    def get_unaffected_earnings_account(self):
+        """ Returns the unaffected earnings account for this company, creating one
+        if none has yet been defined.
+        """
+        unaffected_earnings_type = self.env.ref("account.data_unaffected_earnings")
+        account = self.env['account.account'].search([('company_id', '=', self.id),
+                                                      ('user_type_id', '=', unaffected_earnings_type.id)])
+        if not account:
+            account = self.env['account.account'].create({
+                'code': '999999',
+                'name': _('Undistributed Profits/Losses'),
+                'user_type_id': unaffected_earnings_type.id,
+                'company_id': self.id,
+            })
+        return account
+
+    def get_opening_move_differences(self, opening_move_lines):
+        currency = self.currency_id
+        balancing_move_line = opening_move_lines.filtered(lambda x: x.account_id == self.get_unaffected_earnings_account())
+
+        debits_sum = credits_sum = 0.0
+        for line in opening_move_lines:
+            if line != balancing_move_line:
+                #skip the autobalancing move line
+                debits_sum += line.debit
+                credits_sum += line.credit
+
+        difference = abs(debits_sum - credits_sum)
+        debit_diff = (debits_sum > credits_sum) and float_round(difference, precision_rounding=currency.rounding) or 0.0
+        credit_diff = (debits_sum < credits_sum) and float_round(difference, precision_rounding=currency.rounding) or 0.0
+        return debit_diff, credit_diff
+
+    def _auto_balance_opening_move(self):
+        """ Checks the opening_move of this company. If it has not been posted yet
+        and is unbalanced, balances it with a automatic account.move.line in the
+        current year earnings account.
+        """
+        if self.account_opening_move_id and self.account_opening_move_id.state == 'draft':
+            debit_diff, credit_diff = self.get_opening_move_differences(self.account_opening_move_id.line_ids)
+
+            currency = self.currency_id
+            balancing_move_line = self.account_opening_move_id.line_ids.filtered(lambda x: x.account_id == self.get_unaffected_earnings_account())
+
+            if float_is_zero(debit_diff + credit_diff, precision_rounding=currency.rounding):
+                if balancing_move_line:
+                    # zero difference and existing line : delete the line
+                    balancing_move_line.unlink()
+            else:
+                if balancing_move_line:
+                    # Non-zero difference and existing line : edit the line
+                    balancing_move_line.write({'debit': credit_diff, 'credit': debit_diff})
+                else:
+                    # Non-zero difference and no existing line : create a new line
+                    balancing_account = self.get_unaffected_earnings_account()
+                    self.env['account.move.line'].create({
+                        'name': _('Automatic Balancing Line'),
+                        'move_id': self.account_opening_move_id.id,
+                        'account_id': balancing_account.id,
+                        'debit': credit_diff,
+                        'credit': debit_diff,
+                    })
