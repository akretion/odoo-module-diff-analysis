PR: https://github.com/odoo/odoo/pull/

From: 5450415354233671fe42f62c3b095d03c1389317
From: Thibault Delavall√©e
Date: 2019-08-12 12:00:22

Structural Changes: 2
Total Changes: 34

[REF] sms: improve onboarding and user experience of SMS composer

PURPOSE

SMS are a powerful marketing tool. For instance it is perfect to announce a
sale or to communicate a coupon code, to welcome a new customer in a fidelity
program, ...

Purpose of this task is to integrate SMS sending in batch in mass mailing. It
will use same mailing objects but sending SMS instead of emails. Some metrics
and flows will have to be slightly updated at the same time.

SPECIFICATIONS

Clean the use and options of sms composer after FP feedback :

  * see https://s.nimbusweb.me/share/3167586/ap1xpy95rz29a5cys576 as basis;
  * globally, do not display invalid recipients, only valid / invalid count
    as well as current selection / active domain counts;
  * consider logging a note as default behavior when using the composer;
  * simplify code: when doing a mass SMS, send SMS and attach a simple note
    to the document;

Some other points

  * make name of sms templates translatable;
  * improve various wording, notably in sms widget;
  * display error code in sms list view;
  * update sms composer actions accordingly by correctly setting active id
    or ids;

LINKS

Task 1997464
PR #34424
Original SMS addition: Task 1922163 (4287481)

================================= pseudo patch: =================================

--- a/addons/sms/models/mail_thread.py
+++ b/addons/sms/models/mail_thread.py
@@ -127,7 +127,7 @@ class MailThread(models.AbstractModel):
 
         create_vals = {
             'mass_force_send': False,
-            'mass_keep_log': False,
+            'mass_keep_log': True,
         }
         if composer_values:
             create_vals.update(composer_values)

--- a/addons/sms/models/sms_sms.py
+++ b/addons/sms/models/sms_sms.py
@@ -15,6 +15,13 @@ class SmsSms(models.Model):
     _rec_name = 'number'
     _order = 'id DESC'
 
+    IAP_TO_SMS_STATE = {
+        'success': 'sent',
+        'insufficient_credit': 'sms_credit',
+        'wrong_number_format': 'sms_number_format',
+        'server_error': 'sms_server'
+    }
+
     number = fields.Char('Number', required=True)
     body = fields.Text()
     partner_id = fields.Many2one('res.partner', 'Customer')
@@ -95,27 +102,24 @@ class SmsSms(models.Model):
             _logger.info('Sent batch %s SMS: %s: failed with exception %s', len(self.ids), self.ids, e)
             if raise_exception:
                 raise
-            self._postprocess_sent_sms([{'res_id': sms.id, 'state': 'server_error'} for sms in self], delete_all=delete_all)
+            self._postprocess_iap_sent_sms([{'res_id': sms.id, 'state': 'server_error'} for sms in self], delete_all=delete_all)
         else:
             _logger.info('Send batch %s SMS: %s: gave %s', len(self.ids), self.ids, iap_results)
-            self._postprocess_sent_sms(iap_results, delete_all=delete_all)
+            self._postprocess_iap_sent_sms(iap_results, delete_all=delete_all)
 
-    def _postprocess_sent_sms(self, iap_results, failure_reason=None, delete_all=False):
-        sms_to_notif_status = {
-            'success': False, 'insufficient_credit': 'sms_credit',
-            'wrong_number_format': 'sms_number_format', 'server_error': 'sms_server'}
+    def _postprocess_iap_sent_sms(self, iap_results, failure_reason=None, delete_all=False):
         if delete_all:
             todelete_sms_ids = [item['res_id'] for item in iap_results]
         else:
             todelete_sms_ids = [item['res_id'] for item in iap_results if item['state'] == 'success']
 
-        for state in sms_to_notif_status.keys():
+        for state in self.IAP_TO_SMS_STATE.keys():
             sms_ids = [item['res_id'] for item in iap_results if item['state'] == state]
             if sms_ids:
-                if not delete_all and state != 'success':
+                if state != 'success' and not delete_all:
                     self.env['sms.sms'].sudo().browse(sms_ids).write({
                         'state': 'error',
-                        'error_code': sms_to_notif_status[state],
+                        'error_code': self.IAP_TO_SMS_STATE[state],
                     })
                 notifications = self.env['mail.notification'].sudo().search([
                     ('notification_type', '=', 'sms'),
@@ -125,15 +129,9 @@ class SmsSms(models.Model):
                 if notifications:
                     notifications.write({
                         'notification_status': 'sent' if state == 'success' else 'exception',
-                        'failure_type': sms_to_notif_status[state],
+                        'failure_type': self.IAP_TO_SMS_STATE[state] if state != 'success' else False,
                         'failure_reason': failure_reason if failure_reason else False,
                     })
 
         if todelete_sms_ids:
             self.browse(todelete_sms_ids).sudo().unlink()
-
-    def cancel(self):
-        self.write({
-            'state': 'canceled',
-            'error_code': False
-        })

--- a/addons/sms/models/sms_template.py
+++ b/addons/sms/models/sms_template.py
@@ -16,7 +16,7 @@ class SMSTemplate(models.Model):
             res['model_id'] = self.env['ir.model']._get(res['model']).id
         return res
 
-    name = fields.Char()
+    name = fields.Char('Name', translate=True)
     model_id = fields.Many2one(
         'ir.model', string='Applies to', required=True,
         domain=['&', ('is_mail_thread', '=', True), ('transient', '=', False)],
