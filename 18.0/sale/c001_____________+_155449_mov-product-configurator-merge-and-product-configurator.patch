PR: https://github.com/odoo/odoo/pull/155449

From: fdcd3d5804cb86f3bda472e093739b7393c63659
From: Valentin Chevalier
Date: 2024-03-20 09:34:59

Structural Changes: 6
Total Changes: 50

[MOV] *_product_configurator,*: Merge * and *_product_configurator

Since ee3bf99, `sale_product_configurator` is auto-installed. The
settings to enable or disable it have been removed and the only way to
deactivate the product configurator is to uninstall the module but then
it provides a poor UX (eg. in `website_sale` buy now button on /shop
page adds the first available combination to the cart instead of opening
the configurator).

Therefore, we have decided to merge modules to improve the readability
and reduce the complexity of our codebase.

task-3763473

closes odoo/odoo#155449

Related: odoo/upgrade#5750
Related: odoo/enterprise#57577
Signed-off-by: Victor Feyens (vfe) <vfe@odoo.com>

================================= pseudo patch: =================================

--- a/addons/sale/models/product_template.py
+++ b/addons/sale/models/product_template.py
@@ -8,6 +8,7 @@ from odoo.tools.float_utils import float_round
 
 class ProductTemplate(models.Model):
     _inherit = 'product.template'
+    _check_company_auto = True
 
     service_type = fields.Selection(
         selection=[('manual', "Manually set quantities on order")],
@@ -42,6 +43,17 @@ class ProductTemplate(models.Model):
         compute='_compute_invoice_policy', store=True, readonly=False, precompute=True,
         help="Ordered Quantity: Invoice quantities ordered by the customer.\n"
              "Delivered Quantity: Invoice quantities delivered to the customer.")
+    optional_product_ids = fields.Many2many(
+        comodel_name='product.template',
+        relation='product_optional_rel',
+        column1='src_id',
+        column2='dest_id',
+        string="Optional Products",
+        help="Optional Products are suggested "
+             "whenever the customer hits *Add to Cart* (cross-sell strategy, "
+             "e.g. for computers: warranty, software, etc.).",
+        check_company=True)
+
 
     @api.depends('name')
     def _compute_visible_expense_policy(self):
@@ -58,6 +70,19 @@ class ProductTemplate(models.Model):
         for product in self:
             product.sales_count = float_round(sum([p.sales_count for p in product.with_context(active_test=False).product_variant_ids]), precision_rounding=product.uom_id.rounding)
 
+    @api.depends('attribute_line_ids.value_ids.is_custom', 'attribute_line_ids.attribute_id.create_variant')
+    def _compute_has_configurable_attributes(self):
+        """ A product is considered configurable if:
+        - It has dynamic attributes
+        - It has any attribute line with at least 2 attribute values configured
+        - It has at least one custom attribute value """
+        for product in self:
+            product.has_configurable_attributes = (
+                any(attribute.create_variant == 'dynamic' for attribute in product.attribute_line_ids.attribute_id)
+                or any(len(attribute_line_id.value_ids) >= 2 for attribute_line_id in product.attribute_line_ids)
+                or any(attribute_value.is_custom for attribute_value in product.attribute_line_ids.value_ids)
+            )
+
     @api.constrains('company_id')
     def _check_sale_product_company(self):
         """Ensure the product is not being restricted to a single company while
@@ -142,3 +167,21 @@ class ProductTemplate(models.Model):
                     val['name'],
                     ','.join(field_descriptions[v] for v in incompatible_fields),
                 ))
+
+    def get_single_product_variant(self):
+        """ Method used by the product configurator to check if the product is configurable or not.
+
+        We need to open the product configurator if the product:
+        - is configurable (see has_configurable_attributes)
+        - has optional products """
+        res = super().get_single_product_variant()
+        if res.get('product_id', False):
+            has_optional_products = False
+            for optional_product in self.product_variant_id.optional_product_ids:
+                if optional_product.has_dynamic_attributes() or optional_product._get_possible_variants(
+                    self.product_variant_id.product_template_attribute_value_ids
+                ):
+                    has_optional_products = True
+                    break
+            res.update({'has_optional_products': has_optional_products})
+        return res

--- a/addons/sale/models/sale_order_line.py
+++ b/addons/sale/models/sale_order_line.py
@@ -69,6 +69,10 @@ class SaleOrderLine(models.Model):
             ('line_note', "Note"),
         ],
         default=False)
+    is_configurable_product = fields.Boolean(
+        string="Is the product configurable?",
+        related='product_template_id.has_configurable_attributes',
+        depends=['product_id'])
     is_downpayment = fields.Boolean(
         string="Is a down payment",
         help="Down payments are made when creating invoices from a sales order."
@@ -95,6 +99,9 @@ class SaleOrderLine(models.Model):
         domain=[('sale_ok', '=', True)])
     product_uom_category_id = fields.Many2one(related='product_id.uom_id.category_id', depends=['product_id'])
 
+    product_template_attribute_value_ids = fields.Many2many(
+        related='product_id.product_template_attribute_value_ids',
+        depends=['product_id'])
     product_custom_attribute_value_ids = fields.One2many(
         comodel_name='product.attribute.custom.value', inverse_name='sale_order_line_id',
         string="Custom Values",
