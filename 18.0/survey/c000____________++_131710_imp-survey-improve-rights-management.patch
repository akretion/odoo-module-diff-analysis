PR: https://github.com/odoo/odoo/pull/131710

From: 027a2a66d63225abbfaef425448188007f573ac5
From: Lopes Marc (loma)
Date: 2024-03-19 11:11:44

Structural Changes: 4
Total Changes: 55

[IMP] survey,*: improve rights management

*: hr_recruitment_survey, website_slides_survey

Purpose
=======

It is currently tricky to manage touchy surveys. For instance, Odoo
Certification can currently be edited by a Survey admin and a Survey
user. However, Survey users have read rights on all surveys meaning that
they can all see questions and answers of sensitive survey. The goal of
this spec is to improve the current situation.

In addition, other addons need to grant access rights to survey records
for functional reasons. For the community version of Odoo, see the
hr_recruitment_survey and the website_slides_survey addons. This PR is
an opportunity to improve the distribution of these rights and limit
potential security vulnerabilities.

Aslo, we want the Survey "Administrators" and "Users" be able to
access 'external' surveys like recruitment interviews or  360 feedbacks,
for management purpose, but not the answers from the participants.

Specifications
==============

1. Allow to restrict a survey access to selected users.
2. Survey "Users" have rights on a survey if its 'restricted' list is
   empty or if they are part of it.
3. Survey "Administrators" keep all access on any surveys (except for
   user inputs from interviews or 360 feedbacks).
4. New survey type for Recruitment app:
    - add a new survey type to manage surveys specific to hr_recruitment
    - assign rights and access rules on survey for groups
      hr_recruitment_[manager/user/interviewer].
    - allow access to these surveys from the Recruitment app
    - handle the conditional display of certain elements in survey views
      (form, kanban, button_view_form) depending on the survey
      type and/or user rights.
    - Allow the use of the SurveyInvite wizard from the hr_recruitment
      app
    - complete existing hr_recruitment_survey tests with access tests.
5. Eleaning officer group: add record rules to limit their access to
   certifications and avoid potential access errors raised by rules
   from implied groups.

Note we are removing the "groups" attribute on the
"survey.user_input_ids" field. It allows the use of the SurveyInvite
wizard from other user groups than the survey User/Administrators. The
attribute is no longer necessary thanks to the new record rules.

task-3451217

Part-of: odoo/odoo#131710

================================= pseudo patch: =================================

--- a/addons/survey/models/survey_survey.py
+++ b/addons/survey/models/survey_survey.py
@@ -64,6 +64,7 @@ class Survey(models.Model):
         ('custom', 'Custom'),
     ],
         string='Survey Type', required=True, default='custom')
+    allowed_survey_types = fields.Json(string='Allowed survey types', compute="_compute_allowed_survey_types")
     title = fields.Char('Survey Title', required=True, translate=True)
     color = fields.Integer('Color Index', default=0)
     description = fields.Html(
@@ -77,8 +78,9 @@ class Survey(models.Model):
     active = fields.Boolean("Active", default=True)
     user_id = fields.Many2one(
         'res.users', string='Responsible',
-        domain=[('share', '=', False)], tracking=True,
+        domain=[('share', '=', False)], tracking=1,
         default=lambda self: self.env.user)
+    restrict_user_ids = fields.Many2many('res.users', string='Restricted to', domain=[('share', '=', False)], tracking=2)
     # questions
     question_and_page_ids = fields.One2many('survey.question', 'survey_id', string='Sections and Questions', copy=True)
     page_ids = fields.One2many('survey.question', string='Pages', compute="_compute_page_and_question_ids")
@@ -99,7 +101,7 @@ class Survey(models.Model):
         ('number', 'Number')], string='Display Progress as', default='percent',
         help="If Number is selected, it will display the number of questions answered on the total number of question to answer.")
     # attendees
-    user_input_ids = fields.One2many('survey.user_input', 'survey_id', string='User responses', readonly=True, groups='survey.group_survey_user')
+    user_input_ids = fields.One2many('survey.user_input', 'survey_id', string='User responses', readonly=True)
     # security / access
     access_mode = fields.Selection([
         ('public', 'Anyone with the link'),
@@ -365,6 +367,15 @@ class Survey(models.Model):
         for survey in self:
             survey.session_available = survey.survey_type in {'live_session', 'custom'}
 
+    @api.depends_context('uid')
+    def _compute_allowed_survey_types(self):
+        self.allowed_survey_types = [
+            ('survey', 'Survey'),
+            ('live_session', 'Live session'),
+            ('assessment', 'Assessment'),
+            ('custom', 'Custom'),
+        ] if self.env.user.has_group('survey.group_survey_user') else False
+
     @api.onchange('survey_type')
     def _onchange_survey_type(self):
         if self.survey_type == 'survey':
@@ -397,6 +408,19 @@ class Survey(models.Model):
             survey.question_ids._update_time_limit_from_survey(
                 is_time_limited=survey.session_speed_rating, time_limit=survey.session_speed_rating_time_limit)
 
+    @api.onchange('restrict_user_ids', 'user_id')
+    def _onchange_restrict_user_ids(self):
+        """
+         Add survey user_id to restrict_user_ids when:
+         - restrict_user_ids is not False
+         - user_id is not part of restrict_user_ids
+         - user_id is not a survey manager
+        """
+        surveys_to_check = self.filtered(lambda s: s.restrict_user_ids and bool(s.user_id - s.restrict_user_ids))
+        users_are_managers = surveys_to_check.user_id.filtered(lambda user: user.has_group('survey.group_survey_manager'))
+        for survey in surveys_to_check.filtered(lambda s: s.user_id not in users_are_managers):
+            survey.restrict_user_ids += survey.user_id
+
     @api.constrains('scoring_type', 'users_can_go_back')
     def _check_scoring_after_page_availability(self):
         failing = self.filtered(lambda survey: survey.scoring_type == 'scoring_with_answers_after_page' and survey.users_can_go_back)
@@ -406,6 +430,22 @@ class Survey(models.Model):
                   survey_names="\n- ".join(failing.mapped('title')))
             )
 
+    @api.constrains('user_id', 'restrict_user_ids')
+    def _check_survey_responsible_access(self):
+        """ When:
+                - a survey access is restricted to a list of users
+                - and there is a survey responsible,
+                - and this responsible is not survey manager (just survey officer),
+            check the responsible is part of the list."""
+        surveys_to_check = self.filtered(lambda s: bool(s.user_id - s.restrict_user_ids))
+        if surveys_to_check:
+            valid_surveys = surveys_to_check._filter_access_rules_python("write")
+            failing_surveys_sudo = (self - valid_surveys).sudo()
+            if failing_surveys_sudo:
+                raise ValidationError(
+                    _('The access of the following surveys is restricted. Make sure their responsible still has access to it: \n%(survey_names)s\n',
+                        survey_names='\n'.join(f'- {survey.title}: {survey.user_id.name}' for survey in failing_surveys_sudo)))
+
     # ------------------------------------------------------------
     # CRUD
     # ------------------------------------------------------------
@@ -544,10 +584,13 @@ class Survey(models.Model):
         """ Ensure conditions to create new tokens are met. """
         self.ensure_one()
         if test_entry:
-            # the current user must have the access rights to survey
-            if not user.has_group('survey.group_survey_user'):
+            try:
+                self.with_user(user).check_access_rights('read')
+                self.with_user(user).check_access_rule('read')
+            except AccessError:
                 raise exceptions.UserError(_('Creating test token is not allowed for you.'))
-        else:
+
+        if not test_entry:
             if not self.active:
                 raise exceptions.UserError(_('Creating token for closed/archived surveys is not allowed.'))
             if self.access_mode == 'authentication':

--- a/addons/survey/models/survey_user_input.py
+++ b/addons/survey/models/survey_user_input.py
@@ -23,7 +23,7 @@ class SurveyUserInput(models.Model):
     _inherit = ['mail.thread', 'mail.activity.mixin']
 
     # answer description
-    survey_id = fields.Many2one('survey.survey', string='Survey', required=True, readonly=True, ondelete='cascade')
+    survey_id = fields.Many2one('survey.survey', string='Survey', required=True, readonly=True, index=True, ondelete='cascade')
     scoring_type = fields.Selection(string="Scoring", related="survey_id.scoring_type")
     start_datetime = fields.Datetime('Start date and time', readonly=True)
     end_datetime = fields.Datetime('End date and time', readonly=True)
