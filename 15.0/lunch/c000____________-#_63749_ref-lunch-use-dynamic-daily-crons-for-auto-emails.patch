PR: https://github.com/odoo/odoo/pull/63749

From: e5cf8cc8b7c4919be9617362fc541027c38b8d86
From: Julien Castiaux
Date: 2021-03-17 02:10:41

Structural Changes: 2
Total Changes: 273

[REF] Lunch: Use dynamic daily crons for auto emails

The Lunch module can automatically send an email to a supplier with the
daily orders at a configured time. It can also remind the users via chat
so they don't forget to order their sanddwish.

Before, two high frequency cron jobs were responsible to check every 20
and 5 minutes if we reached the moment when to send the email to the
suppliers or the notification to the users. Together the two crons were
executed 360 times a day.

The new model uses a dedicated daily cron per supplier record and per
alert record, the dedicated cron is created on the fly and its moment of
execution automatically updated to reflect the supplier/alert record.

See also #41858 for prior work.

closes odoo/odoo#63749

Task: 2416741
Related: odoo/upgrade#2044
Signed-off-by: Julien Castiaux <Julien00859@users.noreply.github.com>

================================= pseudo patch: =================================

--- a/addons/lunch/models/lunch_alert.py
+++ b/addons/lunch/models/lunch_alert.py
@@ -1,16 +1,20 @@
-# -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 import pytz
+import logging
 
 from odoo import api, fields, models
 from odoo.osv import expression
 
 from .lunch_supplier import float_to_time
 from datetime import datetime, timedelta
+from textwrap import dedent
 
 from odoo.addons.base.models.res_partner import _tz_get
 
+_logger = logging.getLogger(__name__)
 WEEKDAY_TO_NAME = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday']
+CRON_DEPENDS = {'name', 'active', 'mode', 'until', 'notification_time', 'notification_moment', 'tz'}
+
 
 class LunchAlert(models.Model):
     """ Alerts to display during a lunch order. An alert can be specific to a
@@ -35,6 +39,7 @@ class LunchAlert(models.Model):
         ('am', 'AM'),
         ('pm', 'PM')], default='am', required=True)
     tz = fields.Selection(_tz_get, string='Timezone', required=True, default=lambda self: self.env.user.tz or 'UTC')
+    cron_id = fields.Many2one('ir.cron', ondelete='cascade', required=True, readonly=True)
 
     until = fields.Date('Show Until')
     recurrency_monday = fields.Boolean('Monday', default=True)
@@ -84,36 +89,98 @@ class LunchAlert(models.Model):
             ])
         ])
 
-    def _notify_chat(self):
-        records = self.search([('mode', '=', 'chat'), ('active', '=', True)])
-
-        today = fields.Date.today()
-        now = fields.Datetime.now()
-
-        for alert in records:
-            notification_to = now.astimezone(pytz.timezone(alert.tz)).replace(second=0, microsecond=0, tzinfo=None)
-            notification_from = notification_to - timedelta(minutes=5)
-            send_at = datetime.combine(fields.Date.today(),
-                float_to_time(alert.notification_time, alert.notification_moment))
-
-            if alert.available_today and send_at > notification_from and send_at <= notification_to:
-                order_domain = [('state', '!=', 'cancelled')]
-
-                if alert.location_ids.ids:
-                    order_domain = expression.AND([order_domain, [('user_id.last_lunch_location_id', 'in', alert.location_ids.ids)]])
+    def _sync_cron(self):
+        """ Synchronise the related cron fields to reflect this alert """
+        for alert in self:
+            alert = alert.with_context(tz=alert.tz)
+
+            cron_required = (
+                alert.active
+                and alert.mode == 'chat'
+                and (not alert.until or fields.Date.context_today(alert) <= alert.until)
+            )
+
+            sendat_tz = pytz.timezone(alert.tz).localize(datetime.combine(
+                fields.Date.context_today(alert, fields.Datetime.now()),
+                float_to_time(alert.notification_time, alert.notification_moment)))
+            lc = alert.cron_id.lastcall
+            if ((
+                lc and sendat_tz.date() <= fields.Datetime.context_timestamp(alert, lc).date()
+            ) or (
+                not lc and sendat_tz <= fields.Datetime.context_timestamp(alert, fields.Datetime.now())
+            )):
+                sendat_tz += timedelta(days=1)
+            sendat_utc = sendat_tz.astimezone(pytz.UTC).replace(tzinfo=None)
+
+            alert.cron_id.name = f"Lunch: alert chat notification ({alert.name})"
+            alert.cron_id.active = cron_required
+            alert.cron_id.nextcall = sendat_utc
+            alert.cron_id.code = dedent(f"""\
+                # This cron is dynamically controlled by {self._description}.
+                # Do NOT modify this cron, modify the related record instead.
+                env['{self._name}'].browse([{alert.id}])._notify_chat()""")
+
+    @api.model_create_multi
+    def create(self, vals_list):
+        crons = self.env['ir.cron'].sudo().create([
+            {
+                'user_id': self.env.ref('base.user_root').id,
+                'active': False,
+                'interval_type': 'days',
+                'interval_number': 1,
+                'numbercall': -1,
+                'doall': False,
+                'name': "Lunch: alert chat notification",
+                'model_id': self.env['ir.model']._get_id(self._name),
+                'state': 'code',
+                'code': "",
+            }
+            for _ in range(len(vals_list))
+        ])
+        for vals, cron in zip(vals_list, crons):
+            vals['cron_id'] = cron.id
 
-                if alert.recipients != 'everyone':
-                    weeks = 1
+        alerts = super().create(vals_list)
+        alerts._sync_cron()
+        return alerts
 
-                    if alert.recipients == 'last_month':
-                        weeks = 4
-                    else:  # last_year
-                        weeks = 52
+    def write(self, values):
+        super().write(values)
+        if not CRON_DEPENDS.isdisjoint(values):
+            self._sync_cron()
 
-                    delta = timedelta(weeks=weeks)
-                    order_domain = expression.AND([order_domain, [('date', '>=', today - delta)]])
+    def unlink(self):
+        crons = self.cron_id
+        super().unlink()
+        crons.unlink()
 
-                orders = self.env['lunch.order'].search(order_domain).mapped('user_id')
-                partner_ids = [user.partner_id.id for user in orders]
-                if partner_ids:
-                    self.env['mail.thread'].message_notify(body=alert.message, partner_ids=partner_ids)
+    def _notify_chat(self):
+        # Called daily by cron
+        self.ensure_one()
+
+        if not self.available_today:
+            _logger.warning("cancelled, not available today")
+            if self.cron_id and self.until and fields.Date.context_today(self) > self.until:
+                self.cron_id.unlink()
+                self.cron_id = False
+            return
+
+        if not self.active or self.mode != 'chat':
+            raise ValueError("Cannot send a chat notification in the current state")
+
+        order_domain = [('state', '!=', 'cancelled')]
+
+        if self.location_ids.ids:
+            order_domain = expression.AND([order_domain, [('user_id.last_lunch_location_id', 'in', self.location_ids.ids)]])
+
+        if self.recipients != 'everyone':
+            weeksago = fields.Date.today() - timedelta(weeks=(
+                1 if self.recipients == 'last_week' else
+                4 if self.recipients == 'last_month' else
+                52  # if self.recipients == 'last_year'
+            ))
+            order_domain = expression.AND([order_domain, [('date', '>=', weeksago)]])
+
+        partners = self.env['lunch.order'].search(order_domain).user_id.partner_id
+        if partners:
+            self.env['mail.thread'].message_notify(body=self.message, partner_ids=partners.ids)

--- a/addons/lunch/models/lunch_supplier.py
+++ b/addons/lunch/models/lunch_supplier.py
@@ -1,10 +1,10 @@
-# -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
 import math
 import pytz
 
-from datetime import datetime, time
+from datetime import datetime, time, timedelta
+from textwrap import dedent
 
 from odoo import api, fields, models
 from odoo.osv import expression
@@ -14,6 +14,7 @@ from odoo.addons.base.models.res_partner import _tz_get
 
 
 WEEKDAY_TO_NAME = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday']
+CRON_DEPENDS = {'name', 'active', 'send_by', 'automatic_email_time', 'moment', 'tz'}
 
 def float_to_time(hours, moment='am', tz=None):
     """ Convert a number of hours into a time object. """
@@ -59,6 +60,7 @@ class LunchSupplier(models.Model):
         ('mail', 'Email'),
     ], 'Send Order By', default='phone')
     automatic_email_time = fields.Float('Order Time', default=12.0, required=True)
+    cron_id = fields.Many2one('ir.cron', ondelete='cascade', required=True, readonly=True)
 
     recurrency_monday = fields.Boolean('Monday', default=True)
     recurrency_tuesday = fields.Boolean('Tuesday', default=True)
@@ -103,46 +105,106 @@ class LunchSupplier(models.Model):
                 res.append((supplier.id, supplier.name))
         return res
 
-    @api.model
-    def _auto_email_send(self):
-        """
-            This method is called every 20 minutes via a cron.
-            Its job is simply to get all the orders made for each supplier and send an email
-            automatically to the supplier if the supplier is configured for it and we are ready
-            to send it (usually at 11am or so)
-        """
-        records = self.search([('send_by', '=', 'mail')])
-
-        for supplier in records:
-            send_at = datetime.combine(fields.Date.today(),
-                                       float_to_time(supplier.automatic_email_time, supplier.moment, supplier.tz)).astimezone(pytz.UTC).replace(tzinfo=None)
-            if supplier.available_today and fields.Datetime.now() > send_at:
-                lines = self.env['lunch.order'].search([('supplier_id', '=', supplier.id),
-                                                             ('state', '=', 'ordered'), ('date', '=', fields.Date.today())])
-
-                if lines:
-                    order = {
-                        'company_name': lines[0].company_id.name,
-                        'currency_id': lines[0].currency_id.id,
-                        'supplier_id': supplier.partner_id.id,
-                        'supplier_name': supplier.name,
-                        'email_from': supplier.responsible_id.email_formatted,
-                    }
-
-                    _lines = [{
-                        'product': line.product_id.name,
-                        'note': line.note,
-                        'quantity': line.quantity,
-                        'price': line.price,
-                        'toppings': line.display_toppings,
-                        'username': line.user_id.name,
-                    } for line in lines]
-
-                    order['amount_total'] = sum(line.price for line in lines)
-
-                    self.env.ref('lunch.lunch_order_mail_supplier').with_context(order=order, lines=_lines).send_mail(supplier.id)
-
-                    lines.action_confirm()
+    def _sync_cron(self):
+        for supplier in self:
+            supplier = supplier.with_context(tz=supplier.tz)
+
+            sendat_tz = pytz.timezone(supplier.tz).localize(datetime.combine(
+                fields.Date.context_today(supplier),
+                float_to_time(supplier.automatic_email_time, supplier.moment)))
+            lc = supplier.cron_id.lastcall
+            if ((
+                lc and sendat_tz.date() <= fields.Datetime.context_timestamp(supplier, lc).date()
+            ) or (
+                not lc and sendat_tz <= fields.Datetime.context_timestamp(supplier, fields.Datetime.now())
+            )):
+                sendat_tz += timedelta(days=1)
+            sendat_utc = sendat_tz.astimezone(pytz.UTC).replace(tzinfo=None)
+
+            supplier.cron_id.active = supplier.active and supplier.send_by == 'mail'
+            supplier.cron_id.name = f"Lunch: send automatic email to {supplier.name}"
+            supplier.cron_id.nextcall = sendat_utc
+            supplier.cron_id.code = dedent(f"""\
+                # This cron is dynamically controlled by {self._description}.
+                # Do NOT modify this cron, modify the related record instead.
+                env['{self._name}'].browse([{supplier.id}])._send_auto_email()""")
+
+    @api.model_create_multi
+    def create(self, vals_list):
+        crons = self.env['ir.cron'].sudo().create([
+            {
+                'user_id': self.env.ref('base.user_root').id,
+                'active': False,
+                'interval_type': 'days',
+                'interval_number': 1,
+                'numbercall': -1,
+                'doall': False,
+                'name': "Lunch: send automatic email",
+                'model_id': self.env['ir.model']._get_id(self._name),
+                'state': 'code',
+                'code': "",
+            }
+            for _ in range(len(vals_list))
+        ])
+        for vals, cron in zip(vals_list, crons):
+            vals['cron_id'] = cron.id
+
+        suppliers = super().create(vals_list)
+        suppliers._sync_cron()
+        return suppliers
+
+    def write(self, values):
+        super().write(values)
+        if not CRON_DEPENDS.isdisjoint(values):
+            self._sync_cron()
+
+    def unlink(self):
+        crons = self.cron_id
+        super().unlink()
+        crons.unlink()
+
+    def _send_auto_email(self):
+        """ Send an email to the supplier with the order of the day """
+        # Called daily by cron
+        self.ensure_one()
+
+        if not self.available_today:
+            return
+
+        if self.send_by != 'mail':
+            raise ValueError("Cannot send an email to this supplier")
+
+        orders = self.env['lunch.order'].search([
+            ('supplier_id', '=', self.id),
+            ('state', '=', 'ordered'),
+            ('date', '=', fields.Date.context_today(self.with_context(tz=self.tz))),
+        ])
+        if not orders:
+            return
+
+        order = {
+            'company_name': orders[0].company_id.name,
+            'currency_id': orders[0].currency_id.id,
+            'supplier_id': self.partner_id.id,
+            'supplier_name': self.name,
+            'email_from': self.responsible_id.email_formatted,
+            'amount_total': sum(order.price for order in orders),
+        }
+
+        email_orders = [{
+            'product': order.product_id.name,
+            'note': order.note,
+            'quantity': order.quantity,
+            'price': order.price,
+            'toppings': order.display_toppings,
+            'username': order.user_id.name,
+        } for order in orders]
+
+        self.env.ref('lunch.lunch_order_mail_supplier').with_context(
+            order=order, lines=email_orders
+        ).send_mail(self.id)
+
+        orders.action_confirm()
 
     @api.depends('recurrency_end_date', 'recurrency_monday', 'recurrency_tuesday',
                  'recurrency_wednesday', 'recurrency_thursday', 'recurrency_friday',
