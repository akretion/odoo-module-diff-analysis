PR: https://github.com/odoo/odoo/pull/

From: aa44700dccdc2618e0b8bc94252789264104047c
From: Ravi Gohil
Date: 2016-07-04 15:28:04

Structural Changes: 28.8
Total Changes: 2077

[MIG] crm : migration to new API

Also adapt code in crm_partner_assign according to migration of crm.lead

================================= pseudo patch: =================================

--- a/addons/crm/models/calendar.py
+++ b/addons/crm/models/calendar.py
@@ -1,21 +1,18 @@
 # -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
-from openerp.osv import fields, osv
-import logging
-_logger = logging.getLogger(__name__)
+from odoo import api, fields, models
 
 
-class calendar_event(osv.Model):
-    """ Model for Calendar Event """
+class CalendarEvent(models.Model):
+
     _inherit = 'calendar.event'
-    _columns = {
-        'opportunity_id': fields.many2one('crm.lead', 'Opportunity', domain="[('type', '=', 'opportunity')]"),
-    }
 
-    def create(self, cr, uid, vals, context=None):
-        res = super(calendar_event, self).create(cr, uid, vals, context=context)
-        obj = self.browse(cr, uid, res, context=context)
-        if obj.opportunity_id:
-            self.pool.get('crm.lead').log_meeting(cr, uid, [obj.opportunity_id.id], obj.name, obj.start, obj.duration, context=context)
-        return res
+    opportunity_id = fields.Many2one('crm.lead', 'Opportunity', domain="[('type', '=', 'opportunity')]")
+
+    @api.model
+    def create(self, vals):
+        event = super(CalendarEvent, self).create(vals)
+        if event.opportunity_id:
+            event.opportunity_id.log_meeting(event.name, event.start, event.duration)
+        return event

--- a/addons/crm/models/crm_activity.py
+++ b/addons/crm/models/crm_activity.py
@@ -1,7 +1,7 @@
 # -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
-from openerp import api, fields, models
+from odoo import api, fields, models
 
 
 class CrmActivity(models.Model):

--- a/addons/crm/models/crm_lead.py
+++ b/addons/crm/models/crm_lead.py
@@ -1,24 +1,22 @@
 # -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
+import logging
 from datetime import datetime, timedelta, date
 from dateutil.relativedelta import relativedelta
-import logging
-from operator import itemgetter
-from werkzeug import url_encode
-
-from openerp import SUPERUSER_ID
-from openerp import tools, api
-from openerp.addons.base.res.res_partner import FormatAddress
-from openerp.addons.crm.models import crm_stage
-from openerp.osv import fields, osv
-from openerp.tools.translate import _
-from openerp.tools import email_re, email_split
-from openerp.exceptions import UserError, AccessError
+
+from odoo import api, fields, models, tools
+from odoo.tools.translate import _
+from odoo.tools import email_re, email_split
+from odoo.exceptions import UserError, AccessError
+
+from odoo.addons.base.res.res_partner import FormatAddress
+from odoo.addons.crm.models import crm_stage
 
 _logger = logging.getLogger(__name__)
 
-CRM_LEAD_FIELDS_TO_MERGE = ['name',
+CRM_LEAD_FIELDS_TO_MERGE = [
+    'name',
     'partner_id',
     'campaign_id',
     'company_id',
@@ -51,31 +49,110 @@ CRM_LEAD_FIELDS_TO_MERGE = ['name',
     'partner_name']
 
 
-class crm_lead(FormatAddress, osv.osv):
-    """ CRM Lead Case """
+class Lead(FormatAddress, models.Model):
+
     _name = "crm.lead"
     _description = "Lead/Opportunity"
     _order = "priority desc,date_action,id desc"
     _inherit = ['mail.thread', 'ir.needaction_mixin', 'utm.mixin']
     _mail_mass_mailing = _('Leads / Opportunities')
 
-    def _get_default_probability(self, cr, uid, context=None):
-        """ Gives default probability """
-        stage_id = self._get_default_stage_id(cr, uid, context=context)
+    def _default_probability(self):
+        stage_id = self._default_stage_id()
         if stage_id:
-            return self.pool['crm.stage'].browse(cr, uid, stage_id, context=context).probability
-        else:
-            return 10
+            return self.env['crm.stage'].browse(stage_id).probability
+        return 10
+
+    def _default_stage_id(self):
+        team = self.env['crm.team'].sudo()._get_default_team_id(user_id=self.env.uid)
+        return self.stage_find(team.id, [('fold', '=', False)])
+
+    name = fields.Char('Opportunity', required=True, index=True)
+    partner_id = fields.Many2one('res.partner', string='Customer', track_visibility='onchange', index=True,
+        help="Linked partner (optional). Usually created when converting the lead.")
+    active = fields.Boolean('Active', default=True)
+    date_action_last = fields.Datetime('Last Action', readonly=True)
+    date_action_next = fields.Datetime('Next Action', readonly=True)
+    email_from = fields.Char('Email', help="Email address of the contact", index=True)
+    team_id = fields.Many2one('crm.team', string='Sales Team', oldname='section_id', default=lambda self: self.env['crm.team'].sudo()._get_default_team_id(user_id=self.env.uid),
+        index=True, track_visibility='onchange', help='When sending mails, the default email address is taken from the sales team.')
+    kanban_state = fields.Selection([('grey', 'No next activity planned'), ('red', 'Next activity late'), ('green', 'Next activity is planned')],
+        string='Activity State', compute='_compute_kanban_state')
+    email_cc = fields.Text('Global CC', help="These email addresses will be added to the CC field of all inbound and outbound emails for this record before being sent. Separate multiple email addresses with a comma")
+    description = fields.Text('Notes')
+    create_date = fields.Datetime('Create Date', readonly=True)
+    write_date = fields.Datetime('Update Date', readonly=True)
+    tag_ids = fields.Many2many('crm.lead.tag', 'crm_lead_tag_rel', 'lead_id', 'tag_id', string='Tags', help="Classify and analyze your lead/opportunity categories like: Training, Service")
+    contact_name = fields.Char('Contact Name')
+    partner_name = fields.Char("Customer Name", index=True, help='The name of the future partner company that will be created while converting the lead into opportunity')
+    opt_out = fields.Boolean(string='Opt-Out', oldname='optout',
+        help="If opt-out is checked, this contact has refused to receive emails for mass mailing and marketing campaign. "
+             "Filter 'Available for Mass Mailing' allows users to filter the leads when performing mass mailing.")
+    type = fields.Selection([('lead', 'Lead'), ('opportunity', 'Opportunity')], index=True, required=True,
+        default=lambda self: 'lead' if self.env['res.users'].has_group('crm.group_use_lead') else 'opportunity',
+        help="Type is used to separate Leads and Opportunities")
+    priority = fields.Selection(crm_stage.AVAILABLE_PRIORITIES, string='Rating', index=True, default=lambda *a: crm_stage.AVAILABLE_PRIORITIES[0][0])
+    date_closed = fields.Datetime('Closed Date', readonly=True, copy=False)
+
+    stage_id = fields.Many2one('crm.stage', string='Stage', track_visibility='onchange', index=True,
+        domain="['|', ('team_id', '=', False), ('team_id', '=', team_id)]",
+        default=lambda self: self._default_stage_id())
+    user_id = fields.Many2one('res.users', string='Salesperson', index=True, track_visibility='onchange', default=lambda self: self.env.user)
+    referred = fields.Char('Referred By')
+
+    date_open = fields.Datetime('Assigned', readonly=True)
+    day_open = fields.Float(compute='_compute_day_open', string='Days to Assign', store=True)
+    day_close = fields.Float(compute='_compute_day_close', string='Days to Close', store=True)
+    date_last_stage_update = fields.Datetime(string='Last Stage Update', index=True, default=fields.Datetime.now)
+    date_conversion = fields.Datetime('Conversion Date', readonly=True)
+
+    # Messaging and marketing
+    message_bounce = fields.Integer('Bounce', help="Counter of the number of bounced emails for this contact")
+
+    # Only used for type opportunity
+    probability = fields.Float('Probability', group_operator="avg", default=lambda self: self._default_probability())
+    planned_revenue = fields.Float('Expected Revenue', track_visibility='always')
+    date_deadline = fields.Date('Expected Closing', help="Estimate of the date on which the opportunity will be won.")
+
+    # CRM Actions
+    next_activity_id = fields.Many2one("crm.activity", string="Next Activity", index=True)
+    date_action = fields.Date('Next Activity Date', index=True)
+    title_action = fields.Char('Next Activity Summary')
+
+    color = fields.Integer('Color Index', default=0)
+    partner_address_name = fields.Char('Partner Contact Name', related='partner_id.name', readonly=True)
+    partner_address_email = fields.Char('Partner Contact Email', related='partner_id.email', readonly=True)
+    company_currency = fields.Many2one(string='Currency', related='company_id.currency_id', readonly=True, relation="res.currency")
+    user_email = fields.Char('User Email', related='user_id.email', readonly=True)
+    user_login = fields.Char('User Login', related='user_id.login', readonly=True)
+
+    # Fields for address, due to separation from crm and res.partner
+    street = fields.Char('Street')
+    street2 = fields.Char('Street2')
+    zip = fields.Char('Zip', change_default=True)
+    city = fields.Char('City')
+    state_id = fields.Many2one("res.country.state", string='State')
+    country_id = fields.Many2one('res.country', string='Country')
+    phone = fields.Char('Phone')
+    fax = fields.Char('Fax')
+    mobile = fields.Char('Mobile')
+    function = fields.Char('Job Position')
+    title = fields.Many2one('res.partner.title')
+    company_id = fields.Many2one('res.company', string='Company', index=True, default=lambda self: self.env.user.company_id.id)
+    meeting_count = fields.Integer('# Meetings', compute='_compute_meeting_count')
+    lost_reason = fields.Many2one('crm.lost.reason', string='Lost Reason', index=True, track_visibility='onchange')
 
-    def _get_default_stage_id(self, cr, uid, context=None):
-        """ Gives default stage_id """
-        team_id = self.pool['crm.team']._get_default_team_id(cr, SUPERUSER_ID, context=context, user_id=uid)
-        return self.stage_find(cr, uid, [], team_id, [('fold', '=', False)], context=context)
+    _sql_constraints = [
+        ('check_probability', 'check(probability >= 0 and probability <= 100)', 'The probability of closing the deal should be between 0% and 100%!')
+    ]
 
-    def _read_group_stage_ids(self, cr, uid, ids, domain, read_group_order=None, access_rights_uid=None, context=None):
-        access_rights_uid = access_rights_uid or uid
-        stage_obj = self.pool.get('crm.stage')
-        order = stage_obj._order
+    @api.multi
+    def _read_group_stage_ids(self, domain, read_group_order=None, access_rights_uid=None):
+        if access_rights_uid:
+            self = self.sudo(access_rights_uid)
+
+        Stage = self.env['crm.stage']
+        order = Stage._order
         # lame hack to allow reverting search, should just work in the trivial case
         if read_group_order == 'stage_id desc':
             order = "%s desc" % order
@@ -83,206 +160,97 @@ class crm_lead(FormatAddress, osv.osv):
         # - ('id', 'in', 'ids'): add columns that should be present
         # - OR ('fold', '=', False): add default columns that are not folded
         # - OR ('team_ids', '=', team_id), ('fold', '=', False) if team_id: add team columns that are not folded
-        team_id = context and context.get('default_team_id') or False
+        team_id = self._context.get('default_team_id', False)
         if team_id:
-            search_domain = ['|', ('id', 'in', ids), '|', ('team_id', '=', False), ('team_id', '=', team_id)]
+            search_domain = ['|', ('id', 'in', self.ids), '|', ('team_id', '=', False), ('team_id', '=', team_id)]
         else:
-            search_domain = ['|', ('id', 'in', ids), ('team_id', '=', False)]
+            search_domain = ['|', ('id', 'in', self.ids), ('team_id', '=', False)]
         # perform search
-        stage_ids = stage_obj._search(cr, uid, search_domain, order=order, access_rights_uid=access_rights_uid, context=context)
-        result = stage_obj.name_get(cr, access_rights_uid, stage_ids, context=context)
+        stage_ids = Stage._search(search_domain, order=order, access_rights_uid=access_rights_uid)
+        stages = Stage.browse(stage_ids)
+        result = stages.name_get()
         # restore order of the search
-        result.sort(lambda x, y: cmp(stage_ids.index(x[0]), stage_ids.index(y[0])))
-
+        order_mapping = dict((item[0], stage_ids.index(item[0])) for item in result)  # match stage_id with its index
+        result.sort(key=lambda item: order_mapping.get(item[0]))
         fold = {}
-        for stage in stage_obj.browse(cr, access_rights_uid, stage_ids, context=context):
+        for stage in stages:
             fold[stage.id] = stage.fold or False
         return result, fold
 
-    def fields_view_get(self, cr, user, view_id=None, view_type='form', context=None, toolbar=False, submenu=False):
-        if context and context.get('opportunity_id'):
-            action = self.get_formview_action(cr, user, context['opportunity_id'], context=context)
-            if action.get('views') and any(view_id for view_id in action['views'] if view_id[1] == view_type):
-                view_id = next(view_id[0] for view_id in action['views'] if view_id[1] == view_type)
-        res = super(crm_lead, self).fields_view_get(cr, user, view_id=view_id, view_type=view_type, context=context, toolbar=toolbar, submenu=submenu)
-        if view_type == 'form':
-            res['arch'] = self.fields_view_get_address(cr, user, res['arch'], context=context)
-        return res
-
     _group_by_full = {
         'stage_id': _read_group_stage_ids
     }
 
-    def _compute_kanban_state(self, cr, uid, ids, fields, args, context=None):
-        result = {}
+    @api.multi
+    def _compute_kanban_state(self):
         today = date.today()
-        for lead in self.browse(cr, uid, ids, context=context):
-            result[lead.id] = 'red'
+        for lead in self:
+            kanban_state = 'red'
             if lead.date_action:
-                lead_date = datetime.strptime(lead.date_action, tools.DEFAULT_SERVER_DATE_FORMAT).date()
+                lead_date = fields.Date.from_string(lead.date_action)
                 if lead_date >= today:
-                    result[lead.id] = 'green'
+                    kanban_state = 'green'
                 elif lead_date < today:
-                    result[lead.id] = 'grey'
-        return result
-
-    def _compute_day(self, cr, uid, ids, fields, args, context=None):
-        """
-        :return dict: difference between current date and log date
-        """
-        res = {}
-        for lead in self.browse(cr, uid, ids, context=context):
-            for field in fields:
-                res[lead.id] = {}
-                duration = 0
-                ans = False
-                if field == 'day_open':
-                    if lead.date_open:
-                        date_create = datetime.strptime(lead.create_date, "%Y-%m-%d %H:%M:%S")
-                        date_open = datetime.strptime(lead.date_open, "%Y-%m-%d %H:%M:%S")
-                        ans = date_open - date_create
-                elif field == 'day_close':
-                    if lead.date_closed:
-                        date_create = datetime.strptime(lead.create_date, "%Y-%m-%d %H:%M:%S")
-                        date_close = datetime.strptime(lead.date_closed, "%Y-%m-%d %H:%M:%S")
-                        ans = date_close - date_create
-                if ans:
-                    duration = abs(int(ans.days))
-                res[lead.id][field] = duration
-        return res
-
-    def _meeting_count(self, cr, uid, ids, field_name, arg, context=None):
-        Event = self.pool['calendar.event']
-        return {
-            opp_id: Event.search_count(cr,uid, [('opportunity_id', '=', opp_id)], context=context)
-            for opp_id in ids
-        }
-
-    def _get_company_currency(self, cr, uid, context=None):
-        if context is None:
-            context = {}
-        return self.pool['res.users'].browse(cr, uid, uid, context=context).company_id.currency_id.id
-
-    _columns = {
-        'partner_id': fields.many2one('res.partner', 'Customer', ondelete='set null', track_visibility='onchange',
-            select=True, help="Linked partner (optional). Usually created when converting the lead."),
-
-        'id': fields.integer('ID', readonly=True),
-        'name': fields.char('Opportunity', required=True, select=1),
-        'active': fields.boolean('Active', required=False),
-        'date_action_last': fields.datetime('Last Action', readonly=1),
-        'date_action_next': fields.datetime('Next Action', readonly=1),
-        'email_from': fields.char('Email', size=128, help="Email address of the contact", select=1),
-        'team_id': fields.many2one('crm.team', 'Sales Team', oldname='section_id',
-                        select=True, track_visibility='onchange', help='When sending mails, the default email address is taken from the sales team.'),
-        'kanban_state': fields.function(
-            _compute_kanban_state, string='Activity State', type="selection",
-            selection=[('grey', 'No next activity planned'), ('red', 'Next activity late'), ('green', 'Next activity is planned')]),
-        'create_date': fields.datetime('Creation Date', readonly=True),
-        'email_cc': fields.text('Global CC', help="These email addresses will be added to the CC field of all inbound and outbound emails for this record before being sent. Separate multiple email addresses with a comma"),
-        'description': fields.text('Notes'),
-        'write_date': fields.datetime('Update Date', readonly=True),
-        'tag_ids': fields.many2many('crm.lead.tag', 'crm_lead_tag_rel', 'lead_id', 'tag_id', 'Tags', help="Classify and analyze your lead/opportunity categories like: Training, Service"),
-        'contact_name': fields.char('Contact Name', size=64),
-        'partner_name': fields.char("Customer Name", size=64,help='The name of the future partner company that will be created while converting the lead into opportunity', select=1),
-        'opt_out': fields.boolean('Opt-Out', oldname='optout',
-            help="If opt-out is checked, this contact has refused to receive emails for mass mailing and marketing campaign. "
-                    "Filter 'Available for Mass Mailing' allows users to filter the leads when performing mass mailing."),
-        'type': fields.selection(
-            [('lead', 'Lead'), ('opportunity', 'Opportunity')],
-            string='Type', select=True, required=True,
-            help="Type is used to separate Leads and Opportunities"),
-        'priority': fields.selection(crm_stage.AVAILABLE_PRIORITIES, 'Rating', select=True),
-        'date_closed': fields.datetime('Closed Date', readonly=True, copy=False),
-        'stage_id': fields.many2one('crm.stage', 'Stage', track_visibility='onchange', select=True,
-                        domain="['|', ('team_id', '=', False), ('team_id', '=', team_id)]"),
-        'user_id': fields.many2one('res.users', 'Salesperson', select=True, track_visibility='onchange'),
-        'referred': fields.char('Referred By'),
-        'date_open': fields.datetime('Assigned', readonly=True),
-        'day_open': fields.function(_compute_day, string='Days to Assign',
-                                    multi='day_open', type="float",
-                                    store={'crm.lead': (lambda self, cr, uid, ids, c={}: ids, ['date_open'], 10)}),
-        'day_close': fields.function(_compute_day, string='Days to Close',
-                                     multi='day_open', type="float",
-                                     store={'crm.lead': (lambda self, cr, uid, ids, c={}: ids, ['date_closed'], 10)}),
-        'date_last_stage_update': fields.datetime('Last Stage Update', select=True),
-        'date_conversion': fields.datetime('Conversion Date', readonly=1),
-
-        # Messaging and marketing
-        'message_bounce': fields.integer('Bounce', help="Counter of the number of bounced emails for this contact"),
-        # Only used for type opportunity
-        'probability': fields.float('Probability', group_operator="avg"),
-        'planned_revenue': fields.float('Expected Revenue', track_visibility='always'),
-        'date_deadline': fields.date('Expected Closing', help="Estimate of the date on which the opportunity will be won."),
-        # CRM Actions
-        'next_activity_id': fields.many2one("crm.activity", "Next Activity", select=True),
-        'date_action': fields.date('Next Activity Date', select=True),
-        'title_action': fields.char('Next Activity Summary'),
-
-        'color': fields.integer('Color Index'),
-        'partner_address_name': fields.related('partner_id', 'name', type='char', string='Partner Contact Name', readonly=True),
-        'partner_address_email': fields.related('partner_id', 'email', type='char', string='Partner Contact Email', readonly=True),
-        'company_currency': fields.related('company_id', 'currency_id', type='many2one', string='Currency', readonly=True, relation="res.currency"),
-        'user_email': fields.related('user_id', 'email', type='char', string='User Email', readonly=True),
-        'user_login': fields.related('user_id', 'login', type='char', string='User Login', readonly=True),
-
-        # Fields for address, due to separation from crm and res.partner
-        'street': fields.char('Street'),
-        'street2': fields.char('Street2'),
-        'zip': fields.char('Zip', change_default=True, size=24),
-        'city': fields.char('City'),
-        'state_id': fields.many2one("res.country.state", 'State'),
-        'country_id': fields.many2one('res.country', 'Country'),
-        'phone': fields.char('Phone'),
-        'fax': fields.char('Fax'),
-        'mobile': fields.char('Mobile'),
-        'function': fields.char('Job Position'),
-        'title': fields.many2one('res.partner.title', 'Title'),
-        'company_id': fields.many2one('res.company', 'Company', select=1),
-        'meeting_count': fields.function(_meeting_count, string='# Meetings', type='integer'),
-        'lost_reason': fields.many2one('crm.lost.reason', 'Lost Reason', select=True, track_visibility='onchange'),
-    }
-
-    _defaults = {
-        'active': 1,
-        'type': lambda s, cr, uid, c: 'lead' if s.pool['res.users'].has_group(cr, uid, 'crm.group_use_lead') else 'opportunity',
-        'company_currency': _get_company_currency,
-        'user_id': lambda s, cr, uid, c: uid,
-        'stage_id': lambda s, cr, uid, c: s._get_default_stage_id(cr, uid, c),
-        'team_id': lambda s, cr, uid, c: s.pool['crm.team']._get_default_team_id(cr, SUPERUSER_ID, context=c, user_id=uid),
-        'company_id': lambda s, cr, uid, c: s.pool.get('res.company')._company_default_get(cr, uid, 'crm.lead', context=c),
-        'priority': lambda *a: crm_stage.AVAILABLE_PRIORITIES[0][0],
-        'probability': lambda s, cr, uid, c: s._get_default_probability(cr, uid, c),
-        'color': 0,
-        'date_last_stage_update': fields.datetime.now,
-    }
-
-    _sql_constraints = [
-        ('check_probability', 'check(probability >= 0 and probability <= 100)', 'The probability of closing the deal should be between 0% and 100%!')
-    ]
-
-    def onchange_stage_id(self, cr, uid, ids, stage_id, context=None):
+                    kanban_state = 'grey'
+            lead.kanban_state = kanban_state
+
+    @api.depends('date_open')
+    def _compute_day_open(self):
+        """ Compute difference between create date and open date """
+        for lead in self.filtered(lambda l: l.date_open):
+            date_create = fields.Datetime.from_string(lead.create_date)
+            date_open = fields.Datetime.from_string(lead.date_open)
+            lead.day_open = abs((date_open - date_create).days)
+
+    @api.depends('date_closed')
+    def _compute_day_close(self):
+        """ Compute difference between current date and log date """
+        for lead in self.filtered(lambda l: l.date_closed):
+            date_create = fields.Datetime.from_string(lead.create_date)
+            date_close = fields.Datetime.from_string(lead.date_closed)
+            lead.day_close = abs((date_close - date_create).days)
+
+    @api.multi
+    def _compute_meeting_count(self):
+        meeting_data = self.env['calendar.event'].read_group([('opportunity_id', 'in', self.ids)], ['opportunity_id'], ['opportunity_id'])
+        mapped_data = dict([(m['opportunity_id'][0], m['opportunity_id_count']) for m in meeting_data])
+        for lead in self:
+            lead.meeting_count = mapped_data.get(lead.id, 0)
+
+    @api.model
+    def _onchange_stage_id_values(self, stage_id):
+        """ returns the new values when stage_id has changed """
         if not stage_id:
-            return {'value': {}}
-        stage = self.pool['crm.stage'].browse(cr, uid, stage_id, context=context)
-        if not stage.on_change:
-            return {'value': {}}
-        return {'value': {'probability': stage.probability}}
+            return {}
+        stage = self.env['crm.stage'].browse(stage_id)
+        if stage.on_change:
+            return {'probability': stage.probability}
+        return {}
 
-    def on_change_partner_id(self, cr, uid, ids, partner_id, context=None):
+    @api.onchange('stage_id')
+    def _onchange_stage_id(self):
+        values = self._onchange_stage_id_values(self.stage_id.id if self.stage_id else False)
+        self.update(values)
+
+    def _onchange_partner_id_values(self, partner_id):
+        """ returns the new values when partner_id has changed """
         values = {}
         if partner_id:
-            partner = self.pool.get('res.partner').browse(cr, uid, partner_id, context=context)
-            partner_name = (partner.parent_id and partner.parent_id.name) or (partner.is_company and partner.name) or False
+            partner = self.env['res.partner'].browse(partner_id)
+
+            partner_name = partner.parent_id.name
+            if not partner_name and partner.is_company:
+                partner_name = partner.name
+
             values = {
                 'partner_name': partner_name,
-                'contact_name': (not partner.is_company and partner.name) or False,
-                'title': partner.title and partner.title.id or False,
+                'contact_name': partner.name if not partner.is_company else False,
+                'title': partner.title.id,
                 'street': partner.street,
                 'street2': partner.street2,
                 'city': partner.city,
-                'state_id': partner.state_id and partner.state_id.id or False,
-                'country_id': partner.country_id and partner.country_id.id or False,
+                'state_id': partner.state_id.id,
+                'country_id': partner.country_id.id,
                 'email_from': partner.email,
                 'phone': partner.phone,
                 'mobile': partner.mobile,
@@ -290,40 +258,178 @@ class crm_lead(FormatAddress, osv.osv):
                 'zip': partner.zip,
                 'function': partner.function,
             }
-        return {'value': values}
-
-    def on_change_user(self, cr, uid, ids, user_id, context=None):
-        """ When changing the user, also set a team_id or restrict team id
-            to the ones user_id is member of. """
-        if not context:
-            context = {}
-        if user_id and context.get('team_id'):
-            team = self.pool['crm.team'].browse(cr, uid, context['team_id'], context=context)
+        return values
+
+    @api.onchange('partner_id')
+    def _onchange_partner_id(self):
+        values = self._onchange_partner_id_values(self.partner_id.id if self.partner_id else False)
+        self.update(values)
+
+    @api.model
+    def _onchange_user_values(self, user_id):
+        """ returns new values when user_id has changed """
+        if user_id and self._context.get('team_id'):
+            team = self.env['crm.team'].browse(self._context['team_id'])
             if user_id in team.member_ids.ids:
                 return {}
-        team_id = self.pool['crm.team']._get_default_team_id(cr, uid, context=context, user_id=user_id)
-        return {'value': {'team_id': team_id}}
-
-    def stage_find(self, cr, uid, cases, team_id, domain=None, order='sequence', context=None):
-        """ Override of the base.stage method
-            Parameter of the stage search taken from the lead:
-            - type: stage type must be the same or 'both'
-            - team_id: if set, stages must belong to this team or
-              be a default stage; if not set, stages must be default
-              stages
+        team_id = self.env['crm.team']._get_default_team_id(user_id=user_id)
+        return {'team_id': team_id}
+
+    @api.onchange('user_id')
+    def _onchange_user_id(self):
+        """ When changing the user, also set a team_id or restrict team id to the ones user_id is member of. """
+        values = self._onchange_user_values(self.user_id.id)
+        self.update(values)
+
+    @api.onchange('state_id')
+    def _onchange_state(self):
+        if self.state_id:
+            self.country_id = self.state_id.country_id.id
+
+    @api.onchange('next_activity_id')
+    def _onchange_next_activity_id(self):
+        values = {
+            'title_action': False,
+            'date_action': False,
+        }
+        if self.next_activity_id:
+            values['title_action'] = self.next_activity_id.description
+            if self.next_activity_id.days:
+                values['date_action'] = fields.Datetime.to_string(datetime.now() + timedelta(days=self.next_activity_id.days))
+        self.update(values)
+
+    # ----------------------------------------
+    # ORM override (CRUD, fields_view_get, ...)
+    # ----------------------------------------
+
+    @api.model
+    def create(self, vals):
+        context = dict(self._context or {})
+        if vals.get('type') and not self._context.get('default_type'):
+            context['default_type'] = vals.get('type')
+        if vals.get('team_id') and not self._context.get('default_team_id'):
+            context['default_team_id'] = vals.get('team_id')
+        if vals.get('user_id') and 'date_open' not in vals:
+            vals['date_open'] = fields.Datetime.now()
+        # context: no_log, because subtype already handle this
+        return super(Lead, self.with_context(context, mail_create_nolog=True)).create(vals)
+
+    @api.multi
+    def write(self, vals):
+        # stage change: update date_last_stage_update
+        if 'stage_id' in vals:
+            vals['date_last_stage_update'] = fields.Datetime.now()
+        if vals.get('user_id') and 'date_open' not in vals:
+            vals['date_open'] = fields.Datetime.now()
+        # stage change with new stage: update probability and date_closed
+        if vals.get('stage_id') and 'probability' not in vals:
+            vals.update(self._onchange_stage_id_values(vals.get('stage_id')))
+        if vals.get('probability') >= 100 or not vals.get('active', True):
+            vals['date_closed'] = fields.Datetime.now()
+        elif vals.get('probability') < 100:
+            vals['date_closed'] = False
+        return super(Lead, self).write(vals)
+
+    @api.multi
+    def copy(self, default=None):
+        self.ensure_one()
+        # set default value in context, if not already set (Put stage to 'new' stage)
+        context = dict(self._context)
+        context.setdefault('default_type', self.type)
+        context.setdefault('default_team_id', self.team_id.id)
+        # Set date_open to today if it is an opp
+        default = default or {}
+        default['date_open'] = fields.Datetime.now() if self.type == 'opportunity' else False
+        return super(Lead, self.with_context(context)).copy(default=default)
+
+    @api.model
+    def fields_view_get(self, view_id=None, view_type='form', toolbar=False, submenu=False):
+        if self._context.get('opportunity_id'):
+            opportunity = self.browse(self._context['opportunity_id'])
+            action = opportunity.get_formview_action()
+            if action.get('views') and any(view_id for view_id in action['views'] if view_id[1] == view_type):
+                view_id = next(view_id[0] for view_id in action['views'] if view_id[1] == view_type)
+        res = super(Lead, self).fields_view_get(view_id=view_id, view_type=view_type, toolbar=toolbar, submenu=submenu)
+        if view_type == 'form':
+            res['arch'] = self.fields_view_get_address(res['arch'])
+        return res
+
+    # ----------------------------------------
+    # Actions Methods
+    # ----------------------------------------
+
+    @api.multi
+    def action_set_lost(self):
+        """ Lost semantic: probability = 0, active = False """
+        return self.write({'probability': 0, 'active': False})
+
+    # TODO JEM : check, nad remove this
+    # Backward compatibility
+    case_mark_lost = action_set_lost
+
+    @api.multi
+    def action_set_active(self):
+        return self.write({'active': True})
+
+    @api.multi
+    def action_set_unactive(self):
+        return self.write({'active': False})
+
+    @api.multi
+    def action_set_won(self):
+        """ Won semantic: probability = 100 (active untouched) """
+        for lead in self:
+            stage_id = lead.stage_find(lead.team_id.id, [('probability', '=', 100.0), ('on_change', '=', True)])
+            lead.write({'stage_id': stage_id, 'probability': 100})
+        return True
+
+    # TODO JEM : check, nad remove this
+    # Backward compatibility
+    case_mark_won = action_set_won
+
+    @api.multi
+    def action_schedule_meeting(self):
+        """ Open meeting's calendar view to schedule meeting on current opportunity.
+            :return dict: dictionary value for created Meeting view
+        """
+        self.ensure_one()
+        action = self.env['ir.actions.act_window'].for_xml_id('calendar', 'action_calendar_event')
+        partner_ids = self.env.user.partner_id.ids
+        if self.partner_id:
+            partner_ids.append(self.partner_id.id)
+        action['context'] = {
+            'search_default_opportunity_id': self.id if self.type == 'opportunity' else False,
+            'default_opportunity_id': self.id if self.type == 'opportunity' else False,
+            'default_partner_id': self.partner_id.id,
+            'default_partner_ids': partner_ids,
+            'default_team_id': self.team_id.id,
+            'default_name': self.name,
+        }
+        return action
+
+    @api.multi
+    def close_dialog(self):
+        return {'type': 'ir.actions.act_window_close'}
+
+    # ----------------------------------------
+    # Business Methods
+    # ----------------------------------------
+    # TODO JEM : team_id should be optional
+    @api.multi
+    def stage_find(self, team_id, domain=None, order='sequence'):
+        """ Determine the stage of the current lead with its teams, the given domain and the given team_id
+            :param team_id
+            :param domain : base search domain for stage
+            :returns crm.stage record identifier
         """
-        if isinstance(cases, (int, long)):
-            cases = self.browse(cr, uid, cases, context=context)
-        if context is None:
-            context = {}
-        # collect all team_ids
+        # collect all team_ids by adding given one, and the ones related to the current leads
         team_ids = set()
         if team_id:
             team_ids.add(team_id)
-        for lead in cases:
+        for lead in self:
             if lead.team_id:
                 team_ids.add(lead.team_id.id)
-        # OR all team_ids
+        # generate the domain
         if team_ids:
             search_domain = ['|', ('team_id', '=', False), ('team_id', 'in', list(team_ids))]
         else:
@@ -331,102 +437,56 @@ class crm_lead(FormatAddress, osv.osv):
         # AND with the domain in parameter
         search_domain += list(domain)
         # perform search, return the first found
-        stage_ids = self.pool.get('crm.stage').search(cr, uid, search_domain, order=order, limit=1, context=context)
-        if stage_ids:
-            return stage_ids[0]
+        stage = self.env['crm.stage'].search(search_domain, order=order, limit=1)
+        if stage:
+            return stage.id
         return False
 
-    def action_set_lost(self, cr, uid, ids, context=None):
-        """ Lost semantic: probability = 0, active = False """
-        return self.write(cr, uid, ids, {'probability': 0, 'active': False}, context=context)
-    # Backward compatibility
-    case_mark_lost = action_set_lost
-
-    def action_set_active(self, cr, uid, ids, context=None):
-        return self.write(cr, uid, ids, {'active': True}, context=context)
-
-    def action_set_unactive(self, cr, uid, ids, context=None):
-        return self.write(cr, uid, ids, {'active': False}, context=context)
-
-    def action_set_won(self, cr, uid, ids, context=None):
-        """ Won semantic: probability = 100 (active untouched) """
-        stages_leads = {}
-        for lead in self.browse(cr, uid, ids, context=context):
-            stage_id = self.stage_find(cr, uid, [lead], lead.team_id.id or False, [('probability', '=', 100.0), ('on_change', '=', True)], context=context)
-            if stage_id:
-                if stages_leads.get(stage_id):
-                    stages_leads[stage_id].append(lead.id)
-                else:
-                    stages_leads[stage_id] = [lead.id]
-        for stage_id, lead_ids in stages_leads.items():
-            self.write(cr, uid, lead_ids, {'stage_id': stage_id}, context=context)
-        return self.write(cr, uid, ids, {'probability': 100}, context=context)
-    # Backward compatibility
-    case_mark_won = action_set_won
-
-    def onchange_next_activity_id(self, cr, uid, ids, next_activity_id, context=None):
-        if not next_activity_id:
-            return {'value': {
-                'title_action': False,
-                'date_action': False,
-            }}
-        activity = self.pool['crm.activity'].browse(cr, uid, next_activity_id, context=context)
-        date_action = False
-        if activity.days:
-            date_action = (datetime.now() + timedelta(days=activity.days)).strftime(tools.DEFAULT_SERVER_DATETIME_FORMAT)
-        return {'value': {
-            'title_action': activity.description,
-            'date_action': date_action,
-        }}
-
-    def _merge_get_result_type(self, cr, uid, opps, context=None):
-        """
-        Define the type of the result of the merge.  If at least one of the
-        element to merge is an opp, the resulting new element will be an opp.
-        Otherwise it will be a lead.
-
-        We'll directly use a list of browse records instead of a list of ids
-        for performances' sake: it will spare a second browse of the
-        leads/opps.
-
-        :param list opps: list of browse records containing the leads/opps to process
-        :return string type: the type of the final element
+    @api.multi
+    def _merge_get_result_type(self):
+        """ Define the type of the result of the merge.  If at least one of the
+            element to merge is an opp, the resulting new element will be an opp.
+            Otherwise it will be a lead.
+            We'll directly use a list of browse records instead of a list of ids
+            for performances' sake: it will spare a second browse of the
+            leads/opps.
+
+            :param list opps: list of browse records containing the leads/opps to process
+            :return string type: the type of the final element
         """
-        for opp in opps:
-            if (opp.type == 'opportunity'):
+        for record in self:
+            if record.type == 'opportunity':
                 return 'opportunity'
-
         return 'lead'
 
-    def _merge_data(self, cr, uid, ids, oldest, fields, context=None):
-        """
-        Prepare lead/opp data into a dictionary for merging.  Different types
-        of fields are processed in different ways:
-        - text: all the values are concatenated
-        - m2m and o2m: those fields aren't processed
-        - m2o: the first not null value prevails (the other are dropped)
-        - any other type of field: same as m2o
-
-        :param list ids: list of ids of the leads to process
-        :param list fields: list of leads' fields to process
-        :return dict data: contains the merged values
+    @api.multi
+    def _merge_data(self, fields):
+        """ Prepare lead/opp data into a dictionary for merging. Different types
+            of fields are processed in different ways:
+                - text: all the values are concatenated
+                - m2m and o2m: those fields aren't processed
+                - m2o: the first not null value prevails (the other are dropped)
+                - any other type of field: same as m2o
+
+            :param fields: list of fields to process
+            :return dict data: contains the merged values of the new opportunity
         """
-        opportunities = self.browse(cr, uid, ids, context=context)
-
-        def _get_first_not_null(attr):
+        # helpers
+        def _get_first_not_null(attr, opportunities):
             for opp in opportunities:
-                if hasattr(opp, attr) and bool(getattr(opp, attr)):
-                    return getattr(opp, attr)
+                val = opp[attr]
+                if val:
+                    return val
             return False
 
-        def _get_first_not_null_id(attr):
-            res = _get_first_not_null(attr)
-            return res and res.id or False
+        def _get_first_not_null_id(attr, opportunities):
+            res = _get_first_not_null(attr, opportunities)
+            return res.id if res else False
 
-        def _concat_all(attr):
-            return '\n\n'.join(filter(lambda x: x, [getattr(opp, attr) or '' for opp in opportunities if hasattr(opp, attr)]))
+        def _concat_all(attr, opportunities):
+            return '\n\n'.join(filter(None, (opp[attr] for opp in opportunities)))
 
-        # Process the fields' values
+        # process the fields' values
         data = {}
         for field_name in fields:
             field = self._fields.get(field_name)
@@ -435,313 +495,339 @@ class crm_lead(FormatAddress, osv.osv):
             if field.type in ('many2many', 'one2many'):
                 continue
             elif field.type == 'many2one':
-                data[field_name] = _get_first_not_null_id(field_name)  # !!
+                data[field_name] = _get_first_not_null_id(field_name, self)  # take the first not null
             elif field.type == 'text':
-                data[field_name] = _concat_all(field_name)  #not lost
+                data[field_name] = _concat_all(field_name, self)  # contact field of all opportunities
             else:
-                data[field_name] = _get_first_not_null(field_name)  #not lost
+                data[field_name] = _get_first_not_null(field_name, self)
 
-        # Define the resulting type ('lead' or 'opportunity')
-        data['type'] = self._merge_get_result_type(cr, uid, opportunities, context)
+        # define the resulting type ('lead' or 'opportunity')
+        data['type'] = self._merge_get_result_type()
         return data
 
-    def _mail_body(self, cr, uid, lead, fields, title=False, context=None):
-        body = []
-        if title:
-            body.append("%s\n" % (title))
-
+    @api.one
+    def _mail_body(self, fields):
+        """ generate the message body with the changed values
+            :param fields : list of fields to track
+            :returns the body of the message for the current crm.lead
+        """
+        title = "%s : %s\n" % (_('Merged opportunity') if self.type == 'opportunity' else _('Merged lead'), self.name)
+        body = [title]
         for field_name in fields:
             field = self._fields.get(field_name)
             if field is None:
                 continue
-            value = ''
 
+            value = self[field_name]
             if field.type == 'selection':
-                if callable(field.selection):
-                    key = field.selection(self, cr, uid, context=context)
-                else:
-                    key = field.selection
-                value = dict(key).get(lead[field_name], lead[field_name])
+                value = dict(field.get_values(self.env)).get(value, value)
             elif field.type == 'many2one':
-                if lead[field_name]:
-                    value = lead[field_name].sudo().name_get()[0][1]
+                if value:
+                    value = value.sudo().name_get()[0][1]
             elif field.type == 'many2many':
-                if lead[field_name]:
-                    for val in lead[field_name]:
-                        field_value = val.sudo().name_get()[0][1]
-                        value += field_value + ","
-            else:
-                value = lead[field_name]
-
+                if value:
+                    value = ','.join(
+                        val.name_get()[0][1]
+                        for val in value.sudo()
+                    )
             body.append("%s: %s" % (field.string, value or ''))
         return "<br/>".join(body + ['<br/>'])
 
-    def _merge_notify(self, cr, uid, opportunity_id, opportunities, context=None):
+    @api.multi
+    def _merge_notify(self, opportunities):
+        """ Create a message gathering merged leads/opps informations. Using message_post, send a
+            message explaining which fields has been merged and their new value. `self` is the
+            resulting merge crm.lead record.
+            :param opportunities : recordset of merged crm.lead
+            :returns mail.message posted on resulting crm.lead
         """
-        Create a message gathering merged leads/opps information.
+        # TODO JEM: mail template should be used instead of fix body, subject text
+        self.ensure_one()
+        # mail message's subject
+        result_type = opportunities._merge_get_result_type()
+        merge_message = _('Merged leads') if result_type == 'lead' else _('Merged opportunities')
+        subject = merge_message + ": " + ", ".join(opportunities.mapped('name'))
+        # message bodies
+        message_bodies = opportunities._mail_body(CRM_LEAD_FIELDS_TO_MERGE)
+        message_body = "\n\n".join(message_bodies)
+        return self.message_post(body=message_body, subject=subject)
+
+    @api.multi
+    def _merge_opportunity_history(self, opportunities):
+        """ Move mail.message from the given opportunities to the current one. `self` is the
+            crm.lead record destination for message of `opportunities`.
+            :param opportunities : recordset of crm.lead to move the messages
         """
-        #TOFIX: mail template should be used instead of fix body, subject text
-        details = []
-        result_type = self._merge_get_result_type(cr, uid, opportunities, context)
-        if result_type == 'lead':
-            merge_message = _('Merged leads')
-        else:
-            merge_message = _('Merged opportunities')
-        subject = [merge_message]
+        self.ensure_one()
         for opportunity in opportunities:
-            subject.append(opportunity.name)
-            title = "%s : %s" % (opportunity.type == 'opportunity' and _('Merged opportunity') or _('Merged lead'), opportunity.name)
-            fields = list(CRM_LEAD_FIELDS_TO_MERGE)
-            details.append(self._mail_body(cr, uid, opportunity, fields, title=title, context=context))
-
-        # Chatter message's subject
-        subject = subject[0] + ": " + ", ".join(subject[1:])
-        details = "\n\n".join(details)
-        return self.message_post(cr, uid, [opportunity_id], body=details, subject=subject, context=context)
-
-    def _merge_opportunity_history(self, cr, uid, opportunity_id, opportunities, context=None):
-        message = self.pool.get('mail.message')
-        for opportunity in opportunities:
-            for history in opportunity.message_ids:
-                message.write(cr, uid, history.id, {
-                        'res_id': opportunity_id,
-                        'subject' : _("From %s : %s") % (opportunity.name, history.subject)
-                }, context=context)
-
+            for message in opportunity.message_ids:
+                message.write({
+                    'res_id': self.id,
+                    'subject': _("From %s : %s") % (opportunity.name, message.subject)
+                })
         return True
 
-    def _merge_opportunity_attachments(self, cr, uid, opportunity_id, opportunities, context=None):
-        attach_obj = self.pool.get('ir.attachment')
+    @api.multi
+    def _merge_opportunity_attachments(self, opportunities):
+        """ Move attachments of given opportunities to the current one `self`, and rename
+            the attachments having same name than native ones.
+            :param opportunities : recordset of merged crm.lead
+        """
+        self.ensure_one()
 
         # return attachments of opportunity
         def _get_attachments(opportunity_id):
-            attachment_ids = attach_obj.search(cr, uid, [('res_model', '=', self._name), ('res_id', '=', opportunity_id)], context=context)
-            return attach_obj.browse(cr, uid, attachment_ids, context=context)
+            return self.env['ir.attachment'].search([('res_model', '=', self._name), ('res_id', '=', opportunity_id)])
 
-        first_attachments = _get_attachments(opportunity_id)
-        #counter of all attachments to move. Used to make sure the name is different for all attachments
+        first_attachments = _get_attachments(self.id)
+        # counter of all attachments to move. Used to make sure the name is different for all attachments
         count = 1
         for opportunity in opportunities:
             attachments = _get_attachments(opportunity.id)
             for attachment in attachments:
-                values = {'res_id': opportunity_id,}
+                values = {'res_id': self.id}
                 for attachment_in_first in first_attachments:
                     if attachment.name == attachment_in_first.name:
-                        values['name'] = "%s (%s)" % (attachment.name, count,),
-                count+=1
+                        values['name'] = "%s (%s)" % (attachment.name, count)
+                count += 1
                 attachment.write(values)
         return True
 
-    def get_duplicated_leads(self, cr, uid, ids, partner_id, include_lost=False, context=None):
+    @api.multi
+    def merge_dependences(self, opportunities):
+        """ Merge dependences (messages, attachments, ...). These dependences will be
+            transfered to `self`, the most important lead.
+            :param opportunities : recordset of opportunities to transfert. Does
+                not include `self`.
         """
-        Search for opportunities that have the same partner and that arent done or cancelled
+        self.ensure_one()
+        self._merge_notify(opportunities)
+        self._merge_opportunity_history(opportunities)
+        self._merge_opportunity_attachments(opportunities)
+
+    #TODO JEM : make it return record
+    @api.multi
+    def merge_opportunity(self, user_id=False, team_id=False):
+        """ Merge opportunities in one. Different cases of merge:
+                - merge leads together = 1 new lead
+                - merge at least 1 opp with anything else (lead or opp) = 1 new opp
+            The resulting lead/opportunity will be the most important one (based on its confidence level)
+            updated with values from other opportunities to merge.
+            :param user_id : the id of the saleperson. If not given, will be determined by `_merge_data`.
+            :param team : the id of the sales team. If not given, will be determined by `_merge_data`.
+            :return int id: id of the resulting lead/opportunity
         """
-        lead = self.browse(cr, uid, ids[0], context=context)
-        email = lead.partner_id and lead.partner_id.email or lead.email_from
-        return self.pool['crm.lead']._get_duplicated_leads_by_emails(cr, uid, partner_id, email, include_lost=include_lost, context=context)
-
-    def _get_duplicated_leads_by_emails(self, cr, uid, partner_id, email, include_lost=False, context=None):
-        """
-        Search for opportunities that have   the same partner and that arent done or cancelled
-        """
-        partner_match_domain = []
-        for email in set(email_split(email) + [email]):
-            partner_match_domain.append(('email_from', '=ilike', email))
-        if partner_id:
-            partner_match_domain.append(('partner_id', '=', partner_id))
-        partner_match_domain = ['|'] * (len(partner_match_domain) - 1) + partner_match_domain
-        if not partner_match_domain:
-            return []
-        domain = partner_match_domain
-        if not include_lost:
-            domain += ['&', ('active', '=', True), ('probability', '<', 100)]
-        return self.search(cr, uid, domain, context=context)
-
-    def merge_dependences(self, cr, uid, highest, opportunities, context=None):
-        self._merge_notify(cr, uid, highest, opportunities, context=context)
-        self._merge_opportunity_history(cr, uid, highest, opportunities, context=context)
-        self._merge_opportunity_attachments(cr, uid, highest, opportunities, context=context)
-
-    def merge_opportunity(self, cr, uid, ids, user_id=False, team_id=False, context=None):
-        """
-        Different cases of merge:
-        - merge leads together = 1 new lead
-        - merge at least 1 opp with anything else (lead or opp) = 1 new opp
-
-        :param list ids: leads/opportunities ids to merge
-        :return int id: id of the resulting lead/opp
-        """
-        if context is None:
-            context = {}
-
-        if len(ids) <= 1:
+        if len(self.ids) <= 1:
             raise UserError(_('Please select more than one element (lead or opportunity) from the list view.'))
 
-        opportunities = self.browse(cr, uid, ids, context=context)
-        sequenced_opps = []
         # Sorting the leads/opps according to the confidence level of its stage, which relates to the probability of winning it
         # The confidence level increases with the stage sequence, except when the stage probability is 0.0 (Lost cases)
         # An Opportunity always has higher confidence level than a lead, unless its stage probability is 0.0
-        for opportunity in opportunities:
+        sequenced_opps = []
+        for opportunity in self:
             sequence = -1
             if opportunity.stage_id and opportunity.stage_id.on_change:
                 sequence = opportunity.stage_id.sequence
             sequenced_opps.append(((int(sequence != -1 and opportunity.type == 'opportunity'), sequence, -opportunity.id), opportunity))
-
         sequenced_opps.sort(reverse=True)
-        opportunities = map(itemgetter(1), sequenced_opps)
-        ids = [opportunity.id for opportunity in opportunities]
-        highest = opportunities[0]
-        opportunities_rest = opportunities[1:]
 
-        tail_opportunities = opportunities_rest
+        sorted_opportunities = [item[1] for item in sequenced_opps]  # get sorted list of crm.lead record
+
+        # get SORTED recordset of head and tail, and complete list
+        opportunities = self.browse([opportunity.id for opportunity in sorted_opportunities])
+        opportunities_head = sorted_opportunities[0]
+        opportunities_tail = self.browse([opportunity.id for opportunity in sorted_opportunities[1:]])
 
-        fields = list(CRM_LEAD_FIELDS_TO_MERGE)
-        merged_data = self._merge_data(cr, uid, ids, highest, fields, context=context)
+        # merge all the sorted opportunity. This means the value of
+        # the first (head opp) will be a priority.
+        merged_data = opportunities._merge_data(CRM_LEAD_FIELDS_TO_MERGE)
 
+        # force value for saleperson and sales team
         if user_id:
             merged_data['user_id'] = user_id
         if team_id:
             merged_data['team_id'] = team_id
 
-        # Merge notifications about loss of information
-        opportunities = [highest]
-        opportunities.extend(opportunities_rest)
+        # merge other data (mail.message, attachments, ...) from tail into head
+        opportunities_head.merge_dependences(opportunities_tail)
 
-        self.merge_dependences(cr, uid, highest.id, tail_opportunities, context=context)
-
-        # Check if the stage is in the stages of the sales team. If not, assign the stage with the lowest sequence
+        # check if the stage is in the stages of the sales team. If not, assign the stage with the lowest sequence
         if merged_data.get('team_id'):
-            team_stage_ids = self.pool.get('crm.stage').search(cr, uid, ['|', ('team_id', '=', merged_data['team_id']), ('team_id', '=', False)], order='sequence', context=context)
+            team_stage_ids = self.env['crm.stage'].search(['|', ('team_id', '=', merged_data['team_id']), ('team_id', '=', False)], order='sequence')
+            if merged_data.get('stage_id') not in team_stage_ids.ids:
+                merged_data['stage_id'] = team_stage_ids[0].id if team_stage_ids else False
+
+        # write merged data into first opportunity
+        opportunities_head.write(merged_data)
 
-            if merged_data.get('stage_id') not in team_stage_ids:
-                merged_data['stage_id'] = team_stage_ids and team_stage_ids[0] or False
-        # Write merged data into first opportunity
-        self.write(cr, uid, [highest.id], merged_data, context=context)
-        # Delete tail opportunities
-        # We use the SUPERUSER to avoid access rights issues because as the user had the rights to see the records it should be safe to do so
-        self.unlink(cr, SUPERUSER_ID, [x.id for x in tail_opportunities], context=context)
+        # delete tail opportunities
+        # we use the SUPERUSER to avoid access rights issues because as the user had the rights to see the records it should be safe to do so
+        opportunities_tail.sudo().unlink()
 
-        return highest.id
+        return opportunities_head.id
 
-    def _convert_opportunity_data(self, cr, uid, lead, customer, team_id=False, context=None):
+    @api.multi
+    def get_duplicated_leads(self, partner_id, include_lost=False):
+        """ Search for opportunities that have the same partner and that arent done or cancelled
+            :param partner_id : partner to search
+        """
+        self.ensure_one()
+        email = self.partner_id.email or self.email_from
+        return self._get_duplicated_leads_by_emails(partner_id, email, include_lost=include_lost)
+
+    @api.model
+    def _get_duplicated_leads_by_emails(self, partner_id, email, include_lost=False):
+        """ Search for opportunities that have the same partner and that arent done or cancelled """
+        partner_match_domain = []
+        for email in set(email_split(email) + [email]):
+            partner_match_domain.append(('email_from', '=ilike', email))
+        if partner_id:
+            partner_match_domain.append(('partner_id', '=', partner_id))
+        partner_match_domain = ['|'] * (len(partner_match_domain) - 1) + partner_match_domain
+        if not partner_match_domain:
+            return []
+        domain = partner_match_domain
+        if not include_lost:
+            domain += ['&', ('active', '=', True), ('probability', '<', 100)]
+        return self.search(domain)
+
+    @api.multi
+    def _convert_opportunity_data(self, customer, team_id=False):
+        """ Extract the data from a lead to create the opportunity
+            :param customer : res.partner record
+            :param team_id : identifier of the sales team to determine the stage
+        """
         if not team_id:
-            team_id = lead.team_id and lead.team_id.id or False
-        val = {
-            'planned_revenue': lead.planned_revenue,
-            'probability': lead.probability,
-            'name': lead.name,
-            'partner_id': customer and customer.id or False,
+            team_id = self.team_id.id if self.team_id else False
+        value = {
+            'planned_revenue': self.planned_revenue,
+            'probability': self.probability,
+            'name': self.name,
+            'partner_id': customer.id if customer else False,
             'type': 'opportunity',
-            'date_open': fields.datetime.now(),
-            'email_from': customer and customer.email or lead.email_from,
-            'phone': customer and customer.phone or lead.phone,
-            'date_conversion': fields.datetime.now(),
+            'date_open': fields.Datetime.now(),
+            'email_from': customer.email if customer else self.email_from,
+            'phone': customer.phone if customer else self.phone,
+            'date_conversion': fields.Datetime.now(),
         }
-        if not lead.stage_id:
-            stage_id = self.stage_find(cr, uid, [lead], team_id, [], context=context)
-            val['stage_id'] = stage_id
+        if not self.stage_id:
+            stage_id = self.stage_find(team_id, [])
+            value['stage_id'] = stage_id
             if stage_id:
-                val['probability'] = self.pool['crm.stage'].browse(cr, uid, stage_id, context=context).probability
-        return val
+                value['probability'] = self.env['crm.stage'].browse(stage_id).probability
+        return value
 
-    def convert_opportunity(self, cr, uid, ids, partner_id, user_ids=False, team_id=False, context=None):
+    @api.multi
+    def convert_opportunity(self, partner_id, user_ids=False, team_id=False):
         customer = False
         if partner_id:
-            partner = self.pool.get('res.partner')
-            customer = partner.browse(cr, uid, partner_id, context=context)
-        for lead in self.browse(cr, uid, ids, context=context):
+            customer = self.env['res.partner'].browse(partner_id)
+        for lead in self:
             if not lead.active or lead.probability == 100:
                 continue
-            vals = self._convert_opportunity_data(cr, uid, lead, customer, team_id, context=context)
-            self.write(cr, uid, [lead.id], vals, context=context)
+            vals = lead._convert_opportunity_data(customer, team_id)
+            lead.write(vals)
 
         if user_ids or team_id:
-            self.allocate_salesman(cr, uid, ids, user_ids, team_id, context=context)
+            self.allocate_salesman(user_ids, team_id)
 
         return True
 
-    def _lead_create_contact(self, cr, uid, lead, name, is_company, parent_id=False, context=None):
-        partner = self.pool.get('res.partner')
-        vals = {'name': name,
-            'user_id': lead.user_id.id,
-            'comment': lead.description,
-            'team_id': lead.team_id.id or False,
+    @api.multi
+    def _lead_create_contact(self, name, is_company, parent_id=False):
+        """ extract data from lead to create a partner
+            :param name : furtur name of the partner
+            :param is_company : True if the partner is a company
+            :param parent_id : id of the parent partner (False if no parent)
+            :returns res.partner record
+        """
+        email_split = tools.email_split(self.email_from)
+        values = {
+            'name': name,
+            'user_id': self.user_id.id,
+            'comment': self.description,
+            'team_id': self.team_id.id,
             'parent_id': parent_id,
-            'phone': lead.phone,
-            'mobile': lead.mobile,
-            'email': tools.email_split(lead.email_from) and tools.email_split(lead.email_from)[0] or False,
-            'fax': lead.fax,
-            'title': lead.title and lead.title.id or False,
-            'function': lead.function,
-            'street': lead.street,
-            'street2': lead.street2,
-            'zip': lead.zip,
-            'city': lead.city,
-            'country_id': lead.country_id and lead.country_id.id or False,
-            'state_id': lead.state_id and lead.state_id.id or False,
+            'phone': self.phone,
+            'mobile': self.mobile,
+            'email': email_split[0] if email_split else False,
+            'fax': self.fax,
+            'title': self.title.id,
+            'function': self.function,
+            'street': self.street,
+            'street2': self.street2,
+            'zip': self.zip,
+            'city': self.city,
+            'country_id': self.country_id.id,
+            'state_id': self.state_id.id,
             'is_company': is_company,
             'type': 'contact'
         }
-        partner = partner.create(cr, uid, vals, context=context)
-        return partner
-
-    def _create_lead_partner(self, cr, uid, lead, context=None):
-        contact_id = False
-        contact_name = lead.contact_name or lead.email_from and self.pool.get('res.partner')._parse_partner_name(lead.email_from, context=context)[0] or False
-        if lead.partner_name:
-            partner_company_id = self._lead_create_contact(cr, uid, lead, lead.partner_name, True, context=context)
-        elif lead.partner_id:
-            partner_company_id = lead.partner_id.id
+        return self.env['res.partner'].create(values)
+
+    @api.multi
+    def _create_lead_partner(self):
+        """ Create a partner from lead data
+            :returns res.partner record
+        """
+        contact_name = self.contact_name
+        if not contact_name:
+            contact_name = self.env['res.partner']._parse_partner_name(self.email_from)[0] if self.email_from else False
+
+        if self.partner_name:
+            partner_company = self._lead_create_contact(self.partner_name, True)
+        elif self.partner_id:
+            partner_company = self.partner_id
         else:
-            partner_company_id = False
+            partner_company = None
 
         if contact_name:
-            contact_id = self._lead_create_contact(cr, uid, lead, contact_name, False, partner_company_id, context=context)
-
-        partner_id = contact_id or partner_company_id or self._lead_create_contact(cr, uid, lead, lead.name, False, context=context)
-        return partner_id
-
-    def handle_partner_assignation(self, cr, uid, ids, action='create', partner_id=False, context=None):
-        """
-        Handle partner assignation during a lead conversion.
-        if action is 'create', create new partner with contact and assign lead to new partner_id.
-        otherwise assign lead to the specified partner_id
-
-        :param list ids: leads/opportunities ids to process
-        :param string action: what has to be done regarding partners (create it, assign an existing one, or nothing)
-        :param int partner_id: partner to assign if any
-        :return dict: dictionary organized as followed: {lead_id: partner_assigned_id}
+            return self._lead_create_contact(contact_name, False, partner_company.id if partner_company else False)
+
+        if partner_company:
+            return partner_company
+        return self._lead_create_contact(self.name, False)
+
+    @api.multi
+    def handle_partner_assignation(self,  action='create', partner_id=False):
+        """ Handle partner assignation during a lead conversion.
+            if action is 'create', create new partner with contact and assign lead to new partner_id.
+            otherwise assign lead to the specified partner_id
+
+            :param list ids: leads/opportunities ids to process
+            :param string action: what has to be done regarding partners (create it, assign an existing one, or nothing)
+            :param int partner_id: partner to assign if any
+            :return dict: dictionary organized as followed: {lead_id: partner_assigned_id}
         """
         partner_ids = {}
-        for lead in self.browse(cr, uid, ids, context=context):
+        for lead in self:
             # If the action is set to 'create' and no partner_id is set, create a new one
             if lead.partner_id:
                 partner_ids[lead.id] = lead.partner_id.id
             if action == 'create':
-                partner_id = self._create_lead_partner(cr, uid, lead, context)
-                self.pool['res.partner'].write(cr, uid, partner_id, {'team_id': lead.team_id and lead.team_id.id or False})
+                partner = lead._create_lead_partner()
+                partner_id = partner.id
+                partner.write({'team_id': lead.team_id.id if lead.team_id else False})
             if partner_id:
                 lead.write({'partner_id': partner_id})
             partner_ids[lead.id] = partner_id
         return partner_ids
 
-    def allocate_salesman(self, cr, uid, ids, user_ids=None, team_id=False, context=None):
-        """
-        Assign salesmen and salesteam to a batch of leads.  If there are more
-        leads than salesmen, these salesmen will be assigned in round-robin.
-        E.g.: 4 salesmen (S1, S2, S3, S4) for 6 leads (L1, L2, ... L6).  They
-        will be assigned as followed: L1 - S1, L2 - S2, L3 - S3, L4 - S4,
-        L5 - S1, L6 - S2.
-
-        :param list ids: leads/opportunities ids to process
-        :param list user_ids: salesmen to assign
-        :param int team_id: salesteam to assign
-        :return bool
+    @api.multi
+    def allocate_salesman(self, user_ids=None, team_id=False):
+        """ Assign salesmen and salesteam to a batch of leads.  If there are more
+            leads than salesmen, these salesmen will be assigned in round-robin.
+            E.g.: 4 salesmen (S1, S2, S3, S4) for 6 leads (L1, L2, ... L6).  They
+            will be assigned as followed: L1 - S1, L2 - S2, L3 - S3, L4 - S4,
+            L5 - S1, L6 - S2.
+
+            :param list ids: leads/opportunities ids to process
+            :param list user_ids: salesmen to assign
+            :param int team_id: salesteam to assign
+            :return bool
         """
         index = 0
-
-        for lead_id in ids:
+        for lead in self:
             value = {}
             if team_id:
                 value['team_id'] = team_id
@@ -750,291 +836,95 @@ class crm_lead(FormatAddress, osv.osv):
                 # Cycle through user_ids
                 index = (index + 1) % len(user_ids)
             if value:
-                self.write(cr, uid, [lead_id], value, context=context)
+                lead.write(value)
         return True
 
-    def redirect_opportunity_view(self, cr, uid, opportunity_id, context=None):
-        models_data = self.pool.get('ir.model.data')
-
+    @api.multi
+    def redirect_opportunity_view(self):
+        self.ensure_one()
         # Get opportunity views
-        dummy, form_view = models_data.get_object_reference(cr, uid, 'crm', 'crm_case_form_view_oppor')
-        dummy, tree_view = models_data.get_object_reference(cr, uid, 'crm', 'crm_case_tree_view_oppor')
+        form_view = self.env.ref('crm.crm_case_form_view_oppor')
+        tree_view = self.env.ref('crm.crm_case_tree_view_oppor')
         return {
             'name': _('Opportunity'),
             'view_type': 'form',
             'view_mode': 'tree, form',
             'res_model': 'crm.lead',
             'domain': [('type', '=', 'opportunity')],
-            'res_id': int(opportunity_id),
+            'res_id': self.id,
             'view_id': False,
-            'views': [(form_view or False, 'form'),
-                      (tree_view or False, 'tree'), (False, 'kanban'),
-                      (False, 'calendar'), (False, 'graph')],
+            'views': [
+                (form_view.id if form_view else False, 'form'),
+                (tree_view.id if tree_view else False, 'tree'),
+                (False, 'kanban'),
+                (False, 'calendar'),
+                (False, 'graph')
+            ],
             'type': 'ir.actions.act_window',
             'context': {'default_type': 'opportunity'}
         }
 
-    def redirect_lead_view(self, cr, uid, lead_id, context=None):
-        models_data = self.pool.get('ir.model.data')
-
+    @api.multi
+    def redirect_lead_view(self):
+        self.ensure_one()
         # Get lead views
-        dummy, form_view = models_data.get_object_reference(cr, uid, 'crm', 'crm_case_form_view_leads')
-        dummy, tree_view = models_data.get_object_reference(cr, uid, 'crm', 'crm_case_tree_view_leads')
+        form_view = self.env.ref('crm.crm_case_form_view_leads')
+        tree_view = self.env.ref('crm.crm_case_tree_view_leads')
         return {
             'name': _('Lead'),
             'view_type': 'form',
             'view_mode': 'tree, form',
             'res_model': 'crm.lead',
             'domain': [('type', '=', 'lead')],
-            'res_id': int(lead_id),
+            'res_id': self.id,
             'view_id': False,
-            'views': [(form_view or False, 'form'),
-                      (tree_view or False, 'tree'),
-                      (False, 'calendar'), (False, 'graph')],
+            'views': [
+                (form_view.id if form_view else False, 'form'),
+                (tree_view.id if form_view else False, 'tree'),
+                (False, 'calendar'),
+                (False, 'graph')
+            ],
             'type': 'ir.actions.act_window',
         }
 
-    def action_schedule_meeting(self, cr, uid, ids, context=None):
-        """
-        Open meeting's calendar view to schedule meeting on current opportunity.
-        :return dict: dictionary value for created Meeting view
-        """
-        lead = self.browse(cr, uid, ids[0], context)
-        res = self.pool.get('ir.actions.act_window').for_xml_id(cr, uid, 'calendar', 'action_calendar_event', context)
-        partner_ids = [self.pool['res.users'].browse(cr, uid, uid, context=context).partner_id.id]
-        if lead.partner_id:
-            partner_ids.append(lead.partner_id.id)
-        res['context'] = {
-            'search_default_opportunity_id': lead.type == 'opportunity' and lead.id or False,
-            'default_opportunity_id': lead.type == 'opportunity' and lead.id or False,
-            'default_partner_id': lead.partner_id and lead.partner_id.id or False,
-            'default_partner_ids': partner_ids,
-            'default_team_id': lead.team_id and lead.team_id.id or False,
-            'default_name': lead.name,
+    @api.model
+    def get_empty_list_help(self, help):
+        additionnal_context = {
+            'empty_list_help_model': 'crm.team',
+            'empty_list_help_id': self._context.get('default_team_id', False),
+            'empty_list_help_document_name': _("opportunities")
         }
-        return res
-
-    def create(self, cr, uid, vals, context=None):
-        context = dict(context or {})
-        if vals.get('type') and not context.get('default_type'):
-            context['default_type'] = vals.get('type')
-        if vals.get('team_id') and not context.get('default_team_id'):
-            context['default_team_id'] = vals.get('team_id')
-        if vals.get('user_id') and 'date_open' not in vals:
-            vals['date_open'] = fields.datetime.now()
-
-        # context: no_log, because subtype already handle this
-        create_context = dict(context, mail_create_nolog=True)
-        return super(crm_lead, self).create(cr, uid, vals, context=create_context)
-
-    def write(self, cr, uid, ids, vals, context=None):
-        # stage change: update date_last_stage_update
-        if 'stage_id' in vals:
-            vals['date_last_stage_update'] = fields.datetime.now()
-        if vals.get('user_id') and 'date_open' not in vals:
-            vals['date_open'] = fields.datetime.now()
-        # stage change with new stage: update probability and date_closed
-        if vals.get('stage_id') and 'probability' not in vals:
-            onchange_stage_values = self.onchange_stage_id(cr, uid, ids, vals.get('stage_id'), context=context)['value']
-            vals.update(onchange_stage_values)
-        if vals.get('probability') >= 100 or not vals.get('active', True):
-            vals['date_closed'] = fields.datetime.now()
-        elif 'probability' in vals and vals['probability'] < 100:
-            vals['date_closed'] = False
-        return super(crm_lead, self).write(cr, uid, ids, vals, context=context)
-
-    def copy(self, cr, uid, id, default=None, context=None):
-        if not default:
-            default = {}
-        if not context:
-            context = {}
-        lead = self.browse(cr, uid, id, context=context)
-        local_context = dict(context)
-        local_context.setdefault('default_type', lead.type)
-        local_context.setdefault('default_team_id', lead.team_id.id)
-        if lead.type == 'opportunity':
-            default['date_open'] = fields.datetime.now()
-        else:
-            default['date_open'] = False
-        return super(crm_lead, self).copy(cr, uid, id, default, context=local_context)
-
-    def get_empty_list_help(self, cr, uid, help, context=None):
-        context = dict(context or {})
-        context['empty_list_help_model'] = 'crm.team'
-        context['empty_list_help_id'] = context.get('default_team_id', None)
-        context['empty_list_help_document_name'] = _("opportunities")
         if help:
-            alias_record = self.pool['ir.model.data'].xmlid_to_object(cr, uid, "crm.mail_alias_lead_info")
+            alias_record = self.env.ref("crm.mail_alias_lead_info", raise_if_not_found=False)
             if alias_record and alias_record.alias_domain and alias_record.alias_name:
-                dynamic_help = '<p>%s</p>' % _("""All email incoming to %(link)s  will automatically create new opportunity.
-Update your business card, phone book, social media,... Send an email right now and see it here.""") % {
-                    'link': "<a href='mailto:%(email)s'>%(email)s</a>" % {'email': '%s@%s' % (alias_record.alias_name, alias_record.alias_domain)}
-                }
-                return '<p class="oe_view_nocontent_create">%s</p>%s%s' % (
-                    _('Click to add a new opportunity'),
-                    help,
-                    dynamic_help)
-        return super(crm_lead, self).get_empty_list_help(cr, uid, help, context=context)
-
-    # ----------------------------------------
-    # Mail Gateway
-    # ----------------------------------------
-
-    def _track_subtype(self, cr, uid, ids, init_values, context=None):
-        record = self.browse(cr, uid, ids[0], context=context)
-        if 'stage_id' in init_values and record.probability == 100 and record.stage_id and record.stage_id.on_change:
-            return 'crm.mt_lead_won'
-        elif 'active' in init_values and record.probability == 0 and not record.active:
-            return 'crm.mt_lead_lost'
-        elif 'stage_id' in init_values and record.stage_id and record.stage_id.sequence <= 1:
-            return 'crm.mt_lead_create'
-        elif 'stage_id' in init_values:
-            return 'crm.mt_lead_stage'
-        return super(crm_lead, self)._track_subtype(cr, uid, ids, init_values, context=context)
-
-    def _notification_group_recipients(self, cr, uid, ids, message, recipients, done_ids, group_data, context=None):
-        """ Override the mail.thread method to handle salesman recipients.
-        Indeed those will have specific action in their notification emails. """
-        group_sale_salesman = self.pool['ir.model.data'].xmlid_to_res_id(cr, uid, 'sales_team.group_sale_salesman')
-        for recipient in recipients:
-            if recipient.id in done_ids:
-                continue
-            if recipient.user_ids and group_sale_salesman in recipient.user_ids[0].groups_id.ids:
-                group_data['group_sale_salesman'] |= recipient
-                done_ids.add(recipient.id)
-        return super(crm_lead, self)._notification_group_recipients(cr, uid, ids, message, recipients, done_ids, group_data, context=context)
-
-    def _notification_get_recipient_groups(self, cr, uid, ids, message, recipients, context=None):
-        res = super(crm_lead, self)._notification_get_recipient_groups(cr, uid, ids, message, recipients, context=context)
-
-        lead = self.browse(cr, uid, ids[0], context=context)
-
-        won_action = self._notification_link_helper(cr, uid, ids, 'method', context=context, method='case_mark_won')
-        lost_action = self._notification_link_helper(cr, uid, ids, 'method', context=context, method='case_mark_lost')
-        convert_action = self._notification_link_helper(cr, uid, ids, 'method', context=context, method='convert_opportunity', partner_id=lead.partner_id.id)
-
-        if lead.type == 'lead':
-            res['group_sale_salesman'] = {
-                'actions': [{'url': convert_action, 'title': 'Convert to opportunity'}]
-            }
-        else:
-            res['group_sale_salesman'] = {
-                'actions': [
-                    {'url': won_action, 'title': 'Won'},
-                    {'url': lost_action, 'title': 'Lost'}]
-            }
-        return res
-
-    @api.cr_uid_context
-    def message_get_reply_to(self, cr, uid, ids, default=None, context=None):
-        """ Override to get the reply_to of the parent project. """
-        leads = self.browse(cr, SUPERUSER_ID, ids, context=context)
-        team_ids = set([lead.team_id.id for lead in leads if lead.team_id])
-        aliases = self.pool['crm.team'].message_get_reply_to(cr, uid, list(team_ids), default=default, context=context)
-        return dict((lead.id, aliases.get(lead.team_id and lead.team_id.id or 0, False)) for lead in leads)
-
-    def get_formview_id(self, cr, uid, id, context=None):
-        obj = self.browse(cr, uid, id, context=context)
-        if obj.type == 'opportunity':
-            model, view_id = self.pool.get('ir.model.data').get_object_reference(cr, uid, 'crm', 'crm_case_form_view_oppor')
-        else:
-            view_id = super(crm_lead, self).get_formview_id(cr, uid, id, context=context)
-        return view_id
-
-    def message_get_suggested_recipients(self, cr, uid, ids, context=None):
-        recipients = super(crm_lead, self).message_get_suggested_recipients(cr, uid, ids, context=context)
-        try:
-            for lead in self.browse(cr, uid, ids, context=context):
-                if lead.partner_id:
-                    lead._message_add_suggested_recipient(recipients, partner=lead.partner_id, reason=_('Customer'))
-                elif lead.email_from:
-                    lead._message_add_suggested_recipient(recipients, email=lead.email_from, reason=_('Customer Email'))
-        except AccessError:  # no read access rights -> just ignore suggested recipients because this imply modifying followers
-            pass
-        return recipients
-
-    def message_new(self, cr, uid, msg, custom_values=None, context=None):
-        """ Overrides mail_thread message_new that is called by the mailgateway
-            through message_process.
-            This override updates the document according to the email.
-        """
-        # remove default author when going through the mail gateway. Indeed we
-        # do not want to explicitly set user_id to False; however we do not
-        # want the gateway user to be responsible if no other responsible is
-        # found.
-        create_context = dict(context or {})
-        create_context['default_user_id'] = False
-        if custom_values is None:
-            custom_values = {}
-        defaults = {
-            'name':  msg.get('subject') or _("No Subject"),
-            'email_from': msg.get('from'),
-            'email_cc': msg.get('cc'),
-            'partner_id': msg.get('author_id', False),
-        }
-        if msg.get('author_id'):
-            defaults.update(self.on_change_partner_id(cr, uid, None, msg.get('author_id'), context=context)['value'])
-        if msg.get('priority') in dict(crm_stage.AVAILABLE_PRIORITIES):
-            defaults['priority'] = msg.get('priority')
-        defaults.update(custom_values)
-        return super(crm_lead, self).message_new(cr, uid, msg, custom_values=defaults, context=create_context)
-
-    def message_update(self, cr, uid, ids, msg, update_vals=None, context=None):
-        """ Overrides mail_thread message_update that is called by the mailgateway
-            through message_process.
-            This method updates the document according to the email.
-        """
-        if isinstance(ids, (str, int, long)):
-            ids = [ids]
-        if update_vals is None: update_vals = {}
-
-        if msg.get('priority') in dict(crm_stage.AVAILABLE_PRIORITIES):
-            update_vals['priority'] = msg.get('priority')
-        maps = {
-            'revenue': 'planned_revenue',
-            'probability':'probability',
-        }
-        for line in msg.get('body', '').split('\n'):
-            line = line.strip()
-            res = tools.command_re.match(line)
-            if res and maps.get(res.group(1).lower()):
-                key = maps.get(res.group(1).lower())
-                update_vals[key] = res.group(2).lower()
-
-        return super(crm_lead, self).message_update(cr, uid, ids, msg, update_vals=update_vals, context=context)
-
-    def log_meeting(self, cr, uid, ids, meeting_subject, meeting_date, duration, context=None):
+                email = '%s@%s' % (alias_record.alias_name, alias_record.alias_domain)
+                email_link = "<a href='mailto:%s'>%s</a>" % (email, email)
+                dynamic_help = _("""All email incoming to %s will automatically
+                    create new opportunity. Update your business card, phone book, social media,...
+                    Send an email right now and see it here.""") % (email_link,)
+                return '<p class="oe_view_nocontent_create">%s</p>%s<p>%s</p>' % (_('Click to add a new opportunity'), help, dynamic_help)
+        return super(Lead, self.with_context(**additionnal_context)).get_empty_list_help(help)
+
+    @api.multi
+    def log_meeting(self, meeting_subject, meeting_date, duration):
         if not duration:
             duration = _('unknown')
         else:
             duration = str(duration)
-        meet_date = datetime.strptime(meeting_date, tools.DEFAULT_SERVER_DATETIME_FORMAT)
-        meeting_usertime = fields.datetime.context_timestamp(cr, uid, meet_date, context=context).strftime(tools.DEFAULT_SERVER_DATETIME_FORMAT)
+        meet_date = fields.Datetime.from_string(meeting_date)
+        meeting_usertime = fields.Datetime.to_string(fields.Datetime.context_timestamp(self, meet_date))
         html_time = "<time datetime='%s+00:00'>%s</time>" % (meeting_date, meeting_usertime)
         message = _("Meeting scheduled at '%s'<br> Subject: %s <br> Duration: %s hour(s)") % (html_time, meeting_subject, duration)
-        return self.message_post(cr, uid, ids, body=message, context=context)
-
-    def onchange_state(self, cr, uid, ids, state_id, context=None):
-        if state_id:
-            country_id=self.pool.get('res.country.state').browse(cr, uid, state_id, context).country_id.id
-            return {'value':{'country_id':country_id}}
-        return {}
-
-    def message_partner_info_from_emails(self, cr, uid, ids, emails, link_mail=False, context=None):
-        res = super(crm_lead, self).message_partner_info_from_emails(cr, uid, ids, emails, link_mail=link_mail, context=context)
-        lead = self.browse(cr, uid, ids[0], context=context)
-        for partner_info in res:
-            if not partner_info.get('partner_id') and (lead.partner_name or lead.contact_name):
-                emails = email_re.findall(partner_info['full_name'] or '')
-                email = emails and emails[0] or ''
-                if email and lead.email_from and email.lower() == lead.email_from.lower():
-                    partner_info['full_name'] = '%s <%s>' % (lead.partner_name or lead.contact_name, email)
-                    break
-        return res
+        return self.message_post(body=message)
 
-    def retrieve_sales_dashboard(self, cr, uid, context=None):
+    # ----------------------------------------
+    # Sales Team Dashboard
+    # ----------------------------------------
 
-        res = {
+    @api.model
+    def retrieve_sales_dashboard(self):
+        """ Fetch data to setup Sales Dashboard """
+        result = {
             'meeting': {
                 'today': 0,
                 'next_7_days': 0,
@@ -1060,136 +950,260 @@ Update your business card, phone book, social media,... Send an email right now
             'nb_opportunities': 0,
         }
 
-        opportunities = self.search_read(
-            cr, uid,
-            [('type', '=', 'opportunity'), ('user_id', '=', uid)],
-            ['date_deadline', 'next_activity_id', 'date_action', 'date_closed', 'planned_revenue'], context=context)
+        opportunities = self.search_read([('type', '=', 'opportunity'), ('user_id', '=', self._uid)], ['date_deadline', 'next_activity_id', 'date_action', 'date_closed', 'planned_revenue'])
 
         for opp in opportunities:
-
             # Expected closing
             if opp['date_deadline']:
-                date_deadline = datetime.strptime(opp['date_deadline'], tools.DEFAULT_SERVER_DATE_FORMAT).date()
-
+                date_deadline = fields.Date.from_string(opp['date_deadline'])
                 if date_deadline == date.today():
-                    res['closing']['today'] += 1
+                    result['closing']['today'] += 1
                 if date_deadline >= date.today() and date_deadline <= date.today() + timedelta(days=7):
-                    res['closing']['next_7_days'] += 1
+                    result['closing']['next_7_days'] += 1
                 if date_deadline < date.today():
-                    res['closing']['overdue'] += 1
-
+                    result['closing']['overdue'] += 1
             # Next activities
             if opp['next_activity_id'] and opp['date_action']:
-                date_action = datetime.strptime(opp['date_action'], tools.DEFAULT_SERVER_DATE_FORMAT).date()
-
+                date_action = fields.Date.from_string(opp['date_action'])
                 if date_action == date.today():
-                    res['activity']['today'] += 1
+                    result['activity']['today'] += 1
                 if date_action >= date.today() and date_action <= date.today() + timedelta(days=7):
-                    res['activity']['next_7_days'] += 1
+                    result['activity']['next_7_days'] += 1
                 if date_action < date.today():
-                    res['activity']['overdue'] += 1
-
+                    result['activity']['overdue'] += 1
             # Won in Opportunities
             if opp['date_closed']:
-                date_closed = datetime.strptime(opp['date_closed'], tools.DEFAULT_SERVER_DATETIME_FORMAT).date()
-
+                date_closed = fields.Date.from_string(opp['date_closed'])
                 if date_closed <= date.today() and date_closed >= date.today().replace(day=1):
                     if opp['planned_revenue']:
-                        res['won']['this_month'] += opp['planned_revenue']
+                        result['won']['this_month'] += opp['planned_revenue']
                 elif date_closed < date.today().replace(day=1) and date_closed >= date.today().replace(day=1) - relativedelta(months=+1):
                     if opp['planned_revenue']:
-                        res['won']['last_month'] += opp['planned_revenue']
+                        result['won']['last_month'] += opp['planned_revenue']
+
+        result['nb_opportunities'] = len(opportunities)
 
         # crm.activity is a very messy model so we need to do that in order to retrieve the actions done.
-        cr.execute("""
+        self._cr.execute("""
             SELECT
                 m.id,
                 m.subtype_id,
                 m.date,
                 l.user_id,
                 l.type
-            FROM
-                "mail_message" m
-            LEFT JOIN
-                "crm_lead" l
-            ON
-                (m.res_id = l.id)
-            INNER JOIN
-                "crm_activity" a
-            ON
-                (m.subtype_id = a.subtype_id)
+            FROM mail_message M
+                LEFT JOIN crm_lead L ON (M.res_id = L.id)
+                INNER JOIN crm_activity A ON (M.subtype_id = A.subtype_id)
             WHERE
-                (m.model = 'crm.lead') AND (l.user_id = %s) AND (l.type = 'opportunity')
-        """, (uid,))
-        activites_done = cr.dictfetchall()
+                (M.model = 'crm.lead') AND (L.user_id = %s) AND (L.type = 'opportunity')
+        """, (self._uid,))
+        activites_done = self._cr.dictfetchall()
 
-        for act in activites_done:
-            if act['date']:
-                date_act = datetime.strptime(act['date'], tools.DEFAULT_SERVER_DATETIME_FORMAT).date()
+        for activity in activites_done:
+            if activity['date']:
+                date_act = fields.Date.from_string(activity['date'])
                 if date_act <= date.today() and date_act >= date.today().replace(day=1):
-                        res['done']['this_month'] += 1
+                    result['done']['this_month'] += 1
                 elif date_act < date.today().replace(day=1) and date_act >= date.today().replace(day=1) - relativedelta(months=+1):
-                    res['done']['last_month'] += 1
+                    result['done']['last_month'] += 1
 
         # Meetings
-        min_date = datetime.now().strftime(tools.DEFAULT_SERVER_DATETIME_FORMAT)
-        max_date = (datetime.now() + timedelta(days=8)).strftime(tools.DEFAULT_SERVER_DATETIME_FORMAT)
+        min_date = fields.Datetime.now()
+        max_date = fields.Datetime.to_string(datetime.now() + timedelta(days=8))
         meetings_domain = [
             ('start', '>=', min_date),
             ('start', '<=', max_date)
         ]
+        #TODO JEM : remove this stupid context key
         # We need to add 'mymeetings' in the context for the search to be correct.
-        meetings = self.pool.get('calendar.event').search_read(cr, uid, meetings_domain, ['start'], context=context.update({'mymeetings': 1}) if context else {'mymeetings': 1})
+        meetings = self.env['calendar.event'].with_context(mymeetings=1).search(meetings_domain)
         for meeting in meetings:
             if meeting['start']:
                 start = datetime.strptime(meeting['start'], tools.DEFAULT_SERVER_DATETIME_FORMAT).date()
-
                 if start == date.today():
-                    res['meeting']['today'] += 1
+                    result['meeting']['today'] += 1
                 if start >= date.today() and start <= date.today() + timedelta(days=7):
-                    res['meeting']['next_7_days'] += 1
+                    result['meeting']['next_7_days'] += 1
 
-        res['nb_opportunities'] = len(opportunities)
+        result['done']['target'] = self.env.user.target_sales_done
+        result['won']['target'] = self.env.user.target_sales_won
+        result['currency_id'] = self.env.user.company_id.currency_id.id
 
-        user = self.pool('res.users').browse(cr, uid, uid, context=context)
-        res['done']['target'] = user.target_sales_done
-        res['won']['target'] = user.target_sales_won
+        return result
 
-        res['currency_id'] = user.company_id.currency_id.id
+    @api.model
+    def modify_target_sales_dashboard(self, target_name, target_value):
+        """ Update the user objectives (`target_sales_done`, target_sales_won`
+            and `target_sales_invoiced` fields).
+            :param target_name : part of the fields name to update
+            :param target_value : value of the field to update
+        """
+        if target_name in ['won', 'done', 'invoiced']:
+            # bypass rights, since self.env.user is browsed as SUPERUSER_ID
+            self.env.user.write({'target_sales_' + target_name: target_value})
+        else:
+            raise UserError(_('This target does not exist.'))
 
-        return res
+    # ----------------------------------------
+    # Mail Gateway
+    # ----------------------------------------
 
-    def modify_target_sales_dashboard(self, cr, uid, target_name, target_value, context=None):
+    @api.multi
+    def _track_subtype(self, init_values):
+        self.ensure_one()
+        if 'stage_id' in init_values and self.probability == 100 and self.stage_id and self.stage_id.on_change:
+            return 'crm.mt_lead_won'
+        elif 'active' in init_values and self.probability == 0 and not self.active:
+            return 'crm.mt_lead_lost'
+        elif 'stage_id' in init_values and self.stage_id and self.stage_id.sequence <= 1:
+            return 'crm.mt_lead_create'
+        elif 'stage_id' in init_values:
+            return 'crm.mt_lead_stage'
+        return super(Lead, self)._track_subtype(init_values)
 
-        if target_name in ['won', 'done', 'invoiced']:
-            # bypass rights (with superuser_id)
-            self.pool('res.users').write(cr, SUPERUSER_ID, [uid], {'target_sales_' + target_name: target_value}, context=context)
+    @api.multi
+    def _notification_group_recipients(self, message, recipients, done_ids, group_data):
+        """ Override the mail.thread method to handle salesman recipients.
+            Indeed those will have specific action in their notification emails.
+        """
+        group_sale_salesman = self.env.ref('sales_team.group_sale_salesman')
+        for recipient in recipients:
+            if recipient.id in done_ids:
+                continue
+            # FIXME: why not recipient.user_ids[0].has_group(sales_team.group_sale_salesman)?
+            if recipient.user_ids and group_sale_salesman in recipient.user_ids[0].groups_id:
+                group_data['group_sale_salesman'] |= recipient
+                done_ids.add(recipient.id)
+        return super(Lead, self)._notification_group_recipients(message, recipients, done_ids, group_data)
+
+    @api.multi
+    def _notification_get_recipient_groups(self, message, recipients):
+        result = super(Lead, self)._notification_get_recipient_groups(message, recipients)
+
+        lead = self[0]
+        won_action = self._notification_link_helper('method', method='action_set_won')
+        lost_action = self._notification_link_helper('method', method='action_set_lost')
+        convert_action = self._notification_link_helper('method', method='convert_opportunity', partner_id=lead.partner_id.id)
+
+        if lead.type == 'lead':
+            result['group_sale_salesman'] = {
+                'actions': [{'url': convert_action, 'title': 'Convert to opportunity'}]
+            }
         else:
-            raise UserError(_('This target does not exist.'))
+            result['group_sale_salesman'] = {
+                'actions': [
+                    {'url': won_action, 'title': 'Won'},
+                    {'url': lost_action, 'title': 'Lost'}]
+            }
+        return result
 
-    def close_dialog(self, cr, uid, ids, context=None):
-        return {'type': 'ir.actions.act_window_close'}
+    @api.model
+    def message_get_reply_to(self, res_ids, default=None):
+        leads = self.sudo().browse(res_ids)
+        aliases = self.env['crm.team'].message_get_reply_to(leads.mapped('team_id').ids, default=default)
+        return dict((lead.id, aliases.get(lead.team_id and lead.team_id.id or 0, False)) for lead in leads)
+
+    @api.multi
+    def get_formview_id(self):
+        self.ensure_one()
+        if self.type == 'opportunity':
+            view_id = self.env.ref('crm.crm_case_form_view_oppor').id
+        else:
+            view_id = super(Lead, self).get_formview_id()
+        return view_id
+
+    @api.multi
+    def message_get_suggested_recipients(self):
+        recipients = super(Lead, self).message_get_suggested_recipients()
+        try:
+            for lead in self:
+                if lead.partner_id:
+                    lead._message_add_suggested_recipient(recipients, partner=lead.partner_id, reason=_('Customer'))
+                elif lead.email_from:
+                    lead._message_add_suggested_recipient(recipients, email=lead.email_from, reason=_('Customer Email'))
+        except AccessError:  # no read access rights -> just ignore suggested recipients because this imply modifying followers
+            pass
+        return recipients
+
+    @api.model
+    def message_new(self, msg_dict, custom_values=None):
+        """ Overrides mail_thread message_new that is called by the mailgateway
+            through message_process.
+            This override updates the document according to the email.
+        """
+        # remove default author when going through the mail gateway. Indeed we
+        # do not want to explicitly set user_id to False; however we do not
+        # want the gateway user to be responsible if no other responsible is
+        # found.
+        self = self.with_context(default_user_id=False)
+
+        if custom_values is None:
+            custom_values = {}
+        defaults = {
+            'name':  msg_dict.get('subject') or _("No Subject"),
+            'email_from': msg_dict.get('from'),
+            'email_cc': msg_dict.get('cc'),
+            'partner_id': msg_dict.get('author_id', False),
+        }
+        if msg_dict.get('author_id'):
+            defaults.update(self._onchange_partner_id_values(msg_dict.get('author_id')))
+        if msg_dict.get('priority') in dict(crm_stage.AVAILABLE_PRIORITIES):
+            defaults['priority'] = msg_dict.get('priority')
+        defaults.update(custom_values)
+        return super(Lead, self).message_new(msg_dict, custom_values=defaults)
+
+    @api.multi
+    def message_update(self, msg_dict, update_vals=None):
+        """ Overrides mail_thread message_update that is called by the mailgateway
+            through message_process.
+            This method updates the document according to the email.
+        """
+        if update_vals is None:
+            update_vals = {}
+        if msg_dict.get('priority') in dict(crm_stage.AVAILABLE_PRIORITIES):
+            update_vals['priority'] = msg_dict.get('priority')
+        maps = {
+            'revenue': 'planned_revenue',
+            'probability': 'probability',
+        }
+        for line in msg_dict.get('body', '').split('\n'):
+            line = line.strip()
+            res = tools.command_re.match(line)
+            if res and maps.get(res.group(1).lower()):
+                key = maps.get(res.group(1).lower())
+                update_vals[key] = res.group(2).lower()
+        return super(Lead, self).message_update(msg_dict, update_vals=update_vals)
+
+    @api.multi
+    def message_partner_info_from_emails(self, emails, link_mail=False):
+        result = super(Lead, self).message_partner_info_from_emails(emails, link_mail=link_mail)
+        for partner_info in result:
+            if not partner_info.get('partner_id') and (self.partner_name or self.contact_name):
+                emails = email_re.findall(partner_info['full_name'] or '')
+                email = emails and emails[0] or ''
+                if email and self.email_from and email.lower() == self.email_from.lower():
+                    partner_info['full_name'] = '%s <%s>' % (self.partner_name or self.contact_name, email)
+                    break
+        return result
+
+
+class Tag(models.Model):
 
-class crm_lead_tag(osv.Model):
     _name = "crm.lead.tag"
     _description = "Category of lead"
-    _columns = {
-        'name': fields.char('Name', required=True),
-        'color': fields.integer('Color Index'),
-        'team_id': fields.many2one('crm.team', 'Sales Team'),
-    }
+
+    name = fields.Char('Name', required=True)
+    color = fields.Integer('Color Index')
+    team_id = fields.Many2one('crm.team', 'Sales Team')
+
     _sql_constraints = [
-            ('name_uniq', 'unique (name)', "Tag name already exists !"),
+        ('name_uniq', 'unique (name)', "Tag name already exists !"),
     ]
 
 
-class crm_lost_reason(osv.Model):
+class LostReason(models.Model):
     _name = "crm.lost.reason"
     _description = 'Reason for loosing leads'
-    _columns = {
-        'name': fields.char('Name', required=True, translate=True),
-        'active': fields.boolean('Active'),
-    }
-    _defaults = {
-        'active': True,
-    }
+
+    name = fields.Char('Name', required=True, translate=True)
+    active = fields.Boolean('Active', default=True)

--- a/addons/crm/models/crm_stage.py
+++ b/addons/crm/models/crm_stage.py
@@ -1,7 +1,7 @@
 # -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
-from openerp.osv import osv, fields
+from odoo import api, fields, models
 
 AVAILABLE_PRIORITIES = [
     ('0', 'Normal'),
@@ -11,7 +11,7 @@ AVAILABLE_PRIORITIES = [
 ]
 
 
-class crm_stage(osv.Model):
+class Stage(models.Model):
     """ Model for case stages. This models the main stages of a document
         management flow. Main CRM objects (leads, opportunities, project
         issues, ...) will now use only stages, instead of state and stages.
@@ -22,31 +22,24 @@ class crm_stage(osv.Model):
     _rec_name = 'name'
     _order = "sequence, name, id"
 
-    _columns = {
-        'name': fields.char('Stage Name', required=True, translate=True),
-        'sequence': fields.integer('Sequence', help="Used to order stages. Lower is better."),
-        'probability': fields.float('Probability (%)', required=True, help="This percentage depicts the default/average probability of the Case for this stage to be a success"),
-        'on_change': fields.boolean('Change Probability Automatically', help="Setting this stage will change the probability automatically on the opportunity."),
-        'requirements': fields.text('Requirements', help="Enter here the internal requirements for this stage (ex: Offer sent to customer). It will appear as a tooltip over the stage's name."),
-        'team_id': fields.many2one('crm.team', 'Team',
-                                   ondelete='set null',
-                                   help='Specific team that uses this stage. Other teams will not ne able to see or use this stage.'),
-        'legend_priority': fields.text(
-            'Priority Management Explanation', translate=True,
-            help='Explanation text to help users using the star and priority mechanism on stages or issues that are in this stage.'),
-        'fold': fields.boolean('Folded in Pipeline',
-                               help='This stage is folded in the kanban view when '
-                               'there are no records in that stage to display.'),
-    }
+    @api.model
+    def default_get(self, fields):
+        """ Hack :  when going from the pipeline, creating a stage with a sales team in
+            context should not create a stage for the current sales team only
+        """
+        ctx = dict(self.env.context)
+        if ctx.get('default_team_id') and not ctx.get('crm_team_mono'):
+            ctx.pop('default_team_id')
+        return super(Stage, self.with_context(ctx)).default_get(fields)
 
-    _defaults = {
-        'sequence': 1,
-        'probability': 10.0,
-        'fold': False,
-    }
-
-    def default_get(self, cr, uid, fields, context=None):
-        if context and context.get('default_team_id') and not context.get('crm_team_mono', False):
-            context = dict(context)
-            context.pop('default_team_id')
-        return super(crm_stage, self).default_get(cr, uid, fields, context=context)
+    name = fields.Char('Stage Name', required=True, translate=True)
+    sequence = fields.Integer('Sequence', default=1, help="Used to order stages. Lower is better.")
+    probability = fields.Float('Probability (%)', required=True, default=10.0, help="This percentage depicts the default/average probability of the Case for this stage to be a success")
+    on_change = fields.Boolean('Change Probability Automatically', help="Setting this stage will change the probability automatically on the opportunity.")
+    requirements = fields.Text('Requirements', help="Enter here the internal requirements for this stage (ex: Offer sent to customer). It will appear as a tooltip over the stage's name.")
+    team_id = fields.Many2one('crm.team', string='Team', ondelete='set null',
+        help='Specific team that uses this stage. Other teams will not ne able to see or use this stage.')
+    legend_priority = fields.Text('Priority Management Explanation', translate=True,
+        help='Explanation text to help users using the star and priority mechanism on stages or issues that are in this stage.')
+    fold = fields.Boolean('Folded in Pipeline',
+        help='This stage is folded in the kanban view when there are no records in that stage to display.')

--- a/addons/crm/models/crm_team.py
+++ b/addons/crm/models/crm_team.py
@@ -1,67 +1,60 @@
 # -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
 
-from openerp.osv import fields, osv
-from openerp.tools.safe_eval import safe_eval as eval
-from openerp.tools.translate import _
+from odoo import api, fields, models
+from odoo.tools.safe_eval import safe_eval as eval
+from odoo.tools.translate import _
 
 
-class crm_team(osv.Model):
+class Team(models.Model):
     _name = 'crm.team'
     _inherit = ['mail.alias.mixin', 'crm.team']
 
-    _columns = {
-        'resource_calendar_id': fields.many2one('resource.calendar', "Working Time", help="Used to compute open days"),
-        'use_leads': fields.boolean('Leads',
-            help="The first contact you get with a potential customer is a lead you qualify before converting it into a real business opportunity. Check this box to manage leads in this sales team."),
-        'use_opportunities': fields.boolean('Opportunities', help="Check this box to manage opportunities in this sales team."),
-        'alias_id': fields.many2one('mail.alias', 'Alias', ondelete="restrict", required=True, help="The email address associated with this team. New emails received will automatically create new leads assigned to the team."),
-    }
+    resource_calendar_id = fields.Many2one('resource.calendar', string="Working Time", help="Used to compute open days")
+    use_leads = fields.Boolean('Leads',
+        help="The first contact you get with a potential customer is a lead you qualify before converting it into a real business opportunity. Check this box to manage leads in this sales team.")
+    use_opportunities = fields.Boolean('Opportunities', default=True, help="Check this box to manage opportunities in this sales team.")
+    alias_id = fields.Many2one('mail.alias', string='Alias', ondelete="restrict", required=True, help="The email address associated with this team. New emails received will automatically create new leads assigned to the team.")
 
-    _defaults = {
-        'use_opportunities': True,
-    }
 
     def get_alias_model_name(self, vals):
         return 'crm.lead'
 
     def get_alias_values(self):
         has_group_use_lead = self.env['res.users'].has_group('crm.group_use_lead')
-        values = super(crm_team, self).get_alias_values()
+        values = super(Team, self).get_alias_values()
         values['alias_defaults'] = defaults = eval(self.alias_defaults or "{}")
         defaults['type'] = 'lead' if has_group_use_lead and self.use_leads else 'opportunity'
         defaults['team_id'] = self.id
         return values
 
-    def onchange_use_leads_opportunities(self, cr, uid, ids, use_leads, use_opportunities, context=None):
-        if use_leads or use_opportunities:
-            return {'value': {}}
-        return {'value': {'alias_name': False}}
+    @api.onchange('use_leads', 'use_opportunities')
+    def _onchange_use_leads_opportunities(self):
+        if not self.use_leads and not self.use_opportunities:
+            self.alias_name = False
 
-    def create(self, cr, uid, vals, context=None):
-        generate_alias_name = self.pool['ir.values'].get_default(cr, uid, 'sales.config.settings', 'generate_sales_team_alias')
+    @api.model
+    def create(self, vals):
+        generate_alias_name = self.env['ir.values'].get_default('sales.config.settings', 'generate_sales_team_alias')
         if generate_alias_name and not vals.get('alias_name'):
             vals['alias_name'] = vals.get('name')
-        return super(crm_team, self).create(cr, uid, vals, context=context)
+        return super(Team, self).create(vals)
 
-    def write(self, cr, uid, ids, vals, context=None):
-        res = super(crm_team, self).write(cr, uid, ids, vals, context=context)
+    @api.multi
+    def write(self, vals):
+        result = super(Team, self).write(vals)
         if vals.get('use_leads') or vals.get('alias_defaults'):
-            for team in self.browse(cr, uid, ids, context=context):
+            for team in self:
                 team.alias_id.write(team.get_alias_values())
-        return res
+        return result
 
-    def action_your_pipeline(self, cr, uid, context=None):
-        IrModelData = self.pool['ir.model.data']
-        action = IrModelData.xmlid_to_object(cr, uid, 'crm.crm_lead_opportunities_tree_view', context=context).read(['name', 'help', 'res_model', 'target', 'domain', 'context', 'type', 'search_view_id'])
-        if not action:
-            action = {}
-        else:
-            action = action[0]
-
-        user_team_id = self.pool['res.users'].browse(cr, uid, uid, context=context).sale_team_id.id
+    #TODO JEM : refactor this stuff with xml action, proper customization, ...
+    @api.model
+    def action_your_pipeline(self):
+        action = self.env.ref('crm.crm_lead_opportunities_tree_view').read()[0]
+        user_team_id = self.env.user.sale_team_id.id
         if not user_team_id:
-            user_team_id = self.search(cr, uid, [], context=context, limit=1)
-            user_team_id = user_team_id and user_team_id[0] or False
+            user_team_id = self.search([], limit=1).id
             action['help'] = """<p class='oe_view_nocontent_create'>Click here to add new opportunities</p><p>
     Looks like you are not a member of a sales team. You should add yourself
     as a member of one of the sales team.
@@ -69,15 +62,15 @@ class crm_team(osv.Model):
             if user_team_id:
                 action['help'] += "<p>As you don't belong to any sales team, Odoo opens the first one by default.</p>"
 
-        action_context = eval(action['context'], {'uid': uid})
+        action_context = eval(action['context'], {'uid': self.env.uid})
         if user_team_id:
             action_context.update({
                 'default_team_id': user_team_id,
             })
 
-        tree_view_id = IrModelData.xmlid_to_res_id(cr, uid, 'crm.crm_case_tree_view_oppor')
-        form_view_id = IrModelData.xmlid_to_res_id(cr, uid, 'crm.crm_case_form_view_oppor')
-        kanb_view_id = IrModelData.xmlid_to_res_id(cr, uid, 'crm.crm_case_kanban_view_leads')
+        tree_view_id = self.env.ref('crm.crm_case_tree_view_oppor').id
+        form_view_id = self.env.ref('crm.crm_case_form_view_oppor').id
+        kanb_view_id = self.env.ref('crm.crm_case_kanban_view_leads').id
         action.update({
             'views': [
                 [kanb_view_id, 'kanban'],

--- a/addons/crm/models/res_config.py
+++ b/addons/crm/models/res_config.py
@@ -1,71 +1,61 @@
 # -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
-from openerp import SUPERUSER_ID
-from openerp.osv import fields, osv
+from odoo import api, fields, models
 
 
-class crm_configuration(osv.TransientModel):
+class CRMSettings(models.TransientModel):
+
     _name = 'sale.config.settings'
     _inherit = ['sale.config.settings']
 
-    _columns = {
-        'generate_sales_team_alias': fields.boolean(
-            "Automatically generate an email alias at the sales team creation",
-            help="Odoo will generate an email alias based on the sales team name"),
-        'alias_prefix': fields.char('Default Alias Name for Leads'),
-        'alias_domain' : fields.char('Alias Domain'),
-        'group_use_lead': fields.selection([
-            (0, "Each mail sent to the alias creates a new opportunity"),
-            (1, "Use leads if you need a qualification step before creating an opportunity or a customer")
-            ], "Leads",
-            implied_group='crm.group_use_lead'),
-        'module_crm_voip': fields.boolean("VoIP integration",
-            help="Integration with Asterisk"),
-        'module_website_sign': fields.boolean("Odoo Sign"),
-    }
-
-    _defaults = {
-        'alias_domain': lambda self, cr, uid, context: self.pool["ir.config_parameter"].get_param(cr, uid, "mail.catchall.domain", context=context),
-    }
-
-    def _find_default_lead_alias_id(self, cr, uid, context=None):
-        alias_id = self.pool['ir.model.data'].xmlid_to_res_id(cr, uid, 'crm.mail_alias_lead_info')
-        if not alias_id:
-            alias_ids = self.pool['mail.alias'].search(
-                cr, uid, [
-                    ('alias_model_id.model', '=', 'crm.lead'),
-                    ('alias_force_thread_id', '=', False),
-                    ('alias_parent_model_id.model', '=', 'crm.team'),
-                    ('alias_parent_thread_id', '=', False),
-                    ('alias_defaults', '=', '{}')
-                ], context=context)
-            alias_id = alias_ids and alias_ids[0] or False
-        return alias_id
-
-    def get_default_generate_sales_team_alias(self, cr, uid, fields, context=None):
-        return {'generate_sales_team_alias': self.pool['ir.values'].get_default(
-            cr, uid, 'sales.config.settings', 'generate_sales_team_alias')}
-
-    def set_default_generate_sales_team_alias(self, cr, uid, ids, context=None):
-        config_value = self.browse(cr, uid, ids, context=context).generate_sales_team_alias
-        user_id = SUPERUSER_ID if self.user_has_groups(cr, uid, 'base.group_erp_manager') else uid
-        self.pool['ir.values'].set_default(cr, user_id, 'sales.config.settings', 'generate_sales_team_alias', config_value)
-
-    def get_default_alias_prefix(self, cr, uid, fields, context=None):
-        alias_name = False
-        alias_id = self._find_default_lead_alias_id(cr, uid, context=context)
-        if alias_id:
-            alias_name = self.pool['mail.alias'].browse(cr, uid, alias_id, context=context).alias_name
-        return {'alias_prefix': alias_name}
-
-    def set_default_alias_prefix(self, cr, uid, ids, context=None):
-        mail_alias = self.pool['mail.alias']
-        for record in self.browse(cr, uid, ids, context=context):
-            alias_id = self._find_default_lead_alias_id(cr, uid, context=context)
-            if not alias_id:
-                create_ctx = dict(context, alias_model_name='crm.lead', alias_parent_model_name='crm.team')
-                alias_id = self.pool['mail.alias'].create(cr, uid, {'alias_name': record.alias_prefix}, context=create_ctx)
+    generate_sales_team_alias = fields.Boolean("Automatically generate an email alias at the sales team creation",
+        help="Odoo will generate an email alias based on the sales team name")
+    alias_prefix = fields.Char('Default Alias Name for Leads')
+    alias_domain = fields.Char('Alias Domain', default=lambda self: self.env["ir.config_parameter"].get_param("mail.catchall.domain"))
+    group_use_lead = fields.Selection([
+        (0, "Each mail sent to the alias creates a new opportunity"),
+        (1, "Use leads if you need a qualification step before creating an opportunity or a customer")
+    ], string="Leads", implied_group='crm.group_use_lead')
+    module_crm_voip = fields.Boolean("VoIP integration", help="Integration with Asterisk")
+    module_website_sign = fields.Boolean("Odoo Sign")
+
+    def _find_default_lead_alias_id(self):
+        alias = self.env.ref('crm.mail_alias_lead_info', False)
+        if not alias:
+            alias = self.env['mail.alias'].search([
+                ('alias_model_id.model', '=', 'crm.lead'),
+                ('alias_force_thread_id', '=', False),
+                ('alias_parent_model_id.model', '=', 'crm.team'),
+                ('alias_parent_thread_id', '=', False),
+                ('alias_defaults', '=', '{}')
+            ], limit=1)
+        return alias
+
+    @api.model
+    def get_default_generate_sales_team_alias(self, fields):
+        return {
+            'generate_sales_team_alias': self.env['ir.values'].get_default('sales.config.settings', 'generate_sales_team_alias')
+        }
+
+    @api.multi
+    def set_default_generate_sales_team_alias(self):
+        IrValues = self.env['ir.values']
+        if self.env['res.users'].has_group('base.group_erp_manager'):
+            IrValues = IrValues.sudo()
+        IrValues.set_default('sales.config.settings', 'generate_sales_team_alias', self.generate_sales_team_alias)
+
+    @api.model
+    def get_default_alias_prefix(self, fields):
+        alias = self._find_default_lead_alias_id()
+        return {'alias_prefix': alias.alias_name if alias else False}
+
+    @api.multi
+    def set_default_alias_prefix(self):
+        for record in self:
+            alias = self._find_default_lead_alias_id()
+            if not alias:
+                alias = self.env['mail.alias'].with_context(alias_model_name='crm.lead', alias_parent_model_name='crm.team').create({'alias_name': record.alias_prefix})
             else:
-                mail_alias.write(cr, uid, alias_id, {'alias_name': record.alias_prefix}, context=context)
+                alias.write({'alias_name': record.alias_prefix})
         return True

--- a/addons/crm/models/res_partner.py
+++ b/addons/crm/models/res_partner.py
@@ -1,48 +1,44 @@
 # -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
-from openerp.osv import fields,osv
+from odoo import api, fields, models
+
+
+class Partner(models.Model):
 
-class res_partner(osv.osv):
-    """ Inherits partner and adds CRM information in the partner form """
     _inherit = 'res.partner'
 
-    def _opportunity_meeting_count(self, cr, uid, ids, field_name, arg, context=None):
-        res = dict(map(lambda x: (x,{'opportunity_count': 0, 'meeting_count': 0}), ids))
-        # the user may not have access rights for opportunities or meetings
+    team_id = fields.Many2one('crm.team', string='Sales Team', oldname='section_id')
+    opportunity_ids = fields.One2many('crm.lead', 'partner_id', string='Opportunities', domain=[('type', '=', 'opportunity')])
+    meeting_ids = fields.Many2many('calendar.event', 'calendar_event_res_partner_rel', 'res_partner_id', 'calendar_event_id', string='Meetings')
+    opportunity_count = fields.Integer("Opportunity", compute='_compute_opportunity_count')
+    meeting_count = fields.Integer("# Meetings", compute='_compute_meeting_count')
+    activities_count = fields.Integer("Activities", compute='_compute_activities_count')
+
+    @api.multi
+    def _compute_opportunity_count(self):
+        # TODO JEM : remove the try/except by putting a group on button
         try:
-            for partner in self.browse(cr, uid, ids, context):
-                if partner.is_company:
-                    operator = 'child_of'
-                else:
-                    operator = '='
-                opp_ids = self.pool['crm.lead'].search(cr, uid, [('partner_id', operator, partner.id), ('type', '=', 'opportunity')], context=context)
-                res[partner.id] = {
-                    'opportunity_count': len(opp_ids),
-                    'meeting_count': len(partner.meeting_ids),
-                }
+            for partner in self:
+                operator = 'child_of' if partner.is_company else '='  # the opportunity count should counts the opportunities of this company and all its contacts
+                partner.opportunity_count = self.env['crm.lead'].search_count([('partner_id', operator, partner.id), ('type', '=', 'opportunity')])
         except:
             pass
-        return res
 
-    def _compute_activities_count(self, cr, uid, ids, field_name, arg, context=None):
-        res = dict.fromkeys(ids, None)
-        activities = self.pool['crm.activity.report'].read_group(cr, uid, [('partner_id', 'in', ids)], ['partner_id'], ['partner_id'], context=context)
-        for activity in activities:
-            res[activity['partner_id'][0]] = activity['partner_id_count']
-        return res
+    @api.multi
+    def _compute_meeting_count(self):
+        for partner in self:
+            partner.meeting_count = len(partner.meeting_ids)
 
-    _columns = {
-        'team_id': fields.many2one('crm.team', 'Sales Team', oldname='section_id'),
-        'opportunity_ids': fields.one2many('crm.lead', 'partner_id',\
-            'Opportunities', domain=[('type', '=', 'opportunity')]),
-        'meeting_ids': fields.many2many('calendar.event', 'calendar_event_res_partner_rel','res_partner_id', 'calendar_event_id',
-            'Meetings'),
-        'opportunity_count': fields.function(_opportunity_meeting_count, string="Opportunity", type='integer', multi='opp_meet'),
-        'meeting_count': fields.function(_opportunity_meeting_count, string="# Meetings", type='integer', multi='opp_meet'),
-        'activities_count': fields.function(_compute_activities_count, string="Activities", type="integer"),
-    }
+    @api.multi
+    def _compute_activities_count(self):
+        activity_data = self.env['crm.activity.report'].read_group([('partner_id', 'in', self.ids)], ['partner_id'], ['partner_id'])
+        mapped_data = {act['partner_id'][0]: act['partner_id_count'] for act in activity_data}
+        for partner in self:
+            partner.activities_count = mapped_data.get(partner.id, 0)
 
+    # TODO JEM : it is still used ?
+    @api.v7
     def redirect_partner_form(self, cr, uid, partner_id, context=None):
         search_view = self.pool.get('ir.model.data').get_object_reference(cr, uid, 'base', 'view_res_partner_filter')
         value = {
@@ -58,6 +54,8 @@ class res_partner(osv.osv):
         }
         return value
 
+    # TODO JEM : it is still used ?
+    @api.v7
     def make_opportunity(self, cr, uid, ids, opportunity_summary, planned_revenue=0.0, probability=0.0, partner_id=None, context=None):
         lead_obj = self.pool.get('crm.lead')
         tag_ids = self.pool['crm.lead.tag'].search(cr, uid, [])
@@ -76,12 +74,13 @@ class res_partner(osv.osv):
             opportunity_ids[partner_id] = opportunity_id
         return opportunity_ids
 
-    def schedule_meeting(self, cr, uid, ids, context=None):
-        partner_ids = list(ids)
-        partner_ids.append(self.pool.get('res.users').browse(cr, uid, uid).partner_id.id)
-        res = self.pool.get('ir.actions.act_window').for_xml_id(cr, uid, 'calendar', 'action_calendar_event', context)
-        res['context'] = {
-            'search_default_partner_ids': context['partner_name'],
+    @api.multi
+    def schedule_meeting(self):
+        partner_ids = self.ids
+        partner_ids.append(self.env.user.partner_id.id)
+        action = self.env['ir.actions.act_window'].for_xml_id('calendar', 'action_calendar_event')
+        action['context'] = {
+            'search_default_partner_ids': self._context['partner_name'],
             'default_partner_ids': partner_ids,
         }
-        return res
+        return action

--- a/addons/crm/models/res_users.py
+++ b/addons/crm/models/res_users.py
@@ -1,11 +1,12 @@
 # -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
 
-from openerp.osv import osv, fields
+from odoo import fields, models
 
 
-class res_users(osv.osv):
+class Users(models.Model):
+
     _inherit = 'res.users'
-    _columns = {
-        'target_sales_won': fields.integer('Won in Opportunities Target'),
-        'target_sales_done': fields.integer('Activities Done Target'),
-    }
+
+    target_sales_won = fields.Integer('Won in Opportunities Target')
+    target_sales_done = fields.Integer('Activities Done Target')

--- a/addons/crm/models/web_planner.py
+++ b/addons/crm/models/web_planner.py
@@ -1,5 +1,7 @@
 # -*- coding: utf-8 -*-
-from openerp import api, models
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from odoo import api, models
 
 
 class PlannerCrm(models.Model):
