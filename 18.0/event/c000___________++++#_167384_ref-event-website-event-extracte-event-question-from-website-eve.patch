PR: https://github.com/odoo/odoo/pull/167384

From: 5a4554520e616efdd9f32f2884958b8d562d4d90
From: David Monnom (moda)
Date: 2024-06-11 07:23:30

Structural Changes: 24
Total Changes: 182

[REF] event, website_event: extracte event_question from website_event

In order to use custom questions on events and event registrations
without having to install the website_* module suite, this commit
extracts this functionality from the website_event module to event.

Part-of: odoo/odoo#167384
Related: odoo/upgrade#6094
Signed-off-by: Thibault Delavallee (tde) <tde@openerp.com>

================================= pseudo patch: =================================

--- a/addons/event/models/__init__.py
+++ b/addons/event/models/__init__.py
@@ -10,3 +10,6 @@ from . import event_ticket
 from . import mail_template
 from . import res_config_settings
 from . import res_partner
+from . import event_question_answer
+from . import event_registration_answer
+from . import event_question

--- a/addons/event/models/event_event.py
+++ b/addons/event/models/event_event.py
@@ -52,6 +52,13 @@ class EventType(models.Model):
                   'template_ref': 'mail.template, %i' % self.env.ref('event.event_reminder').id,
                  })]
 
+    def _default_question_ids(self):
+        return [
+            (0, 0, {'title': _('Name'), 'question_type': 'name', 'is_mandatory_answer': True}),
+            (0, 0, {'title': _('Email'), 'question_type': 'email', 'is_mandatory_answer': True}),
+            (0, 0, {'title': _('Phone'), 'question_type': 'phone'}),
+        ]
+
     name = fields.Char('Event Template', required=True, translate=True)
     note = fields.Html(string='Note')
     sequence = fields.Integer(default=10)
@@ -73,6 +80,9 @@ class EventType(models.Model):
     # ticket reports
     ticket_instructions = fields.Html('Ticket Instructions', translate=True,
         help="This information will be printed on your tickets.")
+    question_ids = fields.One2many(
+        'event.question', 'event_type_id', default=_default_question_ids,
+        string='Questions', copy=True)
 
     @api.depends('has_seats_limitation')
     def _compute_seats_max(self):
@@ -114,6 +124,9 @@ class EventEvent(models.Model):
     def _lang_get(self):
         return self.env['res.lang'].get_installed()
 
+    def _default_question_ids(self):
+        return self.env['event.type']._default_question_ids()
+
     name = fields.Char(string='Event', translate=True, required=True)
     note = fields.Html(string='Note', store=True, compute="_compute_note", readonly=False)
     description = fields.Html(string='Description', translate=html_translate, sanitize_attributes=False, sanitize_form=False, default=_default_description)
@@ -230,12 +243,56 @@ class EventEvent(models.Model):
     ticket_instructions = fields.Html('Ticket Instructions', translate=True,
         compute='_compute_ticket_instructions', store=True, readonly=False,
         help="This information will be printed on your tickets.")
+    # questions
+    question_ids = fields.One2many(
+        'event.question', 'event_id', 'Questions', copy=True,
+        compute='_compute_question_ids', readonly=False, store=True)
+    general_question_ids = fields.One2many('event.question', 'event_id', 'General Questions',
+                                           domain=[('once_per_order', '=', True)])
+    specific_question_ids = fields.One2many('event.question', 'event_id', 'Specific Questions',
+                                            domain=[('once_per_order', '=', False)])
 
     def _compute_use_barcode(self):
         use_barcode = self.env['ir.config_parameter'].sudo().get_param('event.use_event_barcode') == 'True'
         for record in self:
             record.use_barcode = use_barcode
 
+    @api.depends('event_type_id')
+    def _compute_question_ids(self):
+        """ Update event questions from its event type. Depends are set only on
+        event_type_id itself to emulate an onchange. Changing event type content
+        itself should not trigger this method.
+
+        When synchronizing questions:
+
+          * lines with no registered answers are removed;
+          * type lines are added;
+        """
+        if self._origin.question_ids:
+            # lines to keep: those with already given answers
+            questions_tokeep_ids = self.env['event.registration.answer'].search(
+                [('question_id', 'in', self._origin.question_ids.ids)]
+            ).question_id.ids
+        else:
+            questions_tokeep_ids = []
+        for event in self:
+            if not event.event_type_id and not event.question_ids:
+                event.question_ids = self._default_question_ids()
+                continue
+
+            if questions_tokeep_ids:
+                questions_toremove = event._origin.question_ids.filtered(
+                    lambda question: question.id not in questions_tokeep_ids)
+                command = [(3, question.id) for question in questions_toremove]
+            else:
+                command = [(5, 0)]
+            event.question_ids = command
+
+            # copy questions so changes in the event don't affect the event type
+            event.question_ids += event.event_type_id.question_ids.copy({
+                'event_type_id': False,
+            })
+
     @api.depends('stage_id', 'kanban_state')
     def _compute_kanban_state_label(self):
         for event in self:

--- a/None
+++ b/addons/event/models/event_question.py
@@ -0,0 +1,65 @@
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from odoo import api, fields, models, _
+from odoo.exceptions import UserError
+
+
+class EventQuestion(models.Model):
+    _name = 'event.question'
+    _rec_name = 'title'
+    _order = 'sequence,id'
+    _description = 'Event Question'
+
+    title = fields.Char(required=True, translate=True)
+    question_type = fields.Selection([
+        ('simple_choice', 'Selection'),
+        ('text_box', 'Text Input'),
+        ('name', 'Name'),
+        ('email', 'Email'),
+        ('phone', 'Phone'),
+        ('company_name', 'Company'),
+    ], default='simple_choice', string="Question Type", required=True)
+    event_type_id = fields.Many2one('event.type', 'Event Type', ondelete='cascade')
+    event_id = fields.Many2one('event.event', 'Event', ondelete='cascade')
+    answer_ids = fields.One2many('event.question.answer', 'question_id', "Answers", copy=True)
+    sequence = fields.Integer(default=10)
+    once_per_order = fields.Boolean('Ask once per order',
+                                    help="If True, this question will be asked only once and its value will be propagated to every attendees."
+                                         "If not it will be asked for every attendee of a reservation.")
+    is_mandatory_answer = fields.Boolean('Mandatory Answer')
+
+    @api.constrains('event_type_id', 'event_id')
+    def _constrains_event(self):
+        if any(question.event_type_id and question.event_id for question in self):
+            raise UserError(_("Question cannot be linked to both an Event and an Event Type."))
+
+    def write(self, vals):
+        """ We add a check to prevent changing the question_type of a question that already has answers.
+        Indeed, it would mess up the event.registration.answer (answer type not matching the question type). """
+
+        if 'question_type' in vals:
+            questions_new_type = self.filtered(lambda question: question.question_type != vals['question_type'])
+            if questions_new_type:
+                answer_count = self.env['event.registration.answer'].search_count([('question_id', 'in', questions_new_type.ids)])
+                if answer_count > 0:
+                    raise UserError(_("You cannot change the question type of a question that already has answers!"))
+        return super().write(vals)
+
+    @api.ondelete(at_uninstall=False)
+    def _unlink_except_answered_question(self):
+        if self.env['event.registration.answer'].search_count([('question_id', 'in', self.ids)]):
+            raise UserError(_('You cannot delete a question that has already been answered by attendees.'))
+
+    def action_view_question_answers(self):
+        """ Allow analyzing the attendees answers to event questions in a convenient way:
+        - A graph view showing counts of each suggestions for simple_choice questions
+          (Along with secondary pivot and tree views)
+        - A tree view showing textual answers values for text_box questions. """
+        self.ensure_one()
+        action = self.env["ir.actions.actions"]._for_xml_id("event.action_event_registration_report")
+        action['domain'] = [('question_id', '=', self.id)]
+        if self.question_type == 'simple_choice':
+            action['views'] = [(False, 'graph'), (False, 'pivot'), (False, 'tree')]
+        elif self.question_type == 'text_box':
+            action['views'] = [(False, 'tree')]
+        return action

--- a/None
+++ b/addons/event/models/event_question_answer.py
@@ -0,0 +1,21 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from odoo import api, fields, models, _
+from odoo.exceptions import UserError
+
+
+class EventQuestionAnswer(models.Model):
+    """ Contains suggested answers to a 'simple_choice' event.question. """
+    _name = 'event.question.answer'
+    _order = 'sequence,id'
+    _description = 'Event Question Answer'
+
+    name = fields.Char('Answer', required=True, translate=True)
+    question_id = fields.Many2one('event.question', required=True, ondelete='cascade')
+    sequence = fields.Integer(default=10)
+
+    @api.ondelete(at_uninstall=False)
+    def _unlink_except_selected_answer(self):
+        if self.env['event.registration.answer'].search_count([('value_answer_id', 'in', self.ids)]):
+            raise UserError(_('You cannot delete an answer that has already been selected by attendees.'))

--- a/addons/event/models/event_registration.py
+++ b/addons/event/models/event_registration.py
@@ -72,6 +72,10 @@ class EventRegistration(models.Model):
              'Registered: registrations considered taken by a client\n'
              'Attended: registrations for which the attendee attended the event\n'
              'Cancelled: registrations cancelled manually')
+    # questions
+    registration_answer_ids = fields.One2many('event.registration.answer', 'registration_id', string='Attendee Answers')
+    registration_answer_choice_ids = fields.One2many('event.registration.answer', 'registration_id', string='Attendee Selection Answers',
+        domain=[('question_type', '=', 'simple_choice')])
     # properties
     registration_properties = fields.Properties(
         'Properties', definition='event_id.registration_properties_definition', copy=True)
@@ -411,5 +415,6 @@ class EventRegistration(models.Model):
             'ticket_name': self.event_ticket_id.name or _('None'),
             'event_id': self.event_id.id,
             'event_display_name': self.event_id.display_name,
+            'registration_answers': self.registration_answer_ids.filtered('value_answer_id').mapped('display_name'),
             'company_name': self.event_id.company_id and self.event_id.company_id.name or False,
         }

--- a/None
+++ b/addons/event/models/event_registration_answer.py
@@ -0,0 +1,31 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from odoo import api, fields, models
+
+
+class EventRegistrationAnswer(models.Model):
+    """ Represents the user input answer for a single event.question """
+    _name = 'event.registration.answer'
+    _description = 'Event Registration Answer'
+    _rec_names_search = ['value_answer_id', 'value_text_box']
+
+    question_id = fields.Many2one(
+        'event.question', ondelete='restrict', required=True,
+        domain="[('event_id', '=', event_id)]")
+    registration_id = fields.Many2one('event.registration', required=True, ondelete='cascade')
+    partner_id = fields.Many2one('res.partner', related='registration_id.partner_id')
+    event_id = fields.Many2one('event.event', related='registration_id.event_id')
+    question_type = fields.Selection(related='question_id.question_type')
+    value_answer_id = fields.Many2one('event.question.answer', string="Suggested answer")
+    value_text_box = fields.Text('Text answer')
+
+    _sql_constraints = [
+        ('value_check', "CHECK(value_answer_id IS NOT NULL OR COALESCE(value_text_box, '') <> '')", "There must be a suggested value or a text value.")
+    ]
+
+    # for displaying selected answers by attendees in attendees list view
+    @api.depends('value_answer_id', 'question_type', 'value_text_box')
+    def _compute_display_name(self):
+        for reg in self:
+            reg.display_name = reg.value_answer_id.name if reg.question_type == "simple_choice" else reg.value_text_box
