PR: https://github.com/odoo/odoo/pull/30028

From: 855c6dac25fccaf9312543022001ed0b360d6e13
From: RomainLibert
Date: 2019-01-18 15:33:04

Structural Changes: 92
Total Changes: 845

[IMP] lunch: automatize lunch orders

We would like to automatize lunch as currently all orders are manually ordered and validated,
and a cash move has to be manually created each time you want to credit the wallet of some user.

1/ In this commit we add a new widget that comes with the kanban view
   and will allow to take orders in a friendly manner.
2/ We also add a lunch.supplier model this also allows you to configure an
   automatic ordering via email.
3/ Introduces new lunch.location model to replace res.partner on suppliers
4/ New mail template for automatic ordering
5/ Add the concept of new products (mark a product as new until some date)
6/ The toppings are now defined by product category
7/ Lunch.order removed, lunch.order.line renamed into lunch.order
8/ New SQL report to get the wallet content (aggregate of lunch.cashmove and lunch.order)
9/ New setting to allow negative wallet (aka overdraft)
10/ Application now remembers what notes and toppings you last ordered with your product
11/ You can change your location using the widget on the kanban view
12/ Edition of the order can be done until the order is arrived

TaskID: 1856876
TaskID: 1916105

closes odoo/odoo#30028

================================= pseudo patch: =================================

--- a/addons/lunch/models/__init__.py
+++ b/addons/lunch/models/__init__.py
@@ -1,6 +1,12 @@
 # -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
 
 from . import lunch_alert
 from . import lunch_cashmove
+from . import lunch_location
 from . import lunch_order
 from . import lunch_product
+from . import lunch_supplier
+from . import res_company
+from . import res_config_settings
+from . import res_users

--- a/addons/lunch/models/lunch_alert.py
+++ b/addons/lunch/models/lunch_alert.py
@@ -1,10 +1,11 @@
 # -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
-import datetime
+from odoo import api, fields, models
+from odoo.osv import expression
 
-from odoo import api, fields, models, _
 
+WEEKDAY_TO_NAME = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday']
 
 class LunchAlert(models.Model):
     """ Alerts to display during a lunch order. An alert can be specific to a
@@ -13,73 +14,46 @@ class LunchAlert(models.Model):
     _description = 'Lunch Alert'
     _rec_name = 'message'
 
-    display = fields.Boolean(compute='_compute_display_get')
-    message = fields.Text('Message', required=True)
-    alert_type = fields.Selection([('specific', 'Specific Day'),
-                                   ('week', 'Every Week'),
-                                   ('days', 'Every Day')],
-                                  string='Recurrence', required=True, index=True, default='specific')
-    partner_id = fields.Many2one('res.partner', string="Vendor",
-                                 help="If specified, the selected vendor can be ordered only on selected days")
-    specific_day = fields.Date('Day', default=fields.Date.context_today)
-    monday = fields.Boolean('Monday')
-    tuesday = fields.Boolean('Tuesday')
-    wednesday = fields.Boolean('Wednesday')
-    thursday = fields.Boolean('Thursday')
-    friday = fields.Boolean('Friday')
-    saturday = fields.Boolean('Saturday')
-    sunday = fields.Boolean('Sunday')
-    start_hour = fields.Float('Between', oldname='active_from', required=True, default=7)
-    end_hour = fields.Float('And', oldname='active_to', required=True, default=23)
-    active = fields.Boolean(default=True)
+    message = fields.Html('Message', required=True)
 
-    @api.multi
-    def name_get(self):
-        return [(alert.id, '%s %s' % (_('Alert'), '#%d' % alert.id)) for alert in self]
+    until = fields.Date('Show Until')
+    recurrency_monday = fields.Boolean('Monday')
+    recurrency_tuesday = fields.Boolean('Tuesday')
+    recurrency_wednesday = fields.Boolean('Wednesday')
+    recurrency_thursday = fields.Boolean('Thursday')
+    recurrency_friday = fields.Boolean('Friday')
+    recurrency_saturday = fields.Boolean('Saturday')
+    recurrency_sunday = fields.Boolean('Sunday')
 
-    @api.depends('alert_type', 'specific_day', 'monday', 'tuesday', 'thursday',
-                 'friday', 'saturday', 'sunday', 'start_hour', 'end_hour')
-    def _compute_display_get(self):
-        """
-        This method check if the alert can be displayed today
-        if alert type is specific : compare specific_day(date) with today's date
-        if alert type is week : check today is set as alert (checkbox true) eg. self['monday']
-        if alert type is day : True
-        return : Message if can_display_alert is True else False
-        """
-        days_codes = {'0': 'sunday',
-                      '1': 'monday',
-                      '2': 'tuesday',
-                      '3': 'wednesday',
-                      '4': 'thursday',
-                      '5': 'friday',
-                      '6': 'saturday'}
-        fullday = False
-        now = datetime.datetime.now()
-        if self.env.context.get('lunch_date'):
-            # lunch_date is a fields.Date -> 00:00:00
-            lunch_date = fields.Datetime.from_string(self.env.context['lunch_date'])
-            # if lunch_date is in the future, planned lunch, ignore hours
-            fullday = lunch_date > now
-            now = max(lunch_date, now)
-        mynow = fields.Datetime.context_timestamp(self, now)
+    available_today = fields.Boolean('Is Displayed Today',
+                                     compute='_compute_available_today', search='_search_available_today')
 
-        for alert in self:
-            can_display_alert = {
-                'specific': (str(alert.specific_day) == fields.Date.to_string(mynow)),
-                'week': alert[days_codes[mynow.strftime('%w')]],
-                'days': True
-            }
+    active = fields.Boolean(default=True)
 
-            if can_display_alert[alert.alert_type]:
-                hour_to = int(alert.end_hour)
-                min_to = int((alert.end_hour - hour_to) * 60)
-                to_alert = datetime.time(hour_to, min_to)
-                hour_from = int(alert.start_hour)
-                min_from = int((alert.start_hour - hour_from) * 60)
-                from_alert = datetime.time(hour_from, min_from)
+    location_ids = fields.Many2many('lunch.location', string='Location')
 
-                if fullday or (from_alert <= mynow.time() <= to_alert):
-                    alert.display = True
-                else:
-                    alert.display = False
+    @api.depends('recurrency_monday', 'recurrency_tuesday', 'recurrency_wednesday',
+                 'recurrency_thursday', 'recurrency_friday', 'recurrency_saturday',
+                 'recurrency_sunday')
+    def _compute_available_today(self):
+        today = fields.Date.context_today(self)
+        fieldname = 'recurrency_%s' % (WEEKDAY_TO_NAME[today.weekday()])
+
+        for alert in self:
+            alert.available_today = alert.until > today if alert.until else True and alert[fieldname]
+
+    def _search_available_today(self, operator, value):
+        if (not operator in ['=', '!=']) or (not value in [True, False]):
+            return []
+
+        searching_for_true = (operator == '=' and value) or (operator == '!=' and not value)
+        today = fields.Date.context_today(self)
+        fieldname = 'recurrency_%s' % (WEEKDAY_TO_NAME[today.weekday()])
+
+        return expression.AND([
+            [(fieldname, operator, value)],
+            expression.OR([
+                [('until', '=', False)],
+                [('until', '>' if searching_for_true else '<', today)],
+            ])
+        ])

--- a/addons/lunch/models/lunch_cashmove.py
+++ b/addons/lunch/models/lunch_cashmove.py
@@ -2,22 +2,30 @@
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
 from odoo import api, fields, models, _
+from odoo.tools import float_round
 
 
 class LunchCashMove(models.Model):
     """ Two types of cashmoves: payment (credit) or order (debit) """
     _name = 'lunch.cashmove'
     _description = 'Lunch Cashmove'
+    _order = 'date desc'
 
+    currency_id = fields.Many2one('res.currency', default=lambda self: self.env['res.company']._company_default_get())
     user_id = fields.Many2one('res.users', 'User',
                               default=lambda self: self.env.uid)
     date = fields.Date('Date', required=True, default=fields.Date.context_today)
-    amount = fields.Float('Amount', required=True, help='Can be positive (payment) or negative (order or payment if user wants to get his money back)')
-    description = fields.Text('Description', help='Can be an order or a payment')
-    order_id = fields.Many2one('lunch.order.line', 'Order', ondelete='cascade')
-    state = fields.Selection([('order', 'Order'), ('payment', 'Payment')],
-                             'Is an order or a payment', default='payment')
+    amount = fields.Float('Amount', required=True)
+    description = fields.Text('Description')
 
     @api.multi
     def name_get(self):
         return [(cashmove.id, '%s %s' % (_('Lunch Cashmove'), '#%d' % cashmove.id)) for cashmove in self]
+
+    @api.model
+    def get_wallet_balance(self, user, include_config=True):
+        result = float_round(sum(move['amount'] for move in self.env['lunch.cashmove.report'].search_read(
+            [('user_id', '=', user.id)], ['amount'])), precision_digits=2)
+        if include_config:
+            result += user.company_id.lunch_minimum_threshold
+        return result

--- a/None
+++ b/addons/lunch/models/lunch_location.py
@@ -0,0 +1,12 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from odoo import fields, models
+
+
+class LunchLocation(models.Model):
+    _name = 'lunch.location'
+    _description = 'Lunch Locations'
+
+    name = fields.Char('Location Name')
+    address = fields.Text('Address')

--- a/addons/lunch/models/lunch_order.py
+++ b/addons/lunch/models/lunch_order.py
@@ -1,315 +1,79 @@
 # -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
-from collections import OrderedDict
-
-import json
-
 from odoo import api, fields, models, _
-from odoo.exceptions import AccessError, ValidationError
+from odoo.exceptions import ValidationError
 from odoo.addons import decimal_precision as dp
 
 
 class LunchOrder(models.Model):
-    """
-    A lunch order contains one or more lunch order line(s). It is associated to a user for a given
-    date. When creating a lunch order, applicable lunch alerts are displayed.
-    """
     _name = 'lunch.order'
     _description = 'Lunch Order'
-    _order = 'date desc'
-
-    def _default_previous_order_ids(self):
-        prev_order = self.env['lunch.order.line'].search([('user_id', '=', self.env.uid), ('product_id.active', '!=', False)], limit=20, order='id desc')
-        # If we return return prev_order.ids, we will have duplicates (identical orders).
-        # Therefore, this following part removes duplicates based on product_id and note.
-        return list({
-            (order.product_id, order.note): order.id
-            for order in prev_order
-        }.values())
-
+    _order = 'id desc'
+    _display_name = 'product_id'
+
+    name = fields.Char(related='product_id.name', string="Product Name", readonly=True)  # to remove
+    topping_ids_1 = fields.Many2many('lunch.topping', 'lunch_order_topping', 'order_id', 'topping_id', string='Toppings 1', domain=[('topping_category', '=', 1)])
+    topping_ids_2 = fields.Many2many('lunch.topping', 'lunch_order_topping', 'order_id', 'topping_id', string='Toppings 2', domain=[('topping_category', '=', 2)])
+    topping_ids_3 = fields.Many2many('lunch.topping', 'lunch_order_topping', 'order_id', 'topping_id', string='Toppings 3', domain=[('topping_category', '=', 3)])
+    product_id = fields.Many2one('lunch.product', string="Product", required=True)
+    category_id = fields.Many2one('lunch.product.category', string='Product Category',
+                                  related='product_id.category_id', readonly=True, store=True)
+    date = fields.Date('Order Date', required=True, readonly=True,
+                       states={'new': [('readonly', False)]},
+                       default=fields.Date.context_today)
+    supplier_id = fields.Many2one('lunch.supplier', string='Vendor', related='product_id.supplier_id',
+                               readonly=True, store=True, index=True)
     user_id = fields.Many2one('res.users', 'User', readonly=True,
                               states={'new': [('readonly', False)]},
                               default=lambda self: self.env.uid)
-    date = fields.Date('Date', required=True, readonly=True,
-                       states={'new': [('readonly', False)]},
-                       default=fields.Date.context_today)
-    order_line_ids = fields.One2many('lunch.order.line', 'order_id', 'Products',
-                                     readonly=True, copy=True,
-                                     states={'new': [('readonly', False)], False: [('readonly', False)]})
-    total = fields.Float(compute='_compute_total', string="Total", store=True)
-    state = fields.Selection([('new', 'New'),
-                              ('confirmed', 'Received'),
-                              ('cancelled', 'Cancelled')],
-                             'Status', readonly=True, index=True, copy=False,
-                             compute='_compute_order_state', store=True)
-    alerts = fields.Text(compute='_compute_alerts_get', string="Alerts")
-    company_id = fields.Many2one('res.company', related='user_id.company_id', store=True, readonly=False)
-    currency_id = fields.Many2one('res.currency', related='company_id.currency_id', readonly=True, store=True)
-    cash_move_balance = fields.Monetary(compute='_compute_cash_move_balance', multi='cash_move_balance')
-    balance_visible = fields.Boolean(compute='_compute_cash_move_balance', multi='cash_move_balance')
-    previous_order_ids = fields.Many2many('lunch.order.line', compute='_compute_previous_order')
-    previous_order_widget = fields.Text(compute='_compute_previous_order')
-
-    @api.one
-    @api.depends('order_line_ids')
-    def _compute_total(self):
-        """
-        get and sum the order lines' price
-        """
-        self.total = sum(
-            orderline.price for orderline in self.order_line_ids)
-
-    @api.multi
-    def name_get(self):
-        return [(order.id, '%s %s' % (_('Lunch Order'), '#%d' % order.id)) for order in self]
-
-    @api.depends('state')
-    def _compute_alerts_get(self):
-        """
-        get the alerts to display on the order form
-        """
-        alert_msg = [alert.message
-                     for alert in self.env['lunch.alert'].search([])
-                     if alert.display]
-
-        if self.state == 'new':
-            self.alerts = alert_msg and '\n'.join(alert_msg) or False
-
-    @api.multi
-    @api.depends('user_id', 'state')
-    def _compute_previous_order(self):
-        self.ensure_one()
-        self.previous_order_widget = json.dumps(False)
-
-        prev_order = self.env['lunch.order.line'].search([('user_id', '=', self.env.uid), ('product_id.active', '!=', False)], limit=20, order='date desc, id desc')
-        # If we use prev_order.ids, we will have duplicates (identical orders).
-        # Therefore, this following part removes duplicates based on product_id and note.
-        self.previous_order_ids = list({
-            (order.product_id, order.note): order.id
-            for order in prev_order
-        }.values())
-
-        if self.previous_order_ids:
-            lunch_data = {}
-            for line in self.previous_order_ids:
-                lunch_data[line.id] = {
-                    'line_id': line.id,
-                    'product_id': line.product_id.id,
-                    'product_name': line.product_id.name,
-                    'supplier': line.supplier.name,
-                    'note': line.note,
-                    'price': line.price,
-                    'date': fields.Date.to_string(line.date),
-                    'currency_id': line.currency_id.id,
-                }
-            # sort the old lunch orders by (date, id)
-            lunch_data = OrderedDict(sorted(lunch_data.items(), key=lambda t: (t[1]['date'], t[0]), reverse=True))
-            self.previous_order_widget = json.dumps(lunch_data)
-
-    @api.one
-    @api.depends('user_id')
-    def _compute_cash_move_balance(self):
-        domain = [('user_id', '=', self.user_id.id)]
-        lunch_cash = self.env['lunch.cashmove'].read_group(domain, ['amount', 'user_id'], ['user_id'])
-        if len(lunch_cash):
-            self.cash_move_balance = lunch_cash[0]['amount']
-        self.balance_visible = (self.user_id == self.env.user) or self.user_has_groups('lunch.group_lunch_manager')
-
-    @api.one
-    @api.constrains('date')
-    def _check_date(self):
-        """
-        Prevents the user to create an order in the past
-        """
-        date_order = self.date
-        date_today = fields.Date.context_today(self)
-        if date_order < date_today:
-            raise ValidationError(_('The date of your order is in the past.'))
-
-    @api.one
-    @api.depends('order_line_ids.state')
-    def _compute_order_state(self):
-        """
-        Update the state of lunch.order based on its orderlines. Here is the logic:
-        - if at least one order line is cancelled, the order is set as cancelled
-        - if no line is cancelled but at least one line is not confirmed, the order is set as new
-        - if all lines are confirmed, the order is set as confirmed
-        """
-        if not self.order_line_ids:
-            self.state = 'new'
-        else:
-            isConfirmed = True
-            for orderline in self.order_line_ids:
-                if orderline.state == 'cancelled':
-                    self.state = 'cancelled'
-                    return
-                elif orderline.state == 'confirmed':
-                    continue
-                else:
-                    isConfirmed = False
-
-            if isConfirmed:
-                self.state = 'confirmed'
-            else:
-                self.state = 'new'
-        return
-
-
-class LunchOrderLine(models.Model):
-    _name = 'lunch.order.line'
-    _description = 'Lunch Order Line'
-    _order = 'date desc, id desc'
-
-    name = fields.Char(related='product_id.name', string="Product Name", readonly=True)
-    order_id = fields.Many2one('lunch.order', 'Order', ondelete='cascade', required=True)
-    product_id = fields.Many2one('lunch.product', 'Product', required=True,
-                                 domain=[('available', '=', True)])
-    category_id = fields.Many2one('lunch.product.category', string='Product Category',
-                                  related='product_id.category_id', readonly=True, store=True)
-    date = fields.Date(string='Date', related='order_id.date', readonly=True, store=True)
-    supplier = fields.Many2one('res.partner', string='Vendor', related='product_id.supplier',
-                               readonly=True, store=True)
-    user_id = fields.Many2one('res.users', string='User', related='order_id.user_id',
-                              readonly=True, store=True)
-    note = fields.Text('Note')
-    price = fields.Float(related='product_id.price', readonly=True, store=True,
+    note = fields.Text('Notes')
+    price = fields.Float('Total Price', compute='_compute_total_price', readonly=True, store=True,
                          digits=dp.get_precision('Account'))
-    state = fields.Selection([('new', 'New'),
-                              ('confirmed', 'Received'),
+    active = fields.Boolean('Active', default=True)
+    state = fields.Selection([('new', 'To Order'),
                               ('ordered', 'Ordered'),
+                              ('confirmed', 'Received'),
                               ('cancelled', 'Cancelled')],
                              'Status', readonly=True, index=True, default='new')
-    cashmove = fields.One2many('lunch.cashmove', 'order_id', 'Cash Move')
-    currency_id = fields.Many2one('res.currency', related='order_id.currency_id', readonly=False)
-
-    def _check_supplier_availibility(self):
-        products = self.mapped('product_id')
-        if not all(product.available for product in products):
-            supplier_name = ", ".join(product.supplier.display_name for product in products if not product.available)
-            raise ValidationError(_("Vendor(s) '%s' is not available today") % supplier_name)
-
-    @api.model
-    def create(self, vals):
-        """ Override as an onchange would not apply if using the history buttons """
-        res = super(LunchOrderLine, self).create(vals)
-        res.with_context(lunch_date=res.order_id.date)._check_supplier_availibility()
-        return res
-
-    @api.model
-    def write(self, vals):
-        """ Override as an onchange would not apply if using the history buttons """
-        res = super(LunchOrderLine, self).write(vals)
-        if vals.get('product_id'):
-            for line in self:
-                line.with_context(lunch_date=line.order_id.date)._check_supplier_availibility()
-        return res
-
-    def order(self):
-        """
-        The order_line is ordered to the vendor but isn't received yet
-        """
-        if self.user_has_groups("lunch.group_lunch_manager"):
-            self.write({'state': 'ordered'})
-
-            order = {
-                'supplier': False,
-                'company': False,
-                'currency': False,
-            }
-            group_lines = {}
-            for line in self:
-                if not line.supplier:
-                    # do not send emails for products with no suppliers
-                    continue
-
-                if order['supplier'] and line.supplier != order['supplier']:
-                    raise ValidationError(_("Validate order for one supplier at a time to send emails (mixed orders from %s and %s)") % (
-                                            order['supplier'].display_name, line.supplier.display_name))
-                order['supplier'] = line.supplier
-
-                if order['company'] and line.order_id.company_id != order['company']:
-                    raise ValidationError(_("Validate order for one company at a time to send emails (mixed orders from %s and %s)") % (
-                                            order['company'].name, line.order_id.company_id.name))
-                order['company'] = line.order_id.company_id
-
-                if order['currency'] and line.currency_id != order['currency']:
-                    raise ValidationError(_("Validate order for one currency at a time to send emails (mixed orders from %s and %s)") % (
-                                            order['currency'].name, line.currency_id.name))
-                order['currency'] = line.currency_id
-
-                # group the order by products and note
-                key = (line.product_id, line.note)
-                group_lines.setdefault(key, 0)
-                group_lines[key] += 1
-
-            order['company_name'] = order['company'].name
-            order['currency_id'] = order['currency'].id
-            order['supplier_id'] = order['supplier'].id
-            order['supplier_name'] = order['supplier'].name
-            order['supplier_email'] = order['supplier'].email_formatted
-
-            lines = []
-            # sort by product name, note
-            for product, note in sorted(group_lines, key=lambda k: (k[0].name, bool(k[1]))):
-                quantity = group_lines[(product, note)]
-                lines.append({
-                    'product': product.name,
-                    'note': note or '',
-                    'quantity': quantity,
-                    'price': product.price * quantity,
-                })
-
-            order['amount_total'] = sum(l['price'] for l in lines)
+    company_id = fields.Many2one('res.company', related='user_id.company_id', store=True)
+    currency_id = fields.Many2one('res.currency', related='company_id.currency_id', readonly=True, store=True)
+    quantity = fields.Float('Quantity', required=True, default=1)
+
+    display_toppings = fields.Text('Toppings', compute='_compute_display_toppings', store=True)
+
+    @api.depends('topping_ids_1', 'topping_ids_2', 'topping_ids_3', 'product_id', 'quantity')
+    def _compute_total_price(self):
+        for line in self:
+            line.price = line.quantity * (line.product_id.price + sum((line.topping_ids_1 | line.topping_ids_2 | line.topping_ids_3).mapped('price')))
+
+    @api.depends('topping_ids_1', 'topping_ids_2', 'topping_ids_3')
+    def _compute_display_toppings(self):
+        for line in self:
+            toppings = line.topping_ids_1 | line.topping_ids_2 | line.topping_ids_3
+            line.display_toppings = '+ '.join(toppings.mapped('name'))
+
+    def update_quantity(self, increment):
+        for line in self.filtered(lambda line: line.state != 'confirmed'):
+            if line.quantity <= -increment:
+                # TODO: maybe unlink the order?
+                line.active = False
+            else:
+                line.quantity += increment
+        self._check_wallet()
 
-            template = self.env.ref('lunch.lunch_order_mail_supplier', raise_if_not_found=False)
-            ctx = dict(
-                default_composition_mode='mass_mail',
-                default_use_template=bool(template),
-                default_template_id=template.id,
-                default_lang=order['supplier'].lang or self.env.user.lang,
-                order=order,
-                lines=lines,
-            )
-            return {
-                'type': 'ir.actions.act_window',
-                'view_type': 'form',
-                'view_mode': 'form',
-                'res_model': 'mail.compose.message',
-                'target': 'new',
-                'context': ctx,
-            }
+    def _check_wallet(self):
+        for line in self:
+            if self.env['lunch.cashmove'].get_wallet_balance(line.user_id) < 0:
+                raise ValidationError(_('Your wallet does not contain enough money to order that.'
+                        'To add some money to your wallet, please contact your lunch manager.'))
 
-        else:
-            raise AccessError(_("Only your lunch manager processes the orders."))
+    def action_order(self):
+        self._check_wallet()
+        self.write({'state': 'ordered'})
 
-    @api.one
-    def confirm(self):
-        """
-        confirm one or more order line, update order status and create new cashmove
-        """
-        if self.user_has_groups("lunch.group_lunch_manager"):
-            if self.state != 'confirmed':
-                values = {
-                    'user_id': self.user_id.id,
-                    'amount': -self.price,
-                    'description': self.product_id.name,
-                    'order_id': self.id,
-                    'state': 'order',
-                    'date': self.date,
-                }
-                self.env['lunch.cashmove'].create(values)
-                self.state = 'confirmed'
-        else:
-            raise AccessError(_("Only your lunch manager sets the orders as received."))
+    def action_confirm(self):
+        self.write({'state': 'confirmed'})
 
-    @api.one
-    def cancel(self):
-        """
-        cancel one or more order.line, update order status and unlink existing cashmoves
-        """
-        if self.user_has_groups("lunch.group_lunch_manager"):
-            self.state = 'cancelled'
-            self.cashmove.unlink()
-        else:
-            raise AccessError(_("Only your lunch manager cancels the orders."))
+    def action_cancel(self):
+        self.write({'state': 'cancelled'})

--- a/addons/lunch/models/lunch_product.py
+++ b/addons/lunch/models/lunch_product.py
@@ -1,10 +1,10 @@
 # -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
-from odoo import api, fields, models, _
+from odoo import api, fields, models, tools
 
 from odoo.addons import decimal_precision as dp
-from odoo.osv import expression
+from odoo.tools import formatLang
 
 
 class LunchProductCategory(models.Model):
@@ -13,51 +13,109 @@ class LunchProductCategory(models.Model):
     _description = 'Lunch Product Category'
 
     name = fields.Char('Product Category', required=True)
+    company_id = fields.Many2one('res.company', default=lambda self: self.env['res.company']._company_default_get())
+    currency_id = fields.Many2one('res.currency', related='company_id.currency_id')
+    topping_label_1 = fields.Char('Topping Label 1', required=True, default='Supplements')
+    topping_label_2 = fields.Char('Topping Label 2', required=True, default='Beverages')
+    topping_label_3 = fields.Char('Topping Label 3', required=True, default='Topping Label 3')
+    topping_ids_1 = fields.One2many('lunch.topping', 'category_id', domain=[('topping_category', '=', 1)], ondelete='cascade')
+    topping_ids_2 = fields.One2many('lunch.topping', 'category_id', domain=[('topping_category', '=', 2)], ondelete='cascade')
+    topping_ids_3 = fields.One2many('lunch.topping', 'category_id', domain=[('topping_category', '=', 3)], ondelete='cascade')
+    topping_quantity_1 = fields.Selection([
+        ('0_more', 'None or More'),
+        ('1_more', 'One or More'),
+        ('1', 'Only One')], default='0_more', required=True)
+    topping_quantity_2 = fields.Selection([
+        ('0_more', 'None or More'),
+        ('1_more', 'One or More'),
+        ('1', 'Only One')], default='0_more', required=True)
+    topping_quantity_3 = fields.Selection([
+        ('0_more', 'None or More'),
+        ('1_more', 'One or More'),
+        ('1', 'Only One')], default='0_more', required=True)
+
+    @api.model
+    def create(self, vals):
+        for topping in vals.get('topping_ids_2', []):
+            topping[2].update({'topping_category': 2})
+        for topping in vals.get('topping_ids_3', []):
+            topping[2].update({'topping_category': 3})
+        return super(LunchProductCategory, self).create(vals)
+
+    def write(self, vals):
+        for topping in vals.get('topping_ids_2', []):
+            topping_values = topping[2]
+            if topping_values:
+                topping_values.update({'topping_category': 2})
+        for topping in vals.get('topping_ids_3', []):
+            topping_values = topping[2]
+            if topping_values:
+                topping_values.update({'topping_category': 3})
+        return super(LunchProductCategory, self).write(vals)
+
+
+class LunchTopping(models.Model):
+    """"""
+    _name = 'lunch.topping'
+    _description = 'Lunch Toppings'
+
+    name = fields.Char('Name', required=True)
+    company_id = fields.Many2one('res.company', default=lambda self: self.env['res.company']._company_default_get())
+    currency_id = fields.Many2one('res.currency', related='company_id.currency_id')
+    price = fields.Float('Price', digits=dp.get_precision('Account'), required=True)
+    category_id = fields.Many2one('lunch.product.category')
+    topping_category = fields.Integer('Topping Category', help="This field is a technical field", required=True, default=1)
+
+    def name_get(self):
+        currency_id = self.env.user.company_id.currency_id
+        res = dict(super(LunchTopping, self).name_get())
+        for topping in self:
+            price = formatLang(self.env, topping.price, currency_obj=currency_id)
+            res[topping.id] = '%s %s' % (topping.name, price)
+        return list(res.items())
 
 
 class LunchProduct(models.Model):
     """ Products available to order. A product is linked to a specific vendor. """
     _name = 'lunch.product'
     _description = 'Lunch Product'
+    _order = 'name'
 
-    name = fields.Char('Product', required=True)
+    name = fields.Char('Product Name', required=True)
     category_id = fields.Many2one('lunch.product.category', 'Product Category', required=True)
     description = fields.Text('Description')
-    price = fields.Float('Price', digits=dp.get_precision('Account'))
-    supplier = fields.Many2one('res.partner', 'Vendor')
+    price = fields.Float('Price', digits=dp.get_precision('Account'), required=True)
+    supplier_id = fields.Many2one('lunch.supplier', 'Vendor', required=True)
     active = fields.Boolean(default=True)
-    available = fields.Boolean(compute='_get_available_product', search='_search_available_products')
-
-    @api.depends('supplier')
-    def _get_available_product(self):
-        for product in self:
-            if not product.supplier:
-                product.available = True
-            else:
-                alerts = self.env['lunch.alert'].search([
-                    ('partner_id', '=', self.supplier.id)
-                ])
-                if alerts and not any(alert.display for alert in alerts):
-                    # every alert is not available
-                    product.available = False
-                else:
-                    # no alert for the supplier or at least one is not available
-                    product.available = True
-
-    def _search_available_products(self, operator, value):
-        alerts = self.env['lunch.alert'].search([])
-        supplier_w_alerts = alerts.mapped('partner_id')
-        available_suppliers = alerts.filtered(lambda a: a.display).mapped('partner_id')
-        available_products = self.search([
-            '|',
-                ('supplier', 'not in', supplier_w_alerts.ids),
-                ('supplier', 'in', available_suppliers.ids)
-        ])
-
-        if (operator in expression.NEGATIVE_TERM_OPERATORS and value) or \
-           (operator not in expression.NEGATIVE_TERM_OPERATORS and not value):
-            # e.g. (available = False) or (available != True)
-            return [('id', 'not in', available_products.ids)]
-        else:
-            # e.g. (available = True) or (available != False)
-            return [('id', 'in', available_products.ids)]
+
+    company_id = fields.Many2one('res.company', default=lambda self: self.env['res.company']._company_default_get())
+    currency_id = fields.Many2one('res.currency', related='company_id.currency_id')
+
+    # image: all image fields are base64 encoded and PIL-supported
+    image = fields.Binary(
+        "Image",
+        help="This field holds the image used as image for the product, limited to 1024x1024px.")
+    image_medium = fields.Binary(
+        "Medium-sized image",
+        help="Medium-sized image of the product. It is automatically "
+             "resized as a 128x128px image, with aspect ratio preserved, "
+             "only when the image exceeds one of those sizes. Use this field in form views or some kanban views.")
+    image_small = fields.Binary(
+        "Small-sized image",
+        help="Small-sized image of the product. It is automatically "
+             "resized as a 64x64px image, with aspect ratio preserved. "
+             "Use this field anywhere a small image is required.")
+
+    new_until = fields.Date('New Until')
+    favorite_user_ids = fields.Many2many('res.users', 'lunch_product_favorite_user_rel', 'product_id', 'user_id')
+
+
+    @api.model_create_multi
+    def create(self, vals_list):
+        for values in vals_list:
+            tools.image_resize_images(values)
+        return super(LunchProduct, self).create(vals_list)
+
+    def write(self, values):
+        tools.image_resize_images(values)
+        return super(LunchProduct, self).write(values)

--- a/None
+++ b/addons/lunch/models/lunch_supplier.py
@@ -0,0 +1,180 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+import math
+import pytz
+
+from datetime import datetime, time
+
+from odoo import api, fields, models
+from odoo.osv import expression
+from odoo.tools import float_round
+
+from odoo.addons.base.models.res_partner import _tz_get
+
+
+WEEKDAY_TO_NAME = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday']
+
+def float_to_time(hours, moment='am', tz=None):
+    """ Convert a number of hours into a time object. """
+    if hours == 12.0 and moment == 'pm':
+        return time.max
+    fractional, integral = math.modf(hours)
+    if moment == 'pm':
+        integral += 12
+    res = time(int(integral), int(float_round(60 * fractional, precision_digits=0)), 0)
+    if tz:
+        res = res.replace(tzinfo=pytz.timezone(tz))
+    return res
+
+def time_to_float(t):
+    return float_round(t.hour + t.minute/60 + t.second/3600, precision_digits=2)
+
+class LunchSupplier(models.Model):
+    _name = 'lunch.supplier'
+    _description = 'Lunch Supplier'
+    _inherit = ['mail.thread', 'mail.activity.mixin']
+
+    partner_id = fields.Many2one('res.partner', string='Vendor', required=True)
+
+    name = fields.Char('Name', related='partner_id.name', readonly=False)
+
+    email = fields.Char(related='partner_id.email', readonly=False)
+    email_formatted = fields.Char(related='partner_id.email_formatted', readonly=True)
+    phone = fields.Char(related='partner_id.phone', readonly=False)
+    street = fields.Char(related='partner_id.street', readonly=False)
+    street2 = fields.Char(related='partner_id.street2', readonly=False)
+    zip_code = fields.Char(related='partner_id.zip', readonly=False)
+    city = fields.Char(related='partner_id.city', readonly=False)
+    state_id = fields.Many2one("res.country.state", related='partner_id.state_id', readonly=False)
+    country_id = fields.Many2one('res.country', related='partner_id.country_id', readonly=False)
+
+    responsible_id = fields.Many2one('res.users', string="Responsible", domain=lambda self: [('groups_id', 'in', self.env.ref('lunch.group_lunch_manager').id)],
+                                     default=lambda self: self.env.user.partner_id,
+                                     help="The responsible is the person that will order lunch for everyone"
+                                          "It will be used as the 'from' when sending the automatic email")
+
+    send_by = fields.Selection([
+        ('phone', 'Phone'),
+        ('mail', 'Email'),
+    ], 'Send Order By', default='phone')
+    automatic_email_time = fields.Float('Order Time', default=12.0, required=True)
+
+    recurrency_monday = fields.Boolean('Monday', default=True)
+    recurrency_tuesday = fields.Boolean('Tuesday', default=True)
+    recurrency_wednesday = fields.Boolean('Wednesday', default=True)
+    recurrency_thursday = fields.Boolean('Thursday', default=True)
+    recurrency_friday = fields.Boolean('Friday', default=True)
+    recurrency_saturday = fields.Boolean('Saturday')
+    recurrency_sunday = fields.Boolean('Sunday')
+
+    recurrency_end_date = fields.Date('Until', help="This field is used in order to ")
+
+    available_location_ids = fields.Many2many('lunch.location', string='Location')
+    available_today = fields.Boolean('This is True when if the supplier is available today',
+                                     compute='_compute_available_today', search='_search_available_today')
+
+    tz = fields.Selection(_tz_get, string='Timezone', required=True, default=lambda self: self.env.user.tz or 'UTC')
+
+    active = fields.Boolean(default=True)
+
+    moment = fields.Selection([
+        ('am', 'AM'),
+        ('pm', 'PM'),
+    ], default='am', required=True)
+
+    delivery = fields.Selection([
+        ('delivery', 'Delivery'),
+        ('no_delivery', 'No Delivery')
+    ], default='no_delivery')
+
+    _sql_constraints = [
+        ('automatic_email_time_range',
+         'CHECK(automatic_email_time >= 0 AND automatic_email_time <= 12)',
+         'Automatic Email Sending Time should be between 0 and 12'),
+    ]
+
+    @api.multi
+    def name_get(self):
+        res = []
+        for supplier in self:
+            if supplier.phone:
+                res.append((supplier.id, '%s %s' % (supplier.name, supplier.phone)))
+            else:
+                res.append((supplier.id, supplier.name))
+        return res
+
+    @api.model
+    def _auto_email_send(self):
+        """
+            This method is called every 20 minutes via a cron.
+            Its job is simply to get all the orders made for each supplier and send an email
+            automatically to the supplier if the supplier is configured for it and we are ready
+            to send it (usually at 11am or so)
+        """
+        records = self.search([('send_by', '=', 'mail')])
+
+        for supplier in records:
+            send_at = datetime.combine(fields.Date.today(),
+                                       float_to_time(supplier.automatic_email_time, supplier.moment, supplier.tz)).astimezone(pytz.UTC).replace(tzinfo=None)
+            if supplier.available_today and fields.Datetime.now() > send_at:
+                lines = self.env['lunch.order'].search([('supplier_id', '=', supplier.id),
+                                                             ('state', '=', 'ordered'), ('date', '=', fields.Date.today())])
+
+                if lines:
+                    order = {
+                        'company_name': lines[0].company_id.name,
+                        'currency_id': lines[0].currency_id.id,
+                        'supplier_id': supplier.partner_id.id,
+                        'supplier_name': supplier.name,
+                        'email_from': supplier.responsible_id.email_formatted,
+                    }
+
+                    _lines = [{
+                        'product': line.product_id.name,
+                        'note': line.note,
+                        'quantity': line.quantity,
+                        'price': line.price,
+                        'toppings': line.display_toppings,
+                        'username': line.user_id.name,
+                    } for line in lines]
+
+                    order['amount_total'] = sum(line.price for line in lines)
+
+                    self.env.ref('lunch.lunch_order_mail_supplier').with_context(order=order, lines=_lines).send_mail(supplier.id)
+
+                    lines.action_confirm()
+
+    @api.depends('recurrency_end_date', 'recurrency_monday', 'recurrency_tuesday',
+                 'recurrency_wednesday', 'recurrency_thursday', 'recurrency_friday',
+                 'recurrency_saturday', 'recurrency_sunday')
+    def _compute_available_today(self):
+        now = fields.Datetime.now().replace(tzinfo=pytz.UTC)
+
+        for supplier in self:
+            now = now.astimezone(pytz.timezone(supplier.tz))
+
+            if supplier.recurrency_end_date and now.date() > supplier.recurrency_end_date:
+                supplier.available_today = False
+            else:
+                fieldname = 'recurrency_%s' % (WEEKDAY_TO_NAME[now.weekday()])
+                supplier.available_today = supplier[fieldname]
+
+    def _search_available_today(self, operator, value):
+        if (not operator in ['=', '!=']) or (not value in [True, False]):
+            return []
+
+        searching_for_true = (operator == '=' and value) or (operator == '!=' and not value)
+
+        now = fields.Datetime.now().replace(tzinfo=pytz.UTC).astimezone(pytz.timezone(self.env.user.tz or 'UTC'))
+        fieldname = 'recurrency_%s' % (WEEKDAY_TO_NAME[now.weekday()])
+
+        recurrency_domain = expression.OR([
+            [('recurrency_end_date', '=', False)],
+            [('recurrency_end_date', '>' if searching_for_true else '<', now)]
+        ])
+
+        return expression.AND([
+            recurrency_domain,
+            [(fieldname, operator, value)]
+        ])

--- a/None
+++ b/addons/lunch/models/res_company.py
@@ -0,0 +1,10 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from odoo import models, fields
+
+
+class Company(models.Model):
+    _inherit = 'res.company'
+
+    lunch_minimum_threshold = fields.Float()

--- a/None
+++ b/addons/lunch/models/res_config_settings.py
@@ -0,0 +1,11 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from odoo import fields, models
+
+
+class ResConfigSettings(models.TransientModel):
+    _inherit = 'res.config.settings'
+
+    currency_id = fields.Many2one('res.currency', related='company_id.currency_id')
+    company_lunch_minimum_threshold = fields.Float(string="Maximum Allowed Overdraft", readonly=False, related='company_id.lunch_minimum_threshold')

--- a/None
+++ b/addons/lunch/models/res_users.py
@@ -0,0 +1,10 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from odoo import fields, models
+
+
+class ResUsers(models.Model):
+    _inherit = 'res.users'
+
+    last_lunch_location_id = fields.Many2one('lunch.location')
