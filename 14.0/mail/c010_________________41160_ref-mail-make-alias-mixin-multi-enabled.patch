PR: https://github.com/odoo/odoo/pull/41160

From: 186cfb5ebd35d572d0f635cd7975de7cff0d1055
From: ryv-odoo
Date: 2020-04-17 06:52:09

Structural Changes: 2
Total Changes: 63

[REF] mail: make alias mixin multi-enabled

Purpose of this commit is to allow multi-create in alias mixin by correctly
creating / updating aliases in batch.

Task ID 1919277
Community PR odoo/odoo#41160
Enterprise PR odoo/enterprise#6983
Upgrade PR odoo/upgrade#872

Co-Authored-By: Rémy Voet <ryv@odoo.com>
Co-Authored-By: Thibault Delavallée <tde@odoo.com>

================================= pseudo patch: =================================

--- a/addons/mail/models/mail_alias.py
+++ b/addons/mail/models/mail_alias.py
@@ -27,6 +27,9 @@ class Alias(models.Model):
     _rec_name = 'alias_name'
     _order = 'alias_model_id, alias_name'
 
+    def _default_alias_domain(self):
+        return self.env["ir.config_parameter"].sudo().get_param("mail.catchall.domain")
+
     alias_name = fields.Char('Alias Name', copy=False, help="The name of the email alias, e.g. 'jobs' if you want to catch emails for <jobs@example.odoo.com>")
     alias_model_id = fields.Many2one('ir.model', 'Aliased Model', required=True, ondelete="cascade",
                                      help="The model (Odoo Document Kind) to which this alias "
@@ -48,8 +51,7 @@ class Alias(models.Model):
         'Record Thread ID',
         help="Optional ID of a thread (record) to which all incoming messages will be attached, even "
              "if they did not reply to it. If set, this will disable the creation of new records completely.")
-    alias_domain = fields.Char('Alias domain', compute='_get_alias_domain',
-                               default=lambda self: self.env["ir.config_parameter"].sudo().get_param("mail.catchall.domain"))
+    alias_domain = fields.Char('Alias domain', compute='_compute_alias_domain', default=_default_alias_domain)
     alias_parent_model_id = fields.Many2one(
         'ir.model', 'Parent Model',
         help="Parent model holding the alias. The model holding the alias reference "
@@ -73,8 +75,8 @@ class Alias(models.Model):
         ('alias_unique', 'UNIQUE(alias_name)', 'Unfortunately this email alias is already used, please choose a unique one')
     ]
 
-    def _get_alias_domain(self):
-        alias_domain = self.env["ir.config_parameter"].sudo().get_param("mail.catchall.domain")
+    def _compute_alias_domain(self):
+        alias_domain = self._default_alias_domain()
         for record in self:
             record.alias_domain = alias_domain
 

--- a/addons/mail/models/mail_alias_mixin.py
+++ b/addons/mail/models/mail_alias_mixin.py
@@ -16,6 +16,7 @@ class AliasMixin(models.AbstractModel):
     _name = 'mail.alias.mixin'
     _inherits = {'mail.alias': 'alias_id'}
     _description = 'Email Aliases Mixin'
+    ALIAS_WRITEABLE_FIELDS = ['alias_name', 'alias_contact', 'alias_defaults']
 
     alias_id = fields.Many2one('mail.alias', string='Alias', ondelete="restrict", required=True)
 
@@ -23,28 +24,54 @@ class AliasMixin(models.AbstractModel):
     # CRUD
     # --------------------------------------------------
 
-    @api.model
-    def create(self, vals):
-        """ Create a record with ``vals``, and create a corresponding alias. """
-        new_alias = not 'alias_id' in vals
-        if new_alias:
-            alias_vals, record_vals = self._alias_filter_fields(vals)
-            alias_vals.update(self._alias_get_creation_values())
-            alias = self.env['mail.alias'].create(alias_vals)
-            record_vals['alias_id'] = alias.id
+    @api.model_create_multi
+    def create(self, vals_list):
+        """ Create a record with each ``vals`` or ``vals_list`` and create a corresponding alias. """
+        valid_vals_list = []
+        for vals in vals_list:
+            new_alias = not vals.get('alias_id')
+            if new_alias:
+                alias_vals, record_vals = self._alias_filter_fields(vals)
+                alias_vals.update(self._alias_get_creation_values())
+                alias = self.env['mail.alias'].sudo().create(alias_vals)
+                record_vals['alias_id'] = alias.id
+                valid_vals_list.append(record_vals)
+            else:
+                valid_vals_list.append(vals)
+
+        records = super(AliasMixin, self).create(valid_vals_list)
+
+        for record in records:
+            record.alias_id.sudo().write(record._alias_get_creation_values())
 
-        record = super(AliasMixin, self).create(record_vals)
-        alias.sudo().write(record._alias_get_creation_values())
+        return records
 
-        return record
+    def write(self, vals):
+        """ Split writable fields of mail.alias and other fields alias fields will
+        write with sudo and the other normally """
+        alias_vals, record_vals = self._alias_filter_fields(vals, filters=self.ALIAS_WRITEABLE_FIELDS)
+        if record_vals:
+            super(AliasMixin, self).write(record_vals)
+        if alias_vals and (record_vals or self.check_access_rights('write', raise_exception=False)):
+            self.mapped('alias_id').sudo().write(alias_vals)
+
+        return True
 
     def unlink(self):
         """ Delete the given records, and cascade-delete their corresponding alias. """
         aliases = self.mapped('alias_id')
         res = super(AliasMixin, self).unlink()
-        aliases.unlink()
+        aliases.sudo().unlink()
         return res
 
+    @api.returns(None, lambda value: value[0])
+    def copy_data(self, default=None):
+        data = super(AliasMixin, self).copy_data(default)[0]
+        for fields_not_writable in set(self.env['mail.alias']._fields.keys()) - set(self.ALIAS_WRITEABLE_FIELDS):
+            if fields_not_writable in data:
+                del data[fields_not_writable]
+        return [data]
+
     def _init_column(self, name):
         """ Create aliases for existing rows. """
         super(AliasMixin, self)._init_column(name)
