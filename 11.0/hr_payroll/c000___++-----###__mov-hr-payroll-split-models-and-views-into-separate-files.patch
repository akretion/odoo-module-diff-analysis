PR: https://github.com/odoo/odoo/pull/

From: d7a3f39d7222d0b2de547dc0837b57e1f8ed1461
From: Yannick Tivisse
Date: 2017-04-26 13:08:09

Breaking data model changes score: 37.399999999999984, change matches:
+    slip_ids = fields.One2many('hr.payslip', 'employee_id', string='Payslips', readonly=True)
-    company_id = fields.Many2one('res.company', string='Company', required=True,
-    _inherit = 'hr.contract'
-    struct_id = fields.Many2one('hr.payroll.structure', string='Salary Structure')
-    schedule_pay = fields.Selection([
-    resource_calendar_id = fields.Many2one(required=True)
-    lower_bound = fields.Float('Lower Bound', help="Lower bound authorized by the employer for this advantage")
-    upper_bound = fields.Float('Upper Bound', help="Upper bound authorized by the employer for this advantage")
-    default_value = fields.Float('Default value for this advantage')
-    company_id = fields.Many2one('res.company', string='Company',
-    register_line_ids = fields.One2many('hr.payslip.line', 'register_id',
-    parent_id = fields.Many2one('hr.salary.rule.category', string='Parent',
-    company_id = fields.Many2one('res.company', string='Company',
-    slip_ids = fields.One2many('hr.payslip', 'payslip_run_id', string='Payslips', readonly=True,
-    state = fields.Selection([
-    date_start = fields.Date(string='Date From', required=True, readonly=True,
-    date_end = fields.Date(string='Date To', required=True, readonly=True,
-    credit_note = fields.Boolean(string='Credit Note', readonly=True,
-    code = fields.Char(required=True,
-    sequence = fields.Integer(required=True, index=True, default=5,
-    quantity = fields.Char(default='1.0',
-    active = fields.Boolean(default=True,
-    appears_on_payslip = fields.Boolean(string='Appears on Payslip', default=True,
-    company_id = fields.Many2one('res.company', string='Company',
-    condition_select = fields.Selection([
-    condition_range = fields.Char(string='Range Based on', default='contract.wage',
-    condition_python = fields.Text(string='Python Condition', required=True,
-    amount_select = fields.Selection([
-    amount_percentage = fields.Float(string='Percentage (%)', digits=dp.get_precision('Payroll Rate'),
-    amount_python_compute = fields.Text(string='Python Code',
-    register_id = fields.Many2one('hr.contribution.register', string='Contribution Register',
+    slip_ids = fields.One2many('hr.payslip', 'payslip_run_id', string='Payslips', readonly=True,
+    state = fields.Selection([
+    date_start = fields.Date(string='Date From', required=True, readonly=True,
+    date_end = fields.Date(string='Date To', required=True, readonly=True,
+    credit_note = fields.Boolean(string='Credit Note', readonly=True,
-    name = fields.Char(string='Description', required=True)
-    code = fields.Char(required=True, help="The code that can be used in the salary rules")
-    _inherit = 'hr.salary.rule'
-    slip_id = fields.Many2one('hr.payslip', string='Pay Slip', required=True, ondelete='cascade')
-    salary_rule_id = fields.Many2one('hr.salary.rule', string='Rule', required=True)
-    employee_id = fields.Many2one('hr.employee', string='Employee', required=True)
-    contract_id = fields.Many2one('hr.contract', string='Contract', required=True, index=True)
-    rate = fields.Float(string='Rate (%)', digits=dp.get_precision('Payroll Rate'), default=100.0)
-    amount = fields.Float(digits=dp.get_precision('Payroll'))
-    quantity = fields.Float(digits=dp.get_precision('Payroll'), default=1.0)
-    total = fields.Float(compute='_compute_total', string='Total', digits=dp.get_precision('Payroll'), store=True)
-    _inherit = 'hr.employee'
-    slip_ids = fields.One2many('hr.payslip', 'employee_id', string='Payslips', readonly=True)
-    payslip_count = fields.Integer(compute='_compute_payslip_count', string='Payslips', groups="hr_payroll.group_hr_payroll_user")
+    company_id = fields.Many2one('res.company', string='Company', required=True,
+    company_id = fields.Many2one('res.company', string='Company',
+    register_line_ids = fields.One2many('hr.payslip.line', 'register_id',
+    parent_id = fields.Many2one('hr.salary.rule.category', string='Parent',
+    company_id = fields.Many2one('res.company', string='Company',
+    code = fields.Char(required=True,
+    sequence = fields.Integer(required=True, index=True, default=5,
+    quantity = fields.Char(default='1.0',
+    active = fields.Boolean(default=True,
+    appears_on_payslip = fields.Boolean(string='Appears on Payslip', default=True,
+    company_id = fields.Many2one('res.company', string='Company',
+    condition_select = fields.Selection([
+    condition_range = fields.Char(string='Range Based on', default='contract.wage',
+    condition_python = fields.Text(string='Python Condition', required=True,
+    amount_select = fields.Selection([
+    amount_percentage = fields.Float(string='Percentage (%)', digits=dp.get_precision('Payroll Rate'),
+    amount_python_compute = fields.Text(string='Python Code',
+    register_id = fields.Many2one('hr.contribution.register', string='Contribution Register',

Total Changes: 1787

[MOV] hr_payroll: Split models and views into separate files

================================= pseudo patch: =================================

--- a/addons/hr_payroll/models/__init__.py
+++ b/addons/hr_payroll/models/__init__.py
@@ -1,5 +1,8 @@
 #-*- coding:utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
-import hr_payroll
-import res_config
+import hr_contract
+import hr_employee
+import hr_payroll_config_settings
+import hr_salary_rule
+import hr_payslip

--- a/None
+++ b/addons/hr_payroll/models/hr_contract.py
@@ -0,0 +1,52 @@
+# -*- coding:utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from odoo import api, fields, models
+
+
+class HrContract(models.Model):
+    """
+    Employee contract based on the visa, work permits
+    allows to configure different Salary structure
+    """
+    _inherit = 'hr.contract'
+    _description = 'Employee Contract'
+
+    struct_id = fields.Many2one('hr.payroll.structure', string='Salary Structure')
+    schedule_pay = fields.Selection([
+        ('monthly', 'Monthly'),
+        ('quarterly', 'Quarterly'),
+        ('semi-annually', 'Semi-annually'),
+        ('annually', 'Annually'),
+        ('weekly', 'Weekly'),
+        ('bi-weekly', 'Bi-weekly'),
+        ('bi-monthly', 'Bi-monthly'),
+    ], string='Scheduled Pay', index=True, default='monthly')
+    resource_calendar_id = fields.Many2one(required=True)
+
+    @api.multi
+    def get_all_structures(self):
+        """
+        @return: the structures linked to the given contracts, ordered by hierachy (parent=False first,
+                 then first level children and so on) and without duplicata
+        """
+        structures = self.mapped('struct_id')
+        if not structures:
+            return []
+        # YTI TODO return browse records
+        return list(set(structures._get_parent_structure().ids))
+
+    @api.multi
+    def get_attribute(self, code, attribute):
+        return getattr(self.env['hr.contract.advantage.template'].search([('code', '=', code)], limit=1), attribute)
+
+
+class HrContractAdvandageTemplate(models.Model):
+    _name = 'hr.contract.advantage.template'
+    _description = "Employee's Advantage on Contract"
+
+    name = fields.Char('Name', required=True)
+    code = fields.Char('Code', required=True)
+    lower_bound = fields.Float('Lower Bound', help="Lower bound authorized by the employer for this advantage")
+    upper_bound = fields.Float('Upper Bound', help="Upper bound authorized by the employer for this advantage")
+    default_value = fields.Float('Default value for this advantage')

--- a/None
+++ b/addons/hr_payroll/models/hr_employee.py
@@ -0,0 +1,17 @@
+# -*- coding:utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from odoo import api, fields, models
+
+
+class HrEmployee(models.Model):
+    _inherit = 'hr.employee'
+    _description = 'Employee'
+
+    slip_ids = fields.One2many('hr.payslip', 'employee_id', string='Payslips', readonly=True)
+    payslip_count = fields.Integer(compute='_compute_payslip_count', string='Payslips', groups="hr_payroll.group_hr_payroll_user")
+
+    @api.multi
+    def _compute_payslip_count(self):
+        for employee in self:
+            employee.payslip_count = len(employee.slip_ids)

--- a/addons/hr_payroll/models/res_config.py
+++ b/addons/hr_payroll/models/hr_payroll_config_settings.py

--- a/addons/hr_payroll/models/hr_payroll.py
+++ b/addons/hr_payroll/models/hr_payslip.py
@@ -2,172 +2,15 @@
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
 import time
-from datetime import datetime, timedelta
+from datetime import datetime
 from datetime import time as datetime_time
 from dateutil import relativedelta
 
 import babel
 
 from odoo import api, fields, models, tools, _
-from odoo.exceptions import UserError, ValidationError
-from odoo.tools.safe_eval import safe_eval
-
 from odoo.addons import decimal_precision as dp
-
-
-class HrPayrollStructure(models.Model):
-    """
-    Salary structure used to defined
-    - Basic
-    - Allowances
-    - Deductions
-    """
-    _name = 'hr.payroll.structure'
-    _description = 'Salary Structure'
-
-    @api.model
-    def _get_parent(self):
-        return self.env.ref('hr_payroll.structure_base', False)
-
-    name = fields.Char(required=True)
-    code = fields.Char(string='Reference', required=True)
-    company_id = fields.Many2one('res.company', string='Company', required=True,
-        copy=False, default=lambda self: self.env['res.company']._company_default_get())
-    note = fields.Text(string='Description')
-    parent_id = fields.Many2one('hr.payroll.structure', string='Parent', default=_get_parent)
-    children_ids = fields.One2many('hr.payroll.structure', 'parent_id', string='Children', copy=True)
-    rule_ids = fields.Many2many('hr.salary.rule', 'hr_structure_salary_rule_rel', 'struct_id', 'rule_id', string='Salary Rules')
-
-    @api.constrains('parent_id')
-    def _check_parent_id(self):
-        if not self._check_recursion():
-            raise ValidationError(_('Error ! You cannot create a recursive Salary Structure.'))
-
-    @api.multi
-    def copy(self, default=None):
-        self.ensure_one()
-        default = dict(default or {}, code=_("%s (copy)") % (self.code))
-        return super(HrPayrollStructure, self).copy(default)
-
-    @api.multi
-    def get_all_rules(self):
-        """
-        @return: returns a list of tuple (id, sequence) of rules that are maybe to apply
-        """
-        all_rules = []
-        for struct in self:
-            all_rules += struct.rule_ids._recursive_search_of_rules()
-        return all_rules
-
-    @api.multi
-    def _get_parent_structure(self):
-        parent = self.mapped('parent_id')
-        if parent:
-            parent = parent._get_parent_structure()
-        return parent + self
-
-
-class HrContract(models.Model):
-    """
-    Employee contract based on the visa, work permits
-    allows to configure different Salary structure
-    """
-    _inherit = 'hr.contract'
-    _description = 'Employee Contract'
-
-    struct_id = fields.Many2one('hr.payroll.structure', string='Salary Structure')
-    schedule_pay = fields.Selection([
-        ('monthly', 'Monthly'),
-        ('quarterly', 'Quarterly'),
-        ('semi-annually', 'Semi-annually'),
-        ('annually', 'Annually'),
-        ('weekly', 'Weekly'),
-        ('bi-weekly', 'Bi-weekly'),
-        ('bi-monthly', 'Bi-monthly'),
-    ], string='Scheduled Pay', index=True, default='monthly')
-    resource_calendar_id = fields.Many2one(required=True)
-
-    @api.multi
-    def get_all_structures(self):
-        """
-        @return: the structures linked to the given contracts, ordered by hierachy (parent=False first,
-                 then first level children and so on) and without duplicata
-        """
-        structures = self.mapped('struct_id')
-        if not structures:
-            return []
-        # YTI TODO return browse records
-        return list(set(structures._get_parent_structure().ids))
-
-    @api.multi
-    def get_attribute(self, code, attribute):
-        return getattr(self.env['hr.contract.advantage.template'].search([('code', '=', code)], limit=1), attribute)
-
-
-class HrContractAdvandageTemplate(models.Model):
-    _name = 'hr.contract.advantage.template'
-    _description = "Employee's Advantage on Contract"
-
-    name = fields.Char('Name', required=True)
-    code = fields.Char('Code', required=True)
-    lower_bound = fields.Float('Lower Bound', help="Lower bound authorized by the employer for this advantage")
-    upper_bound = fields.Float('Upper Bound', help="Upper bound authorized by the employer for this advantage")
-    default_value = fields.Float('Default value for this advantage')
-
-class HrContributionRegister(models.Model):
-    _name = 'hr.contribution.register'
-    _description = 'Contribution Register'
-
-    company_id = fields.Many2one('res.company', string='Company',
-        default=lambda self: self.env['res.company']._company_default_get())
-    partner_id = fields.Many2one('res.partner', string='Partner')
-    name = fields.Char(required=True)
-    register_line_ids = fields.One2many('hr.payslip.line', 'register_id',
-        string='Register Line', readonly=True)
-    note = fields.Text(string='Description')
-
-
-class HrSalaryRuleCategory(models.Model):
-    _name = 'hr.salary.rule.category'
-    _description = 'Salary Rule Category'
-
-    name = fields.Char(required=True)
-    code = fields.Char(required=True)
-    parent_id = fields.Many2one('hr.salary.rule.category', string='Parent',
-        help="Linking a salary category to its parent is used only for the reporting purpose.")
-    children_ids = fields.One2many('hr.salary.rule.category', 'parent_id', string='Children')
-    note = fields.Text(string='Description')
-    company_id = fields.Many2one('res.company', string='Company',
-        default=lambda self: self.env['res.company']._company_default_get())
-
-
-class HrPayslipRun(models.Model):
-    _name = 'hr.payslip.run'
-    _description = 'Payslip Batches'
-
-    name = fields.Char(required=True, readonly=True, states={'draft': [('readonly', False)]})
-    slip_ids = fields.One2many('hr.payslip', 'payslip_run_id', string='Payslips', readonly=True,
-        states={'draft': [('readonly', False)]})
-    state = fields.Selection([
-        ('draft', 'Draft'),
-        ('close', 'Close'),
-    ], string='Status', index=True, readonly=True, copy=False, default='draft')
-    date_start = fields.Date(string='Date From', required=True, readonly=True,
-        states={'draft': [('readonly', False)]}, default=time.strftime('%Y-%m-01'))
-    date_end = fields.Date(string='Date To', required=True, readonly=True,
-        states={'draft': [('readonly', False)]},
-        default=str(datetime.now() + relativedelta.relativedelta(months=+1, day=1, days=-1))[:10])
-    credit_note = fields.Boolean(string='Credit Note', readonly=True,
-        states={'draft': [('readonly', False)]},
-        help="If its checked, indicates that all payslips generated from here are refund payslips.")
-
-    @api.multi
-    def draft_payslip_run(self):
-        return self.write({'state': 'draft'})
-
-    @api.multi
-    def close_payslip_run(self):
-        return self.write({'state': 'close'})
+from odoo.exceptions import UserError, ValidationError
 
 
 class HrPayslip(models.Model):
@@ -286,7 +129,7 @@ class HrPayslip(models.Model):
             raise UserError(_('You cannot delete a payslip which is not draft or cancelled!'))
         return super(HrPayslip, self).unlink()
 
-    #TODO move this function into hr_contract module, on hr.employee object
+    # TODO move this function into hr_contract module, on hr.employee object
     @api.model
     def get_contract(self, employee, date_from, date_to):
         """
@@ -295,11 +138,11 @@ class HrPayslip(models.Model):
         @param date_to: date field
         @return: returns the ids of all the contracts for the given employee that need to be considered for the given dates
         """
-        #a contract is valid if it ends between the given dates
+        # a contract is valid if it ends between the given dates
         clause_1 = ['&', ('date_end', '<=', date_to), ('date_end', '>=', date_from)]
-        #OR if it starts between the given dates
+        # OR if it starts between the given dates
         clause_2 = ['&', ('date_start', '<=', date_to), ('date_start', '>=', date_from)]
-        #OR if it starts before the date_from and finish after the date_end (or never finish)
+        # OR if it starts before the date_from and finish after the date_end (or never finish)
         clause_3 = ['&', ('date_start', '<=', date_from), '|', ('date_end', '=', False), ('date_end', '>=', date_to)]
         clause_final = [('employee_id', '=', employee.id), ('state', '=', 'open'), '|', '|'] + clause_1 + clause_2 + clause_3
         return self.env['hr.contract'].search(clause_final).ids
@@ -308,7 +151,7 @@ class HrPayslip(models.Model):
     def compute_sheet(self):
         for payslip in self:
             number = payslip.number or self.env['ir.sequence'].next_by_code('salary.slip')
-            #delete old payslip lines
+            # delete old payslip lines
             payslip.line_ids.unlink()
             # set the list of contract for which the rules have to be applied
             # if we don't give the contract, then the rules to apply should be for all current contracts of the employee
@@ -642,6 +485,38 @@ class HrPayslip(models.Model):
         else:
             return 0.0
 
+
+class HrPayslipLine(models.Model):
+    _name = 'hr.payslip.line'
+    _inherit = 'hr.salary.rule'
+    _description = 'Payslip Line'
+    _order = 'contract_id, sequence'
+
+    slip_id = fields.Many2one('hr.payslip', string='Pay Slip', required=True, ondelete='cascade')
+    salary_rule_id = fields.Many2one('hr.salary.rule', string='Rule', required=True)
+    employee_id = fields.Many2one('hr.employee', string='Employee', required=True)
+    contract_id = fields.Many2one('hr.contract', string='Contract', required=True, index=True)
+    rate = fields.Float(string='Rate (%)', digits=dp.get_precision('Payroll Rate'), default=100.0)
+    amount = fields.Float(digits=dp.get_precision('Payroll'))
+    quantity = fields.Float(digits=dp.get_precision('Payroll'), default=1.0)
+    total = fields.Float(compute='_compute_total', string='Total', digits=dp.get_precision('Payroll'), store=True)
+
+    @api.depends('quantity', 'amount', 'rate')
+    def _compute_total(self):
+        for line in self:
+            line.total = float(line.quantity) * line.amount * line.rate / 100
+
+    @api.model
+    def create(self, values):
+        if 'employee_id' not in values or 'contract_id' not in values:
+            payslip = self.env['hr.payslip'].browse(values.get('slip_id'))
+            values['employee_id'] = values.get('employee_id') or payslip.employee_id.id
+            values['contract_id'] = values.get('contract_id') or payslip.contract_id and payslip.contract_id.id
+            if not values['contract_id']:
+                raise UserError(_('You must set a contract to create a payslip line.'))
+        return super(HrPayslipLine, self).create(values)
+
+
 class HrPayslipWorkedDays(models.Model):
     _name = 'hr.payslip.worked_days'
     _description = 'Payslip Worked Days'
@@ -673,194 +548,30 @@ class HrPayslipInput(models.Model):
         help="The contract for which applied this input")
 
 
-class HrSalaryRule(models.Model):
-    _name = 'hr.salary.rule'
-
-    name = fields.Char(required=True)
-    code = fields.Char(required=True,
-        help="The code of salary rules can be used as reference in computation of other rules. "
-             "In that case, it is case sensitive.")
-    sequence = fields.Integer(required=True, index=True, default=5,
-        help='Use to arrange calculation sequence')
-    quantity = fields.Char(default='1.0',
-        help="It is used in computation for percentage and fixed amount. "
-             "For e.g. A rule for Meal Voucher having fixed amount of "
-             u"1€ per worked day can have its quantity defined in expression "
-             "like worked_days.WORK100.number_of_days.")
-    category_id = fields.Many2one('hr.salary.rule.category', string='Category', required=True)
-    active = fields.Boolean(default=True,
-        help="If the active field is set to false, it will allow you to hide the salary rule without removing it.")
-    appears_on_payslip = fields.Boolean(string='Appears on Payslip', default=True,
-        help="Used to display the salary rule on payslip.")
-    parent_rule_id = fields.Many2one('hr.salary.rule', string='Parent Salary Rule', index=True)
-    company_id = fields.Many2one('res.company', string='Company',
-        default=lambda self: self.env['res.company']._company_default_get())
-    condition_select = fields.Selection([
-        ('none', 'Always True'),
-        ('range', 'Range'),
-        ('python', 'Python Expression')
-    ], string="Condition Based on", default='none', required=True)
-    condition_range = fields.Char(string='Range Based on', default='contract.wage',
-        help='This will be used to compute the % fields values; in general it is on basic, '
-             'but you can also use categories code fields in lowercase as a variable names '
-             '(hra, ma, lta, etc.) and the variable basic.')
-    condition_python = fields.Text(string='Python Condition', required=True,
-        default='''
-                    # Available variables:
-                    #----------------------
-                    # payslip: object containing the payslips
-                    # employee: hr.employee object
-                    # contract: hr.contract object
-                    # rules: object containing the rules code (previously computed)
-                    # categories: object containing the computed salary rule categories (sum of amount of all rules belonging to that category).
-                    # worked_days: object containing the computed worked days
-                    # inputs: object containing the computed inputs
-
-                    # Note: returned value have to be set in the variable 'result'
-
-                    result = rules.NET > categories.NET * 0.10''',
-        help='Applied this rule for calculation if condition is true. You can specify condition like basic > 1000.')
-    condition_range_min = fields.Float(string='Minimum Range', help="The minimum amount, applied for this rule.")
-    condition_range_max = fields.Float(string='Maximum Range', help="The maximum amount, applied for this rule.")
-    amount_select = fields.Selection([
-        ('percentage', 'Percentage (%)'),
-        ('fix', 'Fixed Amount'),
-        ('code', 'Python Code'),
-    ], string='Amount Type', index=True, required=True, default='fix', help="The computation method for the rule amount.")
-    amount_fix = fields.Float(string='Fixed Amount', digits=dp.get_precision('Payroll'))
-    amount_percentage = fields.Float(string='Percentage (%)', digits=dp.get_precision('Payroll Rate'),
-        help='For example, enter 50.0 to apply a percentage of 50%')
-    amount_python_compute = fields.Text(string='Python Code',
-        default='''
-                    # Available variables:
-                    #----------------------
-                    # payslip: object containing the payslips
-                    # employee: hr.employee object
-                    # contract: hr.contract object
-                    # rules: object containing the rules code (previously computed)
-                    # categories: object containing the computed salary rule categories (sum of amount of all rules belonging to that category).
-                    # worked_days: object containing the computed worked days.
-                    # inputs: object containing the computed inputs.
-
-                    # Note: returned value have to be set in the variable 'result'
-
-                    result = contract.wage * 0.10''')
-    amount_percentage_base = fields.Char(string='Percentage based on', help='result will be affected to a variable')
-    child_ids = fields.One2many('hr.salary.rule', 'parent_rule_id', string='Child Salary Rule', copy=True)
-    register_id = fields.Many2one('hr.contribution.register', string='Contribution Register',
-        help="Eventual third party involved in the salary payment of the employees.")
-    input_ids = fields.One2many('hr.rule.input', 'input_id', string='Inputs', copy=True)
-    note = fields.Text(string='Description')
-
-    @api.multi
-    def _recursive_search_of_rules(self):
-        """
-        @return: returns a list of tuple (id, sequence) which are all the children of the passed rule_ids
-        """
-        children_rules = []
-        for rule in self.filtered(lambda rule: rule.child_ids):
-            children_rules += rule.child_ids._recursive_search_of_rules()
-        return [(rule.id, rule.sequence) for rule in self] + children_rules
+class HrPayslipRun(models.Model):
+    _name = 'hr.payslip.run'
+    _description = 'Payslip Batches'
 
-    #TODO should add some checks on the type of result (should be float)
-    @api.multi
-    def compute_rule(self, localdict):
-        """
-        :param localdict: dictionary containing the environement in which to compute the rule
-        :return: returns a tuple build as the base/amount computed, the quantity and the rate
-        :rtype: (float, float, float)
-        """
-        self.ensure_one()
-        if self.amount_select == 'fix':
-            try:
-                return self.amount_fix, float(safe_eval(self.quantity, localdict)), 100.0
-            except:
-                raise UserError(_('Wrong quantity defined for salary rule %s (%s).') % (self.name, self.code))
-        elif self.amount_select == 'percentage':
-            try:
-                return (float(safe_eval(self.amount_percentage_base, localdict)),
-                        float(safe_eval(self.quantity, localdict)),
-                        self.amount_percentage)
-            except:
-                raise UserError(_('Wrong percentage base or quantity defined for salary rule %s (%s).') % (self.name, self.code))
-        else:
-            try:
-                safe_eval(self.amount_python_compute, localdict, mode='exec', nocopy=True)
-                return float(localdict['result']), 'result_qty' in localdict and localdict['result_qty'] or 1.0, 'result_rate' in localdict and localdict['result_rate'] or 100.0
-            except:
-                raise UserError(_('Wrong python code defined for salary rule %s (%s).') % (self.name, self.code))
+    name = fields.Char(required=True, readonly=True, states={'draft': [('readonly', False)]})
+    slip_ids = fields.One2many('hr.payslip', 'payslip_run_id', string='Payslips', readonly=True,
+        states={'draft': [('readonly', False)]})
+    state = fields.Selection([
+        ('draft', 'Draft'),
+        ('close', 'Close'),
+    ], string='Status', index=True, readonly=True, copy=False, default='draft')
+    date_start = fields.Date(string='Date From', required=True, readonly=True,
+        states={'draft': [('readonly', False)]}, default=time.strftime('%Y-%m-01'))
+    date_end = fields.Date(string='Date To', required=True, readonly=True,
+        states={'draft': [('readonly', False)]},
+        default=str(datetime.now() + relativedelta.relativedelta(months=+1, day=1, days=-1))[:10])
+    credit_note = fields.Boolean(string='Credit Note', readonly=True,
+        states={'draft': [('readonly', False)]},
+        help="If its checked, indicates that all payslips generated from here are refund payslips.")
 
     @api.multi
-    def satisfy_condition(self, localdict):
-        """
-        @param contract_id: id of hr.contract to be tested
-        @return: returns True if the given rule match the condition for the given contract. Return False otherwise.
-        """
-        self.ensure_one()
-
-        if self.condition_select == 'none':
-            return True
-        elif self.condition_select == 'range':
-            try:
-                result = safe_eval(self.condition_range, localdict)
-                return self.condition_range_min <= result and result <= self.condition_range_max or False
-            except:
-                raise UserError(_('Wrong range condition defined for salary rule %s (%s).') % (self.name, self.code))
-        else:  # python code
-            try:
-                safe_eval(self.condition_python, localdict, mode='exec', nocopy=True)
-                return 'result' in localdict and localdict['result'] or False
-            except:
-                raise UserError(_('Wrong python condition defined for salary rule %s (%s).') % (self.name, self.code))
-
-
-class HrRuleInput(models.Model):
-    _name = 'hr.rule.input'
-    _description = 'Salary Rule Input'
-
-    name = fields.Char(string='Description', required=True)
-    code = fields.Char(required=True, help="The code that can be used in the salary rules")
-    input_id = fields.Many2one('hr.salary.rule', string='Salary Rule Input', required=True)
-
-
-class HrPayslipLine(models.Model):
-    _name = 'hr.payslip.line'
-    _inherit = 'hr.salary.rule'
-    _description = 'Payslip Line'
-    _order = 'contract_id, sequence'
-
-    slip_id = fields.Many2one('hr.payslip', string='Pay Slip', required=True, ondelete='cascade')
-    salary_rule_id = fields.Many2one('hr.salary.rule', string='Rule', required=True)
-    employee_id = fields.Many2one('hr.employee', string='Employee', required=True)
-    contract_id = fields.Many2one('hr.contract', string='Contract', required=True, index=True)
-    rate = fields.Float(string='Rate (%)', digits=dp.get_precision('Payroll Rate'), default=100.0)
-    amount = fields.Float(digits=dp.get_precision('Payroll'))
-    quantity = fields.Float(digits=dp.get_precision('Payroll'), default=1.0)
-    total = fields.Float(compute='_compute_total', string='Total', digits=dp.get_precision('Payroll'), store=True)
-
-    @api.depends('quantity', 'amount', 'rate')
-    def _compute_total(self):
-        for line in self:
-            line.total = float(line.quantity) * line.amount * line.rate / 100
-
-    @api.model
-    def create(self, values):
-        if 'employee_id' not in values or 'contract_id' not in values:
-            payslip = self.env['hr.payslip'].browse(values.get('slip_id'))
-            values['employee_id'] = values.get('employee_id') or payslip.employee_id.id
-            values['contract_id'] = values.get('contract_id') or payslip.contract_id and payslip.contract_id.id
-            if not values['contract_id']:
-                raise UserError(_('You must set a contract to create a payslip line.'))
-        return super(HrPayslipLine, self).create(values)
-
-class HrEmployee(models.Model):
-    _inherit = 'hr.employee'
-    _description = 'Employee'
-
-    slip_ids = fields.One2many('hr.payslip', 'employee_id', string='Payslips', readonly=True)
-    payslip_count = fields.Integer(compute='_compute_payslip_count', string='Payslips', groups="hr_payroll.group_hr_payroll_user")
+    def draft_payslip_run(self):
+        return self.write({'state': 'draft'})
 
     @api.multi
-    def _compute_payslip_count(self):
-        for employee in self:
-            employee.payslip_count = len(employee.slip_ids)
+    def close_payslip_run(self):
+        return self.write({'state': 'close'})

--- a/None
+++ b/addons/hr_payroll/models/hr_salary_rule.py
@@ -0,0 +1,236 @@
+# -*- coding:utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from odoo import api, fields, models, _
+from odoo.exceptions import UserError
+from odoo.tools.safe_eval import safe_eval
+
+from odoo.addons import decimal_precision as dp
+
+class HrPayrollStructure(models.Model):
+    """
+    Salary structure used to defined
+    - Basic
+    - Allowances
+    - Deductions
+    """
+    _name = 'hr.payroll.structure'
+    _description = 'Salary Structure'
+
+    @api.model
+    def _get_parent(self):
+        return self.env.ref('hr_payroll.structure_base', False)
+
+    name = fields.Char(required=True)
+    code = fields.Char(string='Reference', required=True)
+    company_id = fields.Many2one('res.company', string='Company', required=True,
+        copy=False, default=lambda self: self.env['res.company']._company_default_get())
+    note = fields.Text(string='Description')
+    parent_id = fields.Many2one('hr.payroll.structure', string='Parent', default=_get_parent)
+    children_ids = fields.One2many('hr.payroll.structure', 'parent_id', string='Children', copy=True)
+    rule_ids = fields.Many2many('hr.salary.rule', 'hr_structure_salary_rule_rel', 'struct_id', 'rule_id', string='Salary Rules')
+
+    @api.constrains('parent_id')
+    def _check_parent_id(self):
+        if not self._check_recursion():
+            raise ValidationError(_('Error ! You cannot create a recursive Salary Structure.'))
+
+    @api.multi
+    def copy(self, default=None):
+        self.ensure_one()
+        default = dict(default or {}, code=_("%s (copy)") % (self.code))
+        return super(HrPayrollStructure, self).copy(default)
+
+    @api.multi
+    def get_all_rules(self):
+        """
+        @return: returns a list of tuple (id, sequence) of rules that are maybe to apply
+        """
+        all_rules = []
+        for struct in self:
+            all_rules += struct.rule_ids._recursive_search_of_rules()
+        return all_rules
+
+    @api.multi
+    def _get_parent_structure(self):
+        parent = self.mapped('parent_id')
+        if parent:
+            parent = parent._get_parent_structure()
+        return parent + self
+
+
+class HrContributionRegister(models.Model):
+    _name = 'hr.contribution.register'
+    _description = 'Contribution Register'
+
+    company_id = fields.Many2one('res.company', string='Company',
+        default=lambda self: self.env['res.company']._company_default_get())
+    partner_id = fields.Many2one('res.partner', string='Partner')
+    name = fields.Char(required=True)
+    register_line_ids = fields.One2many('hr.payslip.line', 'register_id',
+        string='Register Line', readonly=True)
+    note = fields.Text(string='Description')
+
+
+class HrSalaryRuleCategory(models.Model):
+    _name = 'hr.salary.rule.category'
+    _description = 'Salary Rule Category'
+
+    name = fields.Char(required=True)
+    code = fields.Char(required=True)
+    parent_id = fields.Many2one('hr.salary.rule.category', string='Parent',
+        help="Linking a salary category to its parent is used only for the reporting purpose.")
+    children_ids = fields.One2many('hr.salary.rule.category', 'parent_id', string='Children')
+    note = fields.Text(string='Description')
+    company_id = fields.Many2one('res.company', string='Company',
+        default=lambda self: self.env['res.company']._company_default_get())
+
+
+class HrSalaryRule(models.Model):
+    _name = 'hr.salary.rule'
+
+    name = fields.Char(required=True)
+    code = fields.Char(required=True,
+        help="The code of salary rules can be used as reference in computation of other rules. "
+             "In that case, it is case sensitive.")
+    sequence = fields.Integer(required=True, index=True, default=5,
+        help='Use to arrange calculation sequence')
+    quantity = fields.Char(default='1.0',
+        help="It is used in computation for percentage and fixed amount. "
+             "For e.g. A rule for Meal Voucher having fixed amount of "
+             u"1€ per worked day can have its quantity defined in expression "
+             "like worked_days.WORK100.number_of_days.")
+    category_id = fields.Many2one('hr.salary.rule.category', string='Category', required=True)
+    active = fields.Boolean(default=True,
+        help="If the active field is set to false, it will allow you to hide the salary rule without removing it.")
+    appears_on_payslip = fields.Boolean(string='Appears on Payslip', default=True,
+        help="Used to display the salary rule on payslip.")
+    parent_rule_id = fields.Many2one('hr.salary.rule', string='Parent Salary Rule', index=True)
+    company_id = fields.Many2one('res.company', string='Company',
+        default=lambda self: self.env['res.company']._company_default_get())
+    condition_select = fields.Selection([
+        ('none', 'Always True'),
+        ('range', 'Range'),
+        ('python', 'Python Expression')
+    ], string="Condition Based on", default='none', required=True)
+    condition_range = fields.Char(string='Range Based on', default='contract.wage',
+        help='This will be used to compute the % fields values; in general it is on basic, '
+             'but you can also use categories code fields in lowercase as a variable names '
+             '(hra, ma, lta, etc.) and the variable basic.')
+    condition_python = fields.Text(string='Python Condition', required=True,
+        default='''
+                    # Available variables:
+                    #----------------------
+                    # payslip: object containing the payslips
+                    # employee: hr.employee object
+                    # contract: hr.contract object
+                    # rules: object containing the rules code (previously computed)
+                    # categories: object containing the computed salary rule categories (sum of amount of all rules belonging to that category).
+                    # worked_days: object containing the computed worked days
+                    # inputs: object containing the computed inputs
+
+                    # Note: returned value have to be set in the variable 'result'
+
+                    result = rules.NET > categories.NET * 0.10''',
+        help='Applied this rule for calculation if condition is true. You can specify condition like basic > 1000.')
+    condition_range_min = fields.Float(string='Minimum Range', help="The minimum amount, applied for this rule.")
+    condition_range_max = fields.Float(string='Maximum Range', help="The maximum amount, applied for this rule.")
+    amount_select = fields.Selection([
+        ('percentage', 'Percentage (%)'),
+        ('fix', 'Fixed Amount'),
+        ('code', 'Python Code'),
+    ], string='Amount Type', index=True, required=True, default='fix', help="The computation method for the rule amount.")
+    amount_fix = fields.Float(string='Fixed Amount', digits=dp.get_precision('Payroll'))
+    amount_percentage = fields.Float(string='Percentage (%)', digits=dp.get_precision('Payroll Rate'),
+        help='For example, enter 50.0 to apply a percentage of 50%')
+    amount_python_compute = fields.Text(string='Python Code',
+        default='''
+                    # Available variables:
+                    #----------------------
+                    # payslip: object containing the payslips
+                    # employee: hr.employee object
+                    # contract: hr.contract object
+                    # rules: object containing the rules code (previously computed)
+                    # categories: object containing the computed salary rule categories (sum of amount of all rules belonging to that category).
+                    # worked_days: object containing the computed worked days.
+                    # inputs: object containing the computed inputs.
+
+                    # Note: returned value have to be set in the variable 'result'
+
+                    result = contract.wage * 0.10''')
+    amount_percentage_base = fields.Char(string='Percentage based on', help='result will be affected to a variable')
+    child_ids = fields.One2many('hr.salary.rule', 'parent_rule_id', string='Child Salary Rule', copy=True)
+    register_id = fields.Many2one('hr.contribution.register', string='Contribution Register',
+        help="Eventual third party involved in the salary payment of the employees.")
+    input_ids = fields.One2many('hr.rule.input', 'input_id', string='Inputs', copy=True)
+    note = fields.Text(string='Description')
+
+    @api.multi
+    def _recursive_search_of_rules(self):
+        """
+        @return: returns a list of tuple (id, sequence) which are all the children of the passed rule_ids
+        """
+        children_rules = []
+        for rule in self.filtered(lambda rule: rule.child_ids):
+            children_rules += rule.child_ids._recursive_search_of_rules()
+        return [(rule.id, rule.sequence) for rule in self] + children_rules
+
+    #TODO should add some checks on the type of result (should be float)
+    @api.multi
+    def compute_rule(self, localdict):
+        """
+        :param localdict: dictionary containing the environement in which to compute the rule
+        :return: returns a tuple build as the base/amount computed, the quantity and the rate
+        :rtype: (float, float, float)
+        """
+        self.ensure_one()
+        if self.amount_select == 'fix':
+            try:
+                return self.amount_fix, float(safe_eval(self.quantity, localdict)), 100.0
+            except:
+                raise UserError(_('Wrong quantity defined for salary rule %s (%s).') % (self.name, self.code))
+        elif self.amount_select == 'percentage':
+            try:
+                return (float(safe_eval(self.amount_percentage_base, localdict)),
+                        float(safe_eval(self.quantity, localdict)),
+                        self.amount_percentage)
+            except:
+                raise UserError(_('Wrong percentage base or quantity defined for salary rule %s (%s).') % (self.name, self.code))
+        else:
+            try:
+                safe_eval(self.amount_python_compute, localdict, mode='exec', nocopy=True)
+                return float(localdict['result']), 'result_qty' in localdict and localdict['result_qty'] or 1.0, 'result_rate' in localdict and localdict['result_rate'] or 100.0
+            except:
+                raise UserError(_('Wrong python code defined for salary rule %s (%s).') % (self.name, self.code))
+
+    @api.multi
+    def satisfy_condition(self, localdict):
+        """
+        @param contract_id: id of hr.contract to be tested
+        @return: returns True if the given rule match the condition for the given contract. Return False otherwise.
+        """
+        self.ensure_one()
+
+        if self.condition_select == 'none':
+            return True
+        elif self.condition_select == 'range':
+            try:
+                result = safe_eval(self.condition_range, localdict)
+                return self.condition_range_min <= result and result <= self.condition_range_max or False
+            except:
+                raise UserError(_('Wrong range condition defined for salary rule %s (%s).') % (self.name, self.code))
+        else:  # python code
+            try:
+                safe_eval(self.condition_python, localdict, mode='exec', nocopy=True)
+                return 'result' in localdict and localdict['result'] or False
+            except:
+                raise UserError(_('Wrong python condition defined for salary rule %s (%s).') % (self.name, self.code))
+
+
+class HrRuleInput(models.Model):
+    _name = 'hr.rule.input'
+    _description = 'Salary Rule Input'
+
+    name = fields.Char(string='Description', required=True)
+    code = fields.Char(required=True, help="The code that can be used in the salary rules")
+    input_id = fields.Many2one('hr.salary.rule', string='Salary Rule Input', required=True)
