PR: https://github.com/odoo/odoo/pull/64925

From: bc9bc2686ca142a7348dc48e0b7f8e74fdd42e10
From: Krupal Oza
Date: 2021-03-24 15:16:42

Structural Changes: 1
Total Changes: 108

[IMP] calendar: improve main data templates

Purpose of this commit is to make templates easier to preview and edit as
weel as to improve their content.

This is achieved notably by lessening use of custom rendering context and
trying to fix as much error-prone jinja statements.

In this commit we also make ``calendar_template_meeting_reminder`` template
looking more like other templates. There were some rendering differences that
do not seem really wanted.

``calendar_template_meeting_reminder`` was also using an old ``force_event_id``
key not replaced by recurrent_id field on attendee.

This commit improves few strings of the invitation mail being sent while
booking an online appointment. Online appointment is computed based on
``appointment_type_id`` field being defined. Some tweaks in wording made it
necessary to know if recipient is the responsible, customer or an added
attendee on the event, leading to some tooling code added on event model.

The main changes includes

 * for customer, remove the CTAs to accept / decline event as attendee are
   automatically set as accepted;
 * depending on recipient, improve wording of the mail accordingly and mention
   appointment type in the mail;

Task ID-2199620
COM PR odoo/odoo#64925
ENT PR odoo/enterprise#15914
UPG PR odoo/upgrade#2282

Co-Authored-By: Krupal Oza <koz@odoo.com>
Co-Authored-By: Thibault Delavallee <tde@odoo.com>

================================= pseudo patch: =================================

--- a/addons/calendar/models/calendar_alarm_manager.py
+++ b/addons/calendar/models/calendar_alarm_manager.py
@@ -167,10 +167,9 @@ class AlarmManager(models.AbstractModel):
         # Executed via cron
         events = self._get_events_to_notify('email')
         attendees = events.attendee_ids.filtered(lambda a: a.state != 'declined')
-        attendees._send_mail_to_attendees(
+        attendees.with_context(calendar_template_ignore_recurrence=True)._send_mail_to_attendees(
             'calendar.calendar_template_meeting_reminder',
             force_send=True,
-            ignore_recurrence=True,
         )
 
     @api.model

--- a/addons/calendar/models/calendar_attendee.py
+++ b/addons/calendar/models/calendar_attendee.py
@@ -15,6 +15,7 @@ class Attendee(models.Model):
     _name = 'calendar.attendee'
     _rec_name = 'common_name'
     _description = 'Calendar Attendee Information'
+    _order = 'create_date ASC'
 
     def _default_access_token(self):
         return uuid.uuid4().hex
@@ -80,18 +81,16 @@ class Attendee(models.Model):
             partners = (event.attendee_ids & self).partner_id & event.message_partner_ids
             event.message_unsubscribe(partner_ids=partners.ids)
 
-    def _send_mail_to_attendees(self, template_xmlid, force_send=False, ignore_recurrence=False):
+    def _send_mail_to_attendees(self, template_xmlid, force_send=False):
         """ Send mail for event invitation to event attendees.
             :param template_xmlid: xml id of the email template to use to send the invitation
             :param force_send: if set to True, the mail(s) will be sent immediately (instead of the next queue processing)
-            :param ignore_recurrence: ignore event recurrence
         """
         res = False
 
         if self.env['ir.config_parameter'].sudo().get_param('calendar.block_mail') or self._context.get("no_mail_to_attendees"):
             return res
 
-        calendar_view = self.env.ref('calendar.view_calendar_event_calendar')
         invitation_template = self.env.ref(template_xmlid, raise_if_not_found=False)
         if not invitation_template:
             _logger.warning("Template %s could not be found. %s not notified." % (template_xmlid, self))
@@ -99,25 +98,8 @@ class Attendee(models.Model):
         # get ics file for all meetings
         ics_files = self.mapped('event_id')._get_ics_file()
 
-        # prepare rendering context for mail template
-        colors = {
-            'needsAction': 'grey',
-            'accepted': 'green',
-            'tentative': '#FFFF00',
-            'declined': 'red'
-        }
-        rendering_context = dict(self._context)
-        rendering_context.update({
-            'colors': colors,
-            'ignore_recurrence': ignore_recurrence,
-            'action_id': self.env['ir.actions.act_window'].sudo().search([('view_id', '=', calendar_view.id)], limit=1).id,
-            'dbname': self._cr.dbname,
-            'base_url': self.env['ir.config_parameter'].sudo().get_param('web.base.url', default='http://localhost:8069'),
-        })
-
         for attendee in self:
             if attendee.email and attendee.partner_id != self.env.user.partner_id:
-                # FIXME: is ics_file text or bytes?
                 event_id = attendee.event_id.id
                 ics_file = ics_files.get(event_id)
 
@@ -128,7 +110,7 @@ class Attendee(models.Model):
                                 'mimetype': 'text/calendar',
                                 'datas': base64.b64encode(ics_file)})
                     ]
-                body = invitation_template.with_context(rendering_context)._render_field(
+                body = invitation_template._render_field(
                     'body_html',
                     attendee.ids,
                     compute_lang=True,

--- a/addons/calendar/models/calendar_event.py
+++ b/addons/calendar/models/calendar_event.py
@@ -16,7 +16,7 @@ from odoo.addons.calendar.models.calendar_attendee import Attendee
 from odoo.addons.calendar.models.calendar_recurrence import weekday_to_field, RRULE_TYPE_SELECTION, END_TYPE_SELECTION, MONTH_BY_SELECTION, WEEKDAY_SELECTION, BYDAY_SELECTION
 from odoo.tools.translate import _
 from odoo.tools.misc import get_lang
-from odoo.tools import pycompat
+from odoo.tools import pycompat, html_escape
 from odoo.exceptions import UserError, ValidationError, AccessError
 
 _logger = logging.getLogger(__name__)
@@ -287,7 +287,11 @@ class Meeting(models.Model):
 
     def _compute_attendee(self):
         for meeting in self:
-            attendee = meeting._find_my_attendee()
+            attendee = next(
+                (attendee for attendee in self.attendee_ids
+                 if attendee.partner_id == self.env.user.partner_id),
+                self.env['calendar.attendee']
+            )
             meeting.attendee_status = attendee.state if attendee else 'needsAction'
 
     @api.constrains('start', 'stop', 'start_date', 'stop_date')
@@ -477,7 +481,11 @@ class Meeting(models.Model):
             start_date = fields.Datetime.to_datetime(values.get('start'))
             # Only notify on future events
             if start_date and start_date >= fields.Datetime.now():
-                (current_attendees & previous_attendees)._send_mail_to_attendees('calendar.calendar_template_meeting_changedate', ignore_recurrence=not update_recurrence)
+                (current_attendees & previous_attendees).with_context(
+                    calendar_template_ignore_recurrence=not update_recurrence
+                )._send_mail_to_attendees(
+                    'calendar.calendar_template_meeting_changedate'
+                )
 
         return True
 
@@ -713,15 +721,13 @@ class Meeting(models.Model):
             return attendee.do_decline()
         return attendee.do_tentative()
 
-    def _find_my_attendee(self):
-        """ Return the first attendee where the user connected has been invited
-            from all the meeting_ids in parameters.
-        """
+    def find_partner_customer(self):
         self.ensure_one()
-        for attendee in self.attendee_ids:
-            if self.env.user.partner_id == attendee.partner_id:
-                return attendee
-        return False
+        return next(
+            (attendee.partner_id for attendee in self.attendee_ids.sorted('create_date')
+             if attendee.partner_id != self.user_id.partner_id),
+            self.env['calendar.attendee']
+        )
 
     # ------------------------------------------------------------
     # TOOLS
@@ -920,3 +926,56 @@ class Meeting(models.Model):
             'id', 'active', 'allday',
             'duration', 'user_id', 'interval',
             'count', 'rrule', 'recurrence_id', 'show_as', 'privacy'}
+
+    def description_to_html_lines(self):
+        """ Description could contain some structure content, depending on
+        its use. Notably appointment could add some structured data in it
+        in addition to free text. Purpose of this method is to generate a
+        simple html.
+
+        Input (self.description) example:
+Some free text salespeople added
+as multi line
+ * Mobile: +320475000000
+ * Email: my.email@test.example.com
+ * SingleLine: answer
+ * MultiLine:
+Answer1
+Answer2
+Answer3
+ * Dropdown: answer
+ * Radio: answer
+ * Checkboxes: answer1, answer2
+Some free text salespeople added
+as multi line
+
+        Output: a list of items[
+'Some free text salespeople added<br />as multi line',
+'Mobile: +320475000000',
+'Email: my.email@test.example.com',
+'SingleLine: answer',
+'MultiLine:<br />Answer1<br />Answer2<br />Answer3',
+'Dropdown: answer',
+'Radio: answer',
+'Checkboxes: answer1, answer2',
+'Some free text salespeople added<br .>as multi line']
+
+        Each item of returned list is escaped so that only our intended <br />
+        are html tags. It should therefore be safe.
+        """
+
+        final_lines = []
+        parsed_lines = []
+        for line in self.description.split('\n'):
+            if not line.strip():
+                continue
+            # new line
+            if line.startswith(' *'):
+                if parsed_lines:
+                    final_lines.append('<br />'.join(html_escape(line) for line in parsed_lines))
+                parsed_lines = [line.lstrip(' *')]
+            else:
+                parsed_lines.append(line)
+        if parsed_lines:
+            final_lines.append('<br />'.join(html_escape(line) for line in parsed_lines))
+        return final_lines
