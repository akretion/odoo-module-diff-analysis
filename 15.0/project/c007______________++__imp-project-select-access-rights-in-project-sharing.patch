PR: https://github.com/odoo/odoo/pull/

From: 5ea5ddafea936ac53b2dd7b098c1da644c5bc577
From: Xavier BOL (xbo)
Date: 2021-08-26 12:59:33

Structural Changes: 5
Total Changes: 84

[IMP] project: select access rights in project sharing

Before this commit, when the portal user can access to project sharing
views, he can just read. If we just add ir.rule to allow the edition,
the portal could create/edit. We have to allow the project manager to
define the access rights of portal users when he want to share them a
project with the project sharing feature.

This commit adds 3 access modes portal users in project sharing views.
1. **Readonly**: the portal can only see the tasks in the different views.
2. **Comment**: the portal can use the chatter in task form view.
3. **Edit**: the portal user can create and edit tasks.

task-2379518

closes #73341

Co-Authored-by: Yannick Tivisse (yti) <yti@odoo.com>

================================= pseudo patch: =================================

--- a/addons/project/models/__init__.py
+++ b/addons/project/models/__init__.py
@@ -6,6 +6,7 @@ from . import project_milestone
 from . import project_project_stage
 from . import project_task_recurrence
 from . import project
+from . import project_sharing_access
 from . import project_update
 from . import res_config_settings
 from . import res_partner

--- a/addons/project/models/project.py
+++ b/addons/project/models/project.py
@@ -9,10 +9,11 @@ from random import randint
 
 from odoo import api, fields, models, tools, SUPERUSER_ID, _
 from odoo.exceptions import UserError, ValidationError, AccessError
-from odoo.osv.expression import OR
+from odoo.osv import expression
 
 from .project_task_recurrence import DAYS, WEEKS
 from .project_update import STATUS_COLOR
+from .project_sharing_access import PROJECT_SHARING_ACCESS_MODE
 
 
 PROJECT_TASK_READABLE_FIELDS = {
@@ -37,6 +38,7 @@ PROJECT_TASK_READABLE_FIELDS = {
     'displayed_image_id',
     'display_name',
     'priority',
+    'project_sharing_access_mode',
 }
 
 PROJECT_TASK_WRITABLE_FIELDS = {
@@ -280,6 +282,9 @@ class Project(models.Model):
     allow_task_dependencies = fields.Boolean('Task Dependencies', default=lambda self: self.env.user.has_group('project.group_project_task_dependencies'))
     tag_ids = fields.Many2many('project.tags', relation='project_project_project_tags_rel', string='Tags')
 
+    # Project Sharing fields
+    project_sharing_access_ids = fields.One2many('project.sharing.access', 'project_id', 'Project Sharing Access', copy=False)
+
     # rating fields
     rating_request_deadline = fields.Datetime(compute='_compute_rating_request_deadline', store=True)
     rating_active = fields.Boolean('Customer Ratings', default=lambda self: self.env.user.has_group('project.group_project_rating'))
@@ -695,6 +700,25 @@ class Project(models.Model):
             })
             project.write({'analytic_account_id': analytic_account.id})
 
+    def _check_project_sharing_access(self, access_mode='read'):
+        self.ensure_one()
+        if access_mode not in map(lambda access: access[0], PROJECT_SHARING_ACCESS_MODE):
+            raise ValidationError('The %s does not exists in project sharing accesses.' % access_mode)
+        if self.privacy_visibility != 'portal' or self.env.user._is_public():
+            return False
+        if self.env.user.has_group('base.group_portal'):
+            # check in project sharing access model of the project
+            project_sharing_access = self.project_sharing_access_ids.filtered(lambda access: access.user_id == self.env.user)
+            if not project_sharing_access:
+                return False
+            if access_mode == 'edit':
+                return project_sharing_access.access_mode == 'edit'
+            elif access_mode == 'comment':
+                return project_sharing_access.access_mode in ('comment', 'edit')
+            else:
+                return True
+        return self.env.user.has_group('base.group_user')
+
     # ---------------------------------------------------
     # Rating business
     # ---------------------------------------------------
@@ -856,6 +880,9 @@ class Task(models.Model):
     allow_task_dependencies = fields.Boolean(related='project_id.allow_task_dependencies')
     depend_on_ids = fields.Many2many('project.task', relation="task_dependencies_rel", column1="task_id", column2="depends_on_id", string="Blocked By", domain="[('allow_task_dependencies', '=', True), ('id', '!=', id)]")
 
+    # Project Sharing fields
+    project_sharing_access_mode = fields.Selection(PROJECT_SHARING_ACCESS_MODE, compute='_compute_project_sharing_access_mode')
+
     # recurrence fields
     allow_recurring_tasks = fields.Boolean(related='project_id.allow_recurring_tasks')
     recurring_task = fields.Boolean(string="Recurrent")
@@ -1162,6 +1189,26 @@ class Task(models.Model):
             else:
                 task.stage_id = False
 
+    @api.depends_context('uid')
+    @api.depends('project_id.project_sharing_access_ids', 'project_id.privacy_visibility')
+    def _compute_project_sharing_access_mode(self):
+        if self.env.user._is_public():
+            self.project_sharing_access_mode = False
+            return
+        portal_user = self.user_has_groups('base.group_portal')
+        project_sharings = self.project_id.filtered(lambda project: project.privacy_visibility == 'portal')
+        if portal_user:
+            project_sharing_access_read = self.env['project.sharing.access'].search_read(
+                [('user_id', '=', self.env.user.id), ('project_id', 'in', project_sharings.ids)],
+                ['project_id', 'access_mode']
+            )
+            project_sharing_access_dict = {res['project_id'][0]: res['access_mode'] for res in project_sharing_access_read}
+        for task in self:
+            if not portal_user:
+                task.project_sharing_access_mode = task.project_id in project_sharings and 'edit'
+                continue
+            task.project_sharing_access_mode = project_sharing_access_dict.get(task.project_id.id, False)
+
     @api.constrains('recurring_task')
     def _check_recurring_task(self):
         if self.filtered(lambda task: task.parent_id and task.recurring_task):
@@ -1241,10 +1288,10 @@ class Task(models.Model):
         readable_fields = self.SELF_READABLE_FIELDS
         public_fields = {field_name: description for field_name, description in fields.items() if field_name in readable_fields}
 
-            writable_fields = self.SELF_WRITABLE_FIELDS
-            for field_name, description in public_fields.items():
-                if field_name not in writable_fields and not description.get('readonly', False):
-                    # If the field is not in Writable fields and it is not readonly then we force the readonly to True
+        writable_fields = self.SELF_WRITABLE_FIELDS
+        for field_name, description in public_fields.items():
+            if field_name not in writable_fields and not description.get('readonly', False):
+                # If the field is not in Writable fields and it is not readonly then we force the readonly to True
                 description['readonly'] = True
 
         return public_fields
@@ -1412,7 +1459,7 @@ class Task(models.Model):
             recurrence_domain = []
             if recurrence_update == 'subsequent':
                 for task in self:
-                    recurrence_domain = OR([recurrence_domain, ['&', ('recurrence_id', '=', task.recurrence_id.id), ('create_date', '>=', task.create_date)]])
+                    recurrence_domain = expression.OR([recurrence_domain, ['&', ('recurrence_id', '=', task.recurrence_id.id), ('create_date', '>=', task.create_date)]])
             else:
                 recurrence_domain = [('recurrence_id', 'in', self.recurrence_id.ids)]
             tasks |= self.env['project.task'].search(recurrence_domain)

--- a/None
+++ b/addons/project/models/project_sharing_access.py
@@ -0,0 +1,24 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from odoo import fields, models
+
+
+PROJECT_SHARING_ACCESS_MODE = [
+    ('read', 'Read'),
+    ('comment', 'Comment'),
+    ('edit', 'Edit'),
+]
+
+
+class ProjectSharingAccess(models.Model):
+    _name = 'project.sharing.access'
+    _description = 'Project Sharing Access'
+
+    project_id = fields.Many2one('project.project', 'Project Shared', required=True)
+    user_id = fields.Many2one('res.users', string='Portal Users', domain=lambda self: [('groups_id', 'in', self.env.ref('base.group_portal').id)], required=True)
+    access_mode = fields.Selection(PROJECT_SHARING_ACCESS_MODE, string='Access Mode', required=True)
+
+    _sql_constraints = [
+        ('unique_user', 'UNIQUE(project_id, user_id)', 'A user cannot be selected more than once in the project sharing access. Please remove duplicate(s) and try again.'),
+    ]
