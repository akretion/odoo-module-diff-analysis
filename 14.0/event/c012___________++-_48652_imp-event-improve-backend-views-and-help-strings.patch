PR: https://github.com/odoo/odoo/pull/48652

From: 844909b0f1c1cd9ce3f198c9af44e0699f674c77
From: Thibault DelavallÃ©e
Date: 2020-04-03 11:07:55

Structural Changes: 8
Total Changes: 49

[IMP] event: improve backend views and help strings

Embedded tickets view: improve labels, start and end dates are now labeled
Sales Start and Sales End when having sale installed.

Help are added on event_registrations_open and start_sale_date to clearly
define what they mean.

Some linting is also performed to ease readability, notably some computed
fields reorganization to have them ordered by group like fields.

Task ID 2228189
Community PR odoo/odoo#48652

X-original-commit: e2deabc451aa2d62365b1e1b43ea3947907d2648

================================= pseudo patch: =================================

--- a/addons/event/models/event_event.py
+++ b/addons/event/models/event_event.py
@@ -90,6 +90,7 @@ class EventType(models.Model):
             if not template.has_seats_limitation:
                 template.seats_max = 0
 
+
 class EventEvent(models.Model):
     """Event"""
     _name = 'event.event'
@@ -121,7 +122,8 @@ class EventEvent(models.Model):
     event_mail_ids = fields.One2many(
         'event.mail', 'event_id', string='Mail Schedule', copy=True,
         compute='_compute_from_event_type', readonly=False, store=True)
-    tag_ids = fields.Many2many('event.tag', string="Tags", readonly=False,
+    tag_ids = fields.Many2many(
+        'event.tag', string="Tags", readonly=False,
         copy=True, store=True, compute="_compute_from_event_type")
     # Kanban fields
     kanban_state = fields.Selection([('normal', 'In Progress'), ('done', 'Done'), ('blocked', 'Blocked')], default='normal')
@@ -160,12 +162,17 @@ class EventEvent(models.Model):
     auto_confirm = fields.Boolean(
         string='Autoconfirmation',
         compute='_compute_from_event_type', copy=True, readonly=False, store=True,
-        help = 'Autoconfirm Registrations. Registrations will automatically be confirmed upon creation.')
+        help='Autoconfirm Registrations. Registrations will automatically be confirmed upon creation.')
     registration_ids = fields.One2many('event.registration', 'event_id', string='Attendees')
-    event_registrations_open = fields.Boolean('Registration open', compute='_compute_event_registrations_open')
     event_ticket_ids = fields.One2many(
         'event.event.ticket', 'event_id', string='Event Ticket', copy=True,
         compute='_compute_from_event_type', readonly=False, store=True)
+    event_registrations_open = fields.Boolean(
+        'Registration open', compute='_compute_event_registrations_open',
+        help='Registrations are open if seats are available on event and if tickets are sellable if ticketing is used.')
+    start_sale_date = fields.Date(
+        'Start sale date', compute='_compute_start_sale_date',
+        help='If ticketing is used, this is the lowest starting sale date of tickets.')
     # Date fields
     date_tz = fields.Selection(
         _tz_get, string='Timezone', required=True,
@@ -176,7 +183,6 @@ class EventEvent(models.Model):
     date_end_located = fields.Char(string='End Date Located', compute='_compute_date_end_tz')
     is_ongoing = fields.Boolean('Is Ongoing', compute='_compute_is_ongoing', search='_search_is_ongoing')
     is_one_day = fields.Boolean(compute='_compute_field_is_one_day')
-    start_sale_date = fields.Date('Start sale date', compute='_compute_start_sale_date')
     # Location and communication
     address_id = fields.Many2one(
         'res.partner', string='Venue', default=lambda self: self.env.company.partner_id.id,
@@ -191,6 +197,16 @@ class EventEvent(models.Model):
     badge_innerright = fields.Html(string='Badge Inner Right')
     event_logo = fields.Html(string='Event Logo')
 
+    @api.depends('stage_id', 'kanban_state')
+    def _compute_kanban_state_label(self):
+        for event in self:
+            if event.kanban_state == 'normal':
+                event.kanban_state_label = event.stage_id.legend_normal
+            elif event.kanban_state == 'blocked':
+                event.kanban_state_label = event.stage_id.legend_blocked
+            else:
+                event.kanban_state_label = event.stage_id.legend_done
+
     @api.depends('seats_max', 'registration_ids.state')
     def _compute_seats(self):
         """ Determine reserved, available, reserved but unconfirmed and used seats. """
@@ -227,20 +243,23 @@ class EventEvent(models.Model):
 
     @api.depends('date_end', 'seats_available', 'seats_limited', 'event_ticket_ids.sale_available')
     def _compute_event_registrations_open(self):
+        """ Compute whether people may take registrations for this event
+
+          * any ticket is available for sale (seats available) if any;
+          * seats are unlimited or seats are available;
+        """
         for event in self:
             event.event_registrations_open = event.date_end and (event.date_end > fields.Datetime.now()) and \
                 (event.seats_available or not event.seats_limited) and \
                 (not event.event_ticket_ids or any(ticket.sale_available for ticket in event.event_ticket_ids))
 
-    @api.depends('stage_id', 'kanban_state')
-    def _compute_kanban_state_label(self):
+    @api.depends('event_ticket_ids.start_sale_date')
+    def _compute_start_sale_date(self):
+        """ Compute the start sale date of an event. Currently lowest starting sale
+        date of tickets if they are used, of False. """
         for event in self:
-            if event.kanban_state == 'normal':
-                event.kanban_state_label = event.stage_id.legend_normal
-            elif event.kanban_state == 'blocked':
-                event.kanban_state_label = event.stage_id.legend_blocked
-            else:
-                event.kanban_state_label = event.stage_id.legend_done
+            start_dates = [ticket.start_sale_date for ticket in event.event_ticket_ids if ticket.start_sale_date]
+            event.start_sale_date = min(start_dates) if start_dates else False
 
     @api.depends('date_tz', 'date_begin')
     def _compute_date_begin_tz(self):
@@ -289,12 +308,6 @@ class EventEvent(models.Model):
             end_tz = fields.Datetime.context_timestamp(event, event.date_end)
             event.is_one_day = (begin_tz.date() == end_tz.date())
 
-    @api.depends('event_ticket_ids.start_sale_date')
-    def _compute_start_sale_date(self):
-        for event in self:
-            start_dates = [ticket.start_sale_date for ticket in event.event_ticket_ids if ticket.start_sale_date]
-            event.start_sale_date = min(start_dates) if start_dates else False
-
     @api.depends('event_type_id')
     def _compute_date_tz(self):
         for event in self:
