PR: https://github.com/odoo/odoo/pull/124297

From: e08a279afb976ce087fb933206724cd7a4926667
From: Horacio Tellez (hote)
Date: 2023-09-21 16:52:03

Structural Changes: 4
Total Changes: 155

[IMP] sales: confirm on down payment

Some businesses requires customers to pay a down payment in order
to confirm the order. In the case of odoo today this implies to:
 - sending a payment link
 - waiting & checking if theÂ payment has been done
 - confirming the order
 - creating the down payment invoice
A lot of time consuming manual operations with a high risk of errors.

This commit introduces the functionality for sales orders to be
confirmed on down payments and automatizes the flow to minimize the
errors due to human manipulation.

Task - 3087716

Part-of: odoo/odoo#124297
Co-authored-by: Victor Feyens <vfe@odoo.com>

================================= pseudo patch: =================================

--- a/addons/sale/models/payment_transaction.py
+++ b/addons/sale/models/payment_transaction.py
@@ -61,8 +61,9 @@ class PaymentTransaction(models.Model):
         """ Confirm the sales order based on the amount of a transaction.
 
         Confirm the sales orders only if the transaction amount (or the sum of the partial
-        transaction amounts) is equal to the total amount of the sales orders. Grouped payments
-        (paying multiple sales orders in one transaction) are not supported.
+        transaction amounts) is equal to or greater than the required amount for order confirmation
+
+        Grouped payments (paying multiple sales orders in one transaction) are not supported.
 
         :return: The confirmed sales orders.
         :rtype: a `sale.order` recordset
@@ -72,14 +73,9 @@ class PaymentTransaction(models.Model):
             # We only support the flow where exactly one quotation is linked to a transaction.
             if len(tx.sale_order_ids) == 1:
                 quotation = tx.sale_order_ids.filtered(lambda so: so.state in ('draft', 'sent'))
-                if quotation and len(quotation.transaction_ids.filtered(
-                    lambda tx: tx.state in ('authorized', 'done')  # Only consider confirmed tx
-                )) >= 1:
-                    if quotation.currency_id.compare_amounts(
-                        quotation.amount_total, quotation.amount_paid
-                    ) == 0:  # the SO is fully paid
-                        quotation.with_context(send_email=True).action_confirm()
-                        confirmed_orders |= quotation
+                if quotation and quotation._is_confirmation_amount_reached():
+                    quotation.with_context(send_email=True).action_confirm()
+                    confirmed_orders |= quotation
         return confirmed_orders
 
     def _set_authorized(self, state_message=None, **kwargs):
@@ -163,14 +159,25 @@ class PaymentTransaction(models.Model):
 
     def _invoice_sale_orders(self):
         for tx in self.filtered(lambda tx: tx.sale_order_ids):
-            # Create invoices
-            tx = tx.with_company(tx.company_id).with_context(company_id=tx.company_id.id)
+            tx = tx.with_company(tx.company_id)
+
             confirmed_orders = tx.sale_order_ids.filtered(lambda so: so.state == 'sale')
             if confirmed_orders:
-                confirmed_orders._force_lines_to_invoice_policy_order()
-                invoices = confirmed_orders.with_context(
+                # Filter orders between those fully paid and those partially paid.
+                fully_paid_orders = confirmed_orders.filtered(lambda so: so._is_paid())
+
+                # Create a down payment invoice for partially paid orders
+                downpayment_invoices = (
+                    confirmed_orders - fully_paid_orders
+                )._generate_downpayment_invoices()
+
+                # For fully paid orders create a final invoice.
+                fully_paid_orders._force_lines_to_invoice_policy_order()
+                final_invoices = fully_paid_orders.with_context(
                     raise_if_nothing_to_invoice=False
                 )._create_invoices(final=True)
+                invoices = downpayment_invoices + final_invoices
+
                 # Setup access token in advance to avoid serialization failure between
                 # edi postprocessing of invoice and displaying the sale order on the portal
                 for invoice in invoices:

--- a/addons/sale/models/res_company.py
+++ b/addons/sale/models/res_company.py
@@ -1,6 +1,7 @@
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
-from odoo import fields, models
+from odoo import _, api, fields, models
+from odoo.exceptions import ValidationError
 
 
 class ResCompany(models.Model):
@@ -16,6 +17,10 @@ class ResCompany(models.Model):
 
     portal_confirmation_sign = fields.Boolean(string="Online Signature", default=True)
     portal_confirmation_pay = fields.Boolean(string="Online Payment")
+    prepayment_percent = fields.Float(
+        string="Prepayment percentage",
+        default=1.0,
+        help="The percentage of the amount needed to be paid to confirm quotations.")
     quotation_validity_days = fields.Integer(
         string="Default Quotation Validity",
         default=30,
@@ -43,3 +48,9 @@ class ResCompany(models.Model):
             ('manual', "Manual Payment"),
         ],
         string="Sale onboarding selected payment method")
+
+    @api.constrains('prepayment_percent')
+    def _check_prepayment_percent(self):
+        for company in self:
+            if company.portal_confirmation_pay and not (0 < company.prepayment_percent <= 1.0):
+                raise ValidationError(_("Prepayment percentage must be a valid percentage."))

--- a/addons/sale/models/sale_order.py
+++ b/addons/sale/models/sale_order.py
@@ -94,14 +94,20 @@ class SaleOrder(models.Model):
         copy=False)
 
     require_signature = fields.Boolean(
-        string="Online Signature",
+        string="Online signature",
         compute='_compute_require_signature',
         store=True, readonly=False, precompute=True,
-        help="Request a online signature and/or payment to the customer in order to confirm orders automatically.")
+        help="Request a online signature from the customer to confirm the order.")
     require_payment = fields.Boolean(
-        string="Online Payment",
+        string="Online payment",
         compute='_compute_require_payment',
-        store=True, readonly=False, precompute=True)
+        store=True, readonly=False, precompute=True,
+        help="Request a online payment from the customer to confirm the order.")
+    prepayment_percent = fields.Float(
+        string="Prepayment percentage",
+        compute='_compute_prepayment_percent',
+        store=True, readonly=False, precompute=True,
+        help="The percentage of the amount needed that must be paid by the customer to confirm the order.")
 
     signature = fields.Image(
         string="Signature",
@@ -302,6 +308,11 @@ class SaleOrder(models.Model):
         for order in self:
             order.require_payment = order.company_id.portal_confirmation_pay
 
+    @api.depends('require_payment')
+    def _compute_prepayment_percent(self):
+        for order in self:
+            order.prepayment_percent = order.company_id.prepayment_percent
+
     @api.depends('company_id')
     def _compute_validity_date(self):
         today = fields.Date.context_today(self)
@@ -669,6 +680,12 @@ class SaleOrder(models.Model):
                     bad_products=', '.join(bad_products.mapped('display_name')),
                 ))
 
+    @api.constrains('prepayment_percent')
+    def _check_prepayment_percent(self):
+        for order in self:
+            if order.require_payment and not (0 < order.prepayment_percent <= 1.0):
+                raise ValidationError(_("Prepayment percentage must be a valid percentage."))
+
     #=== ONCHANGE METHODS ===#
 
     @api.onchange('commitment_date', 'expected_date')
@@ -734,6 +751,11 @@ class SaleOrder(models.Model):
     def _onchange_pricelist_id_show_update_prices(self):
         self.show_update_pricelist = bool(self.order_line)
 
+    @api.onchange('prepayment_percent')
+    def _onchange_prepayment_percent(self):
+        if not self.prepayment_percent:
+            self.require_payment = False
+
     #=== CRUD METHODS ===#
 
     @api.model_create_multi
@@ -1478,13 +1500,28 @@ class SaleOrder(models.Model):
 
     def _get_default_payment_link_values(self):
         self.ensure_one()
-        amount = self.amount_total - self.amount_paid
+        amount_max = self.amount_total - self.amount_paid
+
+        # Always default to the minimum value needed to confirm the order:
+        # - order is not confirmed yet
+        # - can be confirmed online
+        # - we have still not paid enough for confirmation.
+        prepayment_amount = self._get_prepayment_required_amount()
+        if (
+            self.state in ('draft', 'sent')
+            and self.require_payment
+            and self.currency_id.compare_amounts(prepayment_amount, self.amount_paid) > 0
+        ):
+            amount = prepayment_amount - self.amount_paid
+        else:
+            amount = amount_max
+
         return {
             'description': self.name,
             'currency_id': self.currency_id.id,
             'partner_id': self.partner_invoice_id.id,
             'amount': amount,
-            'amount_max': amount,
+            'amount_max': amount_max,
             'amount_paid': self.amount_paid,
         }
 
@@ -1649,6 +1686,52 @@ class SaleOrder(models.Model):
         del context
         return down_payments_section_line
 
+    def _get_prepayment_required_amount(self):
+        """ Return the minimum amount needed to confirm automatically the quotation.
+
+        Note: self.ensure_one()
+
+        :return: The minimum amount needed to confirm automatically the quotation.
+        :rtype: float
+        """
+        self.ensure_one()
+        if self.prepayment_percent == 1.0 or not self.require_payment:
+            return self.amount_total
+        else:
+            return self.currency_id.round(self.amount_total * self.prepayment_percent)
+
+    def _is_confirmation_amount_reached(self):
+        """ Return whether `self.amount_paid` is higher than the prepayment required amount.
+
+        Note: self.ensure_one()
+
+        :return: Whether `self.amount_paid` is higher than the prepayment required amount.
+        :rtype: bool
+        """
+        self.ensure_one()
+        amount_comparison = self.currency_id.compare_amounts(
+            self._get_prepayment_required_amount(), self.amount_paid,
+        )
+        return amount_comparison <= 0
+
+    def _generate_downpayment_invoices(self):
+        """ Generate invoices as down payments for sale order.
+
+        :return: The generated down payment invoices.
+        :rtype: recordset of `account.move`
+        """
+        generated_invoices = self.env['account.move']
+
+        for order in self:
+            downpayment_wizard = order.env['sale.advance.payment.inv'].create({
+                'sale_order_ids': order,
+                'advance_payment_method': 'fixed',
+                'fixed_amount': order.amount_paid,
+            })
+            generated_invoices |= downpayment_wizard._create_invoices(order)
+
+        return generated_invoices
+
     def _get_product_documents(self):
         self.ensure_one()
 
@@ -1684,3 +1767,15 @@ class SaleOrder(models.Model):
         """
         self.ensure_one()
         return self.state == 'cancel' or self.locked
+
+    def _is_paid(self):
+        """ Return whether the sale order is paid or not based on the linked transactions.
+
+        A sale order is considered paid if the sum of all the linked transaction is equal to or
+        higher than `self.amount_total`.
+
+        :return: Whether the sale order is paid or not.
+        :rtype: bool
+        """
+        self.ensure_one()
+        return self.currency_id.compare_amounts(self.amount_paid, self.amount_total) >= 0
