PR: https://github.com/odoo/odoo/pull/171079

From: 854c3b27aa5476c208572f19e64f8f3364bfc381
From: Antoine Dupuis (andu)
Date: 2024-08-14 22:26:41

Breaking data model changes scores: del:2.3999999999999995 + add:2, change matches:
-    company_currency_id = fields.Many2one(related='company_id.currency_id')
+    company_currency_id = fields.Many2one('res.currency', compute='_compute_company_currency_id')
+    code = fields.Char(string="Code", size=64, tracking=True, compute='_compute_code', search='_search_code', inverse='_inverse_code')
+    company_ids = fields.Many2many('res.company', string='Companies', required=True, readonly=False,
+    code_mapping_ids = fields.One2many(comodel_name='account.code.mapping', inverse_name='account_id')
-    group_id = fields.Many2one('account.group', compute='_compute_account_group', store=True, readonly=True,
+    group_id = fields.Many2one('account.group', compute='_compute_account_group',
-    root_id = fields.Many2one('account.root', compute='_compute_account_root', store=True, precompute=True)
+    root_id = fields.Many2one('account.root', compute='_compute_account_root', search='_search_account_root')
-    name = fields.Char()
-    parent_id = fields.Many2one('account.root')
-    company_id = fields.Many2one('res.company')
+    name = fields.Char(compute='_compute_root')
+    parent_id = fields.Many2one('account.root', compute='_compute_root')

Total Changes: 872

[IMP] account: Share accounts between companies.

In a nutshell:

At the moment, performing accounting duties needed for multi-company
consolidation is a pain in Odoo. The central accountant typically has
all companies active simultaneously, but because each company has a full
set of accounts, this multiplication of accounts makes it particularly
confusing to work with the CoA, accounting entries and reports. The CoA
and reports list duplicate accounts indiscriminately, while for journal
items it is difficult to see which account is actually used.

This commit aims to simplify the central accountant's life by letting
them manage a single chart of accounts that is shared between companies.

Each account now defines one or more companies which it is active on.
As previously, accounts active on a parent company may also be used in
its branches.

In addition, each account can now have a different code depending on the
company. For the account name, variations are expected to be per-
language rather than per-company, and should be handled via the existing
translation mechanism.

Starting from this commit, accounts should no longer be created
specifying a company. Instead, when creating an account, the `company`
context should be used to indicate which company the account starts
active on, and the given code will be assigned to that company.

Changes:
* Accounts no longer belong to a single company: we replace `company_id`
  by `company_ids`, which indicates which companies the account belongs
  to.
* `account.code` is now company-dependent.
* There is a constraint that forces `account.code` to be set for every
  company in `company_ids`. For this reason, if you need to create an
  account for 2 companies, first create it for one, then set the code
  for the second company using `account.with_company(...).code = ...`,
  then add the second company to `company_ids`.
* Account groups and account roots are now computed non-stored fields.
* Merge tool: Accounts that have the same type etc. can now be merged.
  Accounts belonging to different companies will keep their codes in
  their respective companies, and can be reversibly de-merged.
* De-merge tool: Accounts belonging to different companies can be
  de-merged.

closes odoo/odoo#171079

Related: odoo/enterprise#66077
Related: odoo/upgrade#6372
Signed-off-by: William Andr√© (wan) <wan@odoo.com>

================================= pseudo patch: =================================

--- a/addons/account/models/__init__.py
+++ b/addons/account/models/__init__.py
@@ -6,6 +6,8 @@ from . import ir_http
 from . import res_partner_bank
 from . import account_account_tag
 from . import account_account
+from . import account_code_mapping
+from . import account_root
 from . import account_journal
 from . import account_lock_exception
 from . import account_tax

--- a/addons/account/models/account_account.py
+++ b/addons/account/models/account_account.py
@@ -1,28 +1,27 @@
-# -*- coding: utf-8 -*-
-from contextlib import nullcontext
-
-from odoo import api, fields, models, _, tools, Command
-from odoo.osv import expression
-from odoo.exceptions import UserError, ValidationError
-from odoo.tools import SQL, Query
 from bisect import bisect_left
 from collections import defaultdict
-import logging
+import itertools
 import re
 
-_logger = logging.getLogger(__name__)
+from odoo import api, fields, models, _, Command
+from odoo.osv import expression
+from odoo.exceptions import UserError, ValidationError, RedirectWarning
+from odoo.tools import SQL, Query
+from odoo.addons.base.models.ir_property import TYPE2FIELD
+
 
 ACCOUNT_REGEX = re.compile(r'(?:(\S*\d+\S*))?(.*)')
 ACCOUNT_CODE_REGEX = re.compile(r'^[A-Za-z0-9.]+$')
 ACCOUNT_CODE_NUMBER_REGEX = re.compile(r'(.*?)(\d*)(\D*?)$')
 
+
 class AccountAccount(models.Model):
     _name = "account.account"
     _inherit = ['mail.thread']
     _description = "Account"
-    _order = "code, company_id"
+    _order = "code"
     _check_company_auto = True
-    _check_company_domain = models.check_company_domain_parent_of
+    _check_company_domain = models.check_companies_domain_parent_of
 
     @api.constrains('account_type', 'reconcile')
     def _check_reconcile(self):
@@ -34,7 +33,7 @@ class AccountAccount(models.Model):
     def _check_account_type_unique_current_year_earning(self):
         result = self._read_group(
             domain=[('account_type', '=', 'equity_unaffected')],
-            groupby=['company_id'],
+            groupby=['company_ids'],
             aggregates=['id:recordset'],
             having=[('__count', '>', 1)],
         )
@@ -44,8 +43,8 @@ class AccountAccount(models.Model):
     name = fields.Char(string="Account Name", required=True, index='trigram', tracking=True, translate=True)
     currency_id = fields.Many2one('res.currency', string='Account Currency', tracking=True,
         help="Forces all journal items in this account to have a specific currency (i.e. bank journals). If no currency is set, entries can use any currency.")
-    company_currency_id = fields.Many2one(related='company_id.currency_id')
-    code = fields.Char(size=64, required=True, tracking=True, index=True)
+    company_currency_id = fields.Many2one('res.currency', compute='_compute_company_currency_id')
+    code = fields.Char(string="Code", size=64, tracking=True, compute='_compute_code', search='_search_code', inverse='_inverse_code')
     deprecated = fields.Boolean(default=False, tracking=True)
     used = fields.Boolean(compute='_compute_used', search='_search_used')
     account_type = fields.Selection(
@@ -100,8 +99,9 @@ class AccountAccount(models.Model):
         check_company=True,
         context={'append_type_to_tax_name': True})
     note = fields.Text('Internal Notes', tracking=True)
-    company_id = fields.Many2one('res.company', string='Company', required=True, readonly=False,
+    company_ids = fields.Many2many('res.company', string='Companies', required=True, readonly=False,
         default=lambda self: self.env.company)
+    code_mapping_ids = fields.One2many(comodel_name='account.code.mapping', inverse_name='account_id')
     tag_ids = fields.Many2many(
         comodel_name='account.account.tag',
         relation='account_account_account_tag',
@@ -111,9 +111,9 @@ class AccountAccount(models.Model):
         ondelete='restrict',
         tracking=True,
     )
-    group_id = fields.Many2one('account.group', compute='_compute_account_group', store=True, readonly=True,
+    group_id = fields.Many2one('account.group', compute='_compute_account_group',
                                help="Account prefixes can determine account groups.")
-    root_id = fields.Many2one('account.root', compute='_compute_account_root', store=True, precompute=True)
+    root_id = fields.Many2one('account.root', compute='_compute_account_root', search='_search_account_root')
     allowed_journal_ids = fields.Many2many(
         'account.journal',
         string="Allowed Journals",
@@ -134,29 +134,31 @@ class AccountAccount(models.Model):
     def _field_to_sql(self, alias: str, fname: str, query: (Query | None) = None, flush: bool = True) -> SQL:
         if fname == 'internal_group':
             return SQL("split_part(account_account.account_type, '_', 1)", to_flush=self._fields['account_type'])
-        return super()._field_to_sql(alias, fname, query, flush)
-
-    @api.constrains('company_id', 'code')
-    def _constrains_code(self):
-        # check for duplicates in each root company
-        by_root_company = self.grouped(lambda record: record.company_id.root_id)
-        for root_company, records in by_root_company.items():
-            by_code = records.grouped('code')
-            if len(by_code) < len(records):
-                # retrieve duplicates within self
-                duplicates = next(recs for recs in by_code.values() if len(recs) > 1)
-            else:
-                # search for duplicates of self in database
-                duplicates = self.search([
-                    ('company_id', 'child_of', root_company.id),
-                    ('code', 'in', list(by_code)),
-                    ('id', 'not in', records.ids),
-                ])
-            if duplicates:
-                raise ValidationError(
-                    _("The code of the account must be unique per company!")
-                    + "\n" + "\n".join(f"- {duplicate.code} in {duplicate.company_id.name}" for duplicate in duplicates)
+        if fname == 'code':
+            field = self._fields.get(fname)
+
+            company_dependent_field_alias = query.make_alias(alias, f'{field.name}_company_dependent')
+            query.add_join('LEFT JOIN', alias=company_dependent_field_alias, table='ir_property', condition=SQL(
+                    """
+                        %(ir_property_fields_id)s = %(field_id)s
+                        AND %(ir_property_company_id)s = %(root_company_id)s
+                        AND %(ir_property_res_id)s = 'account.account,' || %(account_id)s::text
+                    """,
+                    ir_property_fields_id=self.env['ir.property']._field_to_sql(company_dependent_field_alias, 'fields_id'),
+                    field_id=self.env['ir.model.fields']._get(self._name, field.name).id,
+                    ir_property_company_id=self.env['ir.property']._field_to_sql(company_dependent_field_alias, 'company_id'),
+                    root_company_id=self.env.company.root_id.id,
+                    ir_property_res_id=self.env['ir.property']._field_to_sql(company_dependent_field_alias, 'res_id'),
+                    account_id=SQL.identifier(alias, 'id'),
                 )
+            )
+
+            # This is the field on ir.property that will contain the value of 'code'.
+            value_field = self.env['ir.property']._fields[TYPE2FIELD[field.type]]
+
+            return self.env['ir.property']._field_to_sql(company_dependent_field_alias, value_field.name)
+
+        return super()._field_to_sql(alias, fname, query, flush)
 
     @api.constrains('reconcile', 'account_type', 'tax_ids')
     def _constrains_reconcile(self):
@@ -255,14 +257,19 @@ class AccountAccount(models.Model):
                 account=account.display_name
             ))
 
-    @api.constrains('company_id')
+    @api.constrains('company_ids')
     def _check_company_consistency(self):
-        for company, accounts in tools.groupby(self, lambda account: account.company_id):
-            if self.env['account.move.line'].search_count([
-                ('account_id', 'in', [account.id for account in accounts]),
-                '!', ('company_id', 'child_of', company.id)
+        if accounts_without_company := self.filtered(lambda a: not a.sudo().company_ids):
+            raise ValidationError(
+                _("The following accounts must be assigned to at least one company:")
+                + "\n" + "\n".join(f"- {account.display_name}" for account in accounts_without_company)
+            )
+        for companies, accounts in self.grouped(lambda a: a.company_ids).items():
+            if self.env['account.move.line'].sudo().search_count([
+                ('account_id', 'in', accounts.ids),
+                '!', ('company_id', 'child_of', companies.ids)
             ], limit=1):
-                raise UserError(_("You can't change the company of your account since there are some journal items linked to it."))
+                raise UserError(_("You can't unlink this company from this account since there are some journal items linked to it."))
 
     @api.constrains('account_type')
     def _check_account_type_sales_purchase_journal(self):
@@ -325,7 +332,7 @@ class AccountAccount(models.Model):
     @api.constrains('code')
     def _check_account_code(self):
         for account in self:
-            if not re.match(ACCOUNT_CODE_REGEX, account.code):
+            if account.code and not re.match(ACCOUNT_CODE_REGEX, account.code):
                 raise ValidationError(_(
                     "The account code can only contain alphanumeric characters and dots."
                 ))
@@ -346,20 +353,83 @@ class AccountAccount(models.Model):
         if self._cr.fetchone():
             raise ValidationError(_("You cannot change the type of an account set as Bank Account on a journal to Receivable or Payable."))
 
+    @api.depends_context('company')
+    def _compute_code(self):
+        values = self.env['ir.property'].with_company(self.env.company.root_id).sudo()._get_multi('code', 'account.account', self.ids)
+        for record in self:
+            # Need to set record.code with `company = self.env.company`, not `self.env.company.root_id`
+            record.code = values.get(record.id)
+
+    def _search_code(self, operator, value):
+        return self._fields['code']._search_company_dependent(self.with_company(self.env.company.root_id), operator, value)
+
+    def _inverse_code(self):
+        values = {
+            # Need to access record.code with `company = self.env.company`
+            record.id: self._fields['code'].convert_to_write(record.code, record)
+            for record in self
+        }
+        self.env['ir.property'].with_company(self.env.company.root_id).sudo()._set_multi('code', 'account.account', values)
+
+    @api.depends_context('company')
     @api.depends('code')
     def _compute_account_root(self):
-        # this computes the first 2 digits of the account.
-        # This field should have been a char, but the aim is to use it in a side panel view with hierarchy, and it's only supported by many2one fields so far.
-        # So instead, we make it a many2one to a psql view with what we need as records.
         for record in self:
-            record.root_id = (ord(record.code[0]) * 1000 + ord(record.code[1:2] or '\x00')) if record.code else False
+            record.root_id = self.env['account.root']._from_account_code(record.code)
+
+    def _search_account_root(self, operator, value):
+        if operator in ['=', 'child_of']:
+            root = self.env['account.root'].browse(value)
+            return [('code', '=like', root.name + ('' if operator == '=' and not root.parent_id else '%'))]
+        raise NotImplementedError
+
+    def _search_panel_domain_image(self, field_name, domain, set_count=False, limit=False):
+        if field_name != 'root_id' or set_count:
+            return super()._search_panel_domain_image(field_name, domain, set_count, limit)
+
+        if expression.is_false(self, domain):
+            return {}
+
+        query_account = self.env['account.account']._search(domain, limit=limit)
+        account_code_alias = self.env['account.account']._field_to_sql('account_account', 'code', query_account)
+
+        account_codes = self.env.execute_query(query_account.select(account_code_alias))
+        return {
+            (root := self.env['account.root']._from_account_code(code)).id: {'id': root.id, 'display_name': root.display_name}
+            for code, in account_codes if code
+        }
 
+    @api.depends_context('company')
     @api.depends('code')
     def _compute_account_group(self):
-        if self.ids:
-            self.env['account.group']._adapt_accounts_for_account_groups(self)
-        else:
-            self.group_id = False
+        accounts_with_code = self.filtered(lambda a: a.code)
+
+        (self - accounts_with_code).group_id = False
+
+        if not accounts_with_code:
+            return
+
+        codes = accounts_with_code.mapped('code')
+        account_code_values = SQL(','.join(['(%s)'] * len(codes)), *codes)
+        results = self.env.execute_query(SQL(
+            """
+                 SELECT DISTINCT ON (account_code.code)
+                        account_code.code,
+                        agroup.id AS group_id
+                   FROM (VALUES %(account_code_values)s) AS account_code (code)
+              LEFT JOIN account_group agroup
+                     ON agroup.code_prefix_start <= LEFT(account_code.code, char_length(agroup.code_prefix_start))
+                        AND agroup.code_prefix_end >= LEFT(account_code.code, char_length(agroup.code_prefix_end))
+                        AND agroup.company_id = %(root_company_id)s
+               ORDER BY account_code.code, char_length(agroup.code_prefix_start) DESC, agroup.id
+            """,
+            account_code_values=account_code_values,
+            root_company_id=self.env.company.root_id.id,
+        ))
+        group_by_code = dict(results)
+
+        for account in accounts_with_code:
+            account.group_id = group_by_code[account.code]
 
     def _search_used(self, operator, value):
         if operator not in ['=', '!='] or not isinstance(value, bool):
@@ -378,7 +448,7 @@ class AccountAccount(models.Model):
             record.used = record.id in ids
 
     @api.model
-    def _search_new_account_code(self, start_code, company, cache=None):
+    def _search_new_account_code(self, start_code, cache=None):
         """ Get an available account code by starting from an existing code
             and incrementing it until an available code is found.
 
@@ -394,7 +464,6 @@ class AccountAccount(models.Model):
                 |     9998     |  9999, 9998.copy, 9998.copy2, 9998.copy3, ...              |
 
             :param start_code str: the code to increment until an available one is found
-            :param res.company company: the company for which to find an available account code
             :param set[str] cache: a set of codes which you know are already used
                                     (optional, to speed up the method).
                                     If none is given, the method will use cache = {start_code}.
@@ -413,7 +482,7 @@ class AccountAccount(models.Model):
             cache = {start_code}
 
         def code_is_available(new_code):
-            return new_code not in cache and not self.search_count([('code', '=', new_code), ('company_id', 'child_of', company.root_id.id)], limit=1)
+            return new_code not in cache and not self.search_count([('code', '=', new_code)], limit=1)
 
         if code_is_available(start_code):
             return start_code
@@ -432,11 +501,12 @@ class AccountAccount(models.Model):
 
         raise UserError(_('Cannot generate an unused account code.'))
 
+    @api.depends_context('company')
     def _compute_current_balance(self):
         balances = {
             account.id: balance
             for account, balance in self.env['account.move.line']._read_group(
-                domain=[('account_id', 'in', self.ids), ('parent_state', '=', 'posted')],
+                domain=[('account_id', 'in', self.ids), ('parent_state', '=', 'posted'), ('company_id', '=', self.env.company.id)],
                 groupby=['account_id'],
                 aggregates=['balance:sum'],
             )
@@ -444,29 +514,40 @@ class AccountAccount(models.Model):
         for record in self:
             record.current_balance = balances.get(record.id, 0)
 
+    @api.depends_context('company')
     def _compute_related_taxes_amount(self):
         for record in self:
             record.related_taxes_amount = self.env['account.tax'].search_count([
+                *self.env['account.tax']._check_company_domain(self.env.company),
                 ('repartition_line_ids.account_id', '=', record.id),
             ])
 
+    @api.depends_context('company')
+    def _compute_company_currency_id(self):
+        self.company_currency_id = self.env.company.currency_id
+
+    @api.depends_context('company')
     def _compute_opening_debit_credit(self):
         self.opening_debit = 0
         self.opening_credit = 0
         self.opening_balance = 0
-        if not self.ids:
+        opening_move = self.env.company.account_opening_move_id
+        if not self.ids or not opening_move:
             return
-        self.env.cr.execute("""
+        self.env.cr.execute(SQL(
+            """
             SELECT line.account_id,
                    SUM(line.balance) AS balance,
                    SUM(line.debit) AS debit,
                    SUM(line.credit) AS credit
               FROM account_move_line line
-              JOIN res_company comp ON comp.id = line.company_id
-             WHERE line.move_id = comp.account_opening_move_id
-               AND line.account_id IN %s
+             WHERE line.move_id = %(opening_move_id)s
+               AND line.account_id IN %(account_ids)s
              GROUP BY line.account_id
-        """, [tuple(self.ids)])
+            """,
+            account_ids=tuple(self.ids),
+            opening_move_id=opening_move.id,
+        ))
         result = {r['account_id']: r for r in self.env.cr.dictfetchall()}
         for record in self:
             res = result.get(record.id) or {'debit': 0, 'credit': 0, 'balance': 0}
@@ -496,18 +577,18 @@ class AccountAccount(models.Model):
         assert field_name in self._fields
 
         all_accounts = self.search_read(
-            domain=[('company_id', 'in', accounts_to_process.company_id.ids)],
-            fields=['code', field_name, 'company_id'],
+            domain=self._check_company_domain(self.env.company),
+            fields=['code', field_name],
             order='code',
         )
-        accounts_with_codes = defaultdict(dict)
+        accounts_with_codes = {}
         # We want to group accounts by company to only search for account codes of the current company
         for account in all_accounts:
-            accounts_with_codes[account['company_id'][0]][account['code']] = account[field_name]
+            accounts_with_codes[account['code']] = account[field_name]
         for account in accounts_to_process:
-            codes_list = list(accounts_with_codes[account.company_id.id].keys())
+            codes_list = list(accounts_with_codes.keys())
             closest_index = bisect_left(codes_list, account.code) - 1
-            account[field_name] = accounts_with_codes[account.company_id.id][codes_list[closest_index]] if closest_index != -1 else default_value
+            account[field_name] = accounts_with_codes[codes_list[closest_index]] if closest_index != -1 else default_value
 
     @api.depends('account_type')
     def _compute_include_initial_balance(self):
@@ -572,9 +653,9 @@ class AccountAccount(models.Model):
             self._cr.precommit.add(self._load_precommit_update_opening_move)
         else:
             data = self._cr.precommit.data['import_account_opening_balance']
-        data.setdefault(self.id, [None, None])
+        data.setdefault(self.env.company.id, {}).setdefault(self.id, [None, None])
         index = 0 if field == 'debit' else 1
-        data[self.id][index] = amount
+        data[self.env.company.id][self.id][index] = amount
 
     @api.model
     def default_get(self, default_fields):
@@ -623,18 +704,22 @@ class AccountAccount(models.Model):
             _kind, rhs_table, condition = query._joins['account_move_line__account_id']
             query._joins['account_move_line__account_id'] = (SQL("RIGHT JOIN"), rhs_table, condition)
 
+        company = self.env['res.company'].browse(company_id)
+        code_sql = self.with_company(company)._field_to_sql('account_move_line__account_id', 'code', query)
+
         return [r[0] for r in self.env.execute_query(SQL(
             """
-            SELECT account_move_line__account_id.id
-              FROM %s
-             WHERE %s
-          GROUP BY account_move_line__account_id.id
-          ORDER BY COUNT(account_move_line.id) DESC, account_move_line__account_id.code
-                %s
+                SELECT account_move_line__account_id.id
+                  FROM %(from_clause)s
+                 WHERE %(where_clause)s
+              GROUP BY account_move_line__account_id.id
+              ORDER BY COUNT(account_move_line.id) DESC, MAX(%(code_sql)s)
+                %(limit_clause)s
             """,
-            query.from_clause,
-            query.where_clause or SQL("TRUE"),
-            SQL("LIMIT %s", limit) if limit else SQL(),
+            from_clause=query.from_clause,
+            where_clause=query.where_clause or SQL("TRUE"),
+            code_sql=code_sql,
+            limit_clause=SQL("LIMIT %s", limit) if limit else SQL(),
         ))]
 
     @api.model
@@ -679,24 +764,38 @@ class AccountAccount(models.Model):
             self.name = name
             self.code = code
 
+    @api.depends_context('company')
     @api.depends('code')
     def _compute_display_name(self):
         for account in self:
             account.display_name = f"{account.code} {account.name}"
 
     def copy_data(self, default=None):
-        default = dict(default or {})
         vals_list = super().copy_data(default)
-        cache_map = defaultdict(set)
+        default = default or {}
+
+        # We must restrict check_company fields to values available to the company of the new account.
+        fields_to_filter_by_company = {field for field in self._fields.values() if field.relational and field.check_company}
+        cache = defaultdict(set)
         for account, vals in zip(self, vals_list):
+            match vals.get('company_ids'):
+                case [(Command.LINK, company_id, 0)] | [(Command.SET, 0, [company_id])] | [company_id] if isinstance(company_id, int):
+                    company = self.env['res.company'].browse(company_id)
+                case _:
+                    raise ValueError(_("You may only give an account a single company at creation."))
             if 'code' not in default:
-                company = default.get('company_id', account.company_id)
-                company = company if isinstance(company, models.BaseModel) else account.env['res.company'].browse(company)
-                cache = cache_map[company.id]
-                vals['code'] = account._search_new_account_code(account.code, company, cache)
-                cache.add(vals['code'])
+                start_code = account.with_company(company).code or account.with_company(account.company_ids[0]).code
+                vals['code'] = account.with_company(company)._search_new_account_code(start_code, cache[company])
+                cache[company].add(vals['code'])
             if 'name' not in default:
                 vals['name'] = _("%s (copy)", account.name or '')
+
+            # For check_company fields, only keep values that are compatible with the new account's company.
+            for field in fields_to_filter_by_company:
+                if field.name not in default:
+                    corecord = account[field.name]
+                    filtered_corecord = corecord.filtered_domain(corecord._check_company_domain(company))
+                    vals[field.name] = filtered_corecord.id if field.type == 'many2one' else [Command.set(filtered_corecord.ids)]
         return vals_list
 
     def copy_translations(self, new, excluded=()):
@@ -718,14 +817,12 @@ class AccountAccount(models.Model):
         to update the opening move accordingly.
         """
         data = self._cr.precommit.data.pop('import_account_opening_balance', {})
-        accounts = self.browse(data.keys())
-
-        accounts_per_company = defaultdict(lambda: self.env['account.account'])
-        for account in accounts:
-            accounts_per_company[account.company_id] |= account
 
-        for company, company_accounts in accounts_per_company.items():
-            company._update_opening_move({account: data[account.id] for account in company_accounts})
+        for company_id, account_values in data.items():
+            self.env['res.company'].browse(company_id)._update_opening_move({
+                self.env['account.account'].browse(account_id): values
+                for account_id, values in account_values.items()
+            })
 
     def _toggle_reconcile_to_true(self):
         '''Toggle the `reconcile¬¥ boolean from False -> True
@@ -783,16 +880,27 @@ class AccountAccount(models.Model):
 
     @api.model_create_multi
     def create(self, vals_list):
-        cache_map = defaultdict(list)
-        for vals in vals_list:
-            if 'prefix' in vals:
-                company = self.env['res.company'].browse(vals.get('company_id')) or self.env.company
-                cache = cache_map[company.id]
-                prefix, digits = vals.pop('prefix'), vals.pop('code_digits')
-                start_code = prefix.ljust(digits-1, '0') + '1' if len(prefix) < digits else prefix
-                vals['code'] = self._search_new_account_code(start_code, company, cache)
-                cache.append(vals['code'])
-        return super().create(vals_list)
+        records_list = []
+        for company_ids, vals_list_for_company in itertools.groupby(vals_list, lambda v: v.get('company_ids')):
+            match company_ids:
+                case None:
+                    company = self.env.company
+                case [(Command.LINK, company_id, *_)] | [(Command.SET, 0, [company_id])] | [company_id] if isinstance(company_id, int):
+                    company = self.env['res.company'].browse(company_id)
+                case _:
+                    raise ValueError(_("You may only give an account a single company at creation."))
+            cache = set()
+            vals_list_for_company = list(vals_list_for_company)
+            for vals in vals_list_for_company:
+                if 'prefix' in vals:
+                    prefix, digits = vals.pop('prefix'), vals.pop('code_digits')
+                    start_code = prefix.ljust(digits - 1, '0') + '1' if len(prefix) < digits else prefix
+                    vals['code'] = self.with_company(company)._search_new_account_code(start_code, cache)
+                    cache.add(vals['code'])
+            records_list.append(super(AccountAccount, self.with_company(company)).create(vals_list_for_company))
+        records = self.env['account.account'].union(*records_list)
+        records.with_context(allowed_company_ids=records.company_ids.ids)._ensure_code_is_unique()
+        return records
 
     def write(self, vals):
         if 'reconcile' in vals:
@@ -805,8 +913,37 @@ class AccountAccount(models.Model):
             for account in self:
                 if self.env['account.move.line'].search_count([('account_id', '=', account.id), ('currency_id', 'not in', (False, vals['currency_id']))]):
                     raise UserError(_('You cannot set a currency on this account as it already has some journal entries having a different foreign currency.'))
+        res = super().write(vals)
+        if {'company_ids', 'code'} & vals.keys():
+            self._ensure_code_is_unique()
+        return res
 
-        return super(AccountAccount, self).write(vals)
+    def _ensure_code_is_unique(self):
+        """ Ensure that for each company to which the account belongs, the code is set
+        and that codes are unique per-company. """
+        accounts = self.sudo()
+        for account in accounts:
+            for company in account.company_ids:
+                if not account.with_company(company).code:
+                    raise ValidationError(_("The code must be set for every company to which this account belongs."))
+        accounts_with_code = accounts.filtered(lambda a: a.code)
+        accounts_by_code = accounts_with_code.grouped('code')
+        duplicate_codes = None
+        if len(accounts_by_code) < len(accounts_with_code):
+            duplicate_codes = [code for code, accounts in accounts_by_code.items() if len(accounts) > 1]
+        # search for duplicates of self in database
+        elif duplicates := self.sudo().search_fetch(
+            [
+                ('code', 'in', list(accounts_by_code)),
+                ('id', 'not in', self.ids),
+            ],
+            ['code'],
+        ):
+            duplicate_codes = duplicates.mapped('code')
+        if duplicate_codes:
+            raise ValidationError(
+                _("Account codes must be unique. You can't create accounts with these duplicate codes: %s", ", ".join(duplicate_codes))
+            )
 
     def _load_records_write(self, values):
         if 'prefix' in values:
@@ -864,6 +1001,195 @@ class AccountAccount(models.Model):
     def _merge_method(self, destination, source):
         raise UserError(_("You cannot merge accounts."))
 
+    def action_merge(self):
+        """ Merge the accounts in `self`:
+            - the first one is extended to each company of the accounts in `self`, keeping their codes and names;
+            - the others are deleted; and
+            - journal items and other references are retargeted to the first account.
+
+            If the companies of several accounts overlap, this is an accounting operation, so we check that no impacted entries are in a locked period.
+            If the companies don't overlap, from an accounting perspective, each company still has its own independent view of the account.
+        """
+        # Step 1: Perform checks and get account to merge into.
+        account_to_merge_into, code_by_company = self._check_action_merge_possible()
+
+        # Step 2: If needed, ask the user for confirmation.
+        self._action_merge_get_user_confirmation(account_to_merge_into)
+
+        # Step 3: Perform merge.
+        self._action_merge(account_to_merge_into, code_by_company)
+
+        return {
+            'type': 'ir.actions.client',
+            'tag': 'display_notification',
+            'params': {
+                'type': 'success',
+                'sticky': False,
+                'message': _("Accounts successfully merged!"),
+                'next': {'type': 'ir.actions.act_window_close'},
+            }
+        }
+
+    def _check_action_merge_possible(self):
+        """ Perform checks to determine whether the accounts in `self` can be merged,
+        and return an account to merge the others into.
+
+        :return: (account_to_merge_into, code_by_company)
+        where account_to_merge_into is the account that other accounts should be merged into,
+        and code_by_company is a dict of the codes that should be given to the merged account.
+        """
+        if len(self) < 2:
+            raise UserError(_("You must select at least 2 accounts to merge."))
+
+        for field in ['currency_id', 'deprecated', 'account_type', 'reconcile', 'non_trade']:
+            if len(set(self.mapped(field))) > 1:
+                raise UserError(_(
+                    "You may only merge accounts that have the same account type, currency, deprecated status, "
+                    "reconciliation status, and trade/non-trade receivable status."
+                ))
+
+        # If there are hashed entries in an account, then the merge must preserve that account's.
+        accounts_with_hashed_entries = self.filtered(
+            lambda a: self.env['account.move.line'].sudo().search_count([
+                ('account_id', '=', a.id),
+                ('parent_state', '=', 'posted'),
+                ('move_id.inalterable_hash', '!=', False)
+            ], limit=1)
+        )
+
+        match len(accounts_with_hashed_entries):
+            case 0:
+                account_to_merge_into = None
+                code_by_company = {}
+            case 1:
+                # If exactly one of the accounts contains hashed entries, we must merge the other ones into it,
+                # otherwise the hash will be broken.
+                account_to_merge_into = accounts_with_hashed_entries
+                code_by_company = {company: account_to_merge_into.with_company(company).sudo().code for company in account_to_merge_into.company_ids}
+            case _:
+                raise UserError(_(
+                    "Accounts %s contain hashed entries, so cannot be merged.",
+                    ", ".join(accounts_with_hashed_entries.mapped('display_name'))
+                ))
+
+        # If there are locked entries in an account, then the merge must preserve that account's code in the companies of those locked entries.
+        accounts_by_company = defaultdict(lambda: self.env['account.account'])
+        for account in self:
+            for company in account.company_ids:
+                accounts_by_company[company] |= account
+
+        for company, accounts in accounts_by_company.items():
+            if len(accounts) > 1 and (user_lock_date := max(company.user_fiscalyear_lock_date, company.user_hard_lock_date)):
+                locked_accounts = accounts.filtered(
+                    lambda a: self.env['account.move.line'].sudo().search_count([
+                        ('account_id', '=', a.id),
+                        ('company_id', '=', company.id),
+                        ('parent_state', '=', 'posted'),
+                        ('date', '<=', user_lock_date),
+                    ], limit=1)
+                )
+                if not locked_accounts:
+                    pass
+                elif company in code_by_company and locked_accounts != account_to_merge_into:
+                    raise UserError(_(
+                        "Company %(company_name)s (lock date %(lock_date)s): "
+                        "cannot merge account %(hashed_account_name)s that contains hashed entries "
+                        "with accounts %(locked_account_names)s that contain locked entries.",
+                        company_name=company.name,
+                        lock_date=user_lock_date,
+                        hashed_account_name=account_to_merge_into.display_name,
+                        locked_account_names=", ".join(a.display_name for a in locked_accounts - account_to_merge_into),
+                    ))
+                elif len(locked_accounts) == 1:
+                    code_by_company[company] = locked_accounts.with_company(company).sudo().code
+                else:
+                    raise UserError(_(
+                        "Company %(company_name)s (lock date %(lock_date)s): "
+                        "cannot merge accounts %(locked_account_names)s that both contain locked entries.",
+                        company_name=company.name,
+                        lock_date=user_lock_date,
+                        locked_account_names=", ".join(account.display_name for account in locked_accounts),
+                    ))
+            else:
+                code_by_company[company] = accounts[0].with_company(company).sudo().code
+
+        return account_to_merge_into or self[0], code_by_company
+
+    def _action_merge_get_user_confirmation(self, account_to_merge_into):
+        """ Open a RedirectWarning asking the user whether to proceed with the merge. """
+        if self.env.context.get('account_merge_confirm'):
+            return
+
+        is_irreversible = len(self.company_ids) != sum(len(account.company_ids) for account in self)
+        accounts_to_remove = self - account_to_merge_into
+
+        msg = _("Are you sure? This will perform the following operations:\n")
+        for account in accounts_to_remove:
+            msg += _(
+                "- %(account_1)s (company: %(companies_1)s) will be merged into %(account_2)s (company: %(companies_2)s)\n",
+                account_1=account.with_company(account.company_ids[:1]).display_name,
+                companies_1=",".join(account.company_ids.mapped('name')),
+                account_2=account_to_merge_into.with_company(account_to_merge_into.company_ids[:1]).display_name,
+                companies_2=",".join(account_to_merge_into.company_ids.mapped('name')),
+            )
+        if is_irreversible:
+            msg += _(
+                "This cannot be undone because you are merging accounts belonging to the same company.\n"
+                "After merging, we won't be able to separate journal items based on which account they originally referenced."
+            )
+        action = self.env['ir.actions.actions']._for_xml_id('account.action_merge_accounts')
+        raise RedirectWarning(msg, action, _("Merge"), additional_context={**self.env.context, 'account_merge_confirm': True})
+
+    def _action_merge(self, account_to_merge_into, code_by_company):
+        """ Perform the merge of the accounts in `self` into `account_to_merge_into`.
+        This will update the account codes of `account_to_merge_into` based on those of `self`,
+        and update keys in DB from `self` to `account_to_merge_into`.
+        This method expects checks to already have been performed.
+        """
+        # Step 1: Keep track of the company_ids we should write on the account.
+        # We will do so only at the end, to avoid triggering the constraint that prevents duplicate codes.
+        # Writing the codes will be handled by the update of ir_property.
+        company_ids_to_write = self.sudo().company_ids
+
+        # Step 2: Check that we have write access to all the accounts and access to all the companies
+        # of these accounts.
+        self.check_access_rights('write')
+        self.check_access_rule('write')
+        if forbidden_companies := (self.sudo().company_ids - self.env.user.company_ids):
+            raise UserError(_(
+                "You do not have the right to perform this operation as you do not have access to the following companies: %s.",
+                ", ".join(c.name for c in forbidden_companies)
+            ))
+
+        # Step 3: Update records in DB.
+        accounts_to_remove = self - account_to_merge_into
+
+        # 3.1: Update foreign keys in DB
+        wiz = self.env['base.partner.merge.automatic.wizard'].new()
+        wiz._update_foreign_keys_generic('account.account', accounts_to_remove, account_to_merge_into)
+
+        # 3.2: Update Reference and Many2OneReference fields that reference account.account
+        wiz._update_reference_fields_generic('account.account', accounts_to_remove, account_to_merge_into)
+
+        # Step 4: Remove merged accounts
+        self.env.invalidate_all()
+        self.env.cr.execute(SQL(
+            """
+             DELETE FROM account_account
+              WHERE id IN %(account_ids_to_delete)s
+            """,
+            account_ids_to_delete=tuple(accounts_to_remove.ids),
+        ))
+
+        # Clear ir.model.data ormcache
+        self.env.registry.clear_cache()
+
+        # Step 5: Write company_ids and codes on the account
+        for company, code in code_by_company.items():
+            account_to_merge_into.with_company(company).sudo().code = code
+
+        account_to_merge_into.sudo().company_ids = company_ids_to_write
+
 
 class AccountGroup(models.Model):
     _name = "account.group"
@@ -952,74 +1278,21 @@ class AccountGroup(models.Model):
     @api.model_create_multi
     def create(self, vals_list):
         groups = super().create([self._sanitize_vals(vals) for vals in vals_list])
-        groups._adapt_accounts_for_account_groups()
         groups._adapt_parent_account_group()
         return groups
 
     def write(self, vals):
         res = super(AccountGroup, self).write(self._sanitize_vals(vals))
         if 'code_prefix_start' in vals or 'code_prefix_end' in vals:
-            self._adapt_accounts_for_account_groups()
             self._adapt_parent_account_group()
         return res
 
     def unlink(self):
         for record in self:
-            account_ids = self.env['account.account'].search([('group_id', '=', record.id)])
-            account_ids.write({'group_id': record.parent_id.id})
-
             children_ids = self.env['account.group'].search([('parent_id', '=', record.id)])
             children_ids.write({'parent_id': record.parent_id.id})
         return super().unlink()
 
-    def _adapt_accounts_for_account_groups(self, account_ids=None, company=None):
-        """Ensure consistency between accounts and account groups.
-
-        Find and set the most specific group matching the code of the account.
-        The most specific is the one with the longest prefixes and with the starting
-        prefix being smaller than the account code and the ending prefix being greater.
-        """
-        if self.env.context.get('delay_account_group_sync'):
-            return
-
-        self.flush_model()
-        self.env['account.account'].flush_model(['code'])
-
-        if company:
-            company_ids = company.root_id.ids
-        elif account_ids:
-            company_ids = account_ids.company_id.root_id.ids
-            account_ids = account_ids.ids
-        else:
-            company_ids = self.company_id.ids
-            account_ids = []
-        if not company_ids and not account_ids:
-            return
-        account_where_clause = SQL('account.company_id IN %s', tuple(company_ids))
-        if account_ids:
-            account_where_clause = SQL('%s AND account.id IN %s', account_where_clause, tuple(account_ids))
-
-        self._cr.execute(SQL("""
-            WITH relation AS (
-                 SELECT DISTINCT ON (account.id)
-                        account.id AS account_id,
-                        agroup.id AS group_id
-                   FROM account_account account
-                   JOIN res_company account_company ON account_company.id = account.company_id
-              LEFT JOIN account_group agroup
-                     ON agroup.code_prefix_start <= LEFT(account.code, char_length(agroup.code_prefix_start))
-                    AND agroup.code_prefix_end >= LEFT(account.code, char_length(agroup.code_prefix_end))
-                    AND agroup.company_id = split_part(account_company.parent_path, '/', 1)::int
-                  WHERE %s
-               ORDER BY account.id, char_length(agroup.code_prefix_start) DESC, agroup.id
-            )
-            UPDATE account_account
-               SET group_id = rel.group_id
-              FROM relation rel
-             WHERE account_account.id = rel.account_id
-        """, account_where_clause))
-        self.env['account.account'].invalidate_model(['group_id'], flush=False)
-
     def _adapt_parent_account_group(self, company=None):
         """Ensure consistency of the hierarchy of account groups.
 
@@ -1062,31 +1335,3 @@ class AccountGroup(models.Model):
         updated_rows = self.env.cr.fetchall()
         if updated_rows:
             self.invalidate_model(['parent_id'])
-
-
-class AccountRoot(models.Model):
-    _name = 'account.root'
-    _description = 'Account codes first 2 digits'
-    _auto = False
-
-    name = fields.Char()
-    parent_id = fields.Many2one('account.root')
-    company_id = fields.Many2one('res.company')
-
-    def init(self):
-        tools.drop_view_if_exists(self.env.cr, self._table)
-        self.env.execute_query(SQL('''
-            CREATE OR REPLACE VIEW %s AS (
-            SELECT DISTINCT ASCII(code) * 1000 + ASCII(SUBSTRING(code,2,1)) AS id,
-                   LEFT(code,2) AS name,
-                   ASCII(code) AS parent_id,
-                   company_id
-            FROM account_account WHERE code != ''
-            UNION ALL
-            SELECT DISTINCT ASCII(code) AS id,
-                   LEFT(code,1) AS name,
-                   NULL::int AS parent_id,
-                   company_id
-            FROM account_account WHERE code != ''
-            )''', SQL.identifier(self._table)
-        ))

--- a/addons/account/models/account_bank_statement_line.py
+++ b/addons/account/models/account_bank_statement_line.py
@@ -505,7 +505,7 @@ class AccountBankStatementLine(models.Model):
     def _get_default_amls_matching_domain(self):
         self.ensure_one()
         all_reconcilable_account_ids = self.env['account.account'].search([
-            ("company_id", "child_of", self.company_id.root_id.id),
+            ("company_ids", "child_of", self.company_id.root_id.id),
             ('reconcile', '=', True),
         ]).ids
         return [

--- a/None
+++ b/addons/account/models/account_code_mapping.py
@@ -0,0 +1,63 @@
+from odoo import fields, models
+from odoo.tools import Query
+
+
+class AccountCodeMapping(models.Model):
+    _name = 'account.code.mapping'
+    _description = "Mapping of account codes per company"
+    _auto = False
+    _table_query = '0'
+
+    account_id = fields.Many2one(
+        comodel_name='account.account',
+        string="Account",
+        compute='_compute_self',
+    )
+    company_id = fields.Many2one(
+        comodel_name='res.company',
+        string="Company",
+        compute='_compute_self',
+    )
+    code = fields.Char(
+        string="Code",
+        compute='_compute_self',
+        inverse='_inverse_code',
+    )
+
+    def browse(self, ids=None):
+        if isinstance(ids, str):
+            ids = (ids,)
+        return super().browse(ids)
+
+    def _search(self, domain, offset=0, limit=None, order=None) -> Query:
+        match domain:
+            case [('id', 'in', ids)]:
+                return self.browse(sorted(ids))._as_query()
+            case [('account_id', 'in', account_ids)]:
+                self_ids = {
+                    f'{account_id},{company.id}'
+                    for company in self.env.companies
+                    for account_id in account_ids
+                }
+                return self.browse(sorted(self_ids))._as_query()
+        raise NotImplementedError
+
+    def _compute_self(self):
+        for record in self:
+            (account_id, company_id) = record._origin.id.split(',')
+            # If record is a NewId, then record.account_id and record.company_id should be too
+            # in order to behave correctly in onchange.
+            if isinstance(record.id, models.NewId):
+                record.account_id = models.NewId(int(account_id))
+                record.company_id = models.NewId(int(company_id))
+            else:
+                record.account_id = int(account_id)
+                record.company_id = int(company_id)
+        # Do this in a separate loop, so that prefetching can happen if needed
+        for record in self:
+            account = record.account_id.with_company(record.company_id._origin)
+            record.code = account.code
+
+    def _inverse_code(self):
+        for record in self:
+            record.account_id.with_company(record.company_id._origin).code = record.code

--- a/addons/account/models/account_journal.py
+++ b/addons/account/models/account_journal.py
@@ -583,19 +583,19 @@ class AccountJournal(models.Model):
     def copy_data(self, default=None):
         default = dict(default or {})
         vals_list = super().copy_data(default)
-        codes_by_company = {
-            company: set(self.env['account.journal'].with_context(active_test=False)._read_group(
-                domain=self.env['account.journal']._check_company_domain(company),
+        code_by_company_id = {
+            company_id: set(self.env['account.journal'].with_context(active_test=False)._read_group(
+                domain=self.env['account.journal']._check_company_domain(company_id),
                 aggregates=['code:array_agg'],
             )[0][0])
-            for company in self.company_id
+            for company_id, _ in groupby(vals_list, lambda v: v['company_id'])
         }
         for journal, vals in zip(self, vals_list):
             # Find a unique code for the copied journal
-            all_journal_codes = codes_by_company[journal.company_id]
+            all_journal_codes = code_by_company_id[vals['company_id']]
 
-            copy_code = journal.code
-            code_prefix = re.sub(r'\d+', '', journal.code).strip()
+            copy_code = vals['code']
+            code_prefix = re.sub(r'\d+', '', copy_code).strip()
             counter = 1
             while counter <= len(all_journal_codes) and copy_code in all_journal_codes:
                 counter_str = str(counter)
@@ -746,7 +746,7 @@ class AccountJournal(models.Model):
             'code': code,
             'account_type': 'asset_cash',
             'currency_id': vals.get('currency_id'),
-            'company_id': company.id,
+            'company_ids': [Command.link(company.id)],
         }
 
     @api.model
@@ -765,7 +765,7 @@ class AccountJournal(models.Model):
         vals['company_id'] = company.id
 
         # Don't get the digits on 'chart_template' since the chart template could be a custom one.
-        random_account = self.env['account.account'].search(
+        random_account = self.env['account.account'].with_company(company).search(
             self.env['account.account']._check_company_domain(company),
             limit=1,
         )
@@ -787,7 +787,7 @@ class AccountJournal(models.Model):
             # === Fill missing accounts ===
             if not has_liquidity_accounts:
                 start_code = liquidity_account_prefix.ljust(digits, '0')
-                default_account_code = self.env['account.account']._search_new_account_code(start_code, company)
+                default_account_code = self.env['account.account'].with_company(company)._search_new_account_code(start_code)
                 default_account_vals = self._prepare_liquidity_account_vals(company, default_account_code, vals)
                 default_account = self.env['account.account'].create(default_account_vals)
                 self.env['ir.model.data']._update_xmlids([

--- a/addons/account/models/account_journal_dashboard.py
+++ b/addons/account/models/account_journal_dashboard.py
@@ -84,8 +84,7 @@ class account_journal(models.Model):
         today = fields.Date.context_today(self)
         activities = defaultdict(list)
         # search activity on move on the journal
-        lang = self.env.user.lang or get_lang(self.env).code
-        act_type_name = self.with_context(lang=lang).env['mail.activity.type']._field_to_sql('act_type', 'name')
+        act_type_name = self.env['mail.activity.type']._field_to_sql('act_type', 'name')
         sql_query = SQL(
             """
             SELECT activity.id,

--- a/addons/account/models/account_move.py
+++ b/addons/account/models/account_move.py
@@ -3251,23 +3251,29 @@ class AccountMove(models.Model):
             domain.append(('account_id.internal_group', '=', 'expense'))
 
         query = self.env['account.move.line']._where_calc(domain)
+        account_code = self.env['account.account']._field_to_sql('account_move_line__account_id', 'code', query)
         rows = self.env.execute_query(SQL("""
             SELECT COUNT(foo.id), foo.account_id, foo.taxes
               FROM (
                          SELECT account_move_line__account_id.id AS account_id,
-                                account_move_line__account_id.code,
+                                %(account_code)s AS code,
                                 account_move_line.id,
                                 ARRAY_AGG(tax_rel.account_tax_id) FILTER (WHERE tax_rel.account_tax_id IS NOT NULL) AS taxes
-                           FROM %s
+                           FROM %(from_clause)s
                       LEFT JOIN account_move_line_account_tax_rel tax_rel ON account_move_line.id = tax_rel.account_move_line_id
-                          WHERE %s
+                          WHERE %(where_clause)s
                        GROUP BY account_move_line__account_id.id,
+                                %(account_code)s,
                                 account_move_line.id
                    ) AS foo
-          GROUP BY foo.account_id, foo.code, foo.taxes
-          ORDER BY COUNT(foo.id) DESC, foo.code, taxes ASC NULLS LAST
+          GROUP BY foo.account_id, foo.taxes
+          ORDER BY COUNT(foo.id) DESC, taxes ASC NULLS LAST
              LIMIT 1
-        """, query.from_clause, query.where_clause or SQL("TRUE")))
+            """,
+            account_code=account_code,
+            from_clause=query.from_clause,
+            where_clause=query.where_clause or SQL("TRUE"),
+        ))
         return rows[0] if rows else (0, False, False)
 
     def _get_quick_edit_suggestions(self):

--- a/addons/account/models/account_move_line.py
+++ b/addons/account/models/account_move_line.py
@@ -282,7 +282,7 @@ class AccountMoveLine(models.Model):
     account_root_id = fields.Many2one(
         related='account_id.root_id',
         string="Account Root",
-        store=True,
+        depends_context='company',
     )
     product_category_id = fields.Many2one(related='product_id.product_tmpl_id.categ_id')
 
@@ -576,13 +576,15 @@ class AccountMoveLine(models.Model):
                   ORDER BY property.company_id, property.name, account_id
                 ),
                 fallback AS (
-                    SELECT DISTINCT ON (account.company_id, account.account_type)
+                    SELECT DISTINCT ON (account_companies.res_company_id, account.account_type)
                            'res.company' AS model,
-                           account.company_id AS id,
+                           account_companies.res_company_id AS id,
                            account.account_type AS account_type,
                            account.id AS account_id
                       FROM account_account account
-                     WHERE account.company_id = ANY(%(company_ids)s)
+                      JOIN account_account_res_company_rel account_companies
+                           ON account_companies.account_account_id = account.id
+                     WHERE account_companies.res_company_id = ANY(%(company_ids)s)
                        AND account.account_type IN ('asset_receivable', 'liability_payable')
                        AND account.deprecated = 'f'
                 )
@@ -1812,17 +1814,27 @@ class AccountMoveLine(models.Model):
             return {}
 
         # Override in order to not read the complete move line table and use the index instead
-        query = self._search(domain, limit=1)
-        query.add_where('account.id = account_move_line.account_id')
-        id_rows = self.env.execute_query(SQL("""
-            SELECT account.root_id
-              FROM account_account account,
-                   LATERAL (%s) line
-             WHERE account.company_id IN %s
-        """, query.select(), tuple(self.env.companies.ids)))
+        query_account = self.env['account.account']._search([('company_ids', '=', self.env.companies.ids)])
+        account_code_alias = self.env['account.account']._field_to_sql('account_account', 'code', query_account)
+
+        query_line = self._search(domain, limit=1)
+        query_line.add_where('account_account.id = account_move_line.account_id')
+
+        account_codes = self.env.execute_query(SQL(
+            """
+            SELECT %(account_code_alias)s AS code
+              FROM %(account_table)s,
+                   LATERAL (%(line_select)s) line
+             WHERE %(where_clause)s
+            """,
+            account_code_alias=account_code_alias,
+            account_table=query_account.from_clause,
+            line_select=query_line.select(),
+            where_clause=query_account.where_clause,
+        ))
         return {
-            root.id: {'id': root.id, 'display_name': root.display_name}
-            for root in self.env['account.root'].browse(id_ for [id_] in id_rows)
+            (root := self.env['account.root']._from_account_code(code)).id: {'id': root.id, 'display_name': root.display_name}
+            for code, in account_codes
         }
 
     # -------------------------------------------------------------------------
@@ -2494,13 +2506,13 @@ class AccountMoveLine(models.Model):
             partials[index].exchange_move_id = exchange_move
 
         # ==== Create entries for cash basis taxes ====
-        def is_cash_basis_needed(account):
-            return account.company_id.tax_exigibility \
-                and account.account_type in ('asset_receivable', 'liability_payable')
+        def is_cash_basis_needed(amls):
+            return any(amls.company_id.mapped('tax_exigibility')) \
+                and amls.account_id.account_type in ('asset_receivable', 'liability_payable')
 
         if not self._context.get('move_reverse_cancel') and not self._context.get('no_cash_basis'):
             for plan in plan_list:
-                if is_cash_basis_needed(plan['amls'].account_id):
+                if is_cash_basis_needed(plan['amls']):
                     plan['partials']._create_tax_cash_basis_moves()
 
         # ==== Prepare full reconcile creation ====
@@ -2588,7 +2600,7 @@ class AccountMoveLine(models.Model):
                 # If we are fully reversing the entry, no need to fix anything since the journal entry
                 # is exactly the mirror of the source journal entry.
                 caba_lines_to_reconcile = None
-                if is_cash_basis_needed(involved_amls.account_id) and not self._context.get('move_reverse_cancel'):
+                if is_cash_basis_needed(involved_amls) and not self._context.get('move_reverse_cancel'):
                     caba_lines_to_reconcile = involved_amls._add_exchange_difference_cash_basis_vals(exchange_diff_values)
 
                 # Prepare the exchange difference.

--- a/addons/account/models/account_payment.py
+++ b/addons/account/models/account_payment.py
@@ -573,7 +573,7 @@ class AccountPayment(models.Model):
                 if pay.partner_id:
                     pay.destination_account_id = pay.partner_id.with_company(pay.company_id).property_account_receivable_id
                 else:
-                    pay.destination_account_id = self.env['account.account'].search([
+                    pay.destination_account_id = self.env['account.account'].with_company(pay.company_id).search([
                         *self.env['account.account']._check_company_domain(pay.company_id),
                         ('account_type', '=', 'asset_receivable'),
                         ('deprecated', '=', False),
@@ -583,7 +583,7 @@ class AccountPayment(models.Model):
                 if pay.partner_id:
                     pay.destination_account_id = pay.partner_id.with_company(pay.company_id).property_account_payable_id
                 else:
-                    pay.destination_account_id = self.env['account.account'].search([
+                    pay.destination_account_id = self.env['account.account'].with_company(pay.company_id).search([
                         *self.env['account.account']._check_company_domain(pay.company_id),
                         ('account_type', '=', 'liability_payable'),
                         ('deprecated', '=', False),

--- a/None
+++ b/addons/account/models/account_root.py
@@ -0,0 +1,37 @@
+
+from itertools import accumulate
+
+from odoo import api, fields, models
+from odoo.tools import Query
+
+
+class AccountRoot(models.Model):
+    _name = 'account.root'
+    _description = 'Account codes first 2 digits'
+    _auto = False
+    _table_query = '0'
+
+    name = fields.Char(compute='_compute_root')
+    parent_id = fields.Many2one('account.root', compute='_compute_root')
+
+    def browse(self, ids=None):
+        if isinstance(ids, str):
+            ids = (ids,)
+        return super().browse(ids)
+
+    def _search(self, domain, offset=0, limit=None, order=None) -> Query:
+        match domain:
+            case [('id', 'in', ids)]:
+                return self.browse(sorted(ids))._as_query()
+            case [('id', 'parent_of', ids)]:
+                return self.browse(sorted({s for _id in ids for s in accumulate(_id)}))._as_query()
+        raise NotImplementedError
+
+    @api.model
+    def _from_account_code(self, code):
+        return self.browse(code and code[:2])
+
+    def _compute_root(self):
+        for root in self:
+            root.name = root.id
+            root.parent_id = self.browse(root.id[:-1] if len(root.id) > 1 else False)

--- a/addons/account/models/chart_template.py
+++ b/addons/account/models/chart_template.py
@@ -198,7 +198,8 @@ class AccountChartTemplate(models.AbstractModel):
         if not reload_template and (not company.root_id._existing_accounting() or self.env.ref('base.module_account').demo):
             for model in ('account.move',) + TEMPLATE_MODELS[::-1]:
                 if not company.parent_id:
-                    self.env[model].sudo().with_context(active_test=False).search([('company_id', 'child_of', company.id)]).with_context({MODULE_UNINSTALL_FLAG: True}).unlink()
+                    company_field = 'company_id' if 'company_id' in self.env[model] else 'company_ids'
+                    self.env[model].sudo().with_context(active_test=False).search([(company_field, 'child_of', company.id)]).with_context({MODULE_UNINSTALL_FLAG: True}).unlink()
 
         data = self._get_chart_template_data(template_code)
         template_data = data.pop('template_data')
@@ -217,7 +218,6 @@ class AccountChartTemplate(models.AbstractModel):
 
         # Manual sync because disable above (delay_account_group_sync)
         AccountGroup = self.env['account.group'].with_context(delay_account_group_sync=False)
-        AccountGroup._adapt_accounts_for_account_groups(company=company)
         AccountGroup._adapt_parent_account_group(company=company)
 
         # Install the demo data when the first localization is instanciated on the company
@@ -356,7 +356,8 @@ class AccountChartTemplate(models.AbstractModel):
                     normalized_code = f'{values["code"]:<0{int(template_data.get("code_digits", 6))}}'
                     if not account or not re.match(f'^{values["code"]}0*$', account.code):
                         query = self.env['account.account']._search(self.env['account.account']._check_company_domain(company))
-                        query.add_where("account_account.code SIMILAR TO %s", [f'{values["code"]}0*'])
+                        account_code = self.with_company(company).env['account.account']._field_to_sql('account_account', 'code', query)
+                        query.add_where(SQL("%s SIMILAR TO %s", account_code, f'{values["code"]}0*'))
                         accounts = self.env['account.account'].browse(query)
                         existing_account = accounts.sorted(key=lambda x: x.code != normalized_code)[0] if accounts else None
                         if existing_account:
@@ -796,15 +797,12 @@ class AccountChartTemplate(models.AbstractModel):
             return
 
         def create_foreign_tax_account(existing_account, additional_label):
-            new_code = self.env['account.account']._search_new_account_code(
-                existing_account.code,
-                existing_account.company_id,
-            )
+            new_code = self.env['account.account'].with_company(company)._search_new_account_code(existing_account.code)
             return self.env['account.account'].create({
                 'name': f"{existing_account.name} - {additional_label}",
                 'code': new_code,
                 'account_type': existing_account.account_type,
-                'company_id': existing_account.company_id.id,
+                'company_ids': [Command.link(company.id)],
             })
 
         existing_accounts = {'': None, None: None}  # keeps tracks of the created account by foreign xml_id
@@ -1205,19 +1203,22 @@ class AccountChartTemplate(models.AbstractModel):
             translatable_fields = translatable_model_fields[model]
             if not translatable_fields:
                 continue
+            company_id_field = 'company_ids' if model == 'account.account' else 'company_id'
+
+            self.env[model].flush_model(['id', company_id_field] + translatable_model_fields[model])
 
-            self.env[model].flush_model(['id', 'company_id'] + translatable_model_fields[model])
+            query = self.env[model]._where_calc([(company_id_field, 'in', company_ids)])
 
             # We only want records that have at least 1 missing translation in any of its translatable fields
             missing_translation_clauses = [
-                SQL("(%s ->> %s) IS NULL", SQL.identifier('model', field), lang)
+                SQL("(%s ->> %s) IS NULL", SQL.identifier(query.table, field), lang)
                 for field in translatable_fields
                 for lang in langs
             ]
 
             translatable_field_column_args = []
             for field in translatable_fields:
-                translatable_field_column_args.extend((SQL("%s", field), SQL.identifier('model', field)))
+                translatable_field_column_args.extend((SQL("%s", field), SQL.identifier(query.table, field)))
 
             queries.append(SQL(
                 """
@@ -1225,16 +1226,17 @@ class AccountChartTemplate(models.AbstractModel):
                         model_data.name AS xmlid,
                         model_data.module AS module,
                         json_build_object(%(translatable_field_column_args)s) AS fields
-                   FROM %(table)s model
+                   FROM %(from_clause)s
                    JOIN ir_model_data model_data ON model_data.model = %(model)s
-                                                AND model.id = model_data.res_id
-                  WHERE (%(missing_translation_clauses)s)
-                    AND model.company_id IN %(company_ids)s
+                                                AND %(model_id)s = model_data.res_id
+                  WHERE %(where_clause)s
+                        AND (%(missing_translation_clauses)s)
                 """,
                 model=model,
                 translatable_field_column_args=SQL(", ").join(translatable_field_column_args),
-                table=SQL.identifier(self.env[model]._table),
-                company_ids=company_ids,
+                from_clause=query.from_clause,
+                model_id=SQL.identifier(query.table, 'id'),
+                where_clause=query.where_clause or SQL("TRUE"),
                 missing_translation_clauses=SQL(" OR ").join(missing_translation_clauses),
             ))
 

--- a/addons/account/models/company.py
+++ b/addons/account/models/company.py
@@ -91,7 +91,7 @@ class ResCompany(models.Model):
     user_hard_lock_date = fields.Date(compute='_compute_user_hard_lock_date')
     transfer_account_id = fields.Many2one('account.account',
         check_company=True,
-        domain="[('reconcile', '=', True), ('account_type', '=', 'asset_current'), ('deprecated', '=', False)]", string="Inter-Banks Transfer Account", help="Intermediary account used when moving money from a liqity account to another")
+        domain="[('reconcile', '=', True), ('account_type', '=', 'asset_current'), ('deprecated', '=', False)]", string="Inter-Banks Transfer Account", help="Intermediary account used when moving money from a liquidity account to another")
     expects_chart_of_accounts = fields.Boolean(string='Expects a Chart of Accounts', default=True)
     chart_template = fields.Selection(selection='_chart_template_selection')
     bank_account_code_prefix = fields.Char(string='Prefix of the bank accounts')
@@ -389,7 +389,7 @@ class ResCompany(models.Model):
     def reflect_code_prefix_change(self, old_code, new_code):
         if not old_code or new_code == old_code:
             return
-        accounts = self.env['account.account'].search([
+        accounts = self.env['account.account'].with_company(self).search([
             *self.env['account.account']._check_company_domain(self),
             ('code', '=like', old_code + '%'),
             ('account_type', 'in', ('asset_cash', 'liability_credit_card')),
@@ -731,19 +731,19 @@ class ResCompany(models.Model):
         if none has yet been defined.
         """
         unaffected_earnings_type = "equity_unaffected"
-        account = self.env['account.account'].search([
+        account = self.env['account.account'].with_company(self).search([
             *self.env['account.account']._check_company_domain(self),
             ('account_type', '=', unaffected_earnings_type),
-        ])
+        ], limit=1)
         if account:
-            return account[0]
+            return account
         # Do not assume '999999' doesn't exist since the user might have created such an account
         # manually.
         code = 999999
-        while self.env['account.account'].search([
+        while self.env['account.account'].with_company(self).search_count([
             *self.env['account.account']._check_company_domain(self),
             ('code', '=', str(code)),
-        ]):
+        ], limit=1):
             code -= 1
         return self.env['account.account']._load_records([
             {
@@ -752,7 +752,7 @@ class ResCompany(models.Model):
                               'code': str(code),
                               'name': _('Undistributed Profits/Losses'),
                               'account_type': unaffected_earnings_type,
-                              'company_id': self.id,
+                              'company_ids': [Command.link(self.id)],
                           },
                 'noupdate': True,
             }

--- a/addons/account/models/mail_message.py
+++ b/addons/account/models/mail_message.py
@@ -6,7 +6,7 @@ from odoo.osv.expression import OR
 bypass_token = object()
 DOMAINS = {
     'account.move': lambda operator, value: [('company_id.check_account_audit_trail', operator, value)],
-    'account.account': lambda operator, value: [('company_id.check_account_audit_trail', operator, value)],
+    'account.account': lambda operator, value: [('company_ids.check_account_audit_trail', operator, value)],
     'account.tax': lambda operator, value: [('company_id.check_account_audit_trail', operator, value)],
     'res.partner': lambda operator, value: [
         '|', ('company_id', '=', False), ('company_id.check_account_audit_trail', operator, value),
