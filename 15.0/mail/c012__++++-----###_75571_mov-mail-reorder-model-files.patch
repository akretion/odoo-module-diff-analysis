PR: https://github.com/odoo/odoo/pull/75571

From: 5553ad50bf54bef986038f94e8c8462e2547a927
From: Thibault Delavall√©e
Date: 2021-08-25 13:12:11

Structural Changes: 68
Total Changes: 1621

[MOV] mail: reorder model files

As mail grows and will continue to grow, ordering imports and having right
files naming as well as right content in them is important to understand
module organization and content.

Containing

  * reorder init file to give an overview of models;
  * move ResGroups override in its own file, outside of res_users file;
  * split file containing MailActivity model and MailActivityMixin so that
    mixin is contained in its own file, easing followup;
  * split Activity and ActivityType models into two files;

No functional change comes with this commit. This is only code move.

Task-2631873
PR odoo/odoo#75571

================================= pseudo patch: =================================

--- a/addons/mail/models/__init__.py
+++ b/addons/mail/models/__init__.py
@@ -1,37 +1,48 @@
 # -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
-from . import mail_render_mixin
-from . import mail_composer_mixin
-
-from . import mail_message_subtype
-from . import mail_tracking_value
+# core models (required for mixins)
 from . import mail_alias
+from . import models
+
+# mixin
+from . import mail_activity_mixin
 from . import mail_alias_mixin
-from . import mail_followers
-from . import mail_notification
-from . import mail_message
-from . import mail_activity
-from . import mail_mail
+from . import mail_render_mixin
+from . import mail_composer_mixin
 from . import mail_thread
 from . import mail_thread_blacklist
 from . import mail_thread_cc
+
+# mail models
+from . import mail_notification  # keep before as decorated m2m
+from . import mail_activity_type
+from . import mail_activity
 from . import mail_blacklist
+from . import mail_followers
+from . import mail_message_subtype
+from . import mail_message
+from . import mail_mail
+from . import mail_tracking_value
+from . import mail_template
+
+# discuss
 from . import mail_channel_partner
 from . import mail_channel
-from . import mail_template
 from . import mail_shortcode
-from . import models
-from . import res_partner
-from . import res_users
-from . import res_company
-from . import res_config_settings
-from . import update
+
+# odoo models
 from . import ir_action_act_window
-from . import ir_actions
+from . import ir_actions_server
 from . import ir_attachment
 from . import ir_config_parameter
 from . import ir_http
 from . import ir_model
 from . import ir_model_fields
 from . import ir_ui_view
+from . import res_company
+from . import res_config_settings
+from . import res_partner
+from . import res_users
+from . import res_groups
+from . import update

--- a/addons/mail/models/ir_actions.py
+++ b/addons/mail/models/ir_actions_server.py

--- a/addons/mail/models/mail_activity.py
+++ b/addons/mail/models/mail_activity.py
@@ -1,135 +1,15 @@
 # -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
+import pytz
+
 from collections import defaultdict
 from datetime import date, datetime
 from dateutil.relativedelta import relativedelta
-import logging
-import pytz
 
 from odoo import api, exceptions, fields, models, _, Command
 from odoo.osv import expression
-
 from odoo.tools.misc import clean_context
-from odoo.addons.base.models.ir_model import MODULE_UNINSTALL_FLAG
-
-_logger = logging.getLogger(__name__)
-
-
-class MailActivityType(models.Model):
-    """ Activity Types are used to categorize activities. Each type is a different
-    kind of activity e.g. call, mail, meeting. An activity can be generic i.e.
-    available for all models using activities; or specific to a model in which
-    case res_model field should be used. """
-    _name = 'mail.activity.type'
-    _description = 'Activity Type'
-    _rec_name = 'name'
-    _order = 'sequence, id'
-
-    def _get_model_selection(self):
-        return [
-            (model.model, model.name)
-            for model in self.env['ir.model'].sudo().search(
-                ['&', ('is_mail_thread', '=', True), ('transient', '=', False)])
-        ]
-
-
-    name = fields.Char('Name', required=True, translate=True)
-    summary = fields.Char('Default Summary', translate=True)
-    sequence = fields.Integer('Sequence', default=10)
-    active = fields.Boolean(default=True)
-    create_uid = fields.Many2one('res.users', index=True)
-    delay_count = fields.Integer(
-        'Schedule', default=0,
-        help='Number of days/week/month before executing the action. It allows to plan the action deadline.')
-    delay_unit = fields.Selection([
-        ('days', 'days'),
-        ('weeks', 'weeks'),
-        ('months', 'months')], string="Delay units", help="Unit of delay", required=True, default='days')
-    delay_label = fields.Char(compute='_compute_delay_label')
-    delay_from = fields.Selection([
-        ('current_date', 'after completion date'),
-        ('previous_activity', 'after previous activity deadline')], string="Delay Type", help="Type of delay", required=True, default='previous_activity')
-    icon = fields.Char('Icon', help="Font awesome icon e.g. fa-tasks")
-    decoration_type = fields.Selection([
-        ('warning', 'Alert'),
-        ('danger', 'Error')], string="Decoration Type",
-        help="Change the background color of the related activities of this type.")
-    res_model = fields.Selection(selection=_get_model_selection, string="Model",
-        help='Specify a model if the activity should be specific to a model'
-             ' and not available when managing activities for other models.')
-    triggered_next_type_id = fields.Many2one(
-        'mail.activity.type', string='Trigger', compute='_compute_triggered_next_type_id',
-        inverse='_inverse_triggered_next_type_id', store=True, readonly=False,
-        domain="['|', ('res_model', '=', False), ('res_model', '=', res_model)]", ondelete='restrict',
-        help="Automatically schedule this activity once the current one is marked as done.")
-    chaining_type = fields.Selection([
-        ('suggest', 'Suggest Next Activity'), ('trigger', 'Trigger Next Activity')
-    ], string="Chaining Type", required=True, default="suggest")
-    suggested_next_type_ids = fields.Many2many(
-        'mail.activity.type', 'mail_activity_rel', 'activity_id', 'recommended_id', string='Suggest',
-        domain="['|', ('res_model', '=', False), ('res_model', '=', res_model)]",
-        compute='_compute_suggested_next_type_ids', inverse='_inverse_suggested_next_type_ids', store=True, readonly=False,
-        help="Suggest these activities once the current one is marked as done.")
-    previous_type_ids = fields.Many2many(
-        'mail.activity.type', 'mail_activity_rel', 'recommended_id', 'activity_id',
-        domain="['|', ('res_model', '=', False), ('res_model', '=', res_model)]",
-        string='Preceding Activities')
-    category = fields.Selection([
-        ('default', 'None'), ('upload_file', 'Upload Document')
-    ], default='default', string='Action',
-        help='Actions may trigger specific behavior like opening calendar view or automatically mark as done when a document is uploaded')
-    mail_template_ids = fields.Many2many('mail.template', string='Email templates')
-    default_user_id = fields.Many2one("res.users", string="Default User")
-    default_note = fields.Html(string="Default Note", translate=True)
-
-    #Fields for display purpose only
-    initial_res_model = fields.Selection(selection=_get_model_selection, string='Initial model', compute="_compute_initial_res_model", store=False,
-            help='Technical field to keep track of the model at the start of editing to support UX related behaviour')
-    res_model_change = fields.Boolean(string="Model has change", help="Technical field for UX related behaviour", default=False, store=False)
-
-    @api.onchange('res_model')
-    def _onchange_res_model(self):
-        self.mail_template_ids = self.sudo().mail_template_ids.filtered(lambda template: template.model_id.model == self.res_model)
-        self.res_model_change = self.initial_res_model and self.initial_res_model != self.res_model
-
-    def _compute_initial_res_model(self):
-        for activity_type in self:
-            activity_type.initial_res_model = activity_type.res_model
-
-    @api.depends('delay_unit', 'delay_count')
-    def _compute_delay_label(self):
-        selection_description_values = {
-            e[0]: e[1] for e in self._fields['delay_unit']._description_selection(self.env)}
-        for activity_type in self:
-            unit = selection_description_values[activity_type.delay_unit]
-            activity_type.delay_label = '%s %s' % (activity_type.delay_count, unit)
-
-    @api.depends('chaining_type')
-    def _compute_suggested_next_type_ids(self):
-        """suggested_next_type_ids and triggered_next_type_id should be mutually exclusive"""
-        for activity_type in self:
-            if activity_type.chaining_type == 'trigger':
-                activity_type.suggested_next_type_ids = False
-
-    def _inverse_suggested_next_type_ids(self):
-        for activity_type in self:
-            if activity_type.suggested_next_type_ids:
-                activity_type.chaining_type = 'suggest'
-
-    @api.depends('chaining_type')
-    def _compute_triggered_next_type_id(self):
-        """suggested_next_type_ids and triggered_next_type_id should be mutually exclusive"""
-        for activity_type in self:
-            if activity_type.chaining_type == 'suggest':
-                activity_type.triggered_next_type_id = False
-
-    def _inverse_triggered_next_type_id(self):
-        for activity_type in self:
-            if activity_type.triggered_next_type_id:
-                activity_type.chaining_type = 'trigger'
-            else:
-                activity_type.chaining_type = 'suggest'
 
 
 class MailActivity(models.Model):
@@ -753,494 +633,3 @@ class MailActivity(models.Model):
             'activity_res_ids': sorted(res_id_to_deadline, key=lambda item: res_id_to_deadline[item]),
             'grouped_activities': activity_data,
         }
-
-
-class MailActivityMixin(models.AbstractModel):
-    """ Mail Activity Mixin is a mixin class to use if you want to add activities
-    management on a model. It works like the mail.thread mixin. It defines
-    an activity_ids one2many field toward activities using res_id and res_model_id.
-    Various related / computed fields are also added to have a global status of
-    activities on documents.
-
-    Activities come with a new JS widget for the form view. It is integrated in the
-    Chatter widget although it is a separate widget. It displays activities linked
-    to the current record and allow to schedule, edit and mark done activities.
-    Just include field activity_ids in the div.oe-chatter to use it.
-
-    There is also a kanban widget defined. It defines a small widget to integrate
-    in kanban vignettes. It allow to manage activities directly from the kanban
-    view. Use widget="kanban_activity" on activitiy_ids field in kanban view to
-    use it.
-
-    Some context keys allow to control the mixin behavior. Use those in some
-    specific cases like import
-
-     * ``mail_activity_automation_skip``: skip activities automation; it means
-       no automated activities will be generated, updated or unlinked, allowing
-       to save computation and avoid generating unwanted activities;
-    """
-    _name = 'mail.activity.mixin'
-    _description = 'Activity Mixin'
-
-    def _default_activity_type(self):
-        """Define a default fallback activity type when requested xml id wasn't found.
-
-        Can be overriden to specify the default activity type of a model.
-        It is only called in in activity_schedule() for now.
-        """
-        return self.env.ref('mail.mail_activity_data_todo', raise_if_not_found=False) \
-            or self.env['mail.activity.type'].search([('res_model', '=', self._name)], limit=1) \
-            or self.env['mail.activity.type'].search([('res_model', '=', False)], limit=1)
-
-    activity_ids = fields.One2many(
-        'mail.activity', 'res_id', 'Activities',
-        auto_join=True,
-        groups="base.group_user",)
-    activity_state = fields.Selection([
-        ('overdue', 'Overdue'),
-        ('today', 'Today'),
-        ('planned', 'Planned')], string='Activity State',
-        compute='_compute_activity_state',
-        search='_search_activity_state',
-        groups="base.group_user",
-        help='Status based on activities\nOverdue: Due date is already passed\n'
-             'Today: Activity date is today\nPlanned: Future activities.')
-    activity_user_id = fields.Many2one(
-        'res.users', 'Responsible User',
-        related='activity_ids.user_id', readonly=False,
-        search='_search_activity_user_id',
-        groups="base.group_user")
-    activity_type_id = fields.Many2one(
-        'mail.activity.type', 'Next Activity Type',
-        related='activity_ids.activity_type_id', readonly=False,
-        search='_search_activity_type_id',
-        groups="base.group_user")
-    activity_type_icon = fields.Char('Activity Type Icon', related='activity_ids.icon')
-    activity_date_deadline = fields.Date(
-        'Next Activity Deadline',
-        compute='_compute_activity_date_deadline', search='_search_activity_date_deadline',
-        compute_sudo=False, readonly=True, store=False,
-        groups="base.group_user")
-    my_activity_date_deadline = fields.Date(
-        'My Activity Deadline',
-        compute='_compute_my_activity_date_deadline', search='_search_my_activity_date_deadline',
-        compute_sudo=False, readonly=True, groups="base.group_user")
-    activity_summary = fields.Char(
-        'Next Activity Summary',
-        related='activity_ids.summary', readonly=False,
-        search='_search_activity_summary',
-        groups="base.group_user",)
-    activity_exception_decoration = fields.Selection([
-        ('warning', 'Alert'),
-        ('danger', 'Error')],
-        compute='_compute_activity_exception_type',
-        search='_search_activity_exception_decoration',
-        help="Type of the exception activity on record.")
-    activity_exception_icon = fields.Char('Icon', help="Icon to indicate an exception activity.",
-        compute='_compute_activity_exception_type')
-
-    @api.depends('activity_ids.activity_type_id.decoration_type', 'activity_ids.activity_type_id.icon')
-    def _compute_activity_exception_type(self):
-        # prefetch all activity types for all activities, this will avoid any query in loops
-        self.mapped('activity_ids.activity_type_id.decoration_type')
-
-        for record in self:
-            activity_type_ids = record.activity_ids.mapped('activity_type_id')
-            exception_activity_type_id = False
-            for activity_type_id in activity_type_ids:
-                if activity_type_id.decoration_type == 'danger':
-                    exception_activity_type_id = activity_type_id
-                    break
-                if activity_type_id.decoration_type == 'warning':
-                    exception_activity_type_id = activity_type_id
-            record.activity_exception_decoration = exception_activity_type_id and exception_activity_type_id.decoration_type
-            record.activity_exception_icon = exception_activity_type_id and exception_activity_type_id.icon
-
-    def _search_activity_exception_decoration(self, operator, operand):
-        return [('activity_ids.activity_type_id.decoration_type', operator, operand)]
-
-    @api.depends('activity_ids.state')
-    def _compute_activity_state(self):
-        for record in self:
-            states = record.activity_ids.mapped('state')
-            if 'overdue' in states:
-                record.activity_state = 'overdue'
-            elif 'today' in states:
-                record.activity_state = 'today'
-            elif 'planned' in states:
-                record.activity_state = 'planned'
-            else:
-                record.activity_state = False
-
-    def _search_activity_state(self, operator, value):
-        all_states = {'overdue', 'today', 'planned', False}
-        if operator == '=':
-            search_states = {value}
-        elif operator == '!=':
-            search_states = all_states - {value}
-        elif operator == 'in':
-            search_states = set(value)
-        elif operator == 'not in':
-            search_states = all_states - set(value)
-
-        reverse_search = False
-        if False in search_states:
-            # If we search "activity_state = False", they might be a lot of records
-            # (million for some models), so instead of returning the list of IDs
-            # [(id, 'in', ids)] we will reverse the domain and return something like
-            # [(id, 'not in', ids)], so the list of ids is as small as possible
-            reverse_search = True
-            search_states = all_states - search_states
-
-        # Use number in the SQL query for performance purpose
-        integer_state_value = {
-            'overdue': -1,
-            'today': 0,
-            'planned': 1,
-            False: None,
-        }
-
-        search_states_int = {integer_state_value.get(s or False) for s in search_states}
-
-        query = """
-          SELECT res_id
-            FROM (
-                SELECT res_id,
-                       -- Global activity state
-                       MIN(
-                            -- Compute the state of each individual activities
-                            -- -1: overdue
-                            --  0: today
-                            --  1: planned
-                           SIGN(EXTRACT(day from (
-                                mail_activity.date_deadline - DATE_TRUNC('day', %(today_utc)s AT TIME ZONE res_partner.tz)
-                           )))
-                        )::INT AS activity_state
-                  FROM mail_activity
-             LEFT JOIN res_users
-                    ON res_users.id = mail_activity.user_id
-             LEFT JOIN res_partner
-                    ON res_partner.id = res_users.partner_id
-                 WHERE mail_activity.res_model = %(res_model_table)s
-              GROUP BY res_id
-            ) AS res_record
-          WHERE %(search_states_int)s @> ARRAY[activity_state]
-        """
-
-        self._cr.execute(
-            query,
-            {
-                'today_utc': pytz.UTC.localize(datetime.utcnow()),
-                'res_model_table': self._name,
-                'search_states_int': list(search_states_int)
-            },
-        )
-        return [('id', 'not in' if reverse_search else 'in', [r[0] for r in self._cr.fetchall()])]
-
-    @api.depends('activity_ids.date_deadline')
-    def _compute_activity_date_deadline(self):
-        for record in self:
-            record.activity_date_deadline = record.activity_ids[:1].date_deadline
-
-    def _search_activity_date_deadline(self, operator, operand):
-        if operator == '=' and not operand:
-            return [('activity_ids', '=', False)]
-        return [('activity_ids.date_deadline', operator, operand)]
-
-    @api.model
-    def _search_activity_user_id(self, operator, operand):
-        return [('activity_ids.user_id', operator, operand)]
-
-    @api.model
-    def _search_activity_type_id(self, operator, operand):
-        return [('activity_ids.activity_type_id', operator, operand)]
-
-    @api.model
-    def _search_activity_summary(self, operator, operand):
-        return [('activity_ids.summary', operator, operand)]
-
-    @api.depends('activity_ids.date_deadline', 'activity_ids.user_id')
-    @api.depends_context('uid')
-    def _compute_my_activity_date_deadline(self):
-        for record in self:
-            record.my_activity_date_deadline = next((
-                activity.date_deadline
-                for activity in record.activity_ids
-                if activity.user_id.id == record.env.uid
-            ), False)
-
-    def _search_my_activity_date_deadline(self, operator, operand):
-        activity_ids = self.env['mail.activity']._search([
-            ('date_deadline', operator, operand),
-            ('res_model', '=', self._name),
-            ('user_id', '=', self.env.user.id)
-        ])
-        return [('activity_ids', 'in', activity_ids)]
-
-    def write(self, vals):
-        # Delete activities of archived record.
-        if 'active' in vals and vals['active'] is False:
-            self.env['mail.activity'].sudo().search(
-                [('res_model', '=', self._name), ('res_id', 'in', self.ids)]
-            ).unlink()
-        return super(MailActivityMixin, self).write(vals)
-
-    def unlink(self):
-        """ Override unlink to delete records activities through (res_model, res_id). """
-        record_ids = self.ids
-        result = super(MailActivityMixin, self).unlink()
-        self.env['mail.activity'].sudo().search(
-            [('res_model', '=', self._name), ('res_id', 'in', record_ids)]
-        ).unlink()
-        return result
-
-    def _read_progress_bar(self, domain, group_by, progress_bar):
-        group_by_fname = group_by.partition(':')[0]
-        if not (progress_bar['field'] == 'activity_state' and self._fields[group_by_fname].store):
-            return super()._read_progress_bar(domain, group_by, progress_bar)
-
-        # optimization for 'activity_state'
-
-        # explicitly check access rights, since we bypass the ORM
-        self.check_access_rights('read')
-        self._flush_search(domain, fields=[group_by_fname], order='id')
-        self.env['mail.activity'].flush(['res_model', 'res_id', 'user_id', 'date_deadline'])
-
-        query = self._where_calc(domain)
-        self._apply_ir_rules(query, 'read')
-        gb = group_by.partition(':')[0]
-        annotated_groupbys = [
-            self._read_group_process_groupby(gb, query)
-            for gb in [group_by, 'activity_state']
-        ]
-        groupby_dict = {gb['groupby']: gb for gb in annotated_groupbys}
-        for gb in annotated_groupbys:
-            if gb['field'] == 'activity_state':
-                gb['qualified_field'] = '"_last_activity_state"."activity_state"'
-        groupby_terms, _orderby_terms = self._read_group_prepare('activity_state', [], annotated_groupbys, query)
-        select_terms = [
-            '%s as "%s"' % (gb['qualified_field'], gb['groupby'])
-            for gb in annotated_groupbys
-        ]
-        from_clause, where_clause, where_params = query.get_sql()
-        tz = self._context.get('tz') or self.env.user.tz or 'UTC'
-        select_query = """
-            SELECT 1 AS id, count(*) AS "__count", {fields}
-            FROM {from_clause}
-            JOIN (
-                SELECT res_id,
-                CASE
-                    WHEN min(date_deadline - (now() AT TIME ZONE COALESCE(res_partner.tz, %s))::date) > 0 THEN 'planned'
-                    WHEN min(date_deadline - (now() AT TIME ZONE COALESCE(res_partner.tz, %s))::date) < 0 THEN 'overdue'
-                    WHEN min(date_deadline - (now() AT TIME ZONE COALESCE(res_partner.tz, %s))::date) = 0 THEN 'today'
-                    ELSE null
-                END AS activity_state
-                FROM mail_activity
-                JOIN res_users ON (res_users.id = mail_activity.user_id)
-                JOIN res_partner ON (res_partner.id = res_users.partner_id)
-                WHERE res_model = '{model}'
-                GROUP BY res_id
-            ) AS "_last_activity_state" ON ("{table}".id = "_last_activity_state".res_id)
-            WHERE {where_clause}
-            GROUP BY {group_by}
-        """.format(
-            fields=', '.join(select_terms),
-            from_clause=from_clause,
-            model=self._name,
-            table=self._table,
-            where_clause=where_clause or '1=1',
-            group_by=', '.join(groupby_terms),
-        )
-        self.env.cr.execute(select_query, [tz] * 3 + where_params)
-        fetched_data = self.env.cr.dictfetchall()
-        self._read_group_resolve_many2one_fields(fetched_data, annotated_groupbys)
-        data = [
-            {key: self._read_group_prepare_data(key, val, groupby_dict)
-             for key, val in row.items()}
-            for row in fetched_data
-        ]
-        return [
-            self._read_group_format_result(vals, annotated_groupbys, [group_by], domain)
-            for vals in data
-        ]
-
-    def toggle_active(self):
-        """ Before archiving the record we should also remove its ongoing
-        activities. Otherwise they stay in the systray and concerning archived
-        records it makes no sense. """
-        record_to_deactivate = self.filtered(lambda rec: rec[rec._active_name])
-        if record_to_deactivate:
-            # use a sudo to bypass every access rights; all activities should be removed
-            self.env['mail.activity'].sudo().search([
-                ('res_model', '=', self._name),
-                ('res_id', 'in', record_to_deactivate.ids)
-            ]).unlink()
-        return super(MailActivityMixin, self).toggle_active()
-
-    def activity_send_mail(self, template_id):
-        """ Automatically send an email based on the given mail.template, given
-        its ID. """
-        template = self.env['mail.template'].browse(template_id).exists()
-        if not template:
-            return False
-        for record in self:
-            record.message_post_with_template(
-                template_id,
-                composition_mode='comment'
-            )
-        return True
-
-    def activity_search(self, act_type_xmlids='', user_id=None, additional_domain=None):
-        """ Search automated activities on current record set, given a list of activity
-        types xml IDs. It is useful when dealing with specific types involved in automatic
-        activities management.
-
-        :param act_type_xmlids: list of activity types xml IDs
-        :param user_id: if set, restrict to activities of that user_id;
-        :param additional_domain: if set, filter on that domain;
-        """
-        if self.env.context.get('mail_activity_automation_skip'):
-            return False
-
-        Data = self.env['ir.model.data'].sudo()
-        activity_types_ids = [type_id for type_id in (Data._xmlid_to_res_id(xmlid, raise_if_not_found=False) for xmlid in act_type_xmlids) if type_id]
-        if not any(activity_types_ids):
-            return False
-
-        domain = [
-            '&', '&', '&',
-            ('res_model', '=', self._name),
-            ('res_id', 'in', self.ids),
-            ('automated', '=', True),
-            ('activity_type_id', 'in', activity_types_ids)
-        ]
-
-        if user_id:
-            domain = expression.AND([domain, [('user_id', '=', user_id)]])
-        if additional_domain:
-            domain = expression.AND([domain, additional_domain])
-
-        return self.env['mail.activity'].search(domain)
-
-    def activity_schedule(self, act_type_xmlid='', date_deadline=None, summary='', note='', **act_values):
-        """ Schedule an activity on each record of the current record set.
-        This method allow to provide as parameter act_type_xmlid. This is an
-        xml_id of activity type instead of directly giving an activity_type_id.
-        It is useful to avoid having various "env.ref" in the code and allow
-        to let the mixin handle access rights.
-
-        :param date_deadline: the day the activity must be scheduled on
-        the timezone of the user must be considered to set the correct deadline
-        """
-        if self.env.context.get('mail_activity_automation_skip'):
-            return False
-
-        if not date_deadline:
-            date_deadline = fields.Date.context_today(self)
-        if isinstance(date_deadline, datetime):
-            _logger.warning("Scheduled deadline should be a date (got %s)", date_deadline)
-        if act_type_xmlid:
-            activity_type = self.env.ref(act_type_xmlid, raise_if_not_found=False) or self._default_activity_type()
-        else:
-            activity_type_id = act_values.get('activity_type_id', False)
-            activity_type = activity_type_id and self.env['mail.activity.type'].sudo().browse(activity_type_id)
-
-        model_id = self.env['ir.model']._get(self._name).id
-        activities = self.env['mail.activity']
-        for record in self:
-            create_vals = {
-                'activity_type_id': activity_type and activity_type.id,
-                'summary': summary or activity_type.summary,
-                'automated': True,
-                'note': note or activity_type.default_note,
-                'date_deadline': date_deadline,
-                'res_model_id': model_id,
-                'res_id': record.id,
-                'user_id': act_values.get('user_id') or activity_type.default_user_id.id or self.env.uid
-            }
-            create_vals.update(act_values)
-            activities |= self.env['mail.activity'].create(create_vals)
-        return activities
-
-    def _activity_schedule_with_view(self, act_type_xmlid='', date_deadline=None, summary='', views_or_xmlid='', render_context=None, **act_values):
-        """ Helper method: Schedule an activity on each record of the current record set.
-        This method allow to the same mecanism as `activity_schedule`, but provide
-        2 additionnal parameters:
-        :param views_or_xmlid: record of ir.ui.view or string representing the xmlid
-            of the qweb template to render
-        :type views_or_xmlid: string or recordset
-        :param render_context: the values required to render the given qweb template
-        :type render_context: dict
-        """
-        if self.env.context.get('mail_activity_automation_skip'):
-            return False
-
-        render_context = render_context or dict()
-        if isinstance(views_or_xmlid, str):
-            views = self.env.ref(views_or_xmlid, raise_if_not_found=False)
-        else:
-            views = views_or_xmlid
-        if not views:
-            return
-        activities = self.env['mail.activity']
-        for record in self:
-            render_context['object'] = record
-            note = views._render(render_context, engine='ir.qweb', minimal_qcontext=True)
-            activities |= record.activity_schedule(act_type_xmlid=act_type_xmlid, date_deadline=date_deadline, summary=summary, note=note, **act_values)
-        return activities
-
-    def activity_reschedule(self, act_type_xmlids, user_id=None, date_deadline=None, new_user_id=None):
-        """ Reschedule some automated activities. Activities to reschedule are
-        selected based on type xml ids and optionally by user. Purpose is to be
-        able to
-
-         * update the deadline to date_deadline;
-         * update the responsible to new_user_id;
-        """
-        if self.env.context.get('mail_activity_automation_skip'):
-            return False
-
-        Data = self.env['ir.model.data'].sudo()
-        activity_types_ids = [Data._xmlid_to_res_id(xmlid, raise_if_not_found=False) for xmlid in act_type_xmlids]
-        activity_types_ids = [act_type_id for act_type_id in activity_types_ids if act_type_id]
-        if not any(activity_types_ids):
-            return False
-        activities = self.activity_search(act_type_xmlids, user_id=user_id)
-        if activities:
-            write_vals = {}
-            if date_deadline:
-                write_vals['date_deadline'] = date_deadline
-            if new_user_id:
-                write_vals['user_id'] = new_user_id
-            activities.write(write_vals)
-        return activities
-
-    def activity_feedback(self, act_type_xmlids, user_id=None, feedback=None):
-        """ Set activities as done, limiting to some activity types and
-        optionally to a given user. """
-        if self.env.context.get('mail_activity_automation_skip'):
-            return False
-
-        Data = self.env['ir.model.data'].sudo()
-        activity_types_ids = [Data._xmlid_to_res_id(xmlid, raise_if_not_found=False) for xmlid in act_type_xmlids]
-        activity_types_ids = [act_type_id for act_type_id in activity_types_ids if act_type_id]
-        if not any(activity_types_ids):
-            return False
-        activities = self.activity_search(act_type_xmlids, user_id=user_id)
-        if activities:
-            activities.action_feedback(feedback=feedback)
-        return True
-
-    def activity_unlink(self, act_type_xmlids, user_id=None):
-        """ Unlink activities, limiting to some activity types and optionally
-        to a given user. """
-        if self.env.context.get('mail_activity_automation_skip'):
-            return False
-
-        Data = self.env['ir.model.data'].sudo()
-        activity_types_ids = [Data._xmlid_to_res_id(xmlid, raise_if_not_found=False) for xmlid in act_type_xmlids]
-        activity_types_ids = [act_type_id for act_type_id in activity_types_ids if act_type_id]
-        if not any(activity_types_ids):
-            return False
-        self.activity_search(act_type_xmlids, user_id=user_id).unlink()
-        return True

--- a/None
+++ b/addons/mail/models/mail_activity_mixin.py
@@ -0,0 +1,503 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from datetime import datetime
+
+import logging
+import pytz
+
+from odoo import api, fields, models
+from odoo.osv import expression
+
+_logger = logging.getLogger(__name__)
+
+
+class MailActivityMixin(models.AbstractModel):
+    """ Mail Activity Mixin is a mixin class to use if you want to add activities
+    management on a model. It works like the mail.thread mixin. It defines
+    an activity_ids one2many field toward activities using res_id and res_model_id.
+    Various related / computed fields are also added to have a global status of
+    activities on documents.
+
+    Activities come with a new JS widget for the form view. It is integrated in the
+    Chatter widget although it is a separate widget. It displays activities linked
+    to the current record and allow to schedule, edit and mark done activities.
+    Just include field activity_ids in the div.oe-chatter to use it.
+
+    There is also a kanban widget defined. It defines a small widget to integrate
+    in kanban vignettes. It allow to manage activities directly from the kanban
+    view. Use widget="kanban_activity" on activitiy_ids field in kanban view to
+    use it.
+
+    Some context keys allow to control the mixin behavior. Use those in some
+    specific cases like import
+
+     * ``mail_activity_automation_skip``: skip activities automation; it means
+       no automated activities will be generated, updated or unlinked, allowing
+       to save computation and avoid generating unwanted activities;
+    """
+    _name = 'mail.activity.mixin'
+    _description = 'Activity Mixin'
+
+    def _default_activity_type(self):
+        """Define a default fallback activity type when requested xml id wasn't found.
+
+        Can be overriden to specify the default activity type of a model.
+        It is only called in in activity_schedule() for now.
+        """
+        return self.env.ref('mail.mail_activity_data_todo', raise_if_not_found=False) \
+            or self.env['mail.activity.type'].search([('res_model', '=', self._name)], limit=1) \
+            or self.env['mail.activity.type'].search([('res_model', '=', False)], limit=1)
+
+    activity_ids = fields.One2many(
+        'mail.activity', 'res_id', 'Activities',
+        auto_join=True,
+        groups="base.group_user",)
+    activity_state = fields.Selection([
+        ('overdue', 'Overdue'),
+        ('today', 'Today'),
+        ('planned', 'Planned')], string='Activity State',
+        compute='_compute_activity_state',
+        search='_search_activity_state',
+        groups="base.group_user",
+        help='Status based on activities\nOverdue: Due date is already passed\n'
+             'Today: Activity date is today\nPlanned: Future activities.')
+    activity_user_id = fields.Many2one(
+        'res.users', 'Responsible User',
+        related='activity_ids.user_id', readonly=False,
+        search='_search_activity_user_id',
+        groups="base.group_user")
+    activity_type_id = fields.Many2one(
+        'mail.activity.type', 'Next Activity Type',
+        related='activity_ids.activity_type_id', readonly=False,
+        search='_search_activity_type_id',
+        groups="base.group_user")
+    activity_type_icon = fields.Char('Activity Type Icon', related='activity_ids.icon')
+    activity_date_deadline = fields.Date(
+        'Next Activity Deadline',
+        compute='_compute_activity_date_deadline', search='_search_activity_date_deadline',
+        compute_sudo=False, readonly=True, store=False,
+        groups="base.group_user")
+    my_activity_date_deadline = fields.Date(
+        'My Activity Deadline',
+        compute='_compute_my_activity_date_deadline', search='_search_my_activity_date_deadline',
+        compute_sudo=False, readonly=True, groups="base.group_user")
+    activity_summary = fields.Char(
+        'Next Activity Summary',
+        related='activity_ids.summary', readonly=False,
+        search='_search_activity_summary',
+        groups="base.group_user",)
+    activity_exception_decoration = fields.Selection([
+        ('warning', 'Alert'),
+        ('danger', 'Error')],
+        compute='_compute_activity_exception_type',
+        search='_search_activity_exception_decoration',
+        help="Type of the exception activity on record.")
+    activity_exception_icon = fields.Char('Icon', help="Icon to indicate an exception activity.",
+        compute='_compute_activity_exception_type')
+
+    @api.depends('activity_ids.activity_type_id.decoration_type', 'activity_ids.activity_type_id.icon')
+    def _compute_activity_exception_type(self):
+        # prefetch all activity types for all activities, this will avoid any query in loops
+        self.mapped('activity_ids.activity_type_id.decoration_type')
+
+        for record in self:
+            activity_type_ids = record.activity_ids.mapped('activity_type_id')
+            exception_activity_type_id = False
+            for activity_type_id in activity_type_ids:
+                if activity_type_id.decoration_type == 'danger':
+                    exception_activity_type_id = activity_type_id
+                    break
+                if activity_type_id.decoration_type == 'warning':
+                    exception_activity_type_id = activity_type_id
+            record.activity_exception_decoration = exception_activity_type_id and exception_activity_type_id.decoration_type
+            record.activity_exception_icon = exception_activity_type_id and exception_activity_type_id.icon
+
+    def _search_activity_exception_decoration(self, operator, operand):
+        return [('activity_ids.activity_type_id.decoration_type', operator, operand)]
+
+    @api.depends('activity_ids.state')
+    def _compute_activity_state(self):
+        for record in self:
+            states = record.activity_ids.mapped('state')
+            if 'overdue' in states:
+                record.activity_state = 'overdue'
+            elif 'today' in states:
+                record.activity_state = 'today'
+            elif 'planned' in states:
+                record.activity_state = 'planned'
+            else:
+                record.activity_state = False
+
+    def _search_activity_state(self, operator, value):
+        all_states = {'overdue', 'today', 'planned', False}
+        if operator == '=':
+            search_states = {value}
+        elif operator == '!=':
+            search_states = all_states - {value}
+        elif operator == 'in':
+            search_states = set(value)
+        elif operator == 'not in':
+            search_states = all_states - set(value)
+
+        reverse_search = False
+        if False in search_states:
+            # If we search "activity_state = False", they might be a lot of records
+            # (million for some models), so instead of returning the list of IDs
+            # [(id, 'in', ids)] we will reverse the domain and return something like
+            # [(id, 'not in', ids)], so the list of ids is as small as possible
+            reverse_search = True
+            search_states = all_states - search_states
+
+        # Use number in the SQL query for performance purpose
+        integer_state_value = {
+            'overdue': -1,
+            'today': 0,
+            'planned': 1,
+            False: None,
+        }
+
+        search_states_int = {integer_state_value.get(s or False) for s in search_states}
+
+        query = """
+          SELECT res_id
+            FROM (
+                SELECT res_id,
+                       -- Global activity state
+                       MIN(
+                            -- Compute the state of each individual activities
+                            -- -1: overdue
+                            --  0: today
+                            --  1: planned
+                           SIGN(EXTRACT(day from (
+                                mail_activity.date_deadline - DATE_TRUNC('day', %(today_utc)s AT TIME ZONE res_partner.tz)
+                           )))
+                        )::INT AS activity_state
+                  FROM mail_activity
+             LEFT JOIN res_users
+                    ON res_users.id = mail_activity.user_id
+             LEFT JOIN res_partner
+                    ON res_partner.id = res_users.partner_id
+                 WHERE mail_activity.res_model = %(res_model_table)s
+              GROUP BY res_id
+            ) AS res_record
+          WHERE %(search_states_int)s @> ARRAY[activity_state]
+        """
+
+        self._cr.execute(
+            query,
+            {
+                'today_utc': pytz.UTC.localize(datetime.utcnow()),
+                'res_model_table': self._name,
+                'search_states_int': list(search_states_int)
+            },
+        )
+        return [('id', 'not in' if reverse_search else 'in', [r[0] for r in self._cr.fetchall()])]
+
+    @api.depends('activity_ids.date_deadline')
+    def _compute_activity_date_deadline(self):
+        for record in self:
+            record.activity_date_deadline = record.activity_ids[:1].date_deadline
+
+    def _search_activity_date_deadline(self, operator, operand):
+        if operator == '=' and not operand:
+            return [('activity_ids', '=', False)]
+        return [('activity_ids.date_deadline', operator, operand)]
+
+    @api.model
+    def _search_activity_user_id(self, operator, operand):
+        return [('activity_ids.user_id', operator, operand)]
+
+    @api.model
+    def _search_activity_type_id(self, operator, operand):
+        return [('activity_ids.activity_type_id', operator, operand)]
+
+    @api.model
+    def _search_activity_summary(self, operator, operand):
+        return [('activity_ids.summary', operator, operand)]
+
+    @api.depends('activity_ids.date_deadline', 'activity_ids.user_id')
+    @api.depends_context('uid')
+    def _compute_my_activity_date_deadline(self):
+        for record in self:
+            record.my_activity_date_deadline = next((
+                activity.date_deadline
+                for activity in record.activity_ids
+                if activity.user_id.id == record.env.uid
+            ), False)
+
+    def _search_my_activity_date_deadline(self, operator, operand):
+        activity_ids = self.env['mail.activity']._search([
+            ('date_deadline', operator, operand),
+            ('res_model', '=', self._name),
+            ('user_id', '=', self.env.user.id)
+        ])
+        return [('activity_ids', 'in', activity_ids)]
+
+    def write(self, vals):
+        # Delete activities of archived record.
+        if 'active' in vals and vals['active'] is False:
+            self.env['mail.activity'].sudo().search(
+                [('res_model', '=', self._name), ('res_id', 'in', self.ids)]
+            ).unlink()
+        return super(MailActivityMixin, self).write(vals)
+
+    def unlink(self):
+        """ Override unlink to delete records activities through (res_model, res_id). """
+        record_ids = self.ids
+        result = super(MailActivityMixin, self).unlink()
+        self.env['mail.activity'].sudo().search(
+            [('res_model', '=', self._name), ('res_id', 'in', record_ids)]
+        ).unlink()
+        return result
+
+    def _read_progress_bar(self, domain, group_by, progress_bar):
+        group_by_fname = group_by.partition(':')[0]
+        if not (progress_bar['field'] == 'activity_state' and self._fields[group_by_fname].store):
+            return super()._read_progress_bar(domain, group_by, progress_bar)
+
+        # optimization for 'activity_state'
+
+        # explicitly check access rights, since we bypass the ORM
+        self.check_access_rights('read')
+        self._flush_search(domain, fields=[group_by_fname], order='id')
+        self.env['mail.activity'].flush(['res_model', 'res_id', 'user_id', 'date_deadline'])
+
+        query = self._where_calc(domain)
+        self._apply_ir_rules(query, 'read')
+        gb = group_by.partition(':')[0]
+        annotated_groupbys = [
+            self._read_group_process_groupby(gb, query)
+            for gb in [group_by, 'activity_state']
+        ]
+        groupby_dict = {gb['groupby']: gb for gb in annotated_groupbys}
+        for gb in annotated_groupbys:
+            if gb['field'] == 'activity_state':
+                gb['qualified_field'] = '"_last_activity_state"."activity_state"'
+        groupby_terms, _orderby_terms = self._read_group_prepare('activity_state', [], annotated_groupbys, query)
+        select_terms = [
+            '%s as "%s"' % (gb['qualified_field'], gb['groupby'])
+            for gb in annotated_groupbys
+        ]
+        from_clause, where_clause, where_params = query.get_sql()
+        tz = self._context.get('tz') or self.env.user.tz or 'UTC'
+        select_query = """
+            SELECT 1 AS id, count(*) AS "__count", {fields}
+            FROM {from_clause}
+            JOIN (
+                SELECT res_id,
+                CASE
+                    WHEN min(date_deadline - (now() AT TIME ZONE COALESCE(res_partner.tz, %s))::date) > 0 THEN 'planned'
+                    WHEN min(date_deadline - (now() AT TIME ZONE COALESCE(res_partner.tz, %s))::date) < 0 THEN 'overdue'
+                    WHEN min(date_deadline - (now() AT TIME ZONE COALESCE(res_partner.tz, %s))::date) = 0 THEN 'today'
+                    ELSE null
+                END AS activity_state
+                FROM mail_activity
+                JOIN res_users ON (res_users.id = mail_activity.user_id)
+                JOIN res_partner ON (res_partner.id = res_users.partner_id)
+                WHERE res_model = '{model}'
+                GROUP BY res_id
+            ) AS "_last_activity_state" ON ("{table}".id = "_last_activity_state".res_id)
+            WHERE {where_clause}
+            GROUP BY {group_by}
+        """.format(
+            fields=', '.join(select_terms),
+            from_clause=from_clause,
+            model=self._name,
+            table=self._table,
+            where_clause=where_clause or '1=1',
+            group_by=', '.join(groupby_terms),
+        )
+        self.env.cr.execute(select_query, [tz] * 3 + where_params)
+        fetched_data = self.env.cr.dictfetchall()
+        self._read_group_resolve_many2one_fields(fetched_data, annotated_groupbys)
+        data = [
+            {key: self._read_group_prepare_data(key, val, groupby_dict)
+             for key, val in row.items()}
+            for row in fetched_data
+        ]
+        return [
+            self._read_group_format_result(vals, annotated_groupbys, [group_by], domain)
+            for vals in data
+        ]
+
+    def toggle_active(self):
+        """ Before archiving the record we should also remove its ongoing
+        activities. Otherwise they stay in the systray and concerning archived
+        records it makes no sense. """
+        record_to_deactivate = self.filtered(lambda rec: rec[rec._active_name])
+        if record_to_deactivate:
+            # use a sudo to bypass every access rights; all activities should be removed
+            self.env['mail.activity'].sudo().search([
+                ('res_model', '=', self._name),
+                ('res_id', 'in', record_to_deactivate.ids)
+            ]).unlink()
+        return super(MailActivityMixin, self).toggle_active()
+
+    def activity_send_mail(self, template_id):
+        """ Automatically send an email based on the given mail.template, given
+        its ID. """
+        template = self.env['mail.template'].browse(template_id).exists()
+        if not template:
+            return False
+        for record in self:
+            record.message_post_with_template(
+                template_id,
+                composition_mode='comment'
+            )
+        return True
+
+    def activity_search(self, act_type_xmlids='', user_id=None, additional_domain=None):
+        """ Search automated activities on current record set, given a list of activity
+        types xml IDs. It is useful when dealing with specific types involved in automatic
+        activities management.
+
+        :param act_type_xmlids: list of activity types xml IDs
+        :param user_id: if set, restrict to activities of that user_id;
+        :param additional_domain: if set, filter on that domain;
+        """
+        if self.env.context.get('mail_activity_automation_skip'):
+            return False
+
+        Data = self.env['ir.model.data'].sudo()
+        activity_types_ids = [type_id for type_id in (Data._xmlid_to_res_id(xmlid, raise_if_not_found=False) for xmlid in act_type_xmlids) if type_id]
+        if not any(activity_types_ids):
+            return False
+
+        domain = [
+            '&', '&', '&',
+            ('res_model', '=', self._name),
+            ('res_id', 'in', self.ids),
+            ('automated', '=', True),
+            ('activity_type_id', 'in', activity_types_ids)
+        ]
+
+        if user_id:
+            domain = expression.AND([domain, [('user_id', '=', user_id)]])
+        if additional_domain:
+            domain = expression.AND([domain, additional_domain])
+
+        return self.env['mail.activity'].search(domain)
+
+    def activity_schedule(self, act_type_xmlid='', date_deadline=None, summary='', note='', **act_values):
+        """ Schedule an activity on each record of the current record set.
+        This method allow to provide as parameter act_type_xmlid. This is an
+        xml_id of activity type instead of directly giving an activity_type_id.
+        It is useful to avoid having various "env.ref" in the code and allow
+        to let the mixin handle access rights.
+
+        :param date_deadline: the day the activity must be scheduled on
+        the timezone of the user must be considered to set the correct deadline
+        """
+        if self.env.context.get('mail_activity_automation_skip'):
+            return False
+
+        if not date_deadline:
+            date_deadline = fields.Date.context_today(self)
+        if isinstance(date_deadline, datetime):
+            _logger.warning("Scheduled deadline should be a date (got %s)", date_deadline)
+        if act_type_xmlid:
+            activity_type = self.env.ref(act_type_xmlid, raise_if_not_found=False) or self._default_activity_type()
+        else:
+            activity_type_id = act_values.get('activity_type_id', False)
+            activity_type = activity_type_id and self.env['mail.activity.type'].sudo().browse(activity_type_id)
+
+        model_id = self.env['ir.model']._get(self._name).id
+        activities = self.env['mail.activity']
+        for record in self:
+            create_vals = {
+                'activity_type_id': activity_type and activity_type.id,
+                'summary': summary or activity_type.summary,
+                'automated': True,
+                'note': note or activity_type.default_note,
+                'date_deadline': date_deadline,
+                'res_model_id': model_id,
+                'res_id': record.id,
+                'user_id': act_values.get('user_id') or activity_type.default_user_id.id or self.env.uid
+            }
+            create_vals.update(act_values)
+            activities |= self.env['mail.activity'].create(create_vals)
+        return activities
+
+    def _activity_schedule_with_view(self, act_type_xmlid='', date_deadline=None, summary='', views_or_xmlid='', render_context=None, **act_values):
+        """ Helper method: Schedule an activity on each record of the current record set.
+        This method allow to the same mecanism as `activity_schedule`, but provide
+        2 additionnal parameters:
+        :param views_or_xmlid: record of ir.ui.view or string representing the xmlid
+            of the qweb template to render
+        :type views_or_xmlid: string or recordset
+        :param render_context: the values required to render the given qweb template
+        :type render_context: dict
+        """
+        if self.env.context.get('mail_activity_automation_skip'):
+            return False
+
+        render_context = render_context or dict()
+        if isinstance(views_or_xmlid, str):
+            views = self.env.ref(views_or_xmlid, raise_if_not_found=False)
+        else:
+            views = views_or_xmlid
+        if not views:
+            return
+        activities = self.env['mail.activity']
+        for record in self:
+            render_context['object'] = record
+            note = views._render(render_context, engine='ir.qweb', minimal_qcontext=True)
+            activities |= record.activity_schedule(act_type_xmlid=act_type_xmlid, date_deadline=date_deadline, summary=summary, note=note, **act_values)
+        return activities
+
+    def activity_reschedule(self, act_type_xmlids, user_id=None, date_deadline=None, new_user_id=None):
+        """ Reschedule some automated activities. Activities to reschedule are
+        selected based on type xml ids and optionally by user. Purpose is to be
+        able to
+
+         * update the deadline to date_deadline;
+         * update the responsible to new_user_id;
+        """
+        if self.env.context.get('mail_activity_automation_skip'):
+            return False
+
+        Data = self.env['ir.model.data'].sudo()
+        activity_types_ids = [Data._xmlid_to_res_id(xmlid, raise_if_not_found=False) for xmlid in act_type_xmlids]
+        activity_types_ids = [act_type_id for act_type_id in activity_types_ids if act_type_id]
+        if not any(activity_types_ids):
+            return False
+        activities = self.activity_search(act_type_xmlids, user_id=user_id)
+        if activities:
+            write_vals = {}
+            if date_deadline:
+                write_vals['date_deadline'] = date_deadline
+            if new_user_id:
+                write_vals['user_id'] = new_user_id
+            activities.write(write_vals)
+        return activities
+
+    def activity_feedback(self, act_type_xmlids, user_id=None, feedback=None):
+        """ Set activities as done, limiting to some activity types and
+        optionally to a given user. """
+        if self.env.context.get('mail_activity_automation_skip'):
+            return False
+
+        Data = self.env['ir.model.data'].sudo()
+        activity_types_ids = [Data._xmlid_to_res_id(xmlid, raise_if_not_found=False) for xmlid in act_type_xmlids]
+        activity_types_ids = [act_type_id for act_type_id in activity_types_ids if act_type_id]
+        if not any(activity_types_ids):
+            return False
+        activities = self.activity_search(act_type_xmlids, user_id=user_id)
+        if activities:
+            activities.action_feedback(feedback=feedback)
+        return True
+
+    def activity_unlink(self, act_type_xmlids, user_id=None):
+        """ Unlink activities, limiting to some activity types and optionally
+        to a given user. """
+        if self.env.context.get('mail_activity_automation_skip'):
+            return False
+
+        Data = self.env['ir.model.data'].sudo()
+        activity_types_ids = [Data._xmlid_to_res_id(xmlid, raise_if_not_found=False) for xmlid in act_type_xmlids]
+        activity_types_ids = [act_type_id for act_type_id in activity_types_ids if act_type_id]
+        if not any(activity_types_ids):
+            return False
+        self.activity_search(act_type_xmlids, user_id=user_id).unlink()
+        return True

--- a/None
+++ b/addons/mail/models/mail_activity_type.py
@@ -0,0 +1,120 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from odoo import api, fields, models
+
+
+class MailActivityType(models.Model):
+    """ Activity Types are used to categorize activities. Each type is a different
+    kind of activity e.g. call, mail, meeting. An activity can be generic i.e.
+    available for all models using activities; or specific to a model in which
+    case res_model field should be used. """
+    _name = 'mail.activity.type'
+    _description = 'Activity Type'
+    _rec_name = 'name'
+    _order = 'sequence, id'
+
+    def _get_model_selection(self):
+        return [
+            (model.model, model.name)
+            for model in self.env['ir.model'].sudo().search(
+                ['&', ('is_mail_thread', '=', True), ('transient', '=', False)])
+        ]
+
+
+    name = fields.Char('Name', required=True, translate=True)
+    summary = fields.Char('Default Summary', translate=True)
+    sequence = fields.Integer('Sequence', default=10)
+    active = fields.Boolean(default=True)
+    create_uid = fields.Many2one('res.users', index=True)
+    delay_count = fields.Integer(
+        'Schedule', default=0,
+        help='Number of days/week/month before executing the action. It allows to plan the action deadline.')
+    delay_unit = fields.Selection([
+        ('days', 'days'),
+        ('weeks', 'weeks'),
+        ('months', 'months')], string="Delay units", help="Unit of delay", required=True, default='days')
+    delay_label = fields.Char(compute='_compute_delay_label')
+    delay_from = fields.Selection([
+        ('current_date', 'after completion date'),
+        ('previous_activity', 'after previous activity deadline')], string="Delay Type", help="Type of delay", required=True, default='previous_activity')
+    icon = fields.Char('Icon', help="Font awesome icon e.g. fa-tasks")
+    decoration_type = fields.Selection([
+        ('warning', 'Alert'),
+        ('danger', 'Error')], string="Decoration Type",
+        help="Change the background color of the related activities of this type.")
+    res_model = fields.Selection(selection=_get_model_selection, string="Model",
+        help='Specify a model if the activity should be specific to a model'
+             ' and not available when managing activities for other models.')
+    triggered_next_type_id = fields.Many2one(
+        'mail.activity.type', string='Trigger', compute='_compute_triggered_next_type_id',
+        inverse='_inverse_triggered_next_type_id', store=True, readonly=False,
+        domain="['|', ('res_model', '=', False), ('res_model', '=', res_model)]", ondelete='restrict',
+        help="Automatically schedule this activity once the current one is marked as done.")
+    chaining_type = fields.Selection([
+        ('suggest', 'Suggest Next Activity'), ('trigger', 'Trigger Next Activity')
+    ], string="Chaining Type", required=True, default="suggest")
+    suggested_next_type_ids = fields.Many2many(
+        'mail.activity.type', 'mail_activity_rel', 'activity_id', 'recommended_id', string='Suggest',
+        domain="['|', ('res_model', '=', False), ('res_model', '=', res_model)]",
+        compute='_compute_suggested_next_type_ids', inverse='_inverse_suggested_next_type_ids', store=True, readonly=False,
+        help="Suggest these activities once the current one is marked as done.")
+    previous_type_ids = fields.Many2many(
+        'mail.activity.type', 'mail_activity_rel', 'recommended_id', 'activity_id',
+        domain="['|', ('res_model', '=', False), ('res_model', '=', res_model)]",
+        string='Preceding Activities')
+    category = fields.Selection([
+        ('default', 'None'), ('upload_file', 'Upload Document')
+    ], default='default', string='Action',
+        help='Actions may trigger specific behavior like opening calendar view or automatically mark as done when a document is uploaded')
+    mail_template_ids = fields.Many2many('mail.template', string='Email templates')
+    default_user_id = fields.Many2one("res.users", string="Default User")
+    default_note = fields.Html(string="Default Note", translate=True)
+
+    #Fields for display purpose only
+    initial_res_model = fields.Selection(selection=_get_model_selection, string='Initial model', compute="_compute_initial_res_model", store=False,
+            help='Technical field to keep track of the model at the start of editing to support UX related behaviour')
+    res_model_change = fields.Boolean(string="Model has change", help="Technical field for UX related behaviour", default=False, store=False)
+
+    @api.onchange('res_model')
+    def _onchange_res_model(self):
+        self.mail_template_ids = self.sudo().mail_template_ids.filtered(lambda template: template.model_id.model == self.res_model)
+        self.res_model_change = self.initial_res_model and self.initial_res_model != self.res_model
+
+    def _compute_initial_res_model(self):
+        for activity_type in self:
+            activity_type.initial_res_model = activity_type.res_model
+
+    @api.depends('delay_unit', 'delay_count')
+    def _compute_delay_label(self):
+        selection_description_values = {
+            e[0]: e[1] for e in self._fields['delay_unit']._description_selection(self.env)}
+        for activity_type in self:
+            unit = selection_description_values[activity_type.delay_unit]
+            activity_type.delay_label = '%s %s' % (activity_type.delay_count, unit)
+
+    @api.depends('chaining_type')
+    def _compute_suggested_next_type_ids(self):
+        """suggested_next_type_ids and triggered_next_type_id should be mutually exclusive"""
+        for activity_type in self:
+            if activity_type.chaining_type == 'trigger':
+                activity_type.suggested_next_type_ids = False
+
+    def _inverse_suggested_next_type_ids(self):
+        for activity_type in self:
+            if activity_type.suggested_next_type_ids:
+                activity_type.chaining_type = 'suggest'
+
+    @api.depends('chaining_type')
+    def _compute_triggered_next_type_id(self):
+        """suggested_next_type_ids and triggered_next_type_id should be mutually exclusive"""
+        for activity_type in self:
+            if activity_type.chaining_type == 'suggest':
+                activity_type.triggered_next_type_id = False
+
+    def _inverse_triggered_next_type_id(self):
+        for activity_type in self:
+            if activity_type.triggered_next_type_id:
+                activity_type.chaining_type = 'trigger'
+            else:
+                activity_type.chaining_type = 'suggest'

--- a/None
+++ b/addons/mail/models/res_groups.py
@@ -0,0 +1,23 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from odoo import models
+
+
+class ResGroups(models.Model):
+    """ Update of res.groups class
+        - if adding users from a group, check mail.channels linked to this user
+          group and subscribe them. This is done by overriding the write method.
+    """
+    _name = 'res.groups'
+    _inherit = 'res.groups'
+    _description = 'Access Groups'
+
+    def write(self, vals, context=None):
+        write_res = super(ResGroups, self).write(vals)
+        if vals.get('users'):
+            # form: {'group_ids': [(3, 10), (3, 3), (4, 10), (4, 3)]} or {'group_ids': [(6, 0, [ids]}
+            user_ids = [command[1] for command in vals['users'] if command[0] == 4]
+            user_ids += [id for command in vals['users'] if command[0] == 6 for id in command[2]]
+            self.env['mail.channel'].search([('group_ids', 'in', self._ids)])._subscribe_users_automatically()
+        return write_res

--- a/addons/mail/models/res_users.py
+++ b/addons/mail/models/res_users.py
@@ -139,22 +139,3 @@ class Users(models.Model):
                 'name': 'Summary',
             }]
         return list(user_activities.values())
-
-
-class res_groups_mail_channel(models.Model):
-    """ Update of res.groups class
-        - if adding users from a group, check mail.channels linked to this user
-          group and subscribe them. This is done by overriding the write method.
-    """
-    _name = 'res.groups'
-    _inherit = 'res.groups'
-    _description = 'Access Groups'
-
-    def write(self, vals, context=None):
-        write_res = super(res_groups_mail_channel, self).write(vals)
-        if vals.get('users'):
-            # form: {'group_ids': [(3, 10), (3, 3), (4, 10), (4, 3)]} or {'group_ids': [(6, 0, [ids]}
-            user_ids = [command[1] for command in vals['users'] if command[0] == 4]
-            user_ids += [id for command in vals['users'] if command[0] == 6 for id in command[2]]
-            self.env['mail.channel'].search([('group_ids', 'in', self._ids)])._subscribe_users_automatically()
-        return write_res
