PR: https://github.com/odoo/odoo/pull/84000

From: ea680d85958a050b3e072c8530d791a22a8b8a1a
From: Aurélien Warnon
Date: 2022-04-01 16:49:56

Structural Changes: 32
Total Changes: 896

[IMP] im_livechat: introduce chatbot scripts

PURPOSE

This commit introduces a chatbot operator that works based on a user-defined
script with various steps.

SPECS

A im_livechat.chatbot.script can be defined on a livechat rule.
When a end-user reaches a website page that matches the rule, the chat window
opens and the script of the bot starts iterating through its steps.

The chatbot code is currently directly integrated with the existing livechat
Javascript code.
It defines extra conditions and layout elements to be able to automate the
conversation and register user answers.

AVAILABLE STEPS

A script is defined with several steps that can currently be one of the
following types:

"text"

A simple text step where the bot posts a message without expecting an answer
e.g: "Hello! I'm a friendly robot!"

"question_selection"

The bot will ask a question and suggest answers, the end-user will have to
click on the answer he chooses
e.g: "How can I help you?
  -> Create a Ticket
  -> Create a Lead
  -> Speak with a human"

"question_email"

That step will ask the end user's email address (and validate it)
The result is saved on the linked im_livechat.im_livechatchatbot.mail.message

"question_phone"

Same logic as the 'question_email' for a phone number
We don't validate the input this time as it's a complicated process
(requires country, ...)

"forward_operator"

Special type of step that will add a human operator to the conversation when
reached, which stops the script and allow the visitor to discuss with a
real person.

The operator will be chosen among the available operators on the
livechat.channel.

If there is no operator available, the script continues normally which allows
to automate an "answering machine" that will redirect the user in case no
operator is available.

e.g: "I'm sorry, no operator is available right now, please contact us by email
at 'info@company.com', we will try to respond as soon as possible!".
(Or even something more complex with multiple questions / paths).

"free_input_single"

Will ask the visitor for a single line of text.
This text is not saved anywhere else than in the conversation, but it's still
useful when combined with steps that create leads / tickets since those print
the whole conversation into the description.

"free_input_multi"

Same as "free_input_single" but lets the user input multiple lines of text.
The frontend implementation is made by waiting a few seconds (currently 10) for
either the next submitted message or the next character typed into the input.

This lets visitors explain their issue / question with multiple messages.
Which is very useful since new messages are sent every time you press "Enter".

LINKS

Task-2030386

Part-of: odoo/odoo#84000
Co-authored-by: Patrick Hoste <pko@odoo.com>
Co-authored-by: Aurélien Warnon <awa@odoo.com>

================================= pseudo patch: =================================

--- a/addons/im_livechat/models/__init__.py
+++ b/addons/im_livechat/models/__init__.py
@@ -1,5 +1,9 @@
 # -*- coding: utf-8 -*
 
+from . import chatbot_message
+from . import chatbot_script
+from . import chatbot_script_answer
+from . import chatbot_script_step
 from . import res_users
 from . import res_partner
 from . import im_livechat_channel

--- a/None
+++ b/addons/im_livechat/models/chatbot_message.py
@@ -0,0 +1,28 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from odoo import models, fields
+
+
+class ChatbotMailMessage(models.Model):
+    """ Chatbot Mail Message
+        We create a new model to store the related step to a mail.message and the user's answer.
+        We do this in a new model to avoid bloating the 'mail.message' model.
+    """
+
+    _name = 'chatbot.message'
+    _description = 'Chatbot Message'
+    _order = 'create_date desc, id desc'
+    _rec_name = 'mail_channel_id'
+
+    mail_message_id = fields.Many2one('mail.message', string='Related Mail Message', required=True, ondelete="cascade")
+    mail_channel_id = fields.Many2one('mail.channel', string='Discussion Channel', required=True, ondelete="cascade")
+    script_step_id = fields.Many2one(
+        'chatbot.script.step', string='Chatbot Step', required=True, ondelete='cascade')
+    user_script_answer_id = fields.Many2one('chatbot.script.answer', string="User's answer", ondelete="set null")
+    user_raw_answer = fields.Html(string="User's raw answer")
+
+    _sql_constraints = [
+        ('_unique_mail_message_id', 'unique (mail_message_id)',
+         "A mail.message can only be linked to a single chatbot message"),
+    ]

--- a/None
+++ b/addons/im_livechat/models/chatbot_script.py
@@ -0,0 +1,225 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from odoo import _, api, models, fields
+from odoo.tools import email_normalize, html2plaintext, is_html_empty, plaintext2html
+
+
+class ChatbotScript(models.Model):
+    _name = 'chatbot.script'
+    _description = 'Chatbot Script'
+    _inherit = ['image.mixin', 'utm.source.mixin']
+    _rec_name = 'title'
+    _order = 'title'
+
+    # we keep a separate field for UI since name is manipulated by 'utm.source.mixin'
+    title = fields.Char('Title', required=True, translate=True, default="Chatbot")
+    active = fields.Boolean(default=True)
+    image_1920 = fields.Image(related='operator_partner_id.image_1920', readonly=False)
+
+    script_step_ids = fields.One2many('chatbot.script.step', 'chatbot_script_id',
+        copy=True, string='Script Steps')
+    operator_partner_id = fields.Many2one('res.partner', string='Bot Operator',
+        ondelete='restrict', required=True, copy=False)
+    livechat_channel_count = fields.Integer(string='Livechat Channel Count', compute='_compute_livechat_channel_count')
+    first_step_warning = fields.Selection([
+        ('first_step_operator', 'First Step Operator'),
+        ('first_step_invalid', 'First Step Invalid'),
+    ], compute="_compute_first_step_warning")
+
+    def _compute_livechat_channel_count(self):
+        channels_data = self.env['im_livechat.channel.rule'].read_group(
+            [('chatbot_script_id', 'in', self.ids)], ['channel_id:count_distinct'], ['chatbot_script_id'])
+        mapped_channels = {channel['chatbot_script_id'][0]: channel['channel_id'] for channel in channels_data}
+        for script in self:
+            script.livechat_channel_count = mapped_channels.get(script.id, 0)
+
+    @api.depends('script_step_ids.step_type')
+    def _compute_first_step_warning(self):
+        for script in self:
+            allowed_first_step_types = [
+                'question_selection',
+                'question_email',
+                'question_phone',
+                'free_input_single',
+                'free_input_multi',
+            ]
+            welcome_steps = script.script_step_ids and script._get_welcome_steps()
+            if welcome_steps and welcome_steps[-1].step_type == 'forward_operator':
+                script.first_step_warning = 'first_step_operator'
+            elif welcome_steps and welcome_steps[-1].step_type not in allowed_first_step_types:
+                script.first_step_warning = 'first_step_invalid'
+            else:
+                script.first_step_warning = False
+
+    @api.returns('self', lambda value: value.id)
+    def copy(self, default=None):
+        """ Correctly copy the 'triggering_answer_ids' field from the original script_step_ids to the clone.
+        This needs to be done in post-processing to make sure we get references to the newly created
+        answers from the copy instead of references to the answers of the original.
+
+        This implementation assumes that the order of created steps and answers will be kept between
+        the original and the clone, using 'zip()' to match the records between the two. """
+
+        default = default or {}
+        default['title'] = self.title + _(' (copy)')
+
+        clone_chatbot_script = super().copy(default=default)
+        if 'question_ids' in default:
+            return clone_chatbot_script
+
+        answers_map = {
+            original_answer: clone_answer
+            for clone_answer, original_answer
+            in zip(clone_chatbot_script.script_step_ids.answer_ids, self.script_step_ids.answer_ids)
+        }
+
+        for clone_step, original_step in zip(clone_chatbot_script.script_step_ids, self.script_step_ids):
+            clone_step.write({
+                'triggering_answer_ids': [
+                    (4, answer.id)
+                    for answer in [
+                        answers_map[original_answer]
+                        for original_answer
+                        in original_step.triggering_answer_ids
+                    ]
+                ]
+            })
+
+        return clone_chatbot_script
+
+    @api.model_create_multi
+    def create(self, vals_list):
+        operator_partners_values = [self._prepare_operator_partner_values(
+            vals['title'],
+            vals.get('image_1920', False),
+        ) for vals in vals_list if 'operator_partner_id' not in vals and 'title' in vals]
+
+        operator_partners = self.env['res.partner'].create(operator_partners_values)
+
+        for vals, partner in zip(
+            [vals for vals in vals_list if 'operator_partner_id' not in vals and 'title' in vals],
+            operator_partners
+        ):
+            vals['operator_partner_id'] = partner.id
+
+        return super().create(vals_list)
+
+    def write(self, vals):
+        res = super().write(vals)
+
+        if 'title' in vals:
+            self.operator_partner_id.write({'name': vals['title']})
+
+        return res
+
+    def _get_welcome_steps(self):
+        """ Returns a sub-set of script_step_ids that only contains the "welcoming steps".
+        We consider those as all the steps the bot will say before expecting a first answer from
+        the end user.
+
+        Example 1:
+        - step 1 (question_selection): What do you want to do? - Create a Lead, -Create a Ticket
+        - step 2 (text): Thank you for visiting our website!
+        -> The welcoming steps will only contain step 1, since directly after that we expect an
+        input from the user
+
+        Example 2:
+        - step 1 (text): Hello! I'm a bot!
+        - step 2 (text): I am here to help lost users.
+        - step 3 (question_selection): What do you want to do? - Create a Lead, -Create a Ticket
+        - step 4 (text): Thank you for visiting our website!
+        -> The welcoming steps will contain steps 1, 2 and 3.
+        Meaning the bot will have a small monologue with himself before expecting an input from the
+        end user.
+
+        This is important because we need to display those welcoming steps in a special fashion on
+        the frontend, since those are not inserted into the mail.channel as actual mail.messages,
+        to avoid bloating the channels with bot messages if the end-user never interacts with it. """
+        self.ensure_one()
+
+        welcome_steps = self.env['chatbot.script.step']
+        for step in self.script_step_ids:
+            welcome_steps += step
+            if step.step_type != 'text':
+                break
+
+        return welcome_steps
+
+    def _post_welcome_steps(self, mail_channel):
+        """ Welcome messages are only posted after the visitor's first interaction with the chatbot.
+        See 'chatbot.script#_get_welcome_steps()' for more details.
+
+        Side note: it is important to set the 'chatbot_current_step_id' on each iteration so that
+        it's correctly set when going into 'mail_channel#_message_post_after_hook()'. """
+
+        self.ensure_one()
+        posted_messages = self.env['mail.message']
+
+        for welcome_step in self._get_welcome_steps():
+            mail_channel.chatbot_current_step_id = welcome_step.id
+
+            if not is_html_empty(welcome_step.message):
+                posted_messages += mail_channel.with_context(mail_create_nosubscribe=True).message_post(
+                    author_id=self.operator_partner_id.id,
+                    body=plaintext2html(welcome_step.message),
+                    message_type='comment',
+                    subtype_xmlid='mail.mt_comment',
+                )
+
+        return posted_messages
+
+    def _prepare_operator_partner_values(self, name, image):
+        return {
+            'name': name,
+            'image_1920': image,
+            'active': False,
+        }
+
+    def action_view_livechat_channels(self):
+        self.ensure_one()
+        action = self.env['ir.actions.act_window']._for_xml_id('im_livechat.im_livechat_channel_action')
+        action['domain'] = [('rule_ids.chatbot_script_id', 'in', self.ids)]
+        return action
+
+    # --------------------------
+    # Tooling / Misc
+    # --------------------------
+
+    def _format_for_frontend(self):
+        """ Small utility method that formats the script into a dict usable by the frontend code. """
+        self.ensure_one()
+
+        chatbot_avatar_url = '/mail/static/src/img/smiley/avatar.jpg'
+        if bool(self.image_128):
+            chatbot_avatar_url = f'/web/image/chatbot.script/{self.id}/image_128'
+
+        return {
+            'chatbot_script_id': self.id,
+            'chatbot_name': self.title,
+            'chatbot_operator_partner_id': self.operator_partner_id.id,
+            'chatbot_avatar_url': chatbot_avatar_url,
+            'chatbot_welcome_steps': [
+                step._format_for_frontend()
+                for step in self._get_welcome_steps()
+            ]
+        }
+
+    def _validate_email(self, email_address, mail_channel):
+        email_address = html2plaintext(email_address)
+        email_normalized = email_normalize(email_address)
+
+        posted_message = False
+        error_message = False
+        if not email_normalized:
+            error_message = _(
+                "'%(input_email)s' does not look like a valid email. Can you please try again?",
+                input_email=email_address
+            )
+            posted_message = mail_channel._chatbot_post_message(self, plaintext2html(error_message))
+
+        return {
+            'success': bool(email_normalized),
+            'posted_message': posted_message,
+            'error_message': error_message,
+        }

--- a/None
+++ b/addons/im_livechat/models/chatbot_script_answer.py
@@ -0,0 +1,65 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from odoo import api, models, fields
+from odoo.osv import expression
+
+import textwrap
+
+
+class ChatbotScriptAnswer(models.Model):
+    _name = 'chatbot.script.answer'
+    _description = 'Chatbot Script Answer'
+    _order = 'script_step_id, sequence, id'
+
+    name = fields.Char(string='Name', required=True, translate=True)
+    sequence = fields.Integer(string='Sequence', default=1)
+    redirect_link = fields.Char('Redirect Link',
+        help="The visitor will be redirected to this link upon clicking the option "
+             "(note that the script will end if the link is external to the livechat website).")
+    script_step_id = fields.Many2one(
+        'chatbot.script.step', string='Script Step', required=True, ondelete='cascade')
+    chatbot_script_id = fields.Many2one(related='script_step_id.chatbot_script_id')
+
+    def name_get(self):
+        if self._context.get('chatbot_script_answer_display_short_name'):
+            return super().name_get()
+
+        result = []
+        for answer in self:
+            answer_message = answer.script_step_id.message.replace('\n', ' ')
+            shortened_message = textwrap.shorten(answer_message, width=26, placeholder=" [...]")
+
+            result.append((
+                answer.id,
+                "%s: %s" % (shortened_message, answer.name)
+            ))
+
+        return result
+
+    @api.model
+    def _name_search(self, name='', args=None, operator='ilike', limit=100, name_get_uid=None):
+        """
+        Search the records whose name or step message are matching the ``name`` pattern.
+        The chatbot_script_id is also passed to the context through the custom widget
+        ('chatbot_triggering_answers_widget') This allows to only see the question_answer
+        from the same chatbot you're configuring.
+        """
+        force_domain_chatbot_script_id = self.env.context.get('force_domain_chatbot_script_id')
+
+        if name and operator == 'ilike':
+            if not args:
+                args = []
+
+            # search on both name OR step's message (combined with passed args)
+            name_domain = [('name', operator, name)]
+            step_domain = [('script_step_id.message', operator, name)]
+            domain = expression.AND([args, expression.OR([name_domain, step_domain])])
+
+        else:
+            domain = args or []
+
+        if force_domain_chatbot_script_id:
+            domain = expression.AND([domain, [('chatbot_script_id', '=', force_domain_chatbot_script_id)]])
+
+        return self._search(domain, limit=limit, access_rights_uid=name_get_uid)

--- a/None
+++ b/addons/im_livechat/models/chatbot_script_step.py
@@ -0,0 +1,375 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from odoo import _, api, models, fields
+from odoo.exceptions import ValidationError
+from odoo.fields import Command
+from odoo.osv import expression
+from odoo.tools import html2plaintext, is_html_empty, email_normalize, plaintext2html
+
+from collections import defaultdict
+from markupsafe import Markup
+
+
+class ChatbotScriptStep(models.Model):
+    _name = 'chatbot.script.step'
+    _description = 'Chatbot Script Step'
+    _order = 'sequence, id'
+    _rec_name = 'message'
+
+    message = fields.Text(string='Message', translate=True)
+    sequence = fields.Integer(string='Sequence')
+    chatbot_script_id = fields.Many2one(
+        'chatbot.script', string='Chatbot', required=True, ondelete='cascade')
+    step_type = fields.Selection([
+        ('text', 'Text'),
+        ('question_selection', 'Question'),
+        ('question_email', 'Email'),
+        ('question_phone', 'Phone'),
+        ('forward_operator', 'Forward to Operator'),
+        ('free_input_single', 'Free Input'),
+        ('free_input_multi', 'Free Input (Multi-Line)'),
+    ], default='text', required=True)
+    # answers
+    answer_ids = fields.One2many(
+        'chatbot.script.answer', 'script_step_id',
+        copy=True, string='Answers')
+    triggering_answer_ids = fields.Many2many(
+        'chatbot.script.answer', domain="[('script_step_id.sequence', '<', sequence)]",
+        compute='_compute_triggering_answer_ids', readonly=False, store=True,
+        copy=False,  # copied manually, see chatbot.script#copy
+        string='Only If', help='Show this step only if all of these answers have been selected.')
+    # forward-operator specifics
+    is_forward_operator_child = fields.Boolean(compute='_compute_is_forward_operator_child')
+
+    @api.depends('sequence')
+    def _compute_triggering_answer_ids(self):
+        for step in self.filtered('triggering_answer_ids'):
+            update_command = [Command.unlink(answer.id) for answer in step.triggering_answer_ids
+                                if answer.script_step_id.sequence >= step.sequence]
+            if update_command:
+                step.triggering_answer_ids = update_command
+
+    @api.depends('sequence', 'triggering_answer_ids', 'chatbot_script_id.script_step_ids.triggering_answer_ids',
+                 'chatbot_script_id.script_step_ids.answer_ids', 'chatbot_script_id.script_step_ids.sequence')
+    def _compute_is_forward_operator_child(self):
+        parent_steps_by_chatbot = {}
+        for chatbot in self.chatbot_script_id:
+            parent_steps_by_chatbot[chatbot.id] = chatbot.script_step_ids.filtered(
+                lambda step: step.step_type in ['forward_operator', 'question_selection']
+            ).sorted(lambda s: s.sequence, reverse=True)
+        for step in self:
+            parent_steps = parent_steps_by_chatbot[step.chatbot_script_id.id].filtered(
+                lambda s: s.sequence < step.sequence
+            )
+            parent = step
+            while True:
+                parent = parent._get_parent_step(parent_steps)
+                if not parent or parent.step_type == 'forward_operator':
+                    break
+            step.is_forward_operator_child = parent and parent.step_type == 'forward_operator'
+
+    @api.model_create_multi
+    def create(self, vals_list):
+        """ Ensure we correctly assign sequences when creating steps.
+        Indeed, sequences are very important within the script, and will break the whole flow if
+        not correctly defined.
+
+        This override will group created steps by chatbot_id and increment the sequence accordingly.
+        It will also look for an existing step for that chatbot and resume from the highest sequence.
+
+        This cannot be done in a default_value for the sequence field as we cannot search by
+        runbot_id.
+        It is also safer and more efficient to do it here (we can batch everything).
+
+        It is still possible to manually pass the 'sequence' in the values, which will take priority. """
+
+        vals_by_chatbot_id = {}
+        for vals in vals_list:
+            chatbot_id = vals.get('chatbot_script_id')
+            if chatbot_id:
+                step_values = vals_by_chatbot_id.get(chatbot_id, [])
+                step_values.append(vals)
+                vals_by_chatbot_id[chatbot_id] = step_values
+
+        max_sequence_by_chatbot = {}
+        if vals_by_chatbot_id:
+            read_group_results = self.env['chatbot.script.step'].read_group(
+                [('chatbot_script_id', 'in', list(vals_by_chatbot_id.keys()))],
+                ['sequence:max'],
+                ['chatbot_script_id']
+            )
+
+            max_sequence_by_chatbot = {
+                read_group_result['chatbot_script_id'][0]: read_group_result['sequence']
+                for read_group_result in read_group_results
+            }
+
+        for chatbot_id, step_vals in vals_by_chatbot_id.items():
+            current_sequence = 0
+            if chatbot_id in max_sequence_by_chatbot:
+                current_sequence = max_sequence_by_chatbot[chatbot_id] + 1
+
+            for vals in step_vals:
+                if 'sequence' in vals:
+                    current_sequence = vals.get('sequence')
+                else:
+                    vals['sequence'] = current_sequence
+                    current_sequence += 1
+
+        return super().create(vals_list)
+
+    # --------------------------
+    # Business Methods
+    # --------------------------
+
+    def _chatbot_prepare_customer_values(self, mail_channel, create_partner=True, update_partner=True):
+        """ Common method that allows retreiving default customer values from the mail.channel
+        following a chatbot.script.
+
+        This method will return a dict containing the 'customer' values such as:
+        {
+            'partner': The created partner (see 'create_partner') or the partner from the
+              environment if not public
+            'email': The email extracted from the mail.channel messages
+              (see step_type 'question_email')
+            'phone': The phone extracted from the mail.channel messages
+              (see step_type 'question_phone')
+            'description': A default description containing the "Please contact me on" and "Please
+              call me on" with the related email and phone numbers.
+              Can be used as a default description to create leads or tickets for example.
+        }
+
+        :param record mail_channel: the mail.channel holding the visitor's conversation with the bot.
+        :param bool create_partner: whether or not to create a res.partner is the current user is public.
+          Defaults to True.
+        :param bool update_partner: whether or not to set update the email and phone on the res.partner
+          from the environment (if not a public user) if those are not set yet. Defaults to True.
+
+        :return dict: a dict containing the customer values."""
+
+        partner = False
+        user_inputs = mail_channel._chatbot_find_customer_values_in_messages({
+            'question_email': 'email',
+            'question_phone': 'phone',
+        })
+        input_email = user_inputs.get('email', False)
+        input_phone = user_inputs.get('phone', False)
+
+        if self.env.user._is_public() and create_partner:
+            partner = self.env['res.partner'].create({
+                'name': input_email,
+                'email': input_email,
+                'phone': input_phone,
+            })
+        elif not self.env.user._is_public():
+            partner = self.env.user.partner_id
+            if update_partner:
+                # update email/phone value from partner if not set
+                update_values = {}
+                if input_email and not partner.email:
+                    update_values['email'] = input_email
+                if input_phone and not partner.phone:
+                    update_values['phone'] = input_phone
+                if update_values:
+                    partner.write(update_values)
+
+        description = Markup('')
+        if input_email:
+            description += Markup('%s<strong>%s</strong><br>') % (_('Please contact me on: '), input_email)
+        if input_phone:
+            description += Markup('%s<strong>%s</strong><br>') % (_('Please call me on: '), input_phone)
+        if description:
+            description += Markup('<br>')
+
+        return {
+            'partner': partner,
+            'email': input_email,
+            'phone': input_phone,
+            'description': description,
+        }
+
+    def _fetch_next_step(self, selected_answer_ids):
+        """ Fetch the next step depending on the user's selected answers.
+            If a step contains multiple triggering answers from the same step the condition between
+            them must be a 'OR'. If is contains multiple triggering answers from different steps the
+            condition between them must be a 'AND'.
+
+            e.g:
+
+            STEP 1 : A B
+            STEP 2 : C D
+            STEP 3 : E
+            STEP 4 ONLY IF A B C E
+
+            Scenario 1 (A C E):
+
+            A in (A B) -> OK
+            C in (C)   -> OK
+            E in (E)   -> OK
+
+            -> OK
+
+            Scenario 2 (B D E):
+
+            B in (A B) -> OK
+            D in (C)   -> NOK
+            E in (E)   -> OK
+
+            -> NOK
+        """
+        self.ensure_one()
+        domain = [('chatbot_script_id', '=', self.chatbot_script_id.id), ('sequence', '>', self.sequence)]
+        if selected_answer_ids:
+            domain = expression.AND([domain, [
+                '|',
+                ('triggering_answer_ids', '=', False),
+                ('triggering_answer_ids', 'in', selected_answer_ids.ids)]])
+        steps = self.env['chatbot.script.step'].search(domain)
+        for step in steps:
+            if not step.triggering_answer_ids:
+                return step
+            answers_by_step = defaultdict(list)
+            for answer in step.triggering_answer_ids:
+                answers_by_step[answer.script_step_id.id].append(answer)
+            if all(any(answer in step_triggering_answers for answer in selected_answer_ids)
+                   for step_triggering_answers in answers_by_step.values()):
+                return step
+        return self.env['chatbot.script.step']
+
+    def _get_parent_step(self, all_parent_steps):
+        """ Returns the first preceding step that matches either the triggering answers
+         or the possible answers the user can select """
+        self.ensure_one()
+
+        if not self.chatbot_script_id.ids:
+            return self.env['chatbot.script.step']
+
+        for step in all_parent_steps:
+            if step.sequence >= self.sequence:
+                continue
+            if self.triggering_answer_ids:
+                if not (all(answer in self.triggering_answer_ids for answer in step.triggering_answer_ids) or
+                        any(answer in self.triggering_answer_ids for answer in step.answer_ids)):
+                    continue
+            elif step.triggering_answer_ids:
+                continue
+            return step
+        return self.env['chatbot.script.step']
+
+    def _is_last_step(self, mail_channel=False):
+        self.ensure_one()
+        mail_channel = mail_channel or self.env['mail.channel']
+
+        # if it's not a question and if there is no next step, then we end the script
+        if self.step_type != 'question_selection' and not self._fetch_next_step(
+           mail_channel.chatbot_message_ids.user_script_answer_id):
+            return True
+
+        return False
+
+    def _process_answer(self, mail_channel, message_body):
+        """ Method called when the user reacts to the current chatbot.script step.
+        For most chatbot.script.step#step_types it simply returns the next chatbot.script.step of
+        the script (see '_fetch_next_step').
+
+        Some extra processing is done for steps of type 'question_email' and 'question_phone' where
+        we store the user raw answer (the mail message HTML body) into the chatbot.message in order
+        to be able to recover it later (see '_chatbot_prepare_customer_values').
+
+        :param mail_channel:
+        :param message_body:
+        :return: script step to display next
+        :rtype: 'chatbot.script.step' """
+
+        self.ensure_one()
+
+        user_text_answer = html2plaintext(message_body)
+        if self.step_type == 'question_email' and not email_normalize(user_text_answer):
+            # if this error is raised, display an error message but do not go to next step
+            raise ValidationError(_('"%s" is not a valid email.', user_text_answer))
+
+        if self.step_type in ['question_email', 'question_phone']:
+            chatbot_message = self.env['chatbot.message'].search([
+                ('mail_channel_id', '=', mail_channel.id),
+                ('script_step_id', '=', self.id),
+            ], limit=1)
+
+            if chatbot_message:
+                chatbot_message.write({'user_raw_answer': message_body})
+                chatbot_message.flush()
+
+        return self._fetch_next_step(mail_channel.chatbot_message_ids.user_script_answer_id)
+
+    def _process_step(self, mail_channel):
+        """ When we reach a chatbot.step in the script we need to do some processing on behalf of
+        the bot. Which is for most chatbot.script.step#step_types just posting the message field.
+
+        Some extra processing may be required for special step types such as 'forward_operator',
+        'create_lead', 'create_ticket' (in their related bridge modules).
+        Those will have a dedicated processing method with specific docstrings.
+
+        Returns the mail.message posted by the chatbot's operator_partner_id. """
+
+        self.ensure_one()
+        # We change the current step to the new step
+        mail_channel.chatbot_current_step_id = self.id
+
+        if self.step_type == 'forward_operator':
+            return self._process_step_forward_operator(mail_channel)
+
+        return mail_channel._chatbot_post_message(self.chatbot_script_id, plaintext2html(self.message))
+
+    def _process_step_forward_operator(self, mail_channel):
+        """ Special type of step that will add a human operator to the conversation when reached,
+        which stops the script and allow the visitor to discuss with a real person.
+
+        In case we don't find any operator (e.g: no-one is available) we don't post any messages.
+        The script will continue normally, which allows to add extra steps when it's the case
+        (e.g: ask for the visitor's email and create a lead). """
+
+        human_operator = False
+        posted_message = False
+
+        if mail_channel.livechat_channel_id:
+            human_operator = mail_channel.livechat_channel_id._get_random_operator()
+
+        if human_operator:
+            mail_channel.sudo().add_members(
+                human_operator.partner_id.ids,
+                open_chat_window=True,
+                post_joined_message=False)
+
+            if self.message:
+                # first post the message of the step (if we have one)
+                posted_message = mail_channel._chatbot_post_message(self.chatbot_script_id, plaintext2html(self.message))
+
+            # then post a small custom 'Operator has joined' notification
+            mail_channel._chatbot_post_message(
+                self.chatbot_script_id,
+                Markup('<div class="o_mail_notification">%s</div>') % _('%s has joined', human_operator.partner_id.name))
+
+            mail_channel._broadcast(human_operator.partner_id.ids)
+            mail_channel.channel_pin(mail_channel.uuid, pinned=True)
+
+        return posted_message
+
+    # --------------------------
+    # Tooling / Misc
+    # --------------------------
+
+    def _format_for_frontend(self):
+        """ Small utility method that formats the step into a dict usable by the frontend code. """
+        self.ensure_one()
+
+        return {
+            'chatbot_script_step_id': self.id,
+            'chatbot_step_answers': [{
+                'id': answer.id,
+                'label': answer.name,
+                'redirect_link': answer.redirect_link,
+            } for answer in self.answer_ids],
+            'chatbot_step_message': plaintext2html(self.message) if not is_html_empty(self.message) else False,
+            'chatbot_step_is_last': self._is_last_step(),
+            'chatbot_step_type': self.step_type
+        }

--- a/addons/im_livechat/models/im_livechat_channel.py
+++ b/addons/im_livechat/models/im_livechat_channel.py
@@ -51,12 +51,21 @@ class ImLivechatChannel(models.Model):
     # relationnal fields
     user_ids = fields.Many2many('res.users', 'im_livechat_channel_im_user', 'channel_id', 'user_id', string='Operators', default=_default_user_ids)
     channel_ids = fields.One2many('mail.channel', 'livechat_channel_id', 'Sessions')
+    chatbot_script_count = fields.Integer(string='Number of Chatbot', compute='_compute_chatbot_script_count')
     rule_ids = fields.One2many('im_livechat.channel.rule', 'channel_id', 'Rules')
 
     def _are_you_inside(self):
         for channel in self:
             channel.are_you_inside = bool(self.env.uid in [u.id for u in channel.user_ids])
 
+    @api.depends('rule_ids.chatbot_script_id')
+    def _compute_chatbot_script_count(self):
+        data = self.env['im_livechat.channel.rule'].read_group(
+            [('channel_id', 'in', self.ids)], ['chatbot_script_id:count_distinct'], ['channel_id'])
+        mapped_data = {rule['channel_id'][0]: rule['chatbot_script_id'] for rule in data}
+        for channel in self:
+            channel.chatbot_script_count = mapped_data.get(channel.id, 0)
+
     def _compute_script_external(self):
         values = {
             "dbname": self._cr.dbname,
@@ -100,6 +109,18 @@ class ImLivechatChannel(models.Model):
         action['context'] = {'search_default_parent_res_name': self.name}
         return action
 
+    def action_view_chatbot_scripts(self):
+        action = self.env['ir.actions.act_window']._for_xml_id('im_livechat.chatbot_script_action')
+        chatbot_script_ids = self.env['im_livechat.channel.rule'].search(
+            [('channel_id', 'in', self.ids)]).mapped('chatbot_script_id')
+        if len(chatbot_script_ids) == 1:
+            action['res_id'] = chatbot_script_ids.id
+            action['view_mode'] = 'form'
+            action['views'] = [(False, 'form')]
+        else:
+            action['domain'] = [('id', 'in', chatbot_script_ids.ids)]
+        return action
+
     # --------------------------
     # Channel Methods
     # --------------------------
@@ -110,31 +131,43 @@ class ImLivechatChannel(models.Model):
         self.ensure_one()
         return self.user_ids.filtered(lambda user: user.im_status == 'online')
 
-    def _get_livechat_mail_channel_vals(self, anonymous_name, operator, user_id=None, country_id=None):
+    def _get_livechat_mail_channel_vals(self, anonymous_name, operator=None, chatbot_script=None, user_id=None, country_id=None):
         # partner to add to the mail.channel
-        operator_partner_id = operator.partner_id.id
+        operator_partner_id = operator.partner_id.id if operator else chatbot_script.operator_partner_id.id
         channel_partner_to_add = [Command.create({'partner_id': operator_partner_id, 'is_pinned': False})]
         visitor_user = False
         if user_id:
             visitor_user = self.env['res.users'].browse(user_id)
-            if visitor_user and visitor_user.active and visitor_user != operator:  # valid session user (not public)
+            if visitor_user and visitor_user.active and operator and visitor_user != operator:  # valid session user (not public)
                 channel_partner_to_add.append(Command.create({'partner_id': visitor_user.partner_id.id}))
+
+        if chatbot_script:
+            name = chatbot_script.title
+        else:
+            name = ' '.join([
+                visitor_user.display_name if visitor_user else anonymous_name,
+                operator.livechat_username if operator.livechat_username else operator.name
+            ])
+
         return {
             'channel_last_seen_partner_ids': channel_partner_to_add,
             'livechat_active': True,
             'livechat_operator_id': operator_partner_id,
             'livechat_channel_id': self.id,
+            'chatbot_current_step_id': chatbot_script._get_welcome_steps()[-1].id if chatbot_script else False,
             'anonymous_name': False if user_id else anonymous_name,
             'country_id': country_id,
             'channel_type': 'livechat',
-            'name': ' '.join([visitor_user.display_name if visitor_user else anonymous_name, operator.livechat_username if operator.livechat_username else operator.name]),
+            'name': name,
             'public': 'private',
         }
 
-    def _open_livechat_mail_channel(self, anonymous_name, previous_operator_id=None, user_id=None, country_id=None):
-        """ Return a mail.channel given a livechat channel. It creates one with a connected operator, or return false otherwise
+    def _open_livechat_mail_channel(self, anonymous_name, previous_operator_id=None, chatbot_script=None, user_id=None, country_id=None):
+        """ Return a mail.channel given a livechat channel. It creates one with a connected operator or with Odoobot as
+            an operator if a chatbot has been configured, or return false otherwise
             :param anonymous_name : the name of the anonymous person of the channel
             :param previous_operator_id : partner_id.id of the previous operator that this visitor had in the past
+            :param chatbot_script : chatbot script if there is one configured
             :param user_id : the id of the logged in visitor, if any
             :param country_code : the country of the anonymous person of the channel
             :type anonymous_name : str
@@ -145,22 +178,27 @@ class ImLivechatChannel(models.Model):
             the system will first try to assign that operator if he's available (to improve user experience).
         """
         self.ensure_one()
-        operator = False
-        if previous_operator_id:
+        user_operator = False
+        if chatbot_script:
+            if chatbot_script.id not in self.env['im_livechat.channel.rule'].search(
+                    [('channel_id', 'in', self.ids)]).mapped('chatbot_script_id').ids:
+                return False
+        elif previous_operator_id:
             available_users = self._get_available_users()
             # previous_operator_id is the partner_id of the previous operator, need to convert to user
             if previous_operator_id in available_users.mapped('partner_id').ids:
-                operator = next(available_user for available_user in available_users if available_user.partner_id.id == previous_operator_id)
-        if not operator:
-            operator = self._get_random_operator()
-        if not operator:
+                user_operator = next(available_user for available_user in available_users if available_user.partner_id.id == previous_operator_id)
+        if not user_operator and not chatbot_script:
+            user_operator = self._get_random_operator()
+        if not user_operator and not chatbot_script:
             # no one available
             return False
 
         # create the session, and add the link with the given channel
-        mail_channel_vals = self._get_livechat_mail_channel_vals(anonymous_name, operator, user_id=user_id, country_id=country_id)
+        mail_channel_vals = self._get_livechat_mail_channel_vals(anonymous_name, user_operator, chatbot_script, user_id=user_id, country_id=country_id)
         mail_channel = self.env["mail.channel"].with_context(mail_create_nosubscribe=False).sudo().create(mail_channel_vals)
-        mail_channel._broadcast([operator.partner_id.id])
+        if user_operator:
+            mail_channel._broadcast([user_operator.partner_id.id])
         return mail_channel.sudo().channel_info()[0]
 
     def _get_random_operator(self):
@@ -224,7 +262,7 @@ class ImLivechatChannel(models.Model):
         if username is None:
             username = _('Visitor')
         info = {}
-        info['available'] = len(self._get_available_users()) > 0
+        info['available'] = self.chatbot_script_count or len(self._get_available_users()) > 0
         info['server_url'] = self.get_base_url()
         if info['available']:
             info['options'] = self._get_channel_infos()
@@ -245,13 +283,18 @@ class ImLivechatChannelRule(models.Model):
 
     regex_url = fields.Char('URL Regex',
         help="Regular expression specifying the web pages this rule will be applied on.")
-    action = fields.Selection([('display_button', 'Display the button'), ('auto_popup', 'Auto popup'), ('hide_button', 'Hide the button')],
-        string='Action', required=True, default='display_button',
+    action = fields.Selection([
+        ('display_button', 'Display the LiveChat Button'),
+        ('auto_popup', 'Autopop LiveChat'),
+        ('hide_button', 'Hide all buttons')], string='Action', required=True, default='display_button',
         help="* 'Display the button' displays the chat button on the pages.\n"\
              "* 'Auto popup' displays the button and automatically open the conversation pane.\n"\
-             "* 'Hide the button' hides the chat button on the pages.")
+             "* 'Hide the button' hides the chat button on the pages.\n")
     auto_popup_timer = fields.Integer('Auto popup timer', default=0,
         help="Delay (in seconds) to automatically open the conversation window. Note: the selected action must be 'Auto popup' otherwise this parameter will not be taken into account.")
+    chatbot_script_id = fields.Many2one('chatbot.script', string='Chatbot')
+    chatbot_only_if_no_operator = fields.Boolean(
+        string='Enabled only if no operator', help='Enable the bot only if there is no operator available')
     channel_id = fields.Many2one('im_livechat.channel', 'Channel',
         help="The channel of the rule")
     country_ids = fields.Many2many('res.country', 'im_livechat_channel_country_rel', 'channel_id', 'country_id', 'Country',

--- a/addons/im_livechat/models/mail_channel.py
+++ b/addons/im_livechat/models/mail_channel.py
@@ -2,7 +2,9 @@
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
 from odoo import api, fields, models, _
-from odoo.tools import html_escape
+from odoo.tools import email_normalize, html_escape, html2plaintext, plaintext2html
+
+from markupsafe import Markup
 
 
 class MailChannel(models.Model):
@@ -19,6 +21,8 @@ class MailChannel(models.Model):
     livechat_active = fields.Boolean('Is livechat ongoing?', help='Livechat session is active until visitor leave the conversation.')
     livechat_channel_id = fields.Many2one('im_livechat.channel', 'Channel')
     livechat_operator_id = fields.Many2one('res.partner', string='Operator', help="""Operator for this specific channel""")
+    chatbot_current_step_id = fields.Many2one('chatbot.script.step', string='Chatbot Current Step')
+    chatbot_message_ids = fields.One2many('chatbot.message', 'mail_channel_id', string='Chatbot Messages')
     country_id = fields.Many2one('res.country', string="Country", help="Country of the visitor of the channel")
 
     _sql_constraints = [('livechat_operator_id', "CHECK((channel_type = 'livechat' and livechat_operator_id is not null) or (channel_type != 'livechat'))",
@@ -173,3 +177,92 @@ class MailChannel(models.Model):
             'body_html': mail_body,
         })
         mail.send()
+
+    def _get_channel_history(self):
+        """
+        Converting message body back to plaintext for correct data formatting in HTML field.
+        """
+        return Markup('').join(
+            Markup('%s: %s<br/>') % (message.author_id.name or self.anonymous_name, html2plaintext(message.body))
+            for message in self.message_ids.sorted('id')
+        )
+
+    # =======================
+    # Chatbot
+    # =======================
+
+    def _chatbot_find_customer_values_in_messages(self, step_type_to_field):
+        """
+        Look for user's input in the channel's messages based on a dictionary
+        mapping the step_type to the field name of the model it will be used on.
+
+        :param dict step_type_to_field: a dict of step types to customer fields
+            to fill, like : {'question_email': 'email_from', 'question_phone': 'mobile'}
+        """
+        values = {}
+        filtered_message_ids = self.chatbot_message_ids.filtered(
+            lambda m: m.script_step_id.step_type in step_type_to_field.keys()
+        )
+        for message_id in filtered_message_ids:
+            field_name = step_type_to_field[message_id.script_step_id.step_type]
+            if not values.get(field_name):
+                values[field_name] = html2plaintext(message_id.user_raw_answer or '')
+
+        return values
+
+    def _chatbot_post_message(self, chatbot_script, body):
+        """ Small helper to post a message as the chatbot operator
+
+        :param record chatbot_script
+        :param string body: message HTML body """
+
+        return self.with_context(mail_create_nosubscribe=True).message_post(
+            author_id=chatbot_script.operator_partner_id.id,
+            body=body,
+            message_type='comment',
+            subtype_xmlid='mail.mt_comment',
+        )
+
+    def _chatbot_validate_email(self, email_address, chatbot_script):
+        email_address = html2plaintext(email_address)
+        email_normalized = email_normalize(email_address)
+
+        posted_message = False
+        error_message = False
+        if not email_normalized:
+            error_message = _(
+                "'%(input_email)s' does not look like a valid email. Can you please try again?",
+                input_email=email_address
+            )
+            posted_message = self._chatbot_post_message(chatbot_script, plaintext2html(error_message))
+
+        return {
+            'success': bool(email_normalized),
+            'posted_message': posted_message,
+            'error_message': error_message,
+        }
+
+    def _message_post_after_hook(self, message, msg_vals):
+        """
+        This method is called just before _notify_thread() method which is calling the _message_format()
+        method. We need a 'chatbot.message' record before it happens to correctly display the message.
+        It's created only if the mail channel is linked to a chatbot step.
+        """
+        if self.chatbot_current_step_id:
+            self.env['chatbot.message'].sudo().create({
+                'mail_message_id': message.id,
+                'mail_channel_id': self.id,
+                'script_step_id': self.chatbot_current_step_id.id,
+            })
+        return super(MailChannel, self)._message_post_after_hook(message, msg_vals)
+
+    def _chatbot_restart(self, chatbot_script):
+        self.write({
+            'chatbot_current_step_id': False
+        })
+
+        self.chatbot_message_ids.unlink()
+
+        return self._chatbot_post_message(
+            chatbot_script,
+            '<div class="o_mail_notification">%s</div>' % _('Restarting conversation...'))

--- a/addons/im_livechat/models/mail_message.py
+++ b/addons/im_livechat/models/mail_message.py
@@ -10,12 +10,33 @@ class MailMessage(models.Model):
     def _message_format(self, fnames, format_reply=True):
         """Override to remove email_from and to return the livechat username if applicable.
         A third param is added to the author_id tuple in this case to be able to differentiate it
-        from the normal name in client code."""
+        from the normal name in client code.
+
+        In addition, if we are currently running a chatbot.script, we include the information about
+        the chatbot.message related to this mail.message.
+        This allows the frontend display to include the additional features
+        (e.g: Show additional buttons with the available answers for this step). """
+
         vals_list = super()._message_format(fnames=fnames, format_reply=format_reply)
         for vals in vals_list:
             message_sudo = self.browse(vals['id']).sudo().with_prefetch(self.ids)
-            if message_sudo.model == 'mail.channel' and self.env['mail.channel'].browse(message_sudo.res_id).channel_type == 'livechat':
+            mail_channel = self.env['mail.channel'].browse(message_sudo.res_id) if message_sudo.model == 'mail.channel' else self.env['mail.channel']
+            if mail_channel.channel_type == 'livechat':
                 vals.pop('email_from')
                 if message_sudo.author_id.user_livechat_username:
                     vals['author_id'] = (message_sudo.author_id.id, message_sudo.author_id.user_livechat_username, message_sudo.author_id.user_livechat_username)
+                if mail_channel.chatbot_current_step_id \
+                        and message_sudo.author_id == mail_channel.chatbot_current_step_id.chatbot_script_id.operator_partner_id:
+                    chatbot_message_id = self.env['chatbot.message'].sudo().search([
+                        ('mail_message_id', '=', message_sudo.id)], limit=1)
+                    if chatbot_message_id.script_step_id:
+                        vals['chatbot_script_step_id'] = chatbot_message_id.script_step_id.id
+                        if chatbot_message_id.script_step_id.step_type == 'question_selection':
+                            vals['chatbot_step_answers'] = [{
+                                'id': answer.id,
+                                'label': answer.name,
+                                'redirect_link': answer.redirect_link,
+                            } for answer in chatbot_message_id.script_step_id.answer_ids]
+                    if chatbot_message_id.user_script_answer_id:
+                        vals['chatbot_selected_answer_id'] = chatbot_message_id.user_script_answer_id.id
         return vals_list
