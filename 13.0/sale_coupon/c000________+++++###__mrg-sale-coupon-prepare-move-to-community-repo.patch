PR: https://github.com/odoo/odoo/pull/

From: ac5469646cdea7c0990fbd5092eae26e7e0768ae
From: Jeremy Kersten
Date: 2019-04-01 08:41:55

Structural Changes: 54
Total Changes: 957

[MRG] sale_coupon: prepare move to community repo

================================= pseudo patch: =================================

--- a/None
+++ b/addons/sale_coupon/models/__init__.py
@@ -0,0 +1,8 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from . import sale_coupon
+from . import sale_coupon_reward
+from . import sale_coupon_rules
+from . import sale_coupon_program
+from . import sale_order

--- a/None
+++ b/addons/sale_coupon/models/sale_coupon.py
@@ -0,0 +1,109 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+import random
+from dateutil.relativedelta import relativedelta
+
+from odoo import api, fields, models, _
+
+
+class SaleCoupon(models.Model):
+    _name = 'sale.coupon'
+    _description = "Sales Coupon"
+    _rec_name = 'code'
+
+    @api.model
+    def _generate_code(self):
+        """Generate a 20 char long pseudo-random string of digits for barcode
+        generation.
+
+        A decimal serialisation is longer than a hexadecimal one *but* it
+        generates a more compact barcode (Code128C rather than Code128A).
+
+        Generate 8 bytes (64 bits) barcodes as 16 bytes barcodes are not 
+        compatible with all scanners.
+         """
+        return str(random.getrandbits(64))
+
+    code = fields.Char(default=_generate_code, required=True, readonly=True)
+    expiration_date = fields.Date('Expiration Date', compute='_compute_expiration_date')
+    state = fields.Selection([
+        ('reserved', 'Reserved'),
+        ('new', 'Valid'),
+        ('used', 'Consumed'),
+        ('expired', 'Expired')
+        ], required=True, default='new')
+    partner_id = fields.Many2one('res.partner', "For Customer")
+    program_id = fields.Many2one('sale.coupon.program', "Program")
+    order_id = fields.Many2one('sale.order', 'Order Reference', readonly=True,
+        help="The sales order from which coupon is generated")
+    sales_order_id = fields.Many2one('sale.order', 'Applied on order', readonly=True,
+        help="The sales order on which the coupon is applied")
+    discount_line_product_id = fields.Many2one('product.product', related='program_id.discount_line_product_id', readonly=False,
+        help='Product used in the sales order to apply the discount.')
+
+    _sql_constraints = [
+        ('unique_coupon_code', 'unique(code)', 'The coupon code must be unique!'),
+    ]
+
+    def _compute_expiration_date(self):
+        for coupon in self.filtered(lambda x: x.program_id.validity_duration > 0):
+            coupon.expiration_date = (coupon.create_date + relativedelta(days=coupon.program_id.validity_duration)).date()
+
+    def _check_coupon_code(self, order):
+        message = {}
+        applicable_programs = order._get_applicable_programs()
+        if self.state in ('used', 'expired') or \
+           (self.expiration_date and self.expiration_date < order.date_order.date()):
+            message = {'error': _('This coupon %s has been used or is expired.') % (self.code)}
+        elif self.state == 'reserved':
+            message = {'error': _('This coupon %s exists but the origin sales order is not validated yet.') % (self.code)}
+        # Minimum requirement should not be checked if the coupon got generated by a promotion program (the requirement should have only be checked to generate the coupon)
+        elif self.program_id.program_type == 'coupon_program' and not self.program_id._filter_on_mimimum_amount(order):
+            message = {'error': _('A minimum of %s %s should be purchased to get the reward') % (self.program_id.rule_minimum_amount, self.program_id.currency_id.name)}
+        elif not self.program_id.active:
+            message = {'error': _('The coupon program for %s is in draft or closed state') % (self.code)}
+        elif self.partner_id and self.partner_id != order.partner_id:
+            message = {'error': _('Invalid partner.')}
+        elif self.program_id in order.applied_coupon_ids.mapped('program_id'):
+            message = {'error': _('A Coupon is already applied for the same reward')}
+        elif self.program_id._is_global_discount_program() and order._is_global_discount_already_applied():
+            message = {'error': _('Global discounts are not cumulable.')}
+        elif self.program_id.reward_type == 'product' and not order._is_reward_in_order_lines(self.program_id):
+            message = {'error': _('The reward products should be in the sales order lines to apply the discount.')}
+        elif not self.program_id._is_valid_partner(order.partner_id):
+            message = {'error': _("The customer doesn't have access to this reward.")}
+        # Product requirement should not be checked if the coupon got generated by a promotion program (the requirement should have only be checked to generate the coupon)
+        elif self.program_id.program_type == 'coupon_program' and not self.program_id._filter_programs_on_products(order):
+            message = {'error': _("You don't have the required product quantities on your sales order. All the products should be recorded on the sales order. (Example: You need to have 3 T-shirts on your sales order if the promotion is 'Buy 2, Get 1 Free').")}
+        else:
+            if self.program_id not in applicable_programs and self.program_id.promo_applicability == 'on_current_order':
+                message = {'error': _('At least one of the required conditions is not met to get the reward!')}
+        return message
+
+    @api.multi
+    def action_coupon_sent(self):
+        """ Open a window to compose an email, with the edi invoice template
+            message loaded by default
+        """
+        self.ensure_one()
+        template = self.env.ref('sale_coupon.mail_template_sale_coupon', False)
+        compose_form = self.env.ref('mail.email_compose_message_wizard_form', False)
+        ctx = dict(
+            default_model='sale.coupon',
+            default_res_id=self.id,
+            default_use_template=bool(template),
+            default_template_id=template.id,
+            default_composition_mode='comment',
+            custom_layout='mail.mail_notification_light',
+        )
+        return {
+            'name': _('Compose Email'),
+            'type': 'ir.actions.act_window',
+            'view_type': 'form',
+            'view_mode': 'form',
+            'res_model': 'mail.compose.message',
+            'views': [(compose_form.id, 'form')],
+            'view_id': compose_form.id,
+            'target': 'new',
+            'context': ctx,
+        }

--- a/None
+++ b/addons/sale_coupon/models/sale_coupon_program.py
@@ -0,0 +1,296 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from odoo import api, fields, models, _
+from odoo.exceptions import UserError, ValidationError
+from odoo.tools.safe_eval import safe_eval
+
+
+class SaleCouponProgram(models.Model):
+    _name = 'sale.coupon.program'
+    _description = "Sales Coupon Program"
+    _inherits = {'sale.coupon.rule': 'rule_id', 'sale.coupon.reward': 'reward_id'}
+    # We should apply 'discount' promotion first to avoid offering free product when we should not.
+    # Eg: If the discount lower the SO total below the required threshold
+    # Note: This is only revelant when programs have the same sequence (which they have by default)
+    _order = "sequence, reward_type"
+
+    name = fields.Char(required=True, translate=True)
+    active = fields.Boolean('Active', default=True, help="A program is available for the customers when active")
+    rule_id = fields.Many2one('sale.coupon.rule', string="Coupon Rule", ondelete='restrict', required=True)
+    reward_id = fields.Many2one('sale.coupon.reward', string="Reward", ondelete='restrict', required=True, copy=False)
+    sequence = fields.Integer(copy=False,
+        help="Coupon program will be applied based on given sequence if multiple programs are " +
+        "defined on same condition(For minimum amount)")
+    maximum_use_number = fields.Integer(help="Maximum number of sales orders in which reward can be provided")
+    program_type = fields.Selection([
+        ('promotion_program', 'Promotional Program'),
+        ('coupon_program', 'Coupon Program'),
+        ],
+        help="""A promotional program can be either a limited promotional offer without code (applied automatically)
+                or with a code (displayed on a magazine for example) that may generate a discount on the current
+                order or create a coupon for a next order.
+
+                A coupon program generates coupons with a code that can be used to generate a discount on the current
+                order or create a coupon for a next order.""")
+    promo_code_usage = fields.Selection([
+        ('no_code_needed', 'Automatically Applied'),
+        ('code_needed', 'Use a code')],
+        help="Automatically Applied - No code is required, if the program rules are met, the reward is applied (Except the global discount or the free shipping rewards which are not cumulative)\n" +
+             "Use a code - If the program rules are met, a valid code is mandatory for the reward to be applied\n")
+    promo_code = fields.Char('Promotion Code', copy=False,
+        help="A promotion code is a code that is associated with a marketing discount. For example, a retailer might tell frequent customers to enter the promotion code 'THX001' to receive a 10%% discount on their whole order.")
+    promo_applicability = fields.Selection([
+        ('on_current_order', 'Apply On Current Order'),
+        ('on_next_order', 'Apply On Next Order')],
+        default='on_current_order', string="Applicability")
+    coupon_ids = fields.One2many('sale.coupon', 'program_id', string="Generated Coupons", copy=False)
+    coupon_count = fields.Integer(compute='_compute_coupon_count')
+    order_count = fields.Integer(compute='_compute_order_count')
+    order_line_ids = fields.Many2many('sale.order.line', store=False, search='_search_order_line_ids')
+    company_id = fields.Many2one('res.company', string="Company", default=lambda self: self.env.user.company_id)
+    currency_id = fields.Many2one(string="Currency", related='company_id.currency_id', readonly=True)
+    validity_duration = fields.Integer(default=1,
+        help="Validity duration for a coupon after its generation")
+
+    @api.constrains('promo_code')
+    def _check_promo_code_constraint(self):
+        """ Program code must be unique """
+        for program in self.filtered(lambda p: p.promo_code):
+            domain = [('id', '!=', program.id), ('promo_code', '=', program.promo_code)]
+            if self.search(domain):
+                raise ValidationError(_('The program code must be unique!'))
+
+    def _search_order_line_ids(self, operator, arg):
+        # just a hack to enable the invalidation of 'order_count'
+        return []
+
+    @api.depends('order_line_ids.product_id')
+    def _compute_order_count(self):
+        product_data = self.env['sale.order.line'].read_group([('product_id', 'in', self.mapped('discount_line_product_id').ids)], ['product_id'], ['product_id'])
+        mapped_data = dict([(m['product_id'][0], m['product_id_count']) for m in product_data])
+        for program in self:
+            program.order_count = mapped_data.get(program.discount_line_product_id.id, 0)
+
+    @api.depends('coupon_ids')
+    def _compute_coupon_count(self):
+        coupon_data = self.env['sale.coupon'].read_group([('program_id', 'in', self.ids)], ['program_id'], ['program_id'])
+        mapped_data = dict([(m['program_id'][0], m['program_id_count']) for m in coupon_data])
+        for program in self:
+            program.coupon_count = mapped_data.get(program.id, 0)
+
+    @api.onchange('promo_code_usage')
+    def _onchange_promo_code_usage(self):
+        if self.promo_code_usage == 'no_code_needed':
+            self.promo_code = False
+
+    @api.onchange('reward_product_id')
+    def _onchange_reward_product_id(self):
+        if self.reward_product_id:
+            self.reward_product_uom_id = self.reward_product_id.uom_id
+
+    @api.model
+    def create(self, vals):
+        program = super(SaleCouponProgram, self).create(vals)
+        if not vals.get('discount_line_product_id', False):
+            discount_line_product_id = self.env['product.product'].create({
+                'name': program.reward_id.display_name,
+                'type': 'service',
+                'taxes_id': False,
+                'supplier_taxes_id': False,
+                'sale_ok': False,
+                'purchase_ok': False,
+                'invoice_policy': 'order',
+                'lst_price': -1000000,  # Prevent pricelist strikethrough as negative value will always be lower then default 1$
+            })
+            program.write({'discount_line_product_id': discount_line_product_id.id})
+        return program
+
+    def write(self, vals):
+        res = super(SaleCouponProgram, self).write(vals)
+        reward_fields = [
+            'reward_type', 'reward_product_id', 'discount_type', 'discount_percentage',
+            'discount_apply_on', 'discount_specific_product_id', 'discount_fixed_amount'
+        ]
+        if any(field in reward_fields for field in vals):
+            self.mapped('discount_line_product_id').write({'name': self[0].reward_id.display_name})
+        return res
+
+    def unlink(self):
+        for program in self.filtered(lambda x: x.active):
+            raise UserError(_('You can not delete a program in active state'))
+        return super(SaleCouponProgram, self).unlink()
+
+    def toggle_active(self):
+        super(SaleCouponProgram, self).toggle_active()
+        if not self.active:
+            coupons = self.filtered(lambda p: p.promo_code_usage == 'code_needed').mapped('coupon_ids')
+            coupons.filtered(lambda x: x.state != 'used').write({'state': 'expired'})
+        self.mapped('discount_line_product_id').write({'active': self.active})
+
+    def action_view_sales_orders(self):
+        self.ensure_one()
+        orders = self.env['sale.order.line'].search([('product_id', '=', self.discount_line_product_id.id)]).mapped('order_id')
+        return {
+            'name': _('Sales Orders'),
+            'view_mode': 'tree,form',
+            'res_model': 'sale.order',
+            'type': 'ir.actions.act_window',
+            'domain': [('id', 'in', orders.ids)]
+        }
+
+    def _is_global_discount_program(self):
+        self.ensure_one()
+        return self.promo_applicability == 'on_current_order' and \
+               self.reward_type == 'discount' and \
+               self.discount_type == 'percentage' and \
+               self.discount_apply_on == 'on_order'
+
+    def _check_promo_code(self, order, coupon_code):
+        message = {}
+        applicable_programs = order._get_applicable_programs()
+        if self.maximum_use_number != 0 and self.order_count >= self.maximum_use_number:
+            message = {'error': _('Promo code %s has been expired.') % (coupon_code)}
+        elif not self._filter_on_mimimum_amount(order):
+            message = {'error': _('A minimum of %s %s should be purchased to get the reward') % (self.rule_minimum_amount, self.currency_id.name)}
+        elif self.promo_code and self.promo_code == order.promo_code:
+            message = {'error': _('The promo code is already applied on this order')}
+        elif not self.promo_code and self in order.no_code_promo_program_ids:
+            message = {'error': _('The promotional offer is already applied on this order')}
+        elif not self.active:
+            message = {'error': _('Promo code is invalid')}
+        elif self.rule_date_from and self.rule_date_from > order.date_order or self.rule_date_to and order.date_order > self.rule_date_to:
+            message = {'error': _('Promo code is expired')}
+        elif order.promo_code and self.promo_code_usage == 'code_needed':
+            message = {'error': _('Promotionals codes are not cumulative.')}
+        elif self._is_global_discount_program() and order._is_global_discount_already_applied():
+            message = {'error': _('Global discounts are not cumulative.')}
+        elif self.promo_applicability == 'on_current_order' and self.reward_type == 'product' and not order._is_reward_in_order_lines(self):
+            message = {'error': _('The reward products should be in the sales order lines to apply the discount.')}
+        elif not self._is_valid_partner(order.partner_id):
+            message = {'error': _("The customer doesn't have access to this reward.")}
+        elif not self._filter_programs_on_products(order):
+            message = {'error': _("You don't have the required product quantities on your sales order. If the reward is same product quantity, please make sure that all the products are recorded on the sales order (Example: You need to have 3 T-shirts on your sales order if the promotion is 'Buy 2, Get 1 Free'.")}
+        else:
+            if self not in applicable_programs and self.promo_applicability == 'on_current_order':
+                message = {'error': _('At least one of the required conditions is not met to get the reward!')}
+        return message
+
+    def _compute_program_amount(self, field, currency_to):
+        self.ensure_one()
+        return self.currency_id._convert(getattr(self, field), currency_to, self.company_id, fields.Date.today())
+
+    @api.model
+    def _filter_on_mimimum_amount(self, order):
+        untaxed_amount = order.amount_untaxed
+        tax_amount = order.amount_tax
+
+        # Some lines should not be considered when checking if threshold is met like delivery
+        untaxed_amount -= sum([line.price_subtotal for line in order._get_no_effect_on_threshold_lines()])
+        tax_amount -= sum([line.price_tax for line in order._get_no_effect_on_threshold_lines()])
+
+        return self.filtered(lambda program:
+            program.rule_minimum_amount_tax_inclusion == 'tax_included' and
+            program._compute_program_amount('rule_minimum_amount', order.currency_id) <= untaxed_amount + tax_amount or
+            program.rule_minimum_amount_tax_inclusion == 'tax_excluded' and
+            program._compute_program_amount('rule_minimum_amount', order.currency_id) <= untaxed_amount)
+
+    @api.model
+    def _filter_on_validity_dates(self, order):
+        return self.filtered(lambda program:
+            program.rule_date_from and program.rule_date_to and
+            program.rule_date_from <= order.date_order and program.rule_date_to >= order.date_order or
+            not program.rule_date_from or not program.rule_date_to)
+
+    @api.model
+    def _filter_promo_programs_with_code(self, order):
+        '''Filter Promo program with code with a different promo_code if a promo_code is already ordered'''
+        return self.filtered(lambda program: program.promo_code_usage == 'code_needed' and program.promo_code != order.promo_code)
+
+    def _filter_unexpired_programs(self, order):
+        return self.filtered(lambda program: program.maximum_use_number == 0 or program.order_count <= program.maximum_use_number)
+
+    def _filter_programs_on_partners(self, order):
+        return self.filtered(lambda program: program._is_valid_partner(order.partner_id))
+
+    def _filter_programs_on_products(self, order):
+        """
+        To get valid programs according to product list.
+        i.e Buy 1 imac + get 1 ipad mini free then check 1 imac is on cart or not
+        or  Buy 1 coke + get 1 coke free then check 2 cokes are on cart or not
+        """
+        order_lines = order.order_line.filtered(lambda line: line.product_id) - order._get_reward_lines()
+        products = order_lines.mapped('product_id')
+        products_qties = dict.fromkeys(products, 0)
+        for line in order_lines:
+            products_qties[line.product_id] += line.product_uom_qty
+        valid_programs = self.filtered(lambda program: not program.rule_products_domain)
+        for program in self - valid_programs:
+            valid_products = program._get_valid_products(products)
+            ordered_rule_products_qty = sum(products_qties[product] for product in valid_products)
+            # Avoid program if 1 ordered foo on a program '1 foo, 1 free foo'
+            if program.promo_applicability == 'on_current_order' and \
+               program._is_valid_product(program.reward_product_id) and program.reward_type == 'product':
+                ordered_rule_products_qty -= program.reward_product_quantity
+            if ordered_rule_products_qty >= program.rule_min_quantity:
+                valid_programs |= program
+        return valid_programs
+
+    def _filter_not_ordered_reward_programs(self, order):
+        """
+        Returns the programs when the reward is actually in the order lines
+        """
+        programs = self.env['sale.coupon.program']
+        for program in self:
+            if program.reward_type == 'product' and \
+               not order.order_line.filtered(lambda line: line.product_id == program.reward_product_id):
+                continue
+            elif program.reward_type == 'discount' and program.discount_apply_on == 'specific_product' and \
+               not order.order_line.filtered(lambda line: line.product_id == program.discount_specific_product_id):
+                continue
+            programs |= program
+        return programs
+
+    @api.model
+    def _filter_programs_from_common_rules(self, order, next_order=False):
+        """ Return the programs if every conditions is met
+            :param bool next_order: is the reward given from a previous order
+        """
+        programs = self
+        # Minimum requirement should not be checked if the coupon got generated by a promotion program (the requirement should have only be checked to generate the coupon)
+        if not next_order:
+            programs = programs and programs._filter_on_mimimum_amount(order)
+        programs = programs and programs._filter_on_validity_dates(order)
+        programs = programs and programs._filter_unexpired_programs(order)
+        programs = programs and programs._filter_programs_on_partners(order)
+        # Product requirement should not be checked if the coupon got generated by a promotion program (the requirement should have only be checked to generate the coupon)
+        if not next_order:
+            programs = programs and programs._filter_programs_on_products(order)
+
+        programs_curr_order = programs.filtered(lambda p: p.promo_applicability == 'on_current_order')
+        programs = programs.filtered(lambda p: p.promo_applicability == 'on_next_order')
+        if programs_curr_order:
+            # Checking if rewards are in the SO should not be performed for rewards on_next_order
+            programs += programs_curr_order._filter_not_ordered_reward_programs(order)
+        return programs
+
+    def _is_valid_partner(self, partner):
+        if self.rule_partners_domain:
+            domain = safe_eval(self.rule_partners_domain) + [('id', '=', partner.id)]
+            return bool(self.env['res.partner'].search_count(domain))
+        else:
+            return True
+
+    def _is_valid_product(self, product):
+        # NOTE: if you override this method, think of also overriding _get_valid_products
+        if self.rule_products_domain:
+            domain = safe_eval(self.rule_products_domain) + [('id', '=', product.id)]
+            return bool(self.env['product.product'].search_count(domain))
+        else:
+            return True
+
+    def _get_valid_products(self, products):
+        if self.rule_products_domain:
+            domain = safe_eval(self.rule_products_domain) + [('id', 'in', products.ids)]
+            return self.env['product.product'].search(domain)
+        return products

--- a/None
+++ b/addons/sale_coupon/models/sale_coupon_reward.py
@@ -0,0 +1,77 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from odoo import api, fields, models, _
+from odoo.exceptions import ValidationError
+
+
+class SaleCouponReward(models.Model):
+    _name = 'sale.coupon.reward'
+    _description = "Sales Coupon Reward"
+    _rec_name = 'reward_description'
+
+    reward_description = fields.Char('Reward Description')
+    reward_type = fields.Selection([
+        ('discount', 'Discount'),
+        ('product', 'Free Product'),
+        ], string='Reward Type', default='discount',
+        help="Discount - Reward will be provided as discount.\n" +
+        "Free Product - Free product will be provide as reward \n" +
+        "Free Shipping - Free shipping will be provided as reward (Need delivery module)")
+    # Product Reward
+    reward_product_id = fields.Many2one('product.product', string="Free Product",
+        help="Reward Product")
+    reward_product_quantity = fields.Integer(string="Quantity", default=1, help="Reward product quantity")
+    # Discount Reward
+    discount_type = fields.Selection([
+        ('percentage', 'Percentage'),
+        ('fixed_amount', 'Fixed Amount')], default="percentage",
+        help="Percentage - Entered percentage discount will be provided\n" +
+        "Amount - Entered fixed amount discount will be provided")
+    discount_percentage = fields.Float(string="Discount", default=10,
+        help='The discount in percentage, between 1 to 100')
+    discount_apply_on = fields.Selection([
+        ('on_order', 'On Order'),
+        ('cheapest_product', 'On Cheapest Product'),
+        ('specific_product', 'On Specific Product')], default="on_order",
+        help="On Order - Discount on whole order\n" +
+        "Cheapest product - Discount on cheapest product of the order\n" +
+        "Specific product - Discount on selected specific product")
+    discount_specific_product_id = fields.Many2one('product.product', string="Product",
+        help="Product that will be discounted if the discount is applied on a specific product")
+    discount_max_amount = fields.Float(default=0,
+        help="Maximum amount of discount that can be provided")
+    discount_fixed_amount = fields.Float(string="Fixed Amount", help='The discount in fixed amount')
+    reward_product_uom_id = fields.Many2one(related='reward_product_id.product_tmpl_id.uom_id', string='Unit of Measure', readonly=True)
+    discount_line_product_id = fields.Many2one('product.product', string='Reward Line Product', copy=False,
+        help="Product used in the sales order to apply the discount. Each coupon program has its own reward product for reporting purpose")
+
+    @api.constrains('discount_percentage')
+    def _check_discount_percentage(self):
+        if self.filtered(lambda reward: reward.discount_type == 'percentage' and (reward.discount_percentage < 0 or reward.discount_percentage > 100)):
+            raise ValidationError(_('Discount percentage should be between 1-100'))
+
+    @api.multi
+    def name_get(self):
+        """
+        Returns a complete description of the reward
+        """
+        result = []
+        for reward in self:
+            reward_string = ""
+            if reward.reward_type == 'product':
+                reward_string = _("Free Product - %s" % (reward.reward_product_id.name))
+            elif reward.reward_type == 'discount':
+                if reward.discount_type == 'percentage':
+                    reward_percentage = str(reward.discount_percentage)
+                    if reward.discount_apply_on == 'on_order':
+                        reward_string = _("%s%% discount on total amount" % (reward_percentage))
+                    elif reward.discount_apply_on == 'specific_product':
+                        reward_string = _("%s%% discount on %s" % (reward_percentage, reward.discount_specific_product_id.name))
+                    elif reward.discount_apply_on == 'cheapest_product':
+                        reward_string = _("%s%% discount on cheapest product" % (reward_percentage))
+                elif reward.discount_type == 'fixed_amount':
+                    program = self.env['sale.coupon.program'].search([('reward_id', '=', reward.id)])
+                    reward_string = _("%s %s discount on total amount" % (str(reward.discount_fixed_amount), program.currency_id.name))
+            result.append((reward.id, reward_string))
+        return result

--- a/None
+++ b/addons/sale_coupon/models/sale_coupon_rules.py
@@ -0,0 +1,39 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from odoo import api, fields, models, _
+from odoo.exceptions import ValidationError
+from odoo.tools.safe_eval import safe_eval
+
+
+class SaleCouponRule(models.Model):
+    _name = 'sale.coupon.rule'
+    _description = "Sales Coupon Rule"
+
+    rule_date_from = fields.Datetime(string="Start Date", help="Coupon program start date")
+    rule_date_to = fields.Datetime(string="End Date", help="Coupon program end date")
+    rule_partners_domain = fields.Char(string="Based on Customers", help="Coupon program will work for selected customers only")
+    rule_products_domain = fields.Char(string="Based on Products", default=[['sale_ok', '=', True]], help="On Purchase of selected product, reward will be given")
+    rule_min_quantity = fields.Integer(string="Minimum Quantity", default=1,
+        help="Minimum required product quantity to get the reward")
+    rule_minimum_amount = fields.Float(default=0.0, help="Minimum required amount to get the reward")
+    rule_minimum_amount_tax_inclusion = fields.Selection([
+        ('tax_included', 'Tax Included'),
+        ('tax_excluded', 'Tax Excluded')], default="tax_excluded")
+
+    @api.constrains('rule_date_to', 'rule_date_from')
+    def _check_rule_date_from(self):
+        if any(applicability for applicability in self
+               if applicability.rule_date_to and applicability.rule_date_from
+               and applicability.rule_date_to < applicability.rule_date_from):
+            raise ValidationError(_('The start date must be before the end date'))
+
+    @api.constrains('rule_minimum_amount')
+    def _check_rule_minimum_amount(self):
+        if self.filtered(lambda applicability: applicability.rule_minimum_amount < 0):
+            raise ValidationError(_('Minimum purchased amount should be greater than 0'))
+
+    @api.constrains('rule_min_quantity')
+    def _check_rule_min_quantity(self):
+        if not self.rule_min_quantity > 0:
+            raise ValidationError(_('Minimum quantity should be greater than 0'))

--- a/None
+++ b/addons/sale_coupon/models/sale_order.py
@@ -0,0 +1,428 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from odoo import api, fields, models, _
+from odoo.tools.misc import formatLang
+
+
+class SaleOrder(models.Model):
+    _inherit = "sale.order"
+
+    applied_coupon_ids = fields.One2many('sale.coupon', 'sales_order_id', string="Applied Coupons", copy=False)
+    generated_coupon_ids = fields.One2many('sale.coupon', 'order_id', string="Offered Coupons", copy=False)
+    reward_amount = fields.Float(compute='_compute_reward_total')
+    no_code_promo_program_ids = fields.Many2many('sale.coupon.program', string="Applied Immediate Promo Programs",
+        domain=[('promo_code_usage', '=', 'no_code_needed')], copy=False)
+    code_promo_program_id = fields.Many2one('sale.coupon.program', string="Applied Promo Program",
+        domain=[('promo_code_usage', '=', 'code_needed')], copy=False)
+    promo_code = fields.Char(related='code_promo_program_id.promo_code', help="Applied program code", readonly=False)
+
+    @api.depends('order_line')
+    def _compute_reward_total(self):
+        for order in self:
+            order.reward_amount = sum([line.price_subtotal for line in order._get_reward_lines()])
+
+    def _get_no_effect_on_threshold_lines(self):
+        self.ensure_one()
+        lines = self.env['sale.order.line']
+        # Do not count already applied promo_code discount; Do not substract itself
+        if self.code_promo_program_id and self.code_promo_program_id.reward_type == 'discount':
+            lines = self.order_line.filtered(lambda l: l.product_id == self.code_promo_program_id.discount_line_product_id)
+        return lines
+
+    @api.multi
+    def recompute_coupon_lines(self):
+        for order in self:
+            order._remove_invalid_reward_lines()
+            order._create_new_no_code_promo_reward_lines()
+            order._update_existing_reward_lines()
+
+    @api.multi
+    @api.returns('self', lambda value: value.id)
+    def copy(self, default=None):
+        order = super(SaleOrder, self).copy(default)
+        order._get_reward_lines().unlink()
+        order._create_new_no_code_promo_reward_lines()
+        return order
+
+    def action_confirm(self):
+        self.generated_coupon_ids.write({'state': 'new'})
+        self.applied_coupon_ids.write({'state': 'used'})
+        self._send_reward_coupon_mail()
+        return super(SaleOrder, self).action_confirm()
+
+    def action_cancel(self):
+        res = super(SaleOrder, self).action_cancel()
+        self.generated_coupon_ids.write({'state': 'expired'})
+        self.applied_coupon_ids.write({'state': 'new'})
+        return res
+
+    def action_draft(self):
+        res = super(SaleOrder, self).action_draft()
+        self.generated_coupon_ids.write({'state': 'reserved'})
+        return res
+
+    def _get_reward_lines(self):
+        self.ensure_one()
+        return self.order_line.filtered(lambda line: line.is_reward_line)
+
+    def _is_reward_in_order_lines(self, program):
+        self.ensure_one()
+        return self.order_line.filtered(lambda line:
+            line.product_id == program.reward_product_id and
+            line.product_uom_qty >= program.reward_product_quantity)
+
+    def _is_global_discount_already_applied(self):
+        applied_programs = self.no_code_promo_program_ids + \
+                           self.code_promo_program_id + \
+                           self.applied_coupon_ids.mapped('program_id')
+        return applied_programs.filtered(lambda program: program._is_global_discount_program())
+
+    def _get_reward_values_product(self, program):
+        price_unit = self.order_line.filtered(lambda line: program.reward_product_id == line.product_id)[0].price_unit
+
+        order_lines = (self.order_line - self._get_reward_lines()).filtered(lambda x: program._is_valid_product(x.product_id))
+        max_product_qty = sum(order_lines.mapped('product_uom_qty')) or 1
+        # Remove needed quantity from reward quantity if same reward and rule product
+        if program._is_valid_product(program.reward_product_id):
+            reward_product_qty = max_product_qty // (program.rule_min_quantity + program.reward_product_quantity)
+        else:
+            reward_product_qty = min(max_product_qty, self.order_line.filtered(lambda x: x.product_id == program.reward_product_id).product_uom_qty)
+
+        reward_qty = min(int(int(max_product_qty / program.rule_min_quantity) * program.reward_product_quantity), reward_product_qty)
+        # Take the default taxes on the reward product, mapped with the fiscal position
+        taxes = program.reward_product_id.taxes_id
+        if self.fiscal_position_id:
+            taxes = self.fiscal_position_id.map_tax(taxes)
+        return {
+            'product_id': program.discount_line_product_id.id,
+            'price_unit': - price_unit,
+            'product_uom_qty': reward_qty,
+            'is_reward_line': True,
+            'name': _("Free Product") + " - " + program.reward_product_id.name,
+            'product_uom': program.reward_product_id.uom_id.id,
+            'tax_id': [(4, tax.id, False) for tax in taxes],
+        }
+
+    def _get_paid_order_lines(self):
+        """ Returns the sale order lines that are not reward lines.
+            It will also return reward lines being free product lines. """
+        free_reward_product = self.env['sale.coupon.program'].search([('reward_type', '=', 'product')]).mapped('discount_line_product_id')
+        return self.order_line.filtered(lambda x: not x.is_reward_line or x.product_id in free_reward_product)
+
+    def _get_reward_values_discount_fixed_amount(self, program):
+        total_amount = sum(self._get_paid_order_lines().mapped('price_total'))
+        fixed_amount = program._compute_program_amount('discount_fixed_amount', self.currency_id)
+        if total_amount < fixed_amount:
+            return total_amount
+        else:
+            return fixed_amount
+
+    def _get_cheapest_line(self):
+        # Unit prices tax included
+        return min(self.order_line.filtered(lambda x: not x.is_reward_line and x.price_unit > 0), key=lambda x: x['price_unit'])
+
+    def _get_reward_values_discount_percentage_per_line(self, program, line):
+        discount_amount = line.product_uom_qty * line.price_unit * (program.discount_percentage / 100)
+        return discount_amount
+
+    def _get_reward_values_discount(self, program):
+        if program.discount_type == 'fixed_amount':
+            return [{
+                'name': _("Discount: ") + program.name,
+                'product_id': program.discount_line_product_id.id,
+                'price_unit': - self._get_reward_values_discount_fixed_amount(program),
+                'product_uom_qty': 1.0,
+                'product_uom': program.discount_line_product_id.uom_id.id,
+                'is_reward_line': True,
+                'tax_id': [(4, tax.id, False) for tax in program.discount_line_product_id.taxes_id],
+            }]
+        reward_dict = {}
+        lines = self._get_paid_order_lines()
+        if program.discount_apply_on == 'cheapest_product':
+            line = self._get_cheapest_line()
+            if line:
+                discount_line_amount = line.price_unit * (program.discount_percentage / 100)
+                if discount_line_amount:
+                    taxes = line.tax_id
+                    if self.fiscal_position_id:
+                        taxes = self.fiscal_position_id.map_tax(taxes)
+
+                    reward_dict[line.tax_id] = {
+                        'name': _("Discount: ") + program.name,
+                        'product_id': program.discount_line_product_id.id,
+                        'price_unit': - discount_line_amount,
+                        'product_uom_qty': 1.0,
+                        'product_uom': program.discount_line_product_id.uom_id.id,
+                        'is_reward_line': True,
+                        'tax_id': [(4, tax.id, False) for tax in taxes],
+                    }
+        elif program.discount_apply_on in ['specific_product', 'on_order']:
+            if program.discount_apply_on == 'specific_product':
+                # We should not exclude reward line that offer this product since we need to offer only the discount on the real paid product (regular product - free product)
+                free_product_lines = self.env['sale.coupon.program'].search([('reward_type', '=', 'product'), ('reward_product_id', '=', program.discount_specific_product_id.id)]).mapped('discount_line_product_id')
+                lines = lines.filtered(lambda x: x.product_id == program.discount_specific_product_id or x.product_id in free_product_lines)
+
+            for line in lines:
+                discount_line_amount = self._get_reward_values_discount_percentage_per_line(program, line)
+
+                if discount_line_amount:
+
+                    if line.tax_id in reward_dict:
+                        reward_dict[line.tax_id]['price_unit'] -= discount_line_amount
+                    else:
+                        taxes = line.tax_id
+                        if self.fiscal_position_id:
+                            taxes = self.fiscal_position_id.map_tax(taxes)
+
+                        tax_name = ""
+                        if len(taxes) == 1:
+                            tax_name = " - " + _("On product with following tax: ") + ', '.join(taxes.mapped('name'))
+                        elif len(taxes) > 1:
+                            tax_name = " - " + _("On product with following taxes: ") + ', '.join(taxes.mapped('name'))
+
+                        reward_dict[line.tax_id] = {
+                            'name': _("Discount: ") + program.name + tax_name,
+                            'product_id': program.discount_line_product_id.id,
+                            'price_unit': - discount_line_amount,
+                            'product_uom_qty': 1.0,
+                            'product_uom': program.discount_line_product_id.uom_id.id,
+                            'is_reward_line': True,
+                            'tax_id': [(4, tax.id, False) for tax in taxes],
+                        }
+
+        # If there is a max amount for discount, we might have to limit some discount lines or completely remove some lines
+        max_amount = program._compute_program_amount('discount_max_amount', self.currency_id)
+        if max_amount > 0:
+            amount_already_given = 0
+            for val in list(reward_dict):
+                amount_to_discount = amount_already_given + reward_dict[val]["price_unit"]
+                if abs(amount_to_discount) > max_amount:
+                    reward_dict[val]["price_unit"] = - (max_amount - abs(amount_already_given))
+                    add_name = formatLang(self.env, max_amount, currency_obj=self.currency_id)
+                    reward_dict[val]["name"] += "( " + _("limited to ") + add_name + ")"
+                amount_already_given += reward_dict[val]["price_unit"]
+                if reward_dict[val]["price_unit"] == 0:
+                    del reward_dict[val]
+        return reward_dict.values()
+
+    def _get_reward_line_values(self, program):
+        self.ensure_one()
+        if program.reward_type == 'discount':
+            return self._get_reward_values_discount(program)
+        elif program.reward_type == 'product':
+            return [self._get_reward_values_product(program)]
+
+    def _create_reward_line(self, program):
+        self.write({'order_line': [(0, False, value) for value in self._get_reward_line_values(program)]})
+
+    def _create_reward_coupon(self, program):
+        # if there is already a coupon that was set as expired, reactivate that one instead of creating a new one
+        coupon = self.env['sale.coupon'].search([
+            ('program_id', '=', program.id),
+            ('state', '=', 'expired'),
+            ('partner_id', '=', self.partner_id.id),
+            ('order_id', '=', self.id),
+            ('discount_line_product_id', '=', program.discount_line_product_id.id),
+        ], limit=1)
+        if coupon:
+            coupon.write({'state': 'reserved'})
+        else:
+            coupon = self.env['sale.coupon'].create({
+                'program_id': program.id,
+                'state': 'reserved',
+                'partner_id': self.partner_id.id,
+                'order_id': self.id,
+                'discount_line_product_id': program.discount_line_product_id.id
+            })
+        self.generated_coupon_ids |= coupon
+        return coupon
+
+    def _send_reward_coupon_mail(self):
+        self.ensure_one()
+        template = self.env.ref('sale_coupon.mail_template_sale_coupon', raise_if_not_found=False)
+        if template:
+            for coupon in self.generated_coupon_ids:
+                self.message_post_with_template(
+                    template.id, composition_mode='comment',
+                    model='sale.coupon', res_id=coupon.id,
+                    notif_layout='mail.mail_notification_light',
+                )
+
+    def _get_applicable_programs(self):
+        """
+        This method is used to return the valid applicable programs on given order.
+        param: order - The sale order for which method will get applicable programs.
+        """
+        self.ensure_one()
+        programs = self.env['sale.coupon.program'].search([
+        ])._filter_programs_from_common_rules(self)
+        if self.promo_code:
+            programs._filter_promo_programs_with_code(self)
+        return programs
+
+    def _get_applicable_no_code_promo_program(self):
+        self.ensure_one()
+        programs = self.env['sale.coupon.program'].search([
+            ('promo_code_usage', '=', 'no_code_needed'),
+        ])._filter_programs_from_common_rules(self)
+        return programs
+
+    def _get_applied_coupon_program_coming_from_another_so(self):
+        # TODO: Remove me in master as no more used
+        pass
+
+    def _get_valid_applied_coupon_program(self):
+        self.ensure_one()
+        # applied_coupon_ids's coupons might be coming from:
+        #   * a coupon generated from a previous order that benefited from a promotion_program that rewarded the next sale order.
+        #     In that case requirements to benefit from the program (Quantity and price) should not be checked anymore
+        #   * a coupon_program, in that case the promo_applicability is always for the current order and everything should be checked (filtered)
+        programs = self.applied_coupon_ids.mapped('program_id').filtered(lambda p: p.promo_applicability == 'on_next_order')._filter_programs_from_common_rules(self, True)
+        programs += self.applied_coupon_ids.mapped('program_id').filtered(lambda p: p.promo_applicability == 'on_current_order')._filter_programs_from_common_rules(self)
+        return programs
+
+    def _create_new_no_code_promo_reward_lines(self):
+        '''Apply new programs that are applicable'''
+        self.ensure_one()
+        order = self
+        programs = order._get_applicable_no_code_promo_program()
+        for program in programs:
+            error_status = program._check_promo_code(order, False)
+            if not error_status.get('error'):
+                if program.promo_applicability == 'on_next_order':
+                    order._create_reward_coupon(program)
+                elif program.discount_line_product_id.id not in self.order_line.mapped('product_id').ids:
+                    self.write({'order_line': [(0, False, value) for value in self._get_reward_line_values(program)]})
+                order.no_code_promo_program_ids |= program
+
+    def _update_existing_reward_lines(self):
+        '''Update values for already applied rewards'''
+        def update_line(order, lines, values):
+            '''Update the lines and return them if they should be deleted'''
+            lines_to_remove = self.env['sale.order.line']
+            # Check commit 6bb42904a03 for next if/else
+            # Remove reward line if price or qty equal to 0
+            if values['product_uom_qty'] and values['price_unit']:
+                order.write({'order_line': [(1, line.id, values) for line in lines]})
+            else:
+                if program.reward_type != 'free_shipping':
+                    # Can't remove the lines directly as we might be in a recordset loop
+                    lines_to_remove += lines
+                else:
+                    values.update(price_unit=0.0)
+                    order.write({'order_line': [(1, line.id, values) for line in lines]})
+            return lines_to_remove
+
+        self.ensure_one()
+        order = self
+        applied_programs = order._get_applied_programs_with_rewards_on_current_order()
+        for program in applied_programs:
+            values = order._get_reward_line_values(program)
+            lines = order.order_line.filtered(lambda line: line.product_id == program.discount_line_product_id)
+            if program.reward_type == 'discount' and program.discount_type == 'percentage':
+                lines_to_remove = lines
+                # Values is what discount lines should really be, lines is what we got in the SO at the moment
+                # 1. If values & lines match, we should update the line (or delete it if no qty or price?)
+                # 2. If the value is not in the lines, we should add it
+                # 3. if the lines contains a tax not in value, we should remove it
+                for value in values:
+                    value_found = False
+                    for line in lines:
+                        # Case 1.
+                        if not len(set(line.tax_id.mapped('id')).symmetric_difference(set([v[1] for v in value['tax_id']]))):
+                            value_found = True
+                            # Working on Case 3.
+                            lines_to_remove -= line
+                            lines_to_remove += update_line(order, line, value)
+                            continue
+                    # Case 2.
+                    if not value_found:
+                        order.write({'order_line': [(0, False, value)]})
+                # Case 3.
+                lines_to_remove.unlink()
+            else:
+                update_line(order, lines, values[0]).unlink()
+
+    def _remove_invalid_reward_lines(self):
+        """ Find programs & coupons that are not applicable anymore.
+            It will then unlink the related reward order lines.
+            It will also unset the order's fields that are storing
+            the applied coupons & programs.
+            Note: It will also remove a reward line coming from an archive program.
+        """
+        self.ensure_one()
+        order = self
+
+        applicable_programs = order._get_applicable_no_code_promo_program() + order._get_applicable_programs() + order._get_valid_applied_coupon_program()
+        applied_programs = order._get_applied_programs_with_rewards_on_current_order() + order._get_applied_programs_with_rewards_on_next_order()
+        programs_to_remove = applied_programs - applicable_programs
+        products_to_remove = programs_to_remove.mapped('discount_line_product_id')
+
+        # delete reward line coming from an archived coupon (it will never be updated/removed when recomputing the order)
+        invalid_lines = order.order_line.filtered(lambda line: line.is_reward_line and line.product_id.id not in (applied_programs).mapped('discount_line_product_id').ids)
+
+        # Invalid generated coupon for which we are not eligible anymore ('expired' since it is specific to this SO and we may again met the requirements)
+        self.generated_coupon_ids.filtered(lambda coupon: coupon.program_id.discount_line_product_id.id in products_to_remove.ids).write({'state': 'expired'})
+        # Reset applied coupons for which we are not eligible anymore ('valid' so it can be use on another )
+        coupons_to_remove = order.applied_coupon_ids.filtered(lambda coupon: coupon.program_id in programs_to_remove)
+        coupons_to_remove.write({'state': 'new'})
+
+        # Unbind promotion and coupon programs which requirements are not met anymore
+        order.no_code_promo_program_ids -= programs_to_remove
+        order.code_promo_program_id -= programs_to_remove
+        order.applied_coupon_ids -= coupons_to_remove
+
+        # Remove their reward lines
+        invalid_lines |= order.order_line.filtered(lambda line: line.product_id.id in products_to_remove.ids)
+        invalid_lines.unlink()
+
+    def _get_applied_programs_with_rewards_on_current_order(self):
+        # Need to add filter on current order. Indeed, it has always been calculating reward line even if on next order (which is useless and do calculation for nothing)
+        # This problem could not be noticed since it would only update or delete existing lines related to that program, it would not find the line to update since not in the order
+        # But now if we dont find the reward line in the order, we add it (since we can now have multiple line per  program in case of discount on different vat), thus the bug
+        # mentionned ahead will be seen now
+        return self.no_code_promo_program_ids.filtered(lambda p: p.promo_applicability == 'on_current_order') + \
+               self.applied_coupon_ids.mapped('program_id') + \
+               self.code_promo_program_id.filtered(lambda p: p.promo_applicability == 'on_current_order')
+
+    def _get_applied_programs_with_rewards_on_next_order(self):
+        return self.no_code_promo_program_ids.filtered(lambda p: p.promo_applicability == 'on_next_order') + \
+            self.code_promo_program_id.filtered(lambda p: p.promo_applicability == 'on_next_order')
+
+
+class SaleOrderLine(models.Model):
+    _inherit = "sale.order.line"
+
+    is_reward_line = fields.Boolean('Is a program reward line')
+
+    def unlink(self):
+        related_program_lines = self.env['sale.order.line']
+        # Reactivate coupons related to unlinked reward line
+        for line in self.filtered(lambda line: line.is_reward_line):
+            coupons_to_reactivate = line.order_id.applied_coupon_ids.filtered(
+                lambda coupon: coupon.program_id.discount_line_product_id == line.product_id
+            )
+            coupons_to_reactivate.write({'state': 'new'})
+            line.order_id.applied_coupon_ids -= coupons_to_reactivate
+            # Remove the program from the order if the deleted line is the reward line of the program
+            # And delete the other lines from this program (It's the case when discount is split per different taxes)
+            related_program = self.env['sale.coupon.program'].search([('discount_line_product_id', '=', line.product_id.id)])
+            if related_program:
+                line.order_id.no_code_promo_program_ids -= related_program
+                line.order_id.code_promo_program_id -= related_program
+                related_program_lines |= line.order_id.order_line.filtered(lambda l: l.product_id.id == related_program.discount_line_product_id.id) - line
+        return super(SaleOrderLine, self | related_program_lines).unlink()
+
+    @api.multi
+    def _compute_tax_id(self):
+        reward_lines = self.filtered('is_reward_line')
+        super(SaleOrderLine, self - reward_lines)._compute_tax_id()
+        # Discount reward line is split per tax, the discount is set on the line but not on the product
+        # as the product is the generic discount line.
+        # In case of a free product, retrieving the tax on the line instead of the product won't affect the behavior.
+        for line in reward_lines:
+            fpos = line.order_id.fiscal_position_id or line.order_id.partner_id.property_account_position_id
+            # If company_id is set, always filter taxes by the company
+            taxes = line.tax_id.filtered(lambda r: not line.company_id or r.company_id == line.company_id)
+            line.tax_id = fpos.map_tax(taxes, line.product_id, line.order_id.partner_shipping_id) if fpos else taxes
