PR: https://github.com/odoo/odoo/pull/70986

From: 463af6f61bb6e4398260a240942be8b9ae43e95e
From: Qiuyu (QHO)
Date: 2021-08-25 17:00:06

Structural Changes: 5
Total Changes: 70

[IMP] mail, im_livechat: improve Discuss sidebar

The commit is to refactor the discuss sidebar

 - threads are now organized in categories based on the thread type e.g. chat, channel
 - categories can be folded or unfolded by clicking the category title
 - for active thread, even if the category is folded, it remains under the category title
 - for channel category, a new cog button is added to view all channels
 - the active indicator bar is removed. The active item now is highlighted with a different background color
 - thread avatar is used for livechat, chat and channel
 - for livechat and chat, threads are now sorted by last activity time (pin or message exchange)

closes odoo/odoo#70986

Task-id: 2440073
Signed-off-by: SÃ©bastien Theys (seb) <seb@odoo.com>

================================= pseudo patch: =================================

--- a/addons/mail/models/__init__.py
+++ b/addons/mail/models/__init__.py
@@ -30,6 +30,7 @@ from . import mail_template
 from . import mail_channel_partner
 from . import mail_channel
 from . import mail_shortcode
+from . import res_users_settings
 
 # odoo models
 from . import ir_action_act_window

--- a/addons/mail/models/mail_channel.py
+++ b/addons/mail/models/mail_channel.py
@@ -8,6 +8,7 @@ from uuid import uuid4
 from odoo import _, api, fields, models, modules, tools, Command
 from odoo.exceptions import UserError, ValidationError
 from odoo.osv import expression
+from odoo.tools.misc import DEFAULT_SERVER_DATETIME_FORMAT
 
 _logger = logging.getLogger(__name__)
 
@@ -421,6 +422,20 @@ class Channel(models.Model):
         message_format_values = message.message_format()[0]
         bus_notifications = self._channel_message_notifications(message, message_format_values)
         self.env['bus.bus'].sudo().sendmany(bus_notifications)
+        # Last interest is updated for a chat when posting a message.
+        # So a notification is needed to update UI.
+        if self.is_chat:
+            notifications = []
+            for channel_partners in self.channel_last_seen_partner_ids:
+                notif = {
+                    'type': 'mail.channel_last_interest_dt_changed',
+                    'payload': {
+                        'id': self.id,
+                        'last_interest_dt': channel_partners.last_interest_dt,
+                    }
+                }
+                notifications.append([(self._cr.dbname, 'res.partner', channel_partners.partner_id.id), notif])
+            self.env['bus.bus'].sendmany(notifications)
         return rdata
 
     def _message_receive_bounce(self, email, partner):
@@ -432,7 +447,10 @@ class Channel(models.Model):
 
     @api.returns('mail.message', lambda value: value.id)
     def message_post(self, *, message_type='notification', **kwargs):
-        self.filtered(lambda channel: channel.is_chat).mapped('channel_last_seen_partner_ids').sudo().write({'is_pinned': True})
+        self.filtered(lambda channel: channel.is_chat).mapped('channel_last_seen_partner_ids').sudo().write({
+            'is_pinned': True,
+            'last_interest_dt': fields.Datetime.now(),
+        })
 
         # mail_post_autofollow=False is necessary to prevent adding followers
         # when using mentions in channels. Followers should not be added to
@@ -549,6 +567,7 @@ class Channel(models.Model):
                     info['seen_message_id'] = partner_channel.seen_message_id.id
                     info['custom_channel_name'] = partner_channel.custom_channel_name
                     info['is_pinned'] = partner_channel.is_pinned
+                    info['last_interest_dt'] = partner_channel.last_interest_dt.strftime(DEFAULT_SERVER_DATETIME_FORMAT)
             # add members infos
             if channel.channel_type != 'channel':
                 # avoid sending potentially a lot of members for big channels
@@ -616,7 +635,10 @@ class Channel(models.Model):
             channel = self.browse(result[0].get('channel_id'))
             # pin up the channel for the current partner
             if pin:
-                self.env['mail.channel.partner'].search([('partner_id', '=', self.env.user.partner_id.id), ('channel_id', '=', channel.id)]).write({'is_pinned': True})
+                self.env['mail.channel.partner'].search([('partner_id', '=', self.env.user.partner_id.id), ('channel_id', '=', channel.id)]).write({
+                    'is_pinned': True,
+                    'last_interest_dt': fields.Datetime.now(),
+                })
             channel._broadcast(self.env.user.partner_id.ids)
         else:
             # create a new one

--- a/addons/mail/models/mail_channel_partner.py
+++ b/addons/mail/models/mail_channel_partner.py
@@ -23,6 +23,7 @@ class ChannelPartner(models.Model):
     fold_state = fields.Selection([('open', 'Open'), ('folded', 'Folded'), ('closed', 'Closed')], string='Conversation Fold State', default='open')
     is_minimized = fields.Boolean("Conversation is minimized")
     is_pinned = fields.Boolean("Is pinned on the interface", default=True)
+    last_interest_dt = fields.Datetime("Last Interest", default=fields.Datetime.now, help="Contains the date and time of the last interesting event that happened in this channel for this partner. This includes: creating, joining, pinning, and new message posted.")
 
     @api.model_create_multi
     def create(self, vals_list):

--- a/addons/mail/models/res_users.py
+++ b/addons/mail/models/res_users.py
@@ -25,6 +25,7 @@ class Users(models.Model):
         help="Policy on how to handle Chatter notifications:\n"
              "- Handle by Emails: notifications are sent to your email address\n"
              "- Handle in Odoo: notifications appear in your Odoo Inbox")
+    res_users_settings_ids = fields.One2many('res.users.settings', 'user_id')
 
     # ------------------------------------------------------------
     # CRUD
@@ -95,6 +96,7 @@ class Users(models.Model):
             'channels': self.partner_id._get_channels_as_member().channel_info(),
             'current_partner': self.partner_id.mail_partner_format().get(self.partner_id),
             'current_user_id': self.id,
+            'current_user_settings': self.env['res.users.settings']._find_or_create_for_user(self)._res_users_settings_format(),
             'mail_failures': self.partner_id._message_fetch_failed(),
             'menu_id': self.env['ir.model.data']._xmlid_to_res_id('mail.menu_root_discuss'),
             'needaction_inbox_counter': self.partner_id._get_needaction_count(),

--- a/None
+++ b/addons/mail/models/res_users_settings.py
@@ -0,0 +1,40 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from odoo import api, fields, models
+
+
+class ResUsersSettings(models.Model):
+    _name = 'res.users.settings'
+    _description = 'User Settings'
+
+    user_id = fields.Many2one('res.users', string="User", required=True, readonly=True, ondelete='cascade')
+    is_discuss_sidebar_category_channel_open = fields.Boolean(string="Is discuss sidebar category channel open?", default=True)
+    is_discuss_sidebar_category_chat_open = fields.Boolean(string="Is discuss sidebar category chat open?", default=True)
+
+    _sql_constraints = [
+        ('unique_user_id', 'UNIQUE(user_id)', 'One user should only have one mail user settings.')
+    ]
+
+    @api.model
+    def _find_or_create_for_user(self, user):
+        settings = user.res_users_settings_ids
+        if not settings:
+            settings = self.create({'user_id': user.id})
+        return settings
+
+    def _res_users_settings_format(self):
+        self.ensure_one()
+        return self._read_format(fnames=[name for name, field in self._fields.items() if name == 'id' or not field.automatic])[0]
+
+    def set_res_users_settings(self, new_settings):
+        self.ensure_one()
+        changed_settings = {}
+        for setting in new_settings.keys():
+            if setting in self._fields and new_settings[setting] != self[setting]:
+                changed_settings[setting] = new_settings[setting]
+        self.write(changed_settings)
+        self.env['bus.bus'].sendone((self._cr.dbname, 'res.partner', self.user_id.partner_id.id), {
+            'type': 'res.users_settings_changed',
+            'payload': changed_settings,
+        })
