PR: https://github.com/odoo/odoo/pull/64925

From: 8952ce3bf4b750f815ad6c9acd07271a9111bfa0
From: Thibault Delavall√©e
Date: 2021-03-24 15:09:27

Structural Changes: 10
Total Changes: 890

[MOV] calendar: reorganize calendar event and attendee methods

Purpose is to ease understanding of code. Notably we apply guidelines that
should have been applied at refactoring time, notably

  * set all compute fields together right below fields as it eases model
    discovering;
  * set CRUD methods as a whole after compute fields;
  * group other methods by main use and put tools at the file's end;

This commit causes some diff but we feel this is necessary to ease future
modifications in those models, as they are quite big and important.

Task ID-2199620
COM PR odoo/odoo#64925

================================= pseudo patch: =================================

--- a/addons/calendar/models/calendar_attendee.py
+++ b/addons/calendar/models/calendar_attendee.py
@@ -64,6 +64,10 @@ class Attendee(models.Model):
         self._unsubscribe_partner()
         return super().unlink()
 
+    @api.returns('self', lambda value: value.id)
+    def copy(self, default=None):
+        raise UserError(_('You cannot duplicate a calendar attendee.'))
+
     def _subscribe_partner(self):
         for event in self.event_id:
             partners = (event.attendee_ids & self).partner_id - event.message_partner_ids
@@ -76,10 +80,6 @@ class Attendee(models.Model):
             partners = (event.attendee_ids & self).partner_id & event.message_partner_ids
             event.message_unsubscribe(partner_ids=partners.ids)
 
-    @api.returns('self', lambda value: value.id)
-    def copy(self, default=None):
-        raise UserError(_('You cannot duplicate a calendar attendee.'))
-
     def _send_mail_to_attendees(self, template_xmlid, force_send=False, ignore_recurrence=False):
         """ Send mail for event invitation to event attendees.
             :param template_xmlid: xml id of the email template to use to send the invitation

--- a/addons/calendar/models/calendar_event.py
+++ b/addons/calendar/models/calendar_event.py
@@ -89,111 +89,6 @@ class Meeting(models.Model):
             jitsi_url = 'https://' + jitsi_url
         return url_join(jitsi_url, 'odoo-%s' % (uuid4().hex[:12]))
 
-    def _find_my_attendee(self):
-        """ Return the first attendee where the user connected has been invited
-            from all the meeting_ids in parameters.
-        """
-        self.ensure_one()
-        for attendee in self.attendee_ids:
-            if self.env.user.partner_id == attendee.partner_id:
-                return attendee
-        return False
-
-    @api.model
-    def _get_date_formats(self):
-        """ get current date and time format, according to the context lang
-            :return: a tuple with (format date, format time)
-        """
-        lang = get_lang(self.env)
-        return (lang.date_format, lang.time_format)
-
-    @api.model
-    def _get_recurrent_fields(self):
-        return {'byday', 'until', 'rrule_type', 'month_by', 'event_tz', 'rrule',
-                'interval', 'count', 'end_type', 'mo', 'tu', 'we', 'th', 'fr', 'sa',
-                'su', 'day', 'weekday'}
-
-    @api.model
-    def _get_time_fields(self):
-        return {'start', 'stop', 'start_date', 'stop_date'}
-
-    @api.model
-    def _get_custom_fields(self):
-        all_fields = self.fields_get(attributes=['manual'])
-        return {fname for fname in all_fields if all_fields[fname]['manual']}
-
-    @api.model
-    def _get_public_fields(self):
-        return self._get_recurrent_fields() | self._get_time_fields() | self._get_custom_fields() | {
-            'id', 'active', 'allday',
-            'duration', 'user_id', 'interval',
-            'count', 'rrule', 'recurrence_id', 'show_as', 'privacy'}
-
-    @api.model
-    def _get_display_time(self, start, stop, zduration, zallday):
-        """ Return date and time (from to from) based on duration with timezone in string. Eg :
-                1) if user add duration for 2 hours, return : August-23-2013 at (04-30 To 06-30) (Europe/Brussels)
-                2) if event all day ,return : AllDay, July-31-2013
-        """
-        timezone = self._context.get('tz') or self.env.user.partner_id.tz or 'UTC'
-
-        # get date/time format according to context
-        format_date, format_time = self._get_date_formats()
-
-        # convert date and time into user timezone
-        self_tz = self.with_context(tz=timezone)
-        date = fields.Datetime.context_timestamp(self_tz, fields.Datetime.from_string(start))
-        date_deadline = fields.Datetime.context_timestamp(self_tz, fields.Datetime.from_string(stop))
-
-        # convert into string the date and time, using user formats
-        to_text = pycompat.to_text
-        date_str = to_text(date.strftime(format_date))
-        time_str = to_text(date.strftime(format_time))
-
-        if zallday:
-            display_time = _("All Day, %(day)s", day=date_str)
-        elif zduration < 24:
-            duration = date + timedelta(minutes=round(zduration*60))
-            duration_time = to_text(duration.strftime(format_time))
-            display_time = _(
-                u"%(day)s at (%(start)s To %(end)s) (%(timezone)s)",
-                day=date_str,
-                start=time_str,
-                end=duration_time,
-                timezone=timezone,
-            )
-        else:
-            dd_date = to_text(date_deadline.strftime(format_date))
-            dd_time = to_text(date_deadline.strftime(format_time))
-            display_time = _(
-                u"%(date_start)s at %(time_start)s To\n %(date_end)s at %(time_end)s (%(timezone)s)",
-                date_start=date_str,
-                time_start=time_str,
-                date_end=dd_date,
-                time_end=dd_time,
-                timezone=timezone,
-            )
-        return display_time
-
-    def _get_duration(self, start, stop):
-        """ Get the duration value between the 2 given dates. """
-        if not start or not stop:
-            return 0
-        duration = (stop - start).total_seconds() / 3600
-        return round(duration, 2)
-
-    def _compute_is_highlighted(self):
-        if self.env.context.get('active_model') == 'res.partner':
-            partner_id = self.env.context.get('active_id')
-            for event in self:
-                if event.partner_ids.filtered(lambda s: s.id == partner_id):
-                    event.is_highlighted = True
-                else:
-                    event.is_highlighted = False
-        else:
-            for event in self:
-                event.is_highlighted = False
-
     # description
     name = fields.Char('Meeting Subject', required=True)
     description = fields.Text('Description')
@@ -309,10 +204,17 @@ class Meeting(models.Model):
     byday = fields.Selection(BYDAY_SELECTION, compute='_compute_recurrence', readonly=False)
     until = fields.Date(compute='_compute_recurrence', readonly=False)
 
-    def _compute_attendee(self):
-        for meeting in self:
-            attendee = meeting._find_my_attendee()
-            meeting.attendee_status = attendee.state if attendee else 'needsAction'
+    def _compute_is_highlighted(self):
+        if self.env.context.get('active_model') == 'res.partner':
+            partner_id = self.env.context.get('active_id')
+            for event in self:
+                if event.partner_ids.filtered(lambda s: s.id == partner_id):
+                    event.is_highlighted = True
+                else:
+                    event.is_highlighted = False
+        else:
+            for event in self:
+                event.is_highlighted = False
 
     def _compute_display_time(self):
         for meeting in self:
@@ -377,6 +279,11 @@ class Meeting(models.Model):
                     'stop': enddate.replace(tzinfo=None)
                 })
 
+    def _compute_attendee(self):
+        for meeting in self:
+            attendee = meeting._find_my_attendee()
+            meeting.attendee_status = attendee.state if attendee else 'needsAction'
+
     @api.constrains('start', 'stop', 'start_date', 'stop_date')
     def _check_closing_date(self):
         for meeting in self:
@@ -399,10 +306,6 @@ class Meeting(models.Model):
                     )
                 )
 
-    ####################################################
-    # Calendar Business, Reccurency, ...
-    ####################################################
-
     @api.depends('recurrence_id', 'recurrency')
     def _compute_recurrence(self):
         recurrence_fields = self._get_recurrent_fields()
@@ -420,136 +323,217 @@ class Meeting(models.Model):
             else:
                 event.update(false_values)
 
-    def _get_ics_file(self):
-        """ Returns iCalendar file for the event invitation.
-            :returns a dict of .ics file content for each meeting
-        """
-        result = {}
+    # ------------------------------------------------------------
+    # CRUD
+    # ------------------------------------------------------------
 
-        def ics_datetime(idate, allday=False):
-            if idate:
-                if allday:
-                    return idate
-                return idate.replace(tzinfo=pytz.timezone('UTC'))
-            return False
+    @api.model_create_multi
+    def create(self, vals_list):
+        vals_list = [  # Else bug with quick_create when we are filter on an other user
+            dict(vals, user_id=self.env.user.id) if not 'user_id' in vals else vals
+            for vals in vals_list
+        ]
 
-        try:
-            # FIXME: why isn't this in CalDAV?
-            import vobject
-        except ImportError:
-            _logger.warning("The `vobject` Python module is not installed, so iCal file generation is unavailable. Please install the `vobject` Python module")
-            return result
+        for values in vals_list:
+            # created from calendar: try to create an activity on the related record
+            if not values.get('activity_ids'):
+                defaults = self.default_get(['activity_ids', 'res_model_id', 'res_id', 'user_id'])
+                res_model_id = values.get('res_model_id', defaults.get('res_model_id'))
+                res_id = values.get('res_id', defaults.get('res_id'))
+                user_id = values.get('user_id', defaults.get('user_id'))
+                if not defaults.get('activity_ids') and res_model_id and res_id:
+                    if hasattr(self.env[self.env['ir.model'].sudo().browse(res_model_id).model], 'activity_ids'):
+                        meeting_activity_type = self.env['mail.activity.type'].search([('category', '=', 'meeting')], limit=1)
+                        if meeting_activity_type:
+                            activity_vals = {
+                                'res_model_id': res_model_id,
+                                'res_id': res_id,
+                                'activity_type_id': meeting_activity_type.id,
+                            }
+                            if user_id:
+                                activity_vals['user_id'] = user_id
+                            values['activity_ids'] = [(0, 0, activity_vals)]
 
-        for meeting in self:
-            cal = vobject.iCalendar()
-            event = cal.add('vevent')
+        vals_list = [
+            dict(vals, attendee_ids=self._attendees_values(vals['partner_ids'])) if 'partner_ids' in vals else vals
+            for vals in vals_list
+        ]
+        recurrence_fields = self._get_recurrent_fields()
+        recurring_vals = [vals for vals in vals_list if vals.get('recurrency')]
+        other_vals = [vals for vals in vals_list if not vals.get('recurrency')]
+        events = super().create(other_vals)
 
-            if not meeting.start or not meeting.stop:
-                raise UserError(_("First you have to specify the date of the invitation."))
-            event.add('created').value = ics_datetime(fields.Datetime.now())
-            event.add('dtstart').value = ics_datetime(meeting.start, meeting.allday)
-            event.add('dtend').value = ics_datetime(meeting.stop, meeting.allday)
-            event.add('summary').value = meeting.name
-            if meeting.description:
-                event.add('description').value = meeting.description
-            if meeting.location:
-                event.add('location').value = meeting.location
-            if meeting.rrule:
-                event.add('rrule').value = meeting.rrule
+        for vals in recurring_vals:
 
-            if meeting.alarm_ids:
-                for alarm in meeting.alarm_ids:
-                    valarm = event.add('valarm')
-                    interval = alarm.interval
-                    duration = alarm.duration
-                    trigger = valarm.add('TRIGGER')
-                    trigger.params['related'] = ["START"]
-                    if interval == 'days':
-                        delta = timedelta(days=duration)
-                    elif interval == 'hours':
-                        delta = timedelta(hours=duration)
-                    elif interval == 'minutes':
-                        delta = timedelta(minutes=duration)
-                    trigger.value = delta
-                    valarm.add('DESCRIPTION').value = alarm.name or u'Odoo'
-            for attendee in meeting.attendee_ids:
-                attendee_add = event.add('attendee')
-                attendee_add.value = u'MAILTO:' + (attendee.email or u'')
-            result[meeting.id] = cal.serialize().encode('utf-8')
+            recurrence_values = {field: vals.pop(field) for field in recurrence_fields if field in vals}
+            vals['follow_recurrence'] = True
+            event = super().create(vals)
+            events |= event
+            if vals.get('recurrency'):
+                detached_events = event._apply_recurrence_values(recurrence_values)
+                detached_events.active = False
 
-        return result
+        events.filtered(lambda event: event.start > fields.Datetime.now()).attendee_ids._send_mail_to_attendees('calendar.calendar_template_meeting_invitation')
+        events._sync_activities(fields={f for vals in vals_list for f in vals.keys()})
 
-    def _attendees_values(self, partner_commands):
-        """
-        :param partner_commands: ORM commands for partner_id field (0 and 1 commands not supported)
-        :return: associated attendee_ids ORM commands
-        """
-        attendee_commands = []
+        events._setup_alarms()
 
-        removed_partner_ids = []
-        added_partner_ids = []
-        for command in partner_commands:
-            op = command[0]
-            if op in (2, 3):  # Remove partner
-                removed_partner_ids += [command[1]]
-            elif op == 6:  # Replace all
-                removed_partner_ids += set(self.partner_ids.ids) - set(command[2])  # Don't recreate attendee if partner already attend the event
-                added_partner_ids += set(command[2]) - set(self.partner_ids.ids)
-            elif op == 4:
-                added_partner_ids += [command[1]] if command[1] not in self.partner_ids.ids else []
-            # commands 0 and 1 not supported
+        return events
 
-        attendees_to_unlink = self.env['calendar.attendee'].search([
-            ('event_id', 'in', self.ids),
-            ('partner_id', 'in', removed_partner_ids),
-        ])
-        attendee_commands += [[2, attendee.id] for attendee in attendees_to_unlink]  # Removes and delete
+    def read(self, fields=None, load='_classic_read'):
+        def hide(field, value):
+            """
+            :param field: field name
+            :param value: field value
+            :return: obfuscated field value
+            """
+            if field in {'name', 'display_name'}:
+                return _('Busy')
+            return [] if isinstance(value, list) else False
 
-        attendee_commands += [
-            [0, 0, dict(partner_id=partner_id)]
-            for partner_id in added_partner_ids
-        ]
-        return attendee_commands
+        def split_privacy(events):
+            """
+            :param events: list of event values (dict)
+            :return: tuple(private events, public events)
+            """
+            private = [event for event in events if event.get('privacy') == 'private']
+            public = [event for event in events if event.get('privacy') != 'private']
+            return private, public
 
-    def get_interval(self, interval, tz=None):
-        """ Format and localize some dates to be used in email templates
-            :param string interval: Among 'day', 'month', 'dayname' and 'time' indicating the desired formatting
-            :param string tz: Timezone indicator (optional)
-            :return unicode: Formatted date or time (as unicode string, to prevent jinja2 crash)
-        """
-        self.ensure_one()
-        date = fields.Datetime.from_string(self.start)
+        def my_events(events):
+            """
+            :param events: list of event values (dict)
+            :return: tuple(my events, other events)
+            """
+            my = [event for event in events if event.get('user_id') and event.get('user_id')[0] == self.env.uid]
+            others = [event for event in events if not event.get('user_id') or event.get('user_id')[0] != self.env.uid]
+            return my, others
 
-        if tz:
-            timezone = pytz.timezone(tz or 'UTC')
-            date = date.replace(tzinfo=pytz.timezone('UTC')).astimezone(timezone)
+        def obfuscated(events):
+            """
+            :param events: list of event values (dict)
+            :return: events with private field values obfuscated
+            """
+            public_fields = self._get_public_fields()
+            return [{
+                field: hide(field, value) if field not in public_fields else value
+                for field, value in event.items()
+            } for event in events]
 
-        if interval == 'day':
-            # Day number (1-31)
-            result = str(date.day)
+        events = super().read(fields=fields + ['privacy', 'user_id'], load=load)
+        private_events, public_events = split_privacy(events)
+        my_private_events, others_private_events = my_events(private_events)
 
-        elif interval == 'month':
-            # Localized month name and year
-            result = babel.dates.format_date(date=date, format='MMMM y', locale=get_lang(self.env).code)
+        return public_events + my_private_events + obfuscated(others_private_events)
 
-        elif interval == 'dayname':
-            # Localized day name
-            result = babel.dates.format_date(date=date, format='EEEE', locale=get_lang(self.env).code)
+    def write(self, values):
+        detached_events = self.env['calendar.event']
+        recurrence_update_setting = values.pop('recurrence_update', None)
+        update_recurrence = recurrence_update_setting in ('all_events', 'future_events') and len(self) == 1
+        break_recurrence = values.get('recurrency') is False
 
-        elif interval == 'time':
-            # Localized time
-            # FIXME: formats are specifically encoded to bytes, maybe use babel?
-            dummy, format_time = self._get_date_formats()
-            result = tools.ustr(date.strftime(format_time + " %Z"))
+        if 'partner_ids' in values:
+            values['attendee_ids'] = self._attendees_values(values['partner_ids'])
+
+        if (not recurrence_update_setting or recurrence_update_setting == 'self_only' and len(self) == 1) and 'follow_recurrence' not in values:
+            if any({field: values.get(field) for field in self.env['calendar.event']._get_time_fields() if field in values}):
+                values['follow_recurrence'] = False
+
+        previous_attendees = self.attendee_ids
+
+        recurrence_values = {field: values.pop(field) for field in self._get_recurrent_fields() if field in values}
+        if update_recurrence:
+            if break_recurrence:
+                detached_events |= self._break_recurrence(future=recurrence_update_setting == 'future_events')
+            else:
+                update_start = self.start if recurrence_update_setting == 'future_events' else None
+                time_values = {field: values.pop(field) for field in self.env['calendar.event']._get_time_fields() if field in values}
+                if not update_start and (time_values or recurrence_values):
+                    raise UserError(_("Updating All Events is not allowed when dates or time is modified. You can only update one particular event and following events."))
+                detached_events |= self._split_recurrence(time_values)
+                self.recurrence_id._write_events(values, dtstart=update_start)
+        else:
+            super().write(values)
+            self._sync_activities(fields=values.keys())
+
+        if recurrence_update_setting != 'self_only' and not break_recurrence:
+            detached_events |= self._apply_recurrence_values(recurrence_values, future=recurrence_update_setting == 'future_events')
+
+        (detached_events & self).active = False
+        (detached_events - self).with_context(archive_on_error=True).unlink()
+
+        self._setup_alarms()
+
+        current_attendees = self.filtered('active').attendee_ids
+        if 'partner_ids' in values:
+            (current_attendees - previous_attendees)._send_mail_to_attendees('calendar.calendar_template_meeting_invitation')
+        if 'start' in values:
+            start_date = fields.Datetime.to_datetime(values.get('start'))
+            # Only notify on future events
+            if start_date and start_date >= fields.Datetime.now():
+                (current_attendees & previous_attendees)._send_mail_to_attendees('calendar.calendar_template_meeting_changedate', ignore_recurrence=not update_recurrence)
+
+        return True
+
+    @api.model
+    def read_group(self, domain, fields, groupby, offset=0, limit=None, orderby=False, lazy=True):
+        groupby = [groupby] if isinstance(groupby, str) else groupby
+        grouped_fields = set(group_field.split(':')[0] for group_field in groupby)
+        private_fields = grouped_fields - self._get_public_fields()
+        if not self.env.su and private_fields:
+            raise AccessError(_(
+                "Grouping by %s is not allowed.",
+                ', '.join([self._fields[field_name].string for field_name in private_fields])
+            ))
+        return super(Meeting, self).read_group(domain, fields, groupby, offset=offset, limit=limit, orderby=orderby, lazy=lazy)
+
+    def unlink(self):
+        # Get concerned attendees to notify them if there is an alarm on the unlinked events,
+        # as it might have changed their next event notification
+        events = self.filtered_domain([('alarm_ids', '!=', False)])
+        partner_ids = events.mapped('partner_ids').ids
 
+        result = super().unlink()
+
+        # Notify the concerned attendees (must be done after removing the events)
+        self.env['calendar.alarm_manager']._notify_next_alarm(partner_ids)
         return result
 
-    def get_display_time_tz(self, tz=False):
-        """ get the display_time of the meeting, forcing the timezone. This method is called from email template, to not use sudo(). """
-        self.ensure_one()
-        if tz:
-            self = self.with_context(tz=tz)
-        return self._get_display_time(self.start, self.stop, self.duration, self.allday)
+    def _attendees_values(self, partner_commands):
+        """
+        :param partner_commands: ORM commands for partner_id field (0 and 1 commands not supported)
+        :return: associated attendee_ids ORM commands
+        """
+        attendee_commands = []
+
+        removed_partner_ids = []
+        added_partner_ids = []
+        for command in partner_commands:
+            op = command[0]
+            if op in (2, 3):  # Remove partner
+                removed_partner_ids += [command[1]]
+            elif op == 6:  # Replace all
+                removed_partner_ids += set(self.partner_ids.ids) - set(command[2])  # Don't recreate attendee if partner already attend the event
+                added_partner_ids += set(command[2]) - set(self.partner_ids.ids)
+            elif op == 4:
+                added_partner_ids += [command[1]] if command[1] not in self.partner_ids.ids else []
+            # commands 0 and 1 not supported
+
+        attendees_to_unlink = self.env['calendar.attendee'].search([
+            ('event_id', 'in', self.ids),
+            ('partner_id', 'in', removed_partner_ids),
+        ])
+        attendee_commands += [[2, attendee.id] for attendee in attendees_to_unlink]  # Removes and delete
+
+        attendee_commands += [
+            [0, 0, dict(partner_id=partner_id)]
+            for partner_id in added_partner_ids
+        ]
+        return attendee_commands
+
+    # ------------------------------------------------------------
+    # ACTIONS
+    # ------------------------------------------------------------
 
     def action_open_calendar_event(self):
         if self.res_model and self.res_id:
@@ -586,6 +570,60 @@ class Meeting(models.Model):
             'context': compose_ctx,
         }
 
+    # ------------------------------------------------------------
+    # MAILING
+    # ------------------------------------------------------------
+
+    def _sync_activities(self, fields):
+        # update activities
+        for event in self:
+            if event.activity_ids:
+                activity_values = {}
+                if 'name' in fields:
+                    activity_values['summary'] = event.name
+                if 'description' in fields:
+                    activity_values['note'] = tools.plaintext2html(event.description)
+                if 'start' in fields:
+                    # self.start is a datetime UTC *only when the event is not allday*
+                    # activty.date_deadline is a date (No TZ, but should represent the day in which the user's TZ is)
+                    # See 72254129dbaeae58d0a2055cba4e4a82cde495b7 for the same issue, but elsewhere
+                    deadline = event.start
+                    user_tz = self.env.context.get('tz')
+                    if user_tz and not event.allday:
+                        deadline = pytz.UTC.localize(deadline)
+                        deadline = deadline.astimezone(pytz.timezone(user_tz))
+                    activity_values['date_deadline'] = deadline.date()
+                if 'user_id' in fields:
+                    activity_values['user_id'] = event.user_id.id
+                if activity_values.keys():
+                    event.activity_ids.write(activity_values)
+
+    # ------------------------------------------------------------
+    # ALARMS
+    # ------------------------------------------------------------
+
+    def _get_trigger_alarm_types(self):
+        return ['email']
+
+    def _setup_alarms(self):
+        """ Schedule cron triggers for future events """
+        cron = self.env.ref('calendar.ir_cron_scheduler_alarm')
+        alarm_manager = self.env['calendar.alarm_manager']
+        alarm_types = self._get_trigger_alarm_types()
+
+        for event in self:
+            for alarm in (alarm for alarm in event.alarm_ids if alarm.alarm_type in alarm_types):
+                at = event.start - timedelta(minutes=alarm.duration_minutes)
+                if not cron.lastcall or at > cron.lastcall:
+                    # Don't trigger for past alarms, they would be skipped by design
+                    cron._trigger(at=at)
+            if any(alarm.alarm_type == 'notification' for alarm in event.alarm_ids):
+                alarm_manager._notify_next_alarm(event.partner_ids.ids)
+
+    # ------------------------------------------------------------
+    # RECURRENCY
+    # ------------------------------------------------------------
+
     def _apply_recurrence_values(self, values, future=True):
         """Apply the new recurrence rules in `values`. Create a recurrence if it does not exist
         and create all missing events according to the rrule.
@@ -623,18 +661,6 @@ class Meeting(models.Model):
             'day': event_date.day,
         }
 
-    def _get_start_date(self):
-        """Return the event starting date in the event's timezone.
-        If no starting time is assigned (yet), return today as default
-        :return: date
-        """
-        if not self.start:
-            return fields.Date.today()
-        if self.recurrence_id.event_tz:
-            tz = pytz.timezone(self.recurrence_id.event_tz)
-            return pytz.utc.localize(self.start).astimezone(tz).date()
-        return self.start.date()
-
     def _split_recurrence(self, time_values):
         """Apply time changes to events and update the recurrence accordingly.
 
@@ -669,228 +695,226 @@ class Meeting(models.Model):
         recurrences_to_unlink.with_context(archive_on_error=True).unlink()
         return detached_events - self
 
-    def write(self, values):
-        detached_events = self.env['calendar.event']
-        recurrence_update_setting = values.pop('recurrence_update', None)
-        update_recurrence = recurrence_update_setting in ('all_events', 'future_events') and len(self) == 1
-        break_recurrence = values.get('recurrency') is False
+    # ------------------------------------------------------------
+    # MANAGEMENT
+    # ------------------------------------------------------------
 
-        if 'partner_ids' in values:
-            values['attendee_ids'] = self._attendees_values(values['partner_ids'])
+    def change_attendee_status(self, status):
+        attendee = self.attendee_ids.filtered(lambda x: x.partner_id == self.env.user.partner_id)
+        if status == 'accepted':
+            return attendee.do_accept()
+        if status == 'declined':
+            return attendee.do_decline()
+        return attendee.do_tentative()
 
-        if (not recurrence_update_setting or recurrence_update_setting == 'self_only' and len(self) == 1) and 'follow_recurrence' not in values:
-            if any({field: values.get(field) for field in self.env['calendar.event']._get_time_fields() if field in values}):
-                values['follow_recurrence'] = False
+    def _find_my_attendee(self):
+        """ Return the first attendee where the user connected has been invited
+            from all the meeting_ids in parameters.
+        """
+        self.ensure_one()
+        for attendee in self.attendee_ids:
+            if self.env.user.partner_id == attendee.partner_id:
+                return attendee
+        return False
 
-        previous_attendees = self.attendee_ids
+    # ------------------------------------------------------------
+    # TOOLS
+    # ------------------------------------------------------------
 
-        recurrence_values = {field: values.pop(field) for field in self._get_recurrent_fields() if field in values}
-        if update_recurrence:
-            if break_recurrence:
-                detached_events |= self._break_recurrence(future=recurrence_update_setting == 'future_events')
-            else:
-                update_start = self.start if recurrence_update_setting == 'future_events' else None
-                time_values = {field: values.pop(field) for field in self.env['calendar.event']._get_time_fields() if field in values}
-                if not update_start and (time_values or recurrence_values):
-                    raise UserError(_("Updating All Events is not allowed when dates or time is modified. You can only update one particular event and following events."))
-                detached_events |= self._split_recurrence(time_values)
-                self.recurrence_id._write_events(values, dtstart=update_start)
-        else:
-            super().write(values)
-            self._sync_activities(fields=values.keys())
+    def _get_start_date(self):
+        """Return the event starting date in the event's timezone.
+        If no starting time is assigned (yet), return today as default
+        :return: date
+        """
+        if not self.start:
+            return fields.Date.today()
+        if self.recurrence_id.event_tz:
+            tz = pytz.timezone(self.recurrence_id.event_tz)
+            return pytz.utc.localize(self.start).astimezone(tz).date()
+        return self.start.date()
 
-        if recurrence_update_setting != 'self_only' and not break_recurrence:
-            detached_events |= self._apply_recurrence_values(recurrence_values, future=recurrence_update_setting == 'future_events')
+    def _range(self):
+        self.ensure_one()
+        return (self.start, self.stop)
 
-        (detached_events & self).active = False
-        (detached_events - self).with_context(archive_on_error=True).unlink()
+    def get_interval(self, interval, tz=None):
+        """ Format and localize some dates to be used in email templates
+            :param string interval: Among 'day', 'month', 'dayname' and 'time' indicating the desired formatting
+            :param string tz: Timezone indicator (optional)
+            :return unicode: Formatted date or time (as unicode string, to prevent jinja2 crash)
+        """
+        self.ensure_one()
+        date = fields.Datetime.from_string(self.start)
 
-        self._setup_alarms()
+        if tz:
+            timezone = pytz.timezone(tz or 'UTC')
+            date = date.replace(tzinfo=pytz.timezone('UTC')).astimezone(timezone)
 
-        current_attendees = self.filtered('active').attendee_ids
-        if 'partner_ids' in values:
-            (current_attendees - previous_attendees)._send_mail_to_attendees('calendar.calendar_template_meeting_invitation')
-        if 'start' in values:
-            start_date = fields.Datetime.to_datetime(values.get('start'))
-            # Only notify on future events
-            if start_date and start_date >= fields.Datetime.now():
-                (current_attendees & previous_attendees)._send_mail_to_attendees('calendar.calendar_template_meeting_changedate', ignore_recurrence=not update_recurrence)
+        if interval == 'day':
+            # Day number (1-31)
+            result = str(date.day)
 
-        return True
+        elif interval == 'month':
+            # Localized month name and year
+            result = babel.dates.format_date(date=date, format='MMMM y', locale=get_lang(self.env).code)
 
-    def _get_trigger_alarm_types(self):
-        return ['email']
+        elif interval == 'dayname':
+            # Localized day name
+            result = babel.dates.format_date(date=date, format='EEEE', locale=get_lang(self.env).code)
 
-    def _setup_alarms(self):
-        """ Schedule cron triggers for future events """
-        cron = self.env.ref('calendar.ir_cron_scheduler_alarm')
-        alarm_manager = self.env['calendar.alarm_manager']
-        alarm_types = self._get_trigger_alarm_types()
+        elif interval == 'time':
+            # Localized time
+            # FIXME: formats are specifically encoded to bytes, maybe use babel?
+            dummy, format_time = self._get_date_formats()
+            result = tools.ustr(date.strftime(format_time + " %Z"))
 
-        for event in self:
-            for alarm in (alarm for alarm in event.alarm_ids if alarm.alarm_type in alarm_types):
-                at = event.start - timedelta(minutes=alarm.duration_minutes)
-                if not cron.lastcall or at > cron.lastcall:
-                    # Don't trigger for past alarms, they would be skipped by design
-                    cron._trigger(at=at)
-            if any(alarm.alarm_type == 'notification' for alarm in event.alarm_ids):
-                alarm_manager._notify_next_alarm(event.partner_ids.ids)
+        return result
 
-    @api.model_create_multi
-    def create(self, vals_list):
-        vals_list = [  # Else bug with quick_create when we are filter on an other user
-            dict(vals, user_id=self.env.user.id) if not 'user_id' in vals else vals
-            for vals in vals_list
-        ]
+    def get_display_time_tz(self, tz=False):
+        """ get the display_time of the meeting, forcing the timezone. This method is called from email template, to not use sudo(). """
+        self.ensure_one()
+        if tz:
+            self = self.with_context(tz=tz)
+        return self._get_display_time(self.start, self.stop, self.duration, self.allday)
 
-        for values in vals_list:
-            # created from calendar: try to create an activity on the related record
-            if not values.get('activity_ids'):
-                defaults = self.default_get(['activity_ids', 'res_model_id', 'res_id', 'user_id'])
-                res_model_id = values.get('res_model_id', defaults.get('res_model_id'))
-                res_id = values.get('res_id', defaults.get('res_id'))
-                user_id = values.get('user_id', defaults.get('user_id'))
-                if not defaults.get('activity_ids') and res_model_id and res_id:
-                    if hasattr(self.env[self.env['ir.model'].sudo().browse(res_model_id).model], 'activity_ids'):
-                        meeting_activity_type = self.env['mail.activity.type'].search([('category', '=', 'meeting')], limit=1)
-                        if meeting_activity_type:
-                            activity_vals = {
-                                'res_model_id': res_model_id,
-                                'res_id': res_id,
-                                'activity_type_id': meeting_activity_type.id,
-                            }
-                            if user_id:
-                                activity_vals['user_id'] = user_id
-                            values['activity_ids'] = [(0, 0, activity_vals)]
+    def _get_ics_file(self):
+        """ Returns iCalendar file for the event invitation.
+            :returns a dict of .ics file content for each meeting
+        """
+        result = {}
 
-        vals_list = [
-            dict(vals, attendee_ids=self._attendees_values(vals['partner_ids'])) if 'partner_ids' in vals else vals
-            for vals in vals_list
-        ]
-        recurrence_fields = self._get_recurrent_fields()
-        recurring_vals = [vals for vals in vals_list if vals.get('recurrency')]
-        other_vals = [vals for vals in vals_list if not vals.get('recurrency')]
-        events = super().create(other_vals)
+        def ics_datetime(idate, allday=False):
+            if idate:
+                if allday:
+                    return idate
+                return idate.replace(tzinfo=pytz.timezone('UTC'))
+            return False
 
-        for vals in recurring_vals:
+        try:
+            # FIXME: why isn't this in CalDAV?
+            import vobject
+        except ImportError:
+            _logger.warning("The `vobject` Python module is not installed, so iCal file generation is unavailable. Please install the `vobject` Python module")
+            return result
 
-            recurrence_values = {field: vals.pop(field) for field in recurrence_fields if field in vals}
-            vals['follow_recurrence'] = True
-            event = super().create(vals)
-            events |= event
-            if vals.get('recurrency'):
-                detached_events = event._apply_recurrence_values(recurrence_values)
-                detached_events.active = False
+        for meeting in self:
+            cal = vobject.iCalendar()
+            event = cal.add('vevent')
 
-        events.filtered(lambda event: event.start > fields.Datetime.now()).attendee_ids._send_mail_to_attendees('calendar.calendar_template_meeting_invitation')
-        events._sync_activities(fields={f for vals in vals_list for f in vals.keys() })
+            if not meeting.start or not meeting.stop:
+                raise UserError(_("First you have to specify the date of the invitation."))
+            event.add('created').value = ics_datetime(fields.Datetime.now())
+            event.add('dtstart').value = ics_datetime(meeting.start, meeting.allday)
+            event.add('dtend').value = ics_datetime(meeting.stop, meeting.allday)
+            event.add('summary').value = meeting.name
+            if meeting.description:
+                event.add('description').value = meeting.description
+            if meeting.location:
+                event.add('location').value = meeting.location
+            if meeting.rrule:
+                event.add('rrule').value = meeting.rrule
 
-        events._setup_alarms()
+            if meeting.alarm_ids:
+                for alarm in meeting.alarm_ids:
+                    valarm = event.add('valarm')
+                    interval = alarm.interval
+                    duration = alarm.duration
+                    trigger = valarm.add('TRIGGER')
+                    trigger.params['related'] = ["START"]
+                    if interval == 'days':
+                        delta = timedelta(days=duration)
+                    elif interval == 'hours':
+                        delta = timedelta(hours=duration)
+                    elif interval == 'minutes':
+                        delta = timedelta(minutes=duration)
+                    trigger.value = delta
+                    valarm.add('DESCRIPTION').value = alarm.name or u'Odoo'
+            for attendee in meeting.attendee_ids:
+                attendee_add = event.add('attendee')
+                attendee_add.value = u'MAILTO:' + (attendee.email or u'')
+            result[meeting.id] = cal.serialize().encode('utf-8')
 
-        return events
+        return result
 
-    def read(self, fields=None, load='_classic_read'):
-        def hide(field, value):
-            """
-            :param field: field name
-            :param value: field value
-            :return: obfuscated field value
-            """
-            if field in {'name', 'display_name'}:
-                return _('Busy')
-            return [] if isinstance(value, list) else False
+    @api.model
+    def _get_display_time(self, start, stop, zduration, zallday):
+        """ Return date and time (from to from) based on duration with timezone in string. Eg :
+                1) if user add duration for 2 hours, return : August-23-2013 at (04-30 To 06-30) (Europe/Brussels)
+                2) if event all day ,return : AllDay, July-31-2013
+        """
+        timezone = self._context.get('tz') or self.env.user.partner_id.tz or 'UTC'
 
-        def split_privacy(events):
-            """
-            :param events: list of event values (dict)
-            :return: tuple(private events, public events)
-            """
-            private = [event for event in events if event.get('privacy') == 'private']
-            public = [event for event in events if event.get('privacy') != 'private']
-            return private, public
+        # get date/time format according to context
+        format_date, format_time = self._get_date_formats()
 
-        def my_events(events):
-            """
-            :param events: list of event values (dict)
-            :return: tuple(my events, other events)
-            """
-            my = [event for event in events if event.get('user_id') and event.get('user_id')[0] == self.env.uid]
-            others = [event for event in events if not event.get('user_id') or event.get('user_id')[0] != self.env.uid]
-            return my, others
+        # convert date and time into user timezone
+        self_tz = self.with_context(tz=timezone)
+        date = fields.Datetime.context_timestamp(self_tz, fields.Datetime.from_string(start))
+        date_deadline = fields.Datetime.context_timestamp(self_tz, fields.Datetime.from_string(stop))
 
-        def obfuscated(events):
-            """
-            :param events: list of event values (dict)
-            :return: events with private field values obfuscated
-            """
-            public_fields = self._get_public_fields()
-            return [{
-                field: hide(field, value) if field not in public_fields else value
-                for field, value in event.items()
-            } for event in events]
+        # convert into string the date and time, using user formats
+        to_text = pycompat.to_text
+        date_str = to_text(date.strftime(format_date))
+        time_str = to_text(date.strftime(format_time))
 
-        events = super().read(fields=fields + ['privacy', 'user_id'], load=load)
-        private_events, public_events = split_privacy(events)
-        my_private_events, others_private_events = my_events(private_events)
+        if zallday:
+            display_time = _("All Day, %(day)s", day=date_str)
+        elif zduration < 24:
+            duration = date + timedelta(minutes=round(zduration*60))
+            duration_time = to_text(duration.strftime(format_time))
+            display_time = _(
+                u"%(day)s at (%(start)s To %(end)s) (%(timezone)s)",
+                day=date_str,
+                start=time_str,
+                end=duration_time,
+                timezone=timezone,
+            )
+        else:
+            dd_date = to_text(date_deadline.strftime(format_date))
+            dd_time = to_text(date_deadline.strftime(format_time))
+            display_time = _(
+                u"%(date_start)s at %(time_start)s To\n %(date_end)s at %(time_end)s (%(timezone)s)",
+                date_start=date_str,
+                time_start=time_str,
+                date_end=dd_date,
+                time_end=dd_time,
+                timezone=timezone,
+            )
+        return display_time
 
-        return public_events + my_private_events + obfuscated(others_private_events)
+    def _get_duration(self, start, stop):
+        """ Get the duration value between the 2 given dates. """
+        if not start or not stop:
+            return 0
+        duration = (stop - start).total_seconds() / 3600
+        return round(duration, 2)
 
     @api.model
-    def read_group(self, domain, fields, groupby, offset=0, limit=None, orderby=False, lazy=True):
-        groupby = [groupby] if isinstance(groupby, str) else groupby
-        grouped_fields = set(group_field.split(':')[0] for group_field in groupby)
-        private_fields = grouped_fields - self._get_public_fields()
-        if not self.env.su and private_fields:
-            raise AccessError(_(
-                "Grouping by %s is not allowed.",
-                ', '.join([self._fields[field_name].string for field_name in private_fields])
-            ))
-        return super(Meeting, self).read_group(domain, fields, groupby, offset=offset, limit=limit, orderby=orderby, lazy=lazy)
-
-    def unlink(self):
-        # Get concerned attendees to notify them if there is an alarm on the unlinked events,
-        # as it might have changed their next event notification
-        events = self.filtered_domain([('alarm_ids', '!=', False)])
-        partner_ids = events.mapped('partner_ids').ids
-
-        result = super().unlink()
+    def _get_date_formats(self):
+        """ get current date and time format, according to the context lang
+            :return: a tuple with (format date, format time)
+        """
+        lang = get_lang(self.env)
+        return (lang.date_format, lang.time_format)
 
-        # Notify the concerned attendees (must be done after removing the events)
-        self.env['calendar.alarm_manager']._notify_next_alarm(partner_ids)
-        return result
+    @api.model
+    def _get_recurrent_fields(self):
+        return {'byday', 'until', 'rrule_type', 'month_by', 'event_tz', 'rrule',
+                'interval', 'count', 'end_type', 'mo', 'tu', 'we', 'th', 'fr', 'sa',
+                'su', 'day', 'weekday'}
 
-    def _range(self):
-        self.ensure_one()
-        return (self.start, self.stop)
+    @api.model
+    def _get_time_fields(self):
+        return {'start', 'stop', 'start_date', 'stop_date'}
 
-    def _sync_activities(self, fields):
-        # update activities
-        for event in self:
-            if event.activity_ids:
-                activity_values = {}
-                if 'name' in fields:
-                    activity_values['summary'] = event.name
-                if 'description' in fields:
-                    activity_values['note'] = tools.plaintext2html(event.description)
-                if 'start' in fields:
-                    # self.start is a datetime UTC *only when the event is not allday*
-                    # activty.date_deadline is a date (No TZ, but should represent the day in which the user's TZ is)
-                    # See 72254129dbaeae58d0a2055cba4e4a82cde495b7 for the same issue, but elsewhere
-                    deadline = event.start
-                    user_tz = self.env.context.get('tz')
-                    if user_tz and not event.allday:
-                        deadline = pytz.UTC.localize(deadline)
-                        deadline = deadline.astimezone(pytz.timezone(user_tz))
-                    activity_values['date_deadline'] = deadline.date()
-                if 'user_id' in fields:
-                    activity_values['user_id'] = event.user_id.id
-                if activity_values.keys():
-                    event.activity_ids.write(activity_values)
+    @api.model
+    def _get_custom_fields(self):
+        all_fields = self.fields_get(attributes=['manual'])
+        return {fname for fname in all_fields if all_fields[fname]['manual']}
 
-    def change_attendee_status(self, status):
-        attendee = self.attendee_ids.filtered(lambda x: x.partner_id == self.env.user.partner_id)
-        if status == 'accepted':
-            return attendee.do_accept()
-        if status == 'declined':
-            return attendee.do_decline()
-        return attendee.do_tentative()
+    @api.model
+    def _get_public_fields(self):
+        return self._get_recurrent_fields() | self._get_time_fields() | self._get_custom_fields() | {
+            'id', 'active', 'allday',
+            'duration', 'user_id', 'interval',
+            'count', 'rrule', 'recurrence_id', 'show_as', 'privacy'}
