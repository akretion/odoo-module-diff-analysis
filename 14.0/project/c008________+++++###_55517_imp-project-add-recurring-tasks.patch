PR: https://github.com/odoo/odoo/pull/55517

From: 1b62bd9508c58c5a4f2e41f2176d737a2e404656
From: Kevin Baptiste
Date: 2020-08-12 08:39:32

Structural Changes: 60
Total Changes: 515

[IMP] project: add recurring tasks

Some interventions are done on a regular basis (e.g. maintenance of
fire alarms, safety inspections). Having tasks auto-generate would
facilitate the process and would ensure that the next intervention
isn't missed/forgotten.

closes odoo/odoo#55517

Taskid: 2172156
Related: odoo/enterprise#12246
Related: odoo/upgrade#1604
Signed-off-by: Yannick Tivisse (yti) <yti@odoo.com>

================================= pseudo patch: =================================

--- a/addons/project/models/__init__.py
+++ b/addons/project/models/__init__.py
@@ -2,6 +2,7 @@
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
 from . import analytic_account
+from . import project_task_recurrence
 from . import project
 from . import res_config_settings
 from . import res_partner

--- a/addons/project/models/project.py
+++ b/addons/project/models/project.py
@@ -2,13 +2,15 @@
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
 import ast
-from datetime import timedelta
+from datetime import timedelta, datetime
 from random import randint
 
 from odoo import api, fields, models, tools, SUPERUSER_ID, _
 from odoo.exceptions import UserError, AccessError, ValidationError, RedirectWarning
-from odoo.tools.misc import format_date
+from odoo.tools.misc import format_date, get_lang
+from odoo.osv.expression import OR
 
+from .project_task_recurrence import DAYS, WEEKS
 
 class ProjectTaskType(models.Model):
     _name = 'project.task.type'
@@ -210,6 +212,7 @@ class Project(models.Model):
     subtask_project_id = fields.Many2one('project.project', string='Sub-task Project', ondelete="restrict",
         help="Project in which sub-tasks of the current project will be created. It can be the current project itself.")
     allow_subtasks = fields.Boolean('Sub-tasks', default=lambda self: self.env.user.has_group('project.group_subtask_project'))
+    allow_recurring_tasks = fields.Boolean('Recurring Tasks', default=lambda self: self.env.user.has_group('project.group_project_recurring_tasks'))
 
     # rating fields
     rating_request_deadline = fields.Datetime(compute='_compute_rating_request_deadline', store=True)
@@ -339,6 +342,9 @@ class Project(models.Model):
                 for task in project.task_ids:
                     task.allowed_user_ids -= permission_removed
 
+        if 'allow_recurring_tasks' in vals and not vals.get('allow_recurring_tasks'):
+            self.env['project.task'].search([('project_id', 'in', self.ids), ('recurring_task', '=', True)]).write({'recurring_task': False})
+
         if 'active' in vals:
             # archiving/unarchiving a project does it on its tasks, too
             self.with_context(active_test=False).mapped('tasks').write({'active': vals['active']})
@@ -596,6 +602,172 @@ class Task(models.Model):
     # customer portal: include comment and incoming emails in communication history
     website_message_ids = fields.One2many(domain=lambda self: [('model', '=', self._name), ('message_type', 'in', ['email', 'comment'])])
 
+    # recurrence fields
+    allow_recurring_tasks = fields.Boolean(related='project_id.allow_recurring_tasks')
+    recurring_task = fields.Boolean(string="Recurrent")
+    recurring_count = fields.Integer(string="Tasks in Recurrence", compute='_compute_recurring_count')
+    recurrence_id = fields.Many2one('project.task.recurrence', copy=False)
+    recurrence_update = fields.Selection([
+        ('this', 'This task'),
+        ('subsequent', 'This and following tasks'),
+        ('all', 'All tasks'),
+    ], default='this', store=False)
+    recurrence_message = fields.Char(string='Next Recurrencies', compute='_compute_recurrence_message')
+
+    repeat_interval = fields.Integer(string='Repeat Every', default=1, compute='_compute_repeat', readonly=False)
+    repeat_unit = fields.Selection([
+        ('day', 'Days'),
+        ('week', 'Weeks'),
+        ('month', 'Months'),
+        ('year', 'Years'),
+    ], default='week', compute='_compute_repeat', readonly=False)
+    repeat_type = fields.Selection([
+        ('forever', 'Forever'),
+        ('until', 'End Date'),
+        ('after', 'Number of Repetitions'),
+    ], default="forever", string="Until", compute='_compute_repeat', readonly=False)
+    repeat_until = fields.Date(string="End Date", compute='_compute_repeat', readonly=False)
+    repeat_number = fields.Integer(string="Repetitions", default=1, compute='_compute_repeat', readonly=False)
+
+    repeat_on_month = fields.Selection([
+        ('date', 'Date of the Month'),
+        ('day', 'Day of the Month'),
+    ], default='date', compute='_compute_repeat', readonly=False)
+
+    repeat_on_year = fields.Selection([
+        ('date', 'Date of the Year'),
+        ('day', 'Day of the Year'),
+    ], default='date', compute='_compute_repeat', readonly=False)
+
+    mon = fields.Boolean(string="Mon", compute='_compute_repeat', readonly=False)
+    tue = fields.Boolean(string="Tue", compute='_compute_repeat', readonly=False)
+    wed = fields.Boolean(string="Wed", compute='_compute_repeat', readonly=False)
+    thu = fields.Boolean(string="Thu", compute='_compute_repeat', readonly=False)
+    fri = fields.Boolean(string="Fri", compute='_compute_repeat', readonly=False)
+    sat = fields.Boolean(string="Sat", compute='_compute_repeat', readonly=False)
+    sun = fields.Boolean(string="Sun", compute='_compute_repeat', readonly=False)
+
+    repeat_day = fields.Selection([
+        (str(i), str(i)) for i in range(1, 32)
+    ], compute='_compute_repeat', readonly=False)
+    repeat_week = fields.Selection([
+        ('first', 'First'),
+        ('second', 'Second'),
+        ('third', 'Third'),
+        ('last', 'Last'),
+    ], default='first', compute='_compute_repeat', readonly=False)
+    repeat_weekday = fields.Selection([
+        ('mon', 'Monday'),
+        ('tue', 'Tuesday'),
+        ('wed', 'Wednesday'),
+        ('thu', 'Thursday'),
+        ('fri', 'Friday'),
+        ('sat', 'Saturday'),
+        ('sun', 'Sunday'),
+    ], string='Day Of The Week', compute='_compute_repeat', readonly=False)
+    repeat_month = fields.Selection([
+        ('january', 'January'),
+        ('february', 'February'),
+        ('march', 'March'),
+        ('april', 'April'),
+        ('may', 'May'),
+        ('june', 'June'),
+        ('july', 'July'),
+        ('august', 'August'),
+        ('september', 'September'),
+        ('october', 'October'),
+        ('november', 'November'),
+        ('december', 'December'),
+    ], compute='_compute_repeat', readonly=False)
+
+    repeat_show_dow = fields.Boolean(compute='_compute_repeat_visibility')
+    repeat_show_day = fields.Boolean(compute='_compute_repeat_visibility')
+    repeat_show_week = fields.Boolean(compute='_compute_repeat_visibility')
+    repeat_show_month = fields.Boolean(compute='_compute_repeat_visibility')
+
+    @api.model
+    def _get_recurrence_fields(self):
+        return ['repeat_interval', 'repeat_unit', 'repeat_type', 'repeat_until', 'repeat_number',
+                'repeat_on_month', 'repeat_on_year', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat',
+                'sun', 'repeat_day', 'repeat_week', 'repeat_month', 'repeat_weekday']
+
+    @api.depends('recurring_task', 'repeat_unit', 'repeat_on_month', 'repeat_on_year')
+    def _compute_repeat_visibility(self):
+        for task in self:
+            task.repeat_show_day = task.recurring_task and (task.repeat_unit == 'month' and task.repeat_on_month == 'date') or (task.repeat_unit == 'year' and task.repeat_on_year == 'date')
+            task.repeat_show_week = task.recurring_task and (task.repeat_unit == 'month' and task.repeat_on_month == 'day') or (task.repeat_unit == 'year' and task.repeat_on_year == 'day')
+            task.repeat_show_dow = task.recurring_task and task.repeat_unit == 'week'
+            task.repeat_show_month = task.recurring_task and task.repeat_unit == 'year'
+
+    @api.depends('recurring_task', 'repeat_unit')
+    def _compute_repeat(self):
+        rec_fields = self._get_recurrence_fields()
+        defaults = self.default_get(rec_fields)
+        for task in self:
+            for f in rec_fields:
+                if task.recurrence_id:
+                    task[f] = task.recurrence_id[f]
+                else:
+                    if task.recurring_task:
+                        task[f] = defaults.get(f)
+                    else:
+                        task[f] = False
+
+    def _get_weekdays(self, n=1):
+        self.ensure_one()
+        if self.repeat_unit == 'week':
+            return [fn(n) for day, fn in DAYS.items() if self[day]]
+        return [DAYS.get(self.repeat_weekday)(n)]
+
+    @api.depends(
+        'recurring_task', 'repeat_interval', 'repeat_unit', 'repeat_type', 'repeat_until',
+        'repeat_number', 'repeat_on_month', 'repeat_on_year', 'mon', 'tue', 'wed', 'thu', 'fri',
+        'sat', 'sun', 'repeat_day', 'repeat_week', 'repeat_month', 'repeat_weekday')
+    def _compute_recurrence_message(self):
+        self.recurrence_message = False
+        for task in self.filtered(lambda t: t.recurring_task and t._is_recurrence_valid()):
+            date = fields.Date.today()
+            number_occurrences = min(5, task.repeat_number if task.repeat_type == 'after' else 5)
+            delta = task.repeat_interval if task.repeat_unit == 'day' else 1
+            recurring_dates = self.env['project.task.recurrence']._get_next_recurring_dates(
+                date + timedelta(days=delta),
+                task.repeat_interval,
+                task.repeat_unit,
+                task.repeat_type,
+                task.repeat_until,
+                task.repeat_on_month,
+                task.repeat_on_year,
+                task._get_weekdays(WEEKS.get(task.repeat_week)),
+                task.repeat_day,
+                task.repeat_week,
+                task.repeat_month,
+                count=number_occurrences)
+            date_format = self.env['res.lang']._lang_get(self.env.user.lang).date_format
+            task.recurrence_message = '<ul>'
+            for date in recurring_dates[:5]:
+                task.recurrence_message += '<li>%s</li>' % date.strftime(date_format)
+            if task.repeat_type == 'after' and task.repeat_number > 5 or task.repeat_type == 'forever' or len(recurring_dates) > 5:
+                task.recurrence_message += '<li>...</li>'
+            task.recurrence_message += '</ul>'
+            if task.repeat_type == 'until':
+                task.recurrence_message += _('<p><em>Number of tasks: %(tasks_count)s</em></p>') % {'tasks_count': len(recurring_dates)}
+
+    def _is_recurrence_valid(self):
+        self.ensure_one()
+        return self.repeat_interval > 0 and\
+                (not self.repeat_show_dow or self._get_weekdays()) and\
+                (self.repeat_type != 'after' or self.repeat_number) and\
+                (self.repeat_type != 'until' or self.repeat_until and self.repeat_until > fields.Date.today())
+
+    @api.depends('recurrence_id')
+    def _compute_recurring_count(self):
+        self.recurring_count = 0
+        recurring_tasks = self.filtered(lambda l: l.recurrence_id)
+        count = self.env['project.task'].read_group([('recurrence_id', 'in', recurring_tasks.recurrence_id.ids)], ['id'], 'recurrence_id')
+        tasks_count = {c.get('recurrence_id')[0]: c.get('recurrence_id_count') for c in count}
+        for task in recurring_tasks:
+            task.recurring_count = tasks_count.get(task.recurrence_id.id, 0)
+
     @api.depends('partner_id.email')
     def _compute_partner_email(self):
         for task in self:
@@ -759,6 +931,8 @@ class Task(models.Model):
             default = {}
         if not default.get('name'):
             default['name'] = _("%s (copy)", self.name)
+        if self.recurrence_id:
+            default['recurrence_id'] = self.recurrence_id.copy().id
         return super(Task, self).copy(default)
 
     @api.constrains('parent_id')
@@ -821,6 +995,25 @@ class Task(models.Model):
     # ------------------------------------------------
     # CRUD overrides
     # ------------------------------------------------
+    @api.model
+    def default_get(self, default_fields):
+        vals = super(Task, self).default_get(default_fields)
+
+        days = list(DAYS.keys())
+        week_start = fields.Datetime.today().weekday()
+
+        if all([d in default_fields for d in days]):
+            vals[days[week_start]] = True
+        if 'repeat_day' in default_fields:
+            vals['repeat_day'] = str(fields.Datetime.today().day)
+        if 'repeat_month' in default_fields:
+            vals['repeat_month'] = self._fields.get('repeat_month').selection[fields.Datetime.today().month - 1][0]
+        if 'repeat_until' in default_fields:
+            vals['repeat_until'] = fields.Date.today() + timedelta(days=7)
+        if 'repeat_weekday' in default_fields:
+            vals['repeat_weekday'] = self._fields.get('repeat_weekday').selection[week_start][0]
+
+        return vals
 
     @api.model_create_multi
     def create(self, vals_list):
@@ -847,12 +1040,22 @@ class Task(models.Model):
             if vals.get('stage_id'):
                 vals.update(self.update_date_end(vals['stage_id']))
                 vals['date_last_stage_update'] = fields.Datetime.now()
+            # recurrence
+            rec_fields = vals.keys() & self._get_recurrence_fields()
+            if rec_fields and vals.get('recurring_task') is True:
+                rec_values = {rec_field: vals[rec_field] for rec_field in rec_fields}
+                rec_values['next_recurrence_date'] = fields.Datetime.today()
+                recurrence = self.env['project.task.recurrence'].create(rec_values)
+                vals['recurrence_id'] = recurrence.id
         return super().create(vals_list)
 
     def write(self, vals):
         now = fields.Datetime.now()
         if 'parent_id' in vals and vals['parent_id'] in self.ids:
             raise UserError(_("Sorry. You can't set a task as its parent task."))
+        if 'active' in vals and not vals.get('active') and any(self.mapped('recurrence_id')):
+            # TODO: show a dialog to stop the recurrence
+            raise UserError(_('You cannot archive recurring tasks. Please, disable the recurrence first.'))
         # stage change: update date_last_stage_update
         if 'stage_id' in vals:
             vals.update(self.update_date_end(vals['stage_id']))
@@ -864,7 +1067,33 @@ class Task(models.Model):
         if vals.get('user_id') and 'date_assign' not in vals:
             vals['date_assign'] = now
 
-        result = super(Task, self).write(vals)
+        # recurrence fields
+        rec_fields = vals.keys() & self._get_recurrence_fields()
+        if rec_fields:
+            rec_values = {rec_field: vals[rec_field] for rec_field in rec_fields}
+            for task in self:
+                if task.recurrence_id:
+                    task.recurrence_id.write(rec_values)
+                elif vals.get('recurring_task'):
+                    rec_values['next_recurrence_date'] = fields.Datetime.today()
+                    recurrence = self.env['project.task.recurrence'].create(rec_values)
+                    task.recurrence_id = recurrence.id
+
+        if 'recurring_task' in vals and not vals.get('recurring_task'):
+            self.recurrence_id.unlink()
+
+        tasks = self
+        recurrence_update = vals.pop('recurrence_update', 'this')
+        if recurrence_update != 'this':
+            recurrence_domain = []
+            if recurrence_update == 'subsequent':
+                for task in self:
+                    recurrence_domain = OR([recurrence_domain, ['&', ('recurrence_id', '=', task.recurrence_id.id), ('create_date', '>=', task.create_date)]])
+            else:
+                recurrence_domain = [('recurrence_id', 'in', self.recurrence_id.ids)]
+            tasks |= self.env['project.task'].search(recurrence_domain)
+
+        result = super(Task, tasks).write(vals)
         # rating on stage
         if 'stage_id' in vals and vals.get('stage_id'):
             self.filtered(lambda x: x.project_id.rating_status == 'stage')._send_task_rating_mail(force_send=True)
@@ -876,6 +1105,12 @@ class Task(models.Model):
             return {'date_end': fields.Datetime.now()}
         return {'date_end': False}
 
+    def unlink(self):
+        if any(self.mapped('recurrence_id')):
+            # TODO: show a dialog to stop the recurrence
+            raise UserError(_('You cannot delete recurring tasks. Please, disable the recurrence first.'))
+        return super().unlink()
+
     # ---------------------------------------------------
     # Subtasks
     # ---------------------------------------------------
@@ -1106,6 +1341,15 @@ class Task(models.Model):
 
         return action
 
+    def action_recurring_tasks(self):
+        return {
+            'name': 'Tasks in Recurrence',
+            'type': 'ir.actions.act_window',
+            'res_model': 'project.task',
+            'view_mode': 'tree,form',
+            'domain': [('recurrence_id', 'in', self.recurrence_id.ids)],
+        }
+
     # ---------------------------------------------------
     # Rating business
     # ---------------------------------------------------

--- a/None
+++ b/addons/project/models/project_task_recurrence.py
@@ -0,0 +1,258 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from odoo import api, fields, models
+from odoo.exceptions import ValidationError
+
+from calendar import monthrange
+from dateutil.relativedelta import relativedelta
+from dateutil.rrule import rrule, rruleset, DAILY, WEEKLY, MONTHLY, YEARLY, MO, TU, WE, TH, FR, SA, SU
+
+MONTHS = {
+    'january': 31,
+    'february': 28,
+    'march': 31,
+    'april': 30,
+    'may': 31,
+    'june': 30,
+    'july': 31,
+    'august': 31,
+    'september': 30,
+    'october': 31,
+    'november': 30,
+    'december': 31,
+}
+
+DAYS = {
+    'mon': MO,
+    'tue': TU,
+    'wed': WE,
+    'thu': TH,
+    'fri': FR,
+    'sat': SA,
+    'sun': SU,
+}
+
+WEEKS = {
+    'first': 1,
+    'second': 2,
+    'third': 3,
+    'last': 4,
+}
+
+class ProjectTaskRecurrence(models.Model):
+    _name = 'project.task.recurrence'
+    _description = 'Task Recurrence'
+
+    task_ids = fields.One2many('project.task', 'recurrence_id')
+    next_recurrence_date = fields.Date()
+    recurrence_left = fields.Integer(string="Number of tasks left to create")
+
+    repeat_interval = fields.Integer(string='Repeat Every', default=1)
+    repeat_unit = fields.Selection([
+        ('day', 'Days'),
+        ('week', 'Weeks'),
+        ('month', 'Months'),
+        ('year', 'Years'),
+    ], default='week')
+    repeat_type = fields.Selection([
+        ('forever', 'Forever'),
+        ('until', 'End Date'),
+        ('after', 'Number of Repetitions'),
+    ], default="forever", string="Until")
+    repeat_until = fields.Date(string="End Date")
+    repeat_number = fields.Integer(string="Repetitions")
+
+    repeat_on_month = fields.Selection([
+        ('date', 'Date of the Month'),
+        ('day', 'Day of the Month'),
+    ])
+
+    repeat_on_year = fields.Selection([
+        ('date', 'Date of the Year'),
+        ('day', 'Day of the Year'),
+    ])
+
+    mon = fields.Boolean(string="Mon")
+    tue = fields.Boolean(string="Tue")
+    wed = fields.Boolean(string="Wed")
+    thu = fields.Boolean(string="Thu")
+    fri = fields.Boolean(string="Fri")
+    sat = fields.Boolean(string="Sat")
+    sun = fields.Boolean(string="Sun")
+
+    repeat_day = fields.Selection([
+        (str(i), str(i)) for i in range(1, 32)
+    ])
+    repeat_week = fields.Selection([
+        ('first', 'First'),
+        ('second', 'Second'),
+        ('third', 'Third'),
+        ('last', 'Last'),
+    ])
+    repeat_weekday = fields.Selection([
+        ('mon', 'Monday'),
+        ('tue', 'Tuesday'),
+        ('wed', 'Wednesday'),
+        ('thu', 'Thursday'),
+        ('fri', 'Friday'),
+        ('sat', 'Saturday'),
+        ('sun', 'Sunday'),
+    ], string='Day Of The Week', readonly=False)
+    repeat_month = fields.Selection([
+        ('january', 'January'),
+        ('february', 'February'),
+        ('march', 'March'),
+        ('april', 'April'),
+        ('may', 'May'),
+        ('june', 'June'),
+        ('july', 'July'),
+        ('august', 'August'),
+        ('september', 'September'),
+        ('october', 'October'),
+        ('november', 'November'),
+        ('december', 'December'),
+    ])
+
+    @api.constrains('repeat_unit', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun')
+    def _check_recurrence_days(self):
+        for project in self.filtered(lambda p: p.repeat_unit == 'week'):
+            if not any([project.mon, project.tue, project.wed, project.thu, project.fri, project.sat, project.sun]):
+                raise ValidationError('You should select a least one day')
+
+    @api.constrains('repeat_interval')
+    def _check_repeat_interval(self):
+        if self.filtered(lambda t: t.repeat_interval <= 0):
+            raise ValidationError('The interval should be greater than 0')
+
+    @api.constrains('repeat_number', 'repeat_type')
+    def _check_repeat_number(self):
+        if self.filtered(lambda t: t.repeat_type == 'after' and t.repeat_number <= 0):
+            raise ValidationError('Should repeat at least once')
+
+    @api.constrains('repeat_type', 'repeat_until')
+    def _check_repeat_until_date(self):
+        today = fields.Date.today()
+        if self.filtered(lambda t: t.repeat_type == 'until' and t.repeat_until < today):
+            raise ValidationError('The end date should be in the future')
+
+    @api.constrains('repeat_unit', 'repeat_on_month', 'repeat_day', 'repeat_type', 'repeat_until')
+    def _check_repeat_until_month(self):
+        if self.filtered(lambda r: r.repeat_type == 'until' and r.repeat_unit == 'month' and r.repeat_until and r.repeat_on_month == 'date' and int(r.repeat_day) > r.repeat_until.day):
+            raise ValidationError('The end date should be after the day of the month')
+
+    @api.model
+    def _get_recurring_fields(self):
+        return ['allowed_user_ids', 'company_id', 'description', 'displayed_image_id', 'email_cc',
+                'parent_id', 'partner_email', 'partner_id', 'partner_phone', 'planned_hours',
+                'project_id', 'project_privacy_visibility', 'sequence', 'tag_ids', 'recurrence_id',
+                'name', 'recurring_task']
+
+    def _get_weekdays(self, n=1):
+        self.ensure_one()
+        if self.repeat_unit == 'week':
+            return [fn(n) for day, fn in DAYS.items() if self[day]]
+        return [DAYS.get(self.repeat_weekday)(n)]
+
+    @api.model
+    def _get_next_recurring_dates(self, date_start, repeat_interval, repeat_unit, repeat_type, repeat_until, repeat_on_month, repeat_on_year, weekdays, repeat_day, repeat_week, repeat_month, **kwargs):
+        count = kwargs.get('count', 1)
+        rrule_kwargs = {'interval': repeat_interval or 1, 'dtstart': date_start}
+        repeat_day = int(repeat_day)
+        start = False
+        dates = []
+        if repeat_type == 'until':
+            rrule_kwargs['until'] = repeat_until if repeat_until else fields.Date.today()
+        else:
+            rrule_kwargs['count'] = count
+
+        if repeat_unit == 'week'\
+            or (repeat_unit == 'month' and repeat_on_month == 'day')\
+            or (repeat_unit == 'year' and repeat_on_year == 'day'):
+            rrule_kwargs['byweekday'] = weekdays
+
+        if repeat_unit == 'day':
+            rrule_kwargs['freq'] = DAILY
+        elif repeat_unit == 'month':
+            rrule_kwargs['freq'] = MONTHLY
+            if repeat_on_month == 'date':
+                start = date_start - relativedelta(days=1)
+                if repeat_type == 'until' and repeat_until > date_start:
+                    delta = relativedelta(repeat_until, date_start)
+                    count = delta.years * 12 + delta.months
+                for i in range(count):
+                    start = start.replace(day=min(repeat_day, monthrange(start.year, start.month)[1]))
+                    dates.append(start)
+                    start += relativedelta(months=repeat_interval)
+                return dates
+        elif repeat_unit == 'year':
+            rrule_kwargs['freq'] = YEARLY
+            month = list(MONTHS.keys()).index(repeat_month) + 1
+            rrule_kwargs['bymonth'] = month
+            if repeat_on_year == 'date':
+                rrule_kwargs['bymonthday'] = min(repeat_day, MONTHS.get(repeat_month))
+                rrule_kwargs['bymonth'] = month
+        else:
+            rrule_kwargs['freq'] = WEEKLY
+
+        rules = rrule(**rrule_kwargs)
+        return list(rules) if rules else []
+
+    def _new_task_values(self, task):
+        self.ensure_one()
+        fields_to_copy = self._get_recurring_fields()
+        task_values = task.read(fields_to_copy).pop()
+        create_values = {
+            field: value[0] if isinstance(value, tuple) else value for field, value in task_values.items()
+        }
+        create_values['stage_id'] = task.project_id.type_ids[0].id if task.project_id.type_ids else task.stage_id
+        create_values['user_id'] = False
+        return create_values
+
+    def _create_next_task(self):
+        for recurrence in self:
+            task = self.sudo().task_ids[-1]
+            create_values = recurrence._new_task_values(task)
+            new_task = self.env['project.task'].sudo().create(create_values)
+            if not new_task.parent_id and task.child_ids:
+                children = []
+                # copy the subtasks of the original task
+                for child in task.child_ids:
+                    child_values = self._new_task_values(child)
+                    child_values['parent_id'] = new_task.id
+                    children.append(child_values)
+                self.env['project.task'].create(children)
+
+    def _set_next_recurrence_date(self):
+        today = fields.Date.today()
+        tomorrow = today + relativedelta(days=1)
+        for recurrence in self.filtered(lambda r: r.repeat_type == 'after' and r.recurrence_left > 0 or r.repeat_type == 'until' and r.repeat_until >= today or r.repeat_type == 'forever'):
+            next_date = self._get_next_recurring_dates(tomorrow, recurrence.repeat_interval, recurrence.repeat_unit, recurrence.repeat_type, recurrence.repeat_until, recurrence.repeat_on_month, recurrence.repeat_on_year, recurrence._get_weekdays(), recurrence.repeat_day, recurrence.repeat_week, recurrence.repeat_month, count=1)
+            recurrence.next_recurrence_date = next_date[0] if next_date else False
+
+    def _cron_create_recurring_tasks(self):
+        if not self.env.user.has_group('project.group_project_recurring_tasks'):
+            return
+        today = fields.Date.today()
+        recurring_today = self.search([('next_recurrence_date', '<=', today)])
+        recurring_today._create_next_task()
+        for recurrence in recurring_today.filtered(lambda r: r.repeat_type == 'after'):
+            recurrence.recurrence_left -= 1
+        recurring_today._set_next_recurrence_date()
+
+    def create(self, vals):
+        if vals.get('repeat_number'):
+            vals['recurrence_left'] = vals.get('repeat_number')
+        res = super(ProjectTaskRecurrence, self).create(vals)
+        res._set_next_recurrence_date()
+        return res
+
+    def write(self, vals):
+        if vals.get('repeat_number'):
+            vals['recurrence_left'] = vals.get('repeat_number')
+
+        res = super(ProjectTaskRecurrence, self).write(vals)
+
+        if 'next_recurrence_date' not in vals:
+            self._set_next_recurrence_date()
+        return res

--- a/addons/project/models/res_config_settings.py
+++ b/addons/project/models/res_config_settings.py
@@ -11,3 +11,9 @@ class ResConfigSettings(models.TransientModel):
     module_hr_timesheet = fields.Boolean(string="Task Logs")
     group_subtask_project = fields.Boolean("Sub-tasks", implied_group="project.group_subtask_project")
     group_project_rating = fields.Boolean("Customer Ratings", implied_group='project.group_project_rating')
+    group_project_recurring_tasks = fields.Boolean("Recurring Tasks", implied_group="project.group_project_recurring_tasks")
+
+    def set_values(self):
+        if self.user_has_groups('project.group_project_recurring_tasks') != self.group_project_recurring_tasks:
+            self.env['project.project'].sudo().search([]).write({'allow_recurring_tasks': self.group_project_recurring_tasks})
+        super(ResConfigSettings, self).set_values()
