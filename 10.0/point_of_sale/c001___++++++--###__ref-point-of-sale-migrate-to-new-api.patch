PR: https://github.com/odoo/odoo/pull/

From: 32b5515a8ff6047db489e569935b4416f946bc26
From: Darshan Kalola
Date: 2016-02-17 16:10:03

Structural Changes: 81
Total Changes: 2362

[REF] point_of_sale: migrate to new api

================================= pseudo patch: =================================

--- a/addons/point_of_sale/models/account_bank_statement.py
+++ b/addons/point_of_sale/models/account_bank_statement.py
@@ -1,21 +1,17 @@
 # -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
-
 # Copyright (C) 2004-2008 PC Solutions (<http://pcsol.be>). All Rights Reserved
-
-from openerp.osv import fields, osv
+from odoo import fields, models
 
 
-class account_bank_statement(osv.osv):
+class AccountBankStatement(models.Model):
     _inherit = 'account.bank.statement'
-    _columns = {
-        'pos_session_id' : fields.many2one('pos.session', string="Session", copy=False),
-        'account_id': fields.related('journal_id', 'default_debit_account_id', type='many2one', relation='account.account', readonly=True),
-    }
 
+    pos_session_id = fields.Many2one('pos.session', string="Session", copy=False)
+    account_id = fields.Many2one('account.account', related='journal_id.default_debit_account_id', readonly=True)
 
-class account_bank_statement_line(osv.osv):
+
+class AccountBankStatementLine(models.Model):
     _inherit = 'account.bank.statement.line'
-    _columns= {
-        'pos_statement_id': fields.many2one('pos.order', string="POS statement", ondelete='cascade'),
-    }
+
+    pos_statement_id = fields.Many2one('pos.order', string="POS statement", ondelete='cascade')

--- a/addons/point_of_sale/models/account_journal.py
+++ b/addons/point_of_sale/models/account_journal.py
@@ -1,27 +1,24 @@
 # -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
-
 # Copyright (C) 2004-2008 PC Solutions (<http://pcsol.be>). All Rights Reserved
-from openerp.osv import fields, osv
+from odoo import fields, models, api
 
-class account_journal(osv.osv):
-    _inherit = 'account.journal'
-    _columns = {
-        'journal_user': fields.boolean('Active in Point of Sale', help="Check this box if this journal define a payment method that can be used in a point of sale."),
 
-        'amount_authorized_diff' : fields.float('Amount Authorized Difference', help="This field depicts the maximum difference allowed between the ending balance and the theoretical cash when closing a session, for non-POS managers. If this maximum is reached, the user will have an error message at the closing of his session saying that he needs to contact his manager."),
-    }
+class AccountJournal(models.Model):
+    _inherit = 'account.journal'
 
-    def search(self, cr, uid, args, offset=0, limit=None, order=None, context=None, count=False):
-        if not context:
-            context = {}
-        session_id = context.get('pos_session_id', False) or False
+    journal_user = fields.Boolean('Active in Point of Sale',
+        help="Check this box if this journal define a payment method that can be used in a point of sale.")
+    amount_authorized_diff = fields.Float('Amount Authorized Difference',
+        help="This field depicts the maximum difference allowed between the ending balance and the theoretical cash when "
+             "closing a session, for non-POS managers. If this maximum is reached, the user will have an error message at "
+             "the closing of his session saying that he needs to contact his manager.")
 
+    @api.model
+    def search(self, args, offset=0, limit=None, order=None, count=False):
+        session_id = self.env.context.get('pos_session_id', False)
         if session_id:
-            session = self.pool.get('pos.session').browse(cr, uid, session_id, context=context)
-
+            session = self.env['pos.session'].browse(session_id)
             if session:
-                journal_ids = [journal.id for journal in session.config_id.journal_ids]
-                args += [('id', 'in', journal_ids)]
-
-        return super(account_journal, self).search(cr, uid, args, offset=offset, limit=limit, order=order, context=context, count=count)
+                args += [('id', 'in', session.config_id.journal_ids.ids)]
+        return super(AccountJournal, self).search(args=args, offset=offset, limit=limit, order=order, count=count)

--- a/addons/point_of_sale/models/barcode_rule.py
+++ b/addons/point_of_sale/models/barcode_rule.py
@@ -1,15 +1,16 @@
 # -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 import sets
-from openerp import models
-from openerp.tools.translate import _
 
+from odoo import models
+from odoo.tools.translate import _
 
-class barcode_rule(models.Model):
+
+class BarcodeRule(models.Model):
     _inherit = 'barcode.rule'
 
     def _get_type_selection(self):
-        types = sets.Set(super(barcode_rule,self)._get_type_selection())
+        types = sets.Set(super(BarcodeRule, self)._get_type_selection())
         types.update([
             ('weight', _('Weighted Product')),
             ('price', _('Priced Product')),

--- a/addons/point_of_sale/models/pos_category.py
+++ b/addons/point_of_sale/models/pos_category.py
@@ -1,57 +1,40 @@
 # -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
+from odoo import api, fields, models, tools, _
 
-from openerp import tools
-from openerp.osv import fields, osv
 
-
-class pos_category(osv.osv):
+class PosCategory(models.Model):
     _name = "pos.category"
     _description = "Public Category"
     _order = "sequence, name"
 
-    _constraints = [
-        (osv.osv._check_recursion, 'Error ! You cannot create recursive categories.', ['parent_id'])
-    ]
-
-    def name_get(self, cr, uid, ids, context=None):
-        res = []
-        for cat in self.browse(cr, uid, ids, context=context):
-            names = [cat.name]
-            pcat = cat.parent_id
-            while pcat:
-                names.append(pcat.name)
-                pcat = pcat.parent_id
-            res.append((cat.id, ' / '.join(reversed(names))))
-        return res
-
-    _columns = {
-        'name': fields.char('Name', required=True, translate=True),
-        'parent_id': fields.many2one('pos.category','Parent Category', select=True),
-        'child_id': fields.one2many('pos.category', 'parent_id', string='Children Categories'),
-        'sequence': fields.integer('Sequence', help="Gives the sequence order when displaying a list of product categories."),
-        
-    }
+    @api.constrains('parent_id')
+    def _check_category_recursion(self):
+        if not self._check_recursion():
+            raise ValueError(_('Error ! You cannot create recursive categories.'))
 
+    name = fields.Char(required=True, translate=True)
+    parent_id = fields.Many2one('pos.category', string='Parent Category', index=True)
+    child_id = fields.One2many('pos.category', 'parent_id', string='Children Categories')
+    sequence = fields.Integer(help="Gives the sequence order when displaying a list of product categories.")
     # NOTE: there is no 'default image', because by default we don't show
     # thumbnails for categories. However if we have a thumbnail for at least one
     # category, then we display a default image on the other, so that the
     # buttons have consistent styling.
-    # In this case, the default image is set by the js code.
-    image = openerp.fields.Binary("Image", attachment=True,
+    image = fields.Binary(attachment=True,
         help="This field holds the image used as image for the cateogry, limited to 1024x1024px.")
-    image_medium = openerp.fields.Binary("Medium-sized image",
+    image_medium = fields.Binary(string="Medium-sized image",
         compute='_compute_images', inverse='_inverse_image_medium', store=True, attachment=True,
-        help="Medium-sized image of the category. It is automatically "\
-             "resized as a 128x128px image, with aspect ratio preserved. "\
+        help="Medium-sized image of the category. It is automatically "
+             "resized as a 128x128px image, with aspect ratio preserved. "
              "Use this field in form views or some kanban views.")
-    image_small = openerp.fields.Binary("Small-sized image",
+    image_small = fields.Binary(string="Small-sized image",
         compute='_compute_images', inverse='_inverse_image_small', store=True, attachment=True,
-        help="Small-sized image of the category. It is automatically "\
-             "resized as a 64x64px image, with aspect ratio preserved. "\
+        help="Small-sized image of the category. It is automatically "
+             "resized as a 64x64px image, with aspect ratio preserved. "
              "Use this field anywhere a small image is required.")
 
-    @openerp.api.depends('image')
+    @api.depends('image')
     def _compute_images(self):
         for rec in self:
             rec.image_medium = tools.image_resize_image_medium(rec.image)
@@ -64,3 +47,13 @@ class pos_category(osv.osv):
     def _inverse_image_small(self):
         for rec in self:
             rec.image = tools.image_resize_image_big(rec.image_small)
+
+    @api.multi
+    def name_get(self):
+        def get_names(cat):
+            res = []
+            while cat:
+                res.append(cat.name)
+                cat = cat.parent_id
+            return res
+        return [(cat.id, " / ".join(reversed(get_names(cat)))) for cat in self]

--- a/addons/point_of_sale/models/pos_config.py
+++ b/addons/point_of_sale/models/pos_config.py
@@ -1,13 +1,11 @@
 # -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
-
 import uuid
 
-from openerp import SUPERUSER_ID
-from openerp.osv import fields, osv
-from openerp.tools.translate import _
+from odoo import api, fields, models, _
+from odoo.exceptions import UserError
 
-class pos_config(osv.osv):
+class PosConfig(models.Model):
     _name = 'pos.config'
 
     POS_CONFIG_STATE = [
@@ -16,300 +14,229 @@ class pos_config(osv.osv):
         ('deprecated', 'Deprecated')
     ]
 
-    def _get_currency(self, cr, uid, ids, fieldnames, args, context=None):
-        result = dict.fromkeys(ids, False)
-        for pos_config in self.browse(cr, uid, ids, context=context):
+    def _default_sale_journal(self):
+        return self.env['account.journal'].search([('type', '=', 'sale'), ('company_id', '=', self.env.user.company_id.id)], limit=1)
+
+    def _default_pricelist(self):
+        return self.env['product.pricelist'].search([], limit=1)
+
+    def _get_default_location(self):
+        return self.env['stock.warehouse'].search([('company_id', '=', self.env.user.company_id.id)], limit=1).lot_stock_id
+
+    def _get_default_nomenclature(self):
+        return self.env['barcode.nomenclature'].search([], limit=1)
+
+    def _get_group_pos_manager(self):
+        return self.env.ref('point_of_sale.group_pos_manager')
+
+    def _get_group_pos_user(self):
+        return self.env.ref('point_of_sale.group_pos_user')
+
+    name = fields.Char(string='Point of Sale Name', index=True, required=True, help="An internal identification of the point of sale")
+    journal_ids = fields.Many2many(
+        'account.journal', 'pos_config_journal_rel',
+        'pos_config_id', 'journal_id', string='Available Payment Methods',
+        domain="[('journal_user', '=', True ), ('type', 'in', ['bank', 'cash'])]",)
+    picking_type_id = fields.Many2one('stock.picking.type', string='Picking Type')
+    stock_location_id = fields.Many2one(
+        'stock.location', string='Stock Location',
+        domain=[('usage', '=', 'internal')], required=True, default=_get_default_location)
+    journal_id = fields.Many2one(
+        'account.journal', string='Sale Journal',
+        domain=[('type', '=', 'sale')],
+        help="Accounting journal used to post sales entries.",
+        default=_default_sale_journal)
+    currency_id = fields.Many2one('res.currency', compute='_compute_currency', string="Currency")
+    iface_cashdrawer = fields.Boolean(string='Cashdrawer', help="Automatically open the cashdrawer")
+    iface_payment_terminal = fields.Boolean(string='Payment Terminal', help="Enables Payment Terminal integration")
+    iface_electronic_scale = fields.Boolean(string='Electronic Scale', help="Enables Electronic Scale integration")
+    iface_vkeyboard = fields.Boolean(string='Virtual KeyBoard', help="Enables an integrated Virtual Keyboard")
+    iface_print_via_proxy = fields.Boolean(string='Print via Proxy', help="Bypass browser printing and prints via the hardware proxy")
+    iface_scan_via_proxy = fields.Boolean(string='Scan via Proxy', help="Enable barcode scanning with a remotely connected barcode scanner")
+    iface_invoicing = fields.Boolean(string='Invoicing', help='Enables invoice generation from the Point of Sale', default=True)
+    iface_big_scrollbars = fields.Boolean('Large Scrollbars', help='For imprecise industrial touchscreens')
+    iface_print_auto = fields.Boolean(string='Automatic Receipt Printing', default=False,
+        help='The receipt will automatically be p-rinted at the end of each order')
+    iface_print_skip_screen = fields.Boolean(string='Skip Receipt Screen', default=True,
+        help='The receipt screen will be skipped if the receipt can be printed automatically.')
+    iface_precompute_cash = fields.Boolean(string='Prefill Cash Payment',
+        help='The payment input will behave similarily to bank payment input, and will be prefilled with the exact due amount')
+    iface_tax_included = fields.Boolean(string='Include Taxes in Prices',
+        help='The displayed prices will always include all taxes, even if the taxes have been setup differently')
+    iface_start_categ_id = fields.Many2one('pos.category', string='Start Category',
+        help='The point of sale will display this product category by default. If no category is specified, all available products will be shown')
+    iface_display_categ_images = fields.Boolean(string='Display Category Pictures',
+        help="The product categories will be displayed with pictures.")
+    cash_control = fields.Boolean(string='Cash Control', help="Check the amount of the cashbox at opening and closing.")
+    receipt_header = fields.Text(string='Receipt Header', help="A short text that will be inserted as a header in the printed receipt")
+    receipt_footer = fields.Text(string='Receipt Footer', help="A short text that will be inserted as a footer in the printed receipt")
+    proxy_ip = fields.Char(string='IP Address', size=45,
+        help='The hostname or ip address of the hardware proxy, Will be autodetected if left empty')
+    state = fields.Selection(POS_CONFIG_STATE, string='Status', required=True, readonly=True, copy=False, default=POS_CONFIG_STATE[0][0])
+    uuid = fields.Char(readonly=True, default=lambda self: str(uuid.uuid4()),
+        help='A globally unique identifier for this pos configuration, used to prevent conflicts in client-generated data')
+    sequence_id = fields.Many2one('ir.sequence', string='Order IDs Sequence', readonly=True,
+        help="This sequence is automatically created by Odoo but you can change it "
+        "to customize the reference numbers of your orders.", copy=False)
+    session_ids = fields.One2many('pos.session', 'config_id', string='Sessions')
+    current_session_id = fields.Many2one('pos.session', compute='_compute_current_session', string="Current Session")
+    current_session_state = fields.Char(compute='_compute_current_session')
+    last_session_closing_cash = fields.Float(compute='_compute_last_session')
+    last_session_closing_date = fields.Date(compute='_compute_last_session')
+    pos_session_username = fields.Char(compute='_compute_current_session_user')
+    group_by = fields.Boolean(string='Group Journal Items', default=True,
+        help="Check this if you want to group the Journal Items by Product while closing a Session")
+    pricelist_id = fields.Many2one('product.pricelist', string='Pricelist', required=True, default=_default_pricelist)
+    company_id = fields.Many2one('res.company', string='Company', required=True, default=lambda self: self.env.user.company_id)
+    barcode_nomenclature_id = fields.Many2one('barcode.nomenclature', string='Barcodes', required=True, default=_get_default_nomenclature,
+        help='Defines what kind of barcodes are available and how they are assigned to products, customers and cashiers')
+    group_pos_manager_id = fields.Many2one('res.groups', string='Point of Sale Manager Group', default=_get_group_pos_manager,
+        help='This field is there to pass the id of the pos manager group to the point of sale client')
+    group_pos_user_id = fields.Many2one('res.groups', string='Point of Sale User Group', default=_get_group_pos_user,
+        help='This field is there to pass the id of the pos user group to the point of sale client')
+    tip_product_id = fields.Many2one('product.product', string='Tip Product',
+        help="The product used to encode the customer tip. Leave empty if you do not accept tips.")
+    fiscal_position_ids = fields.Many2many('account.fiscal.position', string='Fiscal Positions')
+
+    @api.depends('journal_id.currency_id', 'journal_id.company_id.currency_id')
+    def _compute_currency(self):
+        for pos_config in self:
             if pos_config.journal_id:
-                currency_id = pos_config.journal_id.currency_id.id or pos_config.journal_id.company_id.currency_id.id
+                pos_config.currency_id = pos_config.journal_id.currency_id.id or pos_config.journal_id.company_id.currency_id.id
             else:
-                currency_id = self.pool['res.users'].browse(cr, uid, uid, context=context).company_id.currency_id.id
-            result[pos_config.id] = currency_id
-        return result
-
-    def _get_current_session(self, cr, uid, ids, fieldnames, args, context=None):
-        result = dict()
-
-        for record in self.browse(cr, uid, ids, context=context):
-            session_id = record.session_ids.filtered(lambda r: r.user_id.id == uid and not r.state == 'closed')
-            result[record.id] = {
-                'current_session_id': session_id,
-                'current_session_state': session_id.state,
-            }
-        return result
-
-    def _get_last_session(self, cr, uid, ids, fieldnames, args, context=None):
-        result = dict()
-
-        for record in self.browse(cr, uid, ids, context=context):
-            session_ids = self.pool['pos.session'].search_read(
-                cr, uid,
-                [('config_id', '=', record.id), ('state', '=', 'closed')],
+                pos_config.currency_id = self.env.user.company_id.currency_id.id
+
+    @api.depends('session_ids')
+    def _compute_current_session(self):
+        for pos_config in self:
+            session = pos_config.session_ids.filtered(lambda r: r.user_id.id == self.env.uid and not r.state == 'closed')
+            pos_config.current_session_id = session
+            pos_config.current_session_state = session.state
+
+    @api.depends('session_ids')
+    def _compute_last_session(self):
+        PosSession = self.env['pos.session']
+        for pos_config in self:
+            session = PosSession.search_read(
+                [('config_id', '=', pos_config.id), ('state', '=', 'closed')],
                 ['cash_register_balance_end_real', 'stop_at'],
-                order="stop_at desc", limit=1, context=context)
-            if session_ids:
-                result[record.id] = {
-                    'last_session_closing_cash': session_ids[0]['cash_register_balance_end_real'],
-                    'last_session_closing_date': session_ids[0]['stop_at'],
-                }
+                order="stop_at desc", limit=1)
+            if session:
+                pos_config.last_session_closing_cash = session[0]['cash_register_balance_end_real']
+                pos_config.last_session_closing_date = session[0]['stop_at']
             else:
-                result[record.id] = {
-                    'last_session_closing_cash': 0,
-                    'last_session_closing_date': None,
-                }
-        return result
-
-    def _get_current_session_user(self, cr, uid, ids, fieldnames, args, context=None):
-        result = dict()
-
-        for record in self.browse(cr, uid, ids, context=context):
-            result[record.id] = record.session_ids.filtered(lambda r: r.state == 'opened').user_id.name
-        return result
-
-    _columns = {
-        'name' : fields.char('Point of Sale Name', select=1,
-             required=True, help="An internal identification of the point of sale"),
-        'journal_ids' : fields.many2many('account.journal', 'pos_config_journal_rel', 
-             'pos_config_id', 'journal_id', 'Available Payment Methods',
-             domain="[('journal_user', '=', True ), ('type', 'in', ['bank', 'cash'])]",),
-        'picking_type_id': fields.many2one('stock.picking.type', 'Picking Type'),
-        'stock_location_id': fields.many2one('stock.location', 'Stock Location', domain=[('usage', '=', 'internal')], required=True),
-        'journal_id' : fields.many2one('account.journal', 'Sale Journal',
-             domain=[('type', '=', 'sale')],
-             help="Accounting journal used to post sales entries."),
-        'currency_id' : fields.function(_get_currency, type="many2one", string="Currency", relation="res.currency"),
-        'iface_cashdrawer' : fields.boolean('Cashdrawer', help="Automatically open the cashdrawer"),
-        'iface_payment_terminal' : fields.boolean('Payment Terminal', help="Enables Payment Terminal integration"),
-        'iface_electronic_scale' : fields.boolean('Electronic Scale', help="Enables Electronic Scale integration"),
-        'iface_vkeyboard' : fields.boolean('Virtual KeyBoard', help="Enables an integrated Virtual Keyboard"),
-        'iface_print_via_proxy' : fields.boolean('Print via Proxy', help="Bypass browser printing and prints via the hardware proxy"),
-        'iface_scan_via_proxy' : fields.boolean('Scan via Proxy', help="Enable barcode scanning with a remotely connected barcode scanner"),
-        'iface_invoicing': fields.boolean('Invoicing',help='Enables invoice generation from the Point of Sale'),
-        'iface_big_scrollbars': fields.boolean('Large Scrollbars',help='For imprecise industrial touchscreens'),
-
-        'iface_print_auto': fields.boolean('Automatic Receipt Printing', help='The receipt will automatically be printed at the end of each order'),
-        'iface_print_skip_screen': fields.boolean('Skip Receipt Screen', help='The receipt screen will be skipped if the receipt can be printed automatically.'),
-        'iface_precompute_cash': fields.boolean('Prefill Cash Payment',  help='The payment input will behave similarily to bank payment input, and will be prefilled with the exact due amount'),
-        'iface_tax_included':   fields.boolean('Include Taxes in Prices', help='The displayed prices will always include all taxes, even if the taxes have been setup differently'),
-        'iface_start_categ_id': fields.many2one('pos.category','Start Category', help='The point of sale will display this product category by default. If no category is specified, all available products will be shown'),
-        'iface_display_categ_images': fields.boolean('Display Category Pictures', help="The product categories will be displayed with pictures."),
-        'cash_control': fields.boolean('Cash Control', help="Check the amount of the cashbox at opening and closing."),
-        'receipt_header': fields.text('Receipt Header',help="A short text that will be inserted as a header in the printed receipt"),
-        'receipt_footer': fields.text('Receipt Footer',help="A short text that will be inserted as a footer in the printed receipt"),
-        'proxy_ip':       fields.char('IP Address', help='The hostname or ip address of the hardware proxy, Will be autodetected if left empty', size=45),
-
-        'state' : fields.selection(POS_CONFIG_STATE, 'Status', required=True, readonly=True, copy=False),
-        'uuid'  : fields.char('uuid', readonly=True, help='A globally unique identifier for this pos configuration, used to prevent conflicts in client-generated data'),
-        'sequence_id' : fields.many2one('ir.sequence', 'Order IDs Sequence', readonly=True,
-            help="This sequence is automatically created by Odoo but you can change it "\
-                "to customize the reference numbers of your orders.", copy=False),
-        'session_ids': fields.one2many('pos.session', 'config_id', 'Sessions'),
-        'current_session_id': fields.function(_get_current_session, multi="session", type="many2one", relation="pos.session", string="Current Session"),
-        'current_session_state': fields.function(_get_current_session, multi="session", type='char'),
-        'last_session_closing_cash': fields.function(_get_last_session, multi="last_session", type='float'),
-        'last_session_closing_date': fields.function(_get_last_session, multi="last_session", type='date'),
-        'pos_session_username': fields.function(_get_current_session_user, type='char'),
-        'group_by' : fields.boolean('Group Journal Items', help="Check this if you want to group the Journal Items by Product while closing a Session"),
-        'pricelist_id': fields.many2one('product.pricelist','Pricelist', required=True),
-        'company_id': fields.many2one('res.company', 'Company', required=True),
-        'barcode_nomenclature_id':  fields.many2one('barcode.nomenclature','Barcodes', help='Defines what kind of barcodes are available and how they are assigned to products, customers and cashiers', required=True),
-        'group_pos_manager_id': fields.many2one('res.groups','Point of Sale Manager Group', help='This field is there to pass the id of the pos manager group to the point of sale client'),
-        'group_pos_user_id':    fields.many2one('res.groups','Point of Sale User Group', help='This field is there to pass the id of the pos user group to the point of sale client'),
-        'tip_product_id':       fields.many2one('product.product','Tip Product', help="The product used to encode the customer tip. Leave empty if you do not accept tips."),
-        'fiscal_position_ids': fields.many2many('account.fiscal.position', string='Fiscal Positions')
-    }
-
-    def _check_company_location(self, cr, uid, ids, context=None):
-        for config in self.browse(cr, uid, ids, context=context):
-            if config.stock_location_id.company_id and config.stock_location_id.company_id.id != config.company_id.id:
-                return False
-        return True
-
-    def _check_company_journal(self, cr, uid, ids, context=None):
-        for config in self.browse(cr, uid, ids, context=context):
-            if config.journal_id and config.journal_id.company_id.id != config.company_id.id:
-                return False
-        return True
-
-    def _check_company_payment(self, cr, uid, ids, context=None):
-        for config in self.browse(cr, uid, ids, context=context):
-            journal_ids = [j.id for j in config.journal_ids]
-            if self.pool['account.journal'].search(cr, uid, [
-                    ('id', 'in', journal_ids),
-                    ('company_id', '!=', config.company_id.id)
-                ], count=True, context=context):
-                return False
-        return True
-
-    _constraints = [
-        (_check_company_location, "The company of the stock location is different than the one of point of sale", ['company_id', 'stock_location_id']),
-        (_check_company_journal, "The company of the sale journal is different than the one of point of sale", ['company_id', 'journal_id']),
-        (_check_company_payment, "The company of a payment method is different than the one of point of sale", ['company_id', 'journal_ids']),
-    ]
-
-    def name_get(self, cr, uid, ids, context=None):
+                pos_config.last_session_closing_cash = 0
+                pos_config.last_session_closing_date = False
+
+    @api.depends('session_ids')
+    def _compute_current_session_user(self):
+        for pos_config in self:
+            pos_config.pos_session_username = pos_config.session_ids.filtered(lambda s: s.state == 'opened').user_id.name
+
+    @api.constrains('company_id', 'stock_location_id')
+    def _check_company_location(self):
+        if self.stock_location_id.company_id and self.stock_location_id.company_id.id != self.company_id.id:
+            raise UserError(_("The company of the stock location is different than the one of point of sale"))
+
+    @api.constrains('company_id', 'journal_id')
+    def _check_company_journal(self):
+        if self.journal_id and self.journal_id.company_id.id != self.company_id.id:
+            raise UserError(_("The company of the sale journal is different than the one of point of sale"))
+
+    @api.constrains('company_id', 'journal_ids')
+    def _check_company_payment(self):
+        if self.env['account.journal'].search_count([('id', 'in', self.journal_ids.ids), ('company_id', '!=', self.company_id.id)]):
+            raise UserError(_("The company of a payment method is different than the one of point of sale"))
+
+    @api.onchange('iface_print_via_proxy')
+    def _onchange_iface_print_via_proxy(self):
+        self.iface_print_auto = self.iface_print_via_proxy
+
+    @api.onchange('picking_type_id')
+    def _onchange_picking_type_id(self):
+        if self.picking_type_id.default_location_src_id.usage == 'internal' and self.picking_type_id.default_location_dest_id.usage == 'customer':
+            self.stock_location_id = self.picking_type_id.default_location_src_id.id
+
+    @api.multi
+    def name_get(self):
         result = []
-        states = {
-            'opening_control': _('Opening Control'),
-            'opened': _('In Progress'),
-            'closing_control': _('Closing Control'),
-            'closed': _('Closed & Posted'),
-        }
-        for record in self.browse(cr, uid, ids, context=context):
-            if (not record.session_ids) or (record.session_ids[0].state=='closed'):
-                result.append((record.id, record.name+' ('+_('not used')+')'))
+        for config in self:
+            if (not config.session_ids) or (config.session_ids[0].state == 'closed'):
+                result.append((config.id, config.name + ' (' + _('not used') + ')'))
                 continue
-            session = record.session_ids[0]
-            result.append((record.id, record.name + ' ('+session.user_id.name+')')) #, '+states[session.state]+')'))
+            result.append((config.id, config.name + ' (' + config.session_ids[0].user_id.name + ')'))
         return result
 
-    def _default_sale_journal(self, cr, uid, context=None):
-        company_id = self.pool.get('res.users').browse(cr, uid, uid, context=context).company_id.id
-        res = self.pool.get('account.journal').search(cr, uid, [('type', '=', 'sale'), ('company_id', '=', company_id)], limit=1, context=context)
-        return res and res[0] or False
-
-    def _default_pricelist(self, cr, uid, context=None):
-        res = self.pool.get('product.pricelist').search(cr, uid, [], limit=1, context=context)
-        return res and res[0] or False
-
-    def _get_default_location(self, cr, uid, context=None):
-        wh_obj = self.pool.get('stock.warehouse')
-        user = self.pool.get('res.users').browse(cr, uid, uid, context)
-        res = wh_obj.search(cr, uid, [('company_id', '=', user.company_id.id)], limit=1, context=context)
-        if res and res[0]:
-            return wh_obj.browse(cr, uid, res[0], context=context).lot_stock_id.id
-        return False
-
-    def _get_default_company(self, cr, uid, context=None):
-        company_id = self.pool.get('res.users')._get_company(cr, uid, context=context)
-        return company_id
-
-    def _get_default_nomenclature(self, cr, uid, context=None):
-        nom_obj = self.pool.get('barcode.nomenclature')
-        res = nom_obj.search(cr, uid, [], limit=1, context=context)
-        return res and res[0] or False
-
-    def _get_group_pos_manager(self, cr, uid, context=None):
-        group = self.pool.get('ir.model.data').get_object_reference(cr,uid,'point_of_sale','group_pos_manager')
-        if group:
-            return group[1]
-        else:
-            return False
-
-    def _get_group_pos_user(self, cr, uid, context=None):
-        group = self.pool.get('ir.model.data').get_object_reference(cr,uid,'point_of_sale','group_pos_user')
-        if group:
-            return group[1]
-        else:
-            return False
-
-    _defaults = {
-        'uuid'  : lambda self, cr, uid, context={}: str(uuid.uuid4()),
-        'state' : POS_CONFIG_STATE[0][0],
-        'journal_id': _default_sale_journal,
-        'group_by' : True,
-        'pricelist_id': _default_pricelist,
-        'iface_invoicing': True,
-        'iface_print_auto': False,
-        'iface_print_skip_screen': True,
-        'stock_location_id': _get_default_location,
-        'company_id': _get_default_company,
-        'barcode_nomenclature_id': _get_default_nomenclature,
-        'group_pos_manager_id': _get_group_pos_manager,
-        'group_pos_user_id': _get_group_pos_user,
-    }
-
-    def onchange_picking_type_id(self, cr, uid, ids, picking_type_id, context=None):
-        p_type_obj = self.pool.get("stock.picking.type")
-        p_type = p_type_obj.browse(cr, uid, picking_type_id, context=context)
-        if p_type.default_location_src_id and p_type.default_location_src_id.usage == 'internal' and p_type.default_location_dest_id and p_type.default_location_dest_id.usage == 'customer':
-            return {'value': {'stock_location_id': p_type.default_location_src_id.id}}
-        return False
-
-    def onchange_iface_print_via_proxy(self, cr, uid, ids, print_via_proxy, context=None):
-        return {'value': {'iface_print_auto': print_via_proxy}}
-
-    def set_active(self, cr, uid, ids, context=None):
-        return self.write(cr, uid, ids, {'state' : 'active'}, context=context)
-
-    def set_inactive(self, cr, uid, ids, context=None):
-        return self.write(cr, uid, ids, {'state' : 'inactive'}, context=context)
-
-    def set_deprecate(self, cr, uid, ids, context=None):
-        return self.write(cr, uid, ids, {'state' : 'deprecated'}, context=context)
-
-    def create(self, cr, uid, values, context=None):
-        ir_sequence = self.pool.get('ir.sequence')
-        # force sequence_id field to new pos.order sequence
-        values['sequence_id'] = ir_sequence.create(cr, SUPERUSER_ID, {
-            'name': 'POS Order %s' % values['name'],
+    @api.model
+    def create(self, values):
+        IrSequence = self.env['ir.sequence']
+        val = {
+            'name': _('POS Order %s') % values['name'],
             'padding': 4,
-            'prefix': "%s/"  % values['name'],
+            'prefix': "%s/" % values['name'],
             'code': "pos.order",
             'company_id': values.get('company_id', False),
-        }, context=context)
+        }
+        # force sequence_id field to new pos.order sequence
+        values['sequence_id'] = IrSequence.create(val).id
 
         # TODO master: add field sequence_line_id on model
         # this make sure we always have one available per company
-        ir_sequence.create(cr, SUPERUSER_ID, {
-            'name': 'POS order line %s' % values['name'],
-            'padding': 4,
-            'prefix': "%s/"  % values['name'],
-            'code': "pos.order.line",
-            'company_id': values.get('company_id', False),
-        }, context=context)
+        val.update(name=_('POS order line %s') % values['name'], code='pos.order.line')
+        IrSequence.create(val)
+        return super(PosConfig, self).create(values)
 
-        return super(pos_config, self).create(cr, uid, values, context=context)
+    @api.multi
+    def unlink(self):
+        for pos_config in self.filtered(lambda pos_config: pos_config.sequence_id):
+            pos_config.sequence_id.unlink()
+        return super(PosConfig, self).unlink()
 
-    def unlink(self, cr, uid, ids, context=None):
-        for obj in self.browse(cr, uid, ids, context=context):
-            if obj.sequence_id:
-                obj.sequence_id.unlink()
-        return super(pos_config, self).unlink(cr, uid, ids, context=context)
+    @api.multi
+    def set_active(self):
+        self.write({'state': 'active'})
 
-    # Methods to open the POS
+    @api.multi
+    def set_inactive(self):
+        self.write({'state': 'inactive'})
 
-    def open_ui(self, cr, uid, ids, context=None):
-        assert len(ids) == 1, "you can open only one session at a time"
+    @api.multi
+    def set_deprecate(self):
+        self.write({'state': 'deprecated'})
 
-        record = self.browse(cr, uid, ids[0], context=context)
-        context = dict(context or {})
-        context['active_id'] = record.current_session_id.id
+    # Methods to open the POS
+    @api.multi
+    def open_ui(self):
+        assert len(self.ids) == 1, "you can open only one session at a time"
         return {
             'type': 'ir.actions.act_url',
             'url':   '/pos/web/',
             'target': 'self',
         }
 
-    def open_existing_session_cb_close(self, cr, uid, ids, context=None):
-        assert len(ids) == 1, "you can open only one session at a time"
-
-        record = self.browse(cr, uid, ids[0], context=context)
-        record.current_session_id.signal_workflow('cashbox_control')
-        return self.open_session_cb(cr, uid, ids, context)
-
-    def open_session_cb(self, cr, uid, ids, context=None):
-        assert len(ids) == 1, "you can open only one session at a time"
-
-        proxy = self.pool.get('pos.session')
-        record = self.browse(cr, uid, ids[0], context=context)
-        current_session_id = record.current_session_id
-        if not current_session_id:
-            values = {
-                'user_id': uid,
-                'config_id': record.id,
-            }
-            session_id = proxy.create(cr, uid, values, context=context)
-            self.write(cr, SUPERUSER_ID, record.id, {'current_session_id': session_id}, context=context)
-            if record.current_session_id.state == 'opened':
-                return self.open_ui(cr, uid, ids, context=context)
-            return self._open_session(session_id)
-        return self._open_session(current_session_id.id)
-
-    def open_existing_session_cb(self, cr, uid, ids, context=None):
-        assert len(ids) == 1, "you can open only one session at a time"
-
-        record = self.browse(cr, uid, ids[0], context=context)
-        return self._open_session(record.current_session_id.id)
+    @api.multi
+    def open_existing_session_cb_close(self):
+        assert len(self.ids) == 1, "you can open only one session at a time"
+        self.current_session_id.signal_workflow('cashbox_control')
+        return self.open_session_cb()
+
+    @api.multi
+    def open_session_cb(self):
+        assert len(self.ids) == 1, "you can open only one session at a time"
+        if not self.current_session_id:
+            self.current_session_id = self.env['pos.session'].create({
+                'user_id': self.env.uid,
+                'config_id': self.id
+            })
+            if self.current_session_id.state == 'opened':
+                return self.open_ui()
+            return self._open_session(self.current_session_id.id)
+        return self._open_session(self.current_session_id.id)
+
+    @api.multi
+    def open_existing_session_cb(self):
+        assert len(self.ids) == 1, "you can open only one session at a time"
+        return self._open_session(self.current_session_id.id)
 
     def _open_session(self, session_id):
         return {

--- a/addons/point_of_sale/models/pos_order.py
+++ b/addons/point_of_sale/models/pos_order.py
@@ -1,26 +1,18 @@
 # -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
-
 import logging
-
-import time
-from datetime import datetime
-
 from functools import partial
 
-import openerp
-import openerp.addons.decimal_precision as dp
-from openerp import tools, SUPERUSER_ID
-from openerp.osv import fields, osv
-from openerp.tools import float_is_zero
-from openerp.tools.translate import _
-from openerp.exceptions import UserError
+from odoo import api, fields, models, tools, _
+from odoo.tools import float_is_zero
+from odoo.exceptions import UserError
 
+import odoo.addons.decimal_precision as dp
 
 _logger = logging.getLogger(__name__)
 
 
-class pos_order(osv.osv):
+class PosOrder(models.Model):
     _name = "pos.order"
     _description = "Point of Sale"
     _order = "id desc"
@@ -30,32 +22,29 @@ class pos_order(osv.osv):
         if fiscal_position_id:
             taxes = fiscal_position_id.map_tax(taxes)
         price = line.price_unit * (1 - (line.discount or 0.0) / 100.0)
-        cur = line.order_id.pricelist_id.currency_id
-        taxes = taxes.compute_all(price, cur, line.qty, product=line.product_id, partner=line.order_id.partner_id or False)['taxes']
-        val = 0.0
-        for c in taxes:
-            val += c.get('amount', 0.0)
-        return val
-
-    def _order_fields(self, cr, uid, ui_order, context=None):
-        process_line = partial(self.pool['pos.order.line']._order_line_fields, cr, uid, context=context)
+        taxes = taxes.compute_all(price, line.order_id.pricelist_id.currency_id, line.qty, product=line.product_id, partner=line.order_id.partner_id or False)['taxes']
+        return sum(tax.get('amount', 0.0) for tax in taxes)
+
+    @api.model
+    def _order_fields(self, ui_order):
+        process_line = partial(self.env['pos.order.line']._order_line_fields)
         return {
             'name':         ui_order['name'],
             'user_id':      ui_order['user_id'] or False,
             'session_id':   ui_order['pos_session_id'],
             'lines':        [process_line(l) for l in ui_order['lines']] if ui_order['lines'] else False,
-            'pos_reference':ui_order['name'],
+            'pos_reference': ui_order['name'],
             'partner_id':   ui_order['partner_id'] or False,
             'date_order':   ui_order['creation_date'],
             'fiscal_position_id': ui_order['fiscal_position_id']
         }
 
-    def _payment_fields(self, cr, uid, ui_paymentline, context=None):
+    def _payment_fields(self, ui_paymentline):
         return {
             'amount':       ui_paymentline['amount'] or 0.0,
             'payment_date': ui_paymentline['name'],
             'statement_id': ui_paymentline['statement_id'],
-            'payment_name': ui_paymentline.get('note',False),
+            'payment_name': ui_paymentline.get('note', False),
             'journal':      ui_paymentline['journal_id'],
         }
 
@@ -63,570 +52,145 @@ class pos_order(osv.osv):
     # to recover from this we:
     # - assign the order to another compatible open session
     # - if that doesn't exist, create a new one
-    def _get_valid_session(self, cr, uid, order, context=None):
-        session = self.pool.get('pos.session')
-        closed_session = session.browse(cr, uid, order['pos_session_id'], context=context)
-        open_sessions = session.search(cr, uid, [('state', '=', 'opened'),
-                                                 ('config_id', '=', closed_session.config_id.id),
-                                                 ('user_id', '=', closed_session.user_id.id)],
-                                       limit=1, order="start_at DESC", context=context)
-
-        if open_sessions:
-            return open_sessions[0]
+    def _get_valid_session(self, order):
+        PosSession = self.env['pos.session']
+        closed_session = PosSession.browse(order['pos_session_id'])
+        open_session = PosSession.search(
+            [('state', '=', 'opened'),
+             ('config_id', '=', closed_session.config_id.id),
+             ('user_id', '=', closed_session.user_id.id)],
+            limit=1, order="start_at DESC")
+
+        if open_session:
+            return open_session
         else:
-            new_session_id = session.create(cr, uid, {
-                'config_id': closed_session.config_id.id,
-            }, context=context)
-            new_session = session.browse(cr, uid, new_session_id, context=context)
-
+            new_session = PosSession.create({'config_id': closed_session.config_id.id})
             # bypass opening_control (necessary when using cash control)
             new_session.signal_workflow('open')
-
-            return new_session_id
-
-    def _process_order(self, cr, uid, order, context=None):
-        session = self.pool.get('pos.session').browse(cr, uid, order['pos_session_id'], context=context)
-
-        if session.state == 'closing_control' or session.state == 'closed':
-            session_id = self._get_valid_session(cr, uid, order, context=context)
-            session = self.pool.get('pos.session').browse(cr, uid, session_id, context=context)
-            order['pos_session_id'] = session_id
-
-        order_id = self.create(cr, uid, self._order_fields(cr, uid, order, context=context),context)
+            return new_session
+
+    @api.model
+    def _process_order(self, pos_order):
+        pos_session = self.env['pos.session'].browse(pos_order['pos_session_id'])
+        if pos_session.state == 'closing_control' or pos_session.state == 'closed':
+            pos_order['pos_session_id'] = self._get_valid_session(pos_order).id
+        order = self.create(self._order_fields(pos_order))
         journal_ids = set()
-        for payments in order['statement_ids']:
-            self.add_payment(cr, uid, order_id, self._payment_fields(cr, uid, payments[2], context=context), context=context)
+        for payments in pos_order['statement_ids']:
+            order.add_payment(self._payment_fields(payments[2]))
             journal_ids.add(payments[2]['journal_id'])
 
-        if session.sequence_number <= order['sequence_number']:
-            session.write({'sequence_number': order['sequence_number'] + 1})
-            session.refresh()
+        if pos_session.sequence_number <= pos_order['sequence_number']:
+            pos_session.write({'sequence_number': pos_order['sequence_number'] + 1})
+            pos_session.refresh()
 
-        if not float_is_zero(order['amount_return'], self.pool.get('decimal.precision').precision_get(cr, uid, 'Account')):
-            cash_journal = session.cash_journal_id.id
-            if not cash_journal:
-                # Select for change one of the cash journals used in this payment
-                cash_journal_ids = self.pool['account.journal'].search(cr, uid, [
+        if not float_is_zero(pos_order['amount_return'], self.env['decimal.precision'].precision_get('Account')):
+            cash_journal_id = pos_session.cash_journal_id.id
+            if not cash_journal_id:
+                # Select for change one of the cash journals used in this
+                # payment
+                cash_journal = self.env['account.journal'].search([
                     ('type', '=', 'cash'),
                     ('id', 'in', list(journal_ids)),
-                ], limit=1, context=context)
-                if not cash_journal_ids:
+                ], limit=1)
+                if not cash_journal:
                     # If none, select for change one of the cash journals of the POS
                     # This is used for example when a customer pays by credit card
                     # an amount higher than total amount of the order and gets cash back
-                    cash_journal_ids = [statement.journal_id.id for statement in session.statement_ids
-                                        if statement.journal_id.type == 'cash']
-                    if not cash_journal_ids:
+                    cash_journal = [statement.journal_id for statement in pos_session.statement_ids if statement.journal_id.type == 'cash']
+                    if not cash_journal:
                         raise UserError(_("No cash statement found for this session. Unable to record returned cash."))
-                cash_journal = cash_journal_ids[0]
-            self.add_payment(cr, uid, order_id, {
-                'amount': -order['amount_return'],
-                'payment_date': time.strftime('%Y-%m-%d %H:%M:%S'),
+                cash_journal_id = cash_journal[0].id
+            order.add_payment({
+                'amount': -pos_order['amount_return'],
+                'payment_date': fields.Datetime.now(),
                 'payment_name': _('return'),
-                'journal': cash_journal,
-            }, context=context)
-        return order_id
-
-    def create_from_ui(self, cr, uid, orders, context=None):
-        # Keep only new orders
-        submitted_references = [o['data']['name'] for o in orders]
-        existing_order_ids = self.search(cr, uid, [('pos_reference', 'in', submitted_references)], context=context)
-        existing_orders = self.read(cr, uid, existing_order_ids, ['pos_reference'], context=context)
-        existing_references = set([o['pos_reference'] for o in existing_orders])
-        orders_to_save = [o for o in orders if o['data']['name'] not in existing_references]
-
-        order_ids = []
-
-        for tmp_order in orders_to_save:
-            to_invoice = tmp_order['to_invoice']
-            order = tmp_order['data']
-            order_id = self._process_order(cr, uid, order, context=context)
-            order_ids.append(order_id)
-
-            try:
-                self.signal_workflow(cr, uid, [order_id], 'paid')
-            except Exception as e:
-                _logger.error('Could not fully process the POS Order: %s', tools.ustr(e))
-
-            if to_invoice:
-                self.action_invoice(cr, uid, [order_id], context)
-                order_obj = self.browse(cr, uid, order_id, context)
-                self.pool['account.invoice'].signal_workflow(cr, SUPERUSER_ID, [order_obj.invoice_id.id], 'invoice_open')
-
-        return order_ids
-
-    def write(self, cr, uid, ids, vals, context=None):
-        res = super(pos_order, self).write(cr, uid, ids, vals, context=context)
-        #If you change the partner of the PoS order, change also the partner of the associated bank statement lines
-        partner_obj = self.pool.get('res.partner')
-        bsl_obj = self.pool.get("account.bank.statement.line")
-        if 'partner_id' in vals:
-            for posorder in self.browse(cr, uid, ids, context=context):
-                if posorder.invoice_id:
-                    raise UserError(_("You cannot change the partner of a POS order for which an invoice has already been issued."))
-                if vals['partner_id']:
-                    p_id = partner_obj.browse(cr, uid, vals['partner_id'], context=context)
-                    part_id = partner_obj._find_accounting_partner(p_id).id
-                else:
-                    part_id = False
-                bsl_ids = [x.id for x in posorder.statement_ids]
-                bsl_obj.write(cr, uid, bsl_ids, {'partner_id': part_id}, context=context)
-        return res
-
-    def unlink(self, cr, uid, ids, context=None):
-        for rec in self.browse(cr, uid, ids, context=context):
-            if rec.state not in ('draft','cancel'):
-                raise UserError(_('In order to delete a sale, it must be new or cancelled.'))
-        return super(pos_order, self).unlink(cr, uid, ids, context=context)
-
-    def onchange_partner_id(self, cr, uid, ids, part=False, context=None):
-        if not part:
-            return {'value': {}}
-        pricelist = self.pool.get('res.partner').browse(cr, uid, part, context=context).property_product_pricelist.id
-        return {'value': {'pricelist_id': pricelist}}
-
-    def _amount_all(self, cr, uid, ids, name, args, context=None):
-        cur_obj = self.pool.get('res.currency')
-        res = {}
-        for order in self.browse(cr, uid, ids, context=context):
-            res[order.id] = {
-                'amount_paid': 0.0,
-                'amount_return':0.0,
-                'amount_tax':0.0,
-            }
-            val1 = val2 = 0.0
-            cur = order.pricelist_id.currency_id
-            for payment in order.statement_ids:
-                res[order.id]['amount_paid'] +=  payment.amount
-                res[order.id]['amount_return'] += (payment.amount < 0 and payment.amount or 0)
-            for line in order.lines:
-                val1 += self._amount_line_tax(cr, uid, line, order.fiscal_position_id, context=context)
-                val2 += line.price_subtotal
-            res[order.id]['amount_tax'] = cur_obj.round(cr, uid, cur, val1)
-            amount_untaxed = cur_obj.round(cr, uid, cur, val2)
-            res[order.id]['amount_total'] = res[order.id]['amount_tax'] + amount_untaxed
-        return res
+                'journal': cash_journal_id,
+            })
+        return order
 
-    _columns = {
-        'name': fields.char('Order Ref', required=True, readonly=True, copy=False),
-        'company_id':fields.many2one('res.company', 'Company', required=True, readonly=True),
-        'date_order': fields.datetime('Order Date', readonly=True, select=True),
-        'user_id': fields.many2one('res.users', 'Salesman', help="Person who uses the cash register. It can be a reliever, a student or an interim employee."),
-        'amount_tax': fields.function(_amount_all, string='Taxes', digits=0, multi='all'),
-        'amount_total': fields.function(_amount_all, string='Total', digits=0,  multi='all'),
-        'amount_paid': fields.function(_amount_all, string='Paid', states={'draft': [('readonly', False)]}, readonly=True, digits=0, multi='all'),
-        'amount_return': fields.function(_amount_all, string='Returned', digits=0, multi='all'),
-        'lines': fields.one2many('pos.order.line', 'order_id', 'Order Lines', states={'draft': [('readonly', False)]}, readonly=True, copy=True),
-        'statement_ids': fields.one2many('account.bank.statement.line', 'pos_statement_id', 'Payments', states={'draft': [('readonly', False)]}, readonly=True),
-        'pricelist_id': fields.many2one('product.pricelist', 'Pricelist', required=True, states={'draft': [('readonly', False)]}, readonly=True),
-        'partner_id': fields.many2one('res.partner', 'Customer', change_default=True, select=1, states={'draft': [('readonly', False)], 'paid': [('readonly', False)]}),
-        'sequence_number': fields.integer('Sequence Number', help='A session-unique sequence number for the order'),
-
-        'session_id' : fields.many2one('pos.session', 'Session', 
-                                        required=True,
-                                        select=1,
-                                        domain="[('state', '=', 'opened')]",
-                                        states={'draft' : [('readonly', False)]},
-                                        readonly=True),
-        'config_id': fields.related('session_id', 'config_id', string="Point of Sale", type='many2one'  , relation='pos.config'),
-        'state': fields.selection([('draft', 'New'),
-                                   ('cancel', 'Cancelled'),
-                                   ('paid', 'Paid'),
-                                   ('done', 'Posted'),
-                                   ('invoiced', 'Invoiced')],
-                                  'Status', readonly=True, copy=False),
-
-        'invoice_id': fields.many2one('account.invoice', 'Invoice', copy=False),
-        'account_move': fields.many2one('account.move', 'Journal Entry', readonly=True, copy=False),
-        'picking_id': fields.many2one('stock.picking', 'Picking', readonly=True, copy=False),
-        'picking_type_id': fields.related('session_id', 'config_id', 'picking_type_id', string="Picking Type", type='many2one', relation='stock.picking.type'),
-        'location_id': fields.related('session_id', 'config_id', 'stock_location_id', string="Location", type='many2one', store=True, relation='stock.location'),
-        'note': fields.text('Internal Notes'),
-        'nb_print': fields.integer('Number of Print', readonly=True, copy=False),
-        'pos_reference': fields.char('Receipt Ref', readonly=True, copy=False),
-        'sale_journal': fields.related('session_id', 'config_id', 'journal_id', relation='account.journal', type='many2one', string='Sale Journal', store=True, readonly=True),
-        'fiscal_position_id': fields.many2one('account.fiscal.position', 'Fiscal Position')
-    }
-
-    def _default_session(self, cr, uid, context=None):
-        so = self.pool.get('pos.session')
-        session_ids = so.search(cr, uid, [('state','=', 'opened'), ('user_id','=',uid)], context=context)
-        return session_ids and session_ids[0] or False
-
-    def _default_pricelist(self, cr, uid, context=None):
-        session_ids = self._default_session(cr, uid, context) 
-        if session_ids:
-            session_record = self.pool.get('pos.session').browse(cr, uid, session_ids, context=context)
-            return session_record.config_id.pricelist_id and session_record.config_id.pricelist_id.id or False
+    def _prepare_analytic_account(self, line):
+        '''This method is designed to be inherited in a custom module'''
         return False
 
-    def _get_out_picking_type(self, cr, uid, context=None):
-        return self.pool.get('ir.model.data').xmlid_to_res_id(
-                    cr, uid, 'point_of_sale.picking_type_posout', context=context)
-
-    _defaults = {
-        'user_id': lambda self, cr, uid, context: uid,
-        'state': 'draft',
-        'name': '/', 
-        'date_order': lambda *a: time.strftime('%Y-%m-%d %H:%M:%S'),
-        'nb_print': 0,
-        'sequence_number': 1,
-        'session_id': _default_session,
-        'company_id': lambda self,cr,uid,c: self.pool.get('res.users').browse(cr, uid, uid, c).company_id.id,
-        'pricelist_id': _default_pricelist,
-    }
-
-    def create(self, cr, uid, values, context=None):
-        if values.get('session_id'):
-            # set name based on the sequence specified on the config
-            session = self.pool['pos.session'].browse(cr, uid, values['session_id'], context=context)
-            values['name'] = session.config_id.sequence_id._next()
-            values.setdefault('session_id', session.config_id.pricelist_id.id)
-        else:
-            # fallback on any pos.order sequence
-            values['name'] = self.pool.get('ir.sequence').next_by_code(cr, uid, 'pos.order', context=context)
-        return super(pos_order, self).create(cr, uid, values, context=context)
+    def _create_account_move(self, dt, ref, journal_id, company_id):
+        date_tz_user = fields.Datetime.context_timestamp(self, fields.Datetime.from_string(dt))
+        date_tz_user = fields.Date.to_string(date_tz_user)
+        return self.env['account.move'].sudo().create({'ref': ref, 'journal_id': journal_id, 'date': date_tz_user})
 
-    def test_paid(self, cr, uid, ids, context=None):
-        """A Point of Sale is paid when the sum
-        @return: True
+    def _prepare_invoice(self):
         """
-        for order in self.browse(cr, uid, ids, context=context):
-            if order.lines and not order.amount_total:
-                return True
-            if (not order.lines) or (not order.statement_ids) or \
-                (abs(order.amount_total-order.amount_paid) > 0.00001):
-                return False
-        return True
-
-    def create_picking(self, cr, uid, ids, context=None):
-        """Create a picking for each order and validate it."""
-        picking_obj = self.pool.get('stock.picking')
-        partner_obj = self.pool.get('res.partner')
-        move_obj = self.pool.get('stock.move')
-
-        for order in self.browse(cr, uid, ids, context=context):
-            if all(t == 'service' for t in order.lines.mapped('product_id.type')):
-                continue
-            addr = order.partner_id and partner_obj.address_get(cr, uid, [order.partner_id.id], ['delivery']) or {}
-            picking_type = order.picking_type_id
-            picking_id = False
-            location_id = order.location_id.id
-            if order.partner_id:
-                destination_id = order.partner_id.property_stock_customer.id
-            else:
-                if (not picking_type) or (not picking_type.default_location_dest_id):
-                    customerloc, supplierloc = self.pool['stock.warehouse']._get_partner_locations(cr, uid, [], context=context)
-                    destination_id = customerloc.id
-                else:
-                    destination_id = picking_type.default_location_dest_id.id
-
-            #All qties negative => Create negative
-            if picking_type:
-                pos_qty = all([x.qty >= 0 for x in order.lines])
-                #Check negative quantities
-                picking_id = picking_obj.create(cr, uid, {
-                    'origin': order.name,
-                    'partner_id': addr.get('delivery',False),
-                    'date_done' : order.date_order,
-                    'picking_type_id': picking_type.id,
-                    'company_id': order.company_id.id,
-                    'move_type': 'direct',
-                    'note': order.note or "",
-                    'location_id': location_id if pos_qty else destination_id,
-                    'location_dest_id': destination_id if pos_qty else location_id,
-                }, context=context)
-                self.write(cr, uid, [order.id], {'picking_id': picking_id}, context=context)
-
-            move_list = []
-            for line in order.lines:
-                if line.product_id and line.product_id.type not in ['product', 'consu']:
-                    continue
-
-                move_list.append(move_obj.create(cr, uid, {
-                    'name': line.name,
-                    'product_uom': line.product_id.uom_id.id,
-                    'picking_id': picking_id,
-                    'picking_type_id': picking_type.id, 
-                    'product_id': line.product_id.id,
-                    'product_uom_qty': abs(line.qty),
-                    'state': 'draft',
-                    'location_id': location_id if line.qty >= 0 else destination_id,
-                    'location_dest_id': destination_id if line.qty >= 0 else location_id,
-                }, context=context))
-                
-            if picking_id:
-                picking_obj.action_confirm(cr, uid, [picking_id], context=context)
-                picking_obj.force_assign(cr, uid, [picking_id], context=context)
-                # Mark pack operations as done
-                pick = picking_obj.browse(cr, uid, picking_id, context=context)
-                for pack in pick.pack_operation_ids:
-                    self.pool['stock.pack.operation'].write(cr, uid, [pack.id], {'qty_done': pack.product_qty}, context=context)
-                picking_obj.action_done(cr, uid, [picking_id], context=context)
-            elif move_list:
-                move_obj.action_confirm(cr, uid, move_list, context=context)
-                move_obj.force_assign(cr, uid, move_list, context=context)
-                move_obj.action_done(cr, uid, move_list, context=context)
-        return True
-
-    def cancel_order(self, cr, uid, ids, context=None):
-        """ Changes order state to cancel
-        @return: True
+        Prepare the dict of values to create the new invoice for a pos order.
         """
-        stock_picking_obj = self.pool.get('stock.picking')
-        for order in self.browse(cr, uid, ids, context=context):
-            stock_picking_obj.action_cancel(cr, uid, [order.picking_id.id])
-            if stock_picking_obj.browse(cr, uid, order.picking_id.id, context=context).state <> 'cancel':
-                raise UserError(_('Unable to cancel the picking.'))
-        self.write(cr, uid, ids, {'state': 'cancel'}, context=context)
-        return True
-
-    def add_payment(self, cr, uid, order_id, data, context=None):
-        """Create a new payment for the order"""
-        context = dict(context or {})
-        statement_line_obj = self.pool.get('account.bank.statement.line')
-        property_obj = self.pool.get('ir.property')
-        order = self.browse(cr, uid, order_id, context=context)
-        date = data.get('payment_date', time.strftime('%Y-%m-%d'))
-        if len(date) > 10:
-            timestamp = datetime.strptime(date, tools.DEFAULT_SERVER_DATETIME_FORMAT)
-            ts = fields.datetime.context_timestamp(cr, uid, timestamp, context)
-            date = ts.strftime(tools.DEFAULT_SERVER_DATE_FORMAT)
-        args = {
-            'amount': data['amount'],
-            'date': date,
-            'name': order.name + ': ' + (data.get('payment_name', '') or ''),
-            'partner_id': order.partner_id and self.pool.get("res.partner")._find_accounting_partner(order.partner_id).id or False,
-        }
-
-        journal_id = data.get('journal', False)
-        statement_id = data.get('statement_id', False)
-        assert journal_id or statement_id, "No statement_id or journal_id passed to the method!"
-
-        journal = self.pool['account.journal'].browse(cr, uid, journal_id, context=context)
-        # use the company of the journal and not of the current user
-        company_cxt = dict(context, force_company=journal.company_id.id)
-        account_def = property_obj.get(cr, uid, 'property_account_receivable_id', 'res.partner', context=company_cxt)
-        args['account_id'] = (order.partner_id and order.partner_id.property_account_receivable_id \
-                             and order.partner_id.property_account_receivable_id.id) or (account_def and account_def.id) or False
-
-        if not args['account_id']:
-            if not args['partner_id']:
-                msg = _('There is no receivable account defined to make payment.')
-            else:
-                msg = _('There is no receivable account defined to make payment for the partner: "%s" (id:%d).') % (order.partner_id.name, order.partner_id.id,)
-            raise UserError(msg)
-
-        context.pop('pos_session_id', False)
-
-        for statement in order.session_id.statement_ids:
-            if statement.id == statement_id:
-                journal_id = statement.journal_id.id
-                break
-            elif statement.journal_id.id == journal_id:
-                statement_id = statement.id
-                break
-
-        if not statement_id:
-            raise UserError(_('You have to open at least one cashbox.'))
-
-        args.update({
-            'statement_id': statement_id,
-            'pos_statement_id': order_id,
-            'journal_id': journal_id,
-            'ref': order.session_id.name,
-        })
-
-        statement_line_obj.create(cr, uid, args, context=context)
-
-        return statement_id
-
-    def refund(self, cr, uid, ids, context=None):
-        """Create a copy of order  for refund order"""
-        clone_list = []
-        line_obj = self.pool.get('pos.order.line')
-        
-        for order in self.browse(cr, uid, ids, context=context):
-            current_session_ids = self.pool.get('pos.session').search(cr, uid, [
-                ('state', '!=', 'closed'),
-                ('user_id', '=', uid)], context=context)
-            if not current_session_ids:
-                raise UserError(_('To return product(s), you need to open a session that will be used to register the refund.'))
-
-            clone_id = self.copy(cr, uid, order.id, {
-                'name': order.name + ' REFUND', # not used, name forced by create
-                'session_id': current_session_ids[0],
-                'date_order': time.strftime('%Y-%m-%d %H:%M:%S'),
-            }, context=context)
-            clone_list.append(clone_id)
-
-        for clone in self.browse(cr, uid, clone_list, context=context):
-            for order_line in clone.lines:
-                line_obj.write(cr, uid, [order_line.id], {
-                    'qty': -order_line.qty
-                }, context=context)
-
-        abs = {
-            'name': _('Return Products'),
-            'view_type': 'form',
-            'view_mode': 'form',
-            'res_model': 'pos.order',
-            'res_id':clone_list[0],
-            'view_id': False,
-            'context':context,
-            'type': 'ir.actions.act_window',
-            'target': 'current',
-        }
-        return abs
-
-    def action_invoice_state(self, cr, uid, ids, context=None):
-        return self.write(cr, uid, ids, {'state':'invoiced'}, context=context)
-
-    def action_invoice(self, cr, uid, ids, context=None):
-        inv_ref = self.pool.get('account.invoice')
-        inv_line_ref = self.pool.get('account.invoice.line')
-        product_obj = self.pool.get('product.product')
-        inv_ids = []
-
-        for order in self.pool.get('pos.order').browse(cr, uid, ids, context=context):
-            # Force company for all SUPERUSER_ID action
-            company_id = order.company_id.id
-            local_context = dict(context or {}, force_company=company_id, company_id=company_id)
-            if order.invoice_id:
-                inv_ids.append(order.invoice_id.id)
-                continue
-
-            if not order.partner_id:
-                raise UserError(_('Please provide a partner for the sale.'))
-
-            acc = order.partner_id.property_account_receivable_id.id
-            inv = {
-                'name': order.name,
-                'origin': order.name,
-                'account_id': acc,
-                'journal_id': order.sale_journal.id or None,
-                'type': 'out_invoice',
-                'reference': order.name,
-                'partner_id': order.partner_id.id,
-                'comment': order.note or '',
-                'currency_id': order.pricelist_id.currency_id.id, # considering partner's sale pricelist's currency
-                'company_id': company_id,
-                'user_id': uid,
-            }
-            invoice = inv_ref.new(cr, uid, inv)
-            invoice._onchange_partner_id()
-
-            inv = invoice._convert_to_write(invoice._cache)
-            if not inv.get('account_id', None):
-                inv['account_id'] = acc
-            inv_id = inv_ref.create(cr, SUPERUSER_ID, inv, context=local_context)
-
-            self.write(cr, uid, [order.id], {'invoice_id': inv_id, 'state': 'invoiced'}, context=local_context)
-            inv_ids.append(inv_id)
-            for line in order.lines:
-                inv_name = product_obj.name_get(cr, uid, [line.product_id.id], context=local_context)[0][1]
-                inv_line = {
-                    'invoice_id': inv_id,
-                    'product_id': line.product_id.id,
-                    'quantity': line.qty,
-                    'account_analytic_id': self._prepare_analytic_account(cr, uid, line, context=local_context),
-                    'name': inv_name,
-                }
-
-                #Oldlin trick
-                invoice_line = inv_line_ref.new(cr, SUPERUSER_ID, inv_line, context=local_context)
-                invoice_line._onchange_product_id()
-                invoice_line.invoice_line_tax_ids = [tax.id for tax in invoice_line.invoice_line_tax_ids if tax.company_id.id == company_id]
-                fiscal_position_id = line.order_id.fiscal_position_id
-                if fiscal_position_id:
-                    invoice_line.invoice_line_tax_ids = fiscal_position_id.map_tax(invoice_line.invoice_line_tax_ids)
-                invoice_line.invoice_line_tax_ids = [tax.id for tax in invoice_line.invoice_line_tax_ids]
-                # We convert a new id object back to a dictionary to write to bridge between old and new api
-                inv_line = invoice_line._convert_to_write(invoice_line._cache)
-                inv_line.update(price_unit=line.price_unit, discount=line.discount)
-                inv_line_ref.create(cr, SUPERUSER_ID, inv_line, context=local_context)
-            inv_ref.compute_taxes(cr, SUPERUSER_ID, [inv_id], context=local_context)
-            self.signal_workflow(cr, uid, [order.id], 'invoice')
-            inv_ref.signal_workflow(cr, SUPERUSER_ID, [inv_id], 'validate')
-
-        if not inv_ids: return {}
-
-        mod_obj = self.pool.get('ir.model.data')
-        res = mod_obj.get_object_reference(cr, uid, 'account', 'invoice_form')
-        res_id = res and res[1] or False
         return {
-            'name': _('Customer Invoice'),
-            'view_type': 'form',
-            'view_mode': 'form',
-            'view_id': [res_id],
-            'res_model': 'account.invoice',
-            'context': "{'type':'out_invoice'}",
-            'type': 'ir.actions.act_window',
-            'target': 'current',
-            'res_id': inv_ids and inv_ids[0] or False,
+            'name': self.name,
+            'origin': self.name,
+            'account_id': self.partner_id.property_account_receivable_id.id,
+            'journal_id': self.sale_journal.id,
+            'type': 'out_invoice',
+            'reference': self.name,
+            'partner_id': self.partner_id.id,
+            'comment': self.note or '',
+            # considering partner's sale pricelist's currency
+            'currency_id': self.pricelist_id.currency_id.id,
+            'user_id': self.env.uid,
         }
 
-    def _prepare_analytic_account(self, cr, uid, line, context=None):
-        '''This method is designed to be inherited in a custom module'''
-        return False
-
-    def _create_account_move(self, cr, uid, dt, ref, journal_id, company_id, context=None):
-        start_at_datetime = datetime.strptime(dt, tools.DEFAULT_SERVER_DATETIME_FORMAT)
-        date_tz_user = fields.datetime.context_timestamp(cr, uid, start_at_datetime, context=context)
-        date_tz_user = date_tz_user.strftime(tools.DEFAULT_SERVER_DATE_FORMAT)
-        return self.pool['account.move'].create(cr, SUPERUSER_ID, {'ref': ref, 'journal_id': journal_id, 'date': date_tz_user}, context=context)
-
-    def _create_account_move_line(self, cr, uid, ids, session=None, move_id=None, context=None):
+    def _action_create_invoice_line(self, line=False, invoice_id=False):
+        InvoiceLine = self.env['account.invoice.line']
+        inv_name = line.product_id.name_get()[0][1]
+        inv_line = {
+            'invoice_id': invoice_id,
+            'product_id': line.product_id.id,
+            'quantity': line.qty,
+            'account_analytic_id': self._prepare_analytic_account(line),
+            'name': inv_name,
+        }
+        # Oldlin trick
+        invoice_line = InvoiceLine.sudo().new(inv_line)
+        invoice_line._onchange_product_id()
+        invoice_line.invoice_line_tax_ids = invoice_line.invoice_line_tax_ids.filtered(lambda t: t.company_id.id == line.order_id.company_id.id).ids
+        fiscal_position_id = line.order_id.fiscal_position_id
+        if fiscal_position_id:
+            invoice_line.invoice_line_tax_ids = fiscal_position_id.map_tax(invoice_line.invoice_line_tax_ids)
+        invoice_line.invoice_line_tax_ids = invoice_line.invoice_line_tax_ids.ids
+        # We convert a new id object back to a dictionary to write to
+        # bridge between old and new api
+        inv_line = invoice_line._convert_to_write(invoice_line._cache)
+        inv_line.update(price_unit=line.price_unit, discount=line.discount)
+        return InvoiceLine.sudo().create(inv_line)
+
+    def _create_account_move_line(self, session=None, move=None):
         # Tricky, via the workflow, we only have one id in the ids variable
         """Create a account move line of order grouped by products or not."""
-        account_move_obj = self.pool.get('account.move')
-        account_tax_obj = self.pool.get('account.tax')
-        property_obj = self.pool.get('ir.property')
-        cur_obj = self.pool.get('res.currency')
-
-        #session_ids = set(order.session_id for order in self.browse(cr, uid, ids, context=context))
+        IrProperty = self.env['ir.property']
+        ResPartner = self.env['res.partner']
 
-        if session and not all(session.id == order.session_id.id for order in self.browse(cr, uid, ids, context=context)):
+        if session and not all(session.id == order.session_id.id for order in self):
             raise UserError(_('Selected orders do not have the same session!'))
 
         grouped_data = {}
         have_to_group_by = session and session.config_id.group_by or False
 
-        for order in self.browse(cr, uid, ids, context=context):
-            if order.account_move:
-                continue
-            if order.state != 'paid':
-                continue
-
+        for order in self.filtered(lambda o: not o.account_move or order.state == 'paid'):
             current_company = order.sale_journal.company_id
-
-            group_tax = {}
-            account_def = property_obj.get(cr, uid, 'property_account_receivable_id', 'res.partner', context=context)
-
-            order_account = order.partner_id and \
-                            order.partner_id.property_account_receivable_id and \
-                            order.partner_id.property_account_receivable_id.id or \
-                            account_def and account_def.id
-
-            if move_id is None:
+            account_def = IrProperty.get(
+                'property_account_receivable_id', 'res.partner')
+            order_account = order.partner_id.property_account_receivable_id.id or account_def and account_def.id
+            partner_id = ResPartner._find_accounting_partner(order.partner_id).id or False
+            if move is None:
                 # Create an entry for the sale
-                move_id = self._create_account_move(cr, uid, order.session_id.start_at, order.name, order.sale_journal.id, order.company_id.id, context=context)
-
-            move = account_move_obj.browse(cr, SUPERUSER_ID, move_id, context=context)
+                move = self._create_account_move(
+                    order.session_id.start_at, order.name, order.sale_journal.id, order.company_id.id)
 
             def insert_data(data_type, values):
                 # if have_to_group_by:
-
-                sale_journal_id = order.sale_journal.id
-
-                # 'quantity': line.qty,
-                # 'product_id': line.product_id.id,
                 values.update({
                     'ref': order.name,
-                    'partner_id': order.partner_id and self.pool.get("res.partner")._find_accounting_partner(order.partner_id).id or False,
-                    'journal_id' : sale_journal_id,
-                    'date' : fields.date.context_today(self, cr, uid, context=context),
-                    'move_id' : move_id,
+                    'partner_id': partner_id,
+                    'journal_id': order.sale_journal.id,
+                    'date': fields.Date.context_today(self),
+                    'move_id': move.id,
                     'company_id': current_company.id,
                 })
 
@@ -641,11 +205,6 @@ class pos_order(osv.osv):
 
                 grouped_data.setdefault(key, [])
 
-                # if not have_to_group_by or (not grouped_data[key]):
-                #     grouped_data[key].append(values)
-                # else:
-                #     pass
-
                 if have_to_group_by:
                     if not grouped_data[key]:
                         grouped_data[key].append(values)
@@ -653,35 +212,38 @@ class pos_order(osv.osv):
                         for line in grouped_data[key]:
                             if line.get('tax_code_id') == values.get('tax_code_id'):
                                 current_value = line
-                                current_value['quantity'] = current_value.get('quantity', 0.0) +  values.get('quantity', 0.0)
-                                current_value['credit'] = current_value.get('credit', 0.0) + values.get('credit', 0.0)
-                                current_value['debit'] = current_value.get('debit', 0.0) + values.get('debit', 0.0)
+                                current_value['quantity'] = current_value.get(
+                                    'quantity', 0.0) + values.get('quantity', 0.0)
+                                current_value['credit'] = current_value.get(
+                                    'credit', 0.0) + values.get('credit', 0.0)
+                                current_value['debit'] = current_value.get(
+                                    'debit', 0.0) + values.get('debit', 0.0)
                                 break
                         else:
                             grouped_data[key].append(values)
                 else:
                     grouped_data[key].append(values)
 
-            #because of the weird way the pos order is written, we need to make sure there is at least one line, 
-            #because just after the 'for' loop there are references to 'line' and 'income_account' variables (that 
-            #are set inside the for loop)
-            #TOFIX: a deep refactoring of this method (and class!) is needed in order to get rid of this stupid hack
+            # because of the weird way the pos order is written, we need to make sure there is at least one line,
+            # because just after the 'for' loop there are references to 'line' and 'income_account' variables (that
+            # are set inside the for loop)
+            # TOFIX: a deep refactoring of this method (and class!) is needed
+            # in order to get rid of this stupid hack
             assert order.lines, _('The POS order must have lines when calling this method')
             # Create an move for each order line
-
             cur = order.pricelist_id.currency_id
             for line in order.lines:
                 amount = line.price_subtotal
 
                 # Search for the income account
-                if  line.product_id.property_account_income_id.id:
+                if line.product_id.property_account_income_id.id:
                     income_account = line.product_id.property_account_income_id.id
                 elif line.product_id.categ_id.property_account_income_categ_id.id:
                     income_account = line.product_id.categ_id.property_account_income_categ_id.id
                 else:
-                    raise UserError(_('Please define income '\
-                        'account for this product: "%s" (id:%d).') \
-                        % (line.product_id.name, line.product_id.id))
+                    raise UserError(_('Please define income '
+                                      'account for this product: "%s" (id:%d).')
+                                    % (line.product_id.name, line.product_id.id))
 
                 name = line.product_id.name
                 if line.notice:
@@ -694,162 +256,441 @@ class pos_order(osv.osv):
                     'quantity': line.qty,
                     'product_id': line.product_id.id,
                     'account_id': income_account,
-                    'analytic_account_id': self._prepare_analytic_account(cr, uid, line, context=context),
-                    'credit': ((amount>0) and amount) or 0.0,
-                    'debit': ((amount<0) and -amount) or 0.0,
-                    'partner_id': order.partner_id and self.pool.get("res.partner")._find_accounting_partner(order.partner_id).id or False
+                    'analytic_account_id': self._prepare_analytic_account(line),
+                    'credit': ((amount > 0) and amount) or 0.0,
+                    'debit': ((amount < 0) and -amount) or 0.0,
+                    'partner_id': partner_id
                 })
 
                 # Create the tax lines
-                taxes = []
-                for t in line.tax_ids_after_fiscal_position:
-                    if t.company_id.id == current_company.id:
-                        taxes.append(t.id)
+                taxes = line.tax_ids_after_fiscal_position.filtered(lambda t: t.company_id.id == current_company.id)
                 if not taxes:
                     continue
-                for tax in account_tax_obj.browse(cr,uid, taxes, context=context).compute_all(line.price_unit * (100.0-line.discount) / 100.0, cur, line.qty)['taxes']:
+                for tax in taxes.compute_all(line.price_unit * (100.0 - line.discount) / 100.0, cur, line.qty)['taxes']:
                     insert_data('tax', {
                         'name': _('Tax') + ' ' + tax['name'],
                         'product_id': line.product_id.id,
                         'quantity': line.qty,
                         'account_id': tax['account_id'] or income_account,
-                        'credit': ((tax['amount']>0) and tax['amount']) or 0.0,
-                        'debit': ((tax['amount']<0) and -tax['amount']) or 0.0,
+                        'credit': ((tax['amount'] > 0) and tax['amount']) or 0.0,
+                        'debit': ((tax['amount'] < 0) and -tax['amount']) or 0.0,
                         'tax_line_id': tax['id'],
-                        'partner_id': order.partner_id and self.pool.get("res.partner")._find_accounting_partner(order.partner_id).id or False
+                        'partner_id': partner_id
                     })
 
             # counterpart
             insert_data('counter_part', {
-                'name': _("Trade Receivables"), #order.name,
+                'name': _("Trade Receivables"),  # order.name,
                 'account_id': order_account,
                 'credit': ((order.amount_total < 0) and -order.amount_total) or 0.0,
                 'debit': ((order.amount_total > 0) and order.amount_total) or 0.0,
-                'partner_id': order.partner_id and self.pool.get("res.partner")._find_accounting_partner(order.partner_id).id or False
+                'partner_id': partner_id
             })
 
-            order.write({'state':'done', 'account_move': move_id})
+            order.write({'state': 'done', 'account_move': move.id})
 
         all_lines = []
         for group_key, group_data in grouped_data.iteritems():
             for value in group_data:
                 all_lines.append((0, 0, value),)
-        if move_id: #In case no order was changed
-            self.pool.get("account.move").write(cr, SUPERUSER_ID, [move_id], {'line_ids':all_lines}, context=context)
-            self.pool.get("account.move").post(cr, SUPERUSER_ID, [move_id], context=context)
-
+        if move:  # In case no order was changed
+            move.sudo().write({'line_ids': all_lines})
+            move.sudo().post()
         return True
 
-    def action_payment(self, cr, uid, ids, context=None):
-        return self.write(cr, uid, ids, {'state': 'payment'}, context=context)
+    def _default_session(self):
+        return self.env['pos.session'].search([('state', '=', 'opened'), ('user_id', '=', self.env.uid)], limit=1)
+
+    def _default_pricelist(self):
+        return self._default_session().config_id.pricelist_id
+
+    name = fields.Char(string='Order Ref', required=True, readonly=True, copy=False, default='/')
+    company_id = fields.Many2one('res.company', string='Company', required=True, readonly=True, default=lambda self: self.env.user.company_id)
+    date_order = fields.Datetime(string='Order Date', readonly=True, index=True, default=fields.Datetime.now)
+    user_id = fields.Many2one('res.users', string='Salesman', help="Person who uses the cash register. It can be a reliever, a student or an interim employee.", default=lambda self: self.env.uid)
+    amount_tax = fields.Float(compute='_compute_amount_all', string='Taxes', digits=0)
+    amount_total = fields.Float(compute='_compute_amount_all', string='Total', digits=0)
+    amount_paid = fields.Float(compute='_compute_amount_all', string='Paid', states={'draft': [('readonly', False)]}, readonly=True, digits=0)
+    amount_return = fields.Float(compute='_compute_amount_all', string='Returned', digits=0)
+    lines = fields.One2many('pos.order.line', 'order_id', string='Order Lines', states={'draft': [('readonly', False)]}, readonly=True, copy=True)
+    statement_ids = fields.One2many('account.bank.statement.line', 'pos_statement_id', string='Payments', states={'draft': [('readonly', False)]}, readonly=True)
+    pricelist_id = fields.Many2one('product.pricelist', string='Pricelist', required=True, states={
+                                   'draft': [('readonly', False)]}, readonly=True, default=_default_pricelist)
+    partner_id = fields.Many2one('res.partner', string='Customer', change_default=True, index=True, states={'draft': [('readonly', False)], 'paid': [('readonly', False)]})
+    sequence_number = fields.Integer(string='Sequence Number', help='A session-unique sequence number for the order', default=1)
+
+    session_id = fields.Many2one(
+        'pos.session', string='Session', required=True, index=True,
+        domain="[('state', '=', 'opened')]", states={'draft': [('readonly', False)]},
+        readonly=True, default=_default_session)
+    config_id = fields.Many2one('pos.config', related='session_id.config_id', string="Point of Sale")
+    state = fields.Selection(
+        [('draft', 'New'), ('cancel', 'Cancelled'), ('paid', 'Paid'), ('done', 'Posted'), ('invoiced', 'Invoiced')],
+        'Status', readonly=True, copy=False, default='draft')
+
+    invoice_id = fields.Many2one('account.invoice', string='Invoice', copy=False)
+    account_move = fields.Many2one('account.move', string='Journal Entry', readonly=True, copy=False)
+    picking_id = fields.Many2one('stock.picking', string='Picking', readonly=True, copy=False)
+    picking_type_id = fields.Many2one('stock.picking.type', related='session_id.config_id.picking_type_id', string="Picking Type")
+    location_id = fields.Many2one('stock.location', related='session_id.config_id.stock_location_id', string="Location", store=True)
+    note = fields.Text(string='Internal Notes')
+    nb_print = fields.Integer(string='Number of Print', readonly=True, copy=False, default=0)
+    pos_reference = fields.Char(string='Receipt Ref', readonly=True, copy=False)
+    sale_journal = fields.Many2one('account.journal', related='session_id.config_id.journal_id', string='Sale Journal', store=True, readonly=True)
+    fiscal_position_id = fields.Many2one('account.fiscal.position', string='Fiscal Position')
+
+    @api.depends('statement_ids', 'lines.price_subtotal_incl', 'lines.discount')
+    def _compute_amount_all(self):
+        for order in self:
+            order.amount_paid = order.amount_return = order.amount_tax = 0.0
+            currency = order.pricelist_id.currency_id
+            order.amount_paid = sum(payment.amount for payment in order.statement_ids)
+            order.amount_return = sum(payment.amount < 0 and payment.amount or 0 for payment in order.statement_ids)
+            order.amount_tax = currency.round(sum(self._amount_line_tax(line, order.fiscal_position_id) for line in order.lines))
+            amount_untaxed = currency.round(sum(line.price_subtotal for line in order.lines))
+            order.amount_total = order.amount_tax + amount_untaxed
+
+    @api.onchange('partner_id')
+    def _onchange_partner_id(self):
+        if self.partner_id:
+            self.pricelist = self.partner_id.property_product_pricelist.id
+
+    @api.multi
+    def write(self, vals):
+        res = super(PosOrder, self).write(vals)
+        Partner = self.env['res.partner']
+        # If you change the partner of the PoS order, change also the partner of the associated bank statement lines
+        if 'partner_id' in vals:
+            for order in self:
+                partner_id = False
+                if order.invoice_id:
+                    raise UserError(_("You cannot change the partner of a POS order for which an invoice has already been issued."))
+                if vals['partner_id']:
+                    partner = Partner.browse(vals['partner_id'])
+                    partner_id = Partner._find_accounting_partner(partner).id
+                order.statement_ids.write({'partner_id': partner_id})
+        return res
+
+    @api.multi
+    def unlink(self):
+        for pos_order in self.filtered(lambda pos_order: pos_order.state not in ['draft', 'cancel']):
+            raise UserError(_('In order to delete a sale, it must be new or cancelled.'))
+        return super(PosOrder, self).unlink()
 
-    def action_paid(self, cr, uid, ids, context=None):
-        self.write(cr, uid, ids, {'state': 'paid'}, context=context)
-        self.create_picking(cr, uid, ids, context=context)
-        return True
+    @api.model
+    def create(self, values):
+        if values.get('session_id'):
+            # set name based on the sequence specified on the config
+            session = self.env['pos.session'].browse(values['session_id'])
+            values['name'] = session.config_id.sequence_id._next()
+            values.setdefault('session_id', session.config_id.pricelist_id.id)
+        else:
+            # fallback on any pos.order sequence
+            values['name'] = self.env['ir.sequence'].next_by_code('pos.order')
+        return super(PosOrder, self).create(values)
+
+    @api.multi
+    def action_invoice_state(self):
+        self.write({'state': 'invoiced'})
+
+    @api.multi
+    def action_invoice(self):
+        Invoice = self.env['account.invoice']
+
+        for order in self:
+            # Force company for all SUPERUSER_ID action
+            local_context = dict(self.env.context, force_company=order.company_id.id, company_id=order.company_id.id)
+            if order.invoice_id:
+                Invoice += order.invoice_id
+                continue
+
+            if not order.partner_id:
+                raise UserError(_('Please provide a partner for the sale.'))
+
+            invoice = Invoice.new(order._prepare_invoice())
+            invoice._onchange_partner_id()
+
+            inv = invoice._convert_to_write(invoice._cache)
+            new_invoice = Invoice.with_context(local_context).sudo().create(inv)
+            order.write({'invoice_id': new_invoice.id, 'state': 'invoiced'})
+            Invoice += new_invoice
 
-    def action_cancel(self, cr, uid, ids, context=None):
-        self.write(cr, uid, ids, {'state': 'cancel'}, context=context)
+            for line in order.lines:
+                self.with_context(local_context)._action_create_invoice_line(line, new_invoice.id)
+
+            new_invoice.with_context(local_context).sudo().compute_taxes()
+            order.sudo().signal_workflow('invoice')
+            new_invoice.sudo().signal_workflow('validate')
+
+        if not Invoice:
+            return {}
+
+        return {
+            'name': _('Customer Invoice'),
+            'view_type': 'form',
+            'view_mode': 'form',
+            'view_id': self.env.ref('account.invoice_form').id,
+            'res_model': 'account.invoice',
+            'context': "{'type':'out_invoice'}",
+            'type': 'ir.actions.act_window',
+            'nodestroy': True,
+            'target': 'current',
+            'res_id': Invoice and Invoice.ids[0] or False,
+        }
+
+    @api.multi
+    def action_paid(self):
+        self.write({'state': 'paid'})
+        self.create_picking()
+
+    @api.multi
+    def action_cancel(self):
+        self.write({'state': 'cancel'})
+
+    @api.multi
+    def action_done(self):
+        self._create_account_move_line()
+
+    @api.model
+    def create_from_ui(self, orders):
+        # Keep only new orders
+        submitted_references = [o['data']['name'] for o in orders]
+        pos_order = self.search([('pos_reference', 'in', submitted_references)])
+        existing_orders = pos_order.read(['pos_reference'])
+        existing_references = set([o['pos_reference'] for o in existing_orders])
+        orders_to_save = [o for o in orders if o['data']['name'] not in existing_references]
+        order_ids = []
+
+        for tmp_order in orders_to_save:
+            to_invoice = tmp_order['to_invoice']
+            pos_order = self._process_order(tmp_order['data'])
+            order_ids.append(pos_order.id)
+
+            try:
+                pos_order.signal_workflow('paid')
+            except Exception as e:
+                _logger.error('Could not fully process the POS Order: %s', tools.ustr(e))
+
+            if to_invoice:
+                pos_order.action_invoice()
+                pos_order.invoice_id.sudo().signal_workflow('invoice_open')
+        return order_ids
+
+    def test_paid(self):
+        """A Point of Sale is paid when the sum
+        @return: True
+        """
+        for order in self:
+            if order.lines and not order.amount_total:
+                return True
+            if (not order.lines) or (not order.statement_ids) or (abs(order.amount_total - order.amount_paid) > 0.00001):
+                return False
         return True
 
-    def action_done(self, cr, uid, ids, context=None):
-        self._create_account_move_line(cr, uid, ids, context=context)
+    def create_picking(self):
+        """Create a picking for each order and validate it."""
+        Picking = self.env['stock.picking']
+        Move = self.env['stock.move']
+        StockWarehouse = self.env['stock.warehouse']
+        for order in self:
+            address = order.partner_id.address_get(['delivery']) or {}
+            picking_type = order.picking_type_id
+            picking_id = False
+            location_id = order.location_id.id
+            if order.partner_id:
+                destination_id = order.partner_id.property_stock_customer.id
+            else:
+                if (not picking_type) or (not picking_type.default_location_dest_id):
+                    customerloc, supplierloc = StockWarehouse._get_partner_locations([])
+                    destination_id = customerloc.id
+                else:
+                    destination_id = picking_type.default_location_dest_id.id
+            if picking_type:
+                pos_qty = all([x.qty >= 0 for x in order.lines])
+                picking_id = Picking.create({
+                    'origin': order.name,
+                    'partner_id': address.get('delivery', False),
+                    'date_done': order.date_order,
+                    'picking_type_id': picking_type.id,
+                    'company_id': order.company_id.id,
+                    'move_type': 'direct',
+                    'note': order.note or "",
+                    'location_id': location_id if pos_qty else destination_id,
+                    'location_dest_id': destination_id if pos_qty else location_id,
+                })
+                order.write({'picking_id': picking_id.id})
+
+            for line in order.lines.filtered(lambda l: l.product_id.type in ['product', 'consu']):
+                Move += Move.create({
+                    'name': line.name,
+                    'product_uom': line.product_id.uom_id.id,
+                    'picking_id': picking_id.id,
+                    'picking_type_id': picking_type.id,
+                    'product_id': line.product_id.id,
+                    'product_uom_qty': abs(line.qty),
+                    'state': 'draft',
+                    'location_id': location_id if line.qty >= 0 else destination_id,
+                    'location_dest_id': destination_id if line.qty >= 0 else location_id,
+                })
+            if picking_id:
+                picking_id.action_confirm()
+                picking_id.force_assign()
+                # Mark pack operations as done
+                for pack in picking_id.pack_operation_ids:
+                    pack.write({'qty_done': pack.product_qty})
+                picking_id.action_done()
+            elif Move:
+                Move.action_confirm()
+                Move.force_assign()
+                Move.action_done()
         return True
 
-class pos_order_line(osv.osv):
+    def add_payment(self, data):
+        """Create a new payment for the order"""
+        args = {
+            'amount': data['amount'],
+            'date': data.get('payment_date', fields.Date.today()),
+            'name': self.name + ': ' + (data.get('payment_name', '') or ''),
+            'partner_id': self.env["res.partner"]._find_accounting_partner(self.partner_id).id or False,
+        }
+
+        journal_id = data.get('journal', False)
+        statement_id = data.get('statement_id', False)
+        assert journal_id or statement_id, "No statement_id or journal_id passed to the method!"
+
+        journal = self.env['account.journal'].browse(journal_id)
+        # use the company of the journal and not of the current user
+        company_cxt = dict(self.env.context, force_company=journal.company_id.id)
+        account_def = self.env['ir.property'].with_context(company_cxt).get('property_account_receivable_id', 'res.partner')
+        args['account_id'] = (self.partner_id.property_account_receivable_id.id) or (account_def and account_def.id) or False
+
+        if not args['account_id']:
+            if not args['partner_id']:
+                msg = _('There is no receivable account defined to make payment.')
+            else:
+                msg = _('There is no receivable account defined to make payment for the partner: "%s" (id:%d).') % (
+                    self.partner_id.name, self.partner_id.id,)
+            raise UserError(msg)
+
+        context = dict(self.env.context)
+        context.pop('pos_session_id', False)
+        for statement in self.session_id.statement_ids:
+            if statement.id == statement_id:
+                journal_id = statement.journal_id.id
+                break
+            elif statement.journal_id.id == journal_id:
+                statement_id = statement.id
+                break
+        if not statement_id:
+            raise UserError(_('You have to open at least one cashbox.'))
+
+        args.update({
+            'statement_id': statement_id,
+            'pos_statement_id': self.id,
+            'journal_id': journal_id,
+            'ref': self.session_id.name,
+        })
+        self.env['account.bank.statement.line'].with_context(context).create(args)
+        return statement_id
+
+    @api.multi
+    def refund(self):
+        """Create a copy of order  for refund order"""
+        PosOrder = self.env['pos.order']
+        current_session = self.env['pos.session'].search([('state', '!=', 'closed'), ('user_id', '=', self.env.uid)], limit=1)
+        if not current_session:
+            raise UserError(_('To return product(s), you need to open a session that will be used to register the refund.'))
+        for order in self:
+            clone = order.copy({
+                # ot used, name forced by create
+                'name': order.name + _(' REFUND'),
+                'session_id': current_session.id,
+                'date_order': fields.Datetime.now(),
+            })
+            PosOrder += clone
+
+        for clone in PosOrder:
+            for order_line in clone.lines:
+                order_line.write({'qty': -order_line.qty})
+        return {
+            'name': _('Return Products'),
+            'view_type': 'form',
+            'view_mode': 'form',
+            'res_model': 'pos.order',
+            'res_id': PosOrder.ids[0],
+            'view_id': False,
+            'context': self.env.context,
+            'type': 'ir.actions.act_window',
+            'target': 'current',
+        }
+
+
+class PosOrderLine(models.Model):
     _name = "pos.order.line"
     _description = "Lines of Point of Sale"
     _rec_name = "product_id"
 
-    def _order_line_fields(self, cr, uid, line, context=None):
+    def _order_line_fields(self, line):
         if line and 'tax_ids' not in line[2]:
-            product = self.pool['product.product'].browse(cr, uid, line[2]['product_id'], context=context)
+            product = self.env['product.product'].browse(line[2]['product_id'])
             line[2]['tax_ids'] = [(6, 0, [x.id for x in product.taxes_id])]
         return line
 
-    def _amount_line_all(self, cr, uid, ids, field_names, arg, context=None):
-        res = dict([(i, {}) for i in ids])
-        account_tax_obj = self.pool.get('account.tax')
-        for line in self.browse(cr, uid, ids, context=context):
-            cur = line.order_id.pricelist_id.currency_id
-            taxes = [ tax for tax in line.tax_ids if tax.company_id.id == line.order_id.company_id.id ]
+    company_id = fields.Many2one('res.company', string='Company', required=True, default=lambda self: self.env.user.company_id)
+    name = fields.Char(string='Line No', required=True, copy=False, default=lambda self: self.env['ir.sequence'].next_by_code('pos.order.line'))
+    notice = fields.Char(string='Discount Notice')
+    product_id = fields.Many2one('product.product', string='Product', domain=[('sale_ok', '=', True)], required=True, change_default=True)
+    price_unit = fields.Float(string='Unit Price', digits=0)
+    qty = fields.Float('Quantity', digits_compute=dp.get_precision('Product Unit of Measure'), default=1)
+    price_subtotal = fields.Float(compute='_compute_amount_line_all', digits=0, string='Subtotal w/o Tax')
+    price_subtotal_incl = fields.Float(compute='_compute_amount_line_all', digits=0, string='Subtotal')
+    discount = fields.Float(string='Discount (%)', digits=0, default=0.0)
+    order_id = fields.Many2one('pos.order', string='Order Ref', ondelete='cascade')
+    create_date = fields.Datetime(string='Creation Date', readonly=True)
+    tax_ids = fields.Many2many('account.tax', string='Taxes', readonly=True)
+    tax_ids_after_fiscal_position = fields.Many2many('account.tax', compute='_get_tax_ids_after_fiscal_position', string='Taxes')
+
+    @api.depends('price_unit', 'tax_ids', 'qty', 'discount', 'product_id')
+    def _compute_amount_line_all(self):
+        for line in self:
+            currency = line.order_id.pricelist_id.currency_id
+            taxes = line.tax_ids.filtered(lambda tax: tax.company_id.id == line.order_id.company_id.id)
             fiscal_position_id = line.order_id.fiscal_position_id
             if fiscal_position_id:
                 taxes = fiscal_position_id.map_tax(taxes)
-            taxes_ids = [ tax.id for tax in taxes ]
             price = line.price_unit * (1 - (line.discount or 0.0) / 100.0)
-            res[line.id]['price_subtotal'] = res[line.id]['price_subtotal_incl'] = price * line.qty
-            if taxes_ids:
-                taxes = account_tax_obj.browse(cr, uid, taxes_ids, context).compute_all(price, cur, line.qty, product=line.product_id, partner=line.order_id.partner_id or False)
-                res[line.id]['price_subtotal'] = taxes['total_excluded']
-                res[line.id]['price_subtotal_incl'] = taxes['total_included']
-        return res
-
-    def onchange_product_id(self, cr, uid, ids, pricelist, product_id, qty=0, partner_id=False, context=None):
-        context = context or {}
-        if not product_id:
-           return {}
-        if not pricelist:
-           raise UserError(
-               _('You have to select a pricelist in the sale form !\n' \
-               'Please set one before choosing a product.'))
-
-        price = self.pool.get('product.pricelist').price_get(cr, uid, [pricelist],
-               product_id, qty or 1.0, partner_id)[pricelist]
-
-        result = self.onchange_qty(cr, uid, ids, pricelist, product_id, 0.0, qty, price, context=context)
-        result['value']['price_unit'] = price
-
-        prod = self.pool.get('product.product').browse(cr, uid, product_id, context=context)
-        result['value']['tax_ids'] = prod.taxes_id.ids
-
-        return result
-
-    def onchange_qty(self, cr, uid, ids, pricelist, product, discount, qty, price_unit, context=None):
-        result = {}
-        if not product:
-            return result
-        if not pricelist:
-           raise UserError(_('You have to select a pricelist in the sale form !'))
-
-        account_tax_obj = self.pool.get('account.tax')
-
-        prod = self.pool.get('product.product').browse(cr, uid, product, context=context)
-
-        price = price_unit * (1 - (discount or 0.0) / 100.0)
-        result['price_subtotal'] = result['price_subtotal_incl'] = price * qty
-        cur = self.pool.get('product.pricelist').browse(cr, uid, [pricelist], context=context).currency_id
-        if (prod.taxes_id):
-            taxes = prod.taxes_id.compute_all(price, cur, qty, product=prod, partner=False)
-            result['price_subtotal'] = taxes['total_excluded']
-            result['price_subtotal_incl'] = taxes['total_included']
-        return {'value': result}
-
-    def _get_tax_ids_after_fiscal_position(self, cr, uid, ids, field_name, args, context=None):
-        res = dict.fromkeys(ids, False)
-        for line in self.browse(cr, uid, ids, context=context):
-            res[line.id] = line.order_id.fiscal_position_id.map_tax(line.tax_ids)
-        return res
-
-    _columns = {
-        'company_id': fields.many2one('res.company', 'Company', required=True),
-        'name': fields.char('Line No', required=True, copy=False),
-        'notice': fields.char('Discount Notice'),
-        'product_id': fields.many2one('product.product', 'Product', domain=[('sale_ok', '=', True)], required=True, change_default=True),
-        'price_unit': fields.float(string='Unit Price', digits=0),
-        'qty': fields.float('Quantity', digits_compute=dp.get_precision('Product Unit of Measure')),
-        'price_subtotal': fields.function(_amount_line_all, multi='pos_order_line_amount', digits=0, string='Subtotal w/o Tax'),
-        'price_subtotal_incl': fields.function(_amount_line_all, multi='pos_order_line_amount', digits=0, string='Subtotal'),
-        'discount': fields.float('Discount (%)', digits=0),
-        'order_id': fields.many2one('pos.order', 'Order Ref', ondelete='cascade'),
-        'create_date': fields.datetime('Creation Date', readonly=True),
-        'tax_ids': fields.many2many('account.tax', string='Taxes'),
-        'tax_ids_after_fiscal_position': fields.function(_get_tax_ids_after_fiscal_position, type='many2many', relation='account.tax', string='Taxes')
-    }
-
-    _defaults = {
-        'name': lambda obj, cr, uid, context: obj.pool.get('ir.sequence').next_by_code(cr, uid, 'pos.order.line', context=context),
-        'qty': lambda *a: 1,
-        'discount': lambda *a: 0.0,
-        'company_id': lambda self,cr,uid,c: self.pool.get('res.users').browse(cr, uid, uid, c).company_id.id,
-    }
+            line.price_subtotal = line.price_subtotal_incl = price * line.qty
+            if taxes:
+                taxes = taxes.compute_all(price, currency, line.qty, product=line.product_id, partner=line.order_id.partner_id or False)
+                line.price_subtotal = taxes['total_excluded']
+                line.price_subtotal_incl = taxes['total_included']
+
+    @api.onchange('product_id')
+    def _onchange_product_id(self):
+        if self.product_id:
+            if not self.order_id.pricelist_id:
+                raise UserError(
+                    _('You have to select a pricelist in the sale form !\n'
+                      'Please set one before choosing a product.'))
+            price = self.order_id.pricelist_id.price_get(
+                self.product_id.id, self.qty or 1.0, self.order_id.partner_id.id)[self.order_id.pricelist_id.id]
+            self.onchange_qty()
+            self.price_unit = price
+            self.tax_ids = self.product_id.taxes_id
+
+    @api.onchange('qty', 'discount', 'price_unit', 'tax_ids')
+    def _onchange_qty(self):
+        if self.product_id:
+            if not self.order_id.pricelist_id:
+                raise UserError(_('You have to select a pricelist in the sale form !'))
+            price = self.price_unit * (1 - (self.discount or 0.0) / 100.0)
+            self.price_subtotal = self.price_subtotal_incl = price * self.qty
+            if (self.product_id.taxes_id):
+                taxes = self.product_id.taxes_id.compute_all(price, self.order_id.pricelist_id.currency_id, self.qty, product=self.product_id, partner=False)
+                self.price_subtotal = taxes['total_excluded']
+                self.price_subtotal_incl = taxes['total_included']
+
+    @api.multi
+    def _get_tax_ids_after_fiscal_position(self):
+        for line in self:
+            line.tax_ids_after_fiscal_position = line.order_id.fiscal_position_id.map_tax(line.tax_ids)

--- a/addons/point_of_sale/models/pos_session.py
+++ b/addons/point_of_sale/models/pos_session.py
@@ -1,161 +1,124 @@
 # -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
-import time
-from openerp.osv import fields, osv
-from openerp.tools.translate import _
+from odoo import api, fields, models, _
+from odoo.exceptions import UserError
 
-class pos_session(osv.osv):
+class PosSession(models.Model):
     _name = 'pos.session'
     _order = 'id desc'
 
     POS_SESSION_STATE = [
         ('opening_control', 'Opening Control'),  # Signal open
-        ('opened', 'In Progress'),                    # Signal closing
+        ('opened', 'In Progress'),               # Signal closing
         ('closing_control', 'Closing Control'),  # Signal close
         ('closed', 'Closed & Posted'),
     ]
 
-    def _compute_cash_all(self, cr, uid, ids, fieldnames, args, context=None):
-        result = dict()
-
-        for record in self.browse(cr, uid, ids, context=context):
-            result[record.id] = {
-                'cash_journal_id' : False,
-                'cash_register_id' : False,
-                'cash_control' : False,
-            }
-
-            if record.config_id.cash_control:
-                for st in record.statement_ids:
-                    if st.journal_id.type == 'cash':
-                        result[record.id]['cash_control'] = True
-                        result[record.id]['cash_journal_id'] = st.journal_id.id
-                        result[record.id]['cash_register_id'] = st.id
-
-                if not result[record.id]['cash_control']:
+    def _confirm_orders(self):
+        for session in self:
+            company_id = session.config_id.journal_id.company_id.id
+            orders = session.order_ids.filtered(lambda order: order.state == 'paid')
+            move = self.env['pos.order'].with_context(force_company=company_id)._create_account_move(session.start_at, session.name, session.config_id.journal_id.id, company_id)
+            orders.with_context(force_company=company_id)._create_account_move_line(session, move)
+            for order in session.order_ids.filtered(lambda o: o.state != 'done'):
+                if order.state not in ('paid', 'invoiced'):
+                    raise UserError(_("You cannot confirm all orders of this session, because they have not the 'paid' status"))
+                order.signal_workflow('done')
+
+    config_id = fields.Many2one(
+        'pos.config', string='Point of Sale',
+        help="The physical point of sale you will use.",
+        required=True,
+        index=True,
+        domain="[('state', '=', 'active')]")
+    name = fields.Char(string='Session ID', required=True, readonly=True, default='/')
+    user_id = fields.Many2one(
+        'res.users', string='Responsible',
+        required=True,
+        index=True,
+        readonly=True,
+        states={'opening_control': [('readonly', False)]},
+        default=lambda self: self.env.uid)
+    currency_id = fields.Many2one('res.currency', related='config_id.currency_id', string="Currency")
+    start_at = fields.Datetime(string='Opening Date', readonly=True)
+    stop_at = fields.Datetime(string='Closing Date', readonly=True, copy=False)
+
+    state = fields.Selection(
+        POS_SESSION_STATE, string='Status',
+        required=True, readonly=True,
+        index=True, copy=False, default='opening_control')        
+
+    sequence_number = fields.Integer(string='Order Sequence Number', help='A sequence number that is incremented with each order', default=1)
+    login_number = fields.Integer(string='Login Sequence Number', help='A sequence number that is incremented each time a user resumes the pos session', default=0)
+
+    cash_control = fields.Boolean(compute='_compute_cash_all',    string='Has Cash Control')
+    cash_journal_id = fields.Many2one('account.journal', compute='_compute_cash_all', string='Cash Journal', store=True)
+    cash_register_id = fields.Many2one('account.bank.statement', compute='_compute_cash_all', string='Cash Register', store=True)
+
+    cash_register_balance_end_real = fields.Monetary(
+        related='cash_register_id.balance_end_real',
+        string="Ending Balance",
+        help="Total of closing cash control lines.",
+        readonly=True)
+    cash_register_balance_start = fields.Monetary(
+        related='cash_register_id.balance_start',
+        string="Starting Balance",
+        help="Total of opening cash control lines.",
+        readonly=True)
+    cash_register_total_entry_encoding = fields.Monetary(
+        related='cash_register_id.total_entry_encoding',
+        string='Total Cash Transaction',
+        readonly=True,
+        help="Total of all paid sale orders")
+    cash_register_balance_end = fields.Monetary(
+        related='cash_register_id.balance_end',
+        digits=0,
+        string="Theoretical Closing Balance",
+        help="Sum of opening balance and transactions.",
+        readonly=True)
+    cash_register_difference = fields.Monetary(
+        related='cash_register_id.difference',
+        string='Difference',
+        help="Difference between the theoretical closing balance and the real closing balance.",
+        readonly=True)
+
+    journal_ids = fields.Many2many(
+        'account.journal',
+        related='config_id.journal_ids',
+        readonly=True,
+        string='Available Payment Methods')
+    order_ids = fields.One2many('pos.order', 'session_id',  string='Orders')
+    statement_ids = fields.One2many('account.bank.statement', 'pos_session_id', string='Bank Statement', readonly=True)
+
+    _sql_constraints = [('uniq_name', 'unique(name)', _("The name of this POS Session must be unique !"))]
+
+    @api.depends('cash_control', 'cash_journal_id', 'config_id.cash_control')
+    def _compute_cash_all(self):
+        for session in self:
+            session.cash_journal_id = session.cash_register_id = session.cash_control = False
+            if session.config_id.cash_control:
+                for statement in session.statement_ids:
+                    if statement.journal_id.type == 'cash':
+                        session.cash_control = True
+                        session.cash_journal_id = statement.journal_id.id
+                        session.cash_register_id = statement.id
+                if not session.cash_control:
                     raise UserError(_("Cash control can only be applied to cash journals."))
 
-        return result
-
-    _columns = {
-        'config_id' : fields.many2one('pos.config', 'Point of Sale',
-                                      help="The physical point of sale you will use.",
-                                      required=True,
-                                      select=1,
-                                      domain="[('state', '=', 'active')]",
-                                     ),
-
-        'name' : fields.char('Session ID', required=True, readonly=True),
-        'user_id' : fields.many2one('res.users', 'Responsible',
-                                    required=True,
-                                    select=1,
-                                    readonly=True,
-                                    states={'opening_control' : [('readonly', False)]}
-                                   ),
-        'currency_id' : fields.related('config_id', 'currency_id', type="many2one", relation='res.currency', string="Currency"),
-        'start_at' : fields.datetime('Opening Date', readonly=True), 
-        'stop_at' : fields.datetime('Closing Date', readonly=True, copy=False),
-
-        'state' : fields.selection(POS_SESSION_STATE, 'Status',
-                required=True, readonly=True,
-                select=1, copy=False),
-        
-        'sequence_number': fields.integer('Order Sequence Number', help='A sequence number that is incremented with each order'),
-        'login_number':  fields.integer('Login Sequence Number', help='A sequence number that is incremented each time a user resumes the pos session'),
-
-        'cash_control' : fields.function(_compute_cash_all,
-                                         multi='cash',
-                                         type='boolean', string='Has Cash Control'),
-        'cash_journal_id' : fields.function(_compute_cash_all,
-                                            multi='cash',
-                                            type='many2one', relation='account.journal',
-                                            string='Cash Journal', store=True),
-        'cash_register_id' : fields.function(_compute_cash_all,
-                                             multi='cash',
-                                             type='many2one', relation='account.bank.statement',
-                                             string='Cash Register', store=True),
-
-        'cash_register_balance_end_real' : fields.related('cash_register_id', 'balance_end_real',
-                type='float',
-                digits=0,
-                string="Ending Balance",
-                help="Total of closing cash control lines.",
-                readonly=True),
-        'cash_register_balance_start' : fields.related('cash_register_id', 'balance_start',
-                type='float',
-                digits=0,
-                string="Starting Balance",
-                help="Total of opening cash control lines.",
-                readonly=True),
-        'cash_register_total_entry_encoding' : fields.related('cash_register_id', 'total_entry_encoding',
-                string='Total Cash Transaction',
-                readonly=True,
-                help="Total of all paid sale orders"),
-        'cash_register_balance_end' : fields.related('cash_register_id', 'balance_end',
-                type='float',
-                digits=0,
-                string="Theoretical Closing Balance",
-                help="Sum of opening balance and transactions.",
-                readonly=True),
-        'cash_register_difference' : fields.related('cash_register_id', 'difference',
-                type='float',
-                string='Difference',
-                help="Difference between the theoretical closing balance and the real closing balance.",
-                readonly=True),
+    @api.constrains('user_id', 'state')
+    def _check_unicity(self):
+        # open if there is no session in 'opening_control', 'opened', 'closing_control' for one user
+        if self.search_count([('state', 'not in', ('closed', 'closing_control')), ('user_id', '=', self.user_id.id)]) > 1:
+            raise UserError(_("You cannot create two active sessions with the same responsible!"))
 
-        'journal_ids' : fields.related('config_id', 'journal_ids',
-                                       type='many2many',
-                                       readonly=True,
-                                       relation='account.journal',
-                                       string='Available Payment Methods'),
-        'order_ids' : fields.one2many('pos.order', 'session_id', 'Orders'),
-
-        'statement_ids' : fields.one2many('account.bank.statement', 'pos_session_id', 'Bank Statement', readonly=True),
-    }
-
-    _defaults = {
-        'name' : '/',
-        'user_id' : lambda obj, cr, uid, context: uid,
-        'state' : 'opening_control',
-        'sequence_number': 1,
-        'login_number': 0,
-    }
-
-    _sql_constraints = [
-        ('uniq_name', 'unique(name)', "The name of this POS Session must be unique !"),
-    ]
-
-    def _check_unicity(self, cr, uid, ids, context=None):
-        for session in self.browse(cr, uid, ids, context=None):
-            # open if there is no session in 'opening_control', 'opened', 'closing_control' for one user
-            domain = [
-                ('state', 'not in', ('closed','closing_control')),
-                ('user_id', '=', session.user_id.id)
-            ]
-            count = self.search_count(cr, uid, domain, context=context)
-            if count>1:
-                return False
-        return True
-
-    def _check_pos_config(self, cr, uid, ids, context=None):
-        for session in self.browse(cr, uid, ids, context=None):
-            domain = [
-                ('state', '!=', 'closed'),
-                ('config_id', '=', session.config_id.id)
-            ]
-            count = self.search_count(cr, uid, domain, context=context)
-            if count>1:
-                return False
-        return True
-
-    _constraints = [
-        (_check_unicity, "You cannot create two active sessions with the same responsible!", ['user_id', 'state']),
-        (_check_pos_config, "You cannot create two active sessions related to the same point of sale!", ['config_id']),
-    ]
+    @api.constrains('config_id')
+    def _check_pos_config(self):
+        if self.search_count([('state', '!=', 'closed'), ('config_id', '=', self.config_id.id)]) > 1:
+            raise UserError(_("You cannot create two active sessions related to the same point of sale!"))
 
-    def create(self, cr, uid, values, context=None):
-        context = dict(context or {})
-        config_id = values.get('config_id', False) or context.get('default_config_id', False)
+    @api.model
+    def create(self, values):
+        config_id = values.get('config_id') or self.env.context.get('default_config_id')
         if not config_id:
             raise UserError(_("You should assign a Point of Sale to your session."))
 
@@ -163,145 +126,105 @@ class pos_session(osv.osv):
         # exists at the installation. If nothing is configured at the
         # installation we do the minimal configuration. Impossible to do in
         # the .xml files as the CoA is not yet installed.
-        jobj = self.pool.get('pos.config')
-        pos_config = jobj.browse(cr, uid, config_id, context=context)
-        context.update({'company_id': pos_config.company_id.id})
+        pos_config = self.env['pos.config'].browse(config_id)
+        ctx = dict(self.env.context, company_id=pos_config.company_id.id)
         if not pos_config.journal_id:
-            jid = jobj.default_get(cr, uid, ['journal_id'], context=context)['journal_id']
-            if jid:
-                jobj.write(cr, SUPERUSER_ID, [pos_config.id], {'journal_id': jid}, context=context)
-            else:
+            jid = pos_config.with_context(ctx).default_get(['journal_id'])['journal_id']
+            if not jid:
                 raise UserError(_("Unable to open the session. You have to assign a sale journal to your point of sale."))
-
+            pos_config.with_context(ctx).sudo().write({'journal_id': jid})
         # define some cash journal if no payment method exists
         if not pos_config.journal_ids:
-            journal_proxy = self.pool.get('account.journal')
-            cashids = journal_proxy.search(cr, uid, [('journal_user', '=', True), ('type','=','cash')], context=context)
-            if not cashids:
-                cashids = journal_proxy.search(cr, uid, [('type', '=', 'cash')], context=context)
-                if not cashids:
-                    cashids = journal_proxy.search(cr, uid, [('journal_user','=',True)], context=context)
-
-            journal_proxy.write(cr, SUPERUSER_ID, cashids, {'journal_user': True})
-            jobj.write(cr, SUPERUSER_ID, [pos_config.id], {'journal_ids': [(6,0, cashids)]})
-
-
-        pos_config = jobj.browse(cr, uid, config_id, context=context)
-
+            Journal = self.env['account.journal']
+            journals = Journal.with_context(ctx).search([('journal_user', '=', True), ('type', '=', 'cash')])
+            if not journals:
+                journals = Journal.with_context(ctx).search([('type', '=', 'cash')])
+                if not journals:
+                    journals = Journal.with_context(ctx).search([('journal_user', '=', True)])
+            journals.sudo().write({'journal_user': True})
+            pos_config.sudo().write({'journal_ids': [(6, 0, journals.ids)]})
         statements = [(0, 0, {
             'journal_id': journal.id,
-            'user_id': uid,
+            'user_id': self.env.uid,
             'company_id': pos_config.company_id.id
         }) for journal in pos_config.journal_ids]
-
         values.update({
-            'name': self.pool['ir.sequence'].next_by_code(cr, uid, 'pos.session', context=context),
+            'name': self.env['ir.sequence'].with_context(ctx).next_by_code('pos.session'),
             'statement_ids': statements,
             'config_id': config_id
         })
-
         # set the journal_id which should be used by
-        # account.bank.statement to set the opening balance of the
-        # newly created bank statement
+        # account.bank.statement to set the opening balance of the newly created bank statement
         if pos_config.cash_control:
-            for journal in pos_config.journal_ids:
-                if journal.type == 'cash':
-                    context.update({'journal_id': journal.id})
-
-        return super(pos_session, self).create(cr, uid, values, context=context)
-
-    def unlink(self, cr, uid, ids, context=None):
-        for obj in self.browse(cr, uid, ids, context=context):
-            self.pool.get('account.bank.statement').unlink(cr, uid, obj.statement_ids.ids, context=context)
-        return super(pos_session, self).unlink(cr, uid, ids, context=context)
-
-    def login(self, cr, uid, ids, context=None):
-        this_record = self.browse(cr, uid, ids[0], context=context)
-        this_record.write({
-            'login_number': this_record.login_number+1,
+            for journal in pos_config.journal_ids.filtered(lambda j: j.type == 'cash'):
+                ctx.update({'journal_id': journal.id})
+        return super(PosSession, self.with_context(ctx)).create(values)
+
+    @api.multi
+    def unlink(self):
+        for session in self.filtered(lambda s: s.statement_ids):
+            session.statement_ids.unlink()
+        return super(PosSession, self).unlink()
+
+    @api.multi
+    def login(self):
+        self.ensure_one()
+        self.write({
+            'login_number': self.login_number + 1,
         })
 
-    def wkf_action_open(self, cr, uid, ids, context=None):
+    def wkf_action_open(self):
         # second browse because we need to refetch the data from the DB for cash_register_id
-        for record in self.browse(cr, uid, ids, context=context):
+        for session in self:
             values = {}
-            if not record.start_at:
-                values['start_at'] = time.strftime('%Y-%m-%d %H:%M:%S')
+            if not session.start_at:
+                values['start_at'] = fields.Datetime.now()
             values['state'] = 'opened'
-            record.write(values)
-            for st in record.statement_ids:
-                st.button_open()
-
+            session.write(values)
+            session.statement_ids.button_open()
         return True
 
-    def wkf_action_opening_control(self, cr, uid, ids, context=None):
-        return self.write(cr, uid, ids, {'state' : 'opening_control'}, context=context)
+    def wkf_action_opening_control(self):
+        return self.write({'state': 'opening_control'})
 
-    def wkf_action_closing_control(self, cr, uid, ids, context=None):
-        for session in self.browse(cr, uid, ids, context=context):
+    def wkf_action_closing_control(self):
+        for session in self:
             for statement in session.statement_ids:
                 if (statement != session.cash_register_id) and (statement.balance_end != statement.balance_end_real):
-                    self.pool.get('account.bank.statement').write(cr, uid, [statement.id], {'balance_end_real': statement.balance_end})
-        return self.write(cr, uid, ids, {'state' : 'closing_control', 'stop_at' : time.strftime('%Y-%m-%d %H:%M:%S')}, context=context)
+                    statement.write({'balance_end_real': statement.balance_end})
+            session.write({'state': 'closing_control', 'stop_at': fields.Datetime.now()})
 
-    def wkf_action_close(self, cr, uid, ids, context=None):
+    def wkf_action_close(self):
         # Close CashBox
-        local_context = dict(context)
-        for record in self.browse(cr, uid, ids, context=context):
-            company_id = record.config_id.company_id.id
-            local_context.update({'force_company': company_id, 'company_id': company_id})
-            for st in record.statement_ids:
+        for session in self:
+            company_id = session.config_id.company_id.id
+            ctx = dict(self.env.context, force_company=company_id, company_id=company_id)
+            for st in session.statement_ids:
                 if abs(st.difference) > st.journal_id.amount_authorized_diff:
                     # The pos manager can close statements with maximums.
-                    if not self.pool.get('ir.model.access').check_groups(cr, uid, "point_of_sale.group_pos_manager"):
+                    if not self.env['ir.model.access'].check_groups("point_of_sale.group_pos_manager"):
                         raise UserError(_("Your ending balance is too different from the theoretical cash closing (%.2f), the maximum allowed is: %.2f. You can contact your manager to force it.") % (st.difference, st.journal_id.amount_authorized_diff))
                 if (st.journal_id.type not in ['bank', 'cash']):
                     raise UserError(_("The type of the journal for your payment method should be bank or cash "))
-                self.pool['account.bank.statement'].button_confirm_bank(cr, SUPERUSER_ID, [st.id], context=local_context)
-        self._confirm_orders(cr, uid, ids, context=local_context)
-        self.write(cr, uid, ids, {'state' : 'closed'}, context=local_context)
-
-        obj = self.pool.get('ir.model.data').get_object_reference(cr, uid, 'point_of_sale', 'menu_point_root')[1]
+                st.with_context(ctx).sudo().button_confirm_bank()
+        self.with_context(ctx)._confirm_orders()
+        self.write({'state': 'closed'})
         return {
-            'type' : 'ir.actions.client',
-            'name' : 'Point of Sale Menu',
-            'tag' : 'reload',
-            'params' : {'menu_id': obj},
+            'type': 'ir.actions.client',
+            'name': 'Point of Sale Menu',
+            'tag': 'reload',
+            'params': {'menu_id': self.env.ref('point_of_sale.menu_point_root').id},
         }
 
-    def _confirm_orders(self, cr, uid, ids, context=None):
-        pos_order_obj = self.pool.get('pos.order')
-        for session in self.browse(cr, uid, ids, context=context):
-            company_id = session.config_id.journal_id.company_id.id
-            local_context = dict(context or {}, force_company=company_id)
-            order_ids = [order.id for order in session.order_ids if order.state == 'paid']
-
-            move_id = pos_order_obj._create_account_move(cr, uid, session.start_at, session.name, session.config_id.journal_id.id, company_id, context=context)
-
-            pos_order_obj._create_account_move_line(cr, uid, order_ids, session, move_id, context=local_context)
-
-            for order in session.order_ids:
-                if order.state == 'done':
-                    continue
-                if order.state not in ('paid', 'invoiced'):
-                    raise UserError(_("You cannot confirm all orders of this session, because they have not the 'paid' status"))
-                else:
-                    pos_order_obj.signal_workflow(cr, uid, [order.id], 'done')
-
-        return True
-
-    def open_frontend_cb(self, cr, uid, ids, context=None):
-        if not context:
-            context = {}
-        if not ids:
+    @api.multi
+    def open_frontend_cb(self):
+        if not self.ids:
             return {}
-        for session in self.browse(cr, uid, ids, context=context):
-            if session.user_id.id != uid:
-                raise UserError(_("You cannot use the session of another users. This session is owned by %s. "
-                                    "Please first close this one to use this point of sale.") % session.user_id.name)
-        context.update({'active_id': ids[0]})
+        for session in self.filtered(lambda s: s.user_id.id != self.env.uid):
+            raise UserError(_("You cannot use the session of another users. This session is owned by %s. "
+                              "Please first close this one to use this point of sale.") % session.user_id.name)
         return {
-            'type' : 'ir.actions.act_url',
+            'type': 'ir.actions.act_url',
             'target': 'self',
             'url':   '/pos/web/',
         }

--- a/addons/point_of_sale/models/product.py
+++ b/addons/point_of_sale/models/product.py
@@ -1,27 +1,22 @@
 # -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
-from openerp.osv import fields, osv
-from openerp.tools.translate import _
+from odoo import api, fields, models, _
+from odoo.exceptions import UserError
 
 
-class product_template(osv.osv):
+class ProductTemplate(models.Model):
     _inherit = 'product.template'
 
-    _columns = {
-        'available_in_pos': fields.boolean('Available in the Point of Sale', help='Check if you want this product to appear in the Point of Sale'), 
-        'to_weight' : fields.boolean('To Weigh With Scale', help="Check if the product should be weighted using the hardware scale integration"),
-        'pos_categ_id': fields.many2one('pos.category','Point of Sale Category', help="Those categories are used to group similar products for point of sale."),
-    }
+    available_in_pos = fields.Boolean(string='Available in the Point of Sale', help='Check if you want this product to appear in the Point of Sale', default=True)
+    to_weight = fields.Boolean(string='To Weigh With Scale', help="Check if the product should be weighted using the hardware scale integration")
+    pos_categ_id = fields.Many2one(
+        'pos.category', string='Point of Sale Category',
+        help="Those categories are used to group similar products for point of sale.")
 
-    _defaults = {
-        'to_weight' : False,
-        'available_in_pos': True,
-    }
-
-    def unlink(self, cr, uid, ids, context=None):
-        product_ctx = dict(context or {}, active_test=False)
-        if self.search_count(cr, uid, [('id', 'in', ids), ('available_in_pos', '=', True)], context=product_ctx):
-            if self.pool['pos.session'].search_count(cr, uid, [('state', '!=', 'closed')], context=context):
-                raise osv.except_osv(_('Error!'),
-                    _('You cannot delete a product saleable in point of sale while a session is still opened.'))
-        return super(product_template, self).unlink(cr, uid, ids, context=context)
+    @api.multi
+    def unlink(self):
+        product_ctx = dict(self.env.context or {}, active_test=False)
+        if self.with_context(product_ctx).search_count([('id', 'in', self.ids), ('available_in_pos', '=', True)]):
+            if self.env['pos.session'].search_count([('state', '!=', 'closed')]):
+                raise UserError(_('You cannot delete a product saleable in point of sale while a session is still opened.'))
+        return super(ProductTemplate, self).unlink()

--- a/addons/point_of_sale/models/res_config.py
+++ b/addons/point_of_sale/models/res_config.py
@@ -1,29 +1,31 @@
-from openerp.osv import fields, osv
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+from odoo import fields, models
 
-class pos_configuration(osv.TransientModel):
+
+class PosConfiguration(models.TransientModel):
     _inherit = 'res.config.settings'
     _name = 'pos.config.settings'
 
-    _columns = {
-        'module_pos_restaurant': fields.selection([
-            (0, "Point of sale for shops"),
-            (1, "Restaurant: activate table management")
-            ], "Restaurant",
-            help='This module adds several restaurant features to the Point of Sale: \n\n- Bill Printing: Allows you to print a receipt before the order is paid \n\n- Bill Splitting: Allows you to split an order into different orders \n\n- Kitchen Order Printing: allows you to print orders updates to kitchen or bar printers'),
-        'module_pos_loyalty': fields.boolean("Loyalty Program",
-            help='Allows you to define a loyalty program in the point of sale, where the customers earn loyalty points and get rewards'),
-        'module_pos_discount': fields.selection([
-            (0, "Allow discounts on order lines only"),
-            (1, "Allow global discounts")
-            ], "Discount",
-            help='Allows the cashier to quickly give a percentage sale discount for all the sales order to a customer'),
-        'module_pos_mercury': fields.selection([
-            (0, "No credit card"),
-            (1, "Allows customers to pay with credit cards.")
-            ], "Credit Cards",
-            help='The transactions are processed by MercuryPay'),
-        'module_pos_reprint': fields.selection([
-            (0, "No reprint"),
-            (1, "Allow cashier to reprint receipts")
-            ], "Reprints"),
-    }
+    module_pos_restaurant = fields.Selection([
+        (0, "Point of sale for shops"),
+        (1, "Restaurant: activate table management")
+    ], string="Restaurant",
+        help='This module adds several restaurant features to the Point of Sale: \n\n- Bill Printing: Allows you to print a receipt before the order is paid \n\n- Bill Splitting: Allows you to split an order into different orders \n\n- Kitchen Order Printing: allows you to print orders updates to kitchen or bar printers')
+    module_pos_loyalty = fields.Boolean(
+        string="Loyalty Program",
+        help='Allows you to define a loyalty program in the point of sale, where the customers earn loyalty points and get rewards')
+    module_pos_discount = fields.Selection([
+        (0, "Allow discounts on order lines only"),
+        (1, "Allow global discounts")
+    ], string="Discount",
+        help='Allows the cashier to quickly give a percentage sale discount for all the sales order to a customer')
+    module_pos_mercury = fields.Selection([
+        (0, "No credit card"),
+        (1, "Allows customers to pay with credit cards.")
+    ], string="Credit Cards",
+        help='The transactions are processed by MercuryPay')
+    module_pos_reprint = fields.Selection([
+        (0, "No reprint"),
+        (1, "Allow cashier to reprint receipts")
+    ], string="Reprints")

--- a/addons/point_of_sale/models/res_partner.py
+++ b/addons/point_of_sale/models/res_partner.py
@@ -1,27 +1,24 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+from odoo import api, fields, models
 
-from openerp.osv import osv, fields
 
-
-class res_users(osv.osv):
+class ResPartner(models.Model):
     _inherit = 'res.partner'
-    _columns = {
-        'barcode' : fields.char('Barcode', help="BarCode", oldname='ean13'),
-    }
 
-    def create_from_ui(self, cr, uid, partner, context=None):
+    barcode = fields.Char(string='Barcode', help="BarCode", oldname='ean13')
+
+    @api.model
+    def create_from_ui(self, partner):
         """ create or modify a partner from the point of sale ui.
             partner contains the partner's fields. """
-
-        #image is a dataurl, get the data after the comma
-        if partner.get('image',False):
-            img =  partner['image'].split(',')[1]
-            partner['image'] = img
-
-        if partner.get('id',False):  # Modifying existing partner
-            partner_id = partner['id']
-            del partner['id']
-            self.write(cr, uid, [partner_id], partner, context=context)
+        # image is a dataurl, get the data after the comma
+        if partner.get('image'):
+            partner['image'] = partner['image'].split(',')[1]
+        partner_id = partner.pop('id', False)
+        if partner_id:  # Modifying existing partner
+            self.browse(partner_id).write(partner)
         else:
-            partner_id = self.create(cr, uid, partner, context=context)
+            partner_id = self.create(partner).id
         
         return partner_id

--- a/addons/point_of_sale/models/res_users.py
+++ b/addons/point_of_sale/models/res_users.py
@@ -1,19 +1,15 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+from odoo import api, fields, models, _
+from odoo.exceptions import UserError
 
-from openerp.osv import osv, fields
 
-
-class res_users(osv.osv):
+class ResUsers(models.Model):
     _inherit = 'res.users'
-    _columns = {
-        'pos_security_pin': fields.char('Security PIN',size=32, help='A Security PIN used to protect sensible functionality in the Point of Sale'),
-    }
 
-    def _check_pin(self, cr, uid, ids, context=None):
-        for user in self.browse(cr, uid, ids, context=context):
-            if user.pos_security_pin and not user.pos_security_pin.isdigit():
-                return False
-        return True
+    pos_security_pin = fields.Char(string='Security PIN', size=32, help='A Security PIN used to protect sensible functionality in the Point of Sale')
 
-    _constraints = [
-        (_check_pin, "Security PIN can only contain digits",['pos_security_pin']),
-    ]
+    @api.constrains('pos_security_pin')
+    def _check_pin(self):
+        if self.pos_security_pin and not self.pos_security_pin.isdigit():
+            raise UserError(_("Security PIN can only contain digits"))
