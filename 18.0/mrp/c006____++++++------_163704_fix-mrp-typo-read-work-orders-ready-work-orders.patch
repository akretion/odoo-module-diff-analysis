PR: https://github.com/odoo/odoo/pull/163704

From: 72af57f11c1339f98512d8f58768db5f8f31656f
From: Odoo's Mergebot
Date: 2024-05-07 09:40:02

Structural Changes: 199
Total Changes: 2

[FIX] mrp: typo # Read Work Orders -> # Ready Work Orders

Description of the issue/feature this PR addresses:
fix a typo

closes odoo/odoo#163704

Signed-off-by: Quentin Wolfs (quwo) <quwo@odoo.com>

================================= pseudo patch: =================================

--- a/addons/mrp/models/mrp_workcenter.py
+++ b/addons/mrp/models/mrp_workcenter.py
@@ -43,7 +43,7 @@ class MrpWorkcenter(models.Model):
     has_routing_lines = fields.Boolean(compute='_compute_has_routing_lines', help='Technical field for workcenter views')
     order_ids = fields.One2many('mrp.workorder', 'workcenter_id', "Orders")
     workorder_count = fields.Integer('# Work Orders', compute='_compute_workorder_count')
-    workorder_ready_count = fields.Integer('# Read Work Orders', compute='_compute_workorder_count')
+    workorder_ready_count = fields.Integer('# Ready Work Orders', compute='_compute_workorder_count')
     workorder_progress_count = fields.Integer('Total Running Orders', compute='_compute_workorder_count')
     workorder_pending_count = fields.Integer('Total Pending Orders', compute='_compute_workorder_count')
     workorder_late_count = fields.Integer('Total Late Orders', compute='_compute_workorder_count')

--- a/addons/mrp/models/__init__.py
+++ b/addons/mrp/models/__init__.py
@@ -15,7 +15,8 @@ from . import res_company
 from . import stock_move
 from . import stock_orderpoint
 from . import stock_picking
-from . import stock_production_lot
+from . import stock_lot
 from . import stock_rule
 from . import stock_scrap
 from . import stock_warehouse
+from . import stock_quant

--- a/addons/mrp/models/mrp_bom.py
+++ b/addons/mrp/models/mrp_bom.py
@@ -1,61 +1,62 @@
 # -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
-from odoo import api, fields, models, _
+from odoo import api, fields, models, _, Command
 from odoo.exceptions import UserError, ValidationError
-from odoo.osv.expression import AND, NEGATIVE_TERM_OPERATORS
+from odoo.osv.expression import AND, OR
 from odoo.tools import float_round
+from odoo.tools.misc import clean_context
 
-from itertools import groupby
+from collections import defaultdict
 
 
 class MrpBom(models.Model):
     """ Defines bills of material for a product or a product template """
     _name = 'mrp.bom'
     _description = 'Bill of Material'
-    _inherit = ['mail.thread']
+    _inherit = ['mail.thread', 'product.catalog.mixin']
     _rec_name = 'product_tmpl_id'
-    _order = "sequence"
+    _rec_names_search = ['product_tmpl_id', 'code']
+    _order = "sequence, id"
     _check_company_auto = True
 
     def _get_default_product_uom_id(self):
         return self.env['uom.uom'].search([], limit=1, order='id').id
 
     code = fields.Char('Reference')
-    active = fields.Boolean(
-        'Active', default=True,
-        help="If the active field is set to False, it will allow you to hide the bills of material without removing it.")
+    active = fields.Boolean('Active', default=True)
     type = fields.Selection([
         ('normal', 'Manufacture this product'),
         ('phantom', 'Kit')], 'BoM Type',
         default='normal', required=True)
     product_tmpl_id = fields.Many2one(
         'product.template', 'Product',
-        check_company=True,
-        domain="[('type', 'in', ['product', 'consu']), '|', ('company_id', '=', False), ('company_id', '=', company_id)]", required=True)
+        check_company=True, index=True,
+        domain="[('type', 'in', ['product', 'consu'])]", required=True)
     product_id = fields.Many2one(
         'product.product', 'Product Variant',
-        check_company=True,
-        domain="['&', ('product_tmpl_id', '=', product_tmpl_id), ('type', 'in', ['product', 'consu']),  '|', ('company_id', '=', False), ('company_id', '=', company_id)]",
+        check_company=True, index=True,
+        domain="['&', ('product_tmpl_id', '=', product_tmpl_id), ('type', 'in', ['product', 'consu'])]",
         help="If a product variant is defined the BOM is available only for this product.")
     bom_line_ids = fields.One2many('mrp.bom.line', 'bom_id', 'BoM Lines', copy=True)
     byproduct_ids = fields.One2many('mrp.bom.byproduct', 'bom_id', 'By-products', copy=True)
     product_qty = fields.Float(
         'Quantity', default=1.0,
-        digits='Unit of Measure', required=True)
+        digits='Product Unit of Measure', required=True,
+        help="This should be the smallest quantity that this product can be produced in. If the BOM contains operations, make sure the work center capacity is accurate.")
     product_uom_id = fields.Many2one(
         'uom.uom', 'Unit of Measure',
         default=_get_default_product_uom_id, required=True,
         help="Unit of Measure (Unit of Measure) is the unit of measurement for the inventory control", domain="[('category_id', '=', product_uom_category_id)]")
     product_uom_category_id = fields.Many2one(related='product_tmpl_id.uom_id.category_id')
-    sequence = fields.Integer('Sequence', help="Gives the sequence order when displaying a list of bills of material.")
+    sequence = fields.Integer('Sequence')
     operation_ids = fields.One2many('mrp.routing.workcenter', 'bom_id', 'Operations', copy=True)
     ready_to_produce = fields.Selection([
         ('all_available', ' When all components are available'),
         ('asap', 'When components for 1st operation are available')], string='Manufacturing Readiness',
-        default='asap', help="Defines when a Manufacturing Order is considered as ready to be started", required=True)
+        default='all_available', required=True)
     picking_type_id = fields.Many2one(
-        'stock.picking.type', 'Operation Type', domain="[('code', '=', 'mrp_operation'), ('company_id', '=', company_id)]",
+        'stock.picking.type', 'Operation Type', domain="[('code', '=', 'mrp_operation')]",
         check_company=True,
         help=u"When a procurement has a ‘produce’ route with a operation type set, it will try to create "
              "a Manufacturing Order for that product using a BoM of the same operation type. That allows "
@@ -70,43 +71,135 @@ class MrpBom(models.Model):
         help="Defines if you can consume more or less components than the quantity defined on the BoM:\n"
              "  * Allowed: allowed for all manufacturing users.\n"
              "  * Allowed with warning: allowed for all manufacturing users with summary of consumption differences when closing the manufacturing order.\n"
+             "  Note that in the case of component Manual Consumption, where consumption is registered manually exclusively, consumption warnings will still be issued when appropriate also.\n"
              "  * Blocked: only a manager can close a manufacturing order when the BoM consumption is not respected.",
         default='warning',
         string='Flexible Consumption',
         required=True
     )
+    possible_product_template_attribute_value_ids = fields.Many2many(
+        'product.template.attribute.value',
+        compute='_compute_possible_product_template_attribute_value_ids')
+    allow_operation_dependencies = fields.Boolean('Operation Dependencies',
+        help="Create operation level dependencies that will influence both planning and the status of work orders upon MO confirmation. If this feature is ticked, and nothing is specified, Odoo will assume that all operations can be started simultaneously."
+    )
+    produce_delay = fields.Integer(
+        'Manufacturing Lead Time', default=0,
+        help="Average lead time in days to manufacture this product. In the case of multi-level BOM, the manufacturing lead times of the components will be added. In case the product is subcontracted, this can be used to determine the date at which components should be sent to the subcontractor.")
+    days_to_prepare_mo = fields.Integer(
+        string="Days to prepare Manufacturing Order", default=0,
+        help="Create and confirm Manufacturing Orders this many days in advance, to have enough time to replenish components or manufacture semi-finished products.\n"
+             "Note that security lead times will also be considered when appropriate.")
 
     _sql_constraints = [
         ('qty_positive', 'check (product_qty > 0)', 'The quantity to produce must be positive!'),
     ]
 
+    @api.depends(
+        'product_tmpl_id.attribute_line_ids.value_ids',
+        'product_tmpl_id.attribute_line_ids.attribute_id.create_variant',
+        'product_tmpl_id.attribute_line_ids.product_template_value_ids.ptav_active',
+    )
+    def _compute_possible_product_template_attribute_value_ids(self):
+        for bom in self:
+            bom.possible_product_template_attribute_value_ids = bom.product_tmpl_id.valid_product_template_attribute_line_ids._without_no_variant_attributes().product_template_value_ids._only_active()
+
     @api.onchange('product_id')
-    def onchange_product_id(self):
+    def _onchange_product_id(self):
         if self.product_id:
-            for line in self.bom_line_ids:
-                line.bom_product_template_attribute_value_ids = False
+            self.bom_line_ids.bom_product_template_attribute_value_ids = False
+            self.operation_ids.bom_product_template_attribute_value_ids = False
+            self.byproduct_ids.bom_product_template_attribute_value_ids = False
+
+    @api.constrains('active', 'product_id', 'product_tmpl_id', 'bom_line_ids')
+    def _check_bom_cycle(self):
+        subcomponents_dict = dict()
+
+        def _check_cycle(components, finished_products):
+            """
+            Check whether the components are part of the finished products (-> cycle). Then, if
+            these components have a BoM, repeat the operation with the subcomponents (recursion).
+            The method will return the list of product variants that creates the cycle
+            """
+            products_to_find = self.env['product.product']
+
+            for component in components:
+                if component in finished_products:
+                    names = finished_products.mapped('display_name')
+                    raise ValidationError(_(
+                        "The current configuration is incorrect because it would create a cycle between these products: %s.",
+                        ', '.join(names)))
+                if component not in subcomponents_dict:
+                    products_to_find |= component
+
+            bom_find_result = self._bom_find(products_to_find)
+            for component in components:
+                if component not in subcomponents_dict:
+                    bom = bom_find_result[component]
+                    subcomponents = bom.bom_line_ids.filtered(lambda l: not l._skip_bom_line(component)).product_id
+                    subcomponents_dict[component] = subcomponents
+                subcomponents = subcomponents_dict[component]
+                if subcomponents:
+                    _check_cycle(subcomponents, finished_products | component)
+
+        boms_to_check = self
+        if self.bom_line_ids.product_id:
+            boms_to_check |= self.search(OR([
+                self._bom_find_domain(product)
+                for product in self.bom_line_ids.product_id
+            ]))
+
+        for bom in boms_to_check:
+            if not bom.active:
+                continue
+            finished_products = bom.product_id or bom.product_tmpl_id.product_variant_ids
+            if bom.bom_line_ids.bom_product_template_attribute_value_ids:
+                grouped_by_components = defaultdict(lambda: self.env['product.product'])
+                for finished in finished_products:
+                    components = bom.bom_line_ids.filtered(lambda l: not l._skip_bom_line(finished)).product_id
+                    grouped_by_components[components] |= finished
+                for components, finished in grouped_by_components.items():
+                    _check_cycle(components, finished)
+            else:
+                _check_cycle(bom.bom_line_ids.product_id, finished_products)
 
-    @api.constrains('product_id', 'product_tmpl_id', 'bom_line_ids')
+    @api.constrains('product_id', 'product_tmpl_id', 'bom_line_ids', 'byproduct_ids', 'operation_ids')
     def _check_bom_lines(self):
         for bom in self:
-            for bom_line in bom.bom_line_ids:
+            apply_variants = bom.bom_line_ids.bom_product_template_attribute_value_ids | bom.operation_ids.bom_product_template_attribute_value_ids | bom.byproduct_ids.bom_product_template_attribute_value_ids
+            if bom.product_id and apply_variants:
+                raise ValidationError(_("You cannot use the 'Apply on Variant' functionality and simultaneously create a BoM for a specific variant."))
+            for ptav in apply_variants:
+                if ptav.product_tmpl_id != bom.product_tmpl_id:
+                    raise ValidationError(_(
+                        "The attribute value %(attribute)s set on product %(product)s does not match the BoM product %(bom_product)s.",
+                        attribute=ptav.display_name,
+                        product=ptav.product_tmpl_id.display_name,
+                        bom_product=bom.product_tmpl_id.display_name
+                    ))
+            for byproduct in bom.byproduct_ids:
                 if bom.product_id:
-                    same_product = bom.product_id == bom_line.product_id
+                    same_product = bom.product_id == byproduct.product_id
                 else:
-                    same_product = bom.product_tmpl_id == bom_line.product_id.product_tmpl_id
+                    same_product = bom.product_tmpl_id == byproduct.product_id.product_tmpl_id
                 if same_product:
-                    raise ValidationError(_("BoM line product %s should not be the same as BoM product.") % bom.display_name)
-                if bom.product_id and bom_line.bom_product_template_attribute_value_ids:
-                    raise ValidationError(_("BoM cannot concern product %s and have a line with attributes (%s) at the same time.")
-                        % (bom.product_id.display_name, ", ".join([ptav.display_name for ptav in bom_line.bom_product_template_attribute_value_ids])))
-                for ptav in bom_line.bom_product_template_attribute_value_ids:
-                    if ptav.product_tmpl_id != bom.product_tmpl_id:
-                        raise ValidationError(_(
-                            "The attribute value %(attribute)s set on product %(product)s does not match the BoM product %(bom_product)s.",
-                            attribute=ptav.display_name,
-                            product=ptav.product_tmpl_id.display_name,
-                            bom_product=bom_line.parent_product_tmpl_id.display_name
-                        ))
+                    raise ValidationError(_("By-product %s should not be the same as BoM product.", bom.display_name))
+                if byproduct.cost_share < 0:
+                    raise ValidationError(_("By-products cost shares must be positive."))
+            if sum(bom.byproduct_ids.mapped('cost_share')) > 100:
+                raise ValidationError(_("The total cost share for a BoM's by-products cannot exceed 100."))
+
+    @api.onchange('bom_line_ids', 'product_qty')
+    def onchange_bom_structure(self):
+        if self.type == 'phantom' and self._origin and self.env['stock.move'].search_count([('bom_line_id', 'in', self._origin.bom_line_ids.ids)], limit=1):
+            return {
+                'warning': {
+                    'title': _('Warning'),
+                    'message': _(
+                        'The product has already been used at least once, editing its structure may lead to undesirable behaviours. '
+                        'You should rather archive the product and create a new one with a new bill of materials.'),
+                }
+            }
 
     @api.onchange('product_uom_id')
     def onchange_product_uom_id(self):
@@ -121,74 +214,145 @@ class MrpBom(models.Model):
     @api.onchange('product_tmpl_id')
     def onchange_product_tmpl_id(self):
         if self.product_tmpl_id:
-            self.product_uom_id = self.product_tmpl_id.uom_id.id
+            default_uom_id = self.env.context.get('default_product_uom_id')
+            # Avoids updating the BoM's UoM in case a specific UoM was passed through as a default value.
+            if self.product_uom_id.category_id != self.product_tmpl_id.uom_id.category_id or self.product_uom_id.id != default_uom_id:
+                self.product_uom_id = self.product_tmpl_id.uom_id.id
             if self.product_id.product_tmpl_id != self.product_tmpl_id:
                 self.product_id = False
-            for line in self.bom_line_ids:
-                line.bom_product_template_attribute_value_ids = False
+            self.bom_line_ids.bom_product_template_attribute_value_ids = False
+            self.operation_ids.bom_product_template_attribute_value_ids = False
+            self.byproduct_ids.bom_product_template_attribute_value_ids = False
 
-    def copy(self, default=None):
-        res = super().copy(default)
-        for bom_line in res.bom_line_ids:
-            if bom_line.operation_id:
-                operation = res.operation_ids.filtered(lambda op: op.name == bom_line.operation_id.name and op.workcenter_id == bom_line.operation_id.workcenter_id)
-                bom_line.operation_id = operation
+            domain = [('product_tmpl_id', '=', self.product_tmpl_id.id)]
+            if self.id.origin:
+                domain.append(('id', '!=', self.id.origin))
+            number_of_bom_of_this_product = self.env['mrp.bom'].search_count(domain)
+            if number_of_bom_of_this_product:  # add a reference to the bom if there is already a bom for this product
+                self.code = _("%s (new) %s", self.product_tmpl_id.name, number_of_bom_of_this_product)
+
+    @api.model_create_multi
+    def create(self, vals_list):
+        res = super().create(vals_list)
+        # Checks if the BoM was created from a Manufacturing Order (through Generate BoM action).
+        parent_production_id = self.env.context.get('parent_production_id')
+        if parent_production_id:  # In this case, assign the newly created BoM to the MO.
+            # Clean context to avoid parasitic default values.
+            self.env.context = clean_context(self.env.context)
+            production = self.env['mrp.production'].browse(parent_production_id)
+            production._link_bom(res[0])
         return res
 
+    def write(self, vals):
+        res = super().write(vals)
+        relevant_fields = ['bom_line_ids', 'byproduct_ids', 'product_tmpl_id', 'product_id', 'product_qty']
+        if any(field_name in vals for field_name in relevant_fields):
+            self._set_outdated_bom_in_productions()
+        if 'sequence' in vals and self and self[-1].id == self._prefetch_ids[-1]:
+            self.browse(self._prefetch_ids)._check_bom_cycle()
+        return res
+
+    def copy(self, default=None):
+        new_boms = super().copy(default)
+        for old_bom, new_bom in zip(self, new_boms):
+            if old_bom.operation_ids:
+                operations_mapping = {}
+                for original, copied in zip(old_bom.operation_ids, new_bom.operation_ids.sorted()):
+                    operations_mapping[original] = copied
+                for bom_line in new_bom.bom_line_ids:
+                    if bom_line.operation_id:
+                        bom_line.operation_id = operations_mapping[bom_line.operation_id]
+                for operation in old_bom.operation_ids:
+                    if operation.blocked_by_operation_ids:
+                        copied_operation = operations_mapping[operation]
+                        dependencies = []
+                        for dependency in operation.blocked_by_operation_ids:
+                            dependencies.append(Command.link(operations_mapping[dependency].id))
+                        copied_operation.blocked_by_operation_ids = dependencies
+        return new_boms
+
     @api.model
     def name_create(self, name):
         # prevent to use string as product_tmpl_id
         if isinstance(name, str):
+            key = 'default_' + self._rec_name
+            if key in self.env.context:
+                result = super().name_create(self.env.context[key])
+                self.browse(result[0]).code = name
+                return result
             raise UserError(_("You cannot create a new Bill of Material from here."))
         return super(MrpBom, self).name_create(name)
 
-    def name_get(self):
-        return [(bom.id, '%s%s' % (bom.code and '%s: ' % bom.code or '', bom.product_tmpl_id.display_name)) for bom in self]
+    def toggle_active(self):
+        self.with_context({'active_test': False}).operation_ids.toggle_active()
+        return super().toggle_active()
+
+    @api.depends('code')
+    def _compute_display_name(self):
+        for bom in self:
+            bom.display_name = f"{bom.code + ': ' if bom.code else ''}{bom.product_tmpl_id.display_name}"
+
+    def action_compute_bom_days(self):
+        company_id = self.env.context.get('default_company_id', self.env.company.id)
+        warehouse = self.env['stock.warehouse'].search([('company_id', '=', company_id)], limit=1)
+        for bom in self:
+            bom_data = self.env['report.mrp.report_bom_structure'].with_context(minimized=True)._get_bom_data(bom, warehouse, bom.product_id, ignore_stock=True)
+            bom.days_to_prepare_mo = self.env['report.mrp.report_bom_structure']._get_max_component_delay(bom_data['components'])
+
+    @api.constrains('product_tmpl_id', 'product_id', 'type')
+    def check_kit_has_not_orderpoint(self):
+        product_ids = [pid for bom in self.filtered(lambda bom: bom.type == "phantom")
+                           for pid in (bom.product_id.ids or bom.product_tmpl_id.product_variant_ids.ids)]
+        if self.env['stock.warehouse.orderpoint'].search_count([('product_id', 'in', product_ids)], limit=1):
+            raise ValidationError(_("You can not create a kit-type bill of materials for products that have at least one reordering rule."))
 
     @api.ondelete(at_uninstall=False)
     def _unlink_except_running_mo(self):
-        if self.env['mrp.production'].search([('bom_id', 'in', self.ids), ('state', 'not in', ['done', 'cancel'])], limit=1):
+        if self.env['mrp.production'].search_count([('bom_id', 'in', self.ids), ('state', 'not in', ['done', 'cancel'])], limit=1):
             raise UserError(_('You can not delete a Bill of Material with running manufacturing orders.\nPlease close or cancel it first.'))
 
     @api.model
-    def _name_search(self, name='', args=None, operator='ilike', limit=100, name_get_uid=None):
-        args = args or []
-        domain = []
-        if (name or '').strip():
-            domain = ['|', (self._rec_name, operator, name), ('code', operator, name)]
-            if operator in NEGATIVE_TERM_OPERATORS:
-                domain = domain[1:]
-        return self._search(AND([domain, args]), limit=limit, access_rights_uid=name_get_uid)
-
-    @api.model
-    def _bom_find_domain(self, product_tmpl=None, product=None, picking_type=None, company_id=False, bom_type=False):
-        if product:
-            if not product_tmpl:
-                product_tmpl = product.product_tmpl_id
-            domain = ['|', ('product_id', '=', product.id), '&', ('product_id', '=', False), ('product_tmpl_id', '=', product_tmpl.id)]
-        elif product_tmpl:
-            domain = [('product_tmpl_id', '=', product_tmpl.id)]
-        else:
-            # neither product nor template, makes no sense to search
-            raise UserError(_('You should provide either a product or a product template to search a BoM'))
-        if picking_type:
-            domain += ['|', ('picking_type_id', '=', picking_type.id), ('picking_type_id', '=', False)]
+    def _bom_find_domain(self, products, picking_type=None, company_id=False, bom_type=False):
+        domain = ['&', '|', ('product_id', 'in', products.ids), '&', ('product_id', '=', False), ('product_tmpl_id', 'in', products.product_tmpl_id.ids), ('active', '=', True)]
         if company_id or self.env.context.get('company_id'):
-            domain = domain + ['|', ('company_id', '=', False), ('company_id', '=', company_id or self.env.context.get('company_id'))]
+            domain = AND([domain, ['|', ('company_id', '=', False), ('company_id', '=', company_id or self.env.context.get('company_id'))]])
+        if picking_type:
+            domain = AND([domain, ['|', ('picking_type_id', '=', picking_type.id), ('picking_type_id', '=', False)]])
         if bom_type:
-            domain += [('type', '=', bom_type)]
-        # order to prioritize bom with product_id over the one without
+            domain = AND([domain, [('type', '=', bom_type)]])
         return domain
 
     @api.model
-    def _bom_find(self, product_tmpl=None, product=None, picking_type=None, company_id=False, bom_type=False):
-        """ Finds BoM for particular product, picking and company """
-        if product and product.type == 'service' or product_tmpl and product_tmpl.type == 'service':
-            return self.env['mrp.bom']
-        domain = self._bom_find_domain(product_tmpl=product_tmpl, product=product, picking_type=picking_type, company_id=company_id, bom_type=bom_type)
-        if domain is False:
-            return self.env['mrp.bom']
-        return self.search(domain, order='sequence, product_id', limit=1)
+    def _bom_find(self, products, picking_type=None, company_id=False, bom_type=False):
+        """ Find the first BoM for each products
+
+        :param products: `product.product` recordset
+        :return: One bom (or empty recordset `mrp.bom` if none find) by product (`product.product` record)
+        :rtype: defaultdict(`lambda: self.env['mrp.bom']`)
+        """
+        bom_by_product = defaultdict(lambda: self.env['mrp.bom'])
+        products = products.filtered(lambda p: p.type != 'service')
+        if not products:
+            return bom_by_product
+        domain = self._bom_find_domain(products, picking_type=picking_type, company_id=company_id, bom_type=bom_type)
+
+        # Performance optimization, allow usage of limit and avoid the for loop `bom.product_tmpl_id.product_variant_ids`
+        if len(products) == 1:
+            bom = self.search(domain, order='sequence, product_id, id', limit=1)
+            if bom:
+                bom_by_product[products] = bom
+            return bom_by_product
+
+        boms = self.search(domain, order='sequence, product_id, id')
+
+        products_ids = set(products.ids)
+        for bom in boms:
+            products_implies = bom.product_id or bom.product_tmpl_id.product_variant_ids
+            for product in products_implies:
+                if product.id in products_ids and product not in bom_by_product:
+                    bom_by_product[product] = bom
+
+        return bom_by_product
 
     def explode(self, product, quantity, picking_type=False):
         """
@@ -196,31 +360,26 @@ class MrpBom(models.Model):
             Quantity describes the number of times you need the BoM: so the quantity divided by the number created by the BoM
             and converted into its UoM
         """
-        from collections import defaultdict
-
-        graph = defaultdict(list)
-        V = set()
-
-        def check_cycle(v, visited, recStack, graph):
-            visited[v] = True
-            recStack[v] = True
-            for neighbour in graph[v]:
-                if visited[neighbour] == False:
-                    if check_cycle(neighbour, visited, recStack, graph) == True:
-                        return True
-                elif recStack[neighbour] == True:
-                    return True
-            recStack[v] = False
-            return False
+        product_ids = set()
+        product_boms = {}
+        def update_product_boms():
+            products = self.env['product.product'].browse(product_ids)
+            product_boms.update(self._bom_find(products, picking_type=picking_type or self.picking_type_id,
+                company_id=self.company_id.id, bom_type='phantom'))
+            # Set missing keys to default value
+            for product in products:
+                product_boms.setdefault(product, self.env['mrp.bom'])
 
         boms_done = [(self, {'qty': quantity, 'product': product, 'original_qty': quantity, 'parent_line': False})]
         lines_done = []
-        V |= set([product.product_tmpl_id.id])
 
-        bom_lines = [(bom_line, product, quantity, False) for bom_line in self.bom_line_ids]
+        bom_lines = []
         for bom_line in self.bom_line_ids:
-            V |= set([bom_line.product_id.product_tmpl_id.id])
-            graph[product.product_tmpl_id.id].append(bom_line.product_id.product_tmpl_id.id)
+            product_id = bom_line.product_id
+            bom_lines.append((bom_line, product, quantity, False))
+            product_ids.add(product_id.id)
+        update_product_boms()
+        product_ids.clear()
         while bom_lines:
             current_line, current_product, current_qty, parent_line = bom_lines[0]
             bom_lines = bom_lines[1:]
@@ -229,15 +388,16 @@ class MrpBom(models.Model):
                 continue
 
             line_quantity = current_qty * current_line.product_qty
-            bom = self._bom_find(product=current_line.product_id, picking_type=picking_type or self.picking_type_id, company_id=self.company_id.id, bom_type='phantom')
+            if not current_line.product_id in product_boms:
+                update_product_boms()
+                product_ids.clear()
+            bom = product_boms.get(current_line.product_id)
             if bom:
                 converted_line_quantity = current_line.product_uom_id._compute_quantity(line_quantity / bom.product_qty, bom.product_uom_id)
-                bom_lines = [(line, current_line.product_id, converted_line_quantity, current_line) for line in bom.bom_line_ids] + bom_lines
+                bom_lines += [(line, current_line.product_id, converted_line_quantity, current_line) for line in bom.bom_line_ids]
                 for bom_line in bom.bom_line_ids:
-                    graph[current_line.product_id.product_tmpl_id.id].append(bom_line.product_id.product_tmpl_id.id)
-                    if bom_line.product_id.product_tmpl_id.id in V and check_cycle(bom_line.product_id.product_tmpl_id.id, {key: False for  key in V}, {key: False for  key in V}, graph):
-                        raise UserError(_('Recursion error!  A product with a Bill of Material should not have itself in its BoM or child BoMs!'))
-                    V |= set([bom_line.product_id.product_tmpl_id.id])
+                    if not bom_line.product_id in product_boms:
+                        product_ids.add(bom_line.product_id.id)
                 boms_done.append((bom, {'qty': converted_line_quantity, 'product': current_product, 'original_qty': quantity, 'parent_line': current_line}))
             else:
                 # We round up here because the user expects that if he has to consume a little more, the whole UOM unit
@@ -255,6 +415,66 @@ class MrpBom(models.Model):
             'template': '/mrp/static/xls/mrp_bom.xls'
         }]
 
+    def _set_outdated_bom_in_productions(self):
+        # Searches for MOs using these BoMs to notify them that their BoM has been updated.
+        list_of_domain_by_bom = []
+        for bom in self:
+            domain_by_products = [('product_id', 'in', bom.product_tmpl_id.product_variant_ids.ids)]
+            if bom.product_id:
+                domain_by_products = [('product_id', '=', bom.product_id.id)]
+            domain_for_confirmed_mo = AND([[('state', '=', 'confirmed')], domain_by_products])
+            # Avoid confirmed MOs if the BoM's product was changed.
+            domain_by_states = OR([[('state', '=', 'draft')], domain_for_confirmed_mo])
+            list_of_domain_by_bom.append(AND([[('bom_id', '=', bom.id)], domain_by_states]))
+        if list_of_domain_by_bom:
+            domain = OR(list_of_domain_by_bom)
+            productions = self.env['mrp.production'].search(domain)
+            if productions:
+                productions.is_outdated_bom = True
+
+    # -------------------------------------------------------------------------
+    # CATALOG
+    # -------------------------------------------------------------------------
+
+    def _default_order_line_values(self, child_field=False):
+        default_data = super()._default_order_line_values(child_field)
+        new_default_data = self[child_field]._get_product_catalog_lines_data(default=True)
+
+        return {**default_data, **new_default_data}
+
+    def _get_product_catalog_order_data(self, products, **kwargs):
+        product_catalog = super()._get_product_catalog_order_data(products, **kwargs)
+        for product in products:
+            product_catalog[product.id] |= self._get_product_price_and_data(product)
+        return product_catalog
+
+    def _get_product_price_and_data(self, product):
+        self.ensure_one()
+        return {'price': product.standard_price}
+
+    def _get_product_catalog_record_lines(self, product_ids, child_field=False, **kwargs):
+        if not child_field:
+            return {}
+        lines = self[child_field].filtered(lambda line: line.product_id.id in product_ids)
+        return lines.grouped('product_id')
+
+    def _update_order_line_info(self, product_id, quantity, child_field=False, **kwargs):
+        if not child_field:
+            return 0
+        entity = self[child_field].filtered(lambda line: line.product_id.id == product_id)
+        if entity:
+            if quantity != 0:
+                entity.product_qty = quantity
+            else:
+                entity.unlink()
+        elif quantity > 0:
+            command = Command.create({
+                'product_qty': quantity,
+                'product_id': product_id,
+            })
+            self.write({child_field: [command]})
+
+        return self.env['product.product'].browse(product_id).standard_price
 
 class MrpBomLine(models.Model):
     _name = 'mrp.bom.line'
@@ -267,7 +487,7 @@ class MrpBomLine(models.Model):
         return self.env['uom.uom'].search([], limit=1, order='id').id
 
     product_id = fields.Many2one('product.product', 'Component', required=True, check_company=True)
-    product_tmpl_id = fields.Many2one('product.template', 'Product Template', related='product_id.product_tmpl_id')
+    product_tmpl_id = fields.Many2one('product.template', 'Product Template', related='product_id.product_tmpl_id', store=True, index=True)
     company_id = fields.Many2one(
         related='bom_id.company_id', store=True, index=True, readonly=True)
     product_qty = fields.Float(
@@ -286,7 +506,7 @@ class MrpBomLine(models.Model):
         'mrp.bom', 'Parent BoM',
         index=True, ondelete='cascade', required=True)
     parent_product_tmpl_id = fields.Many2one('product.template', 'Parent Product Template', related='bom_id.product_tmpl_id')
-    possible_bom_product_template_attribute_value_ids = fields.Many2many('product.template.attribute.value', compute='_compute_possible_bom_product_template_attribute_value_ids')
+    possible_bom_product_template_attribute_value_ids = fields.Many2many(related='bom_id.possible_product_template_attribute_value_ids')
     bom_product_template_attribute_value_ids = fields.Many2many(
         'product.template.attribute.value', string="Apply on Variants", ondelete='restrict',
         domain="[('id', 'in', possible_bom_product_template_attribute_value_ids)]",
@@ -302,31 +522,28 @@ class MrpBomLine(models.Model):
         'mrp.bom.line', string="BOM lines of the referred bom",
         compute='_compute_child_line_ids')
     attachments_count = fields.Integer('Attachments Count', compute='_compute_attachments_count')
+    tracking = fields.Selection(related='product_id.tracking')
+    manual_consumption = fields.Boolean(
+        'Manual Consumption', default=False,
+        readonly=False, store=True, copy=True,
+        help="When activated, then the registration of consumption for that component is recorded manually exclusively.\n"
+             "If not activated, and any of the components consumption is edited manually on the manufacturing order, Odoo assumes manual consumption also.")
 
     _sql_constraints = [
         ('bom_qty_zero', 'CHECK (product_qty>=0)', 'All product quantities must be greater or equal to 0.\n'
             'Lines with 0 quantities can be used as optional lines. \n'
-            'You should install the mrp_byproduct module if you want to manage extra products on BoMs !'),
+            'You should install the mrp_byproduct module if you want to manage extra products on BoMs!'),
     ]
 
-    @api.depends(
-        'parent_product_tmpl_id.attribute_line_ids.value_ids',
-        'parent_product_tmpl_id.attribute_line_ids.attribute_id.create_variant',
-        'parent_product_tmpl_id.attribute_line_ids.product_template_value_ids.ptav_active',
-    )
-    def _compute_possible_bom_product_template_attribute_value_ids(self):
-        for line in self:
-            line.possible_bom_product_template_attribute_value_ids = line.parent_product_tmpl_id.valid_product_template_attribute_line_ids._without_no_variant_attributes().product_template_value_ids._only_active()
-
     @api.depends('product_id', 'bom_id')
     def _compute_child_bom_id(self):
+        products = self.product_id
+        bom_by_product = self.env['mrp.bom']._bom_find(products)
         for line in self:
             if not line.product_id:
                 line.child_bom_id = False
             else:
-                line.child_bom_id = self.env['mrp.bom']._bom_find(
-                    product_tmpl=line.product_id.product_tmpl_id,
-                    product=line.product_id)
+                line.child_bom_id = bom_by_product.get(line.product_id, False)
 
     @api.depends('product_id')
     def _compute_attachments_count(self):
@@ -367,20 +584,12 @@ class MrpBomLine(models.Model):
 
     def _skip_bom_line(self, product):
         """ Control if a BoM line should be produced, can be inherited to add
-        custom control. It currently checks that all variant values are in the
-        product.
-
-        If multiple values are encoded for the same attribute line, only one of
-        them has to be found on the variant.
+        custom control.
         """
         self.ensure_one()
         if product._name == 'product.template':
             return False
-        if self.bom_product_template_attribute_value_ids:
-            for ptal, iter_ptav in groupby(self.bom_product_template_attribute_value_ids.sorted('attribute_line_id'), lambda ptav: ptav.attribute_line_id):
-                if not any(ptav in product.product_template_attribute_value_ids for ptav in iter_ptav):
-                    return True
-        return False
+        return not product._match_all_variant_values(self.bom_product_template_attribute_value_ids)
 
     def action_see_attachments(self):
         domain = [
@@ -405,38 +614,104 @@ class MrpBomLine(models.Model):
             'context': "{'default_res_model': '%s','default_res_id': %d, 'default_company_id': %s}" % ('product.product', self.product_id.id, self.company_id.id)
         }
 
+    # -------------------------------------------------------------------------
+    # CATALOG
+    # -------------------------------------------------------------------------
+
+    def action_add_from_catalog(self):
+        bom = self.env['mrp.bom'].browse(self.env.context.get('order_id'))
+        return bom.with_context(child_field='bom_line_ids').action_add_from_catalog()
+
+    def _get_product_catalog_lines_data(self, default=False, **kwargs):
+        if self and not default:
+            self.product_id.ensure_one()
+            return {
+                **self[0].bom_id._get_product_price_and_data(self[0].product_id),
+                'quantity': sum(
+                    self.mapped(
+                        lambda line: line.product_uom_id._compute_quantity(
+                            qty=line.product_qty,
+                            to_unit=line.product_uom_id,
+                        )
+                    )
+                ),
+                'readOnly': len(self) > 1,
+            }
+        return {
+            'quantity': 0,
+        }
+
 
 class MrpByProduct(models.Model):
     _name = 'mrp.bom.byproduct'
     _description = 'Byproduct'
     _rec_name = "product_id"
     _check_company_auto = True
+    _order = 'sequence, id'
 
     product_id = fields.Many2one('product.product', 'By-product', required=True, check_company=True)
     company_id = fields.Many2one(related='bom_id.company_id', store=True, index=True, readonly=True)
     product_qty = fields.Float(
         'Quantity',
         default=1.0, digits='Product Unit of Measure', required=True)
-    product_uom_id = fields.Many2one('uom.uom', 'Unit of Measure', required=True)
+    product_uom_category_id = fields.Many2one(related='product_id.uom_id.category_id')
+    product_uom_id = fields.Many2one('uom.uom', 'Unit of Measure', required=True,
+                                     compute="_compute_product_uom_id", store=True, readonly=False, precompute=True,
+                                     domain="[('category_id', '=', product_uom_category_id)]")
     bom_id = fields.Many2one('mrp.bom', 'BoM', ondelete='cascade', index=True)
     allowed_operation_ids = fields.One2many('mrp.routing.workcenter', related='bom_id.operation_ids')
     operation_id = fields.Many2one(
         'mrp.routing.workcenter', 'Produced in Operation', check_company=True,
         domain="[('id', 'in', allowed_operation_ids)]")
+    possible_bom_product_template_attribute_value_ids = fields.Many2many(related='bom_id.possible_product_template_attribute_value_ids')
+    bom_product_template_attribute_value_ids = fields.Many2many(
+        'product.template.attribute.value', string="Apply on Variants", ondelete='restrict',
+        domain="[('id', 'in', possible_bom_product_template_attribute_value_ids)]",
+        help="BOM Product Variants needed to apply this line.")
+    sequence = fields.Integer("Sequence")
+    cost_share = fields.Float(
+        "Cost Share (%)", digits=(5, 2),  # decimal = 2 is important for rounding calculations!!
+        help="The percentage of the final production cost for this by-product line (divided between the quantity produced)."
+             "The total of all by-products' cost share must be less than or equal to 100.")
 
-    @api.onchange('product_id')
-    def onchange_product_id(self):
+    @api.depends('product_id')
+    def _compute_product_uom_id(self):
         """ Changes UoM if product_id changes. """
-        if self.product_id:
-            self.product_uom_id = self.product_id.uom_id.id
+        for record in self:
+            record.product_uom_id = record.product_id.uom_id.id
 
-    @api.onchange('product_uom_id')
-    def onchange_uom(self):
-        res = {}
-        if self.product_uom_id and self.product_id and self.product_uom_id.category_id != self.product_id.uom_id.category_id:
-            res['warning'] = {
-                'title': _('Warning'),
-                'message': _('The unit of measure you choose is in a different category than the product unit of measure.')
+    def _skip_byproduct_line(self, product):
+        """ Control if a byproduct line should be produced, can be inherited to add
+        custom control.
+        """
+        self.ensure_one()
+        if product._name == 'product.template':
+            return False
+        return not product._match_all_variant_values(self.bom_product_template_attribute_value_ids)
+
+    # -------------------------------------------------------------------------
+    # CATALOG
+    # -------------------------------------------------------------------------
+
+    def action_add_from_catalog(self):
+        bom = self.env['mrp.bom'].browse(self.env.context.get('order_id'))
+        return bom.with_context(child_field='byproduct_ids').action_add_from_catalog()
+
+    def _get_product_catalog_lines_data(self, default=False, **kwargs):
+        if self and not default:
+            self.product_id.ensure_one()
+            return {
+                **self[0].bom_id._get_product_price_and_data(self[0].product_id),
+                'quantity': sum(
+                    self.mapped(
+                        lambda line: line.product_uom_id._compute_quantity(
+                            qty=line.product_qty,
+                            to_unit=line.product_uom_id,
+                        )
+                    )
+                ),
+                'readOnly': len(self) > 1
             }
-            self.product_uom_id = self.product_id.uom_id.id
-        return res
+        return {
+            'quantity': 0,
+        }

--- a/addons/mrp/models/mrp_document.py
+++ b/addons/mrp/models/mrp_document.py
@@ -15,10 +15,24 @@ class MrpDocument(models.Model):
     }
     _order = "priority desc, id desc"
 
+    def copy_data(self, default=None):
+        vals_list = super().copy_data(default=default)
+        ir_default = default
+        if ir_default:
+            ir_fields = list(self.env['ir.attachment']._fields)
+            ir_default = {field: default[field] for field in default if field in ir_fields}
+        for document, vals in zip(self, vals_list):
+            vals['ir_attachment_id'] = document.ir_attachment_id.with_context(no_document=True).copy(ir_default).id
+        return vals_list
+
     ir_attachment_id = fields.Many2one('ir.attachment', string='Related attachment', required=True, ondelete='cascade')
     active = fields.Boolean('Active', default=True)
     priority = fields.Selection([
         ('0', 'Normal'),
         ('1', 'Low'),
         ('2', 'High'),
-        ('3', 'Very High')], string="Priority", help='Gives the sequence order when displaying a list of MRP documents.')
+        ('3', 'Very High')], string="Priority") # used to order
+
+    def unlink(self):
+        self.mapped('ir_attachment_id').unlink()
+        return super(MrpDocument, self).unlink()

--- a/addons/mrp/models/mrp_production.py
+++ b/addons/mrp/models/mrp_production.py
@@ -6,13 +6,16 @@ import datetime
 import math
 import re
 
+from ast import literal_eval
 from collections import defaultdict
 from dateutil.relativedelta import relativedelta
 
-from odoo import api, fields, models, _
-from odoo.exceptions import AccessError, UserError
+from odoo import api, fields, models, _, Command
+from odoo.addons.web.controllers.utils import clean_action
+from odoo.exceptions import UserError, ValidationError
+from odoo.osv import expression
 from odoo.tools import float_compare, float_round, float_is_zero, format_datetime
-from odoo.tools.misc import format_date
+from odoo.tools.misc import OrderedSet, format_date, groupby as tools_groupby
 
 from odoo.addons.stock.models.stock_move import PROCUREMENT_PRIORITIES
 
@@ -23,124 +26,99 @@ class MrpProduction(models.Model):
     """ Manufacturing Orders """
     _name = 'mrp.production'
     _description = 'Production Order'
-    _date_name = 'date_planned_start'
-    _inherit = ['mail.thread', 'mail.activity.mixin']
-    _order = 'priority desc, date_planned_start asc,id'
+    _date_name = 'date_start'
+    _inherit = ['mail.thread', 'mail.activity.mixin', 'product.catalog.mixin']
+    _order = 'priority desc, date_start asc,id'
 
     @api.model
-    def _get_default_picking_type(self):
-        company_id = self.env.context.get('default_company_id', self.env.company.id)
-        return self.env['stock.picking.type'].search([
-            ('code', '=', 'mrp_operation'),
-            ('warehouse_id.company_id', '=', company_id),
-        ], limit=1).id
-
-    @api.model
-    def _get_default_location_src_id(self):
-        location = False
-        company_id = self.env.context.get('default_company_id', self.env.company.id)
-        if self.env.context.get('default_picking_type_id'):
-            location = self.env['stock.picking.type'].browse(self.env.context['default_picking_type_id']).default_location_src_id
-        if not location:
-            location = self.env['stock.warehouse'].search([('company_id', '=', company_id)], limit=1).lot_stock_id
-        return location and location.id or False
-
-    @api.model
-    def _get_default_location_dest_id(self):
-        location = False
-        company_id = self.env.context.get('default_company_id', self.env.company.id)
-        if self._context.get('default_picking_type_id'):
-            location = self.env['stock.picking.type'].browse(self.env.context['default_picking_type_id']).default_location_dest_id
-        if not location:
-            location = self.env['stock.warehouse'].search([('company_id', '=', company_id)], limit=1).lot_stock_id
-        return location and location.id or False
-
-    @api.model
-    def _get_default_date_planned_finished(self):
-        if self.env.context.get('default_date_planned_start'):
-            return fields.Datetime.to_datetime(self.env.context.get('default_date_planned_start')) + datetime.timedelta(hours=1)
-        return datetime.datetime.now() + datetime.timedelta(hours=1)
+    def _get_default_date_start(self):
+        if self.env.context.get('default_date_deadline'):
+            date_finished = fields.Datetime.to_datetime(self.env.context.get('default_date_deadline'))
+            date_start = date_finished - relativedelta(hours=1)
+            return date_start
+        return fields.Datetime.now()
 
     @api.model
-    def _get_default_date_planned_start(self):
+    def _get_default_date_finished(self):
         if self.env.context.get('default_date_deadline'):
             return fields.Datetime.to_datetime(self.env.context.get('default_date_deadline'))
-        return datetime.datetime.now()
+        date_start = fields.Datetime.now()
+        date_finished = date_start + relativedelta(hours=1)
+        return date_finished
 
     @api.model
     def _get_default_is_locked(self):
-        return self.user_has_groups('mrp.group_locked_by_default')
+        return not self.env.user.has_group('mrp.group_unlocked_by_default')
 
-    name = fields.Char(
-        'Reference', copy=False, readonly=True, default=lambda x: _('New'))
+    name = fields.Char('Reference', default='New', copy=False, readonly=True)
     priority = fields.Selection(
         PROCUREMENT_PRIORITIES, string='Priority', default='0',
         help="Components will be reserved first for the MO with the highest priorities.")
     backorder_sequence = fields.Integer("Backorder Sequence", default=0, copy=False, help="Backorder sequence, if equals to 0 means there is not related backorder")
     origin = fields.Char(
         'Source', copy=False,
-        states={'done': [('readonly', True)], 'cancel': [('readonly', True)]},
         help="Reference of the document that generated this production order request.")
 
     product_id = fields.Many2one(
         'product.product', 'Product',
-        domain="[('id', 'in', allowed_product_ids)]",
-        readonly=True, required=True, check_company=True,
-        states={'draft': [('readonly', False)]})
+        domain="[('type', 'in', ['product', 'consu'])]",
+        compute='_compute_product_id', store=True, copy=True, precompute=True,
+        readonly=False, required=True, check_company=True)
+    product_variant_attributes = fields.Many2many('product.template.attribute.value', related='product_id.product_template_attribute_value_ids')
+    workcenter_id = fields.Many2one('mrp.workcenter', store=False)  # Only used for search in view_mrp_production_filter
     product_tracking = fields.Selection(related='product_id.tracking')
-    allowed_product_ids = fields.Many2many('product.product', compute='_compute_allowed_product_ids')
     product_tmpl_id = fields.Many2one('product.template', 'Product Template', related='product_id.product_tmpl_id')
     product_qty = fields.Float(
-        'Quantity To Produce',
-        default=1.0, digits='Product Unit of Measure',
-        readonly=True, required=True, tracking=True,
-        states={'draft': [('readonly', False)]})
+        'Quantity To Produce', digits='Product Unit of Measure',
+        readonly=False, required=True, tracking=True, precompute=True,
+        compute='_compute_product_qty', store=True, copy=True)
     product_uom_id = fields.Many2one(
         'uom.uom', 'Product Unit of Measure',
-        readonly=True, required=True,
-        states={'draft': [('readonly', False)]}, domain="[('category_id', '=', product_uom_category_id)]")
+        readonly=False, required=True, compute='_compute_uom_id', store=True, copy=True, precompute=True,
+        domain="[('category_id', '=', product_uom_category_id)]")
     lot_producing_id = fields.Many2one(
-        'stock.production.lot', string='Lot/Serial Number', copy=False,
-        domain="[('product_id', '=', product_id), ('company_id', '=', company_id)]", check_company=True)
+        'stock.lot', string='Lot/Serial Number', copy=False,
+        domain="[('product_id', '=', product_id)]", check_company=True)
     qty_producing = fields.Float(string="Quantity Producing", digits='Product Unit of Measure', copy=False)
     product_uom_category_id = fields.Many2one(related='product_id.uom_id.category_id')
     product_uom_qty = fields.Float(string='Total Quantity', compute='_compute_product_uom_qty', store=True)
     picking_type_id = fields.Many2one(
-        'stock.picking.type', 'Operation Type',
-        domain="[('code', '=', 'mrp_operation'), ('company_id', '=', company_id)]",
-        default=_get_default_picking_type, required=True, check_company=True)
+        'stock.picking.type', 'Operation Type', copy=True, readonly=False,
+        compute='_compute_picking_type_id', store=True, precompute=True,
+        domain="[('code', '=', 'mrp_operation')]",
+        required=True, check_company=True, index=True)
     use_create_components_lots = fields.Boolean(related='picking_type_id.use_create_components_lots')
     location_src_id = fields.Many2one(
         'stock.location', 'Components Location',
-        default=_get_default_location_src_id,
-        readonly=True, required=True,
-        domain="[('usage','=','internal'), '|', ('company_id', '=', False), ('company_id', '=', company_id)]",
-        states={'draft': [('readonly', False)]}, check_company=True,
+        compute='_compute_locations', store=True, check_company=True,
+        readonly=False, required=True, precompute=True,
+        domain="[('usage','=','internal')]",
         help="Location where the system will look for components.")
+    # this field was added to be passed a default in view for manual raw moves
+    warehouse_id = fields.Many2one(related='location_src_id.warehouse_id')
     location_dest_id = fields.Many2one(
         'stock.location', 'Finished Products Location',
-        default=_get_default_location_dest_id,
-        readonly=True, required=True,
-        domain="[('usage','=','internal'), '|', ('company_id', '=', False), ('company_id', '=', company_id)]",
-        states={'draft': [('readonly', False)]}, check_company=True,
+        compute='_compute_locations', store=True, check_company=True,
+        readonly=False, required=True, precompute=True,
+        domain="[('usage','=','internal')]",
         help="Location where the system will stock the finished products.")
-    date_planned_start = fields.Datetime(
-        'Scheduled Date', copy=False, default=_get_default_date_planned_start,
-        help="Date at which you plan to start the production.",
-        index=True, required=True)
-    date_planned_finished = fields.Datetime(
-        'Scheduled End Date',
-        default=_get_default_date_planned_finished,
-        help="Date at which you plan to finish the production.",
-        copy=False)
+    location_final_id = fields.Many2one('stock.location', 'Final Location from procurement')
     date_deadline = fields.Datetime(
-        'Deadline', copy=False, store=True, readonly=True, compute='_compute_date_deadline', inverse='_set_date_deadline',
+        'Deadline', copy=False, store=True, readonly=True, compute='_compute_date_deadline',
         help="Informative date allowing to define when the manufacturing order should be processed at the latest to fulfill delivery on time.")
-    date_start = fields.Datetime('Start Date', copy=False, readonly=True, help="Date of the WO")
-    date_finished = fields.Datetime('End Date', copy=False, readonly=True, help="Date when the MO has been close")
+    date_start = fields.Datetime(
+        'Start', copy=False, default=_get_default_date_start,
+        help="Date you plan to start production or date you actually started production.",
+        index=True, required=True)
+    date_finished = fields.Datetime(
+        'End', copy=False, default=_get_default_date_finished,
+        compute='_compute_date_finished', store=True,
+        help="Date you expect to finish production or actual date you finished production.")
+    duration_expected = fields.Float("Expected Duration", help="Total expected duration (in minutes)", compute='_compute_duration_expected')
+    duration = fields.Float("Real Duration", help="Total real duration (in minutes)", compute='_compute_duration')
+
     bom_id = fields.Many2one(
-        'mrp.bom', 'Bill of Material',
-        readonly=True, states={'draft': [('readonly', False)]},
+        'mrp.bom', 'Bill of Material', readonly=False,
         domain="""[
         '&',
             '|',
@@ -153,8 +131,8 @@ class MrpProduction(models.Model):
                         ('product_tmpl_id.product_variant_ids','=',product_id),
                         ('product_id','=',False),
         ('type', '=', 'normal')]""",
-        check_company=True,
-        help="Bill of Materials allow you to define the list of required components to make a finished product.")
+        check_company=True, compute='_compute_bom_id', store=True, precompute=True,
+        help="Bills of Materials, also called recipes, are used to autocomplete components and work order instructions.")
 
     state = fields.Selection([
         ('draft', 'Draft'),
@@ -175,28 +153,29 @@ class MrpProduction(models.Model):
         ('confirmed', 'Waiting'),
         ('assigned', 'Ready'),
         ('waiting', 'Waiting Another Operation')],
-        string='Material Availability',
-        compute='_compute_state', copy=False, index=True, readonly=True,
+        string='MO Readiness',
+        compute='_compute_reservation_state', copy=False, index=True, readonly=True,
         store=True, tracking=True,
-        help=" * Ready: The material is available to start the production.\n\
-            * Waiting: The material is not available to start the production.\n\
-            The material availability is impacted by the manufacturing readiness\
-            defined on the BoM.")
+        help="Manufacturing readiness for this MO, as per bill of material configuration:\n\
+            * Ready: The material is available to start the production.\n\
+            * Waiting: The material is not available to start the production.\n")
 
     move_raw_ids = fields.One2many(
         'stock.move', 'raw_material_production_id', 'Components',
-        copy=True, states={'done': [('readonly', True)], 'cancel': [('readonly', True)]},
+        compute='_compute_move_raw_ids', store=True, readonly=False,
+        copy=False,
         domain=[('scrapped', '=', False)])
     move_finished_ids = fields.One2many(
-        'stock.move', 'production_id', 'Finished Products',
-        copy=True, states={'done': [('readonly', True)], 'cancel': [('readonly', True)]},
+        'stock.move', 'production_id', 'Finished Products', readonly=False,
+        compute='_compute_move_finished_ids', store=True, copy=False,
         domain=[('scrapped', '=', False)])
     move_byproduct_ids = fields.One2many('stock.move', compute='_compute_move_byproduct_ids', inverse='_set_move_byproduct_ids')
     finished_move_line_ids = fields.One2many(
         'stock.move.line', compute='_compute_lines', inverse='_inverse_lines', string="Finished Product"
         )
     workorder_ids = fields.One2many(
-        'mrp.workorder', 'production_id', 'Work Orders', copy=True)
+        'mrp.workorder', 'production_id', 'Work Orders', copy=True,
+        compute='_compute_workorder_ids', store=True, readonly=False)
     move_dest_ids = fields.One2many('stock.move', 'created_production_id',
         string="Stock Movements of Produced Goods")
 
@@ -208,7 +187,6 @@ class MrpProduction(models.Model):
         help='Technical field to check when we can reserve quantities')
     user_id = fields.Many2one(
         'res.users', 'Responsible', default=lambda self: self.env.user,
-        states={'done': [('readonly', True)], 'cancel': [('readonly', True)]},
         domain=lambda self: [('groups_id', 'in', self.env.ref('mrp.group_mrp_user').id)])
     company_id = fields.Many2one(
         'res.company', 'Company', default=lambda self: self.env.company,
@@ -219,7 +197,7 @@ class MrpProduction(models.Model):
         'procurement.group', 'Procurement Group',
         copy=False)
     product_description_variants = fields.Char('Custom Description')
-    orderpoint_id = fields.Many2one('stock.warehouse.orderpoint', 'Orderpoint')
+    orderpoint_id = fields.Many2one('stock.warehouse.orderpoint', 'Orderpoint', copy=False, index='btree_not_null')
     propagate_cancel = fields.Boolean(
         'Propagate cancel and split',
         help='If checked, when the previous move of the move (which was generated by a next procurement) is cancelled or split, the move generated by this move will too')
@@ -227,6 +205,8 @@ class MrpProduction(models.Model):
     json_popover = fields.Char('JSON data for the popover widget', compute='_compute_json_popover')
     scrap_ids = fields.One2many('stock.scrap', 'production_id', 'Scraps')
     scrap_count = fields.Integer(compute='_compute_scrap_move_count', string='Scrap Move')
+    unbuild_ids = fields.One2many('mrp.unbuild', 'mo_id', 'Unbuilds')
+    unbuild_count = fields.Integer(compute='_compute_unbuild_count', string='Number of Unbuilds')
     is_locked = fields.Boolean('Is Locked', default=_get_default_is_locked, copy=False)
     is_planned = fields.Boolean('Its Operations are Planned', compute="_compute_is_planned", store=True)
 
@@ -249,93 +229,222 @@ class MrpProduction(models.Model):
     mrp_production_backorder_count = fields.Integer("Count of linked backorder", compute='_compute_mrp_production_backorder')
     show_lock = fields.Boolean('Show Lock/unlock buttons', compute='_compute_show_lock')
     components_availability = fields.Char(
-        string="Component Availability", compute='_compute_components_availability')
+        string="Component Status", compute='_compute_components_availability',
+        help="Latest component availability status for this MO. If green, then the MO's readiness status is ready, as per BOM configuration.")
     components_availability_state = fields.Selection([
         ('available', 'Available'),
         ('expected', 'Expected'),
-        ('late', 'Late')], compute='_compute_components_availability')
+        ('late', 'Late'),
+        ('unavailable', 'Not Available')], compute='_compute_components_availability', search='_search_components_availability_state')
+    production_capacity = fields.Float(compute='_compute_production_capacity', help="Quantity that can be produced with the current stock of components")
     show_lot_ids = fields.Boolean('Display the serial number shortcut on the moves', compute='_compute_show_lot_ids')
+    forecasted_issue = fields.Boolean(compute='_compute_forecasted_issue')
+    show_allocation = fields.Boolean(
+        compute='_compute_show_allocation',
+        help='Technical Field used to decide whether the button "Allocation" should be displayed.')
+    allow_workorder_dependencies = fields.Boolean('Allow Work Order Dependencies')
+    show_produce = fields.Boolean(compute='_compute_show_produce', help='Technical field to check if produce button can be shown')
+    show_produce_all = fields.Boolean(compute='_compute_show_produce', help='Technical field to check if produce all button can be shown')
+    is_outdated_bom = fields.Boolean("Outdated BoM", help="The BoM has been updated since creation of the MO")
+    is_delayed = fields.Boolean(compute='_compute_is_delayed', search='_search_is_delayed')
 
-    @api.depends('product_id', 'bom_id', 'company_id')
-    def _compute_allowed_product_ids(self):
-        for production in self:
-            product_domain = [
-                ('type', 'in', ['product', 'consu']),
-                '|',
-                    ('company_id', '=', False),
-                    ('company_id', '=', production.company_id.id)
-            ]
-            if production.bom_id:
-                if production.bom_id.product_id:
-                    product_domain += [('id', '=', production.bom_id.product_id.id)]
-                else:
-                    product_domain += [('id', 'in', production.bom_id.product_tmpl_id.product_variant_ids.ids)]
-            production.allowed_product_ids = self.env['product.product'].search(product_domain)
+    _sql_constraints = [
+        ('name_uniq', 'unique(name, company_id)', 'Reference must be unique per Company!'),
+        ('qty_positive', 'check (product_qty > 0)', 'The quantity to produce must be positive!'),
+    ]
 
-    @api.depends('procurement_group_id.stock_move_ids.created_production_id.procurement_group_id.mrp_production_ids')
+    @api.depends('procurement_group_id.stock_move_ids.created_production_id.procurement_group_id.mrp_production_ids',
+                 'procurement_group_id.stock_move_ids.move_orig_ids.created_production_id.procurement_group_id.mrp_production_ids')
     def _compute_mrp_production_child_count(self):
         for production in self:
-            production.mrp_production_child_count = len(production.procurement_group_id.stock_move_ids.created_production_id.procurement_group_id.mrp_production_ids)
+            production.mrp_production_child_count = len(production._get_children())
 
-    @api.depends('move_dest_ids.group_id.mrp_production_ids')
+    @api.depends('procurement_group_id.mrp_production_ids.move_dest_ids.group_id.mrp_production_ids',
+                 'procurement_group_id.stock_move_ids.move_dest_ids.group_id.mrp_production_ids')
     def _compute_mrp_production_source_count(self):
         for production in self:
-            production.mrp_production_source_count = len(production.procurement_group_id.mrp_production_ids.move_dest_ids.group_id.mrp_production_ids)
+            production.mrp_production_source_count = len(production._get_sources())
 
     @api.depends('procurement_group_id.mrp_production_ids')
     def _compute_mrp_production_backorder(self):
         for production in self:
             production.mrp_production_backorder_count = len(production.procurement_group_id.mrp_production_ids)
 
-    @api.depends('move_raw_ids', 'state', 'date_planned_start', 'move_raw_ids.forecast_availability', 'move_raw_ids.forecast_expected_date')
+    @api.depends('company_id', 'bom_id')
+    def _compute_picking_type_id(self):
+        domain = [
+            ('code', '=', 'mrp_operation'),
+            ('warehouse_id.company_id', 'in', self.company_id.ids),
+        ]
+        picking_types = self.env['stock.picking.type'].search_read(domain, ['company_id'], load=False, limit=1)
+        picking_type_by_company = {pt['company_id']: pt['id'] for pt in picking_types}
+        default_picking_type_id = self._context.get('default_picking_type_id')
+        default_picking_type = default_picking_type_id and self.env['stock.picking.type'].browse(default_picking_type_id)
+        for mo in self:
+            if default_picking_type and default_picking_type.company_id == mo.company_id:
+                mo.picking_type_id = default_picking_type_id
+                continue
+            if mo.bom_id and mo.bom_id.picking_type_id:
+                mo.picking_type_id = mo.bom_id.picking_type_id
+                continue
+            if mo.picking_type_id and mo.picking_type_id.company_id == mo.company_id:
+                continue
+            mo.picking_type_id = picking_type_by_company.get(mo.company_id.id, False)
+
+    @api.depends('bom_id', 'product_id')
+    def _compute_uom_id(self):
+        for production in self:
+            if production.state != 'draft':
+                continue
+            if production.bom_id and production._origin.bom_id != production.bom_id:
+                production.product_uom_id = production.bom_id.product_uom_id
+            elif production.product_id:
+                production.product_uom_id = production.product_id.uom_id
+            else:
+                production.product_uom_id = False
+
+    @api.depends('picking_type_id')
+    def _compute_locations(self):
+        for production in self:
+            if not production.picking_type_id.default_location_src_id or not production.picking_type_id.default_location_dest_id:
+                company_id = production.company_id.id if (production.company_id and production.company_id in self.env.companies) else self.env.company.id
+                fallback_loc = self.env['stock.warehouse'].search([('company_id', '=', company_id)], limit=1).lot_stock_id
+            production.location_src_id = production.picking_type_id.default_location_src_id.id or fallback_loc.id
+            production.location_dest_id = production.picking_type_id.default_location_dest_id.id or fallback_loc.id
+
+    def _search_components_availability_state(self, operator, value):
+
+        def _get_comparison_date(move):
+            return move.raw_material_production_id.date_start
+
+        if operator == '!=' and not value:
+            raise UserError(_('Operator not supported without a value.'))
+        elif operator == '=' and not value:
+            raw_stock_moves = self.env['stock.move'].search([
+                ('raw_material_production_id', '!=', False),
+                ('raw_material_production_id.state', 'in', ('cancel', 'done', 'draft'))])
+            return [('move_raw_ids', 'in', raw_stock_moves.ids)]
+
+        selected_production_ids = []
+        for prod in self.env['mrp.production'].search([('state', 'not in', ('done', 'cancel', 'draft'))]):
+            if prod.move_raw_ids._match_searched_availability(operator, value, _get_comparison_date):
+                selected_production_ids.append(prod.id)
+        return [('id', 'in', selected_production_ids)]
+
+    @api.depends('state', 'reservation_state', 'date_start', 'move_raw_ids', 'move_raw_ids.forecast_availability', 'move_raw_ids.forecast_expected_date')
     def _compute_components_availability(self):
-        self.components_availability = False
-        self.components_availability_state = 'available'
-        productions = self.filtered(lambda mo: mo.state not in ['cancel', 'draft', 'done'])
+        productions = self.filtered(lambda mo: mo.state not in ('cancel', 'done', 'draft'))
+        productions.components_availability_state = 'available'
         productions.components_availability = _('Available')
+
+        other_productions = self - productions
+        other_productions.components_availability = False
+        other_productions.components_availability_state = False
+
+        all_raw_moves = productions.move_raw_ids
+        # Force to prefetch more than 1000 by 1000
+        all_raw_moves._fields['forecast_availability'].compute_value(all_raw_moves)
         for production in productions:
-            forecast_date = max(production.move_raw_ids.filtered('forecast_expected_date').mapped('forecast_expected_date'), default=False)
-            if any(float_compare(move.forecast_availability, move.product_qty, move.product_id.uom_id.rounding) == -1 for move in production.move_raw_ids):
+            if any(float_compare(move.forecast_availability, 0 if move.state == 'draft' else move.product_qty, precision_rounding=move.product_id.uom_id.rounding) == -1 for move in production.move_raw_ids):
                 production.components_availability = _('Not Available')
-                production.components_availability_state = 'late'
-            elif forecast_date:
-                production.components_availability = _('Exp %s', format_date(self.env, forecast_date))
-                production.components_availability_state = 'late' if forecast_date > production.date_planned_start else 'expected'
+                production.components_availability_state = 'unavailable'
+            else:
+                forecast_date = max(production.move_raw_ids.filtered('forecast_expected_date').mapped('forecast_expected_date'), default=False)
+                if forecast_date:
+                    production.components_availability = _('Exp %s', format_date(self.env, forecast_date))
+                    if production.date_start:
+                        production.components_availability_state = 'late' if forecast_date > production.date_start else 'expected'
+
+    @api.depends('bom_id')
+    def _compute_product_id(self):
+        for production in self:
+            bom = production.bom_id
+            if bom and (
+                not production.product_id or bom.product_tmpl_id != production.product_tmpl_id
+                or bom.product_id and bom.product_id != production.product_id
+            ):
+                production.product_id = bom.product_id or bom.product_tmpl_id.product_variant_id
+
+    @api.depends('product_id')
+    def _compute_bom_id(self):
+        mo_by_company_id = defaultdict(lambda: self.env['mrp.production'])
+        for mo in self:
+            if not mo.product_id and not mo.bom_id:
+                mo.bom_id = False
+                continue
+            mo_by_company_id[mo.company_id.id] |= mo
+
+        for company_id, productions in mo_by_company_id.items():
+            picking_type_id = self._context.get('default_picking_type_id')
+            picking_type = picking_type_id and self.env['stock.picking.type'].browse(picking_type_id)
+            boms_by_product = self.env['mrp.bom'].with_context(active_test=True)._bom_find(productions.product_id, picking_type=picking_type, company_id=company_id, bom_type='normal')
+            for production in productions:
+                if not production.bom_id or production.bom_id.product_tmpl_id != production.product_tmpl_id or (production.bom_id.product_id and production.bom_id.product_id != production.product_id):
+                    bom = boms_by_product[production.product_id]
+                    production.bom_id = bom.id or False
+                    self.env.add_to_compute(production._fields['picking_type_id'], production)
+
+    @api.depends('bom_id')
+    def _compute_product_qty(self):
+        for production in self:
+            if production.state != 'draft':
+                continue
+            if production.bom_id and production._origin.bom_id != production.bom_id:
+                production.product_qty = production.bom_id.product_qty
+            elif not production.bom_id:
+                production.product_qty = 1.0
+
+    @api.depends('move_raw_ids')
+    def _compute_production_capacity(self):
+        for production in self:
+            production.production_capacity = production.product_qty
+            moves = production.move_raw_ids.filtered(lambda move: move.unit_factor and move.product_id.type != 'consu')
+            if moves:
+                production_capacity = min(moves.mapped(lambda move: move.product_id.uom_id._compute_quantity(move.product_id.qty_available, move.product_uom) / move.unit_factor))
+                production.production_capacity = min(production.product_qty, float_round(production_capacity, precision_rounding=production.product_id.uom_id.rounding))
 
     @api.depends('move_finished_ids.date_deadline')
     def _compute_date_deadline(self):
         for production in self:
             production.date_deadline = min(production.move_finished_ids.filtered('date_deadline').mapped('date_deadline'), default=production.date_deadline or False)
 
-    def _set_date_deadline(self):
+    @api.depends('workorder_ids.duration_expected')
+    def _compute_duration_expected(self):
         for production in self:
-            production.move_finished_ids.date_deadline = production.date_deadline
+            production.duration_expected = sum(production.workorder_ids.mapped('duration_expected'))
 
-    @api.depends("workorder_ids.date_planned_start", "workorder_ids.date_planned_finished")
+    @api.depends('workorder_ids.duration')
+    def _compute_duration(self):
+        for production in self:
+            production.duration = sum(production.workorder_ids.mapped('duration'))
+
+    @api.depends("workorder_ids.date_start", "workorder_ids.date_finished")
     def _compute_is_planned(self):
         for production in self:
             if production.workorder_ids:
-                production.is_planned = any(wo.date_planned_start and wo.date_planned_finished for wo in production.workorder_ids)
+                production.is_planned = any(wo.date_start and wo.date_finished for wo in production.workorder_ids)
             else:
                 production.is_planned = False
 
     @api.depends('move_raw_ids.delay_alert_date')
     def _compute_delay_alert_date(self):
-        delay_alert_date_data = self.env['stock.move'].read_group([('id', 'in', self.move_raw_ids.ids), ('delay_alert_date', '!=', False)], ['delay_alert_date:max'], 'raw_material_production_id')
-        delay_alert_date_data = {data['raw_material_production_id'][0]: data['delay_alert_date'] for data in delay_alert_date_data}
+        delay_alert_date_data = self.env['stock.move']._read_group([('id', 'in', self.move_raw_ids.ids), ('delay_alert_date', '!=', False)], ['raw_material_production_id'], ['delay_alert_date:max'])
+        delay_alert_date_data = {raw_material_production.id: delay_alert_date_max for raw_material_production, delay_alert_date_max in delay_alert_date_data}
         for production in self:
             production.delay_alert_date = delay_alert_date_data.get(production.id, False)
 
     def _compute_json_popover(self):
-        for production in self:
+        production_no_alert = self.filtered(lambda m: m.state in ('done', 'cancel') or not m.delay_alert_date)
+        production_no_alert.json_popover = False
+        for production in (self - production_no_alert):
             production.json_popover = json.dumps({
                 'popoverTemplate': 'stock.PopoverStockRescheduling',
-                'delay_alert_date': format_datetime(self.env, production.delay_alert_date, dt_format=False) if production.delay_alert_date else False,
+                'delay_alert_date': format_datetime(self.env, production.delay_alert_date, dt_format=False),
                 'late_elements': [{
-                        'id': late_document.id,
-                        'name': late_document.display_name,
-                        'model': late_document._name,
-                    } for late_document in production.move_raw_ids.filtered(lambda m: m.delay_alert_date).move_orig_ids._delay_alert_get_documents()
+                    'id': late_document.id,
+                    'name': late_document.display_name,
+                    'model': late_document._name,
+                } for late_document in production.move_raw_ids.filtered(lambda m: m.delay_alert_date).move_orig_ids._delay_alert_get_documents()
                 ]
             })
 
@@ -350,43 +459,21 @@ class MrpProduction(models.Model):
                 ('production_id', 'in', self.ids),
                 ('raw_material_production_id', 'in', self.ids)
         ]
-        res = self.env['stock.move'].read_group(domain, ['state', 'production_id', 'raw_material_production_id'], ['production_id', 'raw_material_production_id'], lazy=False)
-        productions_with_done_move = {}
-        for rec in res:
-            production_record = rec['production_id'] or rec['raw_material_production_id']
-            if production_record:
-                productions_with_done_move[production_record[0]] = True
-        for production in self:
-            production.confirm_cancel = productions_with_done_move.get(production.id, False)
+        res = self.env['stock.move']._read_group(domain, ['production_id', 'raw_material_production_id'])
+        self.confirm_cancel = False
+        for production, raw_material_production in res:
+            production_record = production or raw_material_production
+            production_record.confirm_cancel = True
 
-    @api.depends('procurement_group_id')
+    @api.depends('procurement_group_id', 'procurement_group_id.stock_move_ids.group_id')
     def _compute_picking_ids(self):
         for order in self:
             order.picking_ids = self.env['stock.picking'].search([
                 ('group_id', '=', order.procurement_group_id.id), ('group_id', '!=', False),
             ])
+            order.picking_ids |= order.move_raw_ids.move_orig_ids.picking_id
             order.delivery_count = len(order.picking_ids)
 
-    def action_view_mo_delivery(self):
-        """ This function returns an action that display picking related to
-        manufacturing order orders. It can either be a in a list or in a form
-        view, if there is only one picking to show.
-        """
-        self.ensure_one()
-        action = self.env["ir.actions.actions"]._for_xml_id("stock.action_picking_tree_all")
-        pickings = self.mapped('picking_ids')
-        if len(pickings) > 1:
-            action['domain'] = [('id', 'in', pickings.ids)]
-        elif pickings:
-            form_view = [(self.env.ref('stock.view_picking_form').id, 'form')]
-            if 'views' in action:
-                action['views'] = form_view + [(state,view) for state,view in action['views'] if view != 'form']
-            else:
-                action['views'] = form_view
-            action['res_id'] = pickings.id
-        action['context'] = dict(self._context, default_origin=self.name, create=False)
-        return action
-
     @api.depends('product_uom_id', 'product_qty', 'product_id.uom_id')
     def _compute_product_uom_qty(self):
         for production in self:
@@ -399,16 +486,15 @@ class MrpProduction(models.Model):
     def _compute_production_location(self):
         if not self.company_id:
             return
-        location_by_company = self.env['stock.location'].read_group([
+        location_by_company = self.env['stock.location']._read_group([
             ('company_id', 'in', self.company_id.ids),
             ('usage', '=', 'production')
-        ], ['company_id', 'ids:array_agg(id)'], ['company_id'])
-        location_by_company = {lbc['company_id'][0]: lbc['ids'] for lbc in location_by_company}
+        ], ['company_id'], ['id:array_agg'])
+        location_by_company = {company.id: ids for company, ids in location_by_company}
         for production in self:
-            if production.product_id:
-                production.production_location_id = production.product_id.with_company(production.company_id).property_stock_production
-            else:
-                production.production_location_id = location_by_company.get(production.company_id.id)[0]
+            prod_loc = production.product_id.with_company(production.company_id).property_stock_production
+            comp_locs = location_by_company.get(production.company_id.id)
+            production.production_location_id = prod_loc or (comp_locs and comp_locs[0])
 
     @api.depends('product_id.tracking')
     def _compute_show_lots(self):
@@ -425,73 +511,130 @@ class MrpProduction(models.Model):
             production.finished_move_line_ids = production.move_finished_ids.mapped('move_line_ids')
 
     @api.depends(
-        'move_raw_ids.state', 'move_raw_ids.quantity_done', 'move_finished_ids.state',
-        'workorder_ids', 'workorder_ids.state', 'product_qty', 'qty_producing')
+        'move_raw_ids.state', 'move_raw_ids.quantity', 'move_finished_ids.state',
+        'workorder_ids.state', 'product_qty', 'qty_producing', 'move_raw_ids.picked')
     def _compute_state(self):
-        """ Compute the production state. It use the same process than stock
-        picking. It exists 3 extra steps for production:
+        """ Compute the production state. This uses a similar process to stock
+        picking, but has been adapted to support having no moves. This adaption
+        includes some state changes outside of this compute.
+
+        There exist 3 extra steps for production:
         - progress: At least one item is produced or consumed.
         - to_close: The quantity produced is greater than the quantity to
         produce and all work orders has been finished.
         """
-        # TODO: duplicated code with stock_picking.py
         for production in self:
-            if not production.move_raw_ids:
-                production.state = 'draft'
-            elif all(move.state == 'draft' for move in production.move_raw_ids):
+            if not production.state or not production.product_uom_id:
                 production.state = 'draft'
-            elif all(move.state == 'cancel' for move in production.move_raw_ids):
+            elif production.state == 'cancel' or (production.move_finished_ids and all(move.state == 'cancel' for move in production.move_finished_ids)):
                 production.state = 'cancel'
-            elif all(move.state in ('cancel', 'done') for move in production.move_raw_ids):
+            elif (
+                production.state == 'done'
+                or (production.move_raw_ids and all(move.state in ('cancel', 'done') for move in production.move_raw_ids))
+                and all(move.state in ('cancel', 'done') for move in production.move_finished_ids)
+            ):
                 production.state = 'done'
-            elif production.qty_producing >= production.product_qty:
+            elif production.workorder_ids and all(wo_state in ('done', 'cancel') for wo_state in production.workorder_ids.mapped('state')):
+                production.state = 'to_close'
+            elif not production.workorder_ids and float_compare(production.qty_producing, production.product_qty, precision_rounding=production.product_uom_id.rounding) >= 0:
                 production.state = 'to_close'
             elif any(wo_state in ('progress', 'done') for wo_state in production.workorder_ids.mapped('state')):
                 production.state = 'progress'
-            elif not float_is_zero(production.qty_producing, precision_rounding=production.product_uom_id.rounding):
+            elif production.product_uom_id and not float_is_zero(production.qty_producing, precision_rounding=production.product_uom_id.rounding):
                 production.state = 'progress'
-            elif any(not float_is_zero(move.quantity_done, precision_rounding=move.product_uom.rounding or move.product_id.uom_id.rounding) for move in production.move_raw_ids):
+            elif any(production.move_raw_ids.mapped('picked')):
                 production.state = 'progress'
+
+    @api.depends('bom_id', 'product_id', 'product_qty', 'product_uom_id')
+    def _compute_workorder_ids(self):
+        for production in self:
+            if production.state != 'draft':
+                continue
+            workorders_list = [Command.link(wo.id) for wo in production.workorder_ids.filtered(lambda wo: not wo.operation_id)]
+            workorders_list += [Command.delete(wo.id) for wo in production.workorder_ids.filtered(lambda wo: wo.operation_id and wo.operation_id.bom_id != production.bom_id)]
+            if not production.bom_id and not production._origin.product_id:
+                production.workorder_ids = workorders_list
+            if production.product_id != production._origin.product_id:
+                production.workorder_ids = [Command.clear()]
+            if production.bom_id and production.product_id and production.product_qty > 0:
+                # keep manual entries
+                workorders_values = []
+                product_qty = production.product_uom_id._compute_quantity(production.product_qty, production.bom_id.product_uom_id)
+                exploded_boms, dummy = production.bom_id.explode(production.product_id, product_qty / production.bom_id.product_qty, picking_type=production.bom_id.picking_type_id)
+
+                for bom, bom_data in exploded_boms:
+                    # If the operations of the parent BoM and phantom BoM are the same, don't recreate work orders.
+                    if not (bom.operation_ids and (not bom_data['parent_line'] or bom_data['parent_line'].bom_id.operation_ids != bom.operation_ids)):
+                        continue
+                    for operation in bom.operation_ids:
+                        if operation._skip_operation_line(bom_data['product']):
+                            continue
+                        workorders_values += [{
+                            'name': operation.name,
+                            'production_id': production.id,
+                            'workcenter_id': operation.workcenter_id.id,
+                            'product_uom_id': production.product_uom_id.id,
+                            'operation_id': operation.id,
+                            'state': 'pending',
+                        }]
+                workorders_dict = {wo.operation_id.id: wo for wo in production.workorder_ids.filtered(lambda wo: wo.operation_id)}
+                for workorder_values in workorders_values:
+                    if workorder_values['operation_id'] in workorders_dict:
+                        # update existing entries
+                        workorders_list += [Command.update(workorders_dict[workorder_values['operation_id']].id, workorder_values)]
+                    else:
+                        # add new entries
+                        workorders_list += [Command.create(workorder_values)]
+                production.workorder_ids = workorders_list
             else:
-                production.state = 'confirmed'
+                production.workorder_ids = [Command.delete(wo.id) for wo in production.workorder_ids.filtered(lambda wo: wo.operation_id)]
 
-            # Compute reservation state
-            # State where the reservation does not matter.
-            production.reservation_state = False
+    @api.depends('state', 'move_raw_ids.state')
+    def _compute_reservation_state(self):
+        for production in self:
+            if production.state in ('draft', 'done', 'cancel'):
+                production.reservation_state = False
+                continue
+            relevant_move_state = production.move_raw_ids._get_relevant_state_among_moves()
             # Compute reservation state according to its component's moves.
-            if production.state not in ('draft', 'done', 'cancel'):
-                relevant_move_state = production.move_raw_ids._get_relevant_state_among_moves()
-                if relevant_move_state == 'partially_available':
-                    if production.bom_id.operation_ids and production.bom_id.ready_to_produce == 'asap':
-                        production.reservation_state = production._get_ready_to_produce_state()
-                    else:
-                        production.reservation_state = 'confirmed'
-                elif relevant_move_state != 'draft':
-                    production.reservation_state = relevant_move_state
+            if relevant_move_state == 'partially_available':
+                if production.workorder_ids.operation_id and production.bom_id.ready_to_produce == 'asap':
+                    production.reservation_state = production._get_ready_to_produce_state()
+                else:
+                    production.reservation_state = 'confirmed'
+            elif relevant_move_state != 'draft':
+                production.reservation_state = relevant_move_state
+            else:
+                production.reservation_state = False
 
     @api.depends('move_raw_ids', 'state', 'move_raw_ids.product_uom_qty')
     def _compute_unreserve_visible(self):
         for order in self:
             already_reserved = order.state not in ('done', 'cancel') and order.mapped('move_raw_ids.move_line_ids')
-            any_quantity_done = any(m.quantity_done > 0 for m in order.move_raw_ids)
+            any_quantity_done = any(order.move_raw_ids.mapped('picked'))
 
             order.unreserve_visible = not any_quantity_done and already_reserved
             order.reserve_visible = order.state in ('confirmed', 'progress', 'to_close') and any(move.product_uom_qty and move.state in ['confirmed', 'partially_available'] for move in order.move_raw_ids)
 
-    @api.depends('workorder_ids.state', 'move_finished_ids', 'move_finished_ids.quantity_done')
+    @api.depends('workorder_ids.state', 'move_finished_ids', 'move_finished_ids.quantity')
     def _get_produced_qty(self):
         for production in self:
             done_moves = production.move_finished_ids.filtered(lambda x: x.state != 'cancel' and x.product_id.id == production.product_id.id)
-            qty_produced = sum(done_moves.mapped('quantity_done'))
+            qty_produced = sum(done_moves.filtered(lambda m: m.picked).mapped('quantity'))
             production.qty_produced = qty_produced
         return True
 
     def _compute_scrap_move_count(self):
-        data = self.env['stock.scrap'].read_group([('production_id', 'in', self.ids)], ['production_id'], ['production_id'])
-        count_data = dict((item['production_id'][0], item['production_id_count']) for item in data)
+        data = self.env['stock.scrap']._read_group([('production_id', 'in', self.ids)], ['production_id'], ['__count'])
+        count_data = {production.id: count for production, count in data}
         for production in self:
             production.scrap_count = count_data.get(production.id, 0)
 
+    @api.depends('unbuild_ids')
+    def _compute_unbuild_count(self):
+        for production in self:
+            production.unbuild_count = len(production.unbuild_ids)
+
     @api.depends('move_finished_ids')
     def _compute_move_byproduct_ids(self):
         for order in self:
@@ -499,271 +642,294 @@ class MrpProduction(models.Model):
 
     def _set_move_byproduct_ids(self):
         move_finished_ids = self.move_finished_ids.filtered(lambda m: m.product_id == self.product_id)
+        # TODO: Try to create by-product moves here instead of moving them in the `create`.
         self.move_finished_ids = move_finished_ids | self.move_byproduct_ids
 
     @api.depends('state')
     def _compute_show_lock(self):
         for order in self:
-            order.show_lock = self.env.user.has_group('mrp.group_locked_by_default') and order.id is not False and order.state not in {'cancel', 'draft'}
+            order.show_lock = order.state == 'done' or (
+                not self.env.user.has_group('mrp.group_unlocked_by_default')
+                and order.id is not False
+                and order.state not in {'cancel', 'draft'}
+            )
 
-    @api.depends('state','move_raw_ids')
+    @api.depends('state', 'move_raw_ids')
     def _compute_show_lot_ids(self):
         for order in self:
-            order.show_lot_ids = order.state != 'draft' and any(m.product_id.tracking == 'serial' for m in order.move_raw_ids)
+            order.show_lot_ids = order.state != 'draft' and any(m.product_id.tracking != 'none' for m in order.move_raw_ids)
 
-    _sql_constraints = [
-        ('name_uniq', 'unique(name, company_id)', 'Reference must be unique per Company!'),
-        ('qty_positive', 'check (product_qty > 0)', 'The quantity to produce must be positive!'),
-    ]
+    @api.depends('state', 'move_finished_ids')
+    def _compute_show_allocation(self):
+        self.show_allocation = False
+        if not self.env.user.has_group('mrp.group_mrp_reception_report'):
+            return
+        for mo in self:
+            if not mo.picking_type_id:
+                return
+            lines = mo.move_finished_ids.filtered(lambda m: m.product_id.type == 'product' and m.state != 'cancel')
+            if lines:
+                allowed_states = ['confirmed', 'partially_available', 'waiting']
+                if mo.state == 'done':
+                    allowed_states += ['assigned']
+                wh_location_ids = self.env['stock.location']._search([('id', 'child_of', mo.picking_type_id.warehouse_id.view_location_id.id), ('usage', '!=', 'supplier')])
+                if self.env['stock.move'].search_count([
+                    ('state', 'in', allowed_states),
+                    ('product_qty', '>', 0),
+                    ('location_id', 'in', wh_location_ids),
+                    ('raw_material_production_id', '!=', mo.id),
+                    ('product_id', 'in', lines.product_id.ids),
+                    '|', ('move_orig_ids', '=', False),
+                        ('move_orig_ids', 'in', lines.ids)], limit=1):
+                    mo.show_allocation = True
+
+    @api.depends('product_uom_qty', 'date_start')
+    def _compute_forecasted_issue(self):
+        for order in self:
+            warehouse = order.location_dest_id.warehouse_id
+            order.forecasted_issue = False
+            if order.product_id:
+                virtual_available = order.product_id.with_context(warehouse=warehouse.id, to_date=order.date_start).virtual_available
+                if order.state == 'draft':
+                    virtual_available += order.product_uom_qty
+                if virtual_available < 0:
+                    order.forecasted_issue = True
 
     @api.model
     def _search_delay_alert_date(self, operator, value):
         late_stock_moves = self.env['stock.move'].search([('delay_alert_date', operator, value)])
         return ['|', ('move_raw_ids', 'in', late_stock_moves.ids), ('move_finished_ids', 'in', late_stock_moves.ids)]
 
-    @api.onchange('company_id')
-    def _onchange_company_id(self):
-        if self.company_id:
-            if self.move_raw_ids:
-                self.move_raw_ids.update({'company_id': self.company_id})
-            if self.picking_type_id and self.picking_type_id.company_id != self.company_id:
-                self.picking_type_id = self.env['stock.picking.type'].search([
-                    ('code', '=', 'mrp_operation'),
-                    ('warehouse_id.company_id', '=', self.company_id.id),
-                ], limit=1).id
-
-    @api.onchange('product_id', 'picking_type_id', 'company_id')
-    def _onchange_product_id(self):
-        """ Finds UoM of changed product. """
-        if not self.product_id:
-            self.bom_id = False
-        elif not self.bom_id or self.bom_id.product_tmpl_id != self.product_tmpl_id or (self.bom_id.product_id and self.bom_id.product_id != self.product_id):
-            bom = self.env['mrp.bom']._bom_find(product=self.product_id, picking_type=self.picking_type_id, company_id=self.company_id.id, bom_type='normal')
-            if bom:
-                self.bom_id = bom.id
-                self.product_qty = self.bom_id.product_qty
-                self.product_uom_id = self.bom_id.product_uom_id.id
+    @api.depends('company_id', 'date_start', 'is_planned', 'product_id', 'workorder_ids.duration_expected')
+    def _compute_date_finished(self):
+        for production in self:
+            if not production.date_start or production.is_planned or production.state == 'done':
+                continue
+            days_delay = production.bom_id.produce_delay
+            date_finished = production.date_start + relativedelta(days=days_delay)
+            if production._should_postpone_date_finished(date_finished):
+                workorder_expected_duration = sum(self.workorder_ids.mapped('duration_expected'))
+                date_finished = date_finished + relativedelta(minutes=workorder_expected_duration or 60)
+            production.date_finished = date_finished
+
+    @api.depends('company_id', 'bom_id', 'product_id', 'product_qty', 'product_uom_id', 'location_src_id')
+    def _compute_move_raw_ids(self):
+        for production in self:
+            if production.state != 'draft' or self.env.context.get('skip_compute_move_raw_ids'):
+                continue
+            list_move_raw = [Command.link(move.id) for move in production.move_raw_ids.filtered(lambda m: not m.bom_line_id)]
+            if not production.bom_id and not production._origin.product_id:
+                production.move_raw_ids = list_move_raw
+            if any(move.bom_line_id.bom_id != production.bom_id or move.bom_line_id._skip_bom_line(production.product_id)\
+                for move in production.move_raw_ids if move.bom_line_id):
+                production.move_raw_ids = [Command.clear()]
+            if production.bom_id and production.product_id and production.product_qty > 0:
+                # keep manual entries
+                moves_raw_values = production._get_moves_raw_values()
+                move_raw_dict = {move.bom_line_id.id: move for move in production.move_raw_ids.filtered(lambda m: m.bom_line_id)}
+                for move_raw_values in moves_raw_values:
+                    if move_raw_values['bom_line_id'] in move_raw_dict:
+                        # update existing entries
+                        list_move_raw += [Command.update(move_raw_dict[move_raw_values['bom_line_id']].id, move_raw_values)]
+                    else:
+                        # add new entries
+                        list_move_raw += [Command.create(move_raw_values)]
+                production.move_raw_ids = list_move_raw
             else:
-                self.bom_id = False
-                self.product_uom_id = self.product_id.uom_id.id
+                production.move_raw_ids = [Command.delete(move.id) for move in production.move_raw_ids.filtered(lambda m: m.bom_line_id)]
 
-    @api.onchange('product_qty', 'product_uom_id')
-    def _onchange_product_qty(self):
-        for workorder in self.workorder_ids:
-            workorder.product_uom_id = self.product_uom_id
-            if self._origin.product_qty:
-                workorder.duration_expected = workorder._get_duration_expected(ratio=self.product_qty / self._origin.product_qty)
+    @api.depends('product_id', 'bom_id', 'product_qty', 'product_uom_id', 'location_dest_id', 'date_finished', 'move_dest_ids')
+    def _compute_move_finished_ids(self):
+        for production in self:
+            if production.state != 'draft':
+                updated_values = {}
+                if production.date_finished:
+                    updated_values['date'] = production.date_finished
+                if production.date_deadline:
+                    updated_values['date_deadline'] = production.date_deadline
+                if 'date' in updated_values or 'date_deadline' in updated_values:
+                    production.move_finished_ids = [
+                        Command.update(m.id, updated_values) for m in production.move_finished_ids
+                    ]
+                continue
+            # delete to remove existing moves from database and clear to remove new records
+            production.move_finished_ids = [Command.delete(m) for m in production.move_finished_ids.ids]
+            production.move_finished_ids = [Command.clear()]
+            if production.product_id:
+                production._create_update_move_finished()
             else:
-                workorder.duration_expected = workorder._get_duration_expected()
-            if workorder.date_planned_start and workorder.duration_expected:
-                workorder.date_planned_finished = workorder.date_planned_start + relativedelta(minutes=workorder.duration_expected)
-
-    @api.onchange('bom_id')
-    def _onchange_bom_id(self):
-        if not self.product_id and self.bom_id:
-            self.product_id = self.bom_id.product_id or self.bom_id.product_tmpl_id.product_variant_ids[0]
-        self.product_qty = self.bom_id.product_qty or 1.0
-        self.product_uom_id = self.bom_id and self.bom_id.product_uom_id.id or self.product_id.uom_id.id
-        self.move_raw_ids = [(2, move.id) for move in self.move_raw_ids.filtered(lambda m: m.bom_line_id)]
-        self.move_finished_ids = [(2, move.id) for move in self.move_finished_ids]
-        self.picking_type_id = self.bom_id.picking_type_id or self.picking_type_id
-
-    @api.onchange('date_planned_start', 'product_id')
-    def _onchange_date_planned_start(self):
-        if self.date_planned_start and not self.is_planned:
-            date_planned_finished = self.date_planned_start + relativedelta(days=self.product_id.produce_delay)
-            date_planned_finished = date_planned_finished + relativedelta(days=self.company_id.manufacturing_lead)
-            if date_planned_finished == self.date_planned_start:
-                date_planned_finished = date_planned_finished + relativedelta(hours=1)
-            self.date_planned_finished = date_planned_finished
-            self.move_raw_ids = [(1, m.id, {'date': self.date_planned_start}) for m in self.move_raw_ids]
-            self.move_finished_ids = [(1, m.id, {'date': date_planned_finished}) for m in self.move_finished_ids]
-
-    @api.onchange('bom_id', 'product_id', 'product_qty', 'product_uom_id')
-    def _onchange_move_raw(self):
-        if not self.bom_id and not self._origin.product_id:
-            return
-        # Clear move raws if we are changing the product. In case of creation (self._origin is empty),
-        # we need to avoid keeping incorrect lines, so clearing is necessary too.
-        if self.product_id != self._origin.product_id:
-            self.move_raw_ids = [(5,)]
-        if self.bom_id and self.product_qty > 0:
-            # keep manual entries
-            list_move_raw = [(4, move.id) for move in self.move_raw_ids.filtered(lambda m: not m.bom_line_id)]
-            moves_raw_values = self._get_moves_raw_values()
-            move_raw_dict = {move.bom_line_id.id: move for move in self.move_raw_ids.filtered(lambda m: m.bom_line_id)}
-            for move_raw_values in moves_raw_values:
-                if move_raw_values['bom_line_id'] in move_raw_dict:
-                    # update existing entries
-                    list_move_raw += [(1, move_raw_dict[move_raw_values['bom_line_id']].id, move_raw_values)]
-                else:
-                    # add new entries
-                    list_move_raw += [(0, 0, move_raw_values)]
-            self.move_raw_ids = list_move_raw
-        else:
-            self.move_raw_ids = [(2, move.id) for move in self.move_raw_ids.filtered(lambda m: m.bom_line_id)]
-
-    @api.onchange('bom_id', 'product_id', 'product_qty', 'product_uom_id')
-    def _onchange_move_finished(self):
-        if self.product_id and self.product_qty > 0:
-            # keep manual entries
-            list_move_finished = [(4, move.id) for move in self.move_finished_ids.filtered(
-                lambda m: not m.byproduct_id and m.product_id != self.product_id)]
-            moves_finished_values = self._get_moves_finished_values()
-            moves_byproduct_dict = {move.byproduct_id.id: move for move in self.move_finished_ids.filtered(lambda m: m.byproduct_id)}
-            move_finished = self.move_finished_ids.filtered(lambda m: m.product_id == self.product_id)
-            for move_finished_values in moves_finished_values:
-                if move_finished_values.get('byproduct_id') in moves_byproduct_dict:
-                    # update existing entries
-                    list_move_finished += [(1, moves_byproduct_dict[move_finished_values['byproduct_id']].id, move_finished_values)]
-                elif move_finished_values.get('product_id') == self.product_id.id and move_finished:
-                    list_move_finished += [(1, move_finished.id, move_finished_values)]
-                else:
-                    # add new entries
-                    list_move_finished += [(0, 0, move_finished_values)]
-            self.move_finished_ids = list_move_finished
-        else:
-            self.move_finished_ids = [(2, move.id) for move in self.move_finished_ids.filtered(lambda m: m.bom_line_id)]
-
-    @api.onchange('location_src_id', 'move_raw_ids', 'bom_id')
-    def _onchange_location(self):
-        source_location = self.location_src_id
-        self.move_raw_ids.update({
-            'warehouse_id': source_location.get_warehouse().id,
-            'location_id': source_location.id,
-        })
+                production.move_finished_ids = [
+                    Command.delete(move.id) for move in production.move_finished_ids if move.bom_line_id
+                ]
 
-    @api.onchange('location_dest_id', 'move_finished_ids', 'bom_id')
-    def _onchange_location_dest(self):
-        destination_location = self.location_dest_id
-        update_value_list = []
-        for move in self.move_finished_ids:
-            update_value_list += [(1, move.id, ({
-                'warehouse_id': destination_location.get_warehouse().id,
-                'location_dest_id': destination_location.id,
-            }))]
-        self.move_finished_ids = update_value_list
-
-    @api.onchange('picking_type_id')
-    def _onchange_picking_type(self):
-        if not self.picking_type_id.default_location_src_id or not self.picking_type_id.default_location_dest_id.id:
-            company_id = self.company_id.id if (self.company_id and self.company_id in self.env.companies) else self.env.company.id
-            fallback_loc = self.env['stock.warehouse'].search([('company_id', '=', company_id)], limit=1).lot_stock_id
-        self.location_src_id = self.picking_type_id.default_location_src_id.id or fallback_loc.id
-        self.location_dest_id = self.picking_type_id.default_location_dest_id.id or fallback_loc.id
+    @api.depends('state', 'product_qty', 'qty_producing')
+    def _compute_show_produce(self):
+        for production in self:
+            state_ok = production.state in ('confirmed', 'progress', 'to_close')
+            qty_none_or_all = production.qty_producing in (0, production.product_qty)
+            production.show_produce_all = state_ok and qty_none_or_all
+            production.show_produce = state_ok and not qty_none_or_all
+
+    def _search_is_delayed(self, operator, value):
+        if operator not in ['=', '!='] or not isinstance(value, bool):
+            raise UserError(_('Operation not supported'))
+        if operator != '=':
+            value = not value
+        sub_query = self._search([
+            ('state', 'in', ['confirmed', 'progress', 'to_close']),
+            ('date_deadline', '!=', False),
+            '|',
+                ('date_deadline', '<', self._field_to_sql('mrp_production', 'date_finished')),
+                ('date_deadline', '<', fields.Datetime.now())
+        ])
+        return [('id', 'in' if value else 'not in', sub_query)]
+
+    @api.depends('delay_alert_date', 'state', 'date_deadline', 'date_finished')
+    def _compute_is_delayed(self):
+        for record in self:
+            record.is_delayed = bool(
+                record.state in ['confirmed', 'progress', 'to_close'] and (
+                    record.date_deadline and (record.date_deadline < datetime.datetime.now() or record.date_deadline < record.date_finished))
+            )
 
     @api.onchange('qty_producing', 'lot_producing_id')
     def _onchange_producing(self):
-        self._set_qty_producing()
+        self._set_qty_producing(False)
 
     @api.onchange('lot_producing_id')
     def _onchange_lot_producing(self):
-        if self.product_id.tracking == 'serial':
-            if self.env['stock.move.line'].search_count([
-                ('company_id', '=', self.company_id.id),
-                ('product_id', '=', self.product_id.id),
-                ('lot_id', '=', self.lot_producing_id.id),
-                ('state', '!=', 'cancel')
-            ]):
-                return {
-                    'warning': {
-                        'title': _('Warning'),
-                        'message': _('Existing Serial number (%s). Please correct the serial numbers encoded.') % self.lot_producing_id.name
-                    }
-                }
+        res = self._can_produce_serial_number()
+        if res is not True:
+            return res
+
+    def _can_produce_serial_number(self, sn=None):
+        self.ensure_one()
+        sn = sn or self.lot_producing_id
+        if self.product_id.tracking == 'serial' and sn:
+            message, dummy = self.env['stock.quant'].sudo()._check_serial_number(self.product_id, sn, self.company_id)
+            if message:
+                return {'warning': {'title': _('Warning'), 'message': message}}
+        return True
 
-    @api.onchange('bom_id')
-    def _onchange_workorder_ids(self):
-        if self.bom_id:
-            self._create_workorder()
+    @api.onchange('product_id', 'move_raw_ids')
+    def _onchange_product_id(self):
+        for move in self.move_raw_ids:
+            if self.product_id == move.product_id:
+                message = _("The component %s should not be the same as the product to produce.", self.product_id.display_name)
+                self.move_raw_ids = self.move_raw_ids - move
+                return {'warning': {'title': _('Warning'), 'message': message}}
+
+    @api.constrains('move_finished_ids')
+    def _check_byproducts(self):
+        for order in self:
+            if any(move.cost_share < 0 for move in order.move_byproduct_ids):
+                raise ValidationError(_("By-products cost shares must be positive."))
+            if sum(order.move_byproduct_ids.filtered(lambda m: m.state != 'cancel').mapped('cost_share')) > 100:
+                raise ValidationError(_("The total cost share for a manufacturing order's by-products cannot exceed 100."))
 
     def write(self, vals):
+        if 'move_byproduct_ids' in vals and 'move_finished_ids' not in vals:
+            vals['move_finished_ids'] = vals.get('move_finished_ids', []) + vals['move_byproduct_ids']
+            del vals['move_byproduct_ids']
+        if 'bom_id' in vals and 'move_byproduct_ids' in vals and 'move_finished_ids' in vals:
+            # If byproducts are given, they take precedence over move_finished for byproduts definition
+            bom = self.env['mrp.bom'].browse(vals.get('bom_id'))
+            bom_product = bom.product_id or bom.product_tmpl_id.product_variant_id
+            joined_move_ids = vals.get('move_byproduct_ids', [])
+            for move_finished in vals.get('move_finished_ids', []):
+                # Remove CREATE lines from finished_ids as they do not reflect the form current state (nor the byproduct vals)
+                if move_finished[0] == Command.CREATE and move_finished[2].get('product_id') != bom_product.id:
+                    continue
+                joined_move_ids.append(move_finished)
+            vals['move_finished_ids'] = joined_move_ids
+            del vals['move_byproduct_ids']
         if 'workorder_ids' in self:
             production_to_replan = self.filtered(lambda p: p.is_planned)
+        if 'move_raw_ids' in vals and self.state not in ['draft', 'cancel', 'done']:
+            # When adding a move raw, it should have the source location's `warehouse_id`.
+            # Before, it was handle by an onchange, now it's forced if not already in vals.
+            warehouse_id = self.location_src_id.warehouse_id.id
+            if vals.get('location_src_id'):
+                location_source = self.env['stock.location'].browse(vals.get('location_src_id'))
+                warehouse_id = location_source.warehouse_id.id
+            for move_vals in vals['move_raw_ids']:
+                command = move_vals[0]
+                if command != Command.CREATE:
+                    continue
+                field_values = move_vals[2]
+                if not field_values.get('warehouse_id', False):
+                    field_values['warehouse_id'] = warehouse_id
+
+        if vals.get('picking_type_id'):
+            picking_type = self.env['stock.picking.type'].browse(vals.get('picking_type_id'))
+            for production in self:
+                if production.state == 'draft' and picking_type != production.picking_type_id:
+                    production.name = picking_type.sequence_id.next_by_id()
+
         res = super(MrpProduction, self).write(vals)
 
         for production in self:
-            if 'date_planned_start' in vals and not self.env.context.get('force_date', False):
+            if 'date_start' in vals and not self.env.context.get('force_date', False):
                 if production.state in ['done', 'cancel']:
                     raise UserError(_('You cannot move a manufacturing order once it is cancelled or done.'))
-                if any(wo.date_planned_start and wo.date_planned_finished for wo in production.workorder_ids):
-                    raise UserError(_('You cannot move a manufacturing order once it has a planned workorder, move related workorder(s) instead.'))
-            if vals.get('date_planned_start'):
-                production.move_raw_ids.write({'date': production.date_planned_start, 'date_deadline': production.date_planned_start})
-            if vals.get('date_planned_finished'):
-                production.move_finished_ids.write({'date': production.date_planned_finished})
+                if production.is_planned:
+                    production.button_unplan()
+            if vals.get('date_start'):
+                production.move_raw_ids.write({'date': production.date_start, 'date_deadline': production.date_start})
+            if vals.get('date_finished'):
+                production.move_finished_ids.write({'date': production.date_finished})
             if any(field in ['move_raw_ids', 'move_finished_ids', 'workorder_ids'] for field in vals) and production.state != 'draft':
-                if production.state == 'done':
-                    # for some reason moves added after state = 'done' won't save group_id, reference if added in
-                    # "stock_move.default_get()"
-                    production.move_raw_ids.filtered(lambda move: move.additional and move.date > production.date_planned_start).write({
-                        'group_id': production.procurement_group_id.id,
-                        'reference': production.name,
-                        'date': production.date_planned_start,
-                        'date_deadline': production.date_planned_start
-                    })
-                    production.move_finished_ids.filtered(lambda move: move.additional and move.date > production.date_planned_finished).write({
-                        'reference': production.name,
-                        'date': production.date_planned_finished,
-                        'date_deadline': production.date_deadline
-                    })
                 production._autoconfirm_production()
                 if production in production_to_replan:
-                    production._plan_workorders(replan=True)
+                    production._plan_workorders()
             if production.state == 'done' and ('lot_producing_id' in vals or 'qty_producing' in vals):
                 finished_move_lines = production.move_finished_ids.filtered(
-                    lambda move: move.product_id == self.product_id and move.state == 'done').mapped('move_line_ids')
+                    lambda move: move.product_id == production.product_id and move.state == 'done').mapped('move_line_ids')
                 if 'lot_producing_id' in vals:
                     finished_move_lines.write({'lot_id': vals.get('lot_producing_id')})
                 if 'qty_producing' in vals:
-                    finished_move_lines.write({'qty_done': vals.get('qty_producing')})
-
-            if not production.bom_id.operation_ids and vals.get('date_planned_start') and not vals.get('date_planned_finished'):
-                new_date_planned_start = fields.Datetime.to_datetime(vals.get('date_planned_start'))
-                if not production.date_planned_finished or new_date_planned_start >= production.date_planned_finished:
-                    production.date_planned_finished = new_date_planned_start + datetime.timedelta(hours=1)
+                    finished_move_lines.write({'quantity': vals.get('qty_producing')})
+            if self._has_workorders() and not production.workorder_ids.operation_id and vals.get('date_start') and not vals.get('date_finished'):
+                new_date_start = fields.Datetime.to_datetime(vals.get('date_start'))
+                if not production.date_finished or new_date_start >= production.date_finished:
+                    production.date_finished = new_date_start + datetime.timedelta(hours=1)
         return res
 
-    @api.model
-    def create(self, values):
-        # Remove from `move_finished_ids` the by-product moves and then move `move_byproduct_ids`
-        # into `move_finished_ids` to avoid duplicate and inconsistency.
-        if values.get('move_finished_ids', False):
-            values['move_finished_ids'] = list(filter(lambda move: move[2]['byproduct_id'] is False, values['move_finished_ids']))
-        if values.get('move_byproduct_ids', False):
-            values['move_finished_ids'] = values.get('move_finished_ids', []) + values['move_byproduct_ids']
-            del values['move_byproduct_ids']
-        if not values.get('name', False) or values['name'] == _('New'):
-            picking_type_id = values.get('picking_type_id') or self._get_default_picking_type()
-            picking_type_id = self.env['stock.picking.type'].browse(picking_type_id)
-            if picking_type_id:
-                values['name'] = picking_type_id.sequence_id.next_by_id()
-            else:
-                values['name'] = self.env['ir.sequence'].next_by_code('mrp.production') or _('New')
-        if not values.get('procurement_group_id'):
-            procurement_group_vals = self._prepare_procurement_group_vals(values)
-            values['procurement_group_id'] = self.env["procurement.group"].create(procurement_group_vals).id
-        production = super(MrpProduction, self).create(values)
-        (production.move_raw_ids | production.move_finished_ids).write({
-            'group_id': production.procurement_group_id.id,
-            'origin': production.name
-        })
-        production.move_raw_ids.write({'date': production.date_planned_start})
-        production.move_finished_ids.write({'date': production.date_planned_finished})
-        # Trigger move_raw creation when importing a file
-        if 'import_file' in self.env.context:
-            production._onchange_move_raw()
-            production._onchange_move_finished()
-        return production
-
-    @api.ondelete(at_uninstall=False)
-    def _unlink_except_done(self):
-        if any(production.state == 'done' for production in self):
-            raise UserError(_('Cannot delete a manufacturing order in done state.'))
-        not_cancel = self.filtered(lambda m: m.state != 'cancel')
-        if not_cancel:
-            productions_name = ', '.join([prod.display_name for prod in not_cancel])
-            raise UserError(_('%s cannot be deleted. Try to cancel them before.', productions_name))
+    @api.model_create_multi
+    def create(self, vals_list):
+        for vals in vals_list:
+            # Remove from `move_finished_ids` the by-product moves and then move `move_byproduct_ids`
+            # into `move_finished_ids` to avoid duplicate and inconsistency.
+            if vals.get('move_finished_ids', False) and vals.get('move_byproduct_ids', False):
+                vals['move_finished_ids'] = list(filter(lambda move: move[2]['product_id'] == vals['product_id'], vals['move_finished_ids']))
+                vals['move_finished_ids'] = vals.get('move_finished_ids', []) + vals['move_byproduct_ids']
+                del vals['move_byproduct_ids']
+            if not vals.get('name', False) or vals['name'] == _('New'):
+                picking_type_id = vals.get('picking_type_id')
+                if not picking_type_id:
+                    picking_type_id = self._get_default_picking_type_id(vals.get('company_id', self.env.company.id))
+                    vals['picking_type_id'] = picking_type_id
+                vals['name'] = self.env['stock.picking.type'].browse(picking_type_id).sequence_id.next_by_id()
+            if not vals.get('procurement_group_id'):
+                procurement_group_vals = self._prepare_procurement_group_vals(vals)
+                vals['procurement_group_id'] = self.env["procurement.group"].create(procurement_group_vals).id
+        res = super().create(vals_list)
+        # Make sure that the date passed in vals_list are taken into account and not modified by a compute
+        for rec, vals in zip(res, vals_list):
+            if (rec.move_raw_ids
+                and rec.move_raw_ids[0].date
+                and vals.get('date_start')
+                and rec.move_raw_ids[0].date != vals['date_start']):
+                rec.move_raw_ids.write({
+                    'date': vals['date_start'],
+                    'date_deadline': vals['date_start']
+                })
+            if (rec.move_finished_ids
+                and rec.move_finished_ids[0].date
+                and vals.get('date_finished')
+                and rec.move_finished_ids[0].date != vals['date_finished']):
+                rec.move_finished_ids.write({'date': vals['date_finished']})
+        return res
 
     def unlink(self):
         self.action_cancel()
@@ -772,65 +938,175 @@ class MrpProduction(models.Model):
             workorders_to_delete.unlink()
         return super(MrpProduction, self).unlink()
 
+    def copy_data(self, default=None):
+        default = dict(default or {})
+        vals_list = super().copy_data(default=default)
+        for production, vals in zip(self, vals_list):
+            # covers at least 2 cases: backorders generation (follow default logic for moves copying)
+            # and copying a done MO via the form (i.e. copy only the non-cancelled moves since no backorder = cancelled finished moves)
+            if not default or 'move_finished_ids' not in default:
+                move_finished_ids = production.move_finished_ids
+                if production.state != 'cancel':
+                    move_finished_ids = production.move_finished_ids.filtered(lambda m: m.state != 'cancel' and m.product_qty != 0.0)
+                vals['move_finished_ids'] = [(0, 0, move_vals) for move_vals in move_finished_ids.copy_data()]
+            if not default or 'move_raw_ids' not in default:
+                vals['move_raw_ids'] = [(0, 0, move_vals) for move_vals in production.move_raw_ids.filtered(lambda m: m.product_qty != 0.0).copy_data()]
+        return vals_list
+
+    def copy(self, default=None):
+        new_productions = super().copy(default)
+        for old_production, new_production in zip(self, new_productions):
+            if old_production.workorder_ids.blocked_by_workorder_ids:
+                workorders_mapping = {}
+                for original, copied in zip(old_production.workorder_ids, new_production.workorder_ids.sorted()):
+                    workorders_mapping[original] = copied
+                for workorder in old_production.workorder_ids:
+                    if workorder.blocked_by_workorder_ids:
+                        copied_workorder = workorders_mapping[workorder]
+                        dependencies = []
+                        for dependency in workorder.blocked_by_workorder_ids:
+                            dependencies.append(Command.link(workorders_mapping[dependency].id))
+                        copied_workorder.blocked_by_workorder_ids = dependencies
+        return new_productions
+
+    def action_generate_bom(self):
+        """ Generates a new Bill of Material based on the Manufacturing Order's product, components,
+        workorders and by-products, and assigns it to the MO. Returns a new BoM's form view action.
+        """
+        self.ensure_one()
+        action = self.env['ir.actions.act_window']._for_xml_id('mrp.mrp_bom_form_action')
+        action['view_mode'] = 'form'
+        action['views'] = [(False, 'form')]
+
+        bom_lines_vals, byproduct_vals, operations_vals = self._get_bom_values()
+        action['context'] = {
+            'default_bom_line_ids': bom_lines_vals,
+            'default_byproduct_ids': byproduct_vals,
+            'default_code': _("New BoM from %(mo_name)s", mo_name=self.display_name),
+            'default_company_id': self.company_id.id,
+            'default_operation_ids': operations_vals,
+            'default_product_id': self.product_id.id,
+            'default_product_qty': self.product_qty,
+            'default_product_tmpl_id': self.product_id.product_tmpl_id.id,
+            'default_product_uom_id': self.product_uom_id.id,
+            'parent_production_id': self.id,  # Used to assign the new BoM to the current MO.
+        }
+        return action
+
+    def action_view_mo_delivery(self):
+        """ Returns an action that display picking related to manufacturing order.
+        It can either be a list view or in a form view (if there is only one picking to show).
+        """
+        self.ensure_one()
+        action = self.env["ir.actions.actions"]._for_xml_id("stock.action_picking_tree_all")
+        if len(self.picking_ids) > 1:
+            action['domain'] = [('id', 'in', self.picking_ids.ids)]
+        elif self.picking_ids:
+            action['res_id'] = self.picking_ids.id
+            action['views'] = [(self.env.ref('stock.view_picking_form').id, 'form')]
+            if 'views' in action:
+                action['views'] += [(state, view) for state, view in action['views'] if view != 'form']
+        action['context'] = dict(self._context, default_origin=self.name)
+        return action
+
     def action_toggle_is_locked(self):
         self.ensure_one()
         self.is_locked = not self.is_locked
         return True
 
-    def _create_workorder(self):
+    def action_product_forecast_report(self):
+        self.ensure_one()
+        action = self.product_id.action_product_forecast_report()
+        action['context'] = {
+            'active_id': self.product_id.id,
+            'active_model': 'product.product',
+            'move_to_match_ids': self.move_finished_ids.filtered(lambda m: m.product_id == self.product_id).ids
+        }
+        warehouse = self.picking_type_id.warehouse_id
+        if warehouse:
+            action['context']['warehouse'] = warehouse.id
+        return action
+
+    def action_update_bom(self):
         for production in self:
-            if not production.bom_id:
-                continue
-            workorders_values = []
+            if production.bom_id:
+                production._link_bom(production.bom_id)
+        self.is_outdated_bom = False
+
+    def _get_bom_values(self, ratio=1):
+        """ Returns the BoM lines, by-products and operations values needed to
+        create a new BoM from this Manufacturing Order.
+        :return: A tuple containing the BoM lines, by-products and operations values, in this order
+        :rtype: tuple(dict, dict, dict)
+        """
+        self.ensure_one()
 
-            product_qty = production.product_uom_id._compute_quantity(production.product_qty, production.bom_id.product_uom_id)
-            exploded_boms, dummy = production.bom_id.explode(production.product_id, product_qty / production.bom_id.product_qty, picking_type=production.bom_id.picking_type_id)
+        def get_uom_and_quantity(move):
+            # Use the BoM line/by-product's UoM if the move is linked to one of them.
+            target_uom = (move.bom_line_id or move.byproduct_id).product_uom_id or move.product_uom
+            # In order to be able to multiply the move quantity by the ratio, we
+            # have to be sure they both express in the same UoM.
+            qty = move.quantity or move.product_uom_qty
+            qty = move.product_uom._compute_quantity(qty * ratio, target_uom)
+            return (target_uom, qty)
+
+        # BoM lines values.
+        bom_lines_values = []
+        for move_raw in self.move_raw_ids:
+            uom, qty = get_uom_and_quantity(move_raw)
+            bom_line_vals = {
+                'product_id': move_raw.product_id.id,
+                'product_qty': qty,
+                'product_uom_id': uom.id,
+            }
+            bom_lines_values.append(Command.create(bom_line_vals))
+        # By-Product lines values.
+        byproduct_values = []
+        for move_byproduct in self.move_byproduct_ids:
+            uom, qty = get_uom_and_quantity(move_byproduct)
+            bom_byproduct_vals = {
+                'cost_share': move_byproduct.cost_share,
+                'product_id': move_byproduct.product_id.id,
+                'product_qty': qty,
+                'product_uom_id': uom.id,
+            }
+            byproduct_values.append(Command.create(bom_byproduct_vals))
+        # Operations values.
+        operations_values = [Command.create(wo._get_operation_values()) for wo in self.workorder_ids]
+        return (bom_lines_values, byproduct_values, operations_values)
 
-            for bom, bom_data in exploded_boms:
-                # If the operations of the parent BoM and phantom BoM are the same, don't recreate work orders.
-                if not (bom.operation_ids and (not bom_data['parent_line'] or bom_data['parent_line'].bom_id.operation_ids != bom.operation_ids)):
-                    continue
-                for operation in bom.operation_ids:
-                    workorders_values += [{
-                        'name': operation.name,
-                        'production_id': production.id,
-                        'workcenter_id': operation.workcenter_id.id,
-                        'product_uom_id': production.product_uom_id.id,
-                        'operation_id': operation.id,
-                        'state': 'pending',
-                    }]
-            production.workorder_ids = [(5, 0)] + [(0, 0, value) for value in workorders_values]
-            for workorder in production.workorder_ids:
-                workorder.duration_expected = workorder._get_duration_expected()
+    @api.model
+    def _get_default_picking_type_id(self, company_id):
+        return self.env['stock.picking.type'].search([
+            ('code', '=', 'mrp_operation'),
+            ('warehouse_id.company_id', '=', company_id),
+        ], limit=1).id
 
-    def _get_move_finished_values(self, product_id, product_uom_qty, product_uom, operation_id=False, byproduct_id=False):
+    def _get_move_finished_values(self, product_id, product_uom_qty, product_uom, operation_id=False, byproduct_id=False, cost_share=0):
         group_orders = self.procurement_group_id.mrp_production_ids
         move_dest_ids = self.move_dest_ids
         if len(group_orders) > 1:
             move_dest_ids |= group_orders[0].move_finished_ids.filtered(lambda m: m.product_id == self.product_id).move_dest_ids
-        date_planned_finished = self.date_planned_start + relativedelta(days=self.product_id.produce_delay)
-        date_planned_finished = date_planned_finished + relativedelta(days=self.company_id.manufacturing_lead)
-        if date_planned_finished == self.date_planned_start:
-            date_planned_finished = date_planned_finished + relativedelta(hours=1)
         return {
             'product_id': product_id,
             'product_uom_qty': product_uom_qty,
             'product_uom': product_uom,
             'operation_id': operation_id,
             'byproduct_id': byproduct_id,
-            'name': self.name,
-            'date': date_planned_finished,
+            'name': _('New'),
+            'date': self.date_finished,
             'date_deadline': self.date_deadline,
             'picking_type_id': self.picking_type_id.id,
             'location_id': self.product_id.with_company(self.company_id).property_stock_production.id,
             'location_dest_id': self.location_dest_id.id,
             'company_id': self.company_id.id,
             'production_id': self.id,
-            'warehouse_id': self.location_dest_id.get_warehouse().id,
-            'origin': self.name,
+            'warehouse_id': self.location_dest_id.warehouse_id.id,
+            'origin': self.product_id.partner_ref,
             'group_id': self.procurement_group_id.id,
             'propagate_cancel': self.propagate_cancel,
-            'move_dest_ids': [(4, x.id) for x in move_dest_ids],
+            'move_dest_ids': [(4, x.id) for x in self.move_dest_ids if not byproduct_id],
+            'cost_share': cost_share,
         }
 
     def _get_moves_finished_values(self):
@@ -838,18 +1114,44 @@ class MrpProduction(models.Model):
         for production in self:
             if production.product_id in production.bom_id.byproduct_ids.mapped('product_id'):
                 raise UserError(_("You cannot have %s  as the finished product and in the Byproducts", self.product_id.name))
-            moves.append(production._get_move_finished_values(production.product_id.id, production.product_qty, production.product_uom_id.id))
+            finished_move_values = production._get_move_finished_values(production.product_id.id, production.product_qty, production.product_uom_id.id)
+            finished_move_values['location_final_id'] = self.location_final_id.id
+            moves.append(finished_move_values)
             for byproduct in production.bom_id.byproduct_ids:
+                if byproduct._skip_byproduct_line(production.product_id):
+                    continue
                 product_uom_factor = production.product_uom_id._compute_quantity(production.product_qty, production.bom_id.product_uom_id)
                 qty = byproduct.product_qty * (product_uom_factor / production.bom_id.product_qty)
                 moves.append(production._get_move_finished_values(
                     byproduct.product_id.id, qty, byproduct.product_uom_id.id,
-                    byproduct.operation_id.id, byproduct.id))
+                    byproduct.operation_id.id, byproduct.id, byproduct.cost_share))
         return moves
 
+    def _create_update_move_finished(self):
+        """ This is a helper function to support complexity of onchange logic for MOs.
+        It is important that the special *2Many commands used here remain as long as function
+        is used within onchanges.
+        """
+        list_move_finished = []
+        moves_finished_values = self._get_moves_finished_values()
+        moves_byproduct_dict = {move.byproduct_id.id: move for move in self.move_finished_ids.filtered(lambda m: m.byproduct_id)}
+        move_finished = self.move_finished_ids.filtered(lambda m: m.product_id == self.product_id)
+        for move_finished_values in moves_finished_values:
+            if move_finished_values.get('byproduct_id') in moves_byproduct_dict:
+                # update existing entries
+                list_move_finished += [Command.update(moves_byproduct_dict[move_finished_values['byproduct_id']].id, move_finished_values)]
+            elif move_finished_values.get('product_id') == self.product_id.id and move_finished:
+                list_move_finished += [Command.update(move_finished.id, move_finished_values)]
+            else:
+                # add new entries
+                list_move_finished += [Command.create(move_finished_values)]
+        self.move_finished_ids = list_move_finished
+
     def _get_moves_raw_values(self):
         moves = []
         for production in self:
+            if not production.bom_id:
+                continue
             factor = production.product_uom_id._compute_quantity(production.product_qty, production.bom_id.product_uom_id) / production.bom_id.product_qty
             boms, lines = production.bom_id.explode(production.product_id, factor, picking_type=production.bom_id.picking_type_id)
             for bom_line, line_data in lines:
@@ -866,16 +1168,20 @@ class MrpProduction(models.Model):
                 ))
         return moves
 
-    def _get_move_raw_values(self, product_id, product_uom_qty, product_uom, operation_id=False, bom_line=False):
+    def _get_move_raw_values(self, product, product_uom_qty, product_uom, operation_id=False, bom_line=False):
+        """ Warning, any changes done to this method will need to be repeated for consistency in:
+            - Manually added components, i.e. "default_" values in view
+            - Moves from a copied MO, i.e. move.create
+            - Existing moves during backorder creation """
         source_location = self.location_src_id
         data = {
             'sequence': bom_line.sequence if bom_line else 10,
-            'name': self.name,
-            'date': self.date_planned_start,
-            'date_deadline': self.date_planned_start,
+            'name': _('New'),
+            'date': self.date_start,
+            'date_deadline': self.date_start,
             'bom_line_id': bom_line.id if bom_line else False,
             'picking_type_id': self.picking_type_id.id,
-            'product_id': product_id.id,
+            'product_id': product.id,
             'product_uom_qty': product_uom_qty,
             'product_uom': product_uom.id,
             'location_id': source_location.id,
@@ -883,57 +1189,79 @@ class MrpProduction(models.Model):
             'raw_material_production_id': self.id,
             'company_id': self.company_id.id,
             'operation_id': operation_id,
-            'price_unit': product_id.standard_price,
+            'price_unit': product.standard_price,
             'procure_method': 'make_to_stock',
-            'origin': self.name,
+            'origin': self._get_origin(),
             'state': 'draft',
-            'warehouse_id': source_location.get_warehouse().id,
+            'warehouse_id': source_location.warehouse_id.id,
             'group_id': self.procurement_group_id.id,
             'propagate_cancel': self.propagate_cancel,
+            'manual_consumption': self.env['stock.move']._determine_is_manual_consumption(bom_line),
         }
         return data
 
-    def _set_qty_producing(self):
+    def _get_origin(self):
+        origin = self.name
+        if self.orderpoint_id and self.origin:
+            origin = self.origin.replace(
+                '%s - ' % (self.orderpoint_id.display_name), '')
+            origin = '%s,%s' % (origin, self.name)
+        return origin
+
+    def _set_qty_producing(self, pick_manual_consumption_moves=True):
         if self.product_id.tracking == 'serial':
             qty_producing_uom = self.product_uom_id._compute_quantity(self.qty_producing, self.product_id.uom_id, rounding_method='HALF-UP')
             if qty_producing_uom != 1:
                 self.qty_producing = self.product_id.uom_id._compute_quantity(1, self.product_uom_id, rounding_method='HALF-UP')
-
         for move in (self.move_raw_ids | self.move_finished_ids.filtered(lambda m: m.product_id != self.product_id)):
-            if move._should_bypass_set_qty_producing():
+            # picked + manual means the user set the quantity manually
+            if move.manual_consumption and move.picked:
                 continue
-            new_qty = self.product_uom_id._compute_quantity((self.qty_producing - self.qty_produced) * move.unit_factor, self.product_uom_id, rounding_method='HALF-UP')
-            move.move_line_ids.filtered(lambda ml: ml.state not in ('done', 'cancel')).qty_done = 0
-            move.move_line_ids = move._set_quantity_done_prepare_vals(new_qty)
+
+            # sudo needed for portal users
+            if move.sudo()._should_bypass_set_qty_producing():
+                continue
+
+            new_qty = float_round((self.qty_producing - self.qty_produced) * move.unit_factor, precision_rounding=move.product_uom.rounding)
+            move._set_quantity_done(new_qty)
+            if not move.manual_consumption or pick_manual_consumption_moves:
+                move.picked = True
+
+    def _should_postpone_date_finished(self, date_finished):
+        self.ensure_one()
+        return date_finished == self.date_start
 
     def _update_raw_moves(self, factor):
         self.ensure_one()
         update_info = []
-        move_to_unlink = self.env['stock.move']
         for move in self.move_raw_ids.filtered(lambda m: m.state not in ('done', 'cancel')):
             old_qty = move.product_uom_qty
-            new_qty = old_qty * factor
+            new_qty = float_round(old_qty * factor, precision_rounding=move.product_uom.rounding, rounding_method='UP')
             if new_qty > 0:
+                # procurement and assigning is now run in write
                 move.write({'product_uom_qty': new_qty})
-                move._action_assign()
                 update_info.append((move, old_qty, new_qty))
-            else:
-                if move.quantity_done > 0:
-                    raise UserError(_('Lines need to be deleted, but can not as you still have some quantities to consume in them. '))
-                move._action_cancel()
-                move_to_unlink |= move
-        move_to_unlink.unlink()
         return update_info
 
+    @api.ondelete(at_uninstall=False)
+    def _unlink_except_done(self):
+        if any(production.state == 'done' for production in self):
+            raise UserError(_('Cannot delete a manufacturing order in done state.'))
+        not_cancel = self.filtered(lambda m: m.state != 'cancel')
+        if not_cancel:
+            productions_name = ', '.join([prod.display_name for prod in not_cancel])
+            raise UserError(_('%s cannot be deleted. Try to cancel them before.', productions_name))
+
     def _get_ready_to_produce_state(self):
         """ returns 'assigned' if enough components are reserved in order to complete
         the first operation of the bom. If not returns 'waiting'
         """
         self.ensure_one()
-        first_operation = self.bom_id.operation_ids[0]
-        if len(self.bom_id.operation_ids) == 1:
+        operations = self.workorder_ids.operation_id
+        if len(operations) == 1:
             moves_in_first_operation = self.move_raw_ids
         else:
+            first_operation = operations[0]
             moves_in_first_operation = self.move_raw_ids.filtered(lambda move: move.operation_id == first_operation)
         moves_in_first_operation = moves_in_first_operation.filtered(
             lambda move: move.bom_line_id and
@@ -955,28 +1283,46 @@ class MrpProduction(models.Model):
             if production.state in ('done', 'cancel'):
                 continue
             additional_moves = production.move_raw_ids.filtered(
-                lambda move: move.state == 'draft' and move.additional
+                lambda move: move.state == 'draft'
             )
-            additional_moves.write({
-                'group_id': production.procurement_group_id.id,
-            })
             additional_moves._adjust_procure_method()
             moves_to_confirm |= additional_moves
             additional_byproducts = production.move_finished_ids.filtered(
-                lambda move: move.state == 'draft' and move.additional
+                lambda move: move.state == 'draft'
             )
             moves_to_confirm |= additional_byproducts
 
         if moves_to_confirm:
-            moves_to_confirm._action_confirm()
+            moves_to_confirm = moves_to_confirm._action_confirm()
             # run scheduler for moves forecasted to not have enough in stock
             moves_to_confirm._trigger_scheduler()
 
         self.workorder_ids.filtered(lambda w: w.state not in ['done', 'cancel'])._action_confirm()
 
+    def _get_children(self):
+        self.ensure_one()
+        procurement_moves = self.procurement_group_id.stock_move_ids
+        child_moves = procurement_moves.move_orig_ids
+        return (procurement_moves | child_moves).created_production_id.procurement_group_id.mrp_production_ids.filtered(lambda p: p.origin != self.origin) - self
+
+    def _get_sources(self):
+        self.ensure_one()
+        dest_moves = self.procurement_group_id.mrp_production_ids.move_dest_ids
+        parent_moves = self.procurement_group_id.stock_move_ids.move_dest_ids
+        return (dest_moves | parent_moves).group_id.mrp_production_ids.filtered(lambda p: p.origin != self.origin) - self
+
+    def set_qty_producing(self):
+        # This method is used to call `_set_lot_producing` when the onchange doesn't apply.
+        self.ensure_one()
+        self._set_qty_producing()
+
+    def _set_lot_producing(self):
+        self.ensure_one()
+        self.lot_producing_id = self.env['stock.lot'].create(self._prepare_stock_lot_values())
+
     def action_view_mrp_production_childs(self):
         self.ensure_one()
-        mrp_production_ids = self.procurement_group_id.stock_move_ids.created_production_id.procurement_group_id.mrp_production_ids.ids
+        mrp_production_ids = self._get_children().ids
         action = {
             'res_model': 'mrp.production',
             'type': 'ir.actions.act_window',
@@ -988,7 +1334,7 @@ class MrpProduction(models.Model):
             })
         else:
             action.update({
-                'name': _("%s Child MO's") % self.name,
+                'name': _("%s Child MO's", self.name),
                 'domain': [('id', 'in', mrp_production_ids)],
                 'view_mode': 'tree,form',
             })
@@ -996,7 +1342,7 @@ class MrpProduction(models.Model):
 
     def action_view_mrp_production_sources(self):
         self.ensure_one()
-        mrp_production_ids = self.procurement_group_id.mrp_production_ids.move_dest_ids.group_id.mrp_production_ids.ids
+        mrp_production_ids = self._get_sources().ids
         action = {
             'res_model': 'mrp.production',
             'type': 'ir.actions.act_window',
@@ -1008,7 +1354,7 @@ class MrpProduction(models.Model):
             })
         else:
             action.update({
-                'name': _("MO Generated by %s") % self.name,
+                'name': _("MO Generated by %s", self.name),
                 'domain': [('id', 'in', mrp_production_ids)],
                 'view_mode': 'tree,form',
             })
@@ -1024,40 +1370,43 @@ class MrpProduction(models.Model):
             'view_mode': 'tree,form',
         }
 
-    def action_generate_serial(self):
+    def _prepare_stock_lot_values(self):
         self.ensure_one()
-        self.lot_producing_id = self.env['stock.production.lot'].create({
+        name = self.env['ir.sequence'].next_by_code('stock.lot.serial')
+        exist_lot = not name or self.env['stock.lot'].search([
+            ('product_id', '=', self.product_id.id),
+            '|', ('company_id', '=', False), ('company_id', '=', self.company_id.id),
+            ('name', '=', name),
+        ], limit=1)
+        if exist_lot:
+            name = self.env['stock.lot']._get_next_serial(self.company_id, self.product_id)
+        if not name:
+            raise UserError(_("Please set the first Serial Number or a default sequence"))
+        return {
             'product_id': self.product_id.id,
-            'company_id': self.company_id.id
-        })
-        if self.move_finished_ids.filtered(lambda m: m.product_id == self.product_id).move_line_ids:
-            self.move_finished_ids.filtered(lambda m: m.product_id == self.product_id).move_line_ids.lot_id = self.lot_producing_id
+            'name': name,
+        }
+
+    def action_generate_serial(self):
+        self.ensure_one()
+        self._set_lot_producing()
         if self.product_id.tracking == 'serial':
             self._set_qty_producing()
-
-    def _action_generate_immediate_wizard(self):
-        view = self.env.ref('mrp.view_immediate_production')
-        return {
-            'name': _('Immediate Production?'),
-            'type': 'ir.actions.act_window',
-            'view_mode': 'form',
-            'res_model': 'mrp.immediate.production',
-            'views': [(view.id, 'form')],
-            'view_id': view.id,
-            'target': 'new',
-            'context': dict(self.env.context, default_mo_ids=[(4, mo.id) for mo in self]),
-        }
+        if self.picking_type_id.auto_print_generated_mrp_lot:
+            return self._autoprint_generated_lot(self.lot_producing_id)
 
     def action_confirm(self):
         self._check_company()
+        moves_ids_to_confirm = set()
+        move_raws_ids_to_adjust = set()
+        workorder_ids_to_confirm = set()
         for production in self:
+            production_vals = {}
             if production.bom_id:
-                production.consumption = production.bom_id.consumption
-            if not production.move_raw_ids:
-                raise UserError(_("Add some materials to consume before marking this MO as to do."))
+                production_vals.update({'consumption': production.bom_id.consumption})
             # In case of Serial number tracking, force the UoM to the UoM of product
             if production.product_tracking == 'serial' and production.product_uom_id != production.product_id.uom_id:
-                production.write({
+                production_vals.update({
                     'product_qty': production.product_uom_id._compute_quantity(production.product_qty, production.product_id.uom_id),
                     'product_uom_id': production.product_id.uom_id
                 })
@@ -1066,13 +1415,63 @@ class MrpProduction(models.Model):
                         'product_uom_qty': move_finish.product_uom._compute_quantity(move_finish.product_uom_qty, move_finish.product_id.uom_id),
                         'product_uom': move_finish.product_id.uom_id
                     })
-            production.move_raw_ids._adjust_procure_method()
-            (production.move_raw_ids | production.move_finished_ids)._action_confirm()
-            production.workorder_ids._action_confirm()
-            # run scheduler for moves forecasted to not have enough in stock
-            production.move_raw_ids._trigger_scheduler()
+            if production_vals:
+                production.write(production_vals)
+            move_raws_ids_to_adjust.update(production.move_raw_ids.ids)
+            moves_ids_to_confirm.update((production.move_raw_ids | production.move_finished_ids).ids)
+            workorder_ids_to_confirm.update(production.workorder_ids.ids)
+
+        move_raws_to_adjust = self.env['stock.move'].browse(sorted(move_raws_ids_to_adjust))
+        moves_to_confirm = self.env['stock.move'].browse(sorted(moves_ids_to_confirm))
+        workorder_to_confirm = self.env['mrp.workorder'].browse(sorted(workorder_ids_to_confirm))
+
+        move_raws_to_adjust._adjust_procure_method()
+        moves_to_confirm._action_confirm(merge=False)
+        workorder_to_confirm._action_confirm()
+        # run scheduler for moves forecasted to not have enough in stock
+        ignored_mo_ids = self.env.context.get('ignore_mo_ids', [])
+        self.move_raw_ids.with_context(ignore_mo_ids=ignored_mo_ids + self.ids)._trigger_scheduler()
+        self.picking_ids.filtered(
+            lambda p: p.state not in ['cancel', 'done']).action_confirm()
+        # Force confirm state only for draft production not for more advanced state like
+        # 'progress' (in case of backorders with some qty_producing)
+        self.filtered(lambda mo: mo.state == 'draft').state = 'confirmed'
         return True
 
+    def _link_workorders_and_moves(self):
+        self.ensure_one()
+        if not self.workorder_ids:
+            return
+        workorder_per_operation = {workorder.operation_id: workorder for workorder in self.workorder_ids}
+        workorder_boms = self.workorder_ids.operation_id.bom_id
+        last_workorder_per_bom = defaultdict(lambda: self.env['mrp.workorder'])
+        self.allow_workorder_dependencies = self.bom_id.allow_operation_dependencies
+        if self.allow_workorder_dependencies:
+            for workorder in self.workorder_ids:
+                workorder.blocked_by_workorder_ids = [Command.link(workorder_per_operation[operation_id].id)
+                                                      for operation_id in
+                                                      workorder.operation_id.blocked_by_operation_ids
+                                                      if operation_id in workorder_per_operation]
+                if not workorder.needed_by_workorder_ids:
+                    last_workorder_per_bom[workorder.operation_id.bom_id] = workorder
+        else:
+            previous_workorder = False
+            for workorder in self.workorder_ids:
+                if previous_workorder and previous_workorder.operation_id.bom_id == workorder.operation_id.bom_id:
+                    workorder.blocked_by_workorder_ids = [Command.link(previous_workorder.id)]
+                previous_workorder = workorder
+                last_workorder_per_bom[workorder.operation_id.bom_id] = workorder
+        for move in (self.move_raw_ids | self.move_finished_ids):
+            if move.operation_id:
+                move.write({
+                    'workorder_id': workorder_per_operation[move.operation_id].id if move.operation_id in workorder_per_operation else False
+                })
+            else:
+                bom = move.bom_line_id.bom_id if (move.bom_line_id and move.bom_line_id.bom_id in workorder_boms) else self.bom_id
+                move.write({
+                    'workorder_id': last_workorder_per_bom[bom].id
+                })
+
     def action_assign(self):
         for production in self:
             production.move_raw_ids._action_assign()
@@ -1081,8 +1480,9 @@ class MrpProduction(models.Model):
     def button_plan(self):
         """ Create work orders. And probably do stuff, like things. """
         orders_to_plan = self.filtered(lambda order: not order.is_planned)
+        orders_to_confirm = orders_to_plan.filtered(lambda mo: mo.state == 'draft')
+        orders_to_confirm.action_confirm()
         for order in orders_to_plan:
-            (order.move_raw_ids | order.move_finished_ids).filtered(lambda m: m.state == 'draft')._action_confirm()
             order._plan_workorders()
         return True
 
@@ -1090,84 +1490,42 @@ class MrpProduction(models.Model):
         """ Plan all the production's workorders depending on the workcenters
         work schedule.
 
-        :param replan: If it is a replan, only ready and pending workorder will be take in account
+        :param replan: If it is a replan, only ready and pending workorder will be taken into account
         :type replan: bool.
         """
         self.ensure_one()
 
         if not self.workorder_ids:
             return
-        # Schedule all work orders (new ones and those already created)
-        qty_to_produce = max(self.product_qty - self.qty_produced, 0)
-        qty_to_produce = self.product_uom_id._compute_quantity(qty_to_produce, self.product_id.uom_id)
-        start_date = max(self.date_planned_start, datetime.datetime.now())
-        if replan:
-            workorder_ids = self.workorder_ids.filtered(lambda wo: wo.state in ['ready', 'pending'])
-            # We plan the manufacturing order according to its `date_planned_start`, but if
-            # `date_planned_start` is in the past, we plan it as soon as possible.
-            workorder_ids.leave_id.unlink()
-        else:
-            workorder_ids = self.workorder_ids.filtered(lambda wo: not wo.date_planned_start)
-        for workorder in workorder_ids:
-            workcenters = workorder.workcenter_id | workorder.workcenter_id.alternative_workcenter_ids
-
-            best_finished_date = datetime.datetime.max
-            vals = {}
-            for workcenter in workcenters:
-                # compute theoretical duration
-                if workorder.workcenter_id == workcenter:
-                    duration_expected = workorder.duration_expected
-                else:
-                    duration_expected = workorder._get_duration_expected(alternative_workcenter=workcenter)
 
-                from_date, to_date = workcenter._get_first_available_slot(start_date, duration_expected)
-                # If the workcenter is unavailable, try planning on the next one
-                if not from_date:
-                    continue
-                # Check if this workcenter is better than the previous ones
-                if to_date and to_date < best_finished_date:
-                    best_start_date = from_date
-                    best_finished_date = to_date
-                    best_workcenter = workcenter
-                    vals = {
-                        'workcenter_id': workcenter.id,
-                        'duration_expected': duration_expected,
-                    }
+        self._link_workorders_and_moves()
+
+        # Plan workorders starting from final ones (those with no dependent workorders)
+        final_workorders = self.workorder_ids.filtered(lambda wo: not wo.needed_by_workorder_ids)
+        for workorder in final_workorders:
+            workorder._plan_workorder(replan)
+
+        workorders = self.workorder_ids.filtered(lambda w: w.state not in ['done', 'cancel'])
+        if not workorders:
+            return
 
-            # If none of the workcenter are available, raise
-            if best_finished_date == datetime.datetime.max:
-                raise UserError(_('Impossible to plan the workorder. Please check the workcenter availabilities.'))
-
-            # Instantiate start_date for the next workorder planning
-            if workorder.next_work_order_id:
-                start_date = best_finished_date
-
-            # Create leave on chosen workcenter calendar
-            leave = self.env['resource.calendar.leaves'].create({
-                'name': workorder.display_name,
-                'calendar_id': best_workcenter.resource_calendar_id.id,
-                'date_from': best_start_date,
-                'date_to': best_finished_date,
-                'resource_id': best_workcenter.resource_id.id,
-                'time_type': 'other'
-            })
-            vals['leave_id'] = leave.id
-            workorder.write(vals)
         self.with_context(force_date=True).write({
-            'date_planned_start': self.workorder_ids[0].date_planned_start,
-            'date_planned_finished': self.workorder_ids[-1].date_planned_finished
+            'date_start': min([workorder.leave_id.date_from for workorder in workorders]),
+            'date_finished': max([workorder.leave_id.date_to for workorder in workorders])
         })
 
     def button_unplan(self):
         if any(wo.state == 'done' for wo in self.workorder_ids):
-            raise UserError(_("Some work orders are already done, you cannot unplan this manufacturing order."))
+            raise UserError(_("Some work orders are already done, so you cannot unplan this manufacturing order.\n\n"
+                "It’d be a shame to waste all that progress, right?"))
         elif any(wo.state == 'progress' for wo in self.workorder_ids):
-            raise UserError(_("Some work orders have already started, you cannot unplan this manufacturing order."))
+            raise UserError(_("Some work orders have already started, so you cannot unplan this manufacturing order.\n\n"
+                "It’d be a shame to waste all that progress, right?"))
 
         self.workorder_ids.leave_id.unlink()
         self.workorder_ids.write({
-            'date_planned_start': False,
-            'date_planned_finished': False,
+            'date_start': False,
+            'date_finished': False,
         })
 
     def _get_consumption_issues(self):
@@ -1180,7 +1538,7 @@ class MrpProduction(models.Model):
         :rtype: list
         """
         issues = []
-        if self.env.context.get('skip_consumption', False) or self.env.context.get('skip_immediate', False):
+        if self.env.context.get('skip_consumption', False):
             return issues
         for order in self:
             if order.consumption == 'flexible' or not order.bom_id or not order.bom_id.bom_line_ids:
@@ -1195,17 +1553,19 @@ class MrpProduction(models.Model):
 
             done_qty_by_product = defaultdict(float)
             for move in order.move_raw_ids:
-                qty_done = move.product_uom._compute_quantity(move.quantity_done, move.product_id.uom_id)
+                quantity = move.product_uom._compute_quantity(move._get_picked_quantity(), move.product_id.uom_id)
                 rounding = move.product_id.uom_id.rounding
-                if not (move.product_id in expected_qty_by_product or float_is_zero(qty_done, precision_rounding=rounding)):
-                    issues.append((order, move.product_id, qty_done, 0.0))
+                # extra lines with non-zero qty picked
+                if move.product_id not in expected_qty_by_product and move.picked and not float_is_zero(quantity, precision_rounding=rounding):
+                    issues.append((order, move.product_id, quantity, 0.0))
                     continue
-                done_qty_by_product[move.product_id] += qty_done
+                done_qty_by_product[move.product_id] += quantity if move.picked else 0.0
 
+            # origin lines from bom with different qty
             for product, qty_to_consume in expected_qty_by_product.items():
-                qty_done = done_qty_by_product.get(product, 0.0)
-                if float_compare(qty_to_consume, qty_done, precision_rounding=product.uom_id.rounding) != 0:
-                    issues.append((order, product, qty_done, qty_to_consume))
+                quantity = done_qty_by_product.get(product, 0.0)
+                if float_compare(qty_to_consume, quantity, precision_rounding=product.uom_id.rounding) != 0:
+                    issues.append((order, product, quantity, qty_to_consume))
 
         return issues
 
@@ -1221,7 +1581,9 @@ class MrpProduction(models.Model):
                 'product_consumed_qty_uom': consumed_qty,
                 'product_expected_qty_uom': expected_qty
             }))
-        ctx.update({'default_mrp_production_ids': self.ids, 'default_mrp_consumption_warning_line_ids': lines})
+        ctx.update({'default_mrp_production_ids': self.ids,
+                    'default_mrp_consumption_warning_line_ids': lines,
+                    'form_view_ref': False})
         action = self.env["ir.actions.actions"]._for_xml_id("mrp.action_mrp_consumption_warning")
         action['context'] = ctx
         return action
@@ -1251,9 +1613,6 @@ class MrpProduction(models.Model):
     def action_cancel(self):
         """ Cancels production order, unfinished stock moves and set procurement
         orders in exception """
-        if not self.move_raw_ids:
-            self.state = 'cancel'
-            return True
         self._action_cancel()
         return True
 
@@ -1277,7 +1636,6 @@ class MrpProduction(models.Model):
         self.workorder_ids.filtered(lambda x: x.state not in ['done', 'cancel']).action_cancel()
         finish_moves = self.move_finished_ids.filtered(lambda x: x.state not in ('done', 'cancel'))
         raw_moves = self.move_raw_ids.filtered(lambda x: x.state not in ('done', 'cancel'))
-
         (finish_moves | raw_moves)._action_cancel()
         picking_ids = self.picking_ids.filtered(lambda x: x.state not in ('done', 'cancel'))
         picking_ids.action_cancel()
@@ -1311,27 +1669,44 @@ class MrpProduction(models.Model):
         return True
 
     def _post_inventory(self, cancel_backorder=False):
+        moves_to_do, moves_not_to_do, moves_to_cancel = set(), set(), set()
+        for move in self.move_raw_ids:
+            if move.state == 'done':
+                moves_not_to_do.add(move.id)
+            elif not move.picked:
+                moves_to_cancel.add(move.id)
+            elif move.state != 'cancel':
+                moves_to_do.add(move.id)
+
+        self.with_context(skip_mo_check=True).env['stock.move'].browse(moves_to_do)._action_done(cancel_backorder=cancel_backorder)
+        self.with_context(skip_mo_check=True).env['stock.move'].browse(moves_to_cancel)._action_cancel()
+        moves_to_do = self.move_raw_ids.filtered(lambda x: x.state == 'done') - self.env['stock.move'].browse(moves_not_to_do)
+        # Create a dict to avoid calling filtered inside for loops.
+        moves_to_do_by_order = defaultdict(lambda: self.env['stock.move'], [
+            (key, self.env['stock.move'].concat(*values))
+            for key, values in tools_groupby(moves_to_do, key=lambda m: m.raw_material_production_id.id)
+        ])
         for order in self:
-            moves_not_to_do = order.move_raw_ids.filtered(lambda x: x.state == 'done')
-            moves_to_do = order.move_raw_ids.filtered(lambda x: x.state not in ('done', 'cancel'))
-            for move in moves_to_do.filtered(lambda m: m.product_qty == 0.0 and m.quantity_done > 0):
-                move.product_uom_qty = move.quantity_done
-            # MRP do not merge move, catch the result of _action_done in order
-            # to get extra moves.
-            moves_to_do = moves_to_do._action_done()
-            moves_to_do = order.move_raw_ids.filtered(lambda x: x.state == 'done') - moves_not_to_do
-
             finish_moves = order.move_finished_ids.filtered(lambda m: m.product_id == order.product_id and m.state not in ('done', 'cancel'))
             # the finish move can already be completed by the workorder.
-            if not finish_moves.quantity_done:
-                finish_moves.quantity_done = float_round(order.qty_producing - order.qty_produced, precision_rounding=order.product_uom_id.rounding, rounding_method='HALF-UP')
-                finish_moves.move_line_ids.lot_id = order.lot_producing_id
-            order._cal_price(moves_to_do)
-
-            moves_to_finish = order.move_finished_ids.filtered(lambda x: x.state not in ('done', 'cancel'))
-            moves_to_finish = moves_to_finish._action_done(cancel_backorder=cancel_backorder)
-            order.action_assign()
-            consume_move_lines = moves_to_do.mapped('move_line_ids')
+            for move in finish_moves:
+                move.quantity = float_round(order.qty_producing - order.qty_produced, precision_rounding=order.product_uom_id.rounding, rounding_method='HALF-UP')
+                extra_vals = order._prepare_finished_extra_vals()
+                if extra_vals:
+                    move.move_line_ids.write(extra_vals)
+            # workorder duration need to be set to calculate the price of the product
+            for workorder in order.workorder_ids:
+                if workorder.state not in ('done', 'cancel'):
+                    workorder.duration_expected = workorder._get_duration_expected()
+                if workorder.duration == 0.0:
+                    workorder.duration = workorder.duration_expected * order.qty_producing / order.product_qty
+                    workorder.duration_unit = round(workorder.duration / max(workorder.qty_produced, 1), 2)
+            order._cal_price(moves_to_do_by_order[order.id])
+        moves_to_finish = self.move_finished_ids.filtered(lambda x: x.state not in ('done', 'cancel'))
+        moves_to_finish.picked = True
+        moves_to_finish = moves_to_finish._action_done(cancel_backorder=cancel_backorder)
+        for order in self:
+            consume_move_lines = moves_to_do_by_order[order.id].mapped('move_line_ids')
             order.move_finished_ids.move_line_ids.consume_line_ids = [(6, 0, consume_move_lines.ids)]
         return True
 
@@ -1340,92 +1715,274 @@ class MrpProduction(models.Model):
         if not sequence:
             return name
         seq_back = "-" + "0" * (SIZE_BACK_ORDER_NUMERING - 1 - int(math.log10(sequence))) + str(sequence)
-        if re.search("-\\d{%d}$" % SIZE_BACK_ORDER_NUMERING, name):
-            return name[:-SIZE_BACK_ORDER_NUMERING-1] + seq_back
+        regex = re.compile(r"-\d+$")
+        if regex.search(name) and sequence > 1:
+            return regex.sub(seq_back, name)
         return name + seq_back
 
     def _get_backorder_mo_vals(self):
         self.ensure_one()
-        next_seq = max(self.procurement_group_id.mrp_production_ids.mapped("backorder_sequence"))
+        if not self.procurement_group_id:
+            # in the rare case that the procurement group has been removed somehow, create a new one
+            self.procurement_group_id = self.env["procurement.group"].create({'name': self.name})
         return {
-            'name': self._get_name_backorder(self.name, next_seq + 1),
-            'backorder_sequence': next_seq + 1,
             'procurement_group_id': self.procurement_group_id.id,
             'move_raw_ids': None,
             'move_finished_ids': None,
-            'product_qty': self._get_quantity_to_backorder(),
             'lot_producing_id': False,
-            'origin': self.origin
+            'origin': self.origin,
+            'state': 'draft' if self.state == 'draft' else 'confirmed',
+            'date_deadline': self.date_deadline,
+            'orderpoint_id': self.orderpoint_id.id,
         }
 
-    def _generate_backorder_productions(self, close_mo=True):
-        backorders = self.env['mrp.production']
+    def _split_productions(self, amounts=False, cancel_remaining_qty=False, set_consumed_qty=False):
+        """ Splits productions into productions smaller quantities to produce, i.e. creates
+        its backorders.
+
+        :param dict amounts: a dict with a production as key and a list value containing
+        the amounts each production split should produce including the original production,
+        e.g. {mrp.production(1,): [3, 2]} will result in mrp.production(1,) having a product_qty=3
+        and a new backorder with product_qty=2.
+        :param bool cancel_remaining_qty: whether to cancel remaining quantities or generate
+        an additional backorder, e.g. having product_qty=5 if mrp.production(1,) product_qty was 10.
+        :param bool set_consumed_qty: whether to set quantity on move lines to the reserved quantity
+        or the initial demand if no reservation, except for the remaining backorder.
+        :return: mrp.production records in order of [orig_prod_1, backorder_prod_1,
+        backorder_prod_2, orig_prod_2, backorder_prod_2, etc.]
+        """
+        def _default_amounts(production):
+            return [production.qty_producing, production._get_quantity_to_backorder()]
+
+        if not amounts:
+            amounts = {}
+        has_backorder_to_ignore = defaultdict(lambda: False)
+        for production in self:
+            mo_amounts = amounts.get(production)
+            if not mo_amounts:
+                amounts[production] = _default_amounts(production)
+                continue
+            total_amount = sum(mo_amounts)
+            diff = float_compare(production.product_qty, total_amount, precision_rounding=production.product_uom_id.rounding)
+            if diff > 0 and not cancel_remaining_qty:
+                amounts[production].append(production.product_qty - total_amount)
+                has_backorder_to_ignore[production] = True
+            elif not self.env.context.get('allow_more') and (diff < 0 or production.state in ['done', 'cancel']):
+                raise UserError(_("Unable to split with more than the quantity to produce."))
+
+        backorder_vals_list = []
+        initial_qty_by_production = {}
+
+        # Create the backorders.
         for production in self:
+            initial_qty_by_production[production] = production.product_qty
             if production.backorder_sequence == 0:  # Activate backorder naming
                 production.backorder_sequence = 1
-            backorder_mo = production.copy(default=production._get_backorder_mo_vals())
-            if close_mo:
-                production.move_raw_ids.filtered(lambda m: m.state not in ('done', 'cancel')).write({
-                    'raw_material_production_id': backorder_mo.id,
-                })
-                production.move_finished_ids.filtered(lambda m: m.state not in ('done', 'cancel')).write({
-                    'production_id': backorder_mo.id,
+            production.name = self._get_name_backorder(production.name, production.backorder_sequence)
+            (production.move_raw_ids | production.move_finished_ids).name = production.name
+            (production.move_raw_ids | production.move_finished_ids).origin = production._get_origin()
+            backorder_vals = production.copy_data(default=production._get_backorder_mo_vals())[0]
+            backorder_qtys = amounts[production][1:]
+            production.with_context(skip_compute_move_raw_ids=True).product_qty = amounts[production][0]
+
+            next_seq = max(production.procurement_group_id.mrp_production_ids.mapped("backorder_sequence"), default=1)
+
+            for qty_to_backorder in backorder_qtys:
+                next_seq += 1
+                backorder_vals_list.append(dict(
+                    backorder_vals,
+                    product_qty=qty_to_backorder,
+                    name=production._get_name_backorder(production.name, next_seq),
+                    backorder_sequence=next_seq
+                ))
+
+        backorders = self.env['mrp.production'].with_context(skip_confirm=True).create(backorder_vals_list)
+
+        index = 0
+        production_to_backorders = {}
+        production_ids = OrderedSet()
+        for production in self:
+            number_of_backorder_created = len(amounts.get(production, _default_amounts(production))) - 1
+            production_backorders = backorders[index:index + number_of_backorder_created]
+            production_to_backorders[production] = production_backorders
+            production_ids.update(production.ids)
+            production_ids.update(production_backorders.ids)
+            index += number_of_backorder_created
+
+        # Split the `stock.move` among new backorders.
+        new_moves_vals = []
+        moves = []
+        move_to_backorder_moves = {}
+        for production in self:
+            for move in production.move_raw_ids | production.move_finished_ids:
+                if move.additional:
+                    continue
+                move_to_backorder_moves[move] = self.env['stock.move']
+                unit_factor = move.product_uom_qty / initial_qty_by_production[production]
+                initial_move_vals = move.copy_data(move._get_backorder_move_vals())[0]
+                move.with_context(do_not_unreserve=True, no_procurement=True).product_uom_qty = production.product_qty * unit_factor
+
+                for backorder in production_to_backorders[production]:
+                    move_vals = dict(
+                        initial_move_vals,
+                        product_uom_qty=backorder.product_qty * unit_factor
+                    )
+                    if move.raw_material_production_id:
+                        move_vals['raw_material_production_id'] = backorder.id
+                    else:
+                        move_vals['production_id'] = backorder.id
+                    new_moves_vals.append(move_vals)
+                    moves.append(move)
+
+        backorder_moves = self.env['stock.move'].create(new_moves_vals)
+        move_to_assign = backorder_moves
+        # Split `stock.move.line`s. 2 options for this:
+        # - do_unreserve -> action_assign
+        # - Split the reserved amounts manually
+        # The first option would be easier to maintain since it's less code
+        # However it could be slower (due to `stock.quant` update) and could
+        # create inconsistencies in mass production if a new lot higher in a
+        # FIFO strategy arrives between the reservation and the backorder creation
+        for move, backorder_move in zip(moves, backorder_moves):
+            move_to_backorder_moves[move] |= backorder_move
+
+        move_lines_vals = []
+        assigned_moves = set()
+        partially_assigned_moves = set()
+        move_lines_to_unlink = set()
+        moves_to_consume = self.env['stock.move']
+        for initial_move, backorder_moves in move_to_backorder_moves.items():
+            # Create `stock.move.line` for consumed but non-reserved components and for by-products
+            if set_consumed_qty and (initial_move.raw_material_production_id or (initial_move.production_id and initial_move.product_id != production.product_id)):
+                ml_vals = initial_move._prepare_move_line_vals()
+                backorder_move_to_ignore = backorder_moves[-1] if has_backorder_to_ignore[initial_move.raw_material_production_id] else self.env['stock.move']
+                for move in (initial_move + backorder_moves - backorder_move_to_ignore):
+                    if not initial_move.move_line_ids:
+                        new_ml_vals = dict(
+                            ml_vals,
+                            quantity=move.product_uom_qty,
+                            move_id=move.id
+                        )
+                        move_lines_vals.append(new_ml_vals)
+                    moves_to_consume |= move
+
+        for initial_move, backorder_moves in move_to_backorder_moves.items():
+            ml_by_move = []
+            product_uom = initial_move.product_id.uom_id
+            if not initial_move.picked:
+                for move_line in initial_move.move_line_ids:
+                    available_qty = move_line.product_uom_id._compute_quantity(move_line.quantity, product_uom, rounding_method="HALF-UP")
+                    if float_compare(available_qty, 0, precision_rounding=product_uom.rounding) <= 0:
+                        continue
+                    ml_by_move.append((available_qty, move_line, move_line.copy_data()[0]))
+
+            moves = list(initial_move | backorder_moves)
+
+            move = moves and moves.pop(0)
+            move_qty_to_reserve = move.product_qty  # Product UoM
+
+            for index, (quantity, move_line, ml_vals) in enumerate(ml_by_move):
+                taken_qty = min(quantity, move_qty_to_reserve)
+                taken_qty_uom = product_uom._compute_quantity(taken_qty, move_line.product_uom_id, rounding_method="HALF-UP")
+                if float_is_zero(taken_qty_uom, precision_rounding=move_line.product_uom_id.rounding):
+                    continue
+                move_line.write({
+                    'quantity': taken_qty_uom,
+                    'move_id': move.id,
                 })
-            else:
-                new_moves_vals = []
-                for move in production.move_raw_ids | production.move_finished_ids:
-                    if not move.additional:
-                        qty_to_split = move.product_uom_qty - move.unit_factor * production.qty_producing
-                        qty_to_split = move.product_uom._compute_quantity(qty_to_split, move.product_id.uom_id, rounding_method='HALF-UP')
-                        move_vals = move._split(qty_to_split)
-                        if not move_vals:
-                            continue
-                        if move.raw_material_production_id:
-                            move_vals[0]['raw_material_production_id'] = backorder_mo.id
-                        else:
-                            move_vals[0]['production_id'] = backorder_mo.id
-                        new_moves_vals.append(move_vals[0])
-                new_moves = self.env['stock.move'].create(new_moves_vals)
-            backorders |= backorder_mo
-            for old_wo, wo in zip(production.workorder_ids, backorder_mo.workorder_ids):
-                wo.qty_produced = max(old_wo.qty_produced - old_wo.qty_producing, 0)
-                if wo.product_tracking == 'serial':
-                    wo.qty_producing = 1
-                else:
-                    wo.qty_producing = wo.qty_remaining
+                move_qty_to_reserve -= taken_qty
+                ml_by_move[index] = (quantity - taken_qty, move_line, ml_vals)
+
+                if float_compare(move_qty_to_reserve, 0, precision_rounding=move.product_uom.rounding) <= 0:
+                    assigned_moves.add(move.id)
+                    move = moves and moves.pop(0)
+                    move_qty_to_reserve = move and move.product_qty or 0
+
+            for quantity, move_line, ml_vals in ml_by_move:
+                while float_compare(quantity, 0, precision_rounding=product_uom.rounding) > 0 and move:
+                    # Do not create `stock.move.line` if there is no initial demand on `stock.move`
+                    taken_qty = min(move_qty_to_reserve, quantity)
+                    taken_qty_uom = product_uom._compute_quantity(taken_qty, move_line.product_uom_id, rounding_method="HALF-UP")
+                    if move == initial_move:
+                        move_line.quantity += taken_qty_uom
+                    elif not float_is_zero(taken_qty_uom, precision_rounding=move_line.product_uom_id.rounding):
+                        new_ml_vals = dict(
+                            ml_vals,
+                            quantity=taken_qty_uom,
+                            move_id=move.id
+                        )
+                        move_lines_vals.append(new_ml_vals)
+                    quantity -= taken_qty
+                    move_qty_to_reserve -= taken_qty
+
+                    if float_compare(move_qty_to_reserve, 0, precision_rounding=move.product_uom.rounding) <= 0:
+                        assigned_moves.add(move.id)
+                        move = moves and moves.pop(0)
+                        move_qty_to_reserve = move and move.product_qty or 0
+
+                # Unreserve the quantity removed from initial `stock.move.line` and
+                # not assigned to a move anymore. In case of a split smaller than initial
+                # quantity and fully reserved
+                if quantity and not move_line.move_id._should_bypass_reservation():
+                    self.env['stock.quant']._update_reserved_quantity(
+                        move_line.product_id, move_line.location_id, -quantity,
+                        lot_id=move_line.lot_id, package_id=move_line.package_id,
+                        owner_id=move_line.owner_id, strict=True)
+
+            if move and move_qty_to_reserve != move.product_qty:
+                partially_assigned_moves.add(move.id)
+
+            move_lines_to_unlink.update(initial_move.move_line_ids.filtered(lambda ml: not ml.quantity).ids)
+
+        # reserve new backorder moves depending on the picking type
+        self.env['stock.move'].browse(assigned_moves).write({'state': 'assigned'})
+        self.env['stock.move'].browse(partially_assigned_moves).write({'state': 'partially_available'})
+        move_to_assign = move_to_assign.filtered(
+            lambda move: move.state in ('confirmed', 'partially_available')
+            and (move._should_bypass_reservation()
+                or move.picking_type_id.reservation_method == 'at_confirm'
+                or (move.reservation_date and move.reservation_date <= fields.Date.today())))
+        move_to_assign._action_assign()
+
+        # Avoid triggering a useless _recompute_state
+        self.env['stock.move.line'].browse(move_lines_to_unlink).write({'move_id': False})
+        self.env['stock.move.line'].browse(move_lines_to_unlink).unlink()
+        self.env['stock.move.line'].create(move_lines_vals)
+
+        moves_to_consume.write({'picked': True})
+
+        workorders_to_cancel = self.env['mrp.workorder']
+        for production in self:
+            initial_qty = initial_qty_by_production[production]
+            initial_workorder_remaining_qty = []
+            bo = production_to_backorders[production]
 
-            production.name = self._get_name_backorder(production.name, production.backorder_sequence)
+            # Adapt duration
+            for workorder in bo.workorder_ids:
+                workorder.duration_expected = workorder._get_duration_expected()
 
-            # We need to adapt `duration_expected` on both the original workorders and their
-            # backordered workorders. To do that, we use the original `duration_expected` and the
-            # ratio of the quantity really produced and the quantity to produce.
-            ratio = production.qty_producing / production.product_qty
+            # Adapt quantities produced
             for workorder in production.workorder_ids:
-                workorder.duration_expected = workorder.duration_expected * ratio
-            for workorder in backorder_mo.workorder_ids:
-                workorder.duration_expected = workorder.duration_expected * (1 - ratio)
-
-        # As we have split the moves before validating them, we need to 'remove' the excess reservation
-        if not close_mo:
-            self.move_raw_ids.filtered(lambda m: not m.additional)._do_unreserve()
-            self.move_raw_ids.filtered(lambda m: not m.additional)._action_assign()
-        # Confirm only productions with remaining components
-        backorders.filtered(lambda mo: mo.move_raw_ids).action_confirm()
-        backorders.filtered(lambda mo: mo.move_raw_ids).action_assign()
+                initial_workorder_remaining_qty.append(max(initial_qty - workorder.qty_reported_from_previous_wo - workorder.qty_produced, 0))
+                workorder.qty_produced = min(workorder.qty_produced, workorder.qty_production)
+            workorders_len = len(production.workorder_ids)
+            for index, workorder in enumerate(bo.workorder_ids):
+                remaining_qty = initial_workorder_remaining_qty[index % workorders_len]
+                workorder.qty_reported_from_previous_wo = max(workorder.qty_production - remaining_qty, 0)
+                if remaining_qty:
+                    initial_workorder_remaining_qty[index % workorders_len] = max(remaining_qty - workorder.qty_produced, 0)
+                else:
+                    workorders_to_cancel += workorder
+        workorders_to_cancel.action_cancel()
+        backorders._action_confirm_mo_backorders()
 
-        # Remove the serial move line without reserved quantity. Post inventory will assigned all the non done moves
-        # So those move lines are duplicated.
-        backorders.move_raw_ids.move_line_ids.filtered(lambda ml: ml.product_id.tracking == 'serial' and ml.product_qty == 0).unlink()
-        backorders.move_raw_ids._recompute_state()
+        return self.env['mrp.production'].browse(production_ids)
 
-        return backorders
+    def _action_confirm_mo_backorders(self):
+        self.workorder_ids._action_confirm()
 
     def button_mark_done(self):
-        self._button_mark_done_sanity_checks()
-
-        if not self.env.context.get('button_mark_done_production_ids'):
-            self = self.with_context(button_mark_done_production_ids=self.ids)
-        res = self._pre_button_mark_done()
+        res = self.pre_button_mark_done()
         if res is not True:
             return res
 
@@ -1438,9 +1995,11 @@ class MrpProduction(models.Model):
 
         self.workorder_ids.button_finish()
 
+        backorders = productions_to_backorder and productions_to_backorder._split_productions()
+        backorders = backorders - productions_to_backorder
+
         productions_not_to_backorder._post_inventory(cancel_backorder=True)
-        productions_to_backorder._post_inventory(cancel_backorder=False)
-        backorders = productions_to_backorder._generate_backorder_productions()
+        productions_to_backorder._post_inventory(cancel_backorder=True)
 
         # if completed products make other confirmed/partially_available moves available, assign them
         done_move_finished_ids = (productions_to_backorder.move_finished_ids | productions_not_to_backorder.move_finished_ids).filtered(lambda m: m.state == 'done')
@@ -1453,59 +2012,102 @@ class MrpProduction(models.Model):
             'state': 'done',
             'product_uom_qty': 0.0,
         })
-
         for production in self:
             production.write({
                 'date_finished': fields.Datetime.now(),
-                'product_qty': production.qty_produced,
                 'priority': '0',
                 'is_locked': True,
+                'state': 'done',
             })
 
-        for workorder in self.workorder_ids.filtered(lambda w: w.state not in ('done', 'cancel')):
-            workorder.duration_expected = workorder._get_duration_expected()
-
+        report_actions = self._get_autoprint_done_report_actions()
+        if self.env.context.get('skip_redirection'):
+            if report_actions:
+                return {
+                    'type': 'ir.actions.client',
+                    'tag': 'do_multi_print',
+                    'context': {},
+                    'params': {
+                        'reports': report_actions,
+                    }
+                }
+            return True
+        another_action = False
         if not backorders:
             if self.env.context.get('from_workorder'):
-                return {
+                another_action = {
                     'type': 'ir.actions.act_window',
                     'res_model': 'mrp.production',
                     'views': [[self.env.ref('mrp.mrp_production_form_view').id, 'form']],
                     'res_id': self.id,
                     'target': 'main',
                 }
+            elif self.env.user.has_group('mrp.group_mrp_reception_report'):
+                mos_to_show = self.filtered(lambda mo: mo.picking_type_id.auto_show_reception_report)
+                lines = mos_to_show.move_finished_ids.filtered(lambda m: m.product_id.type == 'product' and m.state != 'cancel' and m.picked and not m.move_dest_ids)
+                if lines:
+                    if any(mo.show_allocation for mo in mos_to_show):
+                        another_action = mos_to_show.action_view_reception_report()
+            if report_actions:
+                return {
+                    'type': 'ir.actions.client',
+                    'tag': 'do_multi_print',
+                    'params': {
+                        'reports': report_actions,
+                        'anotherAction': another_action,
+                    }
+                }
+            if another_action:
+                return another_action
             return True
         context = self.env.context.copy()
         context = {k: v for k, v in context.items() if not k.startswith('default_')}
         for k, v in context.items():
             if k.startswith('skip_'):
                 context[k] = False
-        action = {
+        another_action = {
             'res_model': 'mrp.production',
             'type': 'ir.actions.act_window',
             'context': dict(context, mo_ids_to_backorder=None)
         }
         if len(backorders) == 1:
-            action.update({
+            another_action.update({
+                'views': [[False, 'form']],
                 'view_mode': 'form',
                 'res_id': backorders[0].id,
             })
         else:
-            action.update({
+            another_action.update({
                 'name': _("Backorder MO"),
                 'domain': [('id', 'in', backorders.ids)],
+                'views': [[False, 'list'], [False, 'form']],
                 'view_mode': 'tree,form',
             })
-        return action
-
-    def _pre_button_mark_done(self):
-        productions_to_immediate = self._check_immediate()
-        if productions_to_immediate:
-            return productions_to_immediate._action_generate_immediate_wizard()
+        if report_actions:
+            return {
+                'type': 'ir.actions.client',
+                'tag': 'do_multi_print',
+                'params': {
+                    'reports': report_actions,
+                    'anotherAction': another_action,
+                }
+            }
+        return another_action
 
+    def pre_button_mark_done(self):
+        self._button_mark_done_sanity_checks()
+        productions_auto = set()
         for production in self:
-            if float_is_zero(production.qty_producing, precision_rounding=production.product_uom_id.rounding):
-                raise UserError(_('The quantity to produce must be positive!'))
+            if not float_is_zero(production.qty_producing, precision_rounding=production.product_uom_id.rounding):
+                production.move_raw_ids.filtered('manual_consumption').picked = True
+                continue
+            if production._auto_production_checks():
+                productions_auto.add(production.id)
+            else:
+                return production.action_mass_produce()
+
+        for production in self.env['mrp.production'].browse(productions_auto):
+            production._set_quantities()
 
         consumption_issues = self._get_consumption_issues()
         if consumption_issues:
@@ -1521,16 +2123,21 @@ class MrpProduction(models.Model):
         for order in self:
             order._check_sn_uniqueness()
 
+    def _auto_production_checks(self):
+        self.ensure_one()
+        return all(p.tracking == 'none' for p in self.move_raw_ids.product_id | self.move_finished_ids.product_id)\
+            or self.product_uom_qty == 1 or (self.product_id.tracking != 'serial' and self.reservation_state in ('assigned', 'confirmed'))
+
     def do_unreserve(self):
-        self.move_raw_ids.filtered(lambda x: x.state not in ('done', 'cancel'))._do_unreserve()
+        (self.move_finished_ids | self.move_raw_ids).filtered(lambda x: x.state not in ('done', 'cancel'))._do_unreserve()
 
     def button_scrap(self):
         self.ensure_one()
         return {
-            'name': _('Scrap'),
+            'name': _('Scrap Products'),
             'view_mode': 'form',
             'res_model': 'stock.scrap',
-            'view_id': self.env.ref('stock.stock_scrap_form_view2').id,
+            'views': [[self.env.ref('stock.stock_scrap_form_view2').id, 'form']],
             'type': 'ir.actions.act_window',
             'context': {'default_production_id': self.id,
                         'product_ids': (self.move_raw_ids.filtered(lambda x: x.state not in ('done', 'cancel')) | self.move_finished_ids.filtered(lambda x: x.state == 'done')).mapped('product_id').ids,
@@ -1546,21 +2153,31 @@ class MrpProduction(models.Model):
         action['context'] = dict(self._context, default_origin=self.name)
         return action
 
+    def action_view_reception_report(self):
+        action = self.env["ir.actions.actions"]._for_xml_id("mrp.mrp_reception_action")
+        # default_production_ids needs to be first default_ key so the "print" button correctly works
+        action['context'] = dict({'default_production_ids': self.ids}, **self.env.context)
+        return action
+
+    def action_view_mrp_production_unbuilds(self):
+        self.ensure_one()
+        action = self.env["ir.actions.actions"]._for_xml_id("mrp.mrp_unbuild")
+        action['domain'] = [('mo_id', '=', self.id)]
+        context = literal_eval(action['context'])
+        context.update(self.env.context)
+        context['default_mo_id'] = self.id
+        action['context'] = context
+        return action
+
     @api.model
-    def get_empty_list_help(self, help):
+    def get_empty_list_help(self, help_message):
         self = self.with_context(
             empty_list_help_document_name=_("manufacturing order"),
         )
-        return super(MrpProduction, self).get_empty_list_help(help)
+        return super(MrpProduction, self).get_empty_list_help(help_message)
 
     def _log_downside_manufactured_quantity(self, moves_modification, cancel=False):
 
-        def _keys_in_sorted(move):
-            """ sort by picking and the responsible for the product the
-            move.
-            """
-            return (move.picking_id.id, move.product_id.responsible_id.id)
-
         def _keys_in_groupby(move):
             """ group by picking and the responsible for the product the
             move.
@@ -1574,9 +2191,9 @@ class MrpProduction(models.Model):
                 'impacted_pickings': False,
                 'cancel': cancel
             }
-            return self.env.ref('mrp.exception_on_mo')._render(values=values)
+            return self.env['ir.qweb']._render('mrp.exception_on_mo', values)
 
-        documents = self.env['stock.picking']._log_activity_get_documents(moves_modification, 'move_dest_ids', 'DOWN', _keys_in_sorted, _keys_in_groupby)
+        documents = self.env['stock.picking']._log_activity_get_documents(moves_modification, 'move_dest_ids', 'DOWN', _keys_in_groupby)
         documents = self.env['stock.picking']._less_quantities_than_expected_add_documents(moves_modification, documents)
         self.env['stock.picking']._log_activity(_render_note_exception_quantity_mo, documents)
 
@@ -1589,9 +2206,10 @@ class MrpProduction(models.Model):
                 order_exception, visited = exception
                 order_exceptions.update(order_exception)
                 visited_objects += visited
-            visited_objects = self.env[visited_objects[0]._name].concat(*visited_objects)
+            visited_objects = [sm for sm in visited_objects if sm._name == 'stock.move']
             impacted_object = []
-            if visited_objects and visited_objects._name == 'stock.move':
+            if visited_objects:
+                visited_objects = self.env[visited_objects[0]._name].concat(*visited_objects)
                 visited_objects |= visited_objects.mapped('move_orig_ids')
                 impacted_object = visited_objects.filtered(lambda m: m.state not in ('done', 'cancel')).mapped('picking_id')
             values = {
@@ -1600,7 +2218,7 @@ class MrpProduction(models.Model):
                 'impacted_object': impacted_object,
                 'cancel': cancel
             }
-            return self.env.ref('mrp.exception_on_mo')._render(values=values)
+            return self.env['ir.qweb']._render('mrp.exception_on_mo', values)
 
         self.env['stock.picking']._log_activity(_render_note_exception_quantity_mo, documents)
 
@@ -1612,7 +2230,9 @@ class MrpProduction(models.Model):
             'res_model': 'mrp.unbuild',
             'view_id': self.env.ref('mrp.mrp_unbuild_form_view_simplified').id,
             'type': 'ir.actions.act_window',
-            'context': {'default_mo_id': self.id,
+            'context': {'default_product_id': self.product_id.id,
+                        'default_lot_id': self.lot_producing_id.id,
+                        'default_mo_id': self.id,
                         'default_company_id': self.company_id.id,
                         'default_location_id': self.location_dest_id.id,
                         'default_location_dest_id': self.location_src_id.id,
@@ -1620,6 +2240,255 @@ class MrpProduction(models.Model):
             'target': 'new',
         }
 
+    def action_mass_produce(self):
+        self.ensure_one()
+        self._check_company()
+        if self.state not in ['draft', 'confirmed', 'progress', 'to_close'] or\
+                self._auto_production_checks():
+            return
+
+        action = self.env["ir.actions.actions"]._for_xml_id("mrp.action_mrp_batch_produce")
+        action['context'] = {
+            'default_production_id': self.id,
+        }
+        return action
+
+    def action_split(self):
+        self._pre_action_split_merge_hook(split=True)
+        if len(self) > 1:
+            productions = [Command.create({'production_id': production.id}) for production in self]
+            # Wizard need a real id to have buttons enable in the view
+            wizard = self.env['mrp.production.split.multi'].create({'production_ids': productions})
+            action = self.env['ir.actions.actions']._for_xml_id('mrp.action_mrp_production_split_multi')
+            action['res_id'] = wizard.id
+            return action
+        else:
+            action = self.env['ir.actions.actions']._for_xml_id('mrp.action_mrp_production_split')
+            action['context'] = {
+                'default_production_id': self.id,
+            }
+            return action
+
+    def action_merge(self):
+        self._pre_action_split_merge_hook(merge=True)
+        products = set([(production.product_id, production.bom_id) for production in self])
+        product_id, bom_id = products.pop()
+        users = set([production.user_id for production in self])
+        if len(users) == 1:
+            user_id = users.pop()
+        else:
+            user_id = self.env.user
+
+        origs = self._prepare_merge_orig_links()
+        dests = {}
+        for move in self.move_finished_ids:
+            dests.setdefault(move.byproduct_id.id, []).extend(move.move_dest_ids.ids)
+
+        production = self.env['mrp.production'].with_context(default_picking_type_id=self.picking_type_id.id).create({
+            'product_id': product_id.id,
+            'bom_id': bom_id.id,
+            'picking_type_id': self.picking_type_id.id,
+            'product_qty': sum(production.product_uom_qty for production in self),
+            'product_uom_id': product_id.uom_id.id,
+            'user_id': user_id.id,
+            'origin': ",".join(sorted([production.name for production in self])),
+        })
+
+        for move in production.move_raw_ids:
+            for field, vals in origs[move.bom_line_id.id].items():
+                move[field] = vals
+
+        for move in production.move_finished_ids:
+            move.move_dest_ids = [Command.set(dests[move.byproduct_id.id])]
+
+        self.move_dest_ids.created_production_id = production.id
+
+        self.procurement_group_id.stock_move_ids.group_id = production.procurement_group_id
+
+        if 'confirmed' in self.mapped('state'):
+            production.move_raw_ids._adjust_procure_method()
+            (production.move_raw_ids | production.move_finished_ids).write({'state': 'confirmed'})
+            production.action_confirm()
+
+        self.with_context(skip_activity=True)._action_cancel()
+        # set the new deadline of origin moves (stock to pre prod)
+        production.move_raw_ids.move_orig_ids.with_context(date_deadline_propagate_ids=set(production.move_raw_ids.ids)).write({'date_deadline': production.date_start})
+        for p in self:
+            p._message_log(body=_('This production has been merge in %s', production.display_name))
+
+        return {
+            'type': 'ir.actions.act_window',
+            'res_model': 'mrp.production',
+            'view_mode': 'form',
+            'res_id': production.id,
+        }
+
+    def action_plan_with_components_availability(self):
+        for production in self.filtered(lambda p: p.state in ('draft', 'confirmed')):
+            if production.state == 'draft':
+                production.action_confirm()
+            move_expected_date = production.move_raw_ids.filtered('forecast_expected_date').mapped('forecast_expected_date')
+            expected_date = max(move_expected_date, default=False)
+            if expected_date and production.components_availability_state != 'unavailable':
+                production.date_start = expected_date
+        self.filtered(lambda p: p.state == 'confirmed').button_plan()
+
+    def _has_workorders(self):
+        return self.workorder_ids
+
+    def _link_bom(self, bom):
+        """ Links the given BoM to the MO. Assigns BoM's lines, by-products and operations
+        to the corresponding MO's components, by-products and workorders.
+        """
+        self.ensure_one()
+        product_qty = self.product_qty
+        uom = self.product_uom_id
+        moves_to_unlink = self.env['stock.move']
+        workorders_to_unlink = self.env['mrp.workorder']
+        # For draft MO, all the work will be done by compute methods.
+        # For cancelled and done MO, we don't want to do anything more than assinging the BoM.
+        if self.state == 'draft' and self.bom_id == bom:
+            # Empties `bom_id` field so when the BoM is reassigns to this field, depending computes
+            # will be triggered (doesn't happen if the field's value doesn't change).
+            self.bom_id = False
+        if self.state in ['cancel', 'done', 'draft']:
+            if self.state == 'draft':
+                # Don't straight delete the moves/workorders to avoid to cancel the MO, those will
+                # be deleted once the BoM is assigned (and thus after new moves/WO were created).
+                moves_to_unlink = self.move_raw_ids
+                workorders_to_unlink = self.workorder_ids
+            self.bom_id = bom
+            moves_to_unlink.unlink()
+            workorders_to_unlink.unlink()
+            if self.state == 'draft':
+                # we reset the product_qty/uom when the bom is changed on a draft MO
+                # change them back to the original value
+                self.write({'product_qty': product_qty, 'product_uom_id': uom.id})
+            return
+
+        def operation_key_values(record):
+            return tuple(record[key] for key in ('company_id', 'name', 'workcenter_id'))
+
+        def filter_by_attributes(record):
+            product_attribute_ids = self.product_id.product_template_attribute_value_ids.ids
+            return not record.bom_product_template_attribute_value_ids or\
+                   any(att_val.id in product_attribute_ids for att_val in record.bom_product_template_attribute_value_ids)
+
+        ratio = self._get_ratio_between_mo_and_bom_quantities(bom)
+        bom_lines_by_id = {(bom_line.id, bom_line.product_id.id): bom_line for bom_line in bom.bom_line_ids.filtered(filter_by_attributes)}
+        bom_byproducts_by_id = {byproduct.id: byproduct for byproduct in bom.byproduct_ids.filtered(filter_by_attributes)}
+        operations_by_id = {operation.id: operation for operation in bom.operation_ids.filtered(filter_by_attributes)}
+
+        # Compares the BoM's operations to the MO's workorders.
+        for workorder in self.workorder_ids:
+            operation = operations_by_id.pop(workorder.operation_id.id, False)
+            if not operation:
+                for operation_id in operations_by_id:
+                    _operation = operations_by_id[operation_id]
+                    if operation_key_values(_operation) == operation_key_values(workorder):
+                        operation = operations_by_id.pop(operation_id)
+                        break
+            if operation and workorder.operation_id != operation:
+                workorder.operation_id = operation
+            elif operation and workorder.operation_id == operation:
+                if workorder.workcenter_id != operation.workcenter_id:
+                    workorder.workcenter_id = operation.workcenter_id
+                if workorder.name != operation.name:
+                    workorder.name = operation.name
+            elif workorder.operation_id and workorder.operation_id not in operations_by_id:
+                workorders_to_unlink |= workorder
+        # Creates a workorder for each remaining operation.
+        workorders_values = []
+        for operation in operations_by_id.values():
+            workorder_vals = {
+                'name': operation.name,
+                'operation_id': operation.id,
+                'product_uom_id': self.product_uom_id.id,
+                'production_id': self.id,
+                'state': 'pending',
+                'workcenter_id': operation.workcenter_id.id,
+            }
+            workorders_values.append(workorder_vals)
+        self.workorder_ids += self.env['mrp.workorder'].create(workorders_values)
+
+        # Compares the BoM's lines to the MO's components.
+        for move_raw in self.move_raw_ids:
+            bom_line = bom_lines_by_id.pop((move_raw.bom_line_id.id, move_raw.product_id.id), False)
+            # If the move isn't already linked to a BoM lines, search for a compatible line.
+            if not bom_line:
+                for _bom_line in bom_lines_by_id.values():
+                    if move_raw.product_id == _bom_line.product_id:
+                        bom_line = bom_lines_by_id.pop((_bom_line.id, move_raw.product_id.id))
+                        if bom_line:
+                            break
+            move_raw_qty = bom_line and move_raw.product_uom._compute_quantity(
+                move_raw.product_uom_qty * ratio, bom_line.product_uom_id
+            )
+            if bom_line and (
+                    not move_raw.bom_line_id or
+                    move_raw.bom_line_id.bom_id != bom or
+                    move_raw.operation_id != bom_line.operation_id or
+                    bom_line.product_qty != move_raw_qty
+                ):
+                move_raw.bom_line_id = bom_line
+                move_raw.product_id = bom_line.product_id
+                move_raw.product_uom_qty = bom_line.product_qty / ratio
+                move_raw.product_uom = bom_line.product_uom_id
+                if move_raw.operation_id != bom_line.operation_id:
+                    move_raw.operation_id = bom_line.operation_id
+                    move_raw.workorder_id = self.workorder_ids.filtered(lambda wo: wo.operation_id == move_raw.operation_id)
+            elif not bom_line:
+                moves_to_unlink |= move_raw
+        # Creates a raw moves for each remaining BoM's lines.
+        raw_moves_values = []
+        for bom_line in bom_lines_by_id.values():
+            raw_move_vals = self._get_move_raw_values(
+                bom_line.product_id,
+                bom_line.product_qty / ratio,
+                bom_line.product_uom_id,
+                bom_line=bom_line
+            )
+            raw_moves_values.append(raw_move_vals)
+        self.env['stock.move'].create(raw_moves_values)
+
+        # Compares the BoM's and the MO's by-products.
+        for move_byproduct in self.move_byproduct_ids:
+            bom_byproduct = bom_byproducts_by_id.pop(move_byproduct.byproduct_id.id, False)
+            if not bom_byproduct:
+                for _bom_byproduct in bom_byproducts_by_id.values():
+                    if move_byproduct.product_id == _bom_byproduct.product_id:
+                        bom_byproduct = bom_byproducts_by_id.pop(_bom_byproduct.id)
+                        break
+            move_byproduct_qty = bom_byproduct and move_byproduct.product_uom._compute_quantity(
+                move_byproduct.product_uom_qty * ratio, bom_byproduct.product_uom_id
+            )
+            if bom_byproduct and (
+                    not move_byproduct.byproduct_id or
+                    bom_byproduct.product_id != move_byproduct.product_id or
+                    bom_byproduct.product_qty != move_byproduct_qty
+                ):
+                move_byproduct.byproduct_id = bom_byproduct
+                move_byproduct.cost_share = bom_byproduct.cost_share
+                move_byproduct.product_uom_qty = bom_byproduct.product_qty / ratio
+                move_byproduct.product_uom = bom_byproduct.product_uom_id
+            elif not bom_byproduct:
+                moves_to_unlink |= move_byproduct
+        # For each remaining BoM's by-product, creates a move finished.
+        byproduct_values = []
+        for bom_byproduct in bom_byproducts_by_id.values():
+            qty = bom_byproduct.product_qty / ratio
+            move_byproduct_vals = self._get_move_finished_values(
+                bom_byproduct.product_id.id, qty, bom_byproduct.product_uom_id.id,
+                bom_byproduct.operation_id.id, bom_byproduct.id, bom_byproduct.cost_share
+            )
+            byproduct_values.append(move_byproduct_vals)
+        self.move_finished_ids += self.env['stock.move'].create(byproduct_values)
+
+        moves_to_unlink._action_cancel()
+        moves_to_unlink.unlink()
+        workorders_to_unlink.unlink()
+        self.bom_id = bom
+
     @api.model
     def _prepare_procurement_group_vals(self, values):
         return {'name': values['name']}
@@ -1628,92 +2497,331 @@ class MrpProduction(models.Model):
         self.ensure_one()
         return max(self.product_qty - self.qty_producing, 0)
 
+    def _get_ratio_between_mo_and_bom_quantities(self, bom):
+        self.ensure_one()
+        bom_product_uom = (bom.product_id or bom.product_tmpl_id).uom_id
+        bom_qty = bom.product_uom_id._compute_quantity(bom.product_qty, bom_product_uom)
+        ratio = bom_qty / self.product_uom_qty
+        return ratio
+
     def _check_sn_uniqueness(self):
         """ Alert the user if the serial number as already been consumed/produced """
         if self.product_tracking == 'serial' and self.lot_producing_id:
-            sml = self.env['stock.move.line'].search_count([
-                ('lot_id', '=', self.lot_producing_id.id),
-                ('location_id.usage', '=', 'production'),
-                ('qty_done', '=', 1),
-                ('state', '=', 'done')
-            ])
-            if sml:
+            if self._is_finished_sn_already_produced(self.lot_producing_id):
                 raise UserError(_('This serial number for product %s has already been produced', self.product_id.name))
 
         for move in self.move_finished_ids:
             if move.has_tracking != 'serial' or move.product_id == self.product_id:
                 continue
             for move_line in move.move_line_ids:
-                domain = [
-                    ('lot_id', '=', move_line.lot_id.id),
-                    ('qty_done', '=', 1),
-                    ('state', '=', 'done')
-                ]
-                message = _('The serial number %(number)s used for byproduct %(product_name)s has already been produced',
-                    number=move_line.lot_id.name,
-                    product_name=move_line.product_id.name)
-                co_prod_move_lines = self.move_finished_ids.move_line_ids.filtered(lambda ml: ml.product_id != self.product_id)
-                domain_unbuild = domain + [
-                    ('production_id', '=', False),
-                    ('location_dest_id.usage', '=', 'production')
-                ]
-
-                # Check presence of same sn in previous productions
-                duplicates = self.env['stock.move.line'].search_count(domain + [
-                    ('location_id.usage', '=', 'production')
-                ])
-                if duplicates:
-                    # Maybe some move lines have been compensated by unbuild
-                    duplicates_unbuild = self.env['stock.move.line'].search_count(domain_unbuild)
-                    if not (duplicates_unbuild and duplicates - duplicates_unbuild == 0):
-                        raise UserError(message)
-                # Check presence of same sn in current production
-                duplicates = co_prod_move_lines.filtered(lambda ml: ml.qty_done and ml.lot_id == move_line.lot_id) - move_line
-                if duplicates:
-                    raise UserError(message)
+                if float_is_zero(move_line.quantity, precision_rounding=move_line.product_uom_id.rounding):
+                    continue
+                if self._is_finished_sn_already_produced(move_line.lot_id, excluded_sml=move_line):
+                    raise UserError(_('The serial number %(number)s used for byproduct %(product_name)s has already been produced',
+                                      number=move_line.lot_id.name, product_name=move_line.product_id.name))
 
+        consumed_sn_ids = []
+        sn_error_msg = {}
         for move in self.move_raw_ids:
-            if move.has_tracking != 'serial':
+            if move.has_tracking != 'serial' or not move.picked:
                 continue
             for move_line in move.move_line_ids:
-                if float_is_zero(move_line.qty_done, precision_rounding=move_line.product_uom_id.rounding):
+                if not move_line.picked or float_is_zero(move_line.quantity, precision_rounding=move_line.product_uom_id.rounding) or\
+                        not move_line.lot_id:
                     continue
-                domain = [
-                    ('lot_id', '=', move_line.lot_id.id),
-                    ('qty_done', '=', 1),
-                    ('state', '=', 'done')
-                ]
+                sml_sn = move_line.lot_id
                 message = _('The serial number %(number)s used for component %(component)s has already been consumed',
-                    number=move_line.lot_id.name,
+                    number=sml_sn.name,
                     component=move_line.product_id.name)
+                consumed_sn_ids.append(sml_sn.id)
+                sn_error_msg[sml_sn.id] = message
                 co_prod_move_lines = self.move_raw_ids.move_line_ids
-                domain_unbuild = domain + [
-                    ('production_id', '=', False),
-                    ('location_id.usage', '=', 'production')
-                ]
-
-                # Check presence of same sn in previous productions
-                duplicates = self.env['stock.move.line'].search_count(domain + [
-                    ('location_dest_id.usage', '=', 'production')
-                ])
-                if duplicates:
-                    # Maybe some move lines have been compensated by unbuild
-                    duplicates_unbuild = self.env['stock.move.line'].search_count(domain_unbuild)
-                    if not (duplicates_unbuild and duplicates - duplicates_unbuild == 0):
-                        raise UserError(message)
-                # Check presence of same sn in current production
-                duplicates = co_prod_move_lines.filtered(lambda ml: ml.qty_done and ml.lot_id == move_line.lot_id) - move_line
+                duplicates = co_prod_move_lines.filtered(lambda ml: ml.quantity and ml.lot_id == sml_sn) - move_line
                 if duplicates:
                     raise UserError(message)
 
-    def _check_immediate(self):
-        immediate_productions = self.browse()
-        if self.env.context.get('skip_immediate'):
-            return immediate_productions
-        pd = self.env['decimal.precision'].precision_get('Product Unit of Measure')
-        for production in self:
-            if all(float_is_zero(ml.qty_done, precision_digits=pd) for
-                    ml in production.move_raw_ids.move_line_ids.filtered(lambda m: m.state not in ('done', 'cancel'))
-                    ) and float_is_zero(production.qty_producing, precision_digits=pd):
-                immediate_productions |= production
-        return immediate_productions
+        if not consumed_sn_ids:
+            return
+
+        consumed_sml_groups = self.env['stock.move.line']._read_group([
+            ('lot_id', 'in', consumed_sn_ids),
+            ('quantity', '=', 1),
+            ('state', '=', 'done'),
+            ('location_dest_id.usage', '=', 'production'),
+            ('production_id', '!=', False),
+        ], ['lot_id'], ['quantity:sum'])
+        consumed_qties = {lot.id: qty for lot, qty in consumed_sml_groups}
+        problematic_sn_ids = list(consumed_qties.keys())
+        if not problematic_sn_ids:
+            return
+
+        cancelled_sml_groups = self.env['stock.move.line']._read_group([    # SML that cancels the SN consumption
+            ('lot_id', 'in', problematic_sn_ids),
+            ('quantity', '=', 1),
+            ('state', '=', 'done'),
+            ('location_id.usage', '=', 'production'),
+            ('move_id.production_id', '=', False),
+        ], ['lot_id'], ['quantity:sum'])
+        cancelled_qties = defaultdict(float, {lot.id: qty for lot, qty in cancelled_sml_groups})
+
+        for sn_id in problematic_sn_ids:
+            consumed_qty = consumed_qties[sn_id]
+            cancelled_qty = cancelled_qties[sn_id]
+            if consumed_qty - cancelled_qty > 0:
+                raise UserError(sn_error_msg[sn_id])
+
+    def _is_finished_sn_already_produced(self, lot, excluded_sml=None):
+        if not lot:
+            return False
+        excluded_sml = excluded_sml or self.env['stock.move.line']
+        domain = [
+            ('lot_id', '=', lot.id),
+            ('quantity', '=', 1),
+            ('state', '=', 'done')
+        ]
+        co_prod_move_lines = self.move_finished_ids.move_line_ids - excluded_sml
+        domain_unbuild = domain + [
+            ('production_id', '=', False),
+            ('location_dest_id.usage', '=', 'production')
+        ]
+        # Check presence of same sn in previous productions
+        duplicates = self.env['stock.move.line'].search_count(domain + [
+            ('location_id.usage', '=', 'production'),
+            ('move_id.unbuild_id', '=', False)
+        ])
+        if duplicates:
+            # Maybe some move lines have been compensated by unbuild
+            duplicates_unbuild = self.env['stock.move.line'].search_count(domain_unbuild + [
+                ('move_id.unbuild_id', '!=', False)
+            ])
+            removed = self.env['stock.move.line'].search_count([
+                ('lot_id', '=', lot.id),
+                ('state', '=', 'done'),
+                ('location_id.scrap_location', '=', False),
+                ('location_dest_id.scrap_location', '=', True),
+            ])
+            unremoved = self.env['stock.move.line'].search_count([
+                ('lot_id', '=', lot.id),
+                ('state', '=', 'done'),
+                ('location_id.scrap_location', '=', True),
+                ('location_dest_id.scrap_location', '=', False),
+            ])
+            # Either removed or unbuild
+            if not ((duplicates_unbuild or removed) and duplicates - duplicates_unbuild - removed + unremoved == 0):
+                return True
+        # Check presence of same sn in current production
+        duplicates = co_prod_move_lines.filtered(lambda ml: ml.quantity and ml.lot_id == lot)
+        return bool(duplicates)
+
+    def _pre_action_split_merge_hook(self, merge=False, split=False):
+        if not merge and not split:
+            return True
+        ope_str = merge and _('merged') or _('split')
+        if any(production.state not in ('draft', 'confirmed') for production in self):
+            raise UserError(_("Only manufacturing orders in either a draft or confirmed state can be %s.", ope_str))
+        if any(not production.bom_id for production in self):
+            raise UserError(_("Only manufacturing orders with a Bill of Materials can be %s.", ope_str))
+        if split:
+            return True
+
+        if len(self) < 2:
+            raise UserError(_("You need at least two production orders to merge them."))
+        products = set([(production.product_id, production.bom_id) for production in self])
+        if len(products) > 1:
+            raise UserError(_('You can only merge manufacturing orders of identical products with same BoM.'))
+        additional_raw_ids = self.mapped("move_raw_ids").filtered(lambda move: not move.bom_line_id)
+        additional_byproduct_ids = self.mapped('move_byproduct_ids').filtered(lambda move: not move.byproduct_id)
+        if additional_raw_ids or additional_byproduct_ids:
+            raise UserError(_("You can only merge manufacturing orders with no additional components or by-products."))
+        if len(set(self.mapped('state'))) > 1:
+            raise UserError(_("You can only merge manufacturing with the same state."))
+        if len(set(self.mapped('picking_type_id'))) > 1:
+            raise UserError(_('You can only merge manufacturing with the same operation type'))
+        # TODO explode and check no quantity has been edited
+        return True
+
+    def _prepare_merge_orig_links(self):
+        origs = defaultdict(dict)
+        for move in self.move_raw_ids:
+            if not move.move_orig_ids:
+                continue
+            origs[move.bom_line_id.id].setdefault('move_orig_ids', set()).update(move.move_orig_ids.ids)
+        for vals in origs.values():
+            if not vals.get('move_orig_ids'):
+                continue
+            vals['move_orig_ids'] = [Command.set(vals['move_orig_ids'])]
+        return origs
+
+    def _set_quantities(self):
+        self.ensure_one()
+        missing_lot_id_products = ""
+        if self.product_tracking in ('lot', 'serial') and not self.lot_producing_id:
+            self.action_generate_serial()
+        if self.product_tracking == 'serial' and float_compare(self.qty_producing, 1, precision_rounding=self.product_uom_id.rounding) == 1:
+            self.qty_producing = 1
+        else:
+            self.qty_producing = self.product_qty - self.qty_produced
+        self._set_qty_producing()
+
+        for move in self.move_raw_ids:
+            if move.state in ('done', 'cancel') or not move.product_uom_qty:
+                continue
+            rounding = move.product_uom.rounding
+            if move.manual_consumption:
+                if move.has_tracking in ('serial', 'lot') and (not move.picked or any(not line.lot_id for line in move.move_line_ids if line.quantity and line.picked)):
+                    missing_lot_id_products += "\n  - %s" % move.product_id.display_name
+        if missing_lot_id_products:
+            error_msg = _("You need to supply Lot/Serial Number for products and 'consume' them:") + missing_lot_id_products
+            raise UserError(error_msg)
+
+    def _get_autoprint_done_report_actions(self):
+        """ Reports to auto-print when MO is marked as done
+        """
+        report_actions = []
+        productions_to_print = self.filtered(lambda p: p.picking_type_id.auto_print_done_production_order)
+        if productions_to_print:
+            action = self.env.ref("mrp.action_report_production_order").report_action(productions_to_print.ids, config=False)
+            clean_action(action, self.env)
+            report_actions.append(action)
+        productions_to_print = self.filtered(lambda p: p.picking_type_id.auto_print_done_mrp_product_labels)
+        productions_by_print_formats = productions_to_print.grouped(lambda p: p.picking_type_id.mrp_product_label_to_print)
+        for print_format in productions_to_print.picking_type_id.mapped('mrp_product_label_to_print'):
+            labels_to_print = productions_by_print_formats.get(print_format)
+            if print_format == 'pdf':
+                action = self.env.ref("mrp.action_report_finished_product").report_action(labels_to_print.ids, config=False)
+                clean_action(action, self.env)
+                report_actions.append(action)
+            elif print_format == 'zpl':
+                action = self.env.ref("mrp.label_manufacture_template").report_action(labels_to_print.ids, config=False)
+                clean_action(action, self.env)
+                report_actions.append(action)
+        if self.env.user.has_group('mrp.group_mrp_reception_report'):
+            reception_reports_to_print = self.filtered(
+                lambda p: p.picking_type_id.auto_print_mrp_reception_report
+                          and p.picking_type_id.code == 'mrp_operation'
+                          and p.move_finished_ids.move_dest_ids
+            )
+            if reception_reports_to_print:
+                action = self.env.ref('stock.stock_reception_report_action').report_action(reception_reports_to_print, config=False)
+                action['context'] = dict({'default_production_ids': reception_reports_to_print.ids}, **self.env.context)
+                clean_action(action, self.env)
+                report_actions.append(action)
+            reception_labels_to_print = self.filtered(lambda p: p.picking_type_id.auto_print_mrp_reception_report_labels and p.picking_type_id.code == 'mrp_operation')
+            if reception_labels_to_print:
+                moves_to_print = reception_labels_to_print.move_finished_ids.move_dest_ids
+                if moves_to_print:
+                    # needs to be string to support python + js calls to report
+                    quantities = ','.join(str(qty) for qty in moves_to_print.mapped(lambda m: math.ceil(m.product_uom_qty)))
+                    data = {
+                        'docids': moves_to_print.ids,
+                        'quantity': quantities,
+                    }
+                    action = self.env.ref('stock.label_picking').report_action(moves_to_print, data=data, config=False)
+                    clean_action(action, self.env)
+                    report_actions.append(action)
+        if self.env.user.has_group('stock.group_production_lot'):
+            productions_to_print = self.filtered(lambda p: p.picking_type_id.auto_print_done_mrp_lot and p.move_finished_ids.move_line_ids.lot_id)
+            productions_by_print_formats = productions_to_print.grouped(lambda p: p.picking_type_id.done_mrp_lot_label_to_print)
+            for print_format in productions_to_print.picking_type_id.mapped('done_mrp_lot_label_to_print'):
+                lots_to_print = productions_by_print_formats.get(print_format)
+                lots_to_print = lots_to_print.move_finished_ids.move_line_ids.mapped('lot_id')
+                if print_format == 'pdf':
+                    action = self.env.ref("stock.action_report_lot_label").report_action(lots_to_print.ids, config=False)
+                    clean_action(action, self.env)
+                    report_actions.append(action)
+                elif print_format == 'zpl':
+                    action = self.env.ref("stock.label_lot_template").report_action(lots_to_print.ids, config=False)
+                    clean_action(action, self.env)
+                    report_actions.append(action)
+        return report_actions
+
+    def _autoprint_generated_lot(self, lot_id):
+        self.ensure_one()
+        if self.picking_type_id.generated_mrp_lot_label_to_print == 'pdf':
+            action = self.env.ref("stock.action_report_lot_label").report_action(lot_id.id, config=False)
+            clean_action(action, self.env)
+            return action
+        elif self.picking_type_id.generated_mrp_lot_label_to_print == 'zpl':
+            action = self.env.ref("stock.label_lot_template").report_action(lot_id.id, config=False)
+            clean_action(action, self.env)
+            return action
+
+    def _prepare_finished_extra_vals(self):
+        self.ensure_one()
+        if self.lot_producing_id:
+            return {'lot_id' : self.lot_producing_id.id}
+        return {}
+
+    def action_open_label_layout(self):
+        view = self.env.ref('stock.product_label_layout_form_picking')
+        return {
+            'name': _('Choose Labels Layout'),
+            'type': 'ir.actions.act_window',
+            'res_model': 'product.label.layout',
+            'views': [(view.id, 'form')],
+            'target': 'new',
+            'context': {
+                'default_product_ids': self.move_finished_ids.product_id.ids,
+                'default_move_ids': self.move_finished_ids.ids,
+                'default_move_quantity': 'move'},
+        }
+
+    def action_open_label_type(self):
+        move_line_ids = self.move_finished_ids.mapped('move_line_ids')
+        if self.env.user.has_group('stock.group_production_lot') and move_line_ids.lot_id:
+            view = self.env.ref('stock.picking_label_type_form')
+            return {
+                'name': _('Choose Type of Labels To Print'),
+                'type': 'ir.actions.act_window',
+                'res_model': 'picking.label.type',
+                'views': [(view.id, 'form')],
+                'target': 'new',
+                'context': {'default_production_ids': self.ids},
+            }
+        return self.action_open_label_layout()
+
+    # -------------------------------------------------------------------------
+    # CATALOG
+    # -------------------------------------------------------------------------
+
+    def _default_order_line_values(self, child_field=False):
+        default_data = super()._default_order_line_values(child_field)
+        new_default_data = self.env['stock.move']._get_product_catalog_lines_data(parent_record=self)
+
+        return {**default_data, **new_default_data}
+
+    def _get_product_catalog_order_data(self, products, **kwargs):
+        product_catalog = super()._get_product_catalog_order_data(products, **kwargs)
+        for product in products:
+            product_catalog[product.id] |= self._get_product_price_and_data(product)
+        return product_catalog
+
+    def _get_product_price_and_data(self, product):
+        return {'price': product.standard_price}
+
+    def _get_product_catalog_record_lines(self, product_ids, child_field=False, **kwargs):
+        if not child_field:
+            return {}
+        lines = self[child_field].filtered(lambda line: line.product_id.id in product_ids)
+        return lines.grouped(lambda line: line.product_id)
+
+    def _update_order_line_info(self, product_id, quantity, child_field=False, **kwargs):
+        if not child_field:
+            return 0
+        entity = self[child_field].filtered(lambda line: line.product_id.id == product_id)
+        if entity:
+            if quantity != 0:
+                entity.product_uom_qty = quantity
+            else:
+                entity.unlink()
+        elif quantity > 0:
+            command = Command.create({
+                'product_uom_qty': quantity,
+                'product_id': product_id,
+            })
+            self.write({child_field: [command]})
+
+        return self.env['product.product'].browse(product_id).standard_price
+
+    def _get_product_catalog_domain(self):
+        return expression.AND([super()._get_product_catalog_domain(), [('id', '!=', self.product_id.id)]])

--- a/addons/mrp/models/mrp_routing.py
+++ b/addons/mrp/models/mrp_routing.py
@@ -1,46 +1,70 @@
 # -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
-from odoo import api, fields, models, _
+from odoo import api, fields, models, _, tools
+from odoo.exceptions import ValidationError
 
 
 class MrpRoutingWorkcenter(models.Model):
     _name = 'mrp.routing.workcenter'
     _description = 'Work Center Usage'
-    _order = 'sequence, id'
+    _inherit = ['mail.thread', 'mail.activity.mixin']
+
+    _order = 'bom_id, sequence, id'
     _check_company_auto = True
 
     name = fields.Char('Operation', required=True)
-    workcenter_id = fields.Many2one('mrp.workcenter', 'Work Center', required=True, check_company=True)
+    active = fields.Boolean(default=True)
+    workcenter_id = fields.Many2one('mrp.workcenter', 'Work Center', required=True, check_company=True, tracking=True)
     sequence = fields.Integer(
         'Sequence', default=100,
         help="Gives the sequence order when displaying a list of routing Work Centers.")
     bom_id = fields.Many2one(
         'mrp.bom', 'Bill of Material',
-        index=True, ondelete='cascade', required=True,
-        help="The Bill of Material this operation is linked to")
+        index=True, ondelete='cascade', required=True, check_company=True)
     company_id = fields.Many2one('res.company', 'Company', related='bom_id.company_id')
     worksheet_type = fields.Selection([
         ('pdf', 'PDF'), ('google_slide', 'Google Slide'), ('text', 'Text')],
-        string="Work Sheet", default="text",
-        help="Defines if you want to use a PDF or a Google Slide as work sheet."
+        string="Worksheet", default="text", tracking=True
     )
-    note = fields.Text('Description', help="Text worksheet description")
+    note = fields.Html('Description')
     worksheet = fields.Binary('PDF')
-    worksheet_google_slide = fields.Char('Google Slide', help="Paste the url of your Google Slide. Make sure the access to the document is public.")
+    worksheet_google_slide = fields.Char('Google Slide', help="Paste the url of your Google Slide. Make sure the access to the document is public.", tracking=True)
     time_mode = fields.Selection([
         ('auto', 'Compute based on tracked time'),
         ('manual', 'Set duration manually')], string='Duration Computation',
-        default='manual')
+        default='manual', tracking=True)
     time_mode_batch = fields.Integer('Based on', default=10)
+    time_computed_on = fields.Char('Computed on last', compute='_compute_time_computed_on')
     time_cycle_manual = fields.Float(
-        'Manual Duration', default=60,
+        'Manual Duration', default=60, tracking=True,
         help="Time in minutes:"
         "- In manual mode, time used"
         "- In automatic mode, supposed first time when there aren't any work orders yet")
     time_cycle = fields.Float('Duration', compute="_compute_time_cycle")
     workorder_count = fields.Integer("# Work Orders", compute="_compute_workorder_count")
     workorder_ids = fields.One2many('mrp.workorder', 'operation_id', string="Work Orders")
+    possible_bom_product_template_attribute_value_ids = fields.Many2many(related='bom_id.possible_product_template_attribute_value_ids')
+    bom_product_template_attribute_value_ids = fields.Many2many(
+        'product.template.attribute.value', string="Apply on Variants", ondelete='restrict',
+        domain="[('id', 'in', possible_bom_product_template_attribute_value_ids)]",
+        help="BOM Product Variants needed to apply this line.")
+    allow_operation_dependencies = fields.Boolean(related='bom_id.allow_operation_dependencies')
+    blocked_by_operation_ids = fields.Many2many('mrp.routing.workcenter', relation="mrp_routing_workcenter_dependencies_rel",
+                                     column1="operation_id", column2="blocked_by_id",
+                                     string="Blocked By", help="Operations that need to be completed before this operation can start.",
+                                     domain="[('allow_operation_dependencies', '=', True), ('id', '!=', id), ('bom_id', '=', bom_id)]",
+                                     copy=False)
+    needed_by_operation_ids = fields.Many2many('mrp.routing.workcenter', relation="mrp_routing_workcenter_dependencies_rel",
+                                     column1="blocked_by_id", column2="operation_id",
+                                     string="Blocks", help="Operations that cannot start before this operation is completed.",
+                                     domain="[('allow_operation_dependencies', '=', True), ('id', '!=', id), ('bom_id', '=', bom_id)]",
+                                     copy=False)
+
+    @api.depends('time_mode', 'time_mode_batch')
+    def _compute_time_computed_on(self):
+        for operation in self:
+            operation.time_computed_on = _('%i work orders', operation.time_mode_batch) if operation.time_mode != 'manual' else False
 
     @api.depends('time_cycle_manual', 'time_mode', 'workorder_ids')
     def _compute_time_cycle(self):
@@ -48,20 +72,98 @@ class MrpRoutingWorkcenter(models.Model):
         for operation in manual_ops:
             operation.time_cycle = operation.time_cycle_manual
         for operation in self - manual_ops:
-            data = self.env['mrp.workorder'].read_group([
+            data = self.env['mrp.workorder'].search([
                 ('operation_id', '=', operation.id),
-                ('state', '=', 'done')], ['operation_id', 'duration', 'qty_produced'], ['operation_id'],
-                limit=operation.time_mode_batch)
-            count_data = dict((item['operation_id'][0], (item['duration'], item['qty_produced'])) for item in data)
-            if count_data.get(operation.id) and count_data[operation.id][1]:
-                operation.time_cycle = (count_data[operation.id][0] / count_data[operation.id][1]) * (operation.workcenter_id.capacity or 1.0)
+                ('qty_produced', '>', 0),
+                ('state', '=', 'done')],
+                limit=operation.time_mode_batch,
+                order="date_finished desc, id desc")
+            # To compute the time_cycle, we can take the total duration of previous operations
+            # but for the quantity, we will take in consideration the qty_produced like if the capacity was 1.
+            # So producing 50 in 00:10 with capacity 2, for the time_cycle, we assume it is 25 in 00:10
+            # When recomputing the expected duration, the capacity is used again to divide the qty to produce
+            # so that if we need 50 with capacity 2, it will compute the expected of 25 which is 00:10
+            total_duration = 0  # Can be 0 since it's not an invalid duration for BoM
+            cycle_number = 0  # Never 0 unless infinite item['workcenter_id'].capacity
+            for item in data:
+                total_duration += item['duration']
+                capacity = item['workcenter_id']._get_capacity(item.product_id)
+                cycle_number += tools.float_round((item['qty_produced'] / capacity or 1.0), precision_digits=0, rounding_method='UP')
+            if cycle_number:
+                operation.time_cycle = total_duration / cycle_number
             else:
                 operation.time_cycle = operation.time_cycle_manual
 
     def _compute_workorder_count(self):
-        data = self.env['mrp.workorder'].read_group([
+        data = self.env['mrp.workorder']._read_group([
             ('operation_id', 'in', self.ids),
-            ('state', '=', 'done')], ['operation_id'], ['operation_id'])
-        count_data = dict((item['operation_id'][0], item['operation_id_count']) for item in data)
+            ('state', '=', 'done')], ['operation_id'], ['__count'])
+        count_data = {operation.id: count for operation, count in data}
         for operation in self:
             operation.workorder_count = count_data.get(operation.id, 0)
+
+    @api.constrains('blocked_by_operation_ids')
+    def _check_no_cyclic_dependencies(self):
+        if self._has_cycle('blocked_by_operation_ids'):
+            raise ValidationError(_("You cannot create cyclic dependency."))
+
+    @api.model_create_multi
+    def create(self, vals_list):
+        res = super().create(vals_list)
+        res.bom_id._set_outdated_bom_in_productions()
+        return res
+
+    def write(self, vals):
+        res = super().write(vals)
+        self.bom_id._set_outdated_bom_in_productions()
+        return res
+
+    def action_archive(self):
+        res = super().action_archive()
+        bom_lines = self.env['mrp.bom.line'].search([('operation_id', 'in', self.ids)])
+        bom_lines.write({'operation_id': False})
+        self.bom_id._set_outdated_bom_in_productions()
+        return res
+
+    def action_unarchive(self):
+        res = super().action_unarchive()
+        self.bom_id._set_outdated_bom_in_productions()
+        return res
+
+    def copy_to_bom(self):
+        if 'bom_id' in self.env.context:
+            bom_id = self.env.context.get('bom_id')
+            for operation in self:
+                operation.copy({'bom_id': bom_id})
+            return {
+                'view_mode': 'form',
+                'res_model': 'mrp.bom',
+                'views': [(False, 'form')],
+                'type': 'ir.actions.act_window',
+                'res_id': bom_id,
+            }
+
+    def copy_existing_operations(self):
+        return {
+            'type': 'ir.actions.act_window',
+            'name': _('Select Operations to Copy'),
+            'res_model': 'mrp.routing.workcenter',
+            'view_mode': 'tree,form',
+            'domain': ['|', ('bom_id', '=', False), ('bom_id.active', '=', True)],
+            'context' : {
+                'bom_id': self.env.context["bom_id"],
+                'tree_view_ref': 'mrp.mrp_routing_workcenter_copy_to_bom_tree_view',
+            }
+        }
+
+    def _skip_operation_line(self, product):
+        """ Control if a operation should be processed, can be inherited to add
+        custom control.
+        """
+        self.ensure_one()
+        # skip operation line if archived
+        if not self.active:
+            return True
+        if product._name == 'product.template':
+            return False
+        return not product._match_all_variant_values(self.bom_product_template_attribute_value_ids)

--- a/addons/mrp/models/mrp_unbuild.py
+++ b/addons/mrp/models/mrp_unbuild.py
@@ -1,9 +1,11 @@
-# -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
-from odoo import api, fields, models, _
-from odoo.exceptions import AccessError, UserError
-from odoo.tools import float_compare
+from collections import defaultdict
+
+from odoo import _, api, fields, models
+from odoo.exceptions import UserError
+from odoo.tools import float_compare, float_round
+from odoo.tools.misc import clean_context
 
 
 class MrpUnbuild(models.Model):
@@ -15,18 +17,21 @@ class MrpUnbuild(models.Model):
     name = fields.Char('Reference', copy=False, readonly=True, default=lambda x: _('New'))
     product_id = fields.Many2one(
         'product.product', 'Product', check_company=True,
-        domain="[('bom_ids', '!=', False), '|', ('company_id', '=', False), ('company_id', '=', company_id)]",
-        required=True, states={'done': [('readonly', True)]})
+        domain="[('type', 'in', ['product', 'consu'])]",
+        compute='_compute_product_id', store=True, precompute=True, readonly=False,
+        required=True)
     company_id = fields.Many2one(
         'res.company', 'Company',
         default=lambda s: s.env.company,
-        required=True, index=True, states={'done': [('readonly', True)]})
+        required=True, index=True)
     product_qty = fields.Float(
         'Quantity', default=1.0,
-        required=True, states={'done': [('readonly', True)]})
+        compute='_compute_product_qty', store=True, precompute=True, readonly=False,
+        required=True)
     product_uom_id = fields.Many2one(
         'uom.uom', 'Unit of Measure',
-        required=True, states={'done': [('readonly', True)]})
+        compute='_compute_product_uom_id', store=True, readonly=False, precompute=True,
+        required=True)
     bom_id = fields.Many2one(
         'mrp.bom', 'Bill of Material',
         domain="""[
@@ -39,29 +44,31 @@ class MrpUnbuild(models.Model):
         '|',
             ('company_id', '=', company_id),
             ('company_id', '=', False)
-        ]
-""",
-        states={'done': [('readonly', True)]}, check_company=True)
+        ]""",
+        compute='_compute_bom_id', store=True,
+        check_company=True)
     mo_id = fields.Many2one(
         'mrp.production', 'Manufacturing Order',
-        domain="[('id', 'in', allowed_mo_ids)]",
-        states={'done': [('readonly', True)]}, check_company=True)
+        domain="[('state', '=', 'done'), ('product_id', '=?', product_id), ('bom_id', '=?', bom_id)]",
+        check_company=True)
     mo_bom_id = fields.Many2one('mrp.bom', 'Bill of Material used on the Production Order', related='mo_id.bom_id')
     lot_id = fields.Many2one(
-        'stock.production.lot', 'Lot/Serial Number',
-        domain="[('product_id', '=', product_id), ('company_id', '=', company_id)]", check_company=True,
-        states={'done': [('readonly', True)]}, help="Lot/Serial Number of the product to unbuild.")
-    has_tracking=fields.Selection(related='product_id.tracking', readonly=True)
+        'stock.lot', 'Lot/Serial Number',
+        compute='_compute_lot_id', store=True,
+        domain="[('product_id', '=', product_id)]", check_company=True)
+    has_tracking = fields.Selection(related='product_id.tracking', readonly=True)
     location_id = fields.Many2one(
         'stock.location', 'Source Location',
-        domain="[('usage','=','internal'), '|', ('company_id', '=', False), ('company_id', '=', company_id)]",
+        domain="[('usage','=','internal')]",
         check_company=True,
-        required=True, states={'done': [('readonly', True)]}, help="Location where the product you want to unbuild is.")
+        compute='_compute_location_id', store=True, readonly=False, precompute=True,
+        required=True, help="Location where the product you want to unbuild is.")
     location_dest_id = fields.Many2one(
         'stock.location', 'Destination Location',
-        domain="[('usage','=','internal'), '|', ('company_id', '=', False), ('company_id', '=', company_id)]",
+        domain="[('usage','=','internal')]",
         check_company=True,
-        required=True, states={'done': [('readonly', True)]}, help="Location where you want to send the components resulting from the unbuild order.")
+        compute='_compute_location_id', store=True, readonly=False, precompute=True,
+        required=True, help="Location where you want to send the components resulting from the unbuild order.")
     consume_line_ids = fields.One2many(
         'stock.move', 'consume_unbuild_id', readonly=True,
         string='Consumed Disassembly Lines')
@@ -71,88 +78,110 @@ class MrpUnbuild(models.Model):
     state = fields.Selection([
         ('draft', 'Draft'),
         ('done', 'Done')], string='Status', default='draft')
-    allowed_mo_ids = fields.One2many('mrp.production', compute='_compute_allowed_mo_ids')
 
-    @api.depends('company_id', 'product_id')
-    def _compute_allowed_mo_ids(self):
-        for unbuild in self:
-            if unbuild.product_id:
-                domain = [
-                    ('state', '=', 'done'),
-                    ('product_id', '=', unbuild.product_id.id),
-                    ('company_id', '=', unbuild.company_id.id)
-                ]
-            else:
-                domain = [
-                    ('state', 'in', ['done', 'cancel']),
-                    ('company_id', '=', unbuild.company_id.id)
-                ]
-            allowed_mos = self.env['mrp.production'].search_read(domain, ['id'])
-            if allowed_mos:
-                unbuild.allowed_mo_ids = [mo['id'] for mo in allowed_mos]
+    _sql_constraints = [
+        ('qty_positive', 'check (product_qty > 0)', 'The quantity to unbuild must be positive!'),
+    ]
+
+    @api.depends('mo_id', 'product_id')
+    def _compute_product_uom_id(self):
+        for record in self:
+            if record.mo_id.product_id and record.mo_id.product_id == record.product_id:
+                record.product_uom_id = record.mo_id.product_uom_id.id
             else:
-                unbuild.allowed_mo_ids = False
+                record.product_uom_id = record.product_id.uom_id.id
 
-    @api.onchange('company_id')
-    def _onchange_company_id(self):
-        if self.company_id:
-            warehouse = self.env['stock.warehouse'].search([('company_id', '=', self.company_id.id)], limit=1)
-            if self.location_id.company_id != self.company_id:
-                self.location_id = warehouse.lot_stock_id
-            if self.location_dest_id.company_id != self.company_id:
-                self.location_dest_id = warehouse.lot_stock_id
-        else:
-            self.location_id = False
-            self.location_dest_id = False
+    @api.depends('company_id')
+    def _compute_location_id(self):
+        for order in self:
+            if order.company_id:
+                warehouse = self.env['stock.warehouse'].search([('company_id', '=', order.company_id.id)], limit=1)
+                if order.location_id.company_id != order.company_id:
+                    order.location_id = warehouse.lot_stock_id
+                if order.location_dest_id.company_id != order.company_id:
+                    order.location_dest_id = warehouse.lot_stock_id
 
-    @api.onchange('mo_id')
-    def _onchange_mo_id(self):
-        if self.mo_id:
-            self.product_id = self.mo_id.product_id.id
-            self.bom_id = self.mo_id.bom_id
-            self.product_uom_id = self.mo_id.product_uom_id
-            if self.has_tracking == 'serial':
-                self.product_qty = 1
+    @api.depends('mo_id', 'product_id', 'company_id')
+    def _compute_bom_id(self):
+        for order in self:
+            if order.mo_id:
+                order.bom_id = order.mo_id.bom_id
             else:
-                self.product_qty = self.mo_id.product_qty
+                order.bom_id = self.env['mrp.bom']._bom_find(
+                    order.product_id, company_id=order.company_id.id
+                )[order.product_id]
 
-    @api.onchange('product_id')
-    def _onchange_product_id(self):
-        if self.product_id:
-            self.bom_id = self.env['mrp.bom']._bom_find(product=self.product_id, company_id=self.company_id.id)
-            self.product_uom_id = self.product_id.uom_id.id
+    @api.depends('mo_id')
+    def _compute_lot_id(self):
+        for order in self:
+            if order.mo_id:
+                order.lot_id = order.mo_id.lot_producing_id
 
-    @api.constrains('product_qty')
-    def _check_qty(self):
-        for unbuild in self:
-            if unbuild.product_qty <= 0:
-                raise ValueError(_('Unbuild Order product quantity has to be strictly positive.'))
+    @api.depends('mo_id')
+    def _compute_product_id(self):
+        for order in self:
+            if order.mo_id and order.mo_id.product_id:
+                order.product_id = order.mo_id.product_id
 
-    @api.model
-    def create(self, vals):
-        if not vals.get('name') or vals['name'] == _('New'):
-            vals['name'] = self.env['ir.sequence'].next_by_code('mrp.unbuild') or _('New')
-        return super(MrpUnbuild, self).create(vals)
+    @api.depends('mo_id')
+    def _compute_product_qty(self):
+        for order in self:
+            if order.mo_id:
+                if order.has_tracking == 'serial':
+                    order.product_qty = 1
+                else:
+                    order.product_qty = order.mo_id.qty_produced
+
+    @api.model_create_multi
+    def create(self, vals_list):
+        for vals in vals_list:
+            if not vals.get('name') or vals['name'] == _('New'):
+                vals['name'] = self.env['ir.sequence'].next_by_code('mrp.unbuild') or _('New')
+        return super().create(vals_list)
 
     @api.ondelete(at_uninstall=False)
     def _unlink_except_done(self):
         if 'done' in self.mapped('state'):
             raise UserError(_("You cannot delete an unbuild order if the state is 'Done'."))
 
+    def _prepare_finished_move_line_vals(self, finished_move):
+        return {
+            'move_id': finished_move.id,
+            'lot_id': self.lot_id.id,
+            'quantity': self.product_qty,
+            'product_id': finished_move.product_id.id,
+            'product_uom_id': finished_move.product_uom.id,
+            'location_id': finished_move.location_id.id,
+            'location_dest_id': finished_move.location_dest_id.id,
+        }
+
+    def _prepare_move_line_vals(self, move, origin_move_line, taken_quantity):
+        return {
+            'move_id': move.id,
+            'lot_id': origin_move_line.lot_id.id,
+            'quantity': taken_quantity,
+            'product_id': move.product_id.id,
+            'product_uom_id': origin_move_line.product_uom_id.id,
+            'location_id': move.location_id.id,
+            'location_dest_id': move.location_dest_id.id,
+        }
+
     def action_unbuild(self):
         self.ensure_one()
         self._check_company()
+        # remove the default_* keys that was only needed in the unbuild wizard
+        self.env.context = dict(clean_context(self.env.context))
         if self.product_id.tracking != 'none' and not self.lot_id.id:
             raise UserError(_('You should provide a lot number for the final product.'))
 
-        if self.mo_id:
-            if self.mo_id.state != 'done':
-                raise UserError(_('You cannot unbuild a undone manufacturing order.'))
+        if self.mo_id and self.mo_id.state != 'done':
+            raise UserError(_('You cannot unbuild a undone manufacturing order.'))
 
         consume_moves = self._generate_consume_moves()
         consume_moves._action_confirm()
         produce_moves = self._generate_produce_moves()
         produce_moves._action_confirm()
+        produce_moves.quantity = 0
 
         finished_moves = consume_moves.filtered(lambda m: m.product_id == self.product_id)
         consume_moves -= finished_moves
@@ -164,56 +193,47 @@ class MrpUnbuild(models.Model):
             raise UserError(_('Some of your byproducts are tracked, you have to specify a manufacturing order in order to retrieve the correct byproducts.'))
 
         for finished_move in finished_moves:
-            if finished_move.has_tracking != 'none':
-                self.env['stock.move.line'].create({
-                    'move_id': finished_move.id,
-                    'lot_id': self.lot_id.id,
-                    'qty_done': finished_move.product_uom_qty,
-                    'product_id': finished_move.product_id.id,
-                    'product_uom_id': finished_move.product_uom.id,
-                    'location_id': finished_move.location_id.id,
-                    'location_dest_id': finished_move.location_dest_id.id,
-                })
-            else:
-                finished_move.quantity_done = finished_move.product_uom_qty
+            finished_move_line_vals = self._prepare_finished_move_line_vals(finished_move)
+            self.env['stock.move.line'].create(finished_move_line_vals)
 
         # TODO: Will fail if user do more than one unbuild with lot on the same MO. Need to check what other unbuild has aready took
+        qty_already_used = defaultdict(float)
         for move in produce_moves | consume_moves:
-            if move.has_tracking != 'none':
-                original_move = move in produce_moves and self.mo_id.move_raw_ids or self.mo_id.move_finished_ids
-                original_move = original_move.filtered(lambda m: m.product_id == move.product_id)
-                needed_quantity = move.product_uom_qty
-                moves_lines = original_move.mapped('move_line_ids')
-                if move in produce_moves and self.lot_id:
-                    moves_lines = moves_lines.filtered(lambda ml: self.lot_id in ml.produce_line_ids.lot_id)  # FIXME sle: double check with arm
-                for move_line in moves_lines:
-                    # Iterate over all move_lines until we unbuilded the correct quantity.
-                    taken_quantity = min(needed_quantity, move_line.qty_done)
-                    if taken_quantity:
-                        self.env['stock.move.line'].create({
-                            'move_id': move.id,
-                            'lot_id': move_line.lot_id.id,
-                            'qty_done': taken_quantity,
-                            'product_id': move.product_id.id,
-                            'product_uom_id': move_line.product_uom_id.id,
-                            'location_id': move.location_id.id,
-                            'location_dest_id': move.location_dest_id.id,
-                        })
-                        needed_quantity -= taken_quantity
-            else:
-                move.quantity_done = move.product_uom_qty
+            original_move = move in produce_moves and self.mo_id.move_raw_ids or self.mo_id.move_finished_ids
+            original_move = original_move.filtered(lambda m: m.product_id == move.product_id)
+            if not original_move:
+                move.quantity = float_round(move.product_uom_qty, precision_rounding=move.product_uom.rounding)
+                continue
+            needed_quantity = move.product_uom_qty
+            moves_lines = original_move.mapped('move_line_ids')
+            if move in produce_moves and self.lot_id:
+                moves_lines = moves_lines.filtered(lambda ml: self.lot_id in ml.produce_line_ids.lot_id)  # FIXME sle: double check with arm
+            for move_line in moves_lines:
+                # Iterate over all move_lines until we unbuilded the correct quantity.
+                taken_quantity = min(needed_quantity, move_line.quantity - qty_already_used[move_line])
+                taken_quantity = float_round(taken_quantity, precision_rounding=move.product_uom.rounding)
+                if taken_quantity:
+                    move_line_vals = self._prepare_move_line_vals(move, move_line, taken_quantity)
+                    self.env["stock.move.line"].create(move_line_vals)
+                    needed_quantity -= taken_quantity
+                    qty_already_used[move_line] += taken_quantity
 
+        (finished_moves | consume_moves | produce_moves).picked = True
         finished_moves._action_done()
         consume_moves._action_done()
         produce_moves._action_done()
-        produced_move_line_ids = produce_moves.mapped('move_line_ids').filtered(lambda ml: ml.qty_done > 0)
+        produced_move_line_ids = produce_moves.mapped('move_line_ids').filtered(lambda ml: ml.quantity > 0)
         consume_moves.mapped('move_line_ids').write({'produce_line_ids': [(6, 0, produced_move_line_ids.ids)]})
         if self.mo_id:
-            unbuild_msg = _(
-                "%s %s unbuilt in", self.product_qty, self.product_uom_id.name) + " <a href=# data-oe-model=mrp.unbuild data-oe-id=%d>%s</a>" % (self.id, self.display_name)
+            unbuild_msg = _("%(qty)s %(measure)s unbuilt in %(order)s",
+                qty=self.product_qty,
+                measure=self.product_uom_id.name,
+                order=self._get_html_link(),
+            )
             self.mo_id.message_post(
                 body=unbuild_msg,
-                subtype_id=self.env.ref('mail.mt_note').id)
+                subtype_xmlid='mail.mt_note',
+            )
         return self.write({'state': 'done'})
 
     def _generate_consume_moves(self):
@@ -221,13 +241,15 @@ class MrpUnbuild(models.Model):
         for unbuild in self:
             if unbuild.mo_id:
                 finished_moves = unbuild.mo_id.move_finished_ids.filtered(lambda move: move.state == 'done')
-                factor = unbuild.product_qty / unbuild.mo_id.product_uom_id._compute_quantity(unbuild.mo_id.product_qty, unbuild.product_uom_id)
+                factor = unbuild.product_qty / unbuild.mo_id.product_uom_id._compute_quantity(unbuild.mo_id.qty_produced, unbuild.product_uom_id)
                 for finished_move in finished_moves:
-                    moves += unbuild._generate_move_from_existing_move(finished_move, factor, finished_move.location_dest_id, finished_move.location_id)
+                    moves += unbuild._generate_move_from_existing_move(finished_move, factor, unbuild.location_id, finished_move.location_id)
             else:
                 factor = unbuild.product_uom_id._compute_quantity(unbuild.product_qty, unbuild.bom_id.product_uom_id) / unbuild.bom_id.product_qty
                 moves += unbuild._generate_move_from_bom_line(self.product_id, self.product_uom_id, unbuild.product_qty)
                 for byproduct in unbuild.bom_id.byproduct_ids:
+                    if byproduct._skip_byproduct_line(unbuild.product_id):
+                        continue
                     quantity = byproduct.product_qty * factor
                     moves += unbuild._generate_move_from_bom_line(byproduct.product_id, byproduct.product_uom_id, quantity, byproduct_id=byproduct.id)
         return moves
@@ -237,7 +259,7 @@ class MrpUnbuild(models.Model):
         for unbuild in self:
             if unbuild.mo_id:
                 raw_moves = unbuild.mo_id.move_raw_ids.filtered(lambda move: move.state == 'done')
-                factor = unbuild.product_qty / unbuild.mo_id.product_uom_id._compute_quantity(unbuild.mo_id.product_qty, unbuild.product_uom_id)
+                factor = unbuild.product_qty / unbuild.mo_id.product_uom_id._compute_quantity(unbuild.mo_id.qty_produced, unbuild.product_uom_id)
                 for raw_move in raw_moves:
                     moves += unbuild._generate_move_from_existing_move(raw_move, factor, raw_move.location_dest_id, self.location_dest_id)
             else:
@@ -252,21 +274,22 @@ class MrpUnbuild(models.Model):
             'name': self.name,
             'date': self.create_date,
             'product_id': move.product_id.id,
-            'product_uom_qty': move.product_uom_qty * factor,
+            'product_uom_qty': move.quantity * factor,
             'product_uom': move.product_uom.id,
             'procure_method': 'make_to_stock',
             'location_dest_id': location_dest_id.id,
             'location_id': location_id.id,
-            'warehouse_id': location_dest_id.get_warehouse().id,
+            'warehouse_id': location_dest_id.warehouse_id.id,
             'unbuild_id': self.id,
             'company_id': move.company_id.id,
+            'origin_returned_move_id': move.id,
         })
 
     def _generate_move_from_bom_line(self, product, product_uom, quantity, bom_line_id=False, byproduct_id=False):
         product_prod_location = product.with_company(self.company_id).property_stock_production
         location_id = bom_line_id and product_prod_location or self.location_id
         location_dest_id = bom_line_id and self.location_dest_id or product_prod_location
-        warehouse = location_dest_id.get_warehouse()
+        warehouse = location_dest_id.warehouse_id
         return self.env['stock.move'].create({
             'name': self.name,
             'date': self.create_date,
@@ -302,7 +325,7 @@ class MrpUnbuild(models.Model):
                     'default_location_id': self.location_id.id,
                     'default_unbuild_id': self.id,
                     'default_quantity': unbuild_qty,
-                    'default_product_uom_name': self.product_id.uom_name
+                    'default_product_uom_name': self.product_id.uom_name,
                 },
-                'target': 'new'
+                'target': 'new',
             }

--- a/addons/mrp/models/mrp_workcenter.py
+++ b/addons/mrp/models/mrp_workcenter.py
@@ -2,13 +2,14 @@
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
 from dateutil import relativedelta
-from datetime import timedelta
+from datetime import timedelta, datetime
 from functools import partial
-import datetime
+from pytz import timezone
+from random import randint
 
 from odoo import api, exceptions, fields, models, _
-from odoo.exceptions import ValidationError
-from odoo.addons.resource.models.resource import make_aware, Intervals
+from odoo.exceptions import UserError, ValidationError
+from odoo.addons.resource.models.utils import make_aware, Intervals
 from odoo.tools.float_utils import float_compare
 
 
@@ -25,20 +26,21 @@ class MrpWorkcenter(models.Model):
     active = fields.Boolean('Active', related='resource_id.active', default=True, store=True, readonly=False)
 
     code = fields.Char('Code', copy=False)
-    note = fields.Text(
-        'Description',
-        help="Description of the Work Center.")
-    capacity = fields.Float(
+    note = fields.Html(
+        'Description')
+    default_capacity = fields.Float(
         'Capacity', default=1.0,
-        help="Number of pieces that can be produced in parallel. In case the work center has a capacity of 5 and you have to produce 10 units on your work order, the usual operation time will be multiplied by 2.")
+        help="Default number of pieces (in product UoM) that can be produced in parallel (at the same time) at this work center. For example: the capacity is 5 and you need to produce 10 units, then the operation time listed on the BOM will be multiplied by two. However, note that both time before and after production will only be counted once.")
     sequence = fields.Integer(
         'Sequence', default=1, required=True,
         help="Gives the sequence order when displaying a list of work centers.")
     color = fields.Integer('Color')
-    costs_hour = fields.Float(string='Cost per hour', help='Specify cost of work center per hour.', default=0.0)
-    time_start = fields.Float('Time before prod.', help="Time in minutes for the setup.")
-    time_stop = fields.Float('Time after prod.', help="Time in minutes for the cleaning.")
+    currency_id = fields.Many2one('res.currency', 'Currency', related='company_id.currency_id', readonly=True, required=True)
+    costs_hour = fields.Float(string='Cost per hour', help='Hourly processing cost.', default=0.0)
+    time_start = fields.Float('Setup Time')
+    time_stop = fields.Float('Cleanup Time')
     routing_line_ids = fields.One2many('mrp.routing.workcenter', 'workcenter_id', "Routing Lines")
+    has_routing_lines = fields.Boolean(compute='_compute_has_routing_lines', help='Technical field for workcenter views')
     order_ids = fields.One2many('mrp.workorder', 'workcenter_id', "Orders")
     workorder_count = fields.Integer('# Work Orders', compute='_compute_workorder_count')
     workorder_ready_count = fields.Integer('# Ready Work Orders', compute='_compute_workorder_count')
@@ -70,6 +72,9 @@ class MrpWorkcenter(models.Model):
         string="Alternative Workcenters", check_company=True,
         help="Alternative workcenters that can be substituted to this one in order to dispatch production"
     )
+    tag_ids = fields.Many2many('mrp.workcenter.tag')
+    capacity_ids = fields.One2many('mrp.workcenter.capacity', 'workcenter_id', string='Product Capacities',
+        help="Specific number of pieces that can be produced in parallel per product.", copy=True)
 
     @api.constrains('alternative_workcenter_ids')
     def _check_alternative_workcenter(self):
@@ -77,23 +82,24 @@ class MrpWorkcenter(models.Model):
             if workcenter in workcenter.alternative_workcenter_ids:
                 raise ValidationError(_("Workcenter %s cannot be an alternative of itself.", workcenter.name))
 
-    @api.depends('order_ids.duration_expected', 'order_ids.workcenter_id', 'order_ids.state', 'order_ids.date_planned_start')
+    @api.depends('order_ids.duration_expected', 'order_ids.workcenter_id', 'order_ids.state', 'order_ids.date_start')
     def _compute_workorder_count(self):
         MrpWorkorder = self.env['mrp.workorder']
         result = {wid: {} for wid in self._ids}
         result_duration_expected = {wid: 0 for wid in self._ids}
-        #Count Late Workorder
-        data = MrpWorkorder.read_group([('workcenter_id', 'in', self.ids), ('state', 'in', ('pending', 'ready')), ('date_planned_start', '<', datetime.datetime.now().strftime('%Y-%m-%d'))], ['workcenter_id'], ['workcenter_id'])
-        count_data = dict((item['workcenter_id'][0], item['workcenter_id_count']) for item in data)
-        #Count All, Pending, Ready, Progress Workorder
-        res = MrpWorkorder.read_group(
+        # Count Late Workorder
+        data = MrpWorkorder._read_group(
+            [('workcenter_id', 'in', self.ids), ('state', 'in', ('pending', 'waiting', 'ready')), ('date_start', '<', datetime.now().strftime('%Y-%m-%d'))],
+            ['workcenter_id'], ['__count'])
+        count_data = {workcenter.id: count for workcenter, count in data}
+        # Count All, Pending, Ready, Progress Workorder
+        res = MrpWorkorder._read_group(
             [('workcenter_id', 'in', self.ids)],
-            ['workcenter_id', 'state', 'duration_expected'], ['workcenter_id', 'state'],
-            lazy=False)
-        for res_group in res:
-            result[res_group['workcenter_id'][0]][res_group['state']] = res_group['__count']
-            if res_group['state'] in ('pending', 'ready', 'progress'):
-                result_duration_expected[res_group['workcenter_id'][0]] += res_group['duration_expected']
+            ['workcenter_id', 'state'], ['duration_expected:sum', '__count'])
+        for workcenter, state, duration_sum, count in res:
+            result[workcenter.id][state] = count
+            if state in ('pending', 'waiting', 'ready', 'progress'):
+                result_duration_expected[workcenter.id] += duration_sum
         for workcenter in self:
             workcenter.workorder_count = sum(count for state, count in result[workcenter.id].items() if state not in ('done', 'cancel'))
             workcenter.workorder_pending_count = result[workcenter.id].get('pending', 0)
@@ -124,25 +130,25 @@ class MrpWorkcenter(models.Model):
 
     def _compute_blocked_time(self):
         # TDE FIXME: productivity loss type should be only losses, probably count other time logs differently ??
-        data = self.env['mrp.workcenter.productivity'].read_group([
-            ('date_start', '>=', fields.Datetime.to_string(datetime.datetime.now() - relativedelta.relativedelta(months=1))),
+        data = self.env['mrp.workcenter.productivity']._read_group([
+            ('date_start', '>=', fields.Datetime.to_string(datetime.now() - relativedelta.relativedelta(months=1))),
             ('workcenter_id', 'in', self.ids),
             ('date_end', '!=', False),
             ('loss_type', '!=', 'productive')],
-            ['duration', 'workcenter_id'], ['workcenter_id'], lazy=False)
-        count_data = dict((item['workcenter_id'][0], item['duration']) for item in data)
+            ['workcenter_id'], ['duration:sum'])
+        count_data = {workcenter.id: duration for workcenter, duration in data}
         for workcenter in self:
             workcenter.blocked_time = count_data.get(workcenter.id, 0.0) / 60.0
 
     def _compute_productive_time(self):
         # TDE FIXME: productivity loss type should be only losses, probably count other time logs differently
-        data = self.env['mrp.workcenter.productivity'].read_group([
-            ('date_start', '>=', fields.Datetime.to_string(datetime.datetime.now() - relativedelta.relativedelta(months=1))),
+        data = self.env['mrp.workcenter.productivity']._read_group([
+            ('date_start', '>=', fields.Datetime.to_string(datetime.now() - relativedelta.relativedelta(months=1))),
             ('workcenter_id', 'in', self.ids),
             ('date_end', '!=', False),
             ('loss_type', '=', 'productive')],
-            ['duration', 'workcenter_id'], ['workcenter_id'], lazy=False)
-        count_data = dict((item['workcenter_id'][0], item['duration']) for item in data)
+            ['workcenter_id'], ['duration:sum'])
+        count_data = {workcenter.id: duration for workcenter, duration in data}
         for workcenter in self:
             workcenter.productive_time = count_data.get(workcenter.id, 0.0) / 60.0
 
@@ -155,21 +161,26 @@ class MrpWorkcenter(models.Model):
                 order.oee = 0.0
 
     def _compute_performance(self):
-        wo_data = self.env['mrp.workorder'].read_group([
-            ('date_start', '>=', fields.Datetime.to_string(datetime.datetime.now() - relativedelta.relativedelta(months=1))),
+        wo_data = self.env['mrp.workorder']._read_group([
+            ('date_start', '>=', fields.Datetime.to_string(datetime.now() - relativedelta.relativedelta(months=1))),
             ('workcenter_id', 'in', self.ids),
-            ('state', '=', 'done')], ['duration_expected', 'workcenter_id', 'duration'], ['workcenter_id'], lazy=False)
-        duration_expected = dict((data['workcenter_id'][0], data['duration_expected']) for data in wo_data)
-        duration = dict((data['workcenter_id'][0], data['duration']) for data in wo_data)
+            ('state', '=', 'done')], ['workcenter_id'], ['duration_expected:sum', 'duration:sum'])
+        duration_expected = {workcenter.id: expected for workcenter, expected, __ in wo_data}
+        duration = {workcenter.id: duration for workcenter, __, duration in wo_data}
         for workcenter in self:
             if duration.get(workcenter.id):
                 workcenter.performance = 100 * duration_expected.get(workcenter.id, 0.0) / duration[workcenter.id]
             else:
                 workcenter.performance = 0.0
 
-    @api.constrains('capacity')
+    @api.depends('routing_line_ids')
+    def _compute_has_routing_lines(self):
+        for workcenter in self:
+            workcenter.has_routing_lines = self.env['mrp.routing.workcenter'].search_count([('workcenter_id', '=', workcenter.id)], limit=1)
+
+    @api.constrains('default_capacity')
     def _check_capacity(self):
-        if any(workcenter.capacity <= 0.0 for workcenter in self):
+        if any(workcenter.default_capacity <= 0.0 for workcenter in self):
             raise exceptions.UserError(_('The capacity must be strictly positive.'))
 
     def unblock(self):
@@ -177,8 +188,8 @@ class MrpWorkcenter(models.Model):
         if self.working_state != 'blocked':
             raise exceptions.UserError(_("It has already been unblocked."))
         times = self.env['mrp.workcenter.productivity'].search([('workcenter_id', '=', self.id), ('date_end', '=', False)])
-        times.write({'date_end': fields.Datetime.now()})
-        return {'type': 'ir.actions.client', 'tag': 'reload'}
+        times.write({'date_end': datetime.now()})
+        return True
 
     @api.model_create_multi
     def create(self, vals_list):
@@ -192,6 +203,15 @@ class MrpWorkcenter(models.Model):
             self.resource_id.company_id = vals['company_id']
         return super(MrpWorkcenter, self).write(vals)
 
+    def action_show_operations(self):
+        self.ensure_one()
+        action = self.env['ir.actions.actions']._for_xml_id('mrp.mrp_routing_action')
+        action['domain'] = [('workcenter_id', '=', self.id)]
+        action['context'] = {
+            'default_workcenter_id': self.id,
+        }
+        return action
+
     def action_work_order(self):
         action = self.env["ir.actions.actions"]._for_xml_id("mrp.action_work_orders")
         return action
@@ -209,7 +229,7 @@ class MrpWorkcenter(models.Model):
         unavailability_ressources = self.resource_id._get_unavailable_intervals(start_datetime, end_datetime)
         return {wc.id: unavailability_ressources.get(wc.resource_id.id, []) for wc in self}
 
-    def _get_first_available_slot(self, start_datetime, duration):
+    def _get_first_available_slot(self, start_datetime, duration, backward=False, leaves_to_ignore=False):
         """Get the first available interval for the workcenter in `self`.
 
         The available interval is disjoinct with all other workorders planned on this workcenter, but
@@ -217,56 +237,122 @@ class MrpWorkcenter(models.Model):
         Return the first available interval (start datetime, end datetime) or,
         if there is none before 700 days, a tuple error (False, 'error message').
 
-        :param start_datetime: begin the search at this datetime
         :param duration: minutes needed to make the workorder (float)
+        :param start_datetime: begin the search at this datetime
+        :param backward: search from start_datetime to now (default is from start_datetime to 700 days after)
+        :param leaves_to_ignore: typically, ignore allocated leave when re-planning a workorder
         :rtype: tuple
         """
         self.ensure_one()
+        resource = self.resource_id
         start_datetime, revert = make_aware(start_datetime)
+        available_intervals_domain = [('time_type', 'in', ['other', 'leave'])]
+        workorder_intervals_domain = [('time_type', '=', 'other')]
+        if leaves_to_ignore:
+            available_intervals_domain.append(('id', 'not in', leaves_to_ignore.ids))
+            workorder_intervals_domain.append(('id', 'not in', leaves_to_ignore.ids))
 
-        resource = self.resource_id
-        get_available_intervals = partial(self.resource_calendar_id._work_intervals_batch, domain=[('time_type', 'in', ['other', 'leave'])], resources=resource)
-        get_workorder_intervals = partial(self.resource_calendar_id._leave_intervals_batch, domain=[('time_type', '=', 'other')], resources=resource)
+        get_available_intervals = partial(self.resource_calendar_id._work_intervals_batch, domain=available_intervals_domain, resources=resource, tz=timezone(self.resource_calendar_id.tz))
+        get_workorder_intervals = partial(self.resource_calendar_id._leave_intervals_batch, domain=workorder_intervals_domain, resources=resource, tz=timezone(self.resource_calendar_id.tz))
 
         remaining = duration
         start_interval = start_datetime
-        delta = timedelta(days=14)
-
+        now = make_aware(datetime.now())[0]
+        delta = timedelta(days=-14 if backward else +14)
         for n in range(50):  # 50 * 14 = 700 days in advance (hardcoded)
-            dt = start_datetime + delta * n
-            available_intervals = get_available_intervals(dt, dt + delta)[resource.id]
-            workorder_intervals = get_workorder_intervals(dt, dt + delta)[resource.id]
+            date_start = start_datetime + delta * n
+            date_stop = date_start + delta
+            if backward:
+                date_stop, date_start = date_start, date_stop
+
+            available_intervals = get_available_intervals(date_start, date_stop)[resource.id]
+            workorder_intervals = get_workorder_intervals(date_start, date_stop)[resource.id]
+            if backward:
+                available_intervals = reversed(available_intervals)
+
             for start, stop, dummy in available_intervals:
-                interval_minutes = (stop - start).total_seconds() / 60
-                # If the remaining minutes has never decrease update start_interval
-                if remaining == duration:
-                    start_interval = start
-                # If there is a overlap between the possible available interval and a others WO
-                if Intervals([(start_interval, start + timedelta(minutes=min(remaining, interval_minutes)), dummy)]) & workorder_intervals:
-                    remaining = duration
-                    start_interval = start
-                elif float_compare(interval_minutes, remaining, precision_digits=3) >= 0:
-                    return revert(start_interval), revert(start + timedelta(minutes=remaining))
-                # Decrease a part of the remaining duration
-                remaining -= interval_minutes
+                # Shouldn't loop more than 2 times because the available_intervals contains the workorder_intervals
+                # And remaining == duration can only occur at the first loop and at the interval intersection (cannot happen several time because available_intervals > workorder_intervals
+                for _i in range(2):
+                    interval_minutes = (stop - start).total_seconds() / 60
+                    # If the remaining minutes has never decrease update start_interval
+                    if remaining == duration:
+                        start_interval = start
+                        stop_interval = stop
+                    # If there is a overlap between the possible available interval and a others WO
+                    if Intervals([(start_interval, start + timedelta(minutes=min(remaining, interval_minutes)), dummy)]) & workorder_intervals:
+                        remaining = duration
+                    elif float_compare(interval_minutes, remaining, precision_digits=3) >= 0:
+                        if backward:
+                            return revert(stop - timedelta(minutes=remaining)), revert(stop_interval)
+                        return revert(start_interval), revert(start + timedelta(minutes=remaining))
+                    else:
+                        # Decrease a part of the remaining duration
+                        remaining -= interval_minutes
+                        # Go to the next available interval because the possible current interval duration has been used
+                        break
+            if backward and date_start <= now:
+                break
         return False, 'Not available slot 700 days after the planned start'
 
+    def action_archive(self):
+        res = super().action_archive()
+        filtered_workcenters = ", ".join(workcenter.name for workcenter in self.filtered('routing_line_ids'))
+        if filtered_workcenters:
+            return {
+                'type': 'ir.actions.client',
+                'tag': 'display_notification',
+                'params': {
+                'title': _("Note that archived work center(s): '%s' is/are still linked to active Bill of Materials, which means that operations can still be planned on it/them. "
+                           "To prevent this, deletion of the work center is recommended instead.", filtered_workcenters),
+                'type': 'warning',
+                'sticky': True,  #True/False will display for few seconds if false
+                'next': {'type': 'ir.actions.act_window_close'},
+                },
+            }
+        return res
+
+    def _get_capacity(self, product):
+        product_capacity = self.capacity_ids.filtered(lambda capacity: capacity.product_id == product)
+        return product_capacity.capacity if product_capacity else self.default_capacity
+
+    def _get_expected_duration(self, product_id):
+        """Compute the expected duration when using this work-center
+        Always use the startup / clean-up time from specific capacity if defined.
+        """
+        capacity = self.capacity_ids.filtered(lambda p: p.product_id == product_id)
+        return capacity.time_start + capacity.time_stop if capacity else self.time_start + self.time_stop
+
+
+class WorkcenterTag(models.Model):
+    _name = 'mrp.workcenter.tag'
+    _description = 'Add tag for the workcenter'
+    _order = 'name'
+
+    def _get_default_color(self):
+        return randint(1, 11)
+
+    name = fields.Char("Tag Name", required=True)
+    color = fields.Integer("Color Index", default=_get_default_color)
+
+    _sql_constraints = [
+        ('tag_name_unique', 'unique(name)',
+         'The tag name must be unique.'),
+    ]
+
 
 class MrpWorkcenterProductivityLossType(models.Model):
     _name = "mrp.workcenter.productivity.loss.type"
     _description = 'MRP Workorder productivity losses'
     _rec_name = 'loss_type'
 
-    @api.depends('loss_type')
-    def name_get(self):
+    def _compute_display_name(self):
         """ As 'category' field in form view is a Many2one, its value will be in
-        lower case. In order to display its value capitalized 'name_get' is
+        lower case. In order to display its value capitalized 'display_name' is
         overrided.
         """
-        result = []
         for rec in self:
-            result.append((rec.id, rec.loss_type.title()))
-        return result
+            rec.display_name = rec.loss_type.title()
 
     loss_type = fields.Selection([
             ('availability', 'Availability'),
@@ -280,12 +366,26 @@ class MrpWorkcenterProductivityLoss(models.Model):
     _description = "Workcenter Productivity Losses"
     _order = "sequence, id"
 
-    name = fields.Char('Blocking Reason', required=True)
+    name = fields.Char('Blocking Reason', required=True, translate=True)
     sequence = fields.Integer('Sequence', default=1)
     manual = fields.Boolean('Is a Blocking Reason', default=True)
-    loss_id = fields.Many2one('mrp.workcenter.productivity.loss.type', domain=([('loss_type', 'in', ['quality', 'availability'])]), string='Category')
+    loss_id = fields.Many2one('mrp.workcenter.productivity.loss.type', domain=[('loss_type', 'in', ['quality', 'availability'])], string='Category')
     loss_type = fields.Selection(string='Effectiveness Category', related='loss_id.loss_type', store=True, readonly=False)
 
+    def _convert_to_duration(self, date_start, date_stop, workcenter=False):
+        """ Convert a date range into a duration in minutes.
+        If the productivity type is not from an employee (extra hours are allow)
+        and the workcenter has a calendar, convert the dates into a duration based on
+        working hours.
+        """
+        duration = 0
+        for productivity_loss in self:
+            if (productivity_loss.loss_type not in ('productive', 'performance')) and workcenter and workcenter.resource_calendar_id:
+                r = workcenter._get_work_days_data_batch(date_start, date_stop)[workcenter.id]['hours']
+                duration = max(duration, r * 60)
+            else:
+                duration = max(duration, (date_stop - date_start).total_seconds() / 60.0)
+        return round(duration, 2)
 
 class MrpWorkcenterProductivity(models.Model):
     _name = "mrp.workcenter.productivity"
@@ -330,18 +430,91 @@ class MrpWorkcenterProductivity(models.Model):
     @api.depends('date_end', 'date_start')
     def _compute_duration(self):
         for blocktime in self:
-            if blocktime.date_end:
-                d1 = fields.Datetime.from_string(blocktime.date_start)
-                d2 = fields.Datetime.from_string(blocktime.date_end)
-                diff = d2 - d1
-                if (blocktime.loss_type not in ('productive', 'performance')) and blocktime.workcenter_id.resource_calendar_id:
-                    r = blocktime.workcenter_id._get_work_days_data_batch(d1, d2)[blocktime.workcenter_id.id]['hours']
-                    blocktime.duration = round(r * 60, 2)
-                else:
-                    blocktime.duration = round(diff.total_seconds() / 60.0, 2)
+            if blocktime.date_start and blocktime.date_end:
+                blocktime.duration = blocktime.loss_id._convert_to_duration(blocktime.date_start.replace(microsecond=0), blocktime.date_end.replace(microsecond=0), blocktime.workcenter_id)
             else:
                 blocktime.duration = 0.0
 
+    @api.onchange('duration')
+    def _duration_changed(self):
+        self.date_start = self.date_end - timedelta(minutes=self.duration)
+        self._loss_type_change()
+
+    @api.onchange('date_start')
+    def _date_start_changed(self):
+        if not self.date_start:
+            return
+        self.date_end = self.date_start + timedelta(minutes=self.duration)
+        self._loss_type_change()
+
+    @api.onchange('date_end')
+    def _date_end_changed(self):
+        if not self.date_end:
+            return
+        self.date_start = self.date_end - timedelta(minutes=self.duration)
+        self._loss_type_change()
+
+    @api.constrains('workorder_id')
+    def _check_open_time_ids(self):
+        for workorder in self.workorder_id:
+            open_time_ids_by_user = self.env["mrp.workcenter.productivity"]._read_group(
+                [("id", "in", workorder.time_ids.ids), ("date_end", "=", False)],
+                ["user_id"], having=[("__count", ">", 1)],
+            )
+            if open_time_ids_by_user:
+                raise ValidationError(_('The Workorder (%s) cannot be started twice!', workorder.display_name))
+
     def button_block(self):
         self.ensure_one()
         self.workcenter_id.order_ids.end_all()
+
+    def _loss_type_change(self):
+        self.ensure_one()
+        if self.workorder_id.duration > self.workorder_id.duration_expected:
+            self.loss_id = self.env.ref("mrp.block_reason4").id
+        else:
+            self.loss_id = self.env.ref("mrp.block_reason7").id
+
+    def _close(self):
+        underperformance_timers = self.env['mrp.workcenter.productivity']
+        for timer in self:
+            wo = timer.workorder_id
+            timer.write({'date_end': fields.Datetime.now()})
+            if wo.duration > wo.duration_expected:
+                productive_date_end = timer.date_end - relativedelta.relativedelta(minutes=wo.duration - wo.duration_expected)
+                if productive_date_end <= timer.date_start:
+                    underperformance_timers |= timer
+                else:
+                    underperformance_timers |= timer.copy({'date_start': productive_date_end})
+                    timer.write({'date_end': productive_date_end})
+        if underperformance_timers:
+            underperformance_type = self.env['mrp.workcenter.productivity.loss'].search([('loss_type', '=', 'performance')], limit=1)
+            if not underperformance_type:
+                raise UserError(_("You need to define at least one unactive productivity loss in the category 'Performance'. Create one from the Manufacturing app, menu: Configuration / Productivity Losses."))
+            underperformance_timers.write({'loss_id': underperformance_type.id})
+
+
+class MrpWorkCenterCapacity(models.Model):
+    _name = 'mrp.workcenter.capacity'
+    _description = 'Work Center Capacity'
+    _check_company_auto = True
+
+    def _default_time_start(self):
+        workcenter_id = self.workcenter_id.id or self.env.context.get('default_workcenter_id')
+        return self.env['mrp.workcenter'].browse(workcenter_id).time_start if workcenter_id else 0.0
+
+    def _default_time_stop(self):
+        workcenter_id = self.workcenter_id.id or self.env.context.get('default_workcenter_id')
+        return self.env['mrp.workcenter'].browse(workcenter_id).time_stop if workcenter_id else 0.0
+
+    workcenter_id = fields.Many2one('mrp.workcenter', string='Work Center', required=True)
+    product_id = fields.Many2one('product.product', string='Product', required=True)
+    product_uom_id = fields.Many2one('uom.uom', string='Product UoM', related='product_id.uom_id')
+    capacity = fields.Float('Capacity', default=1.0, help="Number of pieces that can be produced in parallel for this product.")
+    time_start = fields.Float('Setup Time (minutes)', default=_default_time_start, help="Time in minutes for the setup.")
+    time_stop = fields.Float('Cleanup Time (minutes)', default=_default_time_stop, help="Time in minutes for the cleaning.")
+
+    _sql_constraints = [
+        ('positive_capacity', 'CHECK(capacity > 0)', 'Capacity should be a positive number.'),
+        ('unique_product', 'UNIQUE(workcenter_id, product_id)', 'Product capacity should be unique for each workcenter.'),
+    ]

--- a/addons/mrp/models/mrp_workorder.py
+++ b/addons/mrp/models/mrp_workorder.py
@@ -7,42 +7,39 @@ from collections import defaultdict
 import json
 
 from odoo import api, fields, models, _, SUPERUSER_ID
-from odoo.exceptions import UserError
+from odoo.exceptions import UserError, ValidationError
 from odoo.tools import float_compare, float_round, format_datetime
 
 
 class MrpWorkorder(models.Model):
     _name = 'mrp.workorder'
     _description = 'Work Order'
+    _order = 'leave_id, date_start, id'
 
-    def _read_group_workcenter_id(self, workcenters, domain, order):
+    def _read_group_workcenter_id(self, workcenters, domain):
         workcenter_ids = self.env.context.get('default_workcenter_id')
         if not workcenter_ids:
-            workcenter_ids = workcenters._search([], order=order, access_rights_uid=SUPERUSER_ID)
+            workcenter_ids = workcenters._search([], order=workcenters._order, access_rights_uid=SUPERUSER_ID)
         return workcenters.browse(workcenter_ids)
 
     name = fields.Char(
-        'Work Order', required=True,
-        states={'done': [('readonly', True)], 'cancel': [('readonly', True)]})
+        'Work Order', required=True)
+    barcode = fields.Char(compute='_compute_barcode', store=True)
     workcenter_id = fields.Many2one(
         'mrp.workcenter', 'Work Center', required=True,
-        states={'done': [('readonly', True)], 'cancel': [('readonly', True)], 'progress': [('readonly', True)]},
         group_expand='_read_group_workcenter_id', check_company=True)
     working_state = fields.Selection(
-        string='Workcenter Status', related='workcenter_id.working_state',
-        help='Technical: used in views only')
+        string='Workcenter Status', related='workcenter_id.working_state') # technical: used in views only
     product_id = fields.Many2one(related='production_id.product_id', readonly=True, store=True, check_company=True)
     product_tracking = fields.Selection(related="product_id.tracking")
     product_uom_id = fields.Many2one('uom.uom', 'Unit of Measure', required=True, readonly=True)
-    production_id = fields.Many2one('mrp.production', 'Manufacturing Order', required=True, check_company=True, readonly=True)
+    production_id = fields.Many2one('mrp.production', 'Manufacturing Order', required=True, check_company=True, readonly=True, index='btree')
     production_availability = fields.Selection(
         string='Stock Availability', readonly=True,
-        related='production_id.reservation_state', store=True,
-        help='Technical: used in views and domains only.')
+        related='production_id.reservation_state', store=True) # Technical: used in views and domains only
     production_state = fields.Selection(
         string='Production State', readonly=True,
-        related='production_id.state',
-        help='Technical: used in views only.')
+        related='production_id.state') # Technical: used in views only
     production_bom_id = fields.Many2one('mrp.bom', related='production_id.bom_id')
     qty_production = fields.Float('Original Production Quantity', readonly=True, related='production_id.product_qty')
     company_id = fields.Many2one(related='production_id.company_id')
@@ -60,47 +57,39 @@ class MrpWorkorder(models.Model):
         compute='_compute_is_produced')
     state = fields.Selection([
         ('pending', 'Waiting for another WO'),
+        ('waiting', 'Waiting for components'),
         ('ready', 'Ready'),
         ('progress', 'In Progress'),
         ('done', 'Finished'),
         ('cancel', 'Cancelled')], string='Status',
-        default='pending', copy=False, readonly=True)
+        compute='_compute_state', store=True,
+        default='pending', copy=False, readonly=True, recursive=True, index=True)
     leave_id = fields.Many2one(
         'resource.calendar.leaves',
         help='Slot into workcenter calendar once planned',
         check_company=True, copy=False)
-    date_planned_start = fields.Datetime(
-        'Scheduled Start Date',
-        compute='_compute_dates_planned',
-        inverse='_set_dates_planned',
-        states={'done': [('readonly', True)], 'cancel': [('readonly', True)]},
-        store=True, copy=False)
-    date_planned_finished = fields.Datetime(
-        'Scheduled End Date',
-        compute='_compute_dates_planned',
-        inverse='_set_dates_planned',
-        states={'done': [('readonly', True)], 'cancel': [('readonly', True)]},
-        store=True, copy=False)
     date_start = fields.Datetime(
-        'Start Date', copy=False,
-        states={'done': [('readonly', True)], 'cancel': [('readonly', True)]})
+        'Start',
+        compute='_compute_dates',
+        inverse='_set_dates',
+        store=True, copy=False)
     date_finished = fields.Datetime(
-        'End Date', copy=False,
-        states={'done': [('readonly', True)], 'cancel': [('readonly', True)]})
-
+        'End',
+        compute='_compute_dates',
+        inverse='_set_dates',
+        store=True, copy=False)
     duration_expected = fields.Float(
-        'Expected Duration', digits=(16, 2), default=60.0,
-        states={'done': [('readonly', True)], 'cancel': [('readonly', True)]},
-        help="Expected duration (in minutes)")
+        'Expected Duration', digits=(16, 2), compute='_compute_duration_expected',
+        readonly=False, store=True) # in minutes
     duration = fields.Float(
         'Real Duration', compute='_compute_duration', inverse='_set_duration',
         readonly=False, store=True, copy=False)
     duration_unit = fields.Float(
         'Duration Per Unit', compute='_compute_duration',
-        group_operator="avg", readonly=True, store=True)
+        aggregator="avg", readonly=True, store=True)
     duration_percent = fields.Integer(
         'Duration Deviation (%)', compute='_compute_duration',
-        group_operator="avg", readonly=True, store=True)
+        aggregator="avg", readonly=True, store=True)
     progress = fields.Float('Progress Done (%)', digits=(16, 2), compute='_compute_progress')
 
     operation_id = fields.Many2one(
@@ -112,7 +101,7 @@ class MrpWorkorder(models.Model):
         string='Worksheet Type', related='operation_id.worksheet_type', readonly=True)
     worksheet_google_slide = fields.Char(
         'Worksheet URL', related='operation_id.worksheet_google_slide', readonly=True)
-    operation_note = fields.Text("Description", related='operation_id.note', readonly=True)
+    operation_note = fields.Html("Description", related='operation_id.note', readonly=True)
     move_raw_ids = fields.One2many(
         'stock.move', 'workorder_id', 'Raw Moves',
         domain=[('raw_material_production_id', '!=', False), ('production_id', '=', False)])
@@ -123,61 +112,89 @@ class MrpWorkorder(models.Model):
         'stock.move.line', 'workorder_id', 'Moves to Track',
         help="Inventory moves for which you must scan a lot number at this work order")
     finished_lot_id = fields.Many2one(
-        'stock.production.lot', string='Lot/Serial Number', compute='_compute_finished_lot_id',
-        inverse='_set_finished_lot_id', domain="[('product_id', '=', product_id), ('company_id', '=', company_id)]",
-        check_company=True)
+        'stock.lot', string='Lot/Serial Number', related='production_id.lot_producing_id',
+        domain="[('product_id', '=', product_id), ('company_id', '=', company_id)]",
+        readonly=False, check_company=True)
     time_ids = fields.One2many(
         'mrp.workcenter.productivity', 'workorder_id', copy=False)
     is_user_working = fields.Boolean(
-        'Is the Current User Working', compute='_compute_working_users',
-        help="Technical field indicating whether the current user is working. ")
+        'Is the Current User Working', compute='_compute_working_users') # technical: is the current user working
     working_user_ids = fields.One2many('res.users', string='Working user on this work order.', compute='_compute_working_users')
     last_working_user_id = fields.One2many('res.users', string='Last user that worked on this work order.', compute='_compute_working_users')
+    costs_hour = fields.Float(
+        string='Cost per hour',
+        default=0.0, aggregator="avg")
+        # Technical field to store the hourly cost of workcenter at time of work order completion (i.e. to keep a consistent cost).',
 
-    next_work_order_id = fields.Many2one('mrp.workorder', "Next Work Order", check_company=True)
     scrap_ids = fields.One2many('stock.scrap', 'workorder_id')
     scrap_count = fields.Integer(compute='_compute_scrap_move_count', string='Scrap Move')
-    production_date = fields.Datetime('Production Date', related='production_id.date_planned_start', store=True)
+    production_date = fields.Datetime('Production Date', related='production_id.date_start', store=True)
     json_popover = fields.Char('Popover Data JSON', compute='_compute_json_popover')
     show_json_popover = fields.Boolean('Show Popover?', compute='_compute_json_popover')
     consumption = fields.Selection(related='production_id.consumption')
+    qty_reported_from_previous_wo = fields.Float('Carried Quantity', digits='Product Unit of Measure', copy=False,
+        help="The quantity already produced awaiting allocation in the backorders chain.")
+    is_planned = fields.Boolean(related='production_id.is_planned')
+    allow_workorder_dependencies = fields.Boolean(related='production_id.allow_workorder_dependencies')
+    blocked_by_workorder_ids = fields.Many2many('mrp.workorder', relation="mrp_workorder_dependencies_rel",
+                                     column1="workorder_id", column2="blocked_by_id", string="Blocked By",
+                                     domain="[('allow_workorder_dependencies', '=', True), ('id', '!=', id), ('production_id', '=', production_id)]",
+                                     copy=False)
+    needed_by_workorder_ids = fields.Many2many('mrp.workorder', relation="mrp_workorder_dependencies_rel",
+                                     column1="blocked_by_id", column2="workorder_id", string="Blocks",
+                                     domain="[('allow_workorder_dependencies', '=', True), ('id', '!=', id), ('production_id', '=', production_id)]",
+                                     copy=False)
+
+    @api.depends('production_availability', 'blocked_by_workorder_ids.state')
+    def _compute_state(self):
+        # Force to compute the production_availability right away.
+        # It is a trick to force that the state of workorder is computed at the end of the
+        # cyclic depends with the mo.state, mo.reservation_state and wo.state and avoid recursion error
+        self.mapped('production_availability')
+        for workorder in self:
+            if workorder.state == 'pending':
+                if all([wo.state in ('done', 'cancel') for wo in workorder.blocked_by_workorder_ids]):
+                    workorder.state = 'ready' if workorder.production_availability == 'assigned' else 'waiting'
+                    continue
+            if workorder.state not in ('waiting', 'ready'):
+                continue
+            if not all([wo.state in ('done', 'cancel') for wo in workorder.blocked_by_workorder_ids]):
+                workorder.state = 'pending'
+                continue
+            if workorder.production_availability not in ('waiting', 'confirmed', 'assigned'):
+                continue
+            if workorder.production_availability == 'assigned' and workorder.state == 'waiting':
+                workorder.state = 'ready'
+            elif workorder.production_availability != 'assigned' and workorder.state == 'ready':
+                workorder.state = 'waiting'
 
-    @api.depends('production_state', 'date_planned_start', 'date_planned_finished')
+    @api.depends('production_state', 'date_start', 'date_finished')
     def _compute_json_popover(self):
-        previous_wo_data = self.env['mrp.workorder'].read_group(
-            [('next_work_order_id', 'in', self.ids)],
-            ['ids:array_agg(id)', 'date_planned_start:max', 'date_planned_finished:max'],
-            ['next_work_order_id'])
-        previous_wo_dict = dict([(x['next_work_order_id'][0], {
-            'id': x['ids'][0],
-            'date_planned_start': x['date_planned_start'],
-            'date_planned_finished': x['date_planned_finished']})
-            for x in previous_wo_data])
         if self.ids:
             conflicted_dict = self._get_conflicted_workorder_ids()
         for wo in self:
             infos = []
-            if not wo.date_planned_start or not wo.date_planned_finished or not wo.ids:
+            if not wo.date_start or not wo.date_finished or not wo.ids:
                 wo.show_json_popover = False
                 wo.json_popover = False
                 continue
-            if wo.state in ['pending', 'ready']:
-                previous_wo = previous_wo_dict.get(wo.id)
-                prev_start = previous_wo and previous_wo['date_planned_start'] or False
-                prev_finished = previous_wo and previous_wo['date_planned_finished'] or False
-                if wo.state == 'pending' and prev_start and not (prev_start > wo.date_planned_start):
+            if wo.state in ('pending', 'waiting', 'ready'):
+                previous_wos = wo.blocked_by_workorder_ids
+                prev_start = min([workorder.date_start for workorder in previous_wos]) if previous_wos else False
+                prev_finished = max([workorder.date_finished for workorder in previous_wos]) if previous_wos else False
+                if wo.state == 'pending' and prev_start and not (prev_start > wo.date_start):
                     infos.append({
                         'color': 'text-primary',
                         'msg': _("Waiting the previous work order, planned from %(start)s to %(end)s",
                             start=format_datetime(self.env, prev_start, dt_format=False),
                             end=format_datetime(self.env, prev_finished, dt_format=False))
                     })
-                if wo.date_planned_finished < fields.Datetime.now():
+                if wo.date_finished < fields.Datetime.now():
                     infos.append({
                         'color': 'text-warning',
                         'msg': _("The work order should have already been processed.")
                     })
-                if prev_start and prev_start > wo.date_planned_start:
+                if prev_start and prev_start > wo.date_start:
                     infos.append({
                         'color': 'text-danger',
                         'msg': _("Scheduled before the previous work order, planned from %(start)s to %(end)s",
@@ -192,21 +209,13 @@ class MrpWorkorder(models.Model):
             color_icon = infos and infos[-1]['color'] or False
             wo.show_json_popover = bool(color_icon)
             wo.json_popover = json.dumps({
+                'popoverTemplate': 'mrp.workorderPopover',
                 'infos': infos,
                 'color': color_icon,
                 'icon': 'fa-exclamation-triangle' if color_icon in ['text-warning', 'text-danger'] else 'fa-info-circle',
                 'replan': color_icon not in [False, 'text-primary']
             })
 
-    @api.depends('production_id.lot_producing_id')
-    def _compute_finished_lot_id(self):
-        for workorder in self:
-            workorder.finished_lot_id = workorder.production_id.lot_producing_id
-
-    def _set_finished_lot_id(self):
-        for workorder in self:
-            workorder.production_id.lot_producing_id = workorder.finished_lot_id
-
     @api.depends('production_id.qty_producing')
     def _compute_qty_producing(self):
         for workorder in self:
@@ -218,40 +227,62 @@ class MrpWorkorder(models.Model):
                 workorder.production_id.qty_producing = workorder.qty_producing
                 workorder.production_id._set_qty_producing()
 
-    # Both `date_planned_start` and `date_planned_finished` are related fields on `leave_id`. Let's say
+    # Both `date_start` and `date_finished` are related fields on `leave_id`. Let's say
     # we slide a workorder on a gantt view, a single call to write is made with both
     # fields Changes. As the ORM doesn't batch the write on related fields and instead
     # makes multiple call, the constraint check_dates() is raised.
     # That's why the compute and set methods are needed. to ensure the dates are updated
     # in the same time.
     @api.depends('leave_id')
-    def _compute_dates_planned(self):
+    def _compute_dates(self):
         for workorder in self:
-            workorder.date_planned_start = workorder.leave_id.date_from
-            workorder.date_planned_finished = workorder.leave_id.date_to
-
-    def _set_dates_planned(self):
-        date_from = self[0].date_planned_start
-        date_to = self[0].date_planned_finished
-        self.mapped('leave_id').sudo().write({
-            'date_from': date_from,
-            'date_to': date_to,
-        })
+            workorder.date_start = workorder.leave_id.date_from
+            workorder.date_finished = workorder.leave_id.date_to
+
+    def _set_dates(self):
+        for wo in self.sudo():
+            if wo.leave_id:
+                if (not wo.date_start or not wo.date_finished):
+                    raise UserError(_("It is not possible to unplan one single Work Order. "
+                              "You should unplan the Manufacturing Order instead in order to unplan all the linked operations."))
+                wo.leave_id.write({
+                    'date_from': wo.date_start,
+                    'date_to': wo.date_finished,
+                })
+            elif wo.date_start:
+                wo.date_finished = wo._calculate_date_finished()
+                wo.leave_id = wo.env['resource.calendar.leaves'].create({
+                    'name': wo.display_name,
+                    'calendar_id': wo.workcenter_id.resource_calendar_id.id,
+                    'date_from': wo.date_start,
+                    'date_to': wo.date_finished,
+                    'resource_id': wo.workcenter_id.resource_id.id,
+                    'time_type': 'other',
+                })
 
-    def name_get(self):
-        res = []
+    @api.constrains('blocked_by_workorder_ids')
+    def _check_no_cyclic_dependencies(self):
+        if self._has_cycle('blocked_by_workorder_ids'):
+            raise ValidationError(_("You cannot create cyclic dependency."))
+
+    @api.depends('production_id.name')
+    def _compute_barcode(self):
         for wo in self:
-            if len(wo.production_id.workorder_ids) == 1:
-                res.append((wo.id, "%s - %s - %s" % (wo.production_id.name, wo.product_id.name, wo.name)))
-            else:
-                res.append((wo.id, "%s - %s - %s - %s" % (wo.production_id.workorder_ids.ids.index(wo._origin.id) + 1, wo.production_id.name, wo.product_id.name, wo.name)))
-        return res
+            wo.barcode = f"{wo.production_id.name}/{wo.id}"
+
+    @api.depends('production_id', 'product_id')
+    def _compute_display_name(self):
+        for wo in self:
+            wo.display_name = f"{wo.production_id.name} - {wo.name}"
 
     def unlink(self):
         # Removes references to workorder to avoid Validation Error
         (self.mapped('move_raw_ids') | self.mapped('move_finished_ids')).write({'workorder_id': False})
         self.mapped('leave_id').unlink()
         mo_dirty = self.production_id.filtered(lambda mo: mo.state in ("confirmed", "progress", "to_close"))
+
+        for workorder in self:
+            workorder.blocked_by_workorder_ids.needed_by_workorder_ids = workorder.needed_by_workorder_ids
         res = super().unlink()
         # We need to go through `_action_confirm` for all workorders of the current productions to
         # make sure the links between them are correct (`next_work_order_id` could be obsolete now).
@@ -265,13 +296,19 @@ class MrpWorkorder(models.Model):
             rounding = order.production_id.product_uom_id.rounding
             order.is_produced = float_compare(order.qty_produced, order.production_id.product_qty, precision_rounding=rounding) >= 0
 
+    @api.depends('operation_id', 'workcenter_id', 'qty_production')
+    def _compute_duration_expected(self):
+        for workorder in self:
+            if workorder.state not in ['done', 'cancel']:
+                workorder.duration_expected = workorder._get_duration_expected()
+
     @api.depends('time_ids.duration', 'qty_produced')
     def _compute_duration(self):
         for order in self:
             order.duration = sum(order.time_ids.mapped('duration'))
             order.duration_unit = round(order.duration / max(order.qty_produced, 1), 2)  # rounding 2 because it is a time
             if order.duration_expected:
-                order.duration_percent = 100 * (order.duration_expected - order.duration) / order.duration_expected
+                order.duration_percent = max(-2147483648, min(2147483647, 100 * (order.duration_expected - order.duration) / order.duration_expected))
             else:
                 order.duration_percent = 0
 
@@ -283,23 +320,32 @@ class MrpWorkorder(models.Model):
             return minutes * 60 + seconds
 
         for order in self:
-            old_order_duation = sum(order.time_ids.mapped('duration'))
+            old_order_duration = sum(order.time_ids.mapped('duration'))
             new_order_duration = order.duration
-            if new_order_duration == old_order_duation:
+            if new_order_duration == old_order_duration:
                 continue
 
-            delta_duration = new_order_duration - old_order_duation
+            delta_duration = new_order_duration - old_order_duration
 
             if delta_duration > 0:
-                date_start = datetime.now() - timedelta(seconds=_float_duration_to_second(delta_duration))
-                self.env['mrp.workcenter.productivity'].create(
-                    order._prepare_timeline_vals(delta_duration, date_start, datetime.now())
-                )
+                enddate = datetime.now()
+                date_start = enddate - timedelta(seconds=_float_duration_to_second(delta_duration))
+                if order.duration_expected >= new_order_duration or old_order_duration >= order.duration_expected:
+                    # either only productive or only performance (i.e. reduced speed) time respectively
+                    self.env['mrp.workcenter.productivity'].create(
+                        order._prepare_timeline_vals(new_order_duration, date_start, enddate)
+                    )
+                else:
+                    # split between productive and performance (i.e. reduced speed) times
+                    maxdate = fields.Datetime.from_string(enddate) - relativedelta(minutes=new_order_duration - order.duration_expected)
+                    self.env['mrp.workcenter.productivity'].create([
+                        order._prepare_timeline_vals(order.duration_expected, date_start, maxdate),
+                        order._prepare_timeline_vals(new_order_duration, maxdate, enddate)
+                    ])
             else:
                 duration_to_remove = abs(delta_duration)
-                timelines = order.time_ids.sorted(lambda t: t.date_start)
                 timelines_to_unlink = self.env['mrp.workcenter.productivity']
-                for timeline in timelines:
+                for timeline in order.time_ids.sorted():
                     if duration_to_remove <= 0.0:
                         break
                     if timeline.duration <= duration_to_remove:
@@ -337,40 +383,52 @@ class MrpWorkorder(models.Model):
                 order.is_user_working = False
 
     def _compute_scrap_move_count(self):
-        data = self.env['stock.scrap'].read_group([('workorder_id', 'in', self.ids)], ['workorder_id'], ['workorder_id'])
-        count_data = dict((item['workorder_id'][0], item['workorder_id_count']) for item in data)
+        data = self.env['stock.scrap']._read_group([('workorder_id', 'in', self.ids)], ['workorder_id'], ['__count'])
+        count_data = {workorder.id: count for workorder, count in data}
         for workorder in self:
             workorder.scrap_count = count_data.get(workorder.id, 0)
 
-    @api.onchange('date_planned_finished')
-    def _onchange_date_planned_finished(self):
-        if self.date_planned_start and self.date_planned_finished:
-            interval = self.workcenter_id.resource_calendar_id.get_work_duration_data(
-                self.date_planned_start, self.date_planned_finished,
-                domain=[('time_type', 'in', ['leave', 'other'])]
-            )
-            self.duration_expected = interval['hours'] * 60
-
     @api.onchange('operation_id')
     def _onchange_operation_id(self):
         if self.operation_id:
             self.name = self.operation_id.name
             self.workcenter_id = self.operation_id.workcenter_id.id
 
-    @api.onchange('date_planned_start', 'duration_expected')
-    def _onchange_date_planned_start(self):
-        if self.date_planned_start and self.duration_expected:
-            self.date_planned_finished = self.workcenter_id.resource_calendar_id.plan_hours(
-                self.duration_expected / 60.0, self.date_planned_start,
-                compute_leaves=True, domain=[('time_type', 'in', ['leave', 'other'])]
-            )
+    @api.onchange('date_start', 'duration_expected', 'workcenter_id')
+    def _onchange_date_start(self):
+        if self.date_start and self.workcenter_id:
+            self.date_finished = self._calculate_date_finished()
 
-    @api.onchange('operation_id', 'workcenter_id', 'qty_production')
-    def _onchange_expected_duration(self):
-        self.duration_expected = self._get_duration_expected()
+    def _calculate_date_finished(self, date_finished=False):
+        return self.workcenter_id.resource_calendar_id.plan_hours(
+            self.duration_expected / 60.0, date_finished or self.date_start,
+            compute_leaves=True, domain=[('time_type', 'in', ['leave', 'other'])]
+        )
+
+    @api.onchange('date_finished')
+    def _onchange_date_finished(self):
+        if self.date_start and self.date_finished and self.workcenter_id:
+            self.duration_expected = self._calculate_duration_expected()
+        if not self.date_finished and self.date_start:
+            raise UserError(_("It is not possible to unplan one single Work Order. "
+                              "You should unplan the Manufacturing Order instead in order to unplan all the linked operations."))
+
+    def _calculate_duration_expected(self, date_start=False, date_finished=False):
+        interval = self.workcenter_id.resource_calendar_id.get_work_duration_data(
+            date_start or self.date_start, date_finished or self.date_finished,
+            domain=[('time_type', 'in', ['leave', 'other'])]
+        )
+        return interval['hours'] * 60
+
+    @api.onchange('finished_lot_id')
+    def _onchange_finished_lot_id(self):
+        if self.production_id:
+            res = self.production_id._can_produce_serial_number(sn=self.finished_lot_id)
+            if res is not True:
+                return res
 
     def write(self, values):
-        if 'production_id' in values:
+        if 'production_id' in values and any(values['production_id'] != w.production_id.id for w in self):
             raise UserError(_('You cannot link this work order to another manufacturing order.'))
         if 'workcenter_id' in values:
             for workorder in self:
@@ -378,23 +436,33 @@ class MrpWorkorder(models.Model):
                     if workorder.state in ('progress', 'done', 'cancel'):
                         raise UserError(_('You cannot change the workcenter of a work order that is in progress or done.'))
                     workorder.leave_id.resource_id = self.env['mrp.workcenter'].browse(values['workcenter_id']).resource_id
-        if 'date_planned_start' in values or 'date_planned_finished' in values:
+                    workorder.duration_expected = workorder._get_duration_expected()
+                    if workorder.date_start:
+                        workorder.date_finished = workorder._calculate_date_finished()
+        if 'date_start' in values or 'date_finished' in values:
             for workorder in self:
-                start_date = fields.Datetime.to_datetime(values.get('date_planned_start')) or workorder.date_planned_start
-                end_date = fields.Datetime.to_datetime(values.get('date_planned_finished')) or workorder.date_planned_finished
-                if start_date and end_date and start_date > end_date:
+                date_start = fields.Datetime.to_datetime(values.get('date_start', workorder.date_start))
+                date_finished = fields.Datetime.to_datetime(values.get('date_finished', workorder.date_finished))
+                if date_start and date_finished and date_start > date_finished:
                     raise UserError(_('The planned end date of the work order cannot be prior to the planned start date, please correct this to save the work order.'))
+                if 'duration_expected' not in values and not self.env.context.get('bypass_duration_calculation'):
+                    if values.get('date_start') and values.get('date_finished'):
+                        computed_finished_time = workorder._calculate_date_finished(date_start)
+                        values['date_finished'] = computed_finished_time
+                    elif date_start and date_finished:
+                        computed_duration = workorder._calculate_duration_expected(date_start=date_start, date_finished=date_finished)
+                        values['duration_expected'] = computed_duration
                 # Update MO dates if the start date of the first WO or the
                 # finished date of the last WO is update.
-                if workorder == workorder.production_id.workorder_ids[0] and 'date_planned_start' in values:
-                    if values['date_planned_start']:
+                if workorder == workorder.production_id.workorder_ids[0] and 'date_start' in values:
+                    if values['date_start']:
                         workorder.production_id.with_context(force_date=True).write({
-                            'date_planned_start': fields.Datetime.to_datetime(values['date_planned_start'])
+                            'date_start': fields.Datetime.to_datetime(values['date_start'])
                         })
-                if workorder == workorder.production_id.workorder_ids[-1] and 'date_planned_finished' in values:
-                    if values['date_planned_finished']:
+                if workorder == workorder.production_id.workorder_ids[-1] and 'date_finished' in values:
+                    if values['date_finished']:
                         workorder.production_id.with_context(force_date=True).write({
-                            'date_planned_finished': fields.Datetime.to_datetime(values['date_planned_finished'])
+                            'date_finished': fields.Datetime.to_datetime(values['date_finished'])
                         })
         return super(MrpWorkorder, self).write(values)
 
@@ -404,64 +472,84 @@ class MrpWorkorder(models.Model):
         # Auto-confirm manually added workorders.
         # We need to go through `_action_confirm` for all workorders of the current productions to
         # make sure the links between them are correct.
+        if self.env.context.get('skip_confirm'):
+            return res
         to_confirm = res.filtered(lambda wo: wo.production_id.state in ("confirmed", "progress", "to_close"))
         to_confirm = to_confirm.production_id.workorder_ids
         to_confirm._action_confirm()
         return res
 
     def _action_confirm(self):
-        workorders_by_production = defaultdict(lambda: self.env['mrp.workorder'])
-        for workorder in self:
-            workorders_by_production[workorder.production_id] |= workorder
-
-        for production, workorders in workorders_by_production.items():
-            workorders_by_bom = defaultdict(lambda: self.env['mrp.workorder'])
-            bom = self.env['mrp.bom']
-            moves = production.move_raw_ids | production.move_finished_ids
-
-            for workorder in self:
-                if workorder.operation_id.bom_id:
-                    bom = workorder.operation_id.bom_id
-                if not bom:
-                    bom = workorder.production_id.bom_id
-                previous_workorder = workorders_by_bom[bom][-1:]
-                previous_workorder.next_work_order_id = workorder.id
-                workorders_by_bom[bom] |= workorder
-
-                moves.filtered(lambda m: m.operation_id == workorder.operation_id).write({
-                    'workorder_id': workorder.id
-                })
-
-            exploded_boms, dummy = production.bom_id.explode(production.product_id, 1, picking_type=production.bom_id.picking_type_id)
-            exploded_boms = {b[0]: b[1] for b in exploded_boms}
-            for move in moves:
-                if move.workorder_id:
-                    continue
-                bom = move.bom_line_id.bom_id
-                while bom and bom not in workorders_by_bom:
-                    bom_data = exploded_boms.get(bom, {})
-                    bom = bom_data.get('parent_line') and bom_data['parent_line'].bom_id or False
-                if bom in workorders_by_bom:
-                    move.write({
-                        'workorder_id': workorders_by_bom[bom][-1:].id
-                    })
-                else:
-                    move.write({
-                        'workorder_id': workorders_by_bom[production.bom_id][-1:].id
-                    })
-
-            for workorders in workorders_by_bom.values():
-                if workorders[0].state == 'pending':
-                    workorders[0].state = 'ready'
-                for workorder in workorders:
-                    workorder._start_nextworkorder()
+        for production in self.mapped("production_id"):
+            production._link_workorders_and_moves()
 
     def _get_byproduct_move_to_update(self):
         return self.production_id.move_finished_ids.filtered(lambda x: (x.product_id.id != self.production_id.product_id.id) and (x.state not in ('done', 'cancel')))
 
-    def _start_nextworkorder(self):
-        if self.state == 'done' and self.next_work_order_id.state == 'pending':
-            self.next_work_order_id.state = 'ready'
+    def _plan_workorder(self, replan=False):
+        self.ensure_one()
+        # Plan workorder after its predecessors
+        date_start = max(self.production_id.date_start, datetime.now())
+        for workorder in self.blocked_by_workorder_ids:
+            if workorder.state in ['done', 'cancel']:
+                continue
+            workorder._plan_workorder(replan)
+            if workorder.date_finished and workorder.date_finished > date_start:
+                date_start = workorder.date_finished
+        # Plan only suitable workorders
+        if self.state not in ['pending', 'waiting', 'ready']:
+            return
+        if self.leave_id:
+            if replan:
+                self.leave_id.unlink()
+            else:
+                return
+        # Consider workcenter and alternatives
+        workcenters = self.workcenter_id | self.workcenter_id.alternative_workcenter_ids
+        best_date_finished = datetime.max
+        vals = {}
+        for workcenter in workcenters:
+            if not workcenter.resource_calendar_id:
+                raise UserError(_('There is no defined calendar on workcenter %s.', workcenter.name))
+            # Compute theoretical duration
+            if self.workcenter_id == workcenter:
+                duration_expected = self.duration_expected
+            else:
+                duration_expected = self._get_duration_expected(alternative_workcenter=workcenter)
+            from_date, to_date = workcenter._get_first_available_slot(date_start, duration_expected)
+            # If the workcenter is unavailable, try planning on the next one
+            if not from_date:
+                continue
+            # Check if this workcenter is better than the previous ones
+            if to_date and to_date < best_date_finished:
+                best_date_start = from_date
+                best_date_finished = to_date
+                best_workcenter = workcenter
+                vals = {
+                    'workcenter_id': workcenter.id,
+                    'duration_expected': duration_expected,
+                }
+        # If none of the workcenter are available, raise
+        if best_date_finished == datetime.max:
+            raise UserError(_('Impossible to plan the workorder. Please check the workcenter availabilities.'))
+        # Create leave on chosen workcenter calendar
+        leave = self.env['resource.calendar.leaves'].create({
+            'name': self.display_name,
+            'calendar_id': best_workcenter.resource_calendar_id.id,
+            'date_from': best_date_start,
+            'date_to': best_date_finished,
+            'resource_id': best_workcenter.resource_id.id,
+            'time_type': 'other'
+        })
+        vals['leave_id'] = leave.id
+        self.write(vals)
+
+    def _cal_cost(self):
+        total = 0
+        for wo in self:
+            duration = sum(wo.time_ids.mapped('duration'))
+            total += (duration / 60.0) * wo.workcenter_id.costs_hour
+        return total
 
     @api.model
     def gantt_unavailability(self, start_date, end_date, scale, group_bys=None, rows=None):
@@ -486,15 +574,11 @@ class MrpWorkorder(models.Model):
         workcenters = self.env['mrp.workcenter'].browse(workcenter_ids)
         unavailability_mapping = workcenters._get_unavailability_intervals(start_datetime, end_datetime)
 
-        # Only notable interval (more than one case) is send to the front-end (avoid sending useless information)
-        cell_dt = (scale in ['day', 'week'] and timedelta(hours=1)) or (scale == 'month' and timedelta(days=1)) or timedelta(days=28)
-
         def add_unavailability(row, workcenter_id=None):
             if row.get('groupedBy') and row.get('groupedBy')[0] == 'workcenter_id' and row.get('resId'):
                 workcenter_id = row.get('resId')
             if workcenter_id:
-                notable_intervals = filter(lambda interval: interval[1] - interval[0] >= cell_dt, unavailability_mapping[workcenter_id])
-                row['unavailabilities'] = [{'start': interval[0], 'stop': interval[1]} for interval in notable_intervals]
+                row['unavailabilities'] = [{'start': interval[0], 'stop': interval[1]} for interval in unavailability_mapping[workcenter_id]]
                 return {'workcenter_id': workcenter_id}
 
         for row in rows:
@@ -502,64 +586,72 @@ class MrpWorkorder(models.Model):
         return rows
 
     def button_start(self):
-        self.ensure_one()
-        # As button_start is automatically called in the new view
-        if self.state in ('done', 'cancel'):
-            return True
+        if any(wo.working_state == 'blocked' for wo in self):
+            raise UserError(_('Please unblock the work center to start the work order.'))
+        for wo in self:
+            if any(not time.date_end for time in wo.time_ids.filtered(lambda t: t.user_id.id == self.env.user.id)):
+                continue
+            # As button_start is automatically called in the new view
+            if wo.state in ('done', 'cancel'):
+                continue
 
-        if self.product_tracking == 'serial':
-            self.qty_producing = 1.0
+            if wo.product_tracking == 'serial' and wo.qty_producing == 0:
+                wo.qty_producing = 1.0
+            elif wo.qty_producing == 0:
+                wo.qty_producing = wo.qty_remaining
 
-        self.env['mrp.workcenter.productivity'].create(
-            self._prepare_timeline_vals(self.duration, datetime.now())
-        )
-        if self.production_id.state != 'progress':
-            self.production_id.write({
-                'date_start': datetime.now(),
-            })
-        if self.state == 'progress':
-            return True
-        start_date = datetime.now()
-        vals = {
-            'state': 'progress',
-            'date_start': start_date,
-        }
-        if not self.leave_id:
-            leave = self.env['resource.calendar.leaves'].create({
-                'name': self.display_name,
-                'calendar_id': self.workcenter_id.resource_calendar_id.id,
-                'date_from': start_date,
-                'date_to': start_date + relativedelta(minutes=self.duration_expected),
-                'resource_id': self.workcenter_id.resource_id.id,
-                'time_type': 'other'
-            })
-            vals['leave_id'] = leave.id
-            return self.write(vals)
-        else:
-            if self.date_planned_start > start_date:
-                vals['date_planned_start'] = start_date
-            if self.date_planned_finished and self.date_planned_finished < start_date:
-                vals['date_planned_finished'] = start_date
-            return self.write(vals)
+            if wo._should_start_timer():
+                self.env['mrp.workcenter.productivity'].create(
+                    wo._prepare_timeline_vals(wo.duration, fields.Datetime.now())
+                )
+
+            if wo.production_id.state != 'progress':
+                wo.production_id.write({
+                    'date_start': fields.Datetime.now()
+                })
+            if wo.state == 'progress':
+                continue
+            date_start = fields.Datetime.now()
+            vals = {
+                'state': 'progress',
+                'date_start': date_start,
+            }
+            if not wo.leave_id:
+                leave = self.env['resource.calendar.leaves'].create({
+                    'name': wo.display_name,
+                    'calendar_id': wo.workcenter_id.resource_calendar_id.id,
+                    'date_from': date_start,
+                    'date_to': date_start + relativedelta(minutes=wo.duration_expected),
+                    'resource_id': wo.workcenter_id.resource_id.id,
+                    'time_type': 'other'
+                })
+                vals['date_finished'] = leave.date_to
+                vals['leave_id'] = leave.id
+                wo.write(vals)
+            else:
+                if not wo.date_start or wo.date_start > date_start:
+                    vals['date_start'] = date_start
+                    vals['date_finished'] = wo._calculate_date_finished(date_start)
+                if wo.date_finished and wo.date_finished < date_start:
+                    vals['date_finished'] = date_start
+                wo.with_context(bypass_duration_calculation=True).write(vals)
+        return True
 
     def button_finish(self):
-        end_date = datetime.now()
+        date_finished = fields.Datetime.now()
         for workorder in self:
             if workorder.state in ('done', 'cancel'):
                 continue
             workorder.end_all()
             vals = {
+                'qty_produced': workorder.qty_produced or workorder.qty_producing or workorder.qty_production,
                 'state': 'done',
-                'date_finished': end_date,
-                'date_planned_finished': end_date
+                'date_finished': date_finished,
+                'costs_hour': workorder.workcenter_id.costs_hour
             }
-            if not workorder.date_start:
-                vals['date_start'] = end_date
-            if not workorder.date_planned_start or end_date < workorder.date_planned_start:
-                vals['date_planned_start'] = end_date
-            workorder.write(vals)
-
-            workorder._start_nextworkorder()
+            if not workorder.date_start or date_finished < workorder.date_start:
+                vals['date_start'] = date_finished
+            workorder.with_context(bypass_duration_calculation=True).write(vals)
         return True
 
     def end_previous(self, doall=False):
@@ -568,30 +660,10 @@ class MrpWorkorder(models.Model):
         only the one of the current user
         """
         # TDE CLEANME
-        timeline_obj = self.env['mrp.workcenter.productivity']
         domain = [('workorder_id', 'in', self.ids), ('date_end', '=', False)]
         if not doall:
             domain.append(('user_id', '=', self.env.user.id))
-        not_productive_timelines = timeline_obj.browse()
-        for timeline in timeline_obj.search(domain, limit=None if doall else 1):
-            wo = timeline.workorder_id
-            if wo.duration_expected <= wo.duration:
-                if timeline.loss_type == 'productive':
-                    not_productive_timelines += timeline
-                timeline.write({'date_end': fields.Datetime.now()})
-            else:
-                maxdate = fields.Datetime.from_string(timeline.date_start) + relativedelta(minutes=wo.duration_expected - wo.duration)
-                enddate = datetime.now()
-                if maxdate > enddate:
-                    timeline.write({'date_end': enddate})
-                else:
-                    timeline.write({'date_end': maxdate})
-                    not_productive_timelines += timeline.copy({'date_start': maxdate, 'date_end': enddate})
-        if not_productive_timelines:
-            loss_id = self.env['mrp.workcenter.productivity.loss'].search([('loss_type', '=', 'performance')], limit=1)
-            if not len(loss_id):
-                raise UserError(_("You need to define at least one unactive productivity loss in the category 'Performance'. Create one from the Manufacturing app, menu: Configuration / Productivity Losses."))
-            not_productive_timelines.write({'loss_id': loss_id.id})
+        self.env['mrp.workcenter.productivity'].search(domain, limit=None if doall else 1)._close()
         return True
 
     def end_all(self):
@@ -608,6 +680,7 @@ class MrpWorkorder(models.Model):
 
     def action_cancel(self):
         self.leave_id.unlink()
+        self.end_all()
         return self.write({'state': 'cancel'})
 
     def action_replan(self):
@@ -628,16 +701,16 @@ class MrpWorkorder(models.Model):
         return self.write({
             'state': 'done',
             'date_finished': end_date,
-            'date_planned_finished': end_date,
+            'costs_hour': self.workcenter_id.costs_hour
         })
 
     def button_scrap(self):
         self.ensure_one()
         return {
-            'name': _('Scrap'),
+            'name': _('Scrap Products'),
             'view_mode': 'form',
             'res_model': 'stock.scrap',
-            'view_id': self.env.ref('stock.stock_scrap_form_view2').id,
+            'views': [(self.env.ref('stock.stock_scrap_form_view2').id, 'form')],
             'type': 'ir.actions.act_window',
             'context': {'default_company_id': self.production_id.company_id.id,
                         'default_workorder_id': self.id,
@@ -658,10 +731,13 @@ class MrpWorkorder(models.Model):
         action['res_id'] = self.id
         return action
 
-    @api.depends('qty_production', 'qty_produced')
+    @api.depends('qty_production', 'qty_reported_from_previous_wo', 'qty_produced', 'production_id.product_uom_id')
     def _compute_qty_remaining(self):
         for wo in self:
-            wo.qty_remaining = float_round(wo.qty_production - wo.qty_produced, precision_rounding=wo.production_id.product_uom_id.rounding)
+            if wo.production_id.product_uom_id:
+                wo.qty_remaining = max(float_round(wo.qty_production - wo.qty_reported_from_previous_wo - wo.qty_produced, precision_rounding=wo.production_id.product_uom_id.rounding), 0)
+            else:
+                wo.qty_remaining = 0
 
     def _get_duration_expected(self, alternative_workcenter=False, ratio=1):
         self.ensure_one()
@@ -671,17 +747,20 @@ class MrpWorkorder(models.Model):
             duration_expected_working = (self.duration_expected - self.workcenter_id.time_start - self.workcenter_id.time_stop) * self.workcenter_id.time_efficiency / 100.0
             if duration_expected_working < 0:
                 duration_expected_working = 0
-            return self.workcenter_id.time_start + self.workcenter_id.time_stop + duration_expected_working * ratio * 100.0 / self.workcenter_id.time_efficiency
+            return self.workcenter_id._get_expected_duration(self.product_id) + duration_expected_working * ratio * 100.0 / self.workcenter_id.time_efficiency
         qty_production = self.production_id.product_uom_id._compute_quantity(self.qty_production, self.production_id.product_id.uom_id)
-        cycle_number = float_round(qty_production / self.workcenter_id.capacity, precision_digits=0, rounding_method='UP')
+        capacity = self.workcenter_id._get_capacity(self.product_id)
+        cycle_number = float_round(qty_production / capacity, precision_digits=0, rounding_method='UP')
         if alternative_workcenter:
             # TODO : find a better alternative : the settings of workcenter can change
             duration_expected_working = (self.duration_expected - self.workcenter_id.time_start - self.workcenter_id.time_stop) * self.workcenter_id.time_efficiency / (100.0 * cycle_number)
             if duration_expected_working < 0:
                 duration_expected_working = 0
-            return alternative_workcenter.time_start + alternative_workcenter.time_stop + cycle_number * duration_expected_working * 100.0 / alternative_workcenter.time_efficiency
-        time_cycle = self.operation_id and self.operation_id.time_cycle or 60.0
-        return self.workcenter_id.time_start + self.workcenter_id.time_stop + cycle_number * time_cycle * 100.0 / self.workcenter_id.time_efficiency
+            capacity = alternative_workcenter._get_capacity(self.product_id)
+            alternative_wc_cycle_nb = float_round(qty_production / capacity, precision_digits=0, rounding_method='UP')
+            return alternative_workcenter._get_expected_duration(self.product_id) + alternative_wc_cycle_nb * duration_expected_working * 100.0 / alternative_workcenter.time_efficiency
+        time_cycle = self.operation_id.time_cycle
+        return self.workcenter_id._get_expected_duration(self.product_id) + cycle_number * time_cycle * 100.0 / self.workcenter_id.time_efficiency
 
     def _get_conflicted_workorder_ids(self):
         """Get conlicted workorder(s) with self.
@@ -690,18 +769,18 @@ class MrpWorkorder(models.Model):
 
         :return: defaultdict with key as workorder id of self and value as related conflicted workorder
         """
-        self.flush(['state', 'date_planned_start', 'date_planned_finished', 'workcenter_id'])
+        self.flush_model(['state', 'date_start', 'date_finished', 'workcenter_id'])
         sql = """
             SELECT wo1.id, wo2.id
             FROM mrp_workorder wo1, mrp_workorder wo2
             WHERE
                 wo1.id IN %s
-                AND wo1.state IN ('pending','ready')
-                AND wo2.state IN ('pending','ready')
+                AND wo1.state IN ('pending', 'waiting', 'ready')
+                AND wo2.state IN ('pending', 'waiting', 'ready')
                 AND wo1.id != wo2.id
                 AND wo1.workcenter_id = wo2.workcenter_id
-                AND (DATE_TRUNC('second', wo2.date_planned_start), DATE_TRUNC('second', wo2.date_planned_finished))
-                    OVERLAPS (DATE_TRUNC('second', wo1.date_planned_start), DATE_TRUNC('second', wo1.date_planned_finished))
+                AND (DATE_TRUNC('second', wo2.date_start), DATE_TRUNC('second', wo2.date_finished))
+                    OVERLAPS (DATE_TRUNC('second', wo1.date_start), DATE_TRUNC('second', wo1.date_finished))
         """
         self.env.cr.execute(sql, [tuple(self.ids)])
         res = defaultdict(list)
@@ -709,23 +788,21 @@ class MrpWorkorder(models.Model):
             res[wo1].append(wo2)
         return res
 
-    @api.model
-    def _prepare_component_quantity(self, move, qty_producing):
-        """ helper that computes quantity to consume (or to create in case of byproduct)
-        depending on the quantity producing and the move's unit factor"""
-        if move.product_id.tracking == 'serial':
-            uom = move.product_id.uom_id
-        else:
-            uom = move.product_uom
-        return move.product_uom._compute_quantity(
-            qty_producing * move.unit_factor,
-            uom,
-            round=False
-        )
+    def _get_operation_values(self):
+        self.ensure_one()
+        ratio = 1 / self.qty_production
+        if self.operation_id.bom_id:
+            ratio = self.production_id._get_ratio_between_mo_and_bom_quantities(self.operation_id.bom_id)
+        return {
+            'company_id': self.company_id.id,
+            'name': self.name,
+            'time_cycle_manual': self.duration_expected * ratio,
+            'workcenter_id': self.workcenter_id.id,
+        }
 
     def _prepare_timeline_vals(self, duration, date_start, date_end=False):
         # Need a loss in case of the real time exceeding the expected
-        if not self.duration_expected or duration < self.duration_expected:
+        if not self.duration_expected or duration <= self.duration_expected:
             loss_id = self.env['mrp.workcenter.productivity.loss'].search([('loss_type', '=', 'productive')], limit=1)
             if not len(loss_id):
                 raise UserError(_("You need to define at least one productivity loss in the category 'Productivity'. Create one from the Manufacturing app, menu: Configuration / Productivity Losses."))
@@ -738,8 +815,8 @@ class MrpWorkorder(models.Model):
             'workcenter_id': self.workcenter_id.id,
             'description': _('Time Tracking: %(user)s', user=self.env.user.name),
             'loss_id': loss_id[0].id,
-            'date_start': date_start,
-            'date_end': date_end,
+            'date_start': date_start.replace(microsecond=0),
+            'date_end': date_end.replace(microsecond=0) if date_end else date_end,
             'user_id': self.env.user.id,  # FIXME sle: can be inconsistent with company_id
             'company_id': self.company_id.id,
         }
@@ -763,39 +840,55 @@ class MrpWorkorder(models.Model):
             if move_line:
                 if self.product_id.tracking == 'serial':
                     raise UserError(_('You cannot produce the same serial number twice.'))
-                move_line.product_uom_qty += self.qty_producing
-                move_line.qty_done += self.qty_producing
+                move_line.picked = True
+                move_line.quantity += self.qty_producing
             else:
-                location_dest_id = production_move.location_dest_id._get_putaway_strategy(self.product_id).id or production_move.location_dest_id.id
+                quantity = self.product_uom_id._compute_quantity(self.qty_producing, self.product_id.uom_id, rounding_method='HALF-UP')
+                putaway_location = production_move.location_dest_id._get_putaway_strategy(self.product_id, quantity)
                 move_line.create({
                     'move_id': production_move.id,
                     'product_id': production_move.product_id.id,
                     'lot_id': self.finished_lot_id.id,
-                    'product_uom_qty': self.qty_producing,
                     'product_uom_id': self.product_uom_id.id,
-                    'qty_done': self.qty_producing,
+                    'quantity': self.qty_producing,
                     'location_id': production_move.location_id.id,
-                    'location_dest_id': location_dest_id,
+                    'location_dest_id': putaway_location.id,
                 })
         else:
             rounding = production_move.product_uom.rounding
-            production_move._set_quantity_done(
-                float_round(self.qty_producing, precision_rounding=rounding)
-            )
+            production_move.quantity = float_round(self.qty_producing, precision_rounding=rounding)
 
-    def _check_sn_uniqueness(self):
-        """ Alert the user if the serial number as already been produced """
-        if self.product_tracking == 'serial' and self.finished_lot_id:
-            sml = self.env['stock.move.line'].search_count([
-                ('lot_id', '=', self.finished_lot_id.id),
-                ('location_id.usage', '=', 'production'),
-                ('qty_done', '=', 1),
-                ('state', '=', 'done')
-            ])
-            if sml:
-                raise UserError(_('This serial number for product %s has already been produced', self.product_id.name))
+    def _should_start_timer(self):
+        return True
 
     def _update_qty_producing(self, quantity):
         self.ensure_one()
         if self.qty_producing:
             self.qty_producing = quantity
+
+    def get_working_duration(self):
+        """Get the additional duration for 'open times' i.e. productivity lines with no date_end."""
+        self.ensure_one()
+        duration = 0
+        for time in self.time_ids.filtered(lambda time: not time.date_end):
+            duration += (datetime.now() - time.date_start).total_seconds() / 60
+        return duration
+
+    def get_duration(self):
+        self.ensure_one()
+        return sum(self.time_ids.mapped('duration')) + self.get_working_duration()
+
+    def action_mark_as_done(self):
+        for wo in self:
+            if wo.working_state == 'blocked':
+                raise UserError(_('Please unblock the work center to validate the work order'))
+            wo.button_finish()
+            if wo.duration == 0.0:
+                wo.duration = wo.duration_expected
+                wo.duration_percent = 100
+
+    def _compute_expected_operation_cost(self):
+        return (self.duration_expected / 60.0) * self.workcenter_id.costs_hour
+
+    def _compute_current_operation_cost(self):
+        return (self.get_duration() / 60.0) * self.workcenter_id.costs_hour

--- a/addons/mrp/models/product.py
+++ b/addons/mrp/models/product.py
@@ -1,11 +1,24 @@
 # -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
+import collections
 from datetime import timedelta
-from odoo import api, fields, models
+from itertools import groupby
+import operator as py_operator
+from odoo import fields, models, _
+from odoo.tools import groupby
 from odoo.tools.float_utils import float_round, float_is_zero
 
 
+OPERATORS = {
+    '<': py_operator.lt,
+    '>': py_operator.gt,
+    '<=': py_operator.le,
+    '>=': py_operator.ge,
+    '=': py_operator.eq,
+    '!=': py_operator.ne
+}
+
 class ProductTemplate(models.Model):
     _inherit = "product.template"
 
@@ -15,20 +28,32 @@ class ProductTemplate(models.Model):
         compute='_compute_bom_count', compute_sudo=False)
     used_in_bom_count = fields.Integer('# of BoM Where is Used',
         compute='_compute_used_in_bom_count', compute_sudo=False)
-    mrp_product_qty = fields.Float('Manufactured',
+    mrp_product_qty = fields.Float('Manufactured', digits='Product Unit of Measure',
         compute='_compute_mrp_product_qty', compute_sudo=False)
-    produce_delay = fields.Float(
-        'Manufacturing Lead Time', default=0.0,
-        help="Average lead time in days to manufacture this product. In the case of multi-level BOM, the manufacturing lead times of the components will be added.")
+    is_kits = fields.Boolean(compute='_compute_is_kits', compute_sudo=False)
 
     def _compute_bom_count(self):
         for product in self:
-            product.bom_count = self.env['mrp.bom'].search_count([('product_tmpl_id', '=', product.id)])
+            product.bom_count = self.env['mrp.bom'].search_count(['|', ('product_tmpl_id', '=', product.id), ('byproduct_ids.product_id.product_tmpl_id', '=', product.id)])
+
+    def _compute_is_kits(self):
+        domain = [('product_tmpl_id', 'in', self.ids), ('type', '=', 'phantom')]
+        bom_mapping = self.env['mrp.bom'].search_read(domain, ['product_tmpl_id'])
+        kits_ids = set(b['product_tmpl_id'][0] for b in bom_mapping)
+        for template in self:
+            template.is_kits = (template.id in kits_ids)
+
+    def _compute_show_qty_status_button(self):
+        super()._compute_show_qty_status_button()
+        for template in self:
+            if template.is_kits:
+                template.show_on_hand_qty_status_button = template.product_variant_count <= 1
+                template.show_forecasted_qty_status_button = False
 
     def _compute_used_in_bom_count(self):
         for template in self:
             template.used_in_bom_count = self.env['mrp.bom'].search_count(
-                [('bom_line_ids.product_id', 'in', template.product_variant_ids.ids)])
+                [('bom_line_ids.product_tmpl_id', '=', template.id)])
 
     def write(self, values):
         if 'active' in values:
@@ -40,7 +65,7 @@ class ProductTemplate(models.Model):
     def action_used_in_bom(self):
         self.ensure_one()
         action = self.env["ir.actions.actions"]._for_xml_id("mrp.mrp_bom_form_action")
-        action['domain'] = [('bom_line_ids.product_id', 'in', self.product_variant_ids.ids)]
+        action['domain'] = [('bom_line_ids.product_tmpl_id', '=', self.id)]
         return action
 
     def _compute_mrp_product_qty(self):
@@ -48,14 +73,33 @@ class ProductTemplate(models.Model):
             template.mrp_product_qty = float_round(sum(template.mapped('product_variant_ids').mapped('mrp_product_qty')), precision_rounding=template.uom_id.rounding)
 
     def action_view_mos(self):
-        action = self.env["ir.actions.actions"]._for_xml_id("mrp.mrp_production_report")
+        action = self.env["ir.actions.actions"]._for_xml_id("mrp.mrp_production_action")
         action['domain'] = [('state', '=', 'done'), ('product_tmpl_id', 'in', self.ids)]
         action['context'] = {
-            'graph_measure': 'product_uom_qty',
-            'time_ranges': {'field': 'date_planned_start', 'range': 'last_365_days'}
+            'search_default_filter_plan_date': 1,
         }
         return action
 
+    def action_archive(self):
+        filtered_products = self.env['mrp.bom.line'].search([('product_id', 'in', self.product_variant_ids.ids), ('bom_id.active', '=', True)]).product_id.mapped('display_name')
+        res = super().action_archive()
+        if filtered_products:
+            return {
+                'type': 'ir.actions.client',
+                'tag': 'display_notification',
+                'params': {
+                'title': _("Note that product(s): '%s' is/are still linked to active Bill of Materials, "
+                            "which means that the product can still be used on it/them.", filtered_products),
+                'type': 'warning',
+                'sticky': True,  #True/False will display for few seconds if false
+                'next': {'type': 'ir.actions.act_window_close'},
+                },
+            }
+        return res
+
+    def _get_backend_root_menu_ids(self):
+        return super()._get_backend_root_menu_ids() + [self.env.ref('mrp.menu_mrp_root').id]
+
 
 class ProductProduct(models.Model):
     _inherit = "product.product"
@@ -66,12 +110,36 @@ class ProductProduct(models.Model):
         compute='_compute_bom_count', compute_sudo=False)
     used_in_bom_count = fields.Integer('# BoM Where Used',
         compute='_compute_used_in_bom_count', compute_sudo=False)
-    mrp_product_qty = fields.Float('Manufactured',
+    mrp_product_qty = fields.Float('Manufactured', digits='Product Unit of Measure',
         compute='_compute_mrp_product_qty', compute_sudo=False)
+    is_kits = fields.Boolean(compute="_compute_is_kits", compute_sudo=False)
 
     def _compute_bom_count(self):
         for product in self:
-            product.bom_count = self.env['mrp.bom'].search_count(['|', ('product_id', '=', product.id), '&', ('product_id', '=', False), ('product_tmpl_id', '=', product.product_tmpl_id.id)])
+            product.bom_count = self.env['mrp.bom'].search_count(['|', '|', ('byproduct_ids.product_id', '=', product.id), ('product_id', '=', product.id), '&', ('product_id', '=', False), ('product_tmpl_id', '=', product.product_tmpl_id.id)])
+
+    def _compute_is_kits(self):
+        domain = ['&', ('type', '=', 'phantom'),
+                       '|', ('product_id', 'in', self.ids),
+                            '&', ('product_id', '=', False),
+                                 ('product_tmpl_id', 'in', self.product_tmpl_id.ids)]
+        bom_mapping = self.env['mrp.bom'].search_read(domain, ['product_tmpl_id', 'product_id'])
+        kits_template_ids = set([])
+        kits_product_ids = set([])
+        for bom_data in bom_mapping:
+            if bom_data['product_id']:
+                kits_product_ids.add(bom_data['product_id'][0])
+            else:
+                kits_template_ids.add(bom_data['product_tmpl_id'][0])
+        for product in self:
+            product.is_kits = (product.id in kits_product_ids or product.product_tmpl_id.id in kits_template_ids)
+
+    def _compute_show_qty_status_button(self):
+        super()._compute_show_qty_status_button()
+        for product in self:
+            if product.is_kits:
+                product.show_on_hand_qty_status_button = True
+                product.show_forecasted_qty_status_button = False
 
     def _compute_used_in_bom_count(self):
         for product in self:
@@ -88,7 +156,7 @@ class ProductProduct(models.Model):
         """ Return the components list ids in case of kit product.
         Return the product itself otherwise"""
         self.ensure_one()
-        bom_kit = self.env['mrp.bom']._bom_find(product=self, bom_type='phantom')
+        bom_kit = self.env['mrp.bom']._bom_find(self, bom_type='phantom')[self]
         if bom_kit:
             boms, bom_sub_lines = bom_kit.explode(self, 1)
             return [bom_line.product_id.id for bom_line, data in bom_sub_lines if bom_line.product_id.type == 'product']
@@ -104,9 +172,9 @@ class ProductProduct(models.Model):
     def _compute_mrp_product_qty(self):
         date_from = fields.Datetime.to_string(fields.datetime.now() - timedelta(days=365))
         #TODO: state = done?
-        domain = [('state', '=', 'done'), ('product_id', 'in', self.ids), ('date_planned_start', '>', date_from)]
-        read_group_res = self.env['mrp.production'].read_group(domain, ['product_id', 'product_uom_qty'], ['product_id'])
-        mapped_data = dict([(data['product_id'][0], data['product_uom_qty']) for data in read_group_res])
+        domain = [('state', '=', 'done'), ('product_id', 'in', self.ids), ('date_start', '>', date_from)]
+        read_group_res = self.env['mrp.production']._read_group(domain, ['product_id'], ['product_uom_qty:sum'])
+        mapped_data = {product.id: qty for product, qty in read_group_res}
         for product in self:
             if not product.id:
                 product.mrp_product_qty = 0.0
@@ -124,44 +192,75 @@ class ProductProduct(models.Model):
         This override is used to get the correct quantities of products
         with 'phantom' as BoM type.
         """
-        bom_kits = {
-            product: bom
-            for product in self
-            for bom in (self.env['mrp.bom']._bom_find(product=product, bom_type='phantom'),)
-            if bom
-        }
+        bom_kits = self.env['mrp.bom']._bom_find(self, bom_type='phantom')
         kits = self.filtered(lambda p: bom_kits.get(p))
-        res = super(ProductProduct, self - kits)._compute_quantities_dict(lot_id, owner_id, package_id, from_date=from_date, to_date=to_date)
+        regular_products = self - kits
+        res = (
+            super(ProductProduct, regular_products)._compute_quantities_dict(lot_id, owner_id, package_id, from_date=from_date, to_date=to_date)
+            if regular_products
+            else {}
+        )
+        qties = self.env.context.get("mrp_compute_quantities", {})
+        qties.update(res)
+        # pre-compute bom lines and identify missing kit components to prefetch
+        bom_sub_lines_per_kit = {}
+        prefetch_component_ids = set()
         for product in bom_kits:
-            boms, bom_sub_lines = bom_kits[product].explode(product, 1)
+            __, bom_sub_lines = bom_kits[product].explode(product, 1)
+            bom_sub_lines_per_kit[product] = bom_sub_lines
+            for bom_line, __ in bom_sub_lines:
+                if bom_line.product_id.id not in qties:
+                    prefetch_component_ids.add(bom_line.product_id.id)
+        # compute kit quantities
+        for product in bom_kits:
+            bom_sub_lines = bom_sub_lines_per_kit[product]
+            # group lines by component
+            bom_sub_lines_grouped = collections.defaultdict(list)
+            for info in bom_sub_lines:
+                bom_sub_lines_grouped[info[0].product_id].append(info)
             ratios_virtual_available = []
             ratios_qty_available = []
             ratios_incoming_qty = []
             ratios_outgoing_qty = []
             ratios_free_qty = []
-            for bom_line, bom_line_data in bom_sub_lines:
-                component = bom_line.product_id
-                if component.type != 'product' or float_is_zero(bom_line_data['qty'], precision_rounding=bom_line.product_uom_id.rounding):
-                    # As BoMs allow components with 0 qty, a.k.a. optionnal components, we simply skip those
-                    # to avoid a division by zero. The same logic is applied to non-storable products as those
-                    # products have 0 qty available.
-                    continue
-                uom_qty_per_kit = bom_line_data['qty'] / bom_line_data['original_qty']
-                qty_per_kit = bom_line.product_uom_id._compute_quantity(uom_qty_per_kit, bom_line.product_id.uom_id, raise_if_failure=False)
+
+            for component, bom_sub_lines in bom_sub_lines_grouped.items():
+                component = component.with_context(mrp_compute_quantities=qties).with_prefetch(prefetch_component_ids)
+                qty_per_kit = 0
+                for bom_line, bom_line_data in bom_sub_lines:
+                    if component.type != 'product' or float_is_zero(bom_line_data['qty'], precision_rounding=bom_line.product_uom_id.rounding):
+                        # As BoMs allow components with 0 qty, a.k.a. optionnal components, we simply skip those
+                        # to avoid a division by zero. The same logic is applied to non-storable products as those
+                        # products have 0 qty available.
+                        continue
+                    uom_qty_per_kit = bom_line_data['qty'] / bom_line_data['original_qty']
+                    qty_per_kit += bom_line.product_uom_id._compute_quantity(uom_qty_per_kit, bom_line.product_id.uom_id, round=False, raise_if_failure=False)
                 if not qty_per_kit:
                     continue
-                ratios_virtual_available.append(component.virtual_available / qty_per_kit)
-                ratios_qty_available.append(component.qty_available / qty_per_kit)
-                ratios_incoming_qty.append(component.incoming_qty / qty_per_kit)
-                ratios_outgoing_qty.append(component.outgoing_qty / qty_per_kit)
-                ratios_free_qty.append(component.free_qty / qty_per_kit)
+                rounding = component.uom_id.rounding
+                component_res = (
+                    qties.get(component.id)
+                    if component.id in qties
+                    else {
+                        "virtual_available": float_round(component.virtual_available, precision_rounding=rounding),
+                        "qty_available": float_round(component.qty_available, precision_rounding=rounding),
+                        "incoming_qty": float_round(component.incoming_qty, precision_rounding=rounding),
+                        "outgoing_qty": float_round(component.outgoing_qty, precision_rounding=rounding),
+                        "free_qty": float_round(component.free_qty, precision_rounding=rounding),
+                    }
+                )
+                ratios_virtual_available.append(component_res["virtual_available"] / qty_per_kit)
+                ratios_qty_available.append(component_res["qty_available"] / qty_per_kit)
+                ratios_incoming_qty.append(component_res["incoming_qty"] / qty_per_kit)
+                ratios_outgoing_qty.append(component_res["outgoing_qty"] / qty_per_kit)
+                ratios_free_qty.append(component_res["free_qty"] / qty_per_kit)
             if bom_sub_lines and ratios_virtual_available:  # Guard against all cnsumable bom: at least one ratio should be present.
                 res[product.id] = {
-                    'virtual_available': min(ratios_virtual_available) // 1,
-                    'qty_available': min(ratios_qty_available) // 1,
-                    'incoming_qty': min(ratios_incoming_qty) // 1,
-                    'outgoing_qty': min(ratios_outgoing_qty) // 1,
-                    'free_qty': min(ratios_free_qty) // 1,
+                    'virtual_available': min(ratios_virtual_available) * bom_kits[product].product_qty // 1,
+                    'qty_available': min(ratios_qty_available) * bom_kits[product].product_qty // 1,
+                    'incoming_qty': min(ratios_incoming_qty) * bom_kits[product].product_qty // 1,
+                    'outgoing_qty': min(ratios_outgoing_qty) * bom_kits[product].product_qty // 1,
+                    'free_qty': min(ratios_free_qty) * bom_kits[product].product_qty // 1,
                 }
             else:
                 res[product.id] = {
@@ -177,12 +276,12 @@ class ProductProduct(models.Model):
     def action_view_bom(self):
         action = self.env["ir.actions.actions"]._for_xml_id("mrp.product_open_bom")
         template_ids = self.mapped('product_tmpl_id').ids
-        # bom specific to this variant or global to template
+        # bom specific to this variant or global to template or that contains the product as a byproduct
         action['context'] = {
             'default_product_tmpl_id': template_ids[0],
-            'default_product_id': self.ids[0],
+            'default_product_id': self.env.user.has_group('product.group_product_variant') and self.ids[0] or False,
         }
-        action['domain'] = ['|', ('product_id', 'in', self.ids), '&', ('product_id', '=', False), ('product_tmpl_id', 'in', template_ids)]
+        action['domain'] = ['|', '|', ('byproduct_ids.product_id', 'in', self.ids), ('product_id', 'in', self.ids), '&', ('product_id', '=', False), ('product_tmpl_id', 'in', template_ids)]
         return action
 
     def action_view_mos(self):
@@ -191,11 +290,7 @@ class ProductProduct(models.Model):
         return action
 
     def action_open_quants(self):
-        bom_kits = {}
-        for product in self:
-            bom = self.env['mrp.bom']._bom_find(product=product, bom_type='phantom')
-            if bom:
-                bom_kits[product] = bom
+        bom_kits = self.env['mrp.bom']._bom_find(self, bom_type='phantom')
         components = self - self.env['product.product'].concat(*list(bom_kits.keys()))
         for product in bom_kits:
             boms, bom_sub_lines = bom_kits[product].explode(product, 1)
@@ -203,4 +298,62 @@ class ProductProduct(models.Model):
         res = super(ProductProduct, components).action_open_quants()
         if bom_kits:
             res['context']['single_product'] = False
+            res['context'].pop('default_product_tmpl_id', None)
+        return res
+
+    def _match_all_variant_values(self, product_template_attribute_value_ids):
+        """ It currently checks that all variant values (`product_template_attribute_value_ids`)
+        are in the product (`self`).
+
+        If multiple values are encoded for the same attribute line, only one of
+        them has to be found on the variant.
+        """
+        self.ensure_one()
+        # The intersection of the values of the product and those of the line satisfy:
+        # * the number of items equals the number of attributes (since a product cannot
+        #   have multiple values for the same attribute),
+        # * the attributes are a subset of the attributes of the line.
+        return len(self.product_template_attribute_value_ids & product_template_attribute_value_ids) == len(product_template_attribute_value_ids.attribute_id)
+
+    def _count_returned_sn_products_domain(self, sn_lot, or_domains):
+        or_domains.append([
+            ('production_id', '=', False),
+            ('location_id.usage', '=', 'production'),
+            ('move_id.unbuild_id', '!=', False),
+        ])
+        return super()._count_returned_sn_products_domain(sn_lot, or_domains)
+
+    def _search_qty_available_new(self, operator, value, lot_id=False, owner_id=False, package_id=False):
+        '''extending the method in stock.product to take into account kits'''
+        product_ids = super(ProductProduct, self)._search_qty_available_new(operator, value, lot_id, owner_id, package_id)
+        kit_boms = self.env['mrp.bom'].search([('type', "=", 'phantom')])
+        kit_products = self.env['product.product']
+        for kit in kit_boms:
+            if kit.product_id:
+                kit_products |= kit.product_id
+            else:
+                kit_products |= kit.product_tmpl_id.product_variant_ids
+        for product in kit_products:
+            if OPERATORS[operator](product.qty_available, value):
+                product_ids.append(product.id)
+        return list(set(product_ids))
+
+    def action_archive(self):
+        filtered_products = self.env['mrp.bom.line'].search([('product_id', 'in', self.ids), ('bom_id.active', '=', True)]).product_id.mapped('display_name')
+        res = super().action_archive()
+        if filtered_products:
+            return {
+                'type': 'ir.actions.client',
+                'tag': 'display_notification',
+                'params': {
+                'title': _("Note that product(s): '%s' is/are still linked to active Bill of Materials, "
+                            "which means that the product can still be used on it/them.", filtered_products),
+                'type': 'warning',
+                'sticky': True,  #True/False will display for few seconds if false
+                'next': {'type': 'ir.actions.act_window_close'},
+                },
+            }
         return res
+
+    def _get_backend_root_menu_ids(self):
+        return super()._get_backend_root_menu_ids() + [self.env.ref('mrp.menu_mrp_root').id]

--- a/addons/mrp/models/res_config_settings.py
+++ b/addons/mrp/models/res_config_settings.py
@@ -13,28 +13,39 @@ class ResConfigSettings(models.TransientModel):
         implied_group='mrp.group_mrp_byproducts')
     module_mrp_mps = fields.Boolean("Master Production Schedule")
     module_mrp_plm = fields.Boolean("Product Lifecycle Management (PLM)")
-    module_mrp_workorder = fields.Boolean("Work Orders")
     module_quality_control = fields.Boolean("Quality")
     module_quality_control_worksheet = fields.Boolean("Quality Worksheet")
     module_mrp_subcontracting = fields.Boolean("Subcontracting")
     group_mrp_routings = fields.Boolean("MRP Work Orders",
         implied_group='mrp.group_mrp_routings')
-    group_locked_by_default = fields.Boolean("Lock Quantities To Consume", implied_group='mrp.group_locked_by_default')
+    group_unlocked_by_default = fields.Boolean("Unlock Manufacturing Orders", implied_group='mrp.group_unlocked_by_default')
+    group_mrp_reception_report = fields.Boolean("Allocation Report for Manufacturing Orders", implied_group='mrp.group_mrp_reception_report')
+    group_mrp_workorder_dependencies = fields.Boolean("Work Order Dependencies", implied_group="mrp.group_mrp_workorder_dependencies")
+
+    def set_values(self):
+        routing_before = self.env.user.has_group('mrp.group_mrp_routings')
+        super().set_values()
+        if routing_before and not self.group_mrp_routings:
+            self.env['mrp.routing.workcenter'].search([]).active = False
+        elif not routing_before and self.group_mrp_routings:
+            operations = self.env['mrp.routing.workcenter'].search_read([('active', '=', False)], ['id', 'write_date'])
+            last_updated = max((op['write_date'] for op in operations), default=0)
+            if last_updated:
+                op_to_update = self.env['mrp.routing.workcenter'].browse([op['id'] for op in operations if op['write_date'] == last_updated])
+                op_to_update.active = True
+        if not self.group_mrp_workorder_dependencies:
+            # Disabling this option should not interfere with currently planned productions
+            self.env['mrp.bom'].sudo().search([('allow_operation_dependencies', '=', True)]).allow_operation_dependencies = False
 
     @api.onchange('use_manufacturing_lead')
     def _onchange_use_manufacturing_lead(self):
         if not self.use_manufacturing_lead:
             self.manufacturing_lead = 0.0
 
-    @api.onchange('group_mrp_routings')
-    def _onchange_group_mrp_routings(self):
-        # If we activate 'MRP Work Orders', it means that we need to install 'mrp_workorder'.
-        # The opposite is not always true: other modules (such as 'quality_mrp_workorder') may
-        # depend on 'mrp_workorder', so we should not automatically uninstall the module if 'MRP
-        # Work Orders' is deactivated.
-        # Long story short: if 'mrp_workorder' is already installed, we don't uninstall it based on
-        # group_mrp_routings
-        if self.group_mrp_routings:
-            self.module_mrp_workorder = True
-        elif not self.env['ir.module.module'].search([('name', '=', 'mrp_workorder'), ('state', '=', 'installed')]):
-            self.module_mrp_workorder = False
+    @api.onchange('group_unlocked_by_default')
+    def _onchange_group_unlocked_by_default(self):
+        """ When changing this setting, we want existing MOs to automatically update to match setting. """
+        if self.group_unlocked_by_default:
+            self.env['mrp.production'].search([('state', 'not in', ('cancel', 'done')), ('is_locked', '=', True)]).is_locked = False
+        else:
+            self.env['mrp.production'].search([('state', 'not in', ('cancel', 'done')), ('is_locked', '=', False)]).is_locked = True

--- a/addons/mrp/models/stock_production_lot.py
+++ b/addons/mrp/models/stock_lot.py
@@ -5,8 +5,8 @@ from odoo import models, _
 from odoo.exceptions import UserError
 
 
-class StockProductionLot(models.Model):
-    _inherit = 'stock.production.lot'
+class StockLot(models.Model):
+    _inherit = 'stock.lot'
 
     def _check_create(self):
         active_mo_id = self.env.context.get('active_mo_id')
@@ -14,4 +14,4 @@ class StockProductionLot(models.Model):
             active_mo = self.env['mrp.production'].browse(active_mo_id)
             if not active_mo.picking_type_id.use_create_components_lots:
                 raise UserError(_('You are not allowed to create or edit a lot or serial number for the components with the operation type "Manufacturing". To change this, go on the operation type and tick the box "Create New Lots/Serial Numbers for Components".'))
-        return super(StockProductionLot, self)._check_create()
+        return super()._check_create()

--- a/addons/mrp/models/stock_move.py
+++ b/addons/mrp/models/stock_move.py
@@ -1,9 +1,11 @@
 # -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
-from odoo import api, exceptions, fields, models, _
-from odoo.exceptions import UserError
-from odoo.tools import float_compare, float_round, float_is_zero
+from collections import defaultdict
+from dateutil.relativedelta import relativedelta
+from odoo import api, Command, fields, models
+from odoo.osv import expression
+from odoo.tools import float_compare, float_round, float_is_zero, OrderedSet
 
 
 class StockMoveLine(models.Model):
@@ -11,6 +13,30 @@ class StockMoveLine(models.Model):
 
     workorder_id = fields.Many2one('mrp.workorder', 'Work Order', check_company=True)
     production_id = fields.Many2one('mrp.production', 'Production Order', check_company=True)
+    description_bom_line = fields.Char(related='move_id.description_bom_line')
+
+    @api.depends('production_id')
+    def _compute_picking_type_id(self):
+        line_to_remove = self.env['stock.move.line']
+        for line in self:
+            if not line.production_id:
+                continue
+            line.picking_type_id = line.production_id.picking_type_id
+            line_to_remove |= line
+        return super(StockMoveLine, self - line_to_remove)._compute_picking_type_id()
+
+    def _search_picking_type_id(self, operator, value):
+        res = super()._search_picking_type_id(operator=operator, value=value)
+        if operator in ['not in', '!=', 'not ilike']:
+            if value is False:
+                return expression.OR([[('production_id.picking_type_id', operator, value)], res])
+            else:
+                return expression.AND([[('production_id.picking_type_id', operator, value)], res])
+        else:
+            if value is False:
+                return expression.AND([[('production_id.picking_type_id', operator, value)], res])
+            else:
+                return expression.OR([[('production_id.picking_type_id', operator, value)], res])
 
     @api.model_create_multi
     def create(self, values):
@@ -43,22 +69,20 @@ class StockMoveLine(models.Model):
             lines |= raw_moves_lines.filtered(lambda ml: ml.product_id == self.product_id and (ml.lot_id or ml.lot_name))
         return lines
 
-    def _reservation_is_updatable(self, quantity, reserved_quant):
-        self.ensure_one()
-        if self.produce_line_ids.lot_id:
-            ml_remaining_qty = self.qty_done - self.product_uom_qty
-            ml_remaining_qty = self.product_uom_id._compute_quantity(ml_remaining_qty, self.product_id.uom_id, rounding_method="HALF-UP")
-            if float_compare(ml_remaining_qty, quantity, precision_rounding=self.product_id.uom_id.rounding) < 0:
-                return False
-        return super(StockMoveLine, self)._reservation_is_updatable(quantity, reserved_quant)
-
     def write(self, vals):
         for move_line in self:
             production = move_line.move_id.production_id or move_line.move_id.raw_material_production_id
-            if production and move_line.state == 'done' and any(field in vals for field in ('lot_id', 'location_id', 'qty_done')):
+            if production and move_line.state == 'done' and any(field in vals for field in ('lot_id', 'location_id', 'quantity')):
                 move_line._log_message(production, move_line, 'mrp.track_production_move_template', vals)
         return super(StockMoveLine, self).write(vals)
 
+    def _get_aggregated_properties(self, move_line=False, move=False):
+        aggregated_properties = super()._get_aggregated_properties(move_line, move)
+        bom = aggregated_properties['move'].bom_line_id.bom_id
+        aggregated_properties['bom'] = bom or False
+        aggregated_properties['line_key'] += f'_{bom.id if bom else ""}'
+        return aggregated_properties
+
     def _get_aggregated_product_quantities(self, **kwargs):
         """Returns dictionary of products and corresponding values of interest grouped by optional kit_name
 
@@ -71,21 +95,36 @@ class StockMoveLine(models.Model):
         """
         aggregated_move_lines = super()._get_aggregated_product_quantities(**kwargs)
         kit_name = kwargs.get('kit_name')
-        if kit_name:
-            for aggregated_move_line in aggregated_move_lines:
-                if aggregated_move_lines[aggregated_move_line]['description'] == kit_name:
+
+        to_be_removed = []
+        for aggregated_move_line in aggregated_move_lines:
+            bom = aggregated_move_lines[aggregated_move_line]['bom']
+            is_phantom = bom.type == 'phantom' if bom else False
+            if kit_name:
+                product = bom.product_id or bom.product_tmpl_id if bom else False
+                display_name = product.display_name if product else False
+                description = aggregated_move_lines[aggregated_move_line]['description']
+                if not is_phantom or display_name != kit_name:
+                    to_be_removed.append(aggregated_move_line)
+                elif description == kit_name:
                     aggregated_move_lines[aggregated_move_line]['description'] = ""
+            elif not kwargs and is_phantom:
+                to_be_removed.append(aggregated_move_line)
+
+        for move_line in to_be_removed:
+            del aggregated_move_lines[move_line]
+
         return aggregated_move_lines
 
 
 class StockMove(models.Model):
     _inherit = 'stock.move'
 
-    created_production_id = fields.Many2one('mrp.production', 'Created Production Order', check_company=True)
+    created_production_id = fields.Many2one('mrp.production', 'Created Production Order', check_company=True, index=True)
     production_id = fields.Many2one(
-        'mrp.production', 'Production Order for finished products', check_company=True, index=True)
+        'mrp.production', 'Production Order for finished products', check_company=True, index='btree_not_null')
     raw_material_production_id = fields.Many2one(
-        'mrp.production', 'Production Order for components', check_company=True, index=True)
+        'mrp.production', 'Production Order for components', check_company=True, index='btree_not_null')
     unbuild_id = fields.Many2one(
         'mrp.unbuild', 'Disassembly Order', check_company=True)
     consume_unbuild_id = fields.Many2one(
@@ -96,7 +135,7 @@ class StockMove(models.Model):
         'mrp.routing.workcenter', 'Operation To Consume', check_company=True,
         domain="[('id', 'in', allowed_operation_ids)]")
     workorder_id = fields.Many2one(
-        'mrp.workorder', 'Work Order To Consume', check_company=True)
+        'mrp.workorder', 'Work Order To Consume', copy=False, check_company=True, index='btree_not_null')
     # Quantities to process, in normalized UoMs
     bom_line_id = fields.Many2one('mrp.bom.line', 'BoM Line', check_company=True)
     byproduct_id = fields.Many2one(
@@ -104,11 +143,55 @@ class StockMove(models.Model):
         help="By-product line that generated the move in a manufacturing order")
     unit_factor = fields.Float('Unit Factor', compute='_compute_unit_factor', store=True)
     is_done = fields.Boolean(
-        'Done', compute='_compute_is_done',
-        store=True,
-        help='Technical Field to order moves')
-    order_finished_lot_ids = fields.Many2many('stock.production.lot', string="Finished Lot/Serial Number", compute='_compute_order_finished_lot_ids')
+        'Done', compute='_compute_is_done', store=True)
+    order_finished_lot_id = fields.Many2one('stock.lot', string="Finished Lot/Serial Number", related="raw_material_production_id.lot_producing_id", store=True, index='btree_not_null')
     should_consume_qty = fields.Float('Quantity To Consume', compute='_compute_should_consume_qty', digits='Product Unit of Measure')
+    cost_share = fields.Float(
+        "Cost Share (%)", digits=(5, 2),  # decimal = 2 is important for rounding calculations!!
+        help="The percentage of the final production cost for this by-product. The total of all by-products' cost share must be smaller or equal to 100.")
+    product_qty_available = fields.Float('Product On Hand Quantity', related='product_id.qty_available', depends=['product_id'])
+    product_virtual_available = fields.Float('Product Forecasted Quantity', related='product_id.virtual_available', depends=['product_id'])
+    description_bom_line = fields.Char('Kit', compute='_compute_description_bom_line')
+    manual_consumption = fields.Boolean(
+        'Manual Consumption', compute='_compute_manual_consumption', store=True,
+        help="When activated, then the registration of consumption for that component is recorded manually exclusively.\n"
+             "If not activated, and any of the components consumption is edited manually on the manufacturing order, Odoo assumes manual consumption also.")
+
+    @api.depends('product_id')
+    def _compute_manual_consumption(self):
+        for move in self:
+            # when computed for new_id in onchange, use value from _origin
+            if move != move._origin:
+                move.manual_consumption = move._origin.manual_consumption
+            else:
+                move.manual_consumption = move._is_manual_consumption()
+
+    @api.depends('raw_material_production_id', 'raw_material_production_id.location_dest_id', 'production_id', 'production_id.location_dest_id')
+    def _compute_location_dest_id(self):
+        ids_to_super = set()
+        for move in self:
+            if move.production_id:
+                move.location_dest_id = move.production_id.location_dest_id
+            elif move.raw_material_production_id:
+                move.location_dest_id = move.product_id.with_company(move.company_id).property_stock_production.id
+            else:
+                ids_to_super.add(move.id)
+        return super(StockMove, self.browse(ids_to_super))._compute_location_dest_id()
+
+    @api.depends('bom_line_id')
+    def _compute_description_bom_line(self):
+        bom_line_description = {}
+        for bom in self.bom_line_id.bom_id:
+            if bom.type != 'phantom':
+                continue
+            line_ids = bom.bom_line_ids.ids
+            total = len(line_ids)
+            name = bom.display_name
+            for i, line_id in enumerate(line_ids):
+                bom_line_description[line_id] = '%s - %d/%d' % (name, i+1, total)
+
+        for move in self:
+            move.description_bom_line = bom_line_description.get(move.bom_line_id.id)
 
     @api.depends('raw_material_production_id.priority')
     def _compute_priority(self):
@@ -123,11 +206,6 @@ class StockMove(models.Model):
             if move.raw_material_production_id or move.production_id:
                 move.picking_type_id = (move.raw_material_production_id or move.production_id).picking_type_id
 
-    @api.depends('raw_material_production_id.lot_producing_id')
-    def _compute_order_finished_lot_ids(self):
-        for move in self:
-            move.order_finished_lot_ids = move.raw_material_production_id.lot_producing_id
-
     @api.depends('raw_material_production_id.is_locked', 'production_id.is_locked')
     def _compute_is_locked(self):
         super(StockMove, self)._compute_is_locked()
@@ -165,20 +243,26 @@ class StockMove(models.Model):
                 moves_with_reference |= move
         super(StockMove, self - moves_with_reference)._compute_reference()
 
-    @api.depends('raw_material_production_id.qty_producing', 'product_uom_qty')
+    @api.depends('raw_material_production_id.qty_producing', 'product_uom_qty', 'product_uom')
     def _compute_should_consume_qty(self):
         for move in self:
             mo = move.raw_material_production_id
-            if not mo:
+            if not mo or not move.product_uom:
                 move.should_consume_qty = 0
                 continue
-            move.should_consume_qty = mo.product_uom_id._compute_quantity((mo.qty_producing - mo.qty_produced) * move.unit_factor, mo.product_uom_id, rounding_method='HALF-UP')
+            move.should_consume_qty = float_round((mo.qty_producing - mo.qty_produced) * move.unit_factor, precision_rounding=move.product_uom.rounding)
+
+    @api.depends('byproduct_id')
+    def _compute_show_info(self):
+        super()._compute_show_info()
+        self.filtered(lambda m: m.byproduct_id or m in self.production_id.move_finished_ids).show_quant = False
 
     @api.onchange('product_uom_qty')
     def _onchange_product_uom_qty(self):
         if self.raw_material_production_id and self.has_tracking == 'none':
             mo = self.raw_material_production_id
-            self._update_quantity_done(mo)
+            new_qty = float_round((mo.qty_producing - mo.qty_produced) * self.unit_factor, precision_rounding=self.product_uom.rounding)
+            self.quantity = new_qty
 
     @api.model
     def default_get(self, fields_list):
@@ -190,12 +274,115 @@ class StockMove(models.Model):
                     defaults['state'] = 'draft'
                 else:
                     defaults['state'] = 'done'
+                    defaults['additional'] = True
                 defaults['product_uom_qty'] = 0.0
-                defaults['additional'] = True
+            elif production_id.state == 'draft':
+                defaults['group_id'] = production_id.procurement_group_id.id
+                defaults['reference'] = production_id.name
         return defaults
 
-    def _action_assign(self):
-        res = super(StockMove, self)._action_assign()
+    @api.model_create_multi
+    def create(self, vals_list):
+        """ Enforce consistent values (i.e. match _get_move_raw_values/_get_move_finished_values) for:
+        - Manually added components/byproducts specifically values we can't set via view with "default_"
+        - Moves from a copied MO
+        - Backorders
+        """
+        if self.env.context.get('force_manual_consumption'):
+            for vals in vals_list:
+                vals['manual_consumption'] = True
+        mo_id_to_mo = defaultdict(lambda: self.env['mrp.production'])
+        product_id_to_product = defaultdict(lambda: self.env['product.product'])
+        for values in vals_list:
+            mo_id = values.get('raw_material_production_id', False) or values.get('production_id', False)
+            location_dest = self.env['stock.location'].browse(values.get('location_dest_id'))
+            if mo_id and not values.get('scrapped') and not location_dest.scrap_location:
+                mo = mo_id_to_mo[mo_id]
+                if not mo:
+                    mo = mo.browse(mo_id)
+                    mo_id_to_mo[mo_id] = mo
+                values['name'] = mo.name
+                values['origin'] = mo._get_origin()
+                values['group_id'] = mo.procurement_group_id.id
+                values['propagate_cancel'] = mo.propagate_cancel
+                if values.get('raw_material_production_id', False):
+                    product = product_id_to_product[values['product_id']]
+                    if not product:
+                        product = product.browse(values['product_id'])
+                    product_id_to_product[values['product_id']] = product
+                    values['location_dest_id'] = mo.production_location_id.id
+                    values['price_unit'] = product.standard_price
+                    if not values.get('location_id'):
+                        values['location_id'] = mo.location_src_id.id
+                    continue
+                # produced products + byproducts
+                values['location_id'] = mo.production_location_id.id
+                values['date'] = mo.date_finished
+                values['date_deadline'] = mo.date_deadline
+                if not values.get('location_dest_id'):
+                    values['location_dest_id'] = mo.location_dest_id.id
+        return super().create(vals_list)
+
+    def write(self, vals):
+        if 'product_id' in vals:
+            move_to_unlink = self.filtered(lambda m: m.product_id.id != vals.get('product_id'))
+            other_move = self - move_to_unlink
+            if move_to_unlink.production_id and move_to_unlink.state not in ['draft', 'cancel', 'done']:
+                moves_data = move_to_unlink.copy_data()
+                for move_data in moves_data:
+                    move_data.update({'product_id': vals.get('product_id')})
+                updated_product_move = self.create(moves_data)
+                updated_product_move._action_confirm()
+                move_to_unlink.unlink()
+                self = other_move + updated_product_move
+        if self.env.context.get('force_manual_consumption'):
+            vals['manual_consumption'] = True
+        if 'product_uom_qty' in vals and 'move_line_ids' in vals:
+            # first update lines then product_uom_qty as the later will unreserve
+            # so possibly unlink lines
+            move_line_vals = vals.pop('move_line_ids')
+            super().write({'move_line_ids': move_line_vals})
+        old_demand = {move.id: move.product_uom_qty for move in self}
+        res = super().write(vals)
+        if 'product_uom_qty' in vals and not self.env.context.get('no_procurement', False):
+            # when updating consumed qty need to update related pickings
+            # context no_procurement means we don't want the qty update to modify stock i.e create new pickings
+            # ex. when spliting MO to backorders we don't want to move qty from pre prod to stock in 2/3 step config
+            self.filtered(lambda m: m.raw_material_production_id.state == 'confirmed')._run_procurement(old_demand)
+        return res
+
+    def _run_procurement(self, old_qties=False):
+        procurements = []
+        old_qties = old_qties or {}
+        to_assign = self.env['stock.move']
+        self._adjust_procure_method()
+        for move in self:
+            if float_compare(move.product_uom_qty - old_qties.get(move.id, 0), 0, precision_rounding=move.product_uom.rounding) < 0\
+                    and move.procure_method == 'make_to_order'\
+                    and all(m.state == 'done' for m in move.move_orig_ids):
+                continue
+            if float_compare(move.product_uom_qty, 0, precision_rounding=move.product_uom.rounding) > 0:
+                if move._should_bypass_reservation() \
+                        or move.picking_type_id.reservation_method == 'at_confirm' \
+                        or (move.reservation_date and move.reservation_date <= fields.Date.today()):
+                    to_assign |= move
+
+            if move.procure_method == 'make_to_order':
+                procurement_qty = move.product_uom_qty - old_qties.get(move.id, 0)
+                possible_reduceable_qty = -sum(move.move_orig_ids.filtered(lambda m: m.state not in ('done', 'cancel') and m.product_uom_qty).mapped('product_uom_qty'))
+                procurement_qty = max(procurement_qty, possible_reduceable_qty)
+                values = move._prepare_procurement_values()
+                origin = move._prepare_procurement_origin()
+                procurements.append(self.env['procurement.group'].Procurement(
+                    move.product_id, procurement_qty, move.product_uom,
+                    move.location_id, move.name, origin, move.company_id, values))
+
+        to_assign._action_assign()
+        if procurements:
+            self.env['procurement.group'].run(procurements)
+
+    def _action_assign(self, force_qty=False):
+        res = super(StockMove, self)._action_assign(force_qty=force_qty)
         for move in self.filtered(lambda x: x.production_id or x.raw_material_production_id):
             if move.move_line_ids:
                 move.move_line_ids.write({'production_id': move.raw_material_production_id.id,
@@ -204,6 +391,7 @@ class StockMove(models.Model):
 
     def _action_confirm(self, merge=True, merge_into=False):
         moves = self.action_explode()
+        merge_into = merge_into and merge_into.action_explode()
         # we go further with the list of ids potentially changed by action_explode
         return super(StockMove, moves)._action_confirm(merge=merge, merge_into=merge_into)
 
@@ -212,36 +400,39 @@ class StockMove(models.Model):
         # in order to explode a move, we must have a picking_type_id on that move because otherwise the move
         # won't be assigned to a picking and it would be weird to explode a move into several if they aren't
         # all grouped in the same picking.
-        moves_to_return = self.env['stock.move']
-        moves_to_unlink = self.env['stock.move']
+        moves_ids_to_return = OrderedSet()
+        moves_ids_to_unlink = OrderedSet()
         phantom_moves_vals_list = []
         for move in self:
-            if not move.picking_type_id or (move.production_id and move.production_id.product_id == move.product_id):
-                moves_to_return |= move
+            if (not move.picking_type_id and not self.env.context.get('is_scrap')) or (move.production_id and move.production_id.product_id == move.product_id):
+                moves_ids_to_return.add(move.id)
                 continue
-            bom = self.env['mrp.bom'].sudo()._bom_find(product=move.product_id, company_id=move.company_id.id, bom_type='phantom')
+            bom = self.env['mrp.bom'].sudo()._bom_find(move.product_id, company_id=move.company_id.id, bom_type='phantom')[move.product_id]
             if not bom:
-                moves_to_return |= move
+                moves_ids_to_return.add(move.id)
                 continue
-            if move.picking_id.immediate_transfer:
-                factor = move.product_uom._compute_quantity(move.quantity_done, bom.product_uom_id) / bom.product_qty
+            if float_is_zero(move.product_uom_qty, precision_rounding=move.product_uom.rounding):
+                factor = move.product_uom._compute_quantity(move.quantity, bom.product_uom_id) / bom.product_qty
             else:
                 factor = move.product_uom._compute_quantity(move.product_uom_qty, bom.product_uom_id) / bom.product_qty
             boms, lines = bom.sudo().explode(move.product_id, factor, picking_type=bom.picking_type_id)
             for bom_line, line_data in lines:
-                if move.picking_id.immediate_transfer:
+                if float_is_zero(move.product_uom_qty, precision_rounding=move.product_uom.rounding) or self.env.context.get('is_scrap'):
                     phantom_moves_vals_list += move._generate_move_phantom(bom_line, 0, line_data['qty'])
                 else:
                     phantom_moves_vals_list += move._generate_move_phantom(bom_line, line_data['qty'], 0)
             # delete the move with original product which is not relevant anymore
-            moves_to_unlink |= move
+            moves_ids_to_unlink.add(move.id)
 
-        moves_to_unlink.sudo().unlink()
         if phantom_moves_vals_list:
             phantom_moves = self.env['stock.move'].create(phantom_moves_vals_list)
             phantom_moves._adjust_procure_method()
-            moves_to_return |= phantom_moves.action_explode()
-        return moves_to_return
+            moves_ids_to_return |= phantom_moves.action_explode().ids
+        move_to_unlink = self.env['stock.move'].browse(moves_ids_to_unlink).sudo()
+        move_to_unlink.quantity = 0
+        move_to_unlink._action_cancel()
+        move_to_unlink.unlink()
+        return self.env['stock.move'].browse(moves_ids_to_return)
 
     def action_show_details(self):
         self.ensure_one()
@@ -249,17 +440,28 @@ class StockMove(models.Model):
         if self.raw_material_production_id:
             action['views'] = [(self.env.ref('mrp.view_stock_move_operations_raw').id, 'form')]
             action['context']['show_destination_location'] = False
+            action['context']['force_manual_consumption'] = True
+            action['context']['active_mo_id'] = self.raw_material_production_id.id
         elif self.production_id:
             action['views'] = [(self.env.ref('mrp.view_stock_move_operations_finished').id, 'form')]
             action['context']['show_source_location'] = False
+            action['context']['show_reserved_quantity'] = False
         return action
 
+    def action_add_from_catalog_raw(self):
+        mo = self.env['mrp.production'].browse(self.env.context.get('order_id'))
+        return mo.with_context(child_field='move_raw_ids').action_add_from_catalog()
+
+    def action_add_from_catalog_byproduct(self):
+        mo = self.env['mrp.production'].browse(self.env.context.get('order_id'))
+        return mo.with_context(child_field='move_byproduct_ids').action_add_from_catalog()
+
     def _action_cancel(self):
         res = super(StockMove, self)._action_cancel()
-        for production in self.mapped('raw_material_production_id'):
-            if production.state != 'cancel':
-                continue
-            production._action_cancel()
+        if not 'skip_mo_check' in self.env.context:
+            mo_to_cancel = self.mapped('raw_material_production_id').filtered(lambda p: all(m.state == 'cancel' for m in p.move_raw_ids))
+            if mo_to_cancel:
+                mo_to_cancel._action_cancel()
         return res
 
     def _prepare_move_split_vals(self, qty):
@@ -267,15 +469,21 @@ class StockMove(models.Model):
         defaults['workorder_id'] = False
         return defaults
 
+    def _prepare_procurement_origin(self):
+        self.ensure_one()
+        if self.raw_material_production_id and self.raw_material_production_id.orderpoint_id:
+            return self.origin
+        return super()._prepare_procurement_origin()
+
     def _prepare_phantom_move_values(self, bom_line, product_qty, quantity_done):
         return {
             'picking_id': self.picking_id.id if self.picking_id else False,
             'product_id': bom_line.product_id.id,
             'product_uom': bom_line.product_uom_id.id,
             'product_uom_qty': product_qty,
-            'quantity_done': quantity_done,
-            'state': 'draft',  # will be confirmed below
+            'quantity': quantity_done,
             'name': self.name,
+            'picked': self.picked,
             'bom_line_id': bom_line.id,
         }
 
@@ -284,14 +492,24 @@ class StockMove(models.Model):
         if bom_line.product_id.type in ['product', 'consu']:
             vals = self.copy_data(default=self._prepare_phantom_move_values(bom_line, product_qty, quantity_done))
             if self.state == 'assigned':
-                vals['state'] = 'assigned'
+                for v in vals:
+                    v['state'] = 'assigned'
         return vals
 
-    @api.model
-    def _consuming_picking_types(self):
-        res = super()._consuming_picking_types()
-        res.append('mrp_operation')
-        return res
+    def _is_consuming(self):
+        return super()._is_consuming() or self.picking_type_id.code == 'mrp_operation'
+
+    def _get_backorder_move_vals(self):
+        self.ensure_one()
+        return {
+            'state': 'draft' if self.state == 'draft' else 'confirmed',
+            'reservation_date': self.reservation_date,
+            'date_deadline': self.date_deadline,
+            'manual_consumption': self._is_manual_consumption(),
+            'move_orig_ids': [Command.link(m.id) for m in self.mapped('move_orig_ids')],
+            'move_dest_ids': [Command.link(m.id) for m in self.mapped('move_dest_ids')],
+            'procure_method': self.procure_method,
+        }
 
     def _get_source_document(self):
         res = super()._get_source_document()
@@ -318,29 +536,23 @@ class StockMove(models.Model):
         # Do not update extra product quantities
         if float_is_zero(self.product_uom_qty, precision_rounding=self.product_uom.rounding):
             return True
-        if self.has_tracking != 'none' or self.state == 'done':
-            return True
         return False
 
-    def _should_bypass_reservation(self):
-        res = super(StockMove, self)._should_bypass_reservation()
-        return bool(res and not self.production_id)
-
     def _key_assign_picking(self):
         keys = super(StockMove, self)._key_assign_picking()
         return keys + (self.created_production_id,)
 
     @api.model
     def _prepare_merge_moves_distinct_fields(self):
-        distinct_fields = super()._prepare_merge_moves_distinct_fields()
-        distinct_fields.append('created_production_id')
-        return distinct_fields
+        res = super()._prepare_merge_moves_distinct_fields()
+        res += ['created_production_id', 'cost_share']
+        if self.bom_line_id and ("phantom" in self.bom_line_id.bom_id.mapped('type')):
+            res.append('bom_line_id')
+        return res
 
     @api.model
-    def _prepare_merge_move_sort_method(self, move):
-        keys_sorted = super()._prepare_merge_move_sort_method(move)
-        keys_sorted.append(move.created_production_id.id)
-        return keys_sorted
+    def _prepare_merge_negative_moves_excluded_distinct_fields(self):
+        return super()._prepare_merge_negative_moves_excluded_distinct_fields() + ['created_production_id']
 
     def _compute_kit_quantities(self, product_id, kit_qty, kit_bom, filters):
         """ Computes the quantity delivered or received when a kit is sold or purchased.
@@ -353,26 +565,30 @@ class StockMove(models.Model):
         :return: The quantity delivered or received
         """
         qty_ratios = []
+        kit_qty = kit_qty / kit_bom.product_qty
         boms, bom_sub_lines = kit_bom.explode(product_id, kit_qty)
         for bom_line, bom_line_data in bom_sub_lines:
+            # skip service since we never deliver them
+            if bom_line.product_id.type == 'service':
+                continue
+            if float_is_zero(bom_line_data['qty'], precision_rounding=bom_line.product_uom_id.rounding):
+                # As BoMs allow components with 0 qty, a.k.a. optionnal components, we simply skip those
+                # to avoid a division by zero.
+                continue
             bom_line_moves = self.filtered(lambda m: m.bom_line_id == bom_line)
             if bom_line_moves:
-                if float_is_zero(bom_line_data['qty'], precision_rounding=bom_line.product_uom_id.rounding):
-                    # As BoMs allow components with 0 qty, a.k.a. optionnal components, we simply skip those
-                    # to avoid a division by zero.
-                    continue
                 # We compute the quantities needed of each components to make one kit.
                 # Then, we collect every relevant moves related to a specific component
                 # to know how many are considered delivered.
-                uom_qty_per_kit = bom_line_data['qty'] / bom_line_data['original_qty']
-                qty_per_kit = bom_line.product_uom_id._compute_quantity(uom_qty_per_kit, bom_line.product_id.uom_id)
+                uom_qty_per_kit = bom_line_data['qty'] / (bom_line_data['original_qty'])
+                qty_per_kit = bom_line.product_uom_id._compute_quantity(uom_qty_per_kit / kit_bom.product_qty, bom_line.product_id.uom_id, round=False)
                 if not qty_per_kit:
                     continue
                 incoming_moves = bom_line_moves.filtered(filters['incoming_moves'])
                 outgoing_moves = bom_line_moves.filtered(filters['outgoing_moves'])
                 qty_processed = sum(incoming_moves.mapped('product_qty')) - sum(outgoing_moves.mapped('product_qty'))
                 # We compute a ratio to know how many kits we can produce with this quantity of that specific component
-                qty_ratios.append(qty_processed / qty_per_kit)
+                qty_ratios.append(float_round(qty_processed / qty_per_kit, precision_rounding=bom_line.product_id.uom_id.rounding))
             else:
                 return 0.0
         if qty_ratios:
@@ -383,21 +599,47 @@ class StockMove(models.Model):
         else:
             return 0.0
 
-    def _show_details_in_draft(self):
-        self.ensure_one()
-        production = self.raw_material_production_id or self.production_id
-        if production and (self.state != 'draft' or production.state != 'draft'):
-            return True
-        elif production:
-            return False
-        else:
-            return super()._show_details_in_draft()
+    def _update_candidate_moves_list(self, candidate_moves_set):
+        super()._update_candidate_moves_list(candidate_moves_set)
+        for production in self.mapped('raw_material_production_id'):
+            candidate_moves_set.add(production.move_raw_ids.filtered(lambda m: m.product_id in self.product_id))
+        for production in self.mapped('production_id'):
+            candidate_moves_set.add(production.move_finished_ids.filtered(lambda m: m.product_id in self.product_id))
+        # this will include sibling pickings as a result of merging MOs
+        for picking in self.move_dest_ids.raw_material_production_id.picking_ids:
+            candidate_moves_set.add(picking.move_ids)
+
+    def _prepare_procurement_values(self):
+        res = super()._prepare_procurement_values()
+        res['bom_line_id'] = self.bom_line_id.id
+        return res
+
+    def action_open_reference(self):
+        res = super().action_open_reference()
+        source = self.production_id or self.raw_material_production_id
+        if source and source.check_access_rights('read', raise_exception=False):
+            return {
+                'res_model': source._name,
+                'type': 'ir.actions.act_window',
+                'views': [[False, "form"]],
+                'res_id': source.id,
+            }
+        return res
 
-    def _update_quantity_done(self, mo):
+    def _is_manual_consumption(self):
         self.ensure_one()
-        new_qty = mo.product_uom_id._compute_quantity((mo.qty_producing - mo.qty_produced) * self.unit_factor, mo.product_uom_id, rounding_method='HALF-UP')
-        if not self.is_quantity_done_editable:
-            self.move_line_ids.filtered(lambda ml: ml.state not in ('done', 'cancel')).qty_done = 0
-            self.move_line_ids = self._set_quantity_done_prepare_vals(new_qty)
-        else:
-            self.quantity_done = new_qty
+        return self._determine_is_manual_consumption(self.bom_line_id)
+
+    @api.model
+    def _determine_is_manual_consumption(self, bom_line):
+        return bom_line and bom_line.manual_consumption
+
+    def _get_relevant_state_among_moves(self):
+        res = super()._get_relevant_state_among_moves()
+        if res == 'partially_available'\
+                and self.raw_material_production_id\
+                and all(move.should_consume_qty and float_compare(move.quantity, move.should_consume_qty, precision_rounding=move.product_uom.rounding) >= 0
+                        or (float_compare(move.quantity, move.product_uom_qty, precision_rounding=move.product_uom.rounding) >= 0 or (move.manual_consumption and move.picked))
+                        for move in self):
+            res = 'assigned'
+        return res

--- a/addons/mrp/models/stock_orderpoint.py
+++ b/addons/mrp/models/stock_orderpoint.py
@@ -2,6 +2,9 @@
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
 from odoo import _, api, fields, models
+from odoo.tools.float_utils import float_is_zero
+from odoo.osv.expression import AND
+from dateutil.relativedelta import relativedelta
 
 
 class StockWarehouseOrderpoint(models.Model):
@@ -11,12 +14,14 @@ class StockWarehouseOrderpoint(models.Model):
     bom_id = fields.Many2one(
         'mrp.bom', string='Bill of Materials', check_company=True,
         domain="[('type', '=', 'normal'), '&', '|', ('company_id', '=', company_id), ('company_id', '=', False), '|', ('product_id', '=', product_id), '&', ('product_id', '=', False), ('product_tmpl_id', '=', product_tmpl_id)]")
+    manufacturing_visibility_days = fields.Float(default=0.0, help="Visibility Days applied on the manufacturing routes.")
 
     def _get_replenishment_order_notification(self):
         self.ensure_one()
-        production = self.env['mrp.production'].search([
-            ('orderpoint_id', 'in', self.ids)
-        ], order='create_date desc', limit=1)
+        domain = [('orderpoint_id', 'in', self.ids)]
+        if self.env.context.get('written_after'):
+            domain = AND([domain, [('write_date', '>=', self.env.context.get('written_after'))]])
+        production = self.env['mrp.production'].search(domain, limit=1)
         if production:
             action = self.env.ref('mrp.action_mrp_production_form')
             return {
@@ -27,7 +32,7 @@ class StockWarehouseOrderpoint(models.Model):
                     'message': '%s',
                     'links': [{
                         'label': production.name,
-                        'url': f'#action={action.id}&id={production.id}&model=mrp.production'
+                        'url': f'/web#action={action.id}&id={production.id}&model=mrp.production'
                     }],
                     'sticky': False,
                 }
@@ -42,16 +47,111 @@ class StockWarehouseOrderpoint(models.Model):
         for orderpoint in self:
             orderpoint.show_bom = orderpoint.route_id.id in manufacture_route
 
+    def _compute_visibility_days(self):
+        res = super()._compute_visibility_days()
+        for orderpoint in self:
+            if 'manufacture' in orderpoint.rule_ids.mapped('action'):
+                orderpoint.visibility_days = orderpoint.manufacturing_visibility_days
+        return res
+
+    def _set_visibility_days(self):
+        res = super()._set_visibility_days()
+        for orderpoint in self:
+            if 'manufacture' in orderpoint.rule_ids.mapped('action'):
+                orderpoint.manufacturing_visibility_days = orderpoint.visibility_days
+        return res
+
+    def _compute_days_to_order(self):
+        res = super()._compute_days_to_order()
+        for orderpoint in self:
+            if 'manufacture' in orderpoint.rule_ids.mapped('action'):
+                boms = (orderpoint.product_id.variant_bom_ids or orderpoint.product_id.bom_ids)
+                orderpoint.days_to_order = boms and boms[0].days_to_prepare_mo or 0
+        return res
+
+    def _quantity_in_progress(self):
+        bom_kits = self.env['mrp.bom']._bom_find(self.product_id, bom_type='phantom')
+        bom_kit_orderpoints = {
+            orderpoint: bom_kits[orderpoint.product_id]
+            for orderpoint in self
+            if orderpoint.product_id in bom_kits
+        }
+        orderpoints_without_kit = self - self.env['stock.warehouse.orderpoint'].concat(*bom_kit_orderpoints.keys())
+        res = super(StockWarehouseOrderpoint, orderpoints_without_kit)._quantity_in_progress()
+        for orderpoint in bom_kit_orderpoints:
+            dummy, bom_sub_lines = bom_kit_orderpoints[orderpoint].explode(orderpoint.product_id, 1)
+            ratios_qty_available = []
+            # total = qty_available + in_progress
+            ratios_total = []
+            for bom_line, bom_line_data in bom_sub_lines:
+                component = bom_line.product_id
+                if component.type != 'product' or float_is_zero(bom_line_data['qty'], precision_rounding=bom_line.product_uom_id.rounding):
+                    continue
+                uom_qty_per_kit = bom_line_data['qty'] / bom_line_data['original_qty']
+                qty_per_kit = bom_line.product_uom_id._compute_quantity(uom_qty_per_kit, bom_line.product_id.uom_id, raise_if_failure=False)
+                if not qty_per_kit:
+                    continue
+                qty_by_product_location, dummy = component._get_quantity_in_progress(orderpoint.location_id.ids)
+                qty_in_progress = qty_by_product_location.get((component.id, orderpoint.location_id.id), 0.0)
+                qty_available = component.qty_available / qty_per_kit
+                ratios_qty_available.append(qty_available)
+                ratios_total.append(qty_available + (qty_in_progress / qty_per_kit))
+            # For a kit, the quantity in progress is :
+            #  (the quantity if we have received all in-progress components) - (the quantity using only available components)
+            product_qty = min(ratios_total or [0]) - min(ratios_qty_available or [0])
+            res[orderpoint.id] = orderpoint.product_id.uom_id._compute_quantity(product_qty, orderpoint.product_uom, round=False)
+
+        bom_manufacture = self.env['mrp.bom']._bom_find(orderpoints_without_kit.product_id, bom_type='normal')
+        bom_manufacture = self.env['mrp.bom'].concat(*bom_manufacture.values())
+        productions_group = self.env['mrp.production']._read_group(
+            [
+                ('bom_id', 'in', bom_manufacture.ids),
+                ('state', '=', 'draft'),
+                ('orderpoint_id', 'in', orderpoints_without_kit.ids),
+                ('id', 'not in', self.env.context.get('ignore_mo_ids', [])),
+            ],
+            ['orderpoint_id', 'product_uom_id'],
+            ['product_qty:sum'])
+        for orderpoint, uom, product_qty_sum in productions_group:
+            res[orderpoint.id] += uom._compute_quantity(
+                product_qty_sum, orderpoint.product_uom, round=False)
+        return res
+
+    def _get_qty_multiple_to_order(self):
+        """ Calculates the minimum quantity that can be ordered according to the qty and UoM of the BoM
+        """
+        self.ensure_one()
+        qty_multiple_to_order = super()._get_qty_multiple_to_order()
+        if 'manufacture' in self.rule_ids.mapped('action'):
+            bom = self.env['mrp.bom']._bom_find(self.product_id, bom_type='normal')[self.product_id]
+            return bom.product_uom_id._compute_quantity(bom.product_qty, self.product_uom)
+        return qty_multiple_to_order
+
     def _set_default_route_id(self):
-        route_id = self.env['stock.rule'].search([
+        route_ids = self.env['stock.rule'].search([
             ('action', '=', 'manufacture')
         ]).route_id
-        orderpoint_wh_bom = self.filtered(lambda o: o.product_id.bom_ids)
-        if route_id and orderpoint_wh_bom:
-            orderpoint_wh_bom.route_id = route_id[0].id
+        for orderpoint in self:
+            if not orderpoint.product_id.bom_ids:
+                continue
+            route_id = orderpoint.rule_ids.route_id & route_ids
+            if not route_id:
+                continue
+            orderpoint.route_id = route_id[0].id
         return super()._set_default_route_id()
 
     def _prepare_procurement_values(self, date=False, group=False):
         values = super()._prepare_procurement_values(date=date, group=group)
         values['bom_id'] = self.bom_id
         return values
+
+    def _post_process_scheduler(self):
+        """ Confirm the productions only after all the orderpoints have run their
+        procurement to avoid the new procurement created from the production conflict
+        with them. """
+        self.env['mrp.production'].sudo().search([
+            ('orderpoint_id', 'in', self.ids),
+            ('move_raw_ids', '!=', False),
+            ('state', '=', 'draft'),
+        ]).action_confirm()
+        return super()._post_process_scheduler()

--- a/addons/mrp/models/stock_picking.py
+++ b/addons/mrp/models/stock_picking.py
@@ -1,7 +1,7 @@
 # -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
-from odoo import fields, models
+from odoo import api, fields, models
 
 
 class StockPickingType(models.Model):
@@ -9,7 +9,7 @@ class StockPickingType(models.Model):
 
     code = fields.Selection(selection_add=[
         ('mrp_operation', 'Manufacturing')
-    ], ondelete={'mrp_operation': 'cascade'})
+    ], ondelete={'mrp_operation': lambda recs: recs.write({'code': 'incoming', 'active': False})})
     count_mo_todo = fields.Integer(string="Number of Manufacturing Orders to Process",
         compute='_get_mo_count')
     count_mo_waiting = fields.Integer(string="Number of Manufacturing Orders Waiting",
@@ -22,51 +22,126 @@ class StockPickingType(models.Model):
         default=False,
     )
 
+    auto_print_done_production_order = fields.Boolean(
+        "Auto Print Done Production Order",
+        help="If this checkbox is ticked, Odoo will automatically print the production order of a MO when it is done.")
+    auto_print_done_mrp_product_labels = fields.Boolean(
+        "Auto Print Produced Product Labels",
+        help="If this checkbox is ticked, Odoo will automatically print the product labels of a MO when it is done.")
+    mrp_product_label_to_print = fields.Selection(
+        [('pdf', 'PDF'), ('zpl', 'ZPL')],
+        "Product Label to Print", default='pdf')
+    auto_print_done_mrp_lot = fields.Boolean(
+        "Auto Print Produced Lot Label",
+        help="If this checkbox is ticked, Odoo will automatically print the lot/SN label of a MO when it is done.")
+    done_mrp_lot_label_to_print = fields.Selection(
+        [('pdf', 'PDF'), ('zpl', 'ZPL')],
+        "Lot/SN Label to Print", default='pdf')
+    auto_print_mrp_reception_report = fields.Boolean(
+        "Auto Print Allocation Report",
+        help="If this checkbox is ticked, Odoo will automatically print the allocation report of a MO when it is done and has assigned moves.")
+    auto_print_mrp_reception_report_labels = fields.Boolean(
+        "Auto Print Allocation Report Labels",
+        help="If this checkbox is ticked, Odoo will automatically print the allocation report labels of a MO when it is done.")
+    auto_print_generated_mrp_lot = fields.Boolean(
+        "Auto Print Generated Lot/SN Label",
+        help='Automatically print the lot/SN label when the "Create a new serial/lot number" button is used.')
+    generated_mrp_lot_label_to_print = fields.Selection(
+        [('pdf', 'PDF'), ('zpl', 'ZPL')],
+        "Generated Lot/SN Label to Print", default='pdf')
+
+    @api.depends('code')
+    def _compute_use_create_lots(self):
+        super()._compute_use_create_lots()
+        for picking_type in self:
+            if picking_type.code == 'mrp_operation':
+                picking_type.use_create_lots = True
+
+    @api.depends('code')
+    def _compute_use_existing_lots(self):
+        super()._compute_use_existing_lots()
+        for picking_type in self:
+            if picking_type.code == 'mrp_operation':
+                picking_type.use_existing_lots = True
+
     def _get_mo_count(self):
         mrp_picking_types = self.filtered(lambda picking: picking.code == 'mrp_operation')
-        if not mrp_picking_types:
-            self.count_mo_waiting = False
-            self.count_mo_todo = False
-            self.count_mo_late = False
-            return
+        remaining = (self - mrp_picking_types)
+        remaining.count_mo_waiting = remaining.count_mo_todo = remaining.count_mo_late = False
         domains = {
             'count_mo_waiting': [('reservation_state', '=', 'waiting')],
-            'count_mo_todo': ['|', ('state', 'in', ('confirmed', 'draft', 'progress')), ('is_planned', '=', True)],
-            'count_mo_late': [('date_planned_start', '<', fields.Date.today()), ('state', '=', 'confirmed')],
+            'count_mo_todo': ['|', ('state', 'in', ('confirmed', 'draft', 'progress', 'to_close')), ('is_planned', '=', True)],
+            'count_mo_late': [('date_start', '<', fields.Date.today()), ('state', '=', 'confirmed')],
         }
-        for field in domains:
-            data = self.env['mrp.production'].read_group(domains[field] +
-                [('state', 'not in', ('done', 'cancel')), ('picking_type_id', 'in', self.ids)],
-                ['picking_type_id'], ['picking_type_id'])
-            count = {x['picking_type_id'] and x['picking_type_id'][0]: x['picking_type_id_count'] for x in data}
+        for key, domain in domains.items():
+            data = self.env['mrp.production']._read_group(domain +
+                [('state', 'not in', ('done', 'cancel')), ('picking_type_id', 'in', mrp_picking_types.ids)],
+                ['picking_type_id'], ['__count'])
+            count = {picking_type.id: count for picking_type, count in data}
             for record in mrp_picking_types:
-                record[field] = count.get(record.id, 0)
-        remaining = (self - mrp_picking_types)
-        if remaining:
-            remaining.count_mo_waiting = False
-            remaining.count_mo_todo = False
-            remaining.count_mo_late = False
+                record[key] = count.get(record.id, 0)
 
     def get_mrp_stock_picking_action_picking_type(self):
-        return self._get_action('mrp.mrp_production_action_picking_deshboard')
+        action = self.env["ir.actions.actions"]._for_xml_id('mrp.mrp_production_action_picking_deshboard')
+        if self:
+            action['display_name'] = self.display_name
+        return action
 
 class StockPicking(models.Model):
     _inherit = 'stock.picking'
 
+    has_kits = fields.Boolean(compute='_compute_has_kits')
+    production_count = fields.Integer(
+        "Count of MO generated",
+        compute='_compute_mrp_production_ids',
+        groups='mrp.group_mrp_user')
+
+    production_ids = fields.Many2many(
+        'mrp.production',
+        compute='_compute_mrp_production_ids',
+        groups='mrp.group_mrp_user')
+
+    @api.depends('move_ids')
+    def _compute_has_kits(self):
+        for picking in self:
+            picking.has_kits = any(picking.move_ids.mapped('bom_line_id'))
+
+    @api.depends('group_id')
+    def _compute_mrp_production_ids(self):
+        for picking in self:
+            production_ids = picking.group_id.mrp_production_ids | picking.move_ids.move_dest_ids.raw_material_production_id
+            # Filter out unwanted MO types
+            picking.production_ids = production_ids.filtered(lambda p: p.picking_type_id.active)
+            picking.production_count = len(picking.production_ids)
+
+    def action_detailed_operations(self):
+        action = super().action_detailed_operations()
+        action['context']['has_kits'] = self.has_kits
+        return action
+
+    def action_view_mrp_production(self):
+        self.ensure_one()
+        action = {
+            'res_model': 'mrp.production',
+            'type': 'ir.actions.act_window',
+            'domain': [('id', 'in', self.production_ids.ids)],
+            'view_mode': 'tree,form',
+        }
+        if self.production_count == 1:
+            action.update({
+                'view_mode': 'form',
+                'res_id': self.production_ids.id,
+            })
+        return action
+
     def _less_quantities_than_expected_add_documents(self, moves, documents):
         documents = super(StockPicking, self)._less_quantities_than_expected_add_documents(moves, documents)
 
-        def _keys_in_sorted(move):
-            """ sort by picking and the responsible for the product the
-            move.
-            """
-            return (move.raw_material_production_id.id, move.product_id.responsible_id.id)
-
         def _keys_in_groupby(move):
             """ group by picking and the responsible for the product the
             move.
             """
             return (move.raw_material_production_id, move.product_id.responsible_id)
 
-        production_documents = self._log_activity_get_documents(moves, 'move_dest_ids', 'DOWN', _keys_in_sorted, _keys_in_groupby)
+        production_documents = self._log_activity_get_documents(moves, 'move_dest_ids', 'DOWN', _keys_in_groupby)
         return {**documents, **production_documents}

--- a/None
+++ b/addons/mrp/models/stock_quant.py
@@ -0,0 +1,11 @@
+from odoo import models, api, _
+from odoo.exceptions import UserError
+
+
+class StockQuant(models.Model):
+    _inherit = 'stock.quant'
+
+    @api.constrains('product_id')
+    def _check_kits(self):
+        if self.sudo().product_id.filtered("is_kits"):
+            raise UserError(_('You should update the components quantity instead of directly updating the quantity of the kit product.'))

--- a/addons/mrp/models/stock_rule.py
+++ b/addons/mrp/models/stock_rule.py
@@ -2,11 +2,12 @@
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
 from collections import defaultdict
+from datetime import datetime
 from dateutil.relativedelta import relativedelta
 
 from odoo import api, fields, models, SUPERUSER_ID, _
 from odoo.osv import expression
-from odoo.addons.stock.models.stock_rule import ProcurementException
+from odoo.tools import float_compare, OrderedSet
 
 
 class StockRule(models.Model):
@@ -17,13 +18,11 @@ class StockRule(models.Model):
 
     def _get_message_dict(self):
         message_dict = super(StockRule, self)._get_message_dict()
-        source, destination, operation = self._get_message_values()
-        manufacture_message = _('When products are needed in <b>%s</b>, <br/> a manufacturing order is created to fulfill the need.') % (destination)
+        source, destination, __, __ = self._get_message_values()
+        manufacture_message = _('When products are needed in <b>%s</b>, <br/> a manufacturing order is created to fulfill the need.', destination)
         if self.location_src_id:
-            manufacture_message += _(' <br/><br/> The components will be taken from <b>%s</b>.') % (source)
-        message_dict.update({
-            'manufacture': manufacture_message
-        })
+            manufacture_message += _(' <br/><br/> The components will be taken from <b>%s</b>.', source)
+        message_dict['manufacture'] = manufacture_message
         return message_dict
 
     @api.depends('action')
@@ -36,42 +35,112 @@ class StockRule(models.Model):
                 remaining |= rule
         super(StockRule, remaining)._compute_picking_type_code_domain()
 
+    def _should_auto_confirm_procurement_mo(self, p):
+        return (not p.orderpoint_id and p.move_raw_ids) or (p.move_dest_ids.procure_method != 'make_to_order' and not p.move_raw_ids and not p.workorder_ids)
+
     @api.model
     def _run_manufacture(self, procurements):
-        productions_values_by_company = defaultdict(list)
-        errors = []
+        new_productions_values_by_company = defaultdict(list)
         for procurement, rule in procurements:
-            bom = self._get_matching_bom(procurement.product_id, procurement.company_id, procurement.values)
-            if not bom:
-                msg = _('There is no Bill of Material of type manufacture or kit found for the product %s. Please define a Bill of Material for this product.') % (procurement.product_id.display_name,)
-                errors.append((procurement, msg))
-
-            productions_values_by_company[procurement.company_id.id].append(rule._prepare_mo_vals(*procurement, bom))
+            if float_compare(procurement.product_qty, 0, precision_rounding=procurement.product_uom.rounding) <= 0:
+                # If procurement contains negative quantity, don't create a MO that would be for a negative value.
+                continue
+            bom = rule._get_matching_bom(procurement.product_id, procurement.company_id, procurement.values)
 
-        if errors:
-            raise ProcurementException(errors)
+            mo = self.env['mrp.production']
+            if procurement.origin != 'MPS':
+                gpo = rule.group_propagation_option
+                group = (gpo == 'fixed' and rule.group_id) or \
+                        (gpo == 'propagate' and 'group_id' in procurement.values and procurement.values['group_id']) or False
+                domain = (
+                    ('bom_id', '=', bom.id),
+                    ('product_id', '=', procurement.product_id.id),
+                    ('state', 'in', ['draft', 'confirmed']),
+                    ('is_planned', '=', False),
+                    ('picking_type_id', '=', rule.picking_type_id.id),
+                    ('company_id', '=', procurement.company_id.id),
+                    ('user_id', '=', False),
+                )
+                if procurement.values.get('orderpoint_id'):
+                    procurement_date = datetime.combine(
+                        fields.Date.to_date(procurement.values['date_planned']) - relativedelta(days=int(bom.produce_delay)),
+                        datetime.max.time()
+                    )
+                    domain += ('|',
+                               '&', ('state', '=', 'draft'), ('date_deadline', '<=', procurement_date),
+                               '&', ('state', '=', 'confirmed'), ('date_start', '<=', procurement_date))
+                if group:
+                    domain += (('procurement_group_id', '=', group.id),)
+                mo = self.env['mrp.production'].sudo().search(domain, limit=1)
+            if not mo:
+                new_productions_values_by_company[procurement.company_id.id].append(rule._prepare_mo_vals(*procurement, bom))
+            else:
+                self.env['change.production.qty'].sudo().with_context(skip_activity=True).create({
+                    'mo_id': mo.id,
+                    'product_qty': mo.product_id.uom_id._compute_quantity((mo.product_uom_qty + procurement.product_qty), mo.product_uom_id)
+                }).change_prod_qty()
 
-        for company_id, productions_values in productions_values_by_company.items():
+        note_subtype_id = self.env['ir.model.data']._xmlid_to_res_id('mail.mt_note')
+        for company_id, productions_values in new_productions_values_by_company.items():
             # create the MO as SUPERUSER because the current user may not have the rights to do it (mto product launched by a sale for example)
             productions = self.env['mrp.production'].with_user(SUPERUSER_ID).sudo().with_company(company_id).create(productions_values)
-            self.env['stock.move'].sudo().create(productions._get_moves_raw_values())
-            self.env['stock.move'].sudo().create(productions._get_moves_finished_values())
-            productions._create_workorder()
-            productions.filtered(lambda p: p.move_raw_ids).action_confirm()
+            productions.filtered(self._should_auto_confirm_procurement_mo).action_confirm()
 
             for production in productions:
                 origin_production = production.move_dest_ids and production.move_dest_ids[0].raw_material_production_id or False
                 orderpoint = production.orderpoint_id
-                if orderpoint:
-                    production.message_post_with_view('mail.message_origin_link',
-                                                      values={'self': production, 'origin': orderpoint},
-                                                      subtype_id=self.env.ref('mail.mt_note').id)
-                if origin_production:
-                    production.message_post_with_view('mail.message_origin_link',
-                                                      values={'self': production, 'origin': origin_production},
-                                                      subtype_id=self.env.ref('mail.mt_note').id)
+                if orderpoint and orderpoint.create_uid.id == SUPERUSER_ID and orderpoint.trigger == 'manual':
+                    production.message_post(
+                        body=_('This production order has been created from Replenishment Report.'),
+                        message_type='comment',
+                        subtype_id=note_subtype_id
+                    )
+                elif orderpoint:
+                    production.message_post_with_source(
+                        'mail.message_origin_link',
+                        render_values={'self': production, 'origin': orderpoint},
+                        subtype_id=note_subtype_id,
+                    )
+                elif origin_production:
+                    production.message_post_with_source(
+                        'mail.message_origin_link',
+                        render_values={'self': production, 'origin': origin_production},
+                        subtype_id=note_subtype_id,
+                    )
         return True
 
+    @api.model
+    def _run_pull(self, procurements):
+        # Override to correctly assign the move generated from the pull
+        # in its production order (pbm_sam only)
+        for procurement, rule in procurements:
+            warehouse_id = rule.warehouse_id
+            if not warehouse_id:
+                warehouse_id = rule.location_dest_id.warehouse_id
+            if rule.picking_type_id == warehouse_id.sam_type_id or (warehouse_id.sam_loc_id and warehouse_id.sam_loc_id.parent_path in rule.location_src_id.parent_path):
+                if float_compare(procurement.product_qty, 0, precision_rounding=procurement.product_uom.rounding) < 0:
+                    procurement.values['group_id'] = procurement.values['group_id'].stock_move_ids.filtered(
+                        lambda m: m.state not in ['done', 'cancel']).move_orig_ids.group_id[:1]
+                    continue
+                manu_rule = rule.route_id.rule_ids.filtered(lambda r: r.action == 'manufacture' and r.warehouse_id == warehouse_id)
+                if manu_rule:
+                    manu_type_id = manu_rule[0].picking_type_id
+                else:
+                    manu_type_id = warehouse_id.manu_type_id
+                if manu_type_id:
+                    name = manu_type_id.sequence_id.next_by_id()
+                else:
+                    name = self.env['ir.sequence'].next_by_code('mrp.production') or _('New')
+                # Create now the procurement group that will be assigned to the new MO
+                # This ensure that the outgoing move PostProduction -> Stock is linked to its MO
+                # rather than the original record (MO or SO)
+                group = procurement.values.get('group_id')
+                if group:
+                    procurement.values['group_id'] = group.copy({'name': name})
+                else:
+                    procurement.values['group_id'] = self.env["procurement.group"].create({'name': name})
+        return super()._run_pull(procurements)
+
     def _get_custom_move_fields(self):
         fields = super(StockRule, self)._get_custom_move_fields()
         fields += ['bom_line_id']
@@ -80,23 +149,26 @@ class StockRule(models.Model):
     def _get_matching_bom(self, product_id, company_id, values):
         if values.get('bom_id', False):
             return values['bom_id']
-        return self.env['mrp.bom']._bom_find(
-            product=product_id, picking_type=self.picking_type_id, bom_type='normal', company_id=company_id.id)
+        if values.get('orderpoint_id', False) and values['orderpoint_id'].bom_id:
+            return values['orderpoint_id'].bom_id
+        return self.env['mrp.bom']._bom_find(product_id, picking_type=self.picking_type_id, bom_type='normal', company_id=company_id.id)[product_id]
 
-    def _prepare_mo_vals(self, product_id, product_qty, product_uom, location_id, name, origin, company_id, values, bom):
-        date_planned = self._get_date_planned(product_id, company_id, values)
-        date_deadline = values.get('date_deadline') or date_planned + relativedelta(days=company_id.manufacturing_lead) + relativedelta(days=product_id.produce_delay)
-        return {
+    def _prepare_mo_vals(self, product_id, product_qty, product_uom, location_dest_id, name, origin, company_id, values, bom):
+        date_planned = self._get_date_planned(bom, values)
+        date_deadline = values.get('date_deadline') or date_planned + relativedelta(days=bom.produce_delay)
+        mo_values = {
             'origin': origin,
             'product_id': product_id.id,
             'product_description_variants': values.get('product_description_variants'),
-            'product_qty': product_qty,
-            'product_uom_id': product_uom.id,
-            'location_src_id': self.location_src_id.id or self.picking_type_id.default_location_src_id.id or location_id.id,
-            'location_dest_id': location_id.id,
+            'product_qty': product_uom._compute_quantity(product_qty, bom.product_uom_id) if bom else product_qty,
+            'product_uom_id': bom.product_uom_id.id if bom else product_uom.id,
+            'location_src_id': self.picking_type_id.default_location_src_id.id,
+            'location_dest_id': self.picking_type_id.default_location_dest_id.id or location_dest_id.id,
+            'location_final_id': location_dest_id.id,
             'bom_id': bom.id,
             'date_deadline': date_deadline,
-            'date_planned_start': date_planned,
+            'date_start': date_planned,
+            'date_finished': fields.Datetime.from_string(values['date_planned']),
             'procurement_group_id': False,
             'propagate_cancel': self.propagate_cancel,
             'orderpoint_id': values.get('orderpoint_id', False) and values.get('orderpoint_id').id,
@@ -105,31 +177,62 @@ class StockRule(models.Model):
             'move_dest_ids': values.get('move_dest_ids') and [(4, x.id) for x in values['move_dest_ids']] or False,
             'user_id': False,
         }
+        # Use the procurement group created in _run_pull mrp override
+        # Preserve the origin from the original stock move, if available
+        if location_dest_id.warehouse_id.manufacture_steps == 'pbm_sam' and values.get('move_dest_ids') and values.get('group_id') and values['move_dest_ids'][0].origin != values['group_id'].name:
+            origin = values['move_dest_ids'][0].origin
+            mo_values.update({
+                'name': values['group_id'].name,
+                'procurement_group_id': values['group_id'].id,
+                'origin': origin,
+            })
+        return mo_values
 
-    def _get_date_planned(self, product_id, company_id, values):
+    def _get_date_planned(self, bom_id, values):
         format_date_planned = fields.Datetime.from_string(values['date_planned'])
-        date_planned = format_date_planned - relativedelta(days=product_id.produce_delay)
-        date_planned = date_planned - relativedelta(days=company_id.manufacturing_lead)
+        date_planned = format_date_planned - relativedelta(days=bom_id.produce_delay)
         if date_planned == format_date_planned:
             date_planned = date_planned - relativedelta(hours=1)
         return date_planned
 
-    def _get_lead_days(self, product):
+    def _get_lead_days(self, product, **values):
         """Add the product and company manufacture delay to the cumulative delay
         and cumulative description.
         """
-        delay, delay_description = super()._get_lead_days(product)
+        delays, delay_description = super()._get_lead_days(product, **values)
+        bypass_delay_description = self.env.context.get('bypass_delay_description')
         manufacture_rule = self.filtered(lambda r: r.action == 'manufacture')
         if not manufacture_rule:
-            return delay, delay_description
+            return delays, delay_description
         manufacture_rule.ensure_one()
-        manufacture_delay = product.produce_delay
-        delay += manufacture_delay
-        delay_description += '<tr><td>%s</td><td class="text-right">+ %d %s</td></tr>' % (_('Manufacturing Lead Time'), manufacture_delay, _('day(s)'))
-        security_delay = manufacture_rule.picking_type_id.company_id.manufacturing_lead
-        delay += security_delay
-        delay_description += '<tr><td>%s</td><td class="text-right">+ %d %s</td></tr>' % (_('Manufacture Security Lead Time'), security_delay, _('day(s)'))
-        return delay, delay_description
+        bom = values.get('bom') or self.env['mrp.bom']._bom_find(product, picking_type=manufacture_rule.picking_type_id, company_id=manufacture_rule.company_id.id)[product]
+        manufacture_delay = bom.produce_delay
+        delays['total_delay'] += manufacture_delay
+        delays['manufacture_delay'] += manufacture_delay
+        if not bypass_delay_description:
+            delay_description.append((_('Manufacturing Lead Time'), _('+ %d day(s)', manufacture_delay)))
+        if bom.type == 'normal':
+            # pre-production rules
+            warehouse = self.location_dest_id.warehouse_id
+            for wh in warehouse:
+                if wh.manufacture_steps != 'mrp_one_step':
+                    wh_manufacture_rules = product._get_rules_from_location(product.property_stock_production, route_ids=wh.pbm_route_id)
+                    extra_delays, extra_delay_description = (wh_manufacture_rules - self)._get_lead_days(product, **values)
+                    for key, value in extra_delays.items():
+                        delays[key] += value
+                    delay_description += extra_delay_description
+            # manufacturing security lead time
+            for comp in self.picking_type_id.company_id:
+                security_delay = comp.manufacturing_lead
+                delays['total_delay'] += security_delay
+                delays['security_lead_days'] += security_delay
+            if not bypass_delay_description:
+                delay_description.append((_('Manufacture Security Lead Time'), _('+ %d day(s)', security_delay)))
+        days_to_order = values.get('days_to_order', bom.days_to_prepare_mo)
+        delays['total_delay'] += days_to_order
+        if not bypass_delay_description:
+            delay_description.append((_('Days to Supply Components'), _('+ %d day(s)', days_to_order)))
+        return delays, delay_description
 
     def _push_prepare_move_copy_values(self, move_to_copy, new_date):
         new_move_vals = super(StockRule, self)._push_prepare_move_copy_values(move_to_copy, new_date)
@@ -148,12 +251,15 @@ class ProcurementGroup(models.Model):
         the original 'run' method with the values of the components of that kit.
         """
         procurements_without_kit = []
+        product_by_company = defaultdict(OrderedSet)
+        for procurement in procurements:
+            product_by_company[procurement.company_id].add(procurement.product_id.id)
+        kits_by_company = {
+            company: self.env['mrp.bom']._bom_find(self.env['product.product'].browse(product_ids), company_id=company.id, bom_type='phantom')
+            for company, product_ids in product_by_company.items()
+        }
         for procurement in procurements:
-            bom_kit = self.env['mrp.bom']._bom_find(
-                product=procurement.product_id,
-                company_id=procurement.company_id.id,
-                bom_type='phantom',
-            )
+            bom_kit = kits_by_company[procurement.company_id].get(procurement.product_id)
             if bom_kit:
                 order_qty = procurement.product_uom._compute_quantity(procurement.product_qty, bom_kit.product_uom_id, round=False)
                 qty_to_produce = (order_qty / bom_kit.product_qty)

--- a/addons/mrp/models/stock_scrap.py
+++ b/addons/mrp/models/stock_scrap.py
@@ -1,7 +1,7 @@
 # -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
-from odoo import api, fields, models
+from odoo import _, api, fields, models
 
 
 class StockScrap(models.Model):
@@ -9,21 +9,34 @@ class StockScrap(models.Model):
 
     production_id = fields.Many2one(
         'mrp.production', 'Manufacturing Order',
-        states={'done': [('readonly', True)]}, check_company=True)
+        check_company=True)
     workorder_id = fields.Many2one(
         'mrp.workorder', 'Work Order',
-        states={'done': [('readonly', True)]},
-        help='Not to restrict or prefer quants, but informative.', check_company=True)
+        check_company=True) # Not to restrict or prefer quants, but informative
+    product_is_kit = fields.Boolean(related='product_id.is_kits')
+    product_template = fields.Many2one(related='product_id.product_tmpl_id')
+    bom_id = fields.Many2one(
+        'mrp.bom', 'Kit',
+        domain="[('type', '=', 'phantom'), '|', ('product_id', '=', product_id), '&', ('product_id', '=', False), ('product_tmpl_id', '=', product_template)]",
+        check_company=True)
 
-    @api.onchange('workorder_id')
-    def _onchange_workorder_id(self):
-        if self.workorder_id:
-            self.location_id = self.workorder_id.production_id.location_src_id.id
+    @api.depends('workorder_id', 'production_id')
+    def _compute_location_id(self):
+        remaining_scrap = self.browse()
 
-    @api.onchange('production_id')
-    def _onchange_production_id(self):
-        if self.production_id:
-            self.location_id = self.production_id.move_raw_ids.filtered(lambda x: x.state not in ('done', 'cancel')) and self.production_id.location_src_id.id or self.production_id.location_dest_id.id
+        for scrap in self:
+            if scrap.production_id:
+                if scrap.production_id.state != 'done':
+                    scrap.location_id = scrap.production_id.location_src_id.id
+                else:
+                    scrap.location_id = scrap.production_id.location_dest_id.id
+            elif scrap.workorder_id:
+                scrap.location_id = scrap.workorder_id.production_id.location_src_id.id
+            else:
+                remaining_scrap |= scrap
+
+        res = super(StockScrap, remaining_scrap)._compute_location_id()
+        return res
 
     def _prepare_move_values(self):
         vals = super(StockScrap, self)._prepare_move_values()
@@ -34,3 +47,48 @@ class StockScrap(models.Model):
             else:
                 vals.update({'raw_material_production_id': self.production_id.id})
         return vals
+
+    @api.onchange('lot_id')
+    def _onchange_serial_number(self):
+        if self.product_id.tracking == 'serial' and self.lot_id:
+            if self.production_id:
+                message, recommended_location = self.env['stock.quant'].sudo()._check_serial_number(self.product_id,
+                                                                                                    self.lot_id,
+                                                                                                    self.company_id,
+                                                                                                    self.location_id,
+                                                                                                    self.production_id.location_dest_id)
+                if message:
+                    if recommended_location:
+                        self.location_id = recommended_location
+                    return {'warning': {'title': _('Warning'), 'message': message}}
+            else:
+                return super()._onchange_serial_number()
+
+    @api.depends('move_ids', 'move_ids.move_line_ids.quantity', 'product_id')
+    def _compute_scrap_qty(self):
+        self.scrap_qty = 1
+        for scrap in self:
+            if not scrap.bom_id:
+                return super(StockScrap, scrap)._compute_scrap_qty()
+            if scrap.move_ids:
+                filters = {
+                    'incoming_moves': lambda m: True,
+                    'outgoing_moves': lambda m: False
+                }
+                scrap.scrap_qty = scrap.move_ids._compute_kit_quantities(scrap.product_id, scrap.scrap_qty, scrap.bom_id, filters)
+
+    def _should_check_available_qty(self):
+        return super()._should_check_available_qty() or self.product_is_kit
+
+    def do_replenish(self, values=False):
+        self.ensure_one()
+        values = values or {}
+        if self.production_id and self.production_id.procurement_group_id:
+            values.update({
+                'group_id': self.production_id.procurement_group_id,
+                'move_dest_ids': self.production_id.procurement_group_id.stock_move_ids.filtered(
+                    lambda m: m.location_id == self.location_id
+                              and m.product_id == self.product_id
+                              and m.state not in ('assigned', 'done', 'cancel'))
+            })
+        super().do_replenish(values)

--- a/addons/mrp/models/stock_warehouse.py
+++ b/addons/mrp/models/stock_warehouse.py
@@ -2,7 +2,8 @@
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
 from odoo import api, fields, models, _
-from odoo.exceptions import UserError
+from odoo.exceptions import ValidationError, UserError
+from odoo.tools import split_every
 
 
 class StockWarehouse(models.Model):
@@ -12,13 +13,13 @@ class StockWarehouse(models.Model):
         'Manufacture to Resupply', default=True,
         help="When products are manufactured, they can be manufactured in this warehouse.")
     manufacture_pull_id = fields.Many2one(
-        'stock.rule', 'Manufacture Rule')
+        'stock.rule', 'Manufacture Rule', copy=False)
     manufacture_mto_pull_id = fields.Many2one(
-        'stock.rule', 'Manufacture MTO Rule')
+        'stock.rule', 'Manufacture MTO Rule', copy=False)
     pbm_mto_pull_id = fields.Many2one(
-        'stock.rule', 'Picking Before Manufacturing MTO Rule')
+        'stock.rule', 'Picking Before Manufacturing MTO Rule', copy=False)
     sam_rule_id = fields.Many2one(
-        'stock.rule', 'Stock After Manufacturing Rule')
+        'stock.rule', 'Stock After Manufacturing Rule', copy=False)
     manu_type_id = fields.Many2one(
         'stock.picking.type', 'Manufacturing Operation Type',
         domain="[('code', '=', 'mrp_operation'), ('company_id', '=', company_id)]", check_company=True)
@@ -31,12 +32,12 @@ class StockWarehouse(models.Model):
         ('pbm', 'Pick components and then manufacture (2 steps)'),
         ('pbm_sam', 'Pick components, manufacture and then store products (3 steps)')],
         'Manufacture', default='mrp_one_step', required=True,
-        help="Produce : Move the components to the production location\
-        directly and start the manufacturing process.\nPick / Produce : Unload\
+        help="Produce: Move the components to the production location\
+        directly and start the manufacturing process.\nPick / Produce: Unload\
         the components from the Stock to Input location first, and then\
         transfer it to the Production location.")
 
-    pbm_route_id = fields.Many2one('stock.location.route', 'Picking Before Manufacturing Route', ondelete='restrict')
+    pbm_route_id = fields.Many2one('stock.route', 'Picking Before Manufacturing Route', ondelete='restrict', copy=False)
 
     pbm_loc_id = fields.Many2one('stock.location', 'Picking before Manufacturing Location', check_company=True)
     sam_loc_id = fields.Many2one('stock.location', 'Stock after Manufacturing Location', check_company=True)
@@ -103,11 +104,9 @@ class StockWarehouse(models.Model):
         else:
             return super(StockWarehouse, self)._get_route_name(route_type)
 
-    def _get_global_route_rules_values(self):
-        rules = super(StockWarehouse, self)._get_global_route_rules_values()
-        location_src = self.manufacture_steps == 'mrp_one_step' and self.lot_stock_id or self.pbm_loc_id
+    def _generate_global_route_rules_values(self):
+        rules = super()._generate_global_route_rules_values()
         production_location = self._get_production_location()
-        location_id = self.manufacture_steps == 'pbm_sam' and self.sam_loc_id or self.lot_stock_id
         rules.update({
             'manufacture_pull_id': {
                 'depends': ['manufacture_steps', 'manufacture_to_resupply'],
@@ -116,12 +115,12 @@ class StockWarehouse(models.Model):
                     'procure_method': 'make_to_order',
                     'company_id': self.company_id.id,
                     'picking_type_id': self.manu_type_id.id,
-                    'route_id': self._find_global_route('mrp.route_warehouse0_manufacture', _('Manufacture')).id
+                    'route_id': self._find_global_route('mrp.route_warehouse0_manufacture', _('Manufacture'), raise_if_not_found=False).id
                 },
                 'update_values': {
                     'active': self.manufacture_to_resupply,
-                    'name': self._format_rulename(location_id, False, 'Production'),
-                    'location_id': location_id.id,
+                    'name': self._format_rulename(self.lot_stock_id, False, 'Production'),
+                    'location_dest_id': self.lot_stock_id.id,
                     'propagate_cancel': self.manufacture_steps == 'pbm_sam'
                 },
             },
@@ -132,13 +131,13 @@ class StockWarehouse(models.Model):
                     'company_id': self.company_id.id,
                     'action': 'pull',
                     'auto': 'manual',
-                    'route_id': self._find_global_route('stock.route_warehouse0_mto', _('Make To Order')).id,
-                    'location_id': production_location.id,
-                    'location_src_id': location_src.id,
+                    'route_id': self._find_global_route('stock.route_warehouse0_mto', _('Replenish on Order (MTO)'), raise_if_not_found=False).id,
+                    'location_dest_id': production_location.id,
+                    'location_src_id': self.lot_stock_id.id,
                     'picking_type_id': self.manu_type_id.id
                 },
                 'update_values': {
-                    'name': self._format_rulename(location_src, production_location, 'MTO'),
+                    'name': self._format_rulename(self.lot_stock_id, production_location, 'MTO'),
                     'active': self.manufacture_to_resupply,
                 },
             },
@@ -149,9 +148,9 @@ class StockWarehouse(models.Model):
                     'company_id': self.company_id.id,
                     'action': 'pull',
                     'auto': 'manual',
-                    'route_id': self._find_global_route('stock.route_warehouse0_mto', _('Make To Order')).id,
+                    'route_id': self._find_global_route('stock.route_warehouse0_mto', _('Replenish on Order (MTO)'), raise_if_not_found=False).id,
                     'name': self._format_rulename(self.lot_stock_id, self.pbm_loc_id, 'MTO'),
-                    'location_id': self.pbm_loc_id.id,
+                    'location_dest_id': self.pbm_loc_id.id,
                     'location_src_id': self.lot_stock_id.id,
                     'picking_type_id': self.pbm_type_id.id
                 },
@@ -159,30 +158,6 @@ class StockWarehouse(models.Model):
                     'active': self.manufacture_steps != 'mrp_one_step' and self.manufacture_to_resupply,
                 }
             },
-            # The purpose to move sam rule in the manufacture route instead of
-            # pbm_route_id is to avoid conflict with receipt in multiple
-            # step. For example if the product is manufacture and receipt in two
-            # step it would conflict in WH/Stock since product could come from
-            # WH/post-prod or WH/input. We do not have this conflict with
-            # manufacture route since it is set on the product.
-            'sam_rule_id': {
-                'depends': ['manufacture_steps', 'manufacture_to_resupply'],
-                'create_values': {
-                    'procure_method': 'make_to_order',
-                    'company_id': self.company_id.id,
-                    'action': 'pull',
-                    'auto': 'manual',
-                    'route_id': self._find_global_route('mrp.route_warehouse0_manufacture', _('Manufacture')).id,
-                    'name': self._format_rulename(self.sam_loc_id, self.lot_stock_id, False),
-                    'location_id': self.lot_stock_id.id,
-                    'location_src_id': self.sam_loc_id.id,
-                    'picking_type_id': self.sam_type_id.id
-                },
-                'update_values': {
-                    'active': self.manufacture_steps == 'pbm_sam' and self.manufacture_to_resupply,
-                }
-            }
-
         })
         return rules
 
@@ -198,19 +173,19 @@ class StockWarehouse(models.Model):
                 'name': _('Pre-Production'),
                 'active': manufacture_steps in ('pbm', 'pbm_sam'),
                 'usage': 'internal',
-                'barcode': self._valid_barcode(code + '-PREPRODUCTION', company_id)
+                'barcode': self._valid_barcode(code + 'PREPRODUCTION', company_id)
             },
             'sam_loc_id': {
                 'name': _('Post-Production'),
                 'active': manufacture_steps == 'pbm_sam',
                 'usage': 'internal',
-                'barcode': self._valid_barcode(code + '-POSTPRODUCTION', company_id)
+                'barcode': self._valid_barcode(code + 'POSTPRODUCTION', company_id)
             },
         })
         return values
 
-    def _get_sequence_values(self):
-        values = super(StockWarehouse, self)._get_sequence_values()
+    def _get_sequence_values(self, name=False, code=False):
+        values = super(StockWarehouse, self)._get_sequence_values(name=name, code=code)
         values.update({
             'pbm_type_id': {'name': self.name + ' ' + _('Sequence picking before manufacturing'), 'prefix': self.code + '/PC/', 'padding': 5, 'company_id': self.company_id.id},
             'sam_type_id': {'name': self.name + ' ' + _('Sequence stock after manufacturing'), 'prefix': self.code + '/SFP/', 'padding': 5, 'company_id': self.company_id.id},
@@ -259,21 +234,29 @@ class StockWarehouse(models.Model):
         data = super(StockWarehouse, self)._get_picking_type_update_values()
         data.update({
             'pbm_type_id': {
-                'active': self.manufacture_to_resupply and self.manufacture_steps in ('pbm', 'pbm_sam'),
-                'barcode': self.code.replace(" ", "").upper() + "-PC",
+                'active': self.manufacture_to_resupply and self.manufacture_steps in ('pbm', 'pbm_sam') and self.active,
+                'barcode': self.code.replace(" ", "").upper() + "PC",
             },
             'sam_type_id': {
-                'active': self.manufacture_to_resupply and self.manufacture_steps == 'pbm_sam',
-                'barcode': self.code.replace(" ", "").upper() + "-SFP",
+                'active': self.manufacture_to_resupply and self.manufacture_steps == 'pbm_sam' and self.active,
+                'barcode': self.code.replace(" ", "").upper() + "SFP",
             },
             'manu_type_id': {
-                'active': self.manufacture_to_resupply,
+                'active': self.manufacture_to_resupply and self.active,
+                'barcode': self.code.replace(" ", "").upper() + "MANUF",
                 'default_location_src_id': self.manufacture_steps in ('pbm', 'pbm_sam') and self.pbm_loc_id.id or self.lot_stock_id.id,
                 'default_location_dest_id': self.manufacture_steps == 'pbm_sam' and self.sam_loc_id.id or self.lot_stock_id.id,
             },
         })
         return data
 
+    def _create_missing_locations(self, vals):
+        super()._create_missing_locations(vals)
+        for company_id in self.company_id:
+            location = self.env['stock.location'].search([('usage', '=', 'production'), ('company_id', '=', company_id.id)], limit=1)
+            if not location:
+                company_id._create_production_location()
+
     def write(self, vals):
         if any(field in vals for field in ('manufacture_steps', 'manufacture_to_resupply')):
             for warehouse in self:
@@ -296,3 +279,25 @@ class StockWarehouse(models.Model):
             if warehouse.manufacture_pull_id and name:
                 warehouse.manufacture_pull_id.write({'name': warehouse.manufacture_pull_id.name.replace(warehouse.name, name, 1)})
         return res
+
+class Orderpoint(models.Model):
+    _inherit = "stock.warehouse.orderpoint"
+
+    @api.constrains('product_id')
+    def check_product_is_not_kit(self):
+        domain = [
+            '|', ('product_id', 'in', self.product_id.ids),
+                 '&', ('product_id', '=', False),
+                      ('product_tmpl_id', 'in', self.product_id.product_tmpl_id.ids),
+            ('type', '=', 'phantom'),
+        ]
+        if self.env['mrp.bom'].search_count(domain, limit=1):
+            raise ValidationError(_("A product with a kit-type bill of materials can not have a reordering rule."))
+
+    def _get_orderpoint_products(self):
+        non_kit_ids = []
+        for products in split_every(2000, super()._get_orderpoint_products().ids, self.env['product.product'].browse):
+            kit_ids = set(k.id for k in self.env['mrp.bom']._bom_find(products, bom_type='phantom').keys())
+            non_kit_ids.extend(id_ for id_ in products.ids if id_ not in kit_ids)
+            products.invalidate_recordset()
+        return self.env['product.product'].browse(non_kit_ids)
