PR: https://github.com/odoo/odoo/pull/

From: 0e4f3bb95991261c04c08e72b28430acfabdecd1
From: Fabien Pinckaers
Date: 2017-09-08 15:08:05

Breaking data model changes score: 6, change matches:
+    move_dest_ids = fields.One2many('stock.move', 'created_production_id')
-    procurement_ids = fields.One2many('procurement.order', 'production_id', 'Related Procurements')
-    _inherit = 'procurement.order'
-    bom_id = fields.Many2one('mrp.bom', 'BoM', index=True, ondelete='cascade')
-    production_id = fields.Many2one('mrp.production', 'Manufacturing Order')

Total Changes: 149

[IMP] stock: remove procurement orders to fufill immediately

This removes the procurement.order model. To fufill their needs SO, PO, MO and
stock moves now call the _run method of the relevant procurement.group.

This mecanism is now only used for stockable product, tasks now uses their own
independent mecanism.

The _run method will check all the applicable rules and create directly the
needed model to fufill the need.

The modules stock, purchase, mrp, extends the _run method to implement their
specific strategy relevant for the rule type they define.

If an exception happens the message will be logged as a mail messsage on the
source model, for example, if a sales order cannot be fufilled the salesperson
will now see directly the reason.

OLD commit messages:
[WIP] procurement: removing procurement.order in stock, sale, purchase, sale_stock. WIP
fixup! [WIP] procurement: removing procurement.order in stock, sale, purchase, sale_stock. WIP
[IMP] Basic tests
[FIX] test not necessary anymore
[FIX] remove unnecessary print statement
[FIX] unnecessary test + why passing warehouse worked before?
[IMP] purchase: one move by purchase order line
[FIX] purchase: correct inventory tests and pass move_dest_ids among procurements
[FIX] because of bad cherry-pick merge
[IMP] make mrp pass by adding move_dest_ids there too
[IMP] tests of sale_mrp, no need for cancelpropagation then
[IMP] better to consistently use recordsets also for one2many
[FIX] purchase_requisition
[FIX] Exceptions should trigger errors, which should be caught in the tests
[FIX] sale_mrp: remove usage of procurement.order and use sale order name instead of sol
[FIX] stock_dropshipping: add sale_line_id on purchase_line_id
[FIX] Remove pdb
[IMP] add stock_dropshipping files
[IMP] stock: search carrier through sale line instead of procurement group
[IMP] add procrule test and preision needed when updating sol
[FIX] sale_order_dates + [IMP] procurement exceptions by scheduler
[FIX] No need to return task
[IMP] move file as name changes and add corrections
[FIX] Continue Run Schedulers wizard fix
[FIX] name issues of takss
[FIX] updating sale order line, but there is still a problem with the recompute

================================= pseudo patch: =================================

--- a/addons/mrp/models/mrp_production.py
+++ b/addons/mrp/models/mrp_production.py
@@ -9,7 +9,6 @@ from odoo.addons import decimal_precision as dp
 from odoo.exceptions import UserError
 from odoo.tools import float_compare
 
-
 class MrpProduction(models.Model):
     """ Manufacturing Orders """
     _name = 'mrp.production'
@@ -112,6 +111,7 @@ class MrpProduction(models.Model):
         copy=False, oldname='workcenter_lines', readonly=True)
     workorder_count = fields.Integer('# Work Orders', compute='_compute_workorder_count')
     workorder_done_count = fields.Integer('# Done Work Orders', compute='_compute_workorder_done_count')
+    move_dest_ids = fields.One2many('stock.move', 'created_production_id')
 
     state = fields.Selection([
         ('confirmed', 'Confirmed'),
@@ -149,7 +149,6 @@ class MrpProduction(models.Model):
     procurement_group_id = fields.Many2one(
         'procurement.group', 'Procurement Group',
         copy=False)
-    procurement_ids = fields.One2many('procurement.order', 'production_id', 'Related Procurements')
     propagate = fields.Boolean(
         'Propagate cancel and split',
         help='If checked, when the previous move of the move (which was generated by a next procurement) is cancelled or split, the move generated by this move will too')
@@ -316,13 +315,12 @@ class MrpProduction(models.Model):
             'product_uom_qty': self.product_qty,
             'location_id': self.product_id.property_stock_production.id,
             'location_dest_id': self.location_dest_id.id,
-            'move_dest_ids': self.procurement_ids and [(4, p) for p in self.procurement_ids.mapped('move_dest_id').ids] or False,
-            'procurement_id': self.procurement_ids and self.procurement_ids[0].id or False,
             'company_id': self.company_id.id,
             'production_id': self.id,
             'origin': self.name,
             'group_id': self.procurement_group_id.id,
             'propagate': self.propagate,
+            'move_dest_ids': [(4, x.id) for x in self.move_dest_ids],
         })
         move.action_confirm()
         return move
@@ -493,7 +491,6 @@ class MrpProduction(models.Model):
         orders in exception """
         if any(workorder.state == 'progress' for workorder in self.mapped('workorder_ids')):
             raise UserError(_('You can not cancel production order, a work order is still in progress.'))
-        ProcurementOrder = self.env['procurement.order']
         for production in self:
             production.workorder_ids.filtered(lambda x: x.state != 'cancel').action_cancel()
 
@@ -501,13 +498,6 @@ class MrpProduction(models.Model):
             raw_moves = production.move_raw_ids.filtered(lambda x: x.state not in ('done', 'cancel'))
             (finish_moves | raw_moves).action_cancel()
 
-            procurements = ProcurementOrder.search([('move_dest_id', 'in', (finish_moves | raw_moves).ids)])
-            if procurements:
-                procurements.cancel()
-
-        # Put relatfinish_to_canceled procurements in exception -> I agree
-        ProcurementOrder.search([('production_id', 'in', self.ids)]).write({'state': 'exception'})
-
         self.write({'state': 'cancel'})
         return True
 
@@ -547,7 +537,6 @@ class MrpProduction(models.Model):
         moves_to_cancel = (self.move_raw_ids | self.move_finished_ids).filtered(lambda x: x.state not in ('done', 'cancel'))
         moves_to_cancel.action_cancel()
         self.write({'state': 'done', 'date_finished': fields.Datetime.now()})
-        self.env["procurement.order"].search([('production_id', 'in', self.ids)]).check()
         return self.write({'state': 'done'})
 
     @api.multi

--- a/addons/mrp/models/procurement.py
+++ b/addons/mrp/models/procurement.py
@@ -4,98 +4,74 @@
 from dateutil.relativedelta import relativedelta
 
 from odoo import api, fields, models, _
+from odoo.exceptions import UserError
 
 
 class ProcurementRule(models.Model):
     _inherit = 'procurement.rule'
+    action = fields.Selection(selection_add=[('manufacture', 'Manufacture')])
 
-    @api.model
-    def _get_action(self):
-        return [('manufacture', _('Manufacture'))] + super(ProcurementRule, self)._get_action()
-
-
-class ProcurementOrder(models.Model):
-    _inherit = 'procurement.order'
-
-    bom_id = fields.Many2one('mrp.bom', 'BoM', index=True, ondelete='cascade')
-    production_id = fields.Many2one('mrp.production', 'Manufacturing Order')
-
-    @api.multi
-    def propagate_cancels(self):
-        cancel_man_orders = self.filtered(lambda procurement: procurement.rule_id.action == 'manufacture' and procurement.production_id).mapped('production_id')
-        if cancel_man_orders:
-            cancel_man_orders.action_cancel()
-        return super(ProcurementOrder, self).propagate_cancels()
+class ProcurementGroup(models.Model):
+    _inherit = 'procurement.group'
 
     @api.multi
-    def _run(self):
-        self.ensure_one()
-        if self.rule_id.action == 'manufacture':
-            # make a manufacturing order for the procurement
-            return self.make_mo()[self.id]
-        return super(ProcurementOrder, self)._run()
+    def _run(self, values, rule, doraise=True):
+        if rule.action == 'manufacture':
+            Production = self.env['mrp.production']
+            ProductionSudo = Production.sudo().with_context(force_company=values['company_id'].id)
+            bom = self._get_matching_bom(values, rule)
+            if not bom:
+                msg = _('No Bill of Material found for product %s.') % (values['product_id'].display_name,)
+                if doraise:
+                    raise UserError(msg)
+                else:
+                    self.log_next_activity(values['product_id'], msg)
+                    return False
+
+            # create the MO as SUPERUSER because the current user may not have the rights to do it (mto product launched by a sale for example)
+            production = ProductionSudo.create(self._prepare_mo_vals(values, rule, bom))
+            origin_production = values.get('move_dest_ids') and values ['move_dest_ids'][0].raw_material_production_id or False
+            orderpoint = values.get('orderpoint_id')
+            if orderpoint:
+                production.message_post_with_view('mail.message_origin_link',
+                    values={'self': production, 'origin': orderpoint.id},
+                    subtype_id=self.env.ref('mail.mt_note').id)
+            if origin_production:
+                production.message_post_with_view('mail.message_origin_link',
+                    values={'self': production, 'origin': origin_production},
+                    subtype_id=self.env.ref('mail.mt_note').id)
+            return True
+        return super(ProcurementGroup, self)._run(values, rule, doraise)
 
     @api.multi
-    def _check(self):
-        return self.production_id.state == 'done' or super(ProcurementOrder, self)._check()
-
-    @api.multi
-    def _get_matching_bom(self):
-        """ Finds the bill of material for the product from procurement order. """
-        if self.bom_id:
-            return self.bom_id
+    def _get_matching_bom(self, values, rule):
+        if values.get('bom_id', False):
+            return values['bom_id']
         return self.env['mrp.bom'].with_context(
-            company_id=self.company_id.id, force_company=self.company_id.id
-        )._bom_find(product=self.product_id, picking_type=self.rule_id.picking_type_id)  # TDE FIXME: context bullshit
+            company_id=values['company_id'].id, force_company=values['company_id'].id
+        )._bom_find(product=values['product_id'], picking_type=rule.picking_type_id)  # TDE FIXME: context bullshit
 
-    def _get_date_planned(self):
-        format_date_planned = fields.Datetime.from_string(self.date_planned)
-        date_planned = format_date_planned - relativedelta(days=self.product_id.produce_delay or 0.0)
-        date_planned = date_planned - relativedelta(days=self.company_id.manufacturing_lead)
+    def _get_date_planned(self, values, rule):
+        format_date_planned = fields.Datetime.from_string(values['date_planned'])
+        date_planned = format_date_planned - relativedelta(days=values['product_id'].produce_delay or 0.0)
+        date_planned = date_planned - relativedelta(days=values['company_id'].manufacturing_lead)
         return date_planned
 
-    def _prepare_mo_vals(self, bom):
+    def _prepare_mo_vals(self, values, rule, bom):
         return {
-            'origin': self.origin,
-            'product_id': self.product_id.id,
-            'product_qty': self.product_qty,
-            'product_uom_id': self.product_uom.id,
-            'location_src_id': self.rule_id.location_src_id.id or self.location_id.id,
-            'location_dest_id': self.location_id.id,
+            'origin': values['origin'],
+            'product_id': values['product_id'].id,
+            'product_qty': values['product_qty'],
+            'product_uom_id': values['product_uom'].id,
+            'location_src_id': rule.location_src_id.id or values['location_id'].id,
+            'location_dest_id': values['location_id'].id,
             'bom_id': bom.id,
-            'date_planned_start': fields.Datetime.to_string(self._get_date_planned()),
-            'date_planned_finished': self.date_planned,
-            'procurement_group_id': self.group_id.id,
-            'propagate': self.rule_id.propagate,
-            'picking_type_id': self.rule_id.picking_type_id.id or self.warehouse_id.manu_type_id.id,
-            'company_id': self.company_id.id,
-            'procurement_ids': [(6, 0, [self.id])],
+            'date_planned_start': fields.Datetime.to_string(self._get_date_planned(values, rule)),
+            'date_planned_finished': values['date_planned'],
+            'procurement_group_id': values.get('group_id').id if values.get('group_id', False) else False,
+            'propagate': rule.propagate,
+            'picking_type_id': rule.picking_type_id.id or values['warehouse_id'].manu_type_id.id,
+            'company_id': values['company_id'].id,
+            'move_dest_ids': values.get('move_dest_ids') and [(4, x.id) for x in values['move_dest_ids']] or False,
         }
 
-    @api.multi
-    def make_mo(self):
-        """ Create production orders from procurements """
-        res = {}
-        Production = self.env['mrp.production']
-        for procurement in self:
-            ProductionSudo = Production.sudo().with_context(force_company=procurement.company_id.id)
-            bom = procurement._get_matching_bom()
-            if bom:
-                # create the MO as SUPERUSER because the current user may not have the rights to do it (mto product launched by a sale for example)
-                production = ProductionSudo.create(procurement._prepare_mo_vals(bom))
-                origin_production = procurement.move_dest_id.raw_material_production_id
-                orderpoint = procurement.orderpoint_id
-                if orderpoint:
-                    production.message_post_with_view('mail.message_origin_link',
-                        values={'self': production, 'origin': orderpoint},
-                        subtype_id=self.env.ref('mail.mt_note').id)
-                if origin_production:
-                    production.message_post_with_view('mail.message_origin_link',
-                        values={'self': production, 'origin': origin_production},
-                        subtype_id=self.env.ref('mail.mt_note').id)
-
-                res[procurement.id] = production.id
-            else:
-                res[procurement.id] = False
-                procurement.message_post(body=_("No BoM exists for this product!"))
-        return res

--- a/addons/mrp/models/stock_move.py
+++ b/addons/mrp/models/stock_move.py
@@ -42,6 +42,7 @@ class StockMoveLine(models.Model):
 class StockMove(models.Model):
     _inherit = 'stock.move'
 
+    created_production_id = fields.Many2one('mrp.production', 'Created Production Order')
     production_id = fields.Many2one(
         'mrp.production', 'Production Order for finished products')
     raw_material_production_id = fields.Many2one(
@@ -178,7 +179,6 @@ class StockMove(models.Model):
                 'product_uom_qty': quantity,
                 'state': 'draft',  # will be confirmed below
                 'name': self.name,
-                'procurement_id': self.procurement_id.id,
             })
         return self.env['stock.move']
 
