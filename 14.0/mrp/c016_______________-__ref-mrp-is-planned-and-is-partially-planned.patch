PR: https://github.com/odoo/odoo/pull/

From: 481f84953159837514ca4a0cdf825821fc37b6f0
From: Simon Lejeune
Date: 2020-09-25 07:30:48

Structural Changes: 3
Total Changes: 35

[REF] mrp: is_planned and is_partially_planned

the `planned` state was removed but still used in a bunch of places
make `is_planned` compute and use it instead

================================= pseudo patch: =================================

--- a/addons/mrp/models/mrp_production.py
+++ b/addons/mrp/models/mrp_production.py
@@ -4,6 +4,7 @@
 import json
 import datetime
 import math
+import operator as py_operator
 import re
 
 from collections import defaultdict
@@ -230,8 +231,7 @@ class MrpProduction(models.Model):
     scrap_ids = fields.One2many('stock.scrap', 'production_id', 'Scraps')
     scrap_count = fields.Integer(compute='_compute_scrap_move_count', string='Scrap Move')
     is_locked = fields.Boolean('Is Locked', default=_get_default_is_locked, copy=False)
-    is_planned = fields.Boolean('Its Operations are Planned', compute="_compute_is_planned")
-    is_partially_planned = fields.Boolean('One operation is Planned', compute="_compute_is_planned")
+    is_planned = fields.Boolean('Its Operations are Planned', compute='_compute_is_planned', search='_search_is_planned')
 
     show_final_lots = fields.Boolean('Show Final Lots', compute='_compute_show_lots')
     production_location_id = fields.Many2one('stock.location', "Production Location", compute="_compute_production_location", store=True)
@@ -314,14 +314,27 @@ class MrpProduction(models.Model):
         for production in self:
             production.move_finished_ids.date_deadline = production.date_deadline
 
+    @api.depends("workorder_ids.date_planned_start", "workorder_ids.date_planned_finished")
     def _compute_is_planned(self):
         for production in self:
             if production.workorder_ids:
-                production.is_planned = all(wo.date_planned_start and wo.date_planned_finished for wo in production.workorder_ids)
-                production.is_partially_planned = any(wo.date_planned_start and wo.date_planned_finished for wo in production.workorder_ids if production.state != 'draft')
+                production.is_planned = any(wo.date_planned_start and wo.date_planned_finished for wo in production.workorder_ids if wo.state != 'done')
             else:
                 production.is_planned = False
-                production.is_partially_planned = False
+
+    def _search_is_planned(self, operator, value):
+        if operator not in ('=', '!='):
+            raise UserError(_('Invalid domain operator %s', operator))
+
+        if value not in (False, True):
+            raise UserError(_('Invalid domain right operand %s', value))
+        ops = {'=': py_operator.eq, '!=': py_operator.ne}
+        ids = []
+        for mo in self.search([]):
+            if ops[operator](value, mo.is_planned):
+                ids.append(mo.id)
+
+        return [('id', 'in', ids)]
 
     @api.depends('move_raw_ids.delay_alert_date')
     def _compute_delay_alert_date(self):
@@ -487,7 +500,7 @@ class MrpProduction(models.Model):
             any_quantity_done = any(m.quantity_done > 0 for m in order.move_raw_ids)
 
             order.unreserve_visible = not any_quantity_done and already_reserved
-            order.reserve_visible = (order.is_planned or order.state in ('confirmed', 'progress', 'to_close')) and any(move.product_uom_qty and move.state in ['confirmed', 'partially_available'] for move in order.move_raw_ids)
+            order.reserve_visible = order.state in ('confirmed', 'progress', 'to_close') and any(move.product_uom_qty and move.state in ['confirmed', 'partially_available'] for move in order.move_raw_ids)
 
     @api.depends('workorder_ids.state', 'move_finished_ids', 'move_finished_ids.quantity_done')
     def _get_produced_qty(self):
@@ -701,7 +714,7 @@ class MrpProduction(models.Model):
             if 'date_planned_start' in vals and not self.env.context.get('force_date', False):
                 if production.state in ['done', 'cancel']:
                     raise UserError(_('You cannot move a manufacturing order once it is cancelled or done.'))
-                if production.is_partially_planned:
+                if any(wo.date_planned_start and wo.date_planned_finished for wo in production.workorder_ids):
                     raise UserError(_('You cannot move a manufacturing order once it has a planned workorder, move related workorder(s) instead.'))
             if vals.get('date_planned_start'):
                 production.move_raw_ids.write({'date': production.date_planned_start, 'date_deadline': production.date_planned_start})

--- a/addons/mrp/models/mrp_workorder.py
+++ b/addons/mrp/models/mrp_workorder.py
@@ -614,7 +614,11 @@ class MrpWorkorder(models.Model):
 
     def action_cancel(self):
         self.leave_id.unlink()
-        return self.write({'state': 'cancel'})
+        return self.write({
+            'state': 'cancel',
+            'date_planned_start': False,
+            'date_planned_finished': False,
+        })
 
     def action_replan(self):
         """Replan a work order.

--- a/addons/mrp/models/stock_picking.py
+++ b/addons/mrp/models/stock_picking.py
@@ -31,7 +31,7 @@ class StockPickingType(models.Model):
             return
         domains = {
             'count_mo_waiting': [('reservation_state', '=', 'waiting')],
-            'count_mo_todo': ['|', ('state', 'in', ('confirmed', 'draft', 'planned', 'progress'))],
+            'count_mo_todo': [('state', 'in', ('confirmed', 'draft', 'progress'))],
             'count_mo_late': [('date_planned_start', '<', fields.Date.today()), ('state', '=', 'confirmed')],
         }
         for field in domains:
