PR: https://github.com/odoo/odoo/pull/

From: 0a2f036d46b15661b690a0ccaf20a1310f7c33a7
From: Thibault DelavallÃ©e
Date: 2015-08-11 14:11:19

Structural Changes: 69
Total Changes: 570

[MOVE] event: reorganize files according to
the guidelines.

No change has been made in this commit, only file move and renaming.

================================= pseudo patch: =================================

--- a/None
+++ b/addons/event/models/__init__.py
@@ -0,0 +1,6 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+import event
+import event_mail
+import event_config_settings

--- a/None
+++ b/addons/event/models/event.py
@@ -0,0 +1,404 @@
+# -*- coding: utf-8 -*-
+
+import pytz
+
+from openerp import _, api, fields, models
+from openerp.exceptions import UserError
+
+
+class event_type(models.Model):
+    """ Event Type """
+    _name = 'event.type'
+    _description = 'Event Type'
+
+    name = fields.Char('Event Type', required=True, translate=True)
+    default_reply_to = fields.Char('Reply To')
+    default_registration_min = fields.Integer(
+        'Default Minimum Registration', default=0,
+        help="It will select this default minimum value when you choose this event")
+    default_registration_max = fields.Integer(
+        'Default Maximum Registration', default=0,
+        help="It will select this default maximum value when you choose this event")
+
+
+class event_event(models.Model):
+    """Event"""
+    _name = 'event.event'
+    _description = 'Event'
+    _inherit = ['mail.thread', 'ir.needaction_mixin']
+    _order = 'date_begin'
+
+    name = fields.Char(
+        string='Name', translate=True, required=True,
+        readonly=False, states={'done': [('readonly', True)]})
+    user_id = fields.Many2one(
+        'res.users', string='Responsible',
+        default=lambda self: self.env.user,
+        readonly=False, states={'done': [('readonly', True)]})
+    company_id = fields.Many2one(
+        'res.company', string='Company', change_default=True,
+        default=lambda self: self.env['res.company']._company_default_get('event.event'),
+        required=False, readonly=False, states={'done': [('readonly', True)]})
+    organizer_id = fields.Many2one(
+        'res.partner', string='Organizer',
+        default=lambda self: self.env.user.company_id.partner_id)
+    type = fields.Many2one(
+        'event.type', string='Category',
+        readonly=False, states={'done': [('readonly', True)]})
+    color = fields.Integer('Kanban Color Index')
+    event_mail_ids = fields.One2many('event.mail', 'event_id', string='Mail Schedule', default=lambda self: self._default_event_mail_ids())
+
+    @api.model
+    def _default_event_mail_ids(self):
+        return [(0, 0, {
+            'interval_unit': 'now',
+            'interval_type': 'after_sub',
+            'template_id': self.env.ref('event.event_subscription')
+        })]
+
+    # Seats and computation
+    seats_max = fields.Integer(
+        string='Maximum Available Seats', oldname='register_max',
+        readonly=True, states={'draft': [('readonly', False)], 'confirm': [('readonly', False)]},
+        help="For each event you can define a maximum registration of seats(number of attendees), above this numbers the registrations are not accepted.")
+    seats_availability = fields.Selection(
+        [('limited', 'Limited'), ('unlimited', 'Unlimited')],
+        'Available Seat', required=True, default='unlimited')
+    seats_min = fields.Integer(
+        string='Minimum Reservation of Seats Required', oldname='register_min',
+        help="For each event you can define a minimum reserved seats(number of attendees), if it does not reach the mentioned registrations the event can not be confirmed (keep 0 to ignore this rule)")
+    seats_reserved = fields.Integer(
+        oldname='register_current', string='Reserved Seats',
+        store=True, readonly=True, compute='_compute_seats')
+    seats_available = fields.Integer(
+        oldname='register_avail', string='Available Seats',
+        store=True, readonly=True, compute='_compute_seats')
+    seats_unconfirmed = fields.Integer(
+        oldname='register_prospect', string='Unconfirmed Seat Reservations',
+        store=True, readonly=True, compute='_compute_seats')
+    seats_used = fields.Integer(
+        oldname='register_attended', string='Number of Participants',
+        store=True, readonly=True, compute='_compute_seats')
+    seats_expected = fields.Integer(
+        string='Number of Expected Attendees',
+        readonly=True, compute='_compute_seats')
+
+    @api.multi
+    @api.depends('seats_max', 'registration_ids.state')
+    def _compute_seats(self):
+        """ Determine reserved, available, reserved but unconfirmed and used seats. """
+        # initialize fields to 0
+        for event in self:
+            event.seats_unconfirmed = event.seats_reserved = event.seats_used = event.seats_available = 0
+        # aggregate registrations by event and by state
+        if self.ids:
+            state_field = {
+                'draft': 'seats_unconfirmed',
+                'open': 'seats_reserved',
+                'done': 'seats_used',
+            }
+            query = """ SELECT event_id, state, count(event_id)
+                        FROM event_registration
+                        WHERE event_id IN %s AND state IN ('draft', 'open', 'done')
+                        GROUP BY event_id, state
+                    """
+            self._cr.execute(query, (tuple(self.ids),))
+            for event_id, state, num in self._cr.fetchall():
+                event = self.browse(event_id)
+                event[state_field[state]] += num
+        # compute seats_available
+        for event in self:
+            if event.seats_max > 0:
+                event.seats_available = event.seats_max - (event.seats_reserved + event.seats_used)
+            event.seats_expected = event.seats_unconfirmed + event.seats_reserved + event.seats_used
+
+    # Registration fields
+    registration_ids = fields.One2many(
+        'event.registration', 'event_id', string='Attendees',
+        readonly=False, states={'done': [('readonly', True)]})
+    # Date fields
+    date_tz = fields.Selection('_tz_get', string='Timezone', default=lambda self: self.env.user.tz)
+    date_begin = fields.Datetime(
+        string='Start Date', required=True,
+        readonly=True, states={'draft': [('readonly', False)]})
+    date_end = fields.Datetime(
+        string='End Date', required=True,
+        readonly=True, states={'draft': [('readonly', False)]})
+    date_begin_located = fields.Datetime(string='Start Date Located', compute='_compute_date_begin_tz')
+    date_end_located = fields.Datetime(string='End Date Located', compute='_compute_date_end_tz')
+
+    @api.model
+    def _tz_get(self):
+        return [(x, x) for x in pytz.all_timezones]
+
+    @api.one
+    @api.depends('date_tz', 'date_begin')
+    def _compute_date_begin_tz(self):
+        if self.date_begin:
+            self_in_tz = self.with_context(tz=(self.date_tz or 'UTC'))
+            date_begin = fields.Datetime.from_string(self.date_begin)
+            self.date_begin_located = fields.Datetime.to_string(fields.Datetime.context_timestamp(self_in_tz, date_begin))
+        else:
+            self.date_begin_located = False
+
+    @api.one
+    @api.depends('date_tz', 'date_end')
+    def _compute_date_end_tz(self):
+        if self.date_end:
+            self_in_tz = self.with_context(tz=(self.date_tz or 'UTC'))
+            date_end = fields.Datetime.from_string(self.date_end)
+            self.date_end_located = fields.Datetime.to_string(fields.Datetime.context_timestamp(self_in_tz, date_end))
+        else:
+            self.date_end_located = False
+
+    state = fields.Selection([
+        ('draft', 'Unconfirmed'), ('cancel', 'Cancelled'),
+        ('confirm', 'Confirmed'), ('done', 'Done')],
+        string='Status', default='draft', readonly=True, required=True, copy=False,
+        help="If event is created, the status is 'Draft'. If event is confirmed for the particular dates the status is set to 'Confirmed'. If the event is over, the status is set to 'Done'. If event is cancelled the status is set to 'Cancelled'.")
+    auto_confirm = fields.Boolean(string='Auto Confirmation Activated', compute='_compute_auto_confirm')
+
+    @api.one
+    def _compute_auto_confirm(self):
+        self.auto_confirm = self.env['ir.values'].get_default('event.config.settings', 'auto_confirmation')
+
+    reply_to = fields.Char(
+        'Reply-To Email', readonly=False, states={'done': [('readonly', True)]},
+        help="The email address of the organizer is likely to be put here, with the effect to be in the 'Reply-To' of the mails sent automatically at event or registrations confirmation. You can also put the email address of your mail gateway if you use one.")
+    address_id = fields.Many2one(
+        'res.partner', string='Location', default=lambda self: self.env.user.company_id.partner_id,
+        readonly=False, states={'done': [('readonly', True)]})
+    country_id = fields.Many2one('res.country', 'Country',  related='address_id.country_id', store=True)
+    description = fields.Html(
+        string='Description', oldname='note', translate=True,
+        readonly=False, states={'done': [('readonly', True)]})
+    # badge fields
+    badge_front = fields.Html(string='Badge Front')
+    badge_back = fields.Html(string='Badge Back')
+    badge_innerleft = fields.Html(string='Badge Innner Left')
+    badge_innerright = fields.Html(string='Badge Inner Right')
+    event_logo = fields.Html(string='Event Logo')
+
+    @api.multi
+    @api.depends('name', 'date_begin', 'date_end')
+    def name_get(self):
+        result = []
+        for event in self:
+            dates = [dt.split(' ')[0] for dt in [event.date_begin, event.date_end] if dt]
+            dates = sorted(set(dates))
+            result.append((event.id, '%s (%s)' % (event.name, ' - '.join(dates))))
+        return result
+
+    @api.one
+    @api.constrains('seats_max', 'seats_available')
+    def _check_seats_limit(self):
+        if self.seats_availability == 'limited' and self.seats_max and self.seats_available < 0:
+            raise UserError(_('No more available seats.'))
+
+    @api.one
+    @api.constrains('date_begin', 'date_end')
+    def _check_closing_date(self):
+        if self.date_end < self.date_begin:
+            raise UserError(_('Closing Date cannot be set before Beginning Date.'))
+
+    @api.model
+    def create(self, vals):
+        res = super(event_event, self).create(vals)
+        if res.organizer_id:
+            res.message_subscribe([res.organizer_id.id])
+        if res.auto_confirm:
+            res.button_confirm()
+        return res
+
+    @api.multi
+    def write(self, vals):
+        res = super(event_event, self).write(vals)
+        if vals.get('organizer_id'):
+            self.message_subscribe([vals['organizer_id']])
+        return res
+
+    @api.one
+    def button_draft(self):
+        self.state = 'draft'
+
+    @api.one
+    def button_cancel(self):
+        for event_reg in self.registration_ids:
+            if event_reg.state == 'done':
+                raise UserError(_("You have already set a registration for this event as 'Attended'. Please reset it to draft if you want to cancel this event."))
+        self.registration_ids.write({'state': 'cancel'})
+        self.state = 'cancel'
+
+    @api.one
+    def button_done(self):
+        self.state = 'done'
+
+    @api.one
+    def button_confirm(self):
+        self.state = 'confirm'
+
+    @api.onchange('type')
+    def _onchange_type(self):
+        if self.type:
+            self.seats_min = self.type.default_registration_min
+            self.seats_max = self.type.default_registration_max
+            self.reply_to = self.type.default_reply_to
+
+    @api.multi
+    def action_event_registration_report(self):
+        res = self.env['ir.actions.act_window'].for_xml_id('event', 'action_report_event_registration')
+        res['context'] = {
+            "search_default_event_id": self.id,
+            "group_by": ['create_date:day'],
+        }
+        return res
+
+    @api.one
+    def mail_attendees(self, template_id, force_send=False, filter_func=lambda self: True):
+        for attendee in self.registration_ids.filtered(filter_func):
+            self.env['mail.template'].browse(template_id).send_mail(attendee.id, force_send=force_send)
+
+
+class event_registration(models.Model):
+    _name = 'event.registration'
+    _description = 'Attendee'
+    _inherit = ['mail.thread', 'ir.needaction_mixin']
+    _order = 'name, create_date desc'
+
+    origin = fields.Char(
+        string='Source Document', readonly=True,
+        help="Reference of the document that created the registration, for example a sale order")
+    event_id = fields.Many2one(
+        'event.event', string='Event', required=True,
+        readonly=True, states={'draft': [('readonly', False)]})
+    partner_id = fields.Many2one(
+        'res.partner', string='Contact',
+        states={'done': [('readonly', True)]})
+    date_open = fields.Datetime(string='Registration Date', readonly=True, default=lambda self: fields.datetime.now())  # weird crash is directly now
+    date_closed = fields.Datetime(string='Attended Date', readonly=True)
+    event_begin_date = fields.Datetime(string="Event Start Date", related='event_id.date_begin', readonly=True)
+    event_end_date = fields.Datetime(string="Event End Date", related='event_id.date_end', readonly=True)
+    company_id = fields.Many2one(
+        'res.company', string='Company', related='event_id.company_id',
+        store=True, readonly=True, states={'draft': [('readonly', False)]})
+    state = fields.Selection([
+        ('draft', 'Unconfirmed'), ('cancel', 'Cancelled'),
+        ('open', 'Confirmed'), ('done', 'Attended')],
+        string='Status', default='draft', readonly=True, copy=False, track_visibility='onchange')
+    email = fields.Char(string='Email')
+    phone = fields.Char(string='Phone')
+    name = fields.Char(string='Attendee Name', select=True)
+
+    @api.one
+    @api.constrains('event_id', 'state')
+    def _check_seats_limit(self):
+        if self.event_id.seats_availability == 'limited' and self.event_id.seats_max and self.event_id.seats_available < (1 if self.state == 'draft' else 0):
+            raise UserError(_('No more seats available for this event.'))
+
+    @api.multi
+    def _check_auto_confirmation(self):
+        if self._context.get('registration_force_draft'):
+            return False
+        if any(registration.event_id.state != 'confirm' or
+               not registration.event_id.auto_confirm or
+               (not registration.event_id.seats_available and registration.event_id.seats_availability == 'limited') for registration in self):
+            return False
+        return True
+
+    @api.model
+    def create(self, vals):
+        registration = super(event_registration, self).create(vals)
+        if registration._check_auto_confirmation():
+            registration.sudo().confirm_registration()
+        return registration
+
+    @api.model
+    def _prepare_attendee_values(self, registration):
+        """ Method preparing the values to create new attendees based on a
+        sale order line. It takes some registration data (dict-based) that are
+        optional values coming from an external input like a web page. This method
+        is meant to be inherited in various addons that sell events. """
+        partner_id = registration.pop('partner_id', self.env.user.partner_id)
+        event_id = registration.pop('event_id', False)
+        data = {
+            'name': registration.get('name', partner_id.name),
+            'phone': registration.get('phone', partner_id.phone),
+            'email': registration.get('email', partner_id.email),
+            'partner_id': partner_id.id,
+            'event_id': event_id and event_id.id or False,
+        }
+        data.update({key: registration[key] for key in registration.keys() if key in self._fields})
+        return data
+
+    @api.one
+    def do_draft(self):
+        self.state = 'draft'
+
+    @api.one
+    def confirm_registration(self):
+        self.state = 'open'
+
+        # auto-trigger after_sub (on subscribe) mail schedulers, if needed
+        onsubscribe_schedulers = self.event_id.event_mail_ids.filtered(
+            lambda s: s.interval_type == 'after_sub')
+        onsubscribe_schedulers.execute()
+
+    @api.one
+    def button_reg_close(self):
+        """ Close Registration """
+        today = fields.Datetime.now()
+        if self.event_id.date_begin <= today:
+            self.write({'state': 'done', 'date_closed': today})
+        else:
+            raise UserError(_("You must wait for the starting day of the event to do this action."))
+
+    @api.one
+    def button_reg_cancel(self):
+        self.state = 'cancel'
+
+    @api.onchange('partner_id')
+    def _onchange_partner(self):
+        if self.partner_id:
+            contact_id = self.partner_id.address_get().get('default', False)
+            if contact_id:
+                contact = self.env['res.partner'].browse(contact_id)
+                self.name = self.name or contact.name
+                self.email = self.email or contact.email
+                self.phone = self.phone or contact.phone
+
+    @api.multi
+    def message_get_suggested_recipients(self):
+        recipients = super(event_registration, self).message_get_suggested_recipients()
+        for attendee in self:
+            if attendee.email:
+                attendee._message_add_suggested_recipient(recipients, email=attendee.email, reason=_('Customer Email'))
+            if attendee.partner_id:
+                attendee._message_add_suggested_recipient(recipients, partner=attendee.partner_id, reason=_('Customer'))
+        return recipients
+
+    @api.multi
+    def action_send_badge_email(self):
+        """ Open a window to compose an email, with the template - 'event_badge'
+            message loaded by default
+        """
+        self.ensure_one()
+        template = self.env.ref('event.event_registration_mail_template_badge')
+        compose_form = self.env.ref('mail.email_compose_message_wizard_form')
+        ctx = dict(
+            default_model='event.registration',
+            default_res_id=self.id,
+            default_use_template=bool(template),
+            default_template_id=template.id,
+            default_composition_mode='comment',
+        )
+        return {
+            'name': _('Compose Email'),
+            'type': 'ir.actions.act_window',
+            'view_type': 'form',
+            'view_mode': 'form',
+            'res_model': 'mail.compose.message',
+            'views': [(compose_form.id, 'form')],
+            'view_id': compose_form.id,
+            'target': 'new',
+            'context': ctx,
+        }

--- a/None
+++ b/addons/event/models/event_config_settings.py
@@ -0,0 +1,39 @@
+# -*- coding: utf-8 -*-
+
+from openerp.osv import fields, osv
+
+class event_config_settings(osv.TransientModel):
+    _name='event.config.settings'
+    _inherit='res.config.settings'
+    _columns = {
+        'module_event_sale': fields.selection([
+            (0, "All events are free"),
+            (1, 'Allow selling tickets')
+            ], "Tickets",
+            help='Install the event_sale module'),
+        'module_website_event_track': fields.selection([
+            (0, "No mini website per event"),
+            (1, 'Allow tracks, agenda and dedicated menus/website per event')
+            ], "Tracks and Agenda",
+            help='Install the module website_event_track'),
+        'module_website_event_questions': fields.selection([
+            (0, "No extra questions on subscriptions"),
+            (1, 'Allow adding extra questions on subscriptions')
+            ], "Subscription Survey",
+            help='Install the website_event_questions module'),
+        'auto_confirmation': fields.selection([
+            (1, 'No validation step on subscription'),
+            (0, "Manually confirm every subscription")
+            ], "Auto Confirmation",
+            help='Unselect this option to manually manage draft event and draft subscription'),
+        'group_email_scheduling': fields.selection([
+            (0, "No automated emails"),
+            (1, 'Schedule emails to attendees and subscribers')
+            ], "Email Scheduling",
+            help='You will be able to configure emails, and to schedule them to be automatically sent to the attendees on subscription and/or attendance',
+            implied_group='event.group_email_scheduling'),            
+    }
+
+    def set_default_auto_confirmation(self, cr, uid, ids, context=None):
+        config_value = self.browse(cr, uid, ids, context=context).auto_confirmation
+        self.pool.get('ir.values').set_default(cr, uid, 'event.config.settings', 'auto_confirmation', config_value)

--- a/None
+++ b/addons/event/models/event_mail.py
@@ -0,0 +1,121 @@
+# -*- coding: utf-8 -*-
+
+from datetime import datetime
+from dateutil.relativedelta import relativedelta
+
+from openerp import api, fields, models, tools
+
+
+_INTERVALS = {
+    'hours': lambda interval: relativedelta(hours=interval),
+    'days': lambda interval: relativedelta(days=interval),
+    'weeks': lambda interval: relativedelta(days=7*interval),
+    'months': lambda interval: relativedelta(months=interval),
+    'now': lambda interval: relativedelta(hours=0),
+}
+
+
+class EventMailScheduler(models.Model):
+    """ Event automated mailing. This model replaces all existing fields and
+    configuration allowing to send emails on events since Odoo 9. A cron exists
+    that periodically checks for mailing to run. """
+    _name = 'event.mail'
+
+    event_id = fields.Many2one('event.event', string='Event', required=True, ondelete='cascade')
+    sequence = fields.Integer('Display order')
+    interval_nbr = fields.Integer('Interval', default=1)
+    interval_unit = fields.Selection([
+        ('now', 'Immediately'),
+        ('hours', 'Hour(s)'), ('days', 'Day(s)'),
+        ('weeks', 'Week(s)'), ('months', 'Month(s)')],
+        string='Unit', default='hours', required=True)
+    interval_type = fields.Selection([
+        ('after_sub', 'After each subscription'),
+        ('before_event', 'Before the event'),
+        ('after_event', 'After the event')],
+        string='When to Run ', default="before_event", required=True)
+    template_id = fields.Many2one(
+        'mail.template', string='Email to Send',
+        domain=[('model', '=', 'event.registration')], required=True, ondelete='restrict',
+        help='This field contains the template of the mail that will be automatically sent')
+    scheduled_date = fields.Datetime('Scheduled Sent Mail', compute='_compute_scheduled_date', store=True)
+    mail_registration_ids = fields.One2many('event.mail.registration', 'scheduler_id')
+    mail_sent = fields.Boolean('Mail Sent on Event')
+    done = fields.Boolean('Sent', compute='_compute_done', store=True)
+
+    @api.one
+    @api.depends('mail_sent', 'interval_type', 'event_id.registration_ids', 'mail_registration_ids')
+    def _compute_done(self):
+        if self.interval_type in ['before_event', 'after_event']:
+            self.done = self.mail_sent
+        else:
+            self.done = len(self.mail_registration_ids) == len(self.event_id.registration_ids) and all(filter(lambda line: line.mail_sent, self.mail_registration_ids))
+
+    @api.one
+    @api.depends('event_id.state', 'event_id.date_begin', 'interval_type', 'interval_unit', 'interval_nbr')
+    def _compute_scheduled_date(self):
+        if self.event_id.state not in ['confirm', 'done']:
+            self.scheduled_date = False
+        else:
+            if self.interval_type == 'after_sub':
+                date, sign = self.event_id.create_date, 1
+            elif self.interval_type == 'before_event':
+                date, sign = self.event_id.date_begin, -1
+            else:
+                date, sign = self.event_id.date_end, 1
+
+            self.scheduled_date = datetime.strptime(date, tools.DEFAULT_SERVER_DATETIME_FORMAT) + _INTERVALS[self.interval_unit](sign * self.interval_nbr)
+
+    @api.one
+    def execute(self):
+        if self.interval_type == 'after_sub':
+            # update registration lines
+            lines = []
+            for registration in filter(lambda item: item not in [mail_reg.registration_id for mail_reg in self.mail_registration_ids], self.event_id.registration_ids):
+                lines.append((0, 0, {'registration_id': registration.id}))
+            if lines:
+                self.write({'mail_registration_ids': lines})
+            # execute scheduler on registrations
+            self.mail_registration_ids.filtered(lambda reg: reg.scheduled_date and reg.scheduled_date <= datetime.strftime(fields.datetime.now(), tools.DEFAULT_SERVER_DATETIME_FORMAT)).execute()
+        else:
+            if not self.mail_sent:
+                self.event_id.mail_attendees(self.template_id.id)
+                self.write({'mail_sent': True})
+        return True
+
+    @api.model
+    def run(self, autocommit=False):
+        schedulers = self.search([('done', '=', False), ('scheduled_date', '<=', datetime.strftime(fields.datetime.now(), tools.DEFAULT_SERVER_DATETIME_FORMAT))])
+        for scheduler in schedulers:
+            scheduler.execute()
+            if autocommit:
+                self.env.cr.commit()
+        return True
+
+
+class EventMailRegistration(models.Model):
+    _name = 'event.mail.registration'
+    _description = 'Registration Mail Scheduler'
+    _rec_name = 'scheduler_id'
+    _order = 'scheduled_date DESC'
+
+    scheduler_id = fields.Many2one('event.mail', 'Mail Scheduler', required=True, ondelete='cascade')
+    registration_id = fields.Many2one('event.registration', 'Attendee', required=True, ondelete='cascade')
+    scheduled_date = fields.Datetime('Scheduled Time', compute='_compute_scheduled_date', store=True)
+    mail_sent = fields.Boolean('Mail Sent')
+
+    @api.one
+    def execute(self):
+        if self.registration_id.state in ['open', 'done'] and not self.mail_sent:
+            self.scheduler_id.template_id.send_mail(self.registration_id.id)
+            self.write({'mail_sent': True})
+
+    @api.one
+    @api.depends('registration_id', 'scheduler_id.interval_unit', 'scheduler_id.interval_type')
+    def _compute_scheduled_date(self):
+        if self.registration_id:
+            date_open = self.registration_id.date_open
+            date_open_datetime = date_open and datetime.strptime(date_open, tools.DEFAULT_SERVER_DATETIME_FORMAT) or fields.datetime.now()
+            self.scheduled_date = date_open_datetime + _INTERVALS[self.scheduler_id.interval_unit](self.scheduler_id.interval_nbr)
+        else:
+            self.scheduled_date = False
