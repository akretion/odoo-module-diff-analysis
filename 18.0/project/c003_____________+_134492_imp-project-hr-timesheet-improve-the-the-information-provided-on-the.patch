PR: https://github.com/odoo/odoo/pull/134492

From: 606f710ebd611f33c677f89ca25effd691290a15
From: damr
Date: 2024-02-02 19:55:39

Structural Changes: 2
Total Changes: 74

[IMP] project, hr_timesheet: improve the the information provided on the

portal pages and the portal sharing wizard

This commit's purpose is to improve the informations displayed on the
projects and tasks pages (edit & read only) for portal users. This is
done by removing useless column when needed (milestones, timesheet), or
adding some information (adding a 'no group_by' when a group by is done
and some tasks/project does not have relevant data. Information about
the recurrence of tasks is also added for the collaborator of tasks.

The visual and behavior of the portal sharing wizard have also been
updated. Users are no longer set as collaborator for all the task of the
project when a project is shared in edit mode with them. Instead, only
the task for which the user is a customer have the user set as a
collaborator.

Details of the implmentation:
- some boolean value have been used to hide/show the column when needed
for the my/tasks view (e.a multiple_project)
- a new route has been added in order to allow the user to access a view
tree with all the recuring tasks relevant when he clicks on the
'recuring tasks' button on the edit form view of a task
- some fields were added to the task_readable field list in order to
display and compute the field relevant for the recurrence
- the ir.rules of the tasks have been updated in order to ensure that a
portal user have access to a task only if he is a follower of the
task. Being a follower of the project is no longer enough.
- some tests were added/updated to ensure of the task
visibility/sharing is handled correctly.

task - 3186700

closes odoo/odoo#134492

Related: odoo/enterprise#46993
Related: odoo/upgrade#5576
Signed-off-by: Xavier Bol (xbo) <xbo@odoo.com>

================================= pseudo patch: =================================

--- a/addons/project/models/project_project.py
+++ b/addons/project/models/project_project.py
@@ -124,8 +124,8 @@ class Project(models.Model):
             "A user with the project > administrator access right level can still access this project and its tasks, even if they are not explicitly part of the followers.\n\n"
             "- All internal users: all internal users can access the project and all of its tasks without distinction.\n\n"
             "- Invited portal users and all internal users: all internal users can access the project and all of its tasks without distinction.\n"
-            "When following a project, portal users will get access to all of its tasks without distinction. Otherwise, they will only get access to the specific tasks they are following.\n\n"
-            "When a project is shared in read-only, the portal user is redirected to their portal. They can view the tasks, but not edit them.\n"
+            "When following a project, portal users will only get access to the specific tasks they are following.\n\n"
+            "When a project is shared in read-only, the portal user is redirected to their portal. They can view the tasks they are following, but not edit them.\n"
             "When a project is shared in edit, the portal user is redirected to the kanban and list views of the tasks. They can modify a selected number of fields on the tasks.\n\n"
             "In any case, an internal user with no project access rights can still access a task, "
             "provided that they are given the corresponding URL (and that they are part of the followers if the project is private).")
@@ -358,7 +358,7 @@ class Project(models.Model):
     def _compute_access_instruction_message(self):
         for project in self:
             if project.privacy_visibility == 'portal':
-                project.access_instruction_message = _('Grant portal users access to your project or tasks by adding them as followers. Customers automatically get access to their tasks in their portal.')
+                project.access_instruction_message = _('Grant portal users access to your project by adding them as followers (the tasks of the project are not included). To grant access to tasks to a portal user, add them as followers for these tasks.')
             elif project.privacy_visibility == 'followers':
                 project.access_instruction_message = _('Grant employees access to your project or tasks by adding them as followers. Employees automatically get access to the tasks they are assigned to.')
             else:
@@ -647,6 +647,19 @@ class Project(models.Model):
         action['display_name'] = self.name
         return action
 
+    def action_open_share_project_wizard(self):
+        template = self.env.ref('project.mail_template_project_sharing', raise_if_not_found=False)
+
+        local_context = self.env.context | {
+            'default_template_id': template.id if template else False,
+            'default_email_layout_xmlid': 'mail.mail_notification_light',
+        }
+        action = self.env["ir.actions.actions"]._for_xml_id("project.project_share_wizard_action")
+        if self.env.context.get('default_access_mode'):
+            action['name'] = _("Share Project")
+        action['context'] = local_context
+        return action
+
     def toggle_favorite(self):
         favorite_projects = not_fav_projects = self.env['project.project'].sudo()
         for project in self:
@@ -964,3 +977,23 @@ class Project(models.Model):
                 'partner_id': collaborator.id,
             }) for collaborator in new_collaborators],
         })
+
+    def _add_followers(self, partners):
+        self.ensure_one()
+        self.message_subscribe(partners.ids)
+
+        dict_tasks_per_partner = {}
+        dict_partner_ids_to_subscribe_per_partner = {}
+        for task in self.task_ids:
+            if task.partner_id in dict_tasks_per_partner:
+                dict_tasks_per_partner[task.partner_id] |= task
+            else:
+                partner_ids_to_subscribe = [
+                    partner.id for partner in partners
+                    if partner == task.partner_id or partner in task.partner_id.child_ids
+                ]
+                if partner_ids_to_subscribe:
+                    dict_tasks_per_partner[task.partner_id] = task
+                    dict_partner_ids_to_subscribe_per_partner[task.partner_id] = partner_ids_to_subscribe
+        for partner, tasks in dict_tasks_per_partner.items():
+            tasks.message_subscribe(dict_partner_ids_to_subscribe_per_partner[partner])

--- a/addons/project/models/project_task.py
+++ b/addons/project/models/project_task.py
@@ -44,6 +44,12 @@ PROJECT_TASK_READABLE_FIELDS = {
     'dependent_tasks_count',
     'depend_on_ids',
     'depend_on_count',
+    'repeat_interval',
+    'repeat_unit',
+    'repeat_type',
+    'repeat_until',
+    'recurrence_id',
+    'recurring_count',
 }
 
 PROJECT_TASK_WRITABLE_FIELDS = {
@@ -252,18 +258,18 @@ class Task(models.Model):
     recurring_task = fields.Boolean(string="Recurrent")
     recurring_count = fields.Integer(string="Tasks in Recurrence", compute='_compute_recurring_count')
     recurrence_id = fields.Many2one('project.task.recurrence', copy=False)
-    repeat_interval = fields.Integer(string='Repeat Every', default=1, compute='_compute_repeat', readonly=False, groups="project.group_project_user")
+    repeat_interval = fields.Integer(string='Repeat Every', default=1, compute='_compute_repeat', compute_sudo=True, readonly=False)
     repeat_unit = fields.Selection([
         ('day', 'Days'),
         ('week', 'Weeks'),
         ('month', 'Months'),
         ('year', 'Years'),
-    ], default='week', compute='_compute_repeat', readonly=False, groups="project.group_project_user")
+    ], default='week', compute='_compute_repeat', compute_sudo=True, readonly=False)
     repeat_type = fields.Selection([
         ('forever', 'Forever'),
         ('until', 'Until'),
-    ], default="forever", string="Until", compute='_compute_repeat', readonly=False, groups="project.group_project_user")
-    repeat_until = fields.Date(string="End Date", compute='_compute_repeat', readonly=False, groups="project.group_project_user")
+    ], default="forever", string="Until", compute='_compute_repeat', compute_sudo=True, readonly=False)
+    repeat_until = fields.Date(string="End Date", compute='_compute_repeat', compute_sudo=True, readonly=False)
 
     # Account analytic
     analytic_account_id = fields.Many2one('account.analytic.account', ondelete='set null', compute='_compute_analytic_account_id', store=True, readonly=False,
@@ -1707,6 +1713,27 @@ class Task(models.Model):
             'domain': [('recurrence_id', 'in', self.recurrence_id.ids)],
         }
 
+    def action_project_sharing_recurring_tasks(self):
+        self.ensure_one()
+        recurrent_tasks = self.env['project.task'].search([('recurrence_id', 'in', self.recurrence_id.ids)])
+        # If all the recurrent tasks are in the same project, open the list view in sharing mode.
+        if recurrent_tasks.project_id == self.project_id:
+            action = self.env['ir.actions.act_window']._for_xml_id('project.project_sharing_project_task_recurring_tasks_action')
+            action.update({
+                'context': {'default_project_id': self.project_id.id},
+                'domain': [
+                    ('project_id', '=', self.project_id.id),
+                    ('recurrence_id', 'in', self.recurrence_id.ids)
+                ]
+            })
+            return action
+        # If at least one recurrent task belong to another project, open the portal page
+        return {
+            'name': 'Portal Recurrent Tasks',
+            'type': 'ir.actions.act_url',
+            'url':  f'/my/projects/{self.project_id.id}/task/{self.id}/recurrent_tasks',
+        }
+
     def action_open_ratings(self):
         self.ensure_one()
         action = self.env['ir.actions.act_window']._for_xml_id('project.rating_rating_action_task')
