PR: https://github.com/odoo/odoo/pull/

From: adedada349a17f3d91c45d85c95ca82d0c6e5907
From: Thibault DelavallÃ©e
Date: 2021-02-11 12:41:48

Structural Changes: 1
Total Changes: 89

[FIX] event: fix seats_limit and configuration stored editable computed fields compute method

RATIONALE

Stored editable fields receive their values either from compute either from
user input. If a user input is given to create / write compute method is not
called. If multiple fields are computed through the same method giving one
field value discard call to compute method and other fields are not called.

SPECIFICATIONS

Split ``_compute_from_event_type`` compute method so that event template
configuration  related fields are independent.

Fix seats_limited being computed in sevearl method which should not occur.

LINKS

COM PR #65688
Task ID-2455165

X-original-commit odoo/odoo@3c09e86b4e40009ca66c88f33b35cc374571085a

X-original-commit: ddc4ade6ad81c63efebd848ec56d197cd18e8041

================================= pseudo patch: =================================

--- a/addons/event/models/event_event.py
+++ b/addons/event/models/event_event.py
@@ -126,7 +126,7 @@ class EventEvent(models.Model):
         compute='_compute_event_mail_ids', readonly=False, store=True)
     tag_ids = fields.Many2many(
         'event.tag', string="Tags", readonly=False,
-        store=True, compute="_compute_from_event_type")
+        store=True, compute="_compute_tag_ids")
     # Kanban fields
     kanban_state = fields.Selection([('normal', 'In Progress'), ('done', 'Done'), ('blocked', 'Blocked')], default='normal')
     kanban_state_label = fields.Char(
@@ -141,7 +141,7 @@ class EventEvent(models.Model):
     # Seats and computation
     seats_max = fields.Integer(
         string='Maximum Attendees Number',
-        compute='_compute_from_event_type', readonly=False, store=True,
+        compute='_compute_seats_max', readonly=False, store=True,
         help="For each event you can define a maximum registration of seats(number of attendees), above this numbers the registrations are not accepted.")
     seats_limited = fields.Boolean('Maximum Attendees', required=True, compute='_compute_seats_limited',
                                    readonly=False, store=True)
@@ -162,7 +162,7 @@ class EventEvent(models.Model):
         compute_sudo=True, readonly=True, compute='_compute_seats_expected')
     # Registration fields
     auto_confirm = fields.Boolean(
-        string='Autoconfirmation', compute='_compute_from_event_type', readonly=False, store=True,
+        string='Autoconfirmation', compute='_compute_auto_confirm', readonly=False, store=True,
         help='Autoconfirm Registrations. Registrations will automatically be confirmed upon creation.')
     registration_ids = fields.One2many('event.registration', 'event_id', string='Attendees')
     event_ticket_ids = fields.One2many(
@@ -344,52 +344,47 @@ class EventEvent(models.Model):
             if not event.date_tz:
                 event.date_tz = self.env.user.tz or 'UTC'
 
-    @api.depends('event_type_id')
-    def _compute_seats_limited(self):
-        """ Make it separate from ``_compute_from_event_type`` because otherwise
-        a value given at create (see create override) would protect all other fields
-        depending on event type id from being computed as compute method will be
-        blacklisted during create (see ``registry.field_computed`` attribute used in create
-        to compute protected field from re-computation) """
-        for event in self:
-            if event.event_type_id.seats_max:
-                event.seats_limited = True
-            if not event.seats_limited:
-                event.seats_limited = False
+    # seats
 
     @api.depends('event_type_id')
-    def _compute_from_event_type(self):
+    def _compute_seats_max(self):
         """ Update event configuration from its event type. Depends are set only
-        on event_type_id itself, not its sub fields. Indeed purpose is to emulate
-        an onchange: if event type is changed, update event configuration. Changing
-        event type content itself should not trigger this method.
-
-        Updated by this method
-          * seats_max -> triggers _compute_seats (all seats computation)
-          * seats_limited
-          * auto_confirm
-          * tag_ids
-        """
+        on event_type_id itself, not its sub fields. Purpose is to emulate an
+        onchange: if event type is changed, update event configuration. Changing
+        event type content itself should not trigger this method. """
         for event in self:
             if not event.event_type_id:
-                if not event.seats_max:
-                    event.seats_max = 0
-                continue
-
-            event.seats_max = event.event_type_id.seats_max
+                event.seats_max = event.seats_max or 0
+            else:
+                event.seats_max = event.event_type_id.seats_max or 0
 
+    @api.depends('event_type_id')
+    def _compute_seats_limited(self):
+        """ Update event configuration from its event type. Depends are set only
+        on event_type_id itself, not its sub fields. Purpose is to emulate an
+        onchange: if event type is changed, update event configuration. Changing
+        event type content itself should not trigger this method. """
+        for event in self:
             if event.event_type_id.has_seats_limitation != event.seats_limited:
                 event.seats_limited = event.event_type_id.has_seats_limitation
+            if not event.seats_limited:
+                event.seats_limited = False
 
+    @api.depends('event_type_id')
+    def _compute_auto_confirm(self):
+        """ Update event configuration from its event type. Depends are set only
+        on event_type_id itself, not its sub fields. Purpose is to emulate an
+        onchange: if event type is changed, update event configuration. Changing
+        event type content itself should not trigger this method. """
+        for event in self:
             event.auto_confirm = event.event_type_id.auto_confirm
-            if not event.tag_ids and event.event_type_id.tag_ids:
-                event.tag_ids = event.event_type_id.tag_ids
 
     @api.depends('event_type_id')
     def _compute_event_mail_ids(self):
-        """ Update event mails from its event type. Depends are set only on
-        event_type_id itself to emulate an onchange. Changing event type content
-        itself should not trigger this method.
+        """ Update event configuration from its event type. Depends are set only
+        on event_type_id itself, not its sub fields. Purpose is to emulate an
+        onchange: if event type is changed, update event configuration. Changing
+        event type content itself should not trigger this method.
 
         When synchronizing mails:
 
@@ -414,11 +409,22 @@ class EventEvent(models.Model):
             if command:
                 event.event_mail_ids = command
 
+    @api.depends('event_type_id')
+    def _compute_tag_ids(self):
+        """ Update event configuration from its event type. Depends are set only
+        on event_type_id itself, not its sub fields. Purpose is to emulate an
+        onchange: if event type is changed, update event configuration. Changing
+        event type content itself should not trigger this method. """
+        for event in self:
+            if not event.tag_ids and event.event_type_id.tag_ids:
+                event.tag_ids = event.event_type_id.tag_ids
+
     @api.depends('event_type_id')
     def _compute_event_ticket_ids(self):
-        """ Update event tickets from its event type. Depends are set only on
-        event_type_id itself to emulate an onchange. Changing event type content
-        itself should not trigger this method.
+        """ Update event configuration from its event type. Depends are set only
+        on event_type_id itself, not its sub fields. Purpose is to emulate an
+        onchange: if event type is changed, update event configuration. Changing
+        event type content itself should not trigger this method.
 
         When synchronizing tickets:
 
@@ -484,7 +490,7 @@ class EventEvent(models.Model):
     @api.model_create_multi
     def create(self, vals_list):
         for vals in vals_list:
-            # Temporary fix for ``seats_limited`` and ``date_tz`` required fields (see ``_compute_from_event_type``
+            # Temporary fix for ``seats_limited`` and ``date_tz`` required fields
             vals.update(self._sync_required_computed(vals))
 
         events = super(EventEvent, self).create(vals_list)
@@ -513,7 +519,8 @@ class EventEvent(models.Model):
         missing_fields = list(set(['seats_limited', 'date_tz']).difference(set(values.keys())))
         if missing_fields and values:
             cache_event = self.new(values)
-            cache_event._compute_from_event_type()
+            cache_event._compute_seats_limited()
+            cache_event._compute_date_tz()
             return dict((fname, cache_event[fname]) for fname in missing_fields)
         else:
             return {}
