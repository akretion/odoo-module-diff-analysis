PR: https://github.com/odoo/odoo/pull/

From: f8e80cf47d672384d7311572edd4b6e083e4b398
From: Thibault Delavall√©e
Date: 2020-01-30 15:18:08

Structural Changes: 8
Total Changes: 72

[REF] event: improve ticket type / ticket event fields propagation

PURPOSE

This commit is part of ticket model support directly in event application.

SPECIFICATIONS 1: remove date fields from event.type.ticket

Coming from old ticket implementation there are several unused fields on
event.type.ticket, notably dates about selling. Indeed tickets defined on
event.type are templates and should not be time bound.

Previously those fields were available on event.type tickets but not propagated
to the event tickets. Now they are not available anymore, simplifying models.
We therefore remove them from event.type.ticket model.

SPECIFICATIONS 2: propagate seats definition from ticket template to tickets

Previously to the global feature this commit is a member of, only ticket name,
product and price were copied from event.type to its events. Description has
been added in a previous commit. In this commit we also propagate maximum
seats availability.

Use case is linked to event.type defining a recurring event in a given
location. As seats availability is known it can be copied on all events
linked to this event type.

SPECIFICATIONS 3: improve naming of event tickets

Before this commit, all tickets of an event were labeled the same way
by default, using simply ``<event_name>``. This is annoying when
having several tickets as they had all the same name.

In this commit we fix that behavior by setting the name

  * directly from the ticket template when tickets come from an event.type.
    Configuring Standard and VIP tickets on an event type will therefore
    give Standard and VIP tickets on event;
  * generic 'Registration for <event_name>' when adding manually a new ticket
    for an event;

LINKS

Task ID 2177281
Community PR #43488

================================= pseudo patch: =================================

--- a/addons/event/models/event_event.py
+++ b/addons/event/models/event_event.py
@@ -307,7 +307,6 @@ class EventEvent(models.Model):
                         (attribute_name, ticket[attribute_name] if not isinstance(ticket[attribute_name], models.BaseModel) else ticket[attribute_name].id)
                         for attribute_name in self.env['event.type.ticket']._get_event_ticket_fields_whitelist()
                     )
-                    ticket_vals['name'] = self.name and _('Registration for %s') % self.name or ticket.name
                     all_ticket_values.append(ticket_vals)
 
                 self.event_ticket_ids = [(5, 0, 0)] + [(0, 0, item) for item in all_ticket_values]

--- a/addons/event/models/event_ticket.py
+++ b/addons/event/models/event_ticket.py
@@ -18,11 +18,6 @@ class EventTemplateTicket(models.Model):
         help="A description of the ticket that you want to communicate to your customers.")
     event_type_id = fields.Many2one(
         'event.type', string='Event Category', ondelete='cascade', required=True)
-    # sale
-    start_sale_date = fields.Date(string="Registration Start")
-    end_sale_date = fields.Date(string="Registration End")
-    is_expired = fields.Boolean(string='Is Expired', compute='_compute_is_expired')
-    sale_available = fields.Boolean(string='Is Available', compute='_compute_sale_available')
     # seats
     seats_availability = fields.Selection([
         ('limited', 'Limited'), ('unlimited', 'Unlimited')], string='Seats Limit',
@@ -32,44 +27,16 @@ class EventTemplateTicket(models.Model):
         help="Define the number of available tickets. If you have too many registrations you will "
              "not be able to sell tickets anymore. Set 0 to ignore this rule set as unlimited.")
 
-    @api.depends('end_sale_date', 'event_type_id')
-    def _compute_is_expired(self):
-        for ticket in self:
-            if ticket.end_sale_date:
-                current_date = fields.Date.context_today(ticket.with_context(tz=ticket._get_ticket_tz()))
-                ticket.is_expired = ticket.end_sale_date < current_date
-            else:
-                ticket.is_expired = False
-
-    @api.depends('start_sale_date', 'end_sale_date', 'event_type_id')
-    def _compute_sale_available(self):
-        for ticket in self:
-            current_date = fields.Date.context_today(ticket.with_context(tz=ticket._get_ticket_tz()))
-            if (ticket.start_sale_date and ticket.start_sale_date > current_date) or \
-                    ticket.end_sale_date and ticket.end_sale_date < current_date:
-                ticket.sale_available = False
-            else:
-                ticket.sale_available = True
-
     @api.depends('seats_max')
     def _compute_seats_availability(self):
         for ticket in self:
             ticket.seats_availability = 'limited' if ticket.seats_max else 'unlimited'
 
-    @api.constrains('start_sale_date', 'end_sale_date')
-    def _constrains_dates_coherency(self):
-        for ticket in self:
-            if ticket.start_sale_date and ticket.end_sale_date and ticket.start_sale_date > ticket.end_sale_date:
-                raise UserError(_('The stop date cannot be earlier than the start date.'))
-
-    def _get_ticket_tz(self):
-        return self.event_type_id.use_timezone and self.event_type_id.default_timezone or self.env.user.tz
-
     @api.model
     def _get_event_ticket_fields_whitelist(self):
         """ Whitelist of fields that are copied from event_type_ticket_ids to event_ticket_ids when
         changing the event_type_id field of event.event """
-        return ['name', 'description']
+        return ['name', 'description', 'seats_max']
 
 
 class EventTicket(models.Model):
@@ -81,6 +48,13 @@ class EventTicket(models.Model):
     _inherit = 'event.type.ticket'
     _description = 'Event Ticket'
 
+    @api.model
+    def default_get(self, fields):
+        res = super(EventTicket, self).default_get(fields)
+        if 'name' in fields and (not res.get('name') or res['name'] == _('Registration')) and self.env.context.get('default_event_name'):
+            res['name'] = _('Registration for %s') % self.env.context['default_event_name']
+        return res
+
     # description
     event_type_id = fields.Many2one(ondelete='set null', required=False)
     event_id = fields.Many2one(
@@ -88,6 +62,10 @@ class EventTicket(models.Model):
         ondelete='cascade', required=True)
     company_id = fields.Many2one('res.company', related='event_id.company_id')
     # sale
+    start_sale_date = fields.Date(string="Registration Start")
+    end_sale_date = fields.Date(string="Registration End")
+    is_expired = fields.Boolean(string='Is Expired', compute='_compute_is_expired')
+    sale_available = fields.Boolean(string='Is Available', compute='_compute_sale_available')
     registration_ids = fields.One2many('event.registration', 'event_ticket_id', string='Registrations')
     # seats
     seats_reserved = fields.Integer(string='Reserved Seats', compute='_compute_seats', store=True)
@@ -95,6 +73,25 @@ class EventTicket(models.Model):
     seats_unconfirmed = fields.Integer(string='Unconfirmed Seats', compute='_compute_seats', store=True)
     seats_used = fields.Integer(string='Used Seats', compute='_compute_seats', store=True)
 
+    @api.depends('end_sale_date', 'event_id.date_tz')
+    def _compute_is_expired(self):
+        for ticket in self:
+            if ticket.end_sale_date:
+                current_date = fields.Date.context_today(ticket.with_context(tz=ticket._get_ticket_tz()))
+                ticket.is_expired = ticket.end_sale_date < current_date
+            else:
+                ticket.is_expired = False
+
+    @api.depends('start_sale_date', 'end_sale_date', 'event_id.date_tz')
+    def _compute_sale_available(self):
+        for ticket in self:
+            current_date = fields.Date.context_today(ticket.with_context(tz=ticket._get_ticket_tz()))
+            if (ticket.start_sale_date and ticket.start_sale_date > current_date) or \
+                    ticket.end_sale_date and ticket.end_sale_date < current_date:
+                ticket.sale_available = False
+            else:
+                ticket.sale_available = True
+
     @api.depends('seats_max', 'registration_ids.state')
     def _compute_seats(self):
         """ Determine reserved, available, reserved but unconfirmed and used seats. """
@@ -123,6 +120,12 @@ class EventTicket(models.Model):
             if ticket.seats_max > 0:
                 ticket.seats_available = ticket.seats_max - (ticket.seats_reserved + ticket.seats_used)
 
+    @api.constrains('start_sale_date', 'end_sale_date')
+    def _constrains_dates_coherency(self):
+        for ticket in self:
+            if ticket.start_sale_date and ticket.end_sale_date and ticket.start_sale_date > ticket.end_sale_date:
+                raise UserError(_('The stop date cannot be earlier than the start date.'))
+
     @api.constrains('seats_available', 'seats_max')
     def _constrains_seats_available(self):
         if any(record.seats_max and record.seats_available < 0 for record in self):
