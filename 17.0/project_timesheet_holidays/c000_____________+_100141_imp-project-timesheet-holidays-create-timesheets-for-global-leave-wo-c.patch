PR: https://github.com/odoo/odoo/pull/100141

From: fdb692c25b50e84c2a0563fbbe026917f1249e3d
From: Kartik Chavda
Date: 2023-04-03 15:07:07

Structural Changes: 2
Total Changes: 97

[IMP] project_timesheet_holidays: create timesheets for global leave wo calendar

Before this commit when user create a global without calendar then
it'll not create any timesheets for any employee but global leave
without calendar is taken as leave global leave for all calendar
in that company's calendar and should create timesheet for all
calendars employee in company.

This commit create timesheets for all calendars employee in that
company if global leave does not have specific calendar set on it.

task-2969791

Part-of: odoo/odoo#100141

================================= pseudo patch: =================================

--- a/addons/project_timesheet_holidays/models/hr_employee.py
+++ b/addons/project_timesheet_holidays/models/hr_employee.py
@@ -34,14 +34,16 @@ class Employee(models.Model):
 
     def _create_future_public_holidays_timesheets(self, employees):
         lines_vals = []
+        today = fields.Datetime.today()
+        global_leaves_wo_calendar = self.env['resource.calendar.leaves'].search([('calendar_id', '=', False), ('date_from', '>=', today)])
         for employee in employees:
             if not employee.active:
                 continue
             # First we look for the global time off that are already planned after today
-            global_leaves = employee.resource_calendar_id.global_leave_ids.filtered(lambda l: l.date_from >= fields.Datetime.today())
+            global_leaves = employee.resource_calendar_id.global_leave_ids.filtered(lambda l: l.date_from >= today) + global_leaves_wo_calendar
             work_hours_data = global_leaves._work_time_per_day()
             for global_time_off in global_leaves:
-                for index, (day_date, work_hours_count) in enumerate(work_hours_data[global_time_off.id]):
+                for index, (day_date, work_hours_count) in enumerate(work_hours_data[employee.resource_calendar_id.id][global_time_off.id]):
                     lines_vals.append(
                         global_time_off._timesheet_prepare_line_values(
                             index,

--- a/addons/project_timesheet_holidays/models/resource_calendar_leaves.py
+++ b/addons/project_timesheet_holidays/models/resource_calendar_leaves.py
@@ -12,7 +12,15 @@ class ResourceCalendarLeaves(models.Model):
 
     timesheet_ids = fields.One2many('account.analytic.line', 'global_leave_id', string="Analytic Lines")
 
-    def _work_time_per_day(self):
+    def _get_resource_calendars(self):
+        leaves_with_calendar = self.filtered('calendar_id')
+        calendars = leaves_with_calendar.calendar_id
+        leaves_wo_calendar = self - leaves_with_calendar
+        if leaves_wo_calendar:
+            calendars += self.env['resource.calendar'].search([('company_id', 'in', leaves_wo_calendar.company_id.ids)])
+        return calendars
+
+    def _work_time_per_day(self, resource_calendars=False):
         """ Get work time per day based on the calendar and its attendances
 
             1) Gets all calendars with their characteristics (i.e.
@@ -32,6 +40,7 @@ class ResourceCalendarLeaves(models.Model):
                     }
                 }
         """
+        resource_calendars = resource_calendars or self._get_resource_calendars()
         leaves_read_group = self.env['resource.calendar.leaves']._read_group(
             [('id', 'in', self.ids)],
             ['calendar_id', 'ids:array_agg(id)', 'resource_ids:array_agg(resource_id)', 'min_date_from:min(date_from)', 'max_date_to:max(date_to)'],
@@ -39,21 +48,27 @@ class ResourceCalendarLeaves(models.Model):
         )
         # dict of keys: calendar_id
         #   and values : { 'date_from': datetime, 'date_to': datetime, resources: self.env['resource.resource'] }
-        cal_attendance_intervals_dict = {
-            res['calendar_id'][0]: {
+        cal_attendance_intervals_dict = {}
+        for res in leaves_read_group:
+            calendar_data = {
                 'date_from': utc.localize(res['min_date_from']),
                 'date_to': utc.localize(res['max_date_to']),
                 'resources': self.env['resource.resource'].browse(res['resource_ids'] if res['resource_ids'] and res['resource_ids'][0] else []),
                 'leaves': self.env['resource.calendar.leaves'].browse(res['ids']),
-            } for res in leaves_read_group
-        }
+            }
+            if not res.get('calendar_id', False):
+                for calendar_id in resource_calendars.ids:
+                    cal_attendance_intervals_dict[calendar_id] = calendar_data
+            else:
+                cal_attendance_intervals_dict[res['calendar_id'][0]] = calendar_data
         # to easily find the calendar with its id.
-        calendars_dict = {calendar.id: calendar for calendar in self.calendar_id}
+        calendars_dict = {calendar.id: calendar for calendar in resource_calendars}
 
-        # dict of keys: leave.id
-        #   and values: a dict of keys: date
-        #                   and values: number of days
-        results = defaultdict(lambda: defaultdict(float))
+        # dict of keys: calendar_id
+        #   and values: a dict of keys: leave.id
+        #         and values: a dict of keys: date
+        #              and values: number of days
+        results = defaultdict(lambda: defaultdict(lambda: defaultdict(float)))
         for calendar_id, cal_attendance_intervals_params_entry in cal_attendance_intervals_dict.items():
             calendar = calendars_dict[calendar_id]
             work_hours_intervals = calendar._attendance_intervals_batch(
@@ -69,8 +84,8 @@ class ResourceCalendarLeaves(models.Model):
                     if date_to > utc.localize(leave.date_from) and date_from < utc.localize(leave.date_to):
                         tmp_start = max(date_from, utc.localize(leave.date_from))
                         tmp_end = min(date_to, utc.localize(leave.date_to))
-                        results[leave.id][tmp_start.date()] += (tmp_end - tmp_start).total_seconds() / 3600
-                results[leave.id] = sorted(results[leave.id].items())
+                        results[calendar_id][leave.id][tmp_start.date()] += (tmp_end - tmp_start).total_seconds() / 3600
+                results[calendar_id][leave.id] = sorted(results[calendar_id][leave.id].items())
         return results
 
     def _timesheet_create_lines(self):
@@ -78,9 +93,10 @@ class ResourceCalendarLeaves(models.Model):
 
             If the employee has already a time off in the same day then no timesheet should be created.
         """
-        work_hours_data = self._work_time_per_day()
+        resource_calendars = self._get_resource_calendars()
+        work_hours_data = self._work_time_per_day(resource_calendars)
         employees_groups = self.env['hr.employee']._read_group(
-            [('resource_calendar_id', 'in', self.calendar_id.ids)],
+            [('resource_calendar_id', 'in', resource_calendars.ids)],
             ['resource_calendar_id', 'ids:array_agg(id)'],
             ['resource_calendar_id'])
         mapped_employee = {
@@ -91,13 +107,14 @@ class ResourceCalendarLeaves(models.Model):
         employee_ids_set.update(*[line['ids'] for line in employees_groups])
         min_date = max_date = None
         for values in work_hours_data.values():
-            for d, dummy in values:
-                if not min_date and not max_date:
-                    min_date = max_date = d
-                elif d < min_date:
-                    min_date = d
-                elif d > max_date:
-                    max_date = d
+            for vals in values.values():
+                for d, dummy in vals:
+                    if not min_date and not max_date:
+                        min_date = max_date = d
+                    elif d < min_date:
+                        min_date = d
+                    elif d > max_date:
+                        max_date = d
 
         holidays_read_group = self.env['hr.leave']._read_group([
             ('employee_id', 'in', list(employee_ids_set)),
@@ -111,10 +128,10 @@ class ResourceCalendarLeaves(models.Model):
             ] for line in holidays_read_group
         }
         vals_list = []
-        for leave in self:
-            for employee in mapped_employee.get(leave.calendar_id.id, self.env['hr.employee']):
+
+        def get_timesheets_data(employees, work_hours_list, vals_list):
+            for employee in employees:
                 holidays = holidays_by_employee.get(employee.id)
-                work_hours_list = work_hours_data[leave.id]
                 for index, (day_date, work_hours_count) in enumerate(work_hours_list):
                     if not holidays or all(not (date_from <= day_date and date_to >= day_date) for date_from, date_to in holidays):
                         vals_list.append(
@@ -126,6 +143,18 @@ class ResourceCalendarLeaves(models.Model):
                                 work_hours_count
                             )
                         )
+            return vals_list
+
+        for leave in self:
+            if not leave.calendar_id:
+                for calendar_id, calendar_employees in mapped_employee.items():
+                    work_hours_list = work_hours_data[calendar_id][leave.id]
+                    vals_list = get_timesheets_data(calendar_employees, work_hours_list, vals_list)
+            else:
+                employees = mapped_employee.get(leave.calendar_id.id, self.env['hr.employee'])
+                work_hours_list = work_hours_data[leave.calendar_id.id][leave.id]
+                vals_list = get_timesheets_data(employees, work_hours_list, vals_list)
+
         return self.env['account.analytic.line'].sudo().create(vals_list)
 
     def _timesheet_prepare_line_values(self, index, employee_id, work_hours_data, day_date, work_hours_count):
@@ -143,24 +172,26 @@ class ResourceCalendarLeaves(models.Model):
             'company_id': employee_id.company_id.id,
         }
 
+    def _generate_timesheeets(self):
+        results_with_leave_timesheet = self.filtered(lambda r: not r.resource_id and r.company_id.internal_project_id and r.company_id.leave_timesheet_task_id)
+        if results_with_leave_timesheet:
+            results_with_leave_timesheet._timesheet_create_lines()
+
     @api.model_create_multi
     def create(self, vals_list):
         results = super(ResourceCalendarLeaves, self).create(vals_list)
-        results_with_leave_timesheet = results.filtered(lambda r: not r.resource_id.id and r.calendar_id.company_id.internal_project_id and r.calendar_id.company_id.leave_timesheet_task_id)
-        results_with_leave_timesheet and results_with_leave_timesheet._timesheet_create_lines()
+        results._generate_timesheeets()
         return results
 
     def write(self, vals):
         date_from, date_to, calendar_id = vals.get('date_from'), vals.get('date_to'), vals.get('calendar_id')
         global_time_off_updated = self.env['resource.calendar.leaves']
         if date_from or date_to or 'calendar_id' in vals:
-            global_time_off_updated = self.filtered(lambda r: (date_from is not None and r.date_from != date_from) or (date_to is not None and r.date_to != date_to) or (calendar_id is not None and r.calendar_id.id != calendar_id))
+            global_time_off_updated = self.filtered(lambda r: (date_from is not None and r.date_from != date_from) or (date_to is not None and r.date_to != date_to) or (calendar_id is None or r.calendar_id.id != calendar_id))
             timesheets = global_time_off_updated.sudo().timesheet_ids
             if timesheets:
                 timesheets.write({'global_leave_id': False})
                 timesheets.unlink()
         result = super(ResourceCalendarLeaves, self).write(vals)
-        if global_time_off_updated:
-            global_time_offs_with_leave_timesheet = global_time_off_updated.filtered(lambda r: not r.resource_id and r.calendar_id.company_id.internal_project_id and r.calendar_id.company_id.leave_timesheet_task_id)
-            global_time_offs_with_leave_timesheet.sudo()._timesheet_create_lines()
+        global_time_off_updated and global_time_off_updated.sudo()._generate_timesheeets()
         return result
