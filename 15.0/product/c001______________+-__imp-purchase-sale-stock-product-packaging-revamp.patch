PR: https://github.com/odoo/odoo/pull/

From: 688d65530575a6b2a69db404e3f11aaf84ef0035
From: yhu-odoo
Date: 2021-05-06 13:36:28

Structural Changes: 4
Total Changes: 50

[IMP] {purchase, sale}_stock, product: packaging revamp

1. add packaging to PO lines
2. packaging on PO/SO lines can be propagate to MO
3. add package type to packaging
4. on picking types, we can choose to only reserve full packaging. That
means if you want 1 pallet(100 units) and you have 50 units in stock. It
won't be reserved.
5. suggest suitable packaging for PO/SO/MO line according to the product
qty

Task-2357259
PR #68654
UPG PR odoo/upgrade#2444

================================= pseudo patch: =================================

--- a/addons/product/models/product.py
+++ b/addons/product/models/product.py
@@ -9,7 +9,7 @@ from odoo.exceptions import UserError, ValidationError
 from odoo.osv import expression
 
 
-from odoo.tools import float_compare
+from odoo.tools import float_compare, float_round
 
 _logger = logging.getLogger(__name__)
 
@@ -719,17 +719,59 @@ class ProductProduct(models.Model):
 class ProductPackaging(models.Model):
     _name = "product.packaging"
     _description = "Product Packaging"
-    _order = 'sequence'
+    _order = 'product_id, sequence, id'
     _check_company_auto = True
 
-    name = fields.Char('Package Type', required=True)
+    name = fields.Char('Product Packaging', required=True)
     sequence = fields.Integer('Sequence', default=1, help="The first in the sequence is the default one.")
     product_id = fields.Many2one('product.product', string='Product', check_company=True)
-    qty = fields.Float('Contained Quantity', help="Quantity of products contained in the packaging.")
+    qty = fields.Float('Contained Quantity', default=1, help="Quantity of products contained in the packaging.")
     barcode = fields.Char('Barcode', copy=False, help="Barcode used for packaging identification. Scan this packaging barcode from a transfer in the Barcode app to move all the contained units")
     product_uom_id = fields.Many2one('uom.uom', related='product_id.uom_id', readonly=True)
     company_id = fields.Many2one('res.company', 'Company', index=True)
 
+    _sql_constraints = [
+        ('positive_qty', 'CHECK(qty > 0)', 'Contained Quantity should be positive.')
+    ]
+
+    def _check_qty(self, product_qty, uom_id, rounding_method="HALF-UP"):
+        """Check if product_qty in given uom is a multiple of the packaging qty.
+        If not, rounding the product_qty to closest multiple of the packaging qty
+        according to the rounding_method "UP", "HALF-UP or "DOWN".
+        """
+        self.ensure_one()
+        default_uom = self.product_id.uom_id
+        packaging_qty = default_uom._compute_quantity(self.qty, uom_id)
+        # We do not use the modulo operator to check if qty is a mltiple of q. Indeed the quantity
+        # per package might be a float, leading to incorrect results. For example:
+        # 8 % 1.6 = 1.5999999999999996
+        # 5.4 % 1.8 = 2.220446049250313e-16
+        if (
+            product_qty
+            and packaging_qty
+            and float_compare(
+                product_qty / packaging_qty,
+                float_round(product_qty / packaging_qty, precision_rounding=1.0),
+                precision_rounding=default_uom.rounding
+            )
+            != 0
+        ):
+            return float_round(
+                product_qty / packaging_qty, precision_rounding=1.0, rounding_method=rounding_method
+            ) * packaging_qty
+        return product_qty
+
+    def _find_suitable_product_packaging(self, product_qty, uom_id):
+        """ try find in `self` if a packaging's qty in given uom is a divisor of
+        the given product_qty. If so, return the one with greatest divisor.
+        """
+        packagings = self.sorted(lambda p: p.qty, reverse=True)
+        for packaging in packagings:
+            new_qty = packaging._check_qty(product_qty, uom_id)
+            if new_qty == product_qty:
+                return packaging
+        return self.env['product.packaging']
+
 
 class SupplierInfo(models.Model):
     _name = "product.supplierinfo"
