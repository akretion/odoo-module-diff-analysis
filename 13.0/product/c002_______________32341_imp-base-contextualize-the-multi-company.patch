PR: https://github.com/odoo/odoo/pull/32341

From: a5b6f31cf28e5381e1c85f66730bcdb55998e643
From: Yannick Tivisse
Date: 2019-05-13 08:57:49

Structural Changes: 1.8
Total Changes: 32

[IMP] base: Contextualize the multi company

Purpose
=======

Allow the user to select the allowed companies for which he wants to see records
on top of selecting his current company.

It is confusing for users to see the records from the company he is connected to
and the records of the children companies.

Instead of using the hierarchy of companies to access records across companies,
the user can now select (from his set of allowed companies) the companies for
which he wants to access records.

/!\ This means that the user will interact with records from company A when in
company B.
Example: a SO has been created and confirmed in A. When in B, I create the
invoice from it.

Specifications
==============

1/ Deprecate the parent/children hierarchy on the res.company model. The fields are
kept on the res.company model to ensure the retro-compatibility, but won't be used
accross the standard code anymore. The only functional usage for this mechanism
was to allow to see records from several companies by creating a virtual parent
company, which will be possible with the new mechanism.

2/ By default, a user will only see the records of the company he is connected
to (or records without a company). (It is still editable by the user if needed).
For that, put this information in the user context, to allow having different
configurations on different browser tabs. Instead of having domains like
['|',
('company_id', '=', False),
('company_id', 'child_of', user.company_id.id)]
you'll have something like
['|',
('company_id', '=', False),
('company_id', 'in', company_ids)]
Note that the 'company_ids' is a value that is passed in the evaluation
context on the record rule, as we already have user, or time.
company_ids is a list of the ids of all the enabled companies in the
user's context.

3/ Out of the generic improvements brought by this task, this will illustrate
issues that could exist since several versions. For example, it should not be
possible to create a scrap order for the company A with a package of the company
B, or it should not be possible to create an invoice on the company A with
payment terms from the company B. Before the version 12.0, it was easy to
encounter this kind of issues as the admin was the SUPERUSER_ID. A positive side
effect of the fact that the SUPERUSER_ID has become an inactive user was to
make it more difficult to introduce mismatch on the records, but haven't solved
the issue, as it was still possible to do it with parent companies
configuration. Some of these issues have been fixed in this commit, but all the
business flows should be re-tested to check if an ir.rule should be introduced
(eg: a multi company rule for stock.quand.package), if the company of a record
is correctly transfered to another record created from the first record (eg:
From a SO, create an invoice and a payment, the company of the sales order
should be transfered on the invoice and the payment, even if the company of the
sales order is A and I'm logged into the company B with the company A enabled.

4/ Currently, if I click on a button on a notification email (example 'View
Task'), I face a traceback if I'm not logged into the company of the record.
Now, if you click on a button and if you have access to the record, the correct
company will be automatically set.

5/ If I display a kanban view with several records from several companies (and
an image), all the images should be displayed.

6/ Currently if you copy paste an url, this will crash if you're not in the
correct company. This won't be fixed because it's quite impossible to do it in
a clean way. This task brings a workaround. Copy/Paste -> Traceback -> Log into
the correct company, re-copy/paste -> Ok.

7/ 2 property methods have been added on the environment to retrieve the company
on which the user is logged in and the companies the user enabled, on a specific
tab.
That way, when creating a record, instead of doing
default=lambda self: self.env.user.company_id
do
default=lambda self: self.env.company_id
On the other hand, to retrieve the enabled companies, do
companies = self.env.company_ids

8/ Modify the Company Switcher widget to allow to log into another company
WITHOUT writing on the res.users (and thus bringing cache invalidation issues
and so on). Also allow to enable several companies and see records from several
companies, and independantly of the other browser's tabs.

9/ When focusing on a tab, save the current company configuration on the local
storage. That way, when doing 'CTRL+T' or a middle click, the context is
propagated to the new tab.

10/ Improve the error message in case of multi company access errors. Now, when
the user is in debug mode, display the related names of the records and the name
of the user who brings the issue.

11/ Remove the context erasing when writing on a res.users
This is probably coming from the migration to new API of the base module.
The context was not propagated at this moment, which was a common mistake at
that time. When migrating the module, probably by using the 'black box' method,
as the context was not propagated, it was erased on the new version. This is
now an issue because the context (i.e. the enabled companies) was erased when
writing on a res.users, leading to tracebacks.
See: https://github.com/odoo/odoo/commit/7eab8e26d3d46c53f4be924d6a34e80a66e74960#diff-4c2e738ee8f64f11806c889ea097b5e7R624

12/ Fix the crash manager on redirect warnings. The issue is the following
- Create an invoice on a company without a configured CoA.
- Set a partner
- On the onchange_partner_id, a redirect warning is raised to propose you
to configure a CoA
- Click on 'Go to the configuration panel'
- A generic warning says something like 'Do you want to discard your changes?'
- Click on yes, the page refreshes, but not on the redirect action.
Now, set correctly the action on the hash, and reload instead. The breadcrumb is
lost for example, but you reach the correct action at least.

13/ Introduce a res.group to enable/disable the multi company per tab
feature.

14/ To help the users to know which tab is in which company, add the
possibility to have a favicon per company. When creating a company,
the classical 'O' icon is colored by default in a random color.

15/ Remove the company switcher on the frontend. This was mainly there
to allow a user to swicth to the company linked to the website.
This behavior is now transparent to the user. If the website A is
activated, then the company set on the context is the company of the
website.

16/ Deprecated the _company_default_get method on the res.company
model. Remove the method _get_company on the res.users model.

17/ Add 'allowed_company_ids' and 'current_company_id' on the pyeval
context. You can now use those variables on domains in the views to
access directly to the activated company.ies on the current tab.

TaskID: 1960971

closes odoo/odoo#32341

Signed-off-by: Yannick Tivisse (yti) <yti@odoo.com>

================================= pseudo patch: =================================

--- a/addons/product/models/decimal_precision.py
+++ b/addons/product/models/decimal_precision.py
@@ -11,7 +11,7 @@ class DecimalPrecision(models.Model):
     @api.constrains('digits')
     def _check_main_currency_rounding(self):
         if any(precision.name == 'Account' and
-                tools.float_compare(self.env.user.company_id.currency_id.rounding, 10 ** - precision.digits, precision_digits=6) == -1
+                tools.float_compare(self.env.company_id.currency_id.rounding, 10 ** - precision.digits, precision_digits=6) == -1
                 for precision in self):
             raise ValidationError(_("You cannot define the decimal precision of 'Account' as greater than the rounding factor of the company's main currency"))
         return True

--- a/addons/product/models/product.py
+++ b/addons/product/models/product.py
@@ -71,7 +71,7 @@ class ProductPriceHistory(models.Model):
     _description = 'Product Price List History'
 
     def _get_default_company_id(self):
-        return self._context.get('force_company', self.env.user.company_id.id)
+        return self._context.get('force_company', self.env.company_id.id)
 
     company_id = fields.Many2one('res.company', string='Company',
         default=_get_default_company_id, required=True)
@@ -651,7 +651,7 @@ class ProductProduct(models.Model):
             # standard_price field can only be seen by users in base.group_user
             # Thus, in order to compute the sale price from the cost for users not in this group
             # We fetch the standard price as the superuser
-            products = self.with_context(force_company=company and company.id or self._context.get('force_company', self.env.user.company_id.id)).sudo()
+            products = self.with_context(force_company=company and company.id or self._context.get('force_company', self.env.company_id.id)).sudo()
 
         prices = dict.fromkeys(self.ids, 0.0)
         for product in products:
@@ -689,7 +689,7 @@ class ProductProduct(models.Model):
             PriceHistory.create({
                 'product_id': product.id,
                 'cost': value,
-                'company_id': self._context.get('force_company', self.env.user.company_id.id),
+                'company_id': self._context.get('force_company', self.env.company_id.id),
             })
 
     @api.multi
@@ -814,10 +814,10 @@ class SupplierInfo(models.Model):
         required=True, help="The price to purchase a product")
     company_id = fields.Many2one(
         'res.company', 'Company',
-        default=lambda self: self.env.user.company_id.id, index=1)
+        default=lambda self: self.env.company_id.id, index=1)
     currency_id = fields.Many2one(
         'res.currency', 'Currency',
-        default=lambda self: self.env.user.company_id.currency_id.id,
+        default=lambda self: self.env.company_id.currency_id.id,
         required=True)
     date_start = fields.Date('Start Date', help="Start date for this vendor price")
     date_end = fields.Date('End Date', help="End date for this vendor price")

--- a/addons/product/models/product_pricelist.py
+++ b/addons/product/models/product_pricelist.py
@@ -15,7 +15,7 @@ class Pricelist(models.Model):
     _order = "sequence asc, id desc"
 
     def _get_default_currency_id(self):
-        return self.env.user.company_id.currency_id.id
+        return self.env.company_id.currency_id.id
 
     def _get_default_item_ids(self):
         ProductPricelistItem = self.env['product.pricelist.item']
@@ -221,7 +221,7 @@ class Pricelist(models.Model):
 
                 if rule.base == 'pricelist' and rule.base_pricelist_id:
                     price_tmp = rule.base_pricelist_id._compute_price_rule([(product, qty, partner)])[product.id][0]  # TDE: 0 = price, 1 = rule
-                    price = rule.base_pricelist_id.currency_id._convert(price_tmp, self.currency_id, self.env.user.company_id, date, round=False)
+                    price = rule.base_pricelist_id.currency_id._convert(price_tmp, self.currency_id, self.env.company_id, date, round=False)
                 else:
                     # if base option is public price take sale price else cost price of product
                     # price_compute returns the price in the context UoM, i.e. qty_uom_id
@@ -260,7 +260,7 @@ class Pricelist(models.Model):
                     cur = product.cost_currency_id
                 else:
                     cur = product.currency_id
-                price = cur._convert(price, self.currency_id, self.env.user.company_id, date, round=False)
+                price = cur._convert(price, self.currency_id, self.env.company_id, date, round=False)
 
             results[product.id] = (price, suitable_rule and suitable_rule.id or False)
 
@@ -353,7 +353,7 @@ class Pricelist(models.Model):
         # as we will do a search() later (real case for website public user).
         Partner = self.env['res.partner'].with_context(active_test=False)
 
-        Property = self.env['ir.property'].with_context(force_company=company_id or self.env.user.company_id.id)
+        Property = self.env['ir.property'].with_context(force_company=company_id or self.env.company_id.id)
         Pricelist = self.env['product.pricelist']
         pl_domain = self._get_partner_pricelist_multi_search_domain_hook()
 

--- a/addons/product/models/product_template.py
+++ b/addons/product/models/product_template.py
@@ -109,7 +109,7 @@ class ProductTemplate(models.Model):
         help="Default unit of measure used for purchase orders. It must be in the same category as the default unit of measure.")
     company_id = fields.Many2one(
         'res.company', 'Company',
-        default=lambda self: self.env['res.company']._company_default_get('product.template'), index=1)
+        default=lambda self: self.env.company_id, index=1)
     packaging_ids = fields.One2many(
         'product.packaging', string="Product Packages", compute="_compute_packaging_ids", inverse="_set_packaging_ids",
         help="Gives the different ways to package the same product.")
@@ -168,7 +168,7 @@ class ProductTemplate(models.Model):
 
     def _compute_cost_currency_id(self):
         for template in self:
-            template.cost_currency_id = self.env.user.company_id.currency_id.id
+            template.cost_currency_id = self.env.company_id.currency_id.id
 
     @api.multi
     def _compute_template_price(self):
@@ -450,12 +450,12 @@ class ProductTemplate(models.Model):
             # standard_price field can only be seen by users in base.group_user
             # Thus, in order to compute the sale price from the cost for users not in this group
             # We fetch the standard price as the superuser
-            templates = self.with_context(force_company=company and company.id or self._context.get('force_company', self.env.user.company_id.id)).sudo()
+            templates = self.with_context(force_company=company and company.id or self._context.get('force_company', self.env.company_id.id)).sudo()
         if not company:
             if self._context.get('force_company'):
                 company = self.env['res.company'].browse(self._context['force_company'])
             else:
-                company = self.env.user.company_id
+                company = self.env.company_id
         date = self.env.context.get('date') or fields.Date.today()
 
         prices = dict.fromkeys(self.ids, 0.0)
@@ -1090,7 +1090,7 @@ class ProductTemplate(models.Model):
         :rtype: recordset of one `res.company`
         """
         self.ensure_one()
-        return self.env.user.company_id
+        return self.env.company_id
 
     @api.model
     def get_empty_list_help(self, help):

--- a/addons/product/models/res_partner.py
+++ b/addons/product/models/res_partner.py
@@ -34,7 +34,7 @@ class Partner(models.Model):
         # update at each change country, and so erase old pricelist
         if self.property_product_pricelist or (actual and default_for_country and default_for_country.id != actual.id):
             # keep the company of the current user before sudo
-            self.env['ir.property'].with_context(force_company=self.env.user.company_id.id).sudo().set_multi(
+            self.env['ir.property'].with_context(force_company=self.env.company_id.id).sudo().set_multi(
                 'property_product_pricelist',
                 self._name,
                 {self.id: self.property_product_pricelist or default_for_country.id},
