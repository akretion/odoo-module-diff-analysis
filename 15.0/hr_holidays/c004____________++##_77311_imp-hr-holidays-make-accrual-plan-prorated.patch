PR: https://github.com/odoo/odoo/pull/77311

From: 55428da85fdd5317207ea22e348afe8dba43988a
From: William Braeckman
Date: 2021-09-28 12:20:11

Structural Changes: 6
Total Changes: 307

[IMP] hr_holidays: make accrual plan prorated

This commit adds the necessary logic to make accrual plans prorated
compared to the period they represent.
For example:
- You have an accrual plan that gives 5 days every week on monday.
- You create a new allocation on a wednesday.
- On the monday following the creation of the allocation the allocation
  will receive 3/5 * 5 days (3 days) instead of 5 since the 'period'
  required for the full 5 days was not completed.

TaskId-2637489

Part-of: odoo/odoo#77311

================================= pseudo patch: =================================

--- a/addons/hr_holidays/models/hr_leave_accrual_plan_level.py
+++ b/addons/hr_holidays/models/hr_leave_accrual_plan_level.py
@@ -5,23 +5,25 @@ import datetime
 import calendar
 
 from dateutil.relativedelta import relativedelta
+from num2words import num2words
 
-from odoo import api, fields, models
+from odoo import _, api, fields, models
 from odoo.tools.date_utils import get_timedelta
+from odoo.tools.misc import get_lang
 
 
 DAYS = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat']
 MONTHS = ['jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul', 'aug', 'sep', 'oct', 'nov', 'dec']
+# Used for displaying the days and reversing selection -> integer
+DAY_SELECT_VALUES = [str(i) for i in range(1, 29)] + ['last']
 
-def _get_date_check_month(year, month, day):
-    """
-    Returns the day it would be if day is outside of the month's range
-    Example: 2021 feb 30 -> 2021 mar 2
-    """
-    month_range = calendar.monthrange(year, month)
-    if day > month_range[1]:
-        return datetime.date(year, month, month_range[1]) + relativedelta(days=(day - month_range[1]))
-    return datetime.date(year, month, day)
+def _get_selection_days(self):
+    lang = get_lang(self.env).code
+    return [
+        (DAY_SELECT_VALUES[i - 1],
+        num2words(i, lang=lang, to='ordinal_num') if i < 29 else _('last day'))
+        for i in range(1, 30)
+    ]
 
 class AccrualPlanLevel(models.Model):
     _name = "hr.leave.accrual.level"
@@ -70,8 +72,14 @@ class AccrualPlanLevel(models.Model):
         ('sun', 'Sunday'),
     ], default='mon', required=True, string="Allocation on")
     first_day = fields.Integer(default=1)
+    first_day_display = fields.Selection(
+        _get_selection_days, compute='_compute_days_display', inverse='_inverse_first_day_display')
     second_day = fields.Integer(default=15)
+    second_day_display = fields.Selection(
+        _get_selection_days, compute='_compute_days_display', inverse='_inverse_second_day_display')
     first_month_day = fields.Integer(default=1)
+    first_month_day_display = fields.Selection(
+        _get_selection_days, compute='_compute_days_display', inverse='_inverse_first_month_day_display')
     first_month = fields.Selection([
         ('jan', 'January'),
         ('feb', 'February'),
@@ -81,6 +89,8 @@ class AccrualPlanLevel(models.Model):
         ('jun', 'June'),
     ], default="jan")
     second_month_day = fields.Integer(default=1)
+    second_month_day_display = fields.Selection(
+        _get_selection_days, compute='_compute_days_display', inverse='_inverse_second_month_day_display')
     second_month = fields.Selection([
         ('jul', 'July'),
         ('aug', 'Augustus'),
@@ -104,6 +114,8 @@ class AccrualPlanLevel(models.Model):
         ('dec', 'December')
     ], default="jan")
     yearly_day = fields.Integer(default=1)
+    yearly_day_display = fields.Selection(
+        _get_selection_days, compute='_compute_days_display', inverse='_inverse_yearly_day_display')
     maximum_leave = fields.Float(
         'Limit to', required=False, default=100,
         help="Choose a maximum limit of days for this accrual. 0 means no limit.")
@@ -125,7 +137,7 @@ class AccrualPlanLevel(models.Model):
          "(first_month_day > 0 AND first_month_day <= 31 AND second_month_day > 0 AND second_month_day <= 31 AND frequency = 'biyearly') or "
          "(yearly_day > 0 AND yearly_day <= 31 AND frequency = 'yearly'))",
          "The dates you've set up aren't correct. Please check them."),
-        ('start_count_check', "CHECK( start_count >= 1 )", "You must start after more than 0 days."),
+        ('start_count_check', "CHECK( start_count >= 0 )", "You can not start an accrual in the past."),
         ('added_value_greater_than_zero', 'CHECK(added_value > 0)', 'You must give the gain greater than 0 in accrual plan levels.')
     ]
 
@@ -153,90 +165,50 @@ class AccrualPlanLevel(models.Model):
             else:
                 level.level = 1
 
-    def _get_accrual_values(self, allocation_create_date):
-        """
-        This method returns all the accrual linked to their accrual_plan with the updated dynamic parameters depending
-        on the date.
-        :return: dict: {accrual_id, accrual_start, accrual_stop, nextcall, sufficient_seniority}
-         where accrual_start and accrual_stop are start and stop of the current period
-        """
-        today = fields.Date.context_today(self, )
-        results = []
-        for accrual in self:
-            seniority = allocation_create_date + get_timedelta(accrual.start_count, accrual.start_type)
-            frequency = accrual.frequency
-            if frequency == 'daily':
-                accrual_start = max(today, seniority.date())
-                accrual_stop = accrual_start + relativedelta(days=1)
-                nextcall = accrual_stop
-            elif frequency == 'weekly':
-                min_accrual_date = max(today, seniority.date())
-                if min_accrual_date.isoweekday() == DAYS.index(accrual.week_day):
-                    accrual_stop = min_accrual_date
-                else:
-                    accrual_stop = accrual._get_next_weekday(min_accrual_date, accrual.week_day)
-                accrual_start = accrual_stop - relativedelta(days=7)
-                nextcall = accrual._get_next_weekday(min_accrual_date, accrual.week_day)
-            elif frequency == 'bimonthly':
-                if today.day <= accrual.first_day:
-                    accrual_start = datetime.date(today.year, today.month, accrual.second_day) - relativedelta(months=1)
-                    accrual_stop = datetime.date(today.year, today.month, accrual.first_day)
-                    nextcall = datetime.date(today.year, today.month, accrual.second_day)
-                else:
-                    if today.day <= accrual.second_day:
-                        accrual_start = datetime.date(today.year, today.month, accrual.first_day)
-                        accrual_stop = datetime.date(today.year, today.month, accrual.second_day)
-                        nextcall = datetime.date(today.year, today.month, accrual.first_day) + relativedelta(months=1)
-                    else:
-                        accrual_start = datetime.date(today.year, today.month, accrual.second_day)
-                        accrual_stop = datetime.date(today.year, today.month, accrual.first_day) + relativedelta(months=1)
-                        nextcall = datetime.date(today.year, today.month, accrual.second_day) + relativedelta(months=1)
-            elif frequency == 'monthly':
-                if today.day <= accrual.first_day:
-                    accrual_start = datetime.date(today.year, today.month, accrual.first_day) - relativedelta(months=1)
-                    accrual_stop = datetime.date(today.year, today.month, accrual.first_day)
-                    nextcall = datetime.date(today.year, today.month, accrual.first_day) + relativedelta(months=1)
-                else:
-                    accrual_start = datetime.date(today.year, today.month, accrual.first_day)
-                    accrual_stop = datetime.date(today.year, today.month, accrual.first_day) + relativedelta(months=1)
-                    nextcall = datetime.date(today.year, today.month, accrual.first_day) + relativedelta(months=2)
-            elif frequency == 'biyearly':
-                first_month = MONTHS.index(accrual.first_month) + 1
-                second_month = MONTHS.index(accrual.second_month) + 1
-                potential_first_accrual_date = datetime.date(today.year, first_month, accrual.first_month_day)
-                potential_second_accrual_date = datetime.date(today.year, second_month, accrual.second_month_day)
-                if today <= potential_first_accrual_date:
-                    accrual_start = potential_second_accrual_date - relativedelta(years=1)
-                    accrual_stop = potential_first_accrual_date
-                    nextcall = potential_second_accrual_date
-                else:
-                    if today <= potential_second_accrual_date:
-                        accrual_start = potential_first_accrual_date
-                        accrual_stop = potential_second_accrual_date
-                        nextcall = potential_first_accrual_date + relativedelta(years=1)
-                    else:
-                        accrual_start = potential_second_accrual_date
-                        accrual_stop = potential_first_accrual_date + relativedelta(years=1)
-                        nextcall = potential_first_accrual_date + relativedelta(years=1)
-            elif frequency == 'yearly':
-                month = MONTHS.index(accrual.yearly_month) + 1
-                potential_accrual_date = datetime.date(today.year, month, accrual.yearly_day)
-                if today <= potential_accrual_date:
-                    accrual_start = potential_accrual_date - relativedelta(years=1)
-                    accrual_stop = potential_accrual_date
-                    nextcall = potential_accrual_date + relativedelta(years=1)
-                else:
-                    accrual_start = potential_accrual_date
-                    accrual_stop = potential_accrual_date + relativedelta(years=1)
-                    nextcall = accrual_stop
+    @api.depends('first_day', 'second_day', 'first_month_day', 'second_month_day', 'yearly_day')
+    def _compute_days_display(self):
+        days_select = _get_selection_days(self)
+        for level in self:
+            level.first_day_display = days_select[min(level.first_day - 1, 28)][0]
+            level.second_day_display = days_select[min(level.second_day - 1, 28)][0]
+            level.first_month_day_display = days_select[min(level.first_month_day - 1, 28)][0]
+            level.second_month_day_display = days_select[min(level.second_month_day - 1, 28)][0]
+            level.yearly_day_display = days_select[min(level.yearly_day - 1, 28)][0]
 
-            results.append({'accrual_level_id': accrual.id,
-                            'start_after': accrual.start_count,
-                            'accrual_start': datetime.datetime.combine(accrual_start, datetime.datetime.min.time()),
-                            'accrual_stop': datetime.datetime.combine(accrual_stop, datetime.datetime.min.time()),
-                            'nextcall': nextcall,
-                            'sufficient_seniority': seniority.date() <= today})
-        return results
+    def _inverse_first_day_display(self):
+        for level in self:
+            if level.first_day_display == 'last':
+                level.first_day = 31
+            else:
+                level.first_day = DAY_SELECT_VALUES.index(level.first_day_display) + 1
+
+    def _inverse_second_day_display(self):
+        for level in self:
+            if level.second_day_display == 'last':
+                level.second_day = 31
+            else:
+                level.second_day = DAY_SELECT_VALUES.index(level.second_day_display) + 1
+
+    def _inverse_first_month_day_display(self):
+        for level in self:
+            if level.first_month_day_display == 'last':
+                level.first_month_day = 31
+            else:
+                level.first_month_day = DAY_SELECT_VALUES.index(level.first_month_day_display) + 1
+
+    def _inverse_second_month_day_display(self):
+        for level in self:
+            if level.second_month_day_display == 'last':
+                level.second_month_day = 31
+            else:
+                level.second_month_day = DAY_SELECT_VALUES.index(level.second_month_day_display) + 1
+
+    def _inverse_yearly_day_display(self):
+        for level in self:
+            if level.yearly_day_display == 'last':
+                level.yearly_day = 31
+            else:
+                level.yearly_day = DAY_SELECT_VALUES.index(level.yearly_day_display) + 1
 
     def _get_next_date(self, last_call):
         """
@@ -246,47 +218,90 @@ class AccrualPlanLevel(models.Model):
         if self.frequency == 'daily':
             return last_call + relativedelta(days=1)
         elif self.frequency == 'weekly':
-            return self._get_next_weekday(last_call, self.week_day)
+            daynames = ['mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun']
+            weekday = daynames.index(self.week_day)
+            return last_call + relativedelta(days=1, weekday=weekday)
         elif self.frequency == 'bimonthly':
-            if last_call.day < self.first_day:
-                return _get_date_check_month(last_call.year, last_call.month, self.first_day)
-            elif last_call.day < self.second_day:
-                return _get_date_check_month(last_call.year, last_call.month, self.second_day)
+            first_date = last_call + relativedelta(day=self.first_day)
+            second_date = last_call + relativedelta(day=self.second_day)
+            if last_call < first_date:
+                return first_date
+            elif last_call < second_date:
+                return second_date
             else:
-                return _get_date_check_month(last_call.year, last_call.month, self.first_day) + relativedelta(months=1)
+                return last_call + relativedelta(months=1, day=self.first_day)
         elif self.frequency == 'monthly':
-            if last_call.day < self.first_day:
-                return _get_date_check_month(last_call.year, last_call.month, self.first_day)
+            date = last_call + relativedelta(self.first_day)
+            if last_call < date:
+                return date
             else:
-                return _get_date_check_month(last_call.year, last_call.month, self.first_day) + relativedelta(months=1)
+                return last_call + relativedelta(months=1, day=self.first_day)
         elif self.frequency == 'biyearly':
             first_month = MONTHS.index(self.first_month) + 1
             second_month = MONTHS.index(self.second_month) + 1
-            if last_call < _get_date_check_month(last_call.year, first_month, self.first_month_day):
-                return _get_date_check_month(last_call.year, first_month, self.first_month_day)
-            elif last_call < _get_date_check_month(last_call.year, second_month, self.second_month_day):
-                return _get_date_check_month(last_call.year, second_month, self.second_month_day)
+            first_date = last_call + relativedelta(month=first_month, day=self.first_month_day)
+            second_date = last_call + relativedelta(month=second_month, day=self.second_month_day)
+            if last_call < first_date:
+                return first_date
+            elif last_call < second_date:
+                return second_date
             else:
-                return _get_date_check_month(last_call.year, first_month, self.first_month_day) + relativedelta(years=1)
+                return last_call + relativedelta(years=1, month=first_month, day=self.first_month_day)
         elif self.frequency == 'yearly':
             month = MONTHS.index(self.yearly_month) + 1
-            if last_call < _get_date_check_month(last_call.year, month, self.yearly_day):
-                return _get_date_check_month(last_call.year, month, self.yearly_day)
+            date = last_call + relativedelta(month=month, day=self.yearly_day)
+            if last_call < date:
+                return date
             else:
-                return _get_date_check_month(last_call.year, month, self.yearly_day) + relativedelta(years=1)
+                return last_call + relativedelta(years=1, month=month, day=self.yearly_day)
         else:
             return False
 
-    @api.model
-    def _get_next_weekday(self, day, weekday):
+    def _get_previous_date(self, last_call):
         """
-        :param day: a datetime object
-        :param weekday: Weekday as a decimal number, where 0 is Sunday and 6 is Saturday.
-        :return: datetime of the next weekday
+        Returns the date a potential previous call would have been at
+        For example if you have a monthly level giving 16/02 would return 01/02
+        Contrary to `_get_next_date` this function will return the 01/02 if that date is given
         """
-        daynames = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat']
-        weekday = daynames.index(weekday)
-        days_ahead = weekday - day.isoweekday()
-        if days_ahead <= 0:
-            days_ahead += 7
-        return day + relativedelta(days=days_ahead)
+        self.ensure_one()
+        if self.frequency == 'daily':
+            return last_call
+        elif self.frequency == 'weekly':
+            daynames = ['mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun']
+            weekday = daynames.index(self.week_day)
+            return last_call + relativedelta(days=-6, weekday=weekday)
+        elif self.frequency == 'bimonthly':
+            second_date = last_call + relativedelta(day=self.second_day)
+            first_date = last_call + relativedelta(day=self.first_day)
+            if last_call >= second_date:
+                return second_date
+            elif last_call >= first_date:
+                return first_date
+            else:
+                return last_call + relativedelta(months=-1, day=self.second_day)
+        elif self.frequency == 'monthly':
+            date = last_call + relativedelta(day=self.first_day)
+            if last_call >= date:
+                return date
+            else:
+                return last_call + relativedelta(months=-1, day=self.first_day)
+        elif self.frequency == 'biyearly':
+            first_month = MONTHS.index(self.first_month) + 1
+            second_month = MONTHS.index(self.second_month) + 1
+            first_date = last_call + relativedelta(month=first_month, day=self.first_month_day)
+            second_date = last_call + relativedelta(month=second_month, day=self.second_month_day)
+            if last_call >= second_date:
+                return second_date
+            elif last_call >= first_date:
+                return first_date
+            else:
+                return last_call + relativedelta(years=-1, month=second_month, day=self.second_month_day)
+        elif self.frequency == 'yearly':
+            month = MONTHS.index(self.yearly_month) + 1
+            year_date = last_call + relativedelta(month=month, day=self.yearly_day)
+            if last_call >= year_date:
+                return year_date
+            else:
+                return last_call + relativedelta(years=-1, month=month, day=self.yearly_day)
+        else:
+            return False

--- a/addons/hr_holidays/models/hr_leave_allocation.py
+++ b/addons/hr_holidays/models/hr_leave_allocation.py
@@ -6,7 +6,7 @@
 from collections import defaultdict
 import logging
 
-from datetime import datetime, time
+from datetime import datetime, time, timedelta
 from dateutil.relativedelta import relativedelta
 
 from odoo import api, fields, models
@@ -321,18 +321,19 @@ class HolidaysAllocation(models.Model):
         # to override in payroll
         today = fields.Date.today()
         for allocation in self:
-            current_level = allocation._get_current_accrual_plan_level_id(today)
+            current_level = allocation._get_current_accrual_plan_level_id(today)[0]
             if current_level and current_level.action_with_unused_accruals == 'lost':
                 # Allocations are lost but number_of_days should not be lower than leaves_taken
                 allocation.write({'number_of_days': allocation.leaves_taken, 'lastcall': today, 'nextcall': False})
 
     def _get_current_accrual_plan_level_id(self, date, level_ids=False):
         """
-        Returns the accrual_plan_level for the given date of the record's accrual plan
+        Returns a pair (accrual_plan_level, idx) where accrual_plan_level is the level for the given date
+         and idx is the index for the plan in the ordered set of levels
         """
         self.ensure_one()
         if not self.accrual_plan_id.level_ids:
-            return False
+            return (False, False)
         # Sort by sequence which should be equivalent to the level
         if not level_ids:
             level_ids = self.accrual_plan_id.level_ids.sorted('sequence')
@@ -345,28 +346,28 @@ class HolidaysAllocation(models.Model):
         # If transition_mode is set to `immediately` or we are currently on the first level
         # the current_level is simply the first level in the list.
         if current_level_idx <= 0 or self.accrual_plan_id.transition_mode == "immediately":
-            return current_level
+            return (current_level, current_level_idx)
         # In this case we have to verify that the 'previous level' is not the current one due to `end_of_accrual`
         level_start_date = self.date_from + get_timedelta(current_level.start_count, current_level.start_type)
         previous_level = level_ids[current_level_idx - 1]
         # If the next date from the current level's start date is before the last call of the previous level
         # return the previous level
         if current_level._get_next_date(level_start_date) < previous_level._get_next_date(level_start_date):
-            return previous_level
-        return current_level
+            return (previous_level, current_level_idx - 1)
+        return (current_level, current_level_idx)
 
-    def _process_accrual_plan_level(self, level, start_date, end_date):
+    def _process_accrual_plan_level(self, level, start_period, start_date, end_period, end_date):
         """
         Returns the added days for that level
         """
         self.ensure_one()
         if level.is_based_on_worked_time:
             start_dt = datetime.combine(start_date, datetime.min.time())
-            end_dt = datetime.combine(end_date, datetime.min.time())
+            end_dt = datetime.combine(end_date, datetime.max.time())
             worked = self.employee_id._get_work_days_data_batch(start_dt, end_dt, calendar=self.employee_id.resource_calendar_id)\
-                [self.employee_id.id]['days']
+                [self.employee_id.id]['hours']
             left = self.employee_id.sudo()._get_leave_days_data_batch(start_dt, end_dt,
-                domain=[('time_type', '=', 'leave')])[self.employee_id.id]['days']
+                domain=[('time_type', '=', 'leave')])[self.employee_id.id]['hours']
             work_entry_prorata = worked / (left + worked) if worked else 0
             added_value = work_entry_prorata * level.added_value
         else:
@@ -374,7 +375,12 @@ class HolidaysAllocation(models.Model):
         # Convert time in hours to time in days in case the level is encoded in hours
         if level.added_value_type == 'hours':
             added_value = added_value / (self.employee_id.sudo().resource_id.calendar_id.hours_per_day or HOURS_PER_DAY)
-        return added_value
+        period_prorata = 1
+        if start_period != start_date or end_period != end_date:
+            period_days = (end_period - start_period)
+            call_days = (end_date - start_date)
+            period_prorata = min(1, call_days / period_days) if period_days else 1
+        return added_value * period_prorata
 
     def _process_accrual_plans(self):
         """
@@ -383,7 +389,7 @@ class HolidaysAllocation(models.Model):
         """
         today = fields.Date.today()
         for allocation in self:
-            level_ids = self.accrual_plan_id.level_ids.sorted('sequence')
+            level_ids = allocation.accrual_plan_id.level_ids.sorted('sequence')
             if not level_ids:
                 continue
             if not allocation.nextcall:
@@ -396,9 +402,21 @@ class HolidaysAllocation(models.Model):
                 allocation.nextcall = first_level._get_next_date(allocation.lastcall)
             days_added_per_level = defaultdict(lambda: 0)
             while allocation.nextcall <= today:
-                current_level = allocation._get_current_accrual_plan_level_id(allocation.nextcall)
+                (current_level, current_level_idx) = allocation._get_current_accrual_plan_level_id(allocation.nextcall)
                 nextcall = current_level._get_next_date(allocation.nextcall)
-                days_added_per_level[current_level] += allocation._process_accrual_plan_level(current_level, allocation.lastcall, allocation.nextcall)
+                # Since _get_previous_date returns the given date if it corresponds to a call date
+                # this will always return lastcall except possibly on the first call
+                # this is used to prorate the first number of days given to the employee
+                period_start = current_level._get_previous_date(allocation.lastcall)
+                period_end = current_level._get_next_date(allocation.lastcall)
+                # Also prorate this accrual in the event that we are passing from one level to another
+                if current_level_idx < (len(level_ids) - 1) and allocation.accrual_plan_id.transition_mode == 'immediately':
+                    next_level = level_ids[current_level_idx + 1]
+                    current_level_last_date = allocation.date_from + get_timedelta(next_level.start_count, next_level.start_type) - relativedelta(days=1)
+                    if allocation.nextcall != current_level_last_date:
+                        nextcall = min(nextcall, current_level_last_date)
+                days_added_per_level[current_level] += allocation._process_accrual_plan_level(
+                    current_level, period_start, allocation.lastcall, period_end, allocation.nextcall)
                 allocation.lastcall = allocation.nextcall
                 allocation.nextcall = nextcall
             if days_added_per_level:
