PR: https://github.com/odoo/odoo/pull/48145

From: 94f8f15036c3e5fec4aed9a7e50960bc7f190631
From: Jeremy Kersten
Date: 2020-03-21 10:23:32

Structural Changes: 3
Total Changes: 45

[FIX] website: make handle_visibility private

This commit:
   - make handle_visibility a private function (even if not
     exploitable in rpc easily since it uses request.website)
   - encrypt the password in db (even if not critic, since this
     password could be shared on twitter, ... it doesn't cost anything
     to secure it a bit more)
   - remove useless sudo, since handle_visibility does a sudo itself.

In the future, this notion of visibility should be handled on controller layer,
and no more on the View layer (during rendering)

closes odoo/odoo#48145

X-original-commit: 06e0e48217f25f17dff23331111f5dcb98e8cecd
Signed-off-by: Martin Trigaux (mat) <mat@odoo.com>
Signed-off-by: Christophe Monniez (moc) <moc@odoo.com>

================================= pseudo patch: =================================

--- a/addons/website/models/ir_ui_view.py
+++ b/addons/website/models/ir_ui_view.py
@@ -10,6 +10,7 @@ from odoo import api, fields, models
 from odoo import tools
 from odoo.addons import website
 from odoo.addons.http_routing.models.ir_http import url_for
+from odoo.exceptions import AccessError
 from odoo.osv import expression
 from odoo.http import request
 
@@ -27,8 +28,20 @@ class View(models.Model):
     first_page_id = fields.Many2one('website.page', string='Website Page', help='First page linked to this view', compute='_compute_first_page_id')
     track = fields.Boolean(string='Track', default=False, help="Allow to specify for one page of the website to be trackable or not")
     visibility = fields.Selection([('', 'All'), ('connected', 'Signed In'), ('restricted_group', 'Restricted Group'), ('password', 'With Password')], default='')
-    visibility_group = fields.Many2one('res.groups')
-    visibility_password = fields.Char(groups='website.group_website_publisher')
+    visibility_group = fields.Many2one('res.groups', copy=False)
+    visibility_password = fields.Char(groups='base.group_system', copy=False)
+    visibility_password_display = fields.Char(compute='_get_pwd', inverse='_set_pwd', groups='website.group_website_designer')
+
+    @api.depends('visibility_password')
+    def _get_pwd(self):
+        for r in self:
+            r.visibility_password_display = r.sudo().visibility_password and '********' or ''
+
+    def _set_pwd(self):
+        crypt_context = self.env.user._crypt_context()
+        for r in self:
+            r.sudo().visibility_password = crypt_context.encrypt(r.visibility_password_display)
+            r.visibility = r.visibility  # double check access
 
     def _compute_first_page_id(self):
         for view in self:
@@ -324,8 +337,8 @@ class View(models.Model):
 
     @api.model
     def read_template(self, xml_id):
-        view_sudo = self._view_obj(self.get_view_id(xml_id)).sudo()
-        if view_sudo.visibility and view_sudo.handle_visibility(do_raise=False):
+        view = self._view_obj(self.get_view_id(xml_id))
+        if view.visibility and view._handle_visibility(do_raise=False):
             self = self.sudo()
         return super(View, self).read_template(xml_id)
 
@@ -338,14 +351,19 @@ class View(models.Model):
         domain = [('key', '=', self.key), ('model_data_id', '!=', None)]
         return self.with_context(active_test=False).search(domain, limit=1)  # Useless limit has multiple xmlid should not be possible
 
-    def handle_visibility(self, do_raise=True):
+    def _handle_visibility(self, do_raise=True):
         """ Check the visibility set on the main view and raise 403 if you should not have access.
             Order is: Public, Connected, Has group, Password
 
             It only check the visibility on the main content, others views called stay available in rpc.
         """
         error = False
-        self = self.sudo()
+
+        try:
+            self.visibility  # avoid useless sudo() in case page is public
+        except AccessError:
+            self = self.sudo()
+
         if self.visibility and not request.env.user.has_group('website.group_website_designer'):
             if (self.visibility == 'connected' and request.website.is_public_user()):
                 error = werkzeug.exceptions.Forbidden()
@@ -356,7 +374,9 @@ class View(models.Model):
                     error = werkzeug.exceptions.Forbidden()
             elif self.visibility == 'password' and \
                     (request.website.is_public_user() or self.id not in request.session.get('views_unlock', [])):
-                if self.sudo().visibility_password == request.params.get('visibility_password'):
+                pwd = request.params.get('visibility_password')
+                if pwd and self.env.user._crypt_context().verify(
+                        pwd, self.sudo().visibility_password):
                     request.session.setdefault('views_unlock', list()).append(self.id)
                 else:
                     error = werkzeug.exceptions.Forbidden('website_visibility_password_required')
@@ -369,7 +389,7 @@ class View(models.Model):
 
     def render(self, values=None, engine='ir.qweb', minimal_qcontext=False):
         """ Render the template. If website is enabled on request, then extend rendering context with website values. """
-        self.handle_visibility(do_raise=True)
+        self._handle_visibility(do_raise=True)
         new_context = dict(self._context)
         if request and getattr(request, 'is_frontend', False):
 

--- a/addons/website/models/website_menu.py
+++ b/addons/website/models/website_menu.py
@@ -113,7 +113,7 @@ class Menu(models.Model):
             visible = True
             if menu.page_id and not menu.user_has_groups('base.group_user') and \
                 (not menu.page_id.sudo().is_visible or
-                 (not menu.page_id.view_id.handle_visibility(do_raise=False) and
+                 (not menu.page_id.view_id._handle_visibility(do_raise=False) and
                  menu.page_id.view_id.visibility != "password")):
                 visible = False
             menu.is_visible = visible

--- a/addons/website/models/website_page.py
+++ b/addons/website/models/website_page.py
@@ -66,10 +66,11 @@ class Page(models.Model):
         self.ensure_one()
         res = self.read([
             'id', 'name', 'url', 'website_published', 'website_indexed', 'date_publish',
-            'menu_ids', 'is_homepage', 'website_id', 'visibility', 'visibility_password', 'visibility_group'
+            'menu_ids', 'is_homepage', 'website_id', 'visibility', 'visibility_group'
         ])[0]
         if not res['visibility_group']:
             res['visibility_group'] = self.env.ref('base.group_user').name_get()[0]
+        res['visibility_password'] = res['visibility'] == 'password' and self.visibility_password_display or ''
         return res
 
     @api.model
@@ -122,9 +123,11 @@ class Page(models.Model):
             'date_publish': data['date_publish'] or None,
             'is_homepage': data['is_homepage'],
             'visibility': data['visibility'],
-            'visibility_password': data['visibility'] == "password" and data['visibility_password'] or '',
             'visibility_group': data['visibility'] == "restricted_group" and data['visibility_group'],
         }
+        if 'visibility_pwd' in data:
+            w_vals['visibility_password_display'] = data['visibility_pwd'] or ''
+
         page.with_context(no_cow=True).write(w_vals)
 
         # Create redirect if needed
