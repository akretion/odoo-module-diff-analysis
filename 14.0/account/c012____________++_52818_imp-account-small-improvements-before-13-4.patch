PR: https://github.com/odoo/odoo/pull/52818

From: 394e9fa4aaafbb518b95f03d12a487e9759893a1
From: william
Date: 2020-06-12 13:28:40

Structural Changes: 5
Total Changes: 72

[IMP] account: small improvements before 13.4

Task 2274998

1/ In the accounting dashboard, maximum one primary button per box
2/ In all boxes : "Sample data" must be removed. (Too obvious)
3/ In the configuration of Accounting Periods
  * Opening date and fiscal year end must be on a same line.
  * Remove the button "Configure your tax accounts".
4/ "Configure your tax accounts" is still available in the settings.
  * But also make it available while doing the Tax Report Entry, if an
  error message pops up.
5/ Chart of Account (list view)
  * Captital D for opening Debit/Credit
  * Rename "Name" into "Account Name"
6/ While g√©nerating an Invoice
  * Rename "Post" button into "Confirm"
  * Check that the incremental number is added as a suffix of the name
  of the bill ; not as a prefix
7/ Vendor Bill (list view)
  * Status must appear as a Tag ; like it is already done in "Payment
  State"
  * Rename "Payment State" into "Payment Status"
8/ Bank journals
  * On the bank journal level, if bank feed is set to synchronization,
  then while selecting that journal from the accounting dashboard, then
  directly go to the statement lines rather than the bank statement
  itself.
  * In the bank statement's account moves, remove the button duplicate.
  It is enough to have it in the actions.

closes odoo/odoo#52818

Related: odoo/enterprise#11081
Signed-off-by: Laurent Smet <smetl@users.noreply.github.com>

================================= pseudo patch: =================================

--- a/addons/account/models/account_account.py
+++ b/addons/account/models/account_account.py
@@ -54,7 +54,7 @@ class AccountAccount(models.Model):
                                                            ('user_type_id', '=', data_unaffected_earnings.id)])
                 raise ValidationError(_('You cannot have more than one account with "Current Year Earnings" as type. (accounts: %s)') % [a.code for a in account_unaffected_earnings])
 
-    name = fields.Char(required=True, index=True)
+    name = fields.Char(string="Account Name", required=True, index=True)
     currency_id = fields.Many2one('res.currency', string='Account Currency',
         help="Forces all moves for this account to have this account currency.")
     code = fields.Char(size=64, required=True, index=True)
@@ -80,8 +80,9 @@ class AccountAccount(models.Model):
     root_id = fields.Many2one('account.root', compute='_compute_account_root', store=True)
     allowed_journal_ids = fields.Many2many('account.journal', string="Allowed Journals", help="Define in which journals this account can be used. If empty, can be used in all journals.")
 
-    opening_debit = fields.Monetary(string="Opening debit", compute='_compute_opening_debit_credit', inverse='_set_opening_debit', help="Opening debit value for this account.")
-    opening_credit = fields.Monetary(string="Opening credit", compute='_compute_opening_debit_credit', inverse='_set_opening_credit', help="Opening credit value for this account.")
+    opening_debit = fields.Monetary(string="Opening Debit", compute='_compute_opening_debit_credit', inverse='_set_opening_debit', help="Opening debit value for this account.")
+    opening_credit = fields.Monetary(string="Opening Credit", compute='_compute_opening_debit_credit', inverse='_set_opening_credit', help="Opening credit value for this account.")
+    opening_balance = fields.Monetary(string="Opening Balance", compute='_compute_opening_debit_credit', help="Opening balance value for this account.")
 
     _sql_constraints = [
         ('code_company_uniq', 'unique (code,company_id)', 'The code of the account must be unique per company !')
@@ -220,17 +221,25 @@ class AccountAccount(models.Model):
         raise UserError(_('Cannot generate an unused account code.'))
 
     def _compute_opening_debit_credit(self):
+        if not self:
+            return
+        self.env.cr.execute("""
+            SELECT line.account_id,
+                   SUM(line.balance) AS balance,
+                   SUM(line.debit) AS debit,
+                   SUM(line.credit) AS credit
+              FROM account_move_line line
+              JOIN res_company comp ON comp.id = line.company_id
+             WHERE line.move_id = comp.account_opening_move_id
+               AND line.account_id IN %s
+             GROUP BY line.account_id
+        """, [tuple(self.ids)])
+        result = {r['account_id']: r for r in self.env.cr.dictfetchall()}
         for record in self:
-            opening_debit = opening_credit = 0.0
-            if record.company_id.account_opening_move_id:
-                for line in self.env['account.move.line'].search([('account_id', '=', record.id),
-                                                                 ('move_id','=', record.company_id.account_opening_move_id.id)]):
-                    if line.debit:
-                        opening_debit += line.debit
-                    elif line.credit:
-                        opening_credit += line.credit
-            record.opening_debit = opening_debit
-            record.opening_credit = opening_credit
+            res = result.get(record.id) or {'debit': 0, 'credit': 0, 'balance': 0}
+            record.opening_debit = res['debit']
+            record.opening_credit = res['credit']
+            record.opening_balance = res['balance']
 
     def _set_opening_debit(self):
         self._set_opening_debit_credit(self.opening_debit, 'debit')

--- a/addons/account/models/account_journal_dashboard.py
+++ b/addons/account/models/account_journal_dashboard.py
@@ -435,22 +435,25 @@ class account_journal(models.Model):
         statement_line_ids = self.env['account.move.line'].search(domain).mapped('statement_line_id')
         return statement_line_ids
 
+    def _select_action_to_open(self):
+        self.ensure_one()
+        if self._context.get('action_name'):
+            return self._context.get('action_name')
+        elif self.type == 'bank':
+            return 'action_bank_statement_tree'
+        elif self.type == 'cash':
+            return 'action_view_bank_statement_tree'
+        elif self.type == 'sale':
+            return 'action_move_out_invoice_type'
+        elif self.type == 'purchase':
+            return 'action_move_in_invoice_type'
+        else:
+            return 'action_move_journal_line'
+
     def open_action(self):
         """return action based on type for related journals"""
-        action_name = self._context.get('action_name')
-
-        # Find action based on journal.
-        if not action_name:
-            if self.type == 'bank':
-                action_name = 'action_bank_statement_tree'
-            elif self.type == 'cash':
-                action_name = 'action_view_bank_statement_tree'
-            elif self.type == 'sale':
-                action_name = 'action_move_out_invoice_type'
-            elif self.type == 'purchase':
-                action_name = 'action_move_in_invoice_type'
-            else:
-                action_name = 'action_move_journal_line'
+        self.ensure_one()
+        action_name = self._select_action_to_open()
 
         # Set 'account.' prefix if missing.
         if '.' not in action_name:

--- a/addons/account/models/account_move.py
+++ b/addons/account/models/account_move.py
@@ -207,7 +207,7 @@ class AccountMove(models.Model):
         ('partial', 'Partially Paid'),
         ('reversed', 'Reversed'),
         ('invoicing_legacy', 'Invoicing App Legacy')],
-        string="Payment State", store=True, readonly=True, copy=False, tracking=True,
+        string="Payment Status", store=True, readonly=True, copy=False, tracking=True,
         compute='_compute_amount')
 
     # ==== Cash basis feature fields ====

--- a/addons/account/models/sequence_mixin.py
+++ b/addons/account/models/sequence_mixin.py
@@ -122,9 +122,9 @@ class SequenceMixin(models.AbstractModel):
 
         sequence = re.match(self._sequence_fixed_regex, last_sequence)
         value = ("{prefix}{seq:0%sd}{suffix}" % len(sequence.group('seq'))).format(
-            prefix=sequence.group('prefix1'),
+            prefix=sequence.group('prefix1') if sequence.group('seq') else sequence.group('suffix'),
             seq=int(sequence.group('seq') or 0) + 1,
-            suffix=sequence.group('suffix'),
+            suffix=sequence.group('suffix') if sequence.group('seq') else "",
         )
         self[self._sequence_field] = value
         self.flush([self._sequence_field])
