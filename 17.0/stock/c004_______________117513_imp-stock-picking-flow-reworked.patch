PR: https://github.com/odoo/odoo/pull/117513

From: 5e5d92ef796ff725527f2b66d247683e1b0ef982
From: William Henrotin
Date: 2023-05-17 11:37:47

Structural Changes: 1
Total Changes: 91

[IMP] stock: picking flow reworked

This commit changes the process flow of stock pickings. A new picking will
always be created in immediate transfer mode and 'ready' state. From
their, it can be validated directly or 'reset to draft'. This second action
switch the immediate mode to planned mode and reset the state as draft.
From their the classical workflow is processed
confirm -> (assigned ->) validated

Task: 3256447
Part-of: odoo/odoo#117513

================================= pseudo patch: =================================

--- a/addons/stock/models/stock_move.py
+++ b/addons/stock/models/stock_move.py
@@ -55,7 +55,7 @@ class StockMove(models.Model):
     product_uom_qty = fields.Float(
         'Demand',
         digits='Product Unit of Measure',
-        default=1.0, required=True, states={'done': [('readonly', True)]},
+        default=0, required=True, states={'done': [('readonly', True)]},
         help="This is the quantity of products from an inventory "
              "point of view. For moves in the state 'done', this is the "
              "quantity of products that were actually moved. For other "
@@ -248,7 +248,6 @@ class StockMove(models.Model):
             else:
                 move.show_details_visible = (((consignment_enabled and move.picking_code != 'incoming') or
                                              show_details_visible or move.has_tracking != 'none') and
-                                             move._show_details_in_draft() and
                                              move.show_operations is False)
 
     def _compute_show_reserved_availability(self):
@@ -392,7 +391,7 @@ class StockMove(models.Model):
 
         def _process_increase(move, quantity):
             moves = move
-            if move.picking_id.immediate_transfer:
+            if move.picking_id and move.picking_id.immediate_transfer:
                 moves = move._action_confirm(merge=False)
             # Kits, already handle in action_explode, should be clean in master
             if len(moves) > 1:
@@ -681,7 +680,10 @@ Please change the quantity done or the rounding precision of your unit of measur
                 (self - move_to_unreserve).filtered(lambda m: m.state == 'assigned').write({'state': 'partially_available'})
                 # When editing the initial demand, directly run again action assign on receipt moves.
                 receipt_moves_to_reassign |= move_to_unreserve.filtered(lambda m: m.location_id.usage == 'supplier')
-                receipt_moves_to_reassign |= (self - move_to_unreserve).filtered(lambda m: m.location_id.usage == 'supplier' and m.state in ('partially_available', 'assigned'))
+                receipt_moves_to_reassign |= (self - move_to_unreserve).filtered(lambda m:
+                     m.location_id.usage == 'supplier'
+                     and m.state in ('partially_available', 'assigned')
+                     and not m.picking_id.immediate_transfer)
                 move_to_recompute_state |= self - move_to_unreserve - receipt_moves_to_reassign
         # propagate product_packaging_id changes in the stock move chain
         if 'product_packaging_id' in vals:
@@ -784,7 +786,7 @@ Please change the quantity done or the rounding precision of your unit of measur
                 show_source_location=self.picking_type_id.code != 'incoming',
                 show_destination_location=self.picking_type_id.code != 'outgoing',
                 show_package=not self.location_id.usage == 'supplier',
-                show_reserved_quantity=self.state != 'done' and not self.picking_id.immediate_transfer and self.picking_type_id.code != 'incoming'
+                show_reserved_quantity=self.state != 'done' and self.picking_type_id.code != 'incoming'
             ),
         }
 
@@ -1194,7 +1196,6 @@ Please change the quantity done or the rounding precision of your unit of measur
             ('location_dest_id', '=', self.location_dest_id.id),
             ('picking_type_id', '=', self.picking_type_id.id),
             ('printed', '=', False),
-            ('immediate_transfer', '=', False),
             ('state', 'in', ['draft', 'confirmed', 'waiting', 'partially_available', 'assigned'])]
         if self.partner_id and (self.location_id.usage == 'transit' or self.location_dest_id.usage == 'transit'):
             domain += [('partner_id', '=', self.partner_id.id)]
@@ -1328,6 +1329,8 @@ Please change the quantity done or the rounding precision of your unit of measur
             'picking_type_id': self.mapped('picking_type_id').id,
             'location_id': self.mapped('location_id').id,
             'location_dest_id': self.mapped('location_dest_id').id,
+            'state': 'draft',
+            'immediate_transfer': False,
         }
 
     def _should_be_assigned(self):
@@ -1408,8 +1411,7 @@ Please change the quantity done or the rounding precision of your unit of measur
         neg_r_moves._assign_picking()
 
         # call `_action_assign` on every confirmed move which location_id bypasses the reservation + those expected to be auto-assigned
-        moves.filtered(lambda move: not move.picking_id.immediate_transfer
-                       and move.state in ('confirmed', 'partially_available')
+        moves.filtered(lambda move: move.state in ('confirmed', 'partially_available')
                        and (move._should_bypass_reservation()
                             or move.picking_type_id.reservation_method == 'at_confirm'
                             or (move.reservation_date and move.reservation_date <= fields.Date.today())))\
@@ -1676,7 +1678,7 @@ Please change the quantity done or the rounding precision of your unit of measur
                 assigned_moves_ids.add(move.id)
                 moves_to_redirect.add(move.id)
             else:
-                if float_is_zero(move.product_uom_qty, precision_rounding=move.product_uom.rounding):
+                if float_is_zero(move.product_uom_qty, precision_rounding=move.product_uom.rounding) and not force_qty:
                     assigned_moves_ids.add(move.id)
                 elif not move.move_orig_ids:
                     if move.procure_method == 'make_to_order':
@@ -1876,8 +1878,8 @@ Please change the quantity done or the rounding precision of your unit of measur
 
     @api.ondelete(at_uninstall=False)
     def _unlink_if_draft_or_cancel(self):
-        if any(move.state not in ('draft', 'cancel') for move in self):
-            raise UserError(_('You can only delete draft or cancelled moves.'))
+        if any(move.state not in ('draft', 'cancel') and (move.move_orig_ids or move.move_dest_ids) for move in self):
+            raise UserError(_('You can not delete moves linked to another operation'))
 
     def unlink(self):
         # With the non plannified picking, draft moves could have some move lines.
@@ -2112,10 +2114,6 @@ Please change the quantity done or the rounding precision of your unit of measur
             else:
                 move.procure_method = 'make_to_order'
 
-    def _show_details_in_draft(self):
-        self.ensure_one()
-        return self.state != 'draft' or (self.picking_id.immediate_transfer and self.state == 'draft')
-
     def _trigger_scheduler(self):
         """ Check for auto-triggered orderpoints and trigger them. """
         if not self or self.env['ir.config_parameter'].sudo().get_param('stock.no_auto_scheduler'):

--- a/addons/stock/models/stock_picking.py
+++ b/addons/stock/models/stock_picking.py
@@ -313,7 +313,7 @@ class Picking(models.Model):
         ('assigned', 'Ready'),
         ('done', 'Done'),
         ('cancel', 'Cancelled'),
-    ], string='Status', compute='_compute_state',
+    ], string='Status', compute='_compute_state', default='assigned',
         copy=False, index=True, readonly=True, store=True, tracking=True,
         help=" * Draft: The transfer is not confirmed yet. Reservation doesn't apply.\n"
              " * Waiting another operation: This transfer is waiting for another operation before being ready.\n"
@@ -365,8 +365,7 @@ class Picking(models.Model):
     picking_type_id = fields.Many2one(
         'stock.picking.type', 'Operation Type',
         required=True, readonly=True, index=True,
-        default=_default_picking_type_id,
-        states={'draft': [('readonly', False)]})
+        default=_default_picking_type_id)
     picking_type_code = fields.Selection(
         related='picking_type_id.code',
         readonly=True)
@@ -400,9 +399,6 @@ class Picking(models.Model):
     show_check_availability = fields.Boolean(
         compute='_compute_show_check_availability',
         help='Technical field used to compute whether the button "Check Availability" should be displayed.')
-    show_mark_as_todo = fields.Boolean(
-        compute='_compute_show_mark_as_todo',
-        help='Technical field used to compute whether the button "Mark as Todo" should be displayed.')
     show_validate = fields.Boolean(
         compute='_compute_show_validate',
         help='Technical field used to decide whether the button "Validate" should be displayed.')
@@ -426,7 +422,7 @@ class Picking(models.Model):
     show_reserved = fields.Boolean(related='picking_type_id.show_reserved')
     show_lots_text = fields.Boolean(compute='_compute_show_lots_text')
     has_tracking = fields.Boolean(compute='_compute_has_tracking')
-    immediate_transfer = fields.Boolean(default=False)
+    immediate_transfer = fields.Boolean(default=True)
     package_level_ids = fields.One2many('stock.package_level', 'picking_id')
     package_level_ids_details = fields.One2many('stock.package_level', 'picking_id')
     products_availability = fields.Char(
@@ -443,14 +439,14 @@ class Picking(models.Model):
         ('name_uniq', 'unique(name, company_id)', 'Reference must be unique per company!'),
     ]
 
-    @api.depends('show_validate', 'immediate_transfer',
+    @api.depends('show_validate',
                  'move_ids.reserved_availability',
                  'move_ids.quantity_done')
     def _compute_show_qty_button(self):
         self.show_set_qty_button = False
         self.show_clear_qty_button = False
         for picking in self:
-            if not picking.show_validate or picking.immediate_transfer:
+            if not picking.show_validate:
                 continue
             if any(float_is_zero(m.quantity_done, precision_rounding=m.product_uom.rounding) and not float_is_zero(m.reserved_availability, precision_rounding=m.product_uom.rounding) for m in picking.move_ids):
                 picking.show_set_qty_button = True
@@ -511,7 +507,7 @@ class Picking(models.Model):
                 picking.show_operations = True
                 continue
             if picking.picking_type_id.show_operations:
-                if (picking.state == 'draft' and picking.immediate_transfer) or picking.state != 'draft':
+                if (picking.state == 'draft') or picking.state != 'draft':
                     picking.show_operations = True
                 else:
                     picking.show_operations = False
@@ -545,7 +541,7 @@ class Picking(models.Model):
                 ]
             })
 
-    @api.depends('move_type', 'immediate_transfer', 'move_ids.state', 'move_ids.picking_id')
+    @api.depends('move_type', 'move_ids.state', 'move_ids.picking_id')
     def _compute_state(self):
         ''' State of a picking depends on the state of its related stock.move
         - Draft: only used for "planned pickings"
@@ -574,7 +570,9 @@ class Picking(models.Model):
             picking_move_lines[picking_id.id].add(move.id)
         for picking in self:
             picking_id = (picking.ids and picking.ids[0]) or picking.id
-            if not picking_moves_state_map[picking_id]:
+            if not picking_moves_state_map[picking_id] and picking.immediate_transfer:
+                continue
+            elif not picking_moves_state_map[picking_id]:
                 picking.state = 'draft'
             elif picking_moves_state_map[picking_id]['any_draft']:
                 picking.state = 'draft'
@@ -633,13 +631,13 @@ class Picking(models.Model):
         for picking in self:
             picking.has_packages = bool(cnt_by_picking.get(picking.id, False))
 
-    @api.depends('immediate_transfer', 'state')
+    @api.depends('state')
     def _compute_show_check_availability(self):
         """ According to `picking.show_check_availability`, the "check availability" button will be
         displayed in the form view of a picking.
         """
         for picking in self:
-            if picking.immediate_transfer or picking.state not in ('confirmed', 'waiting', 'assigned'):
+            if picking.state not in ('confirmed', 'waiting', 'assigned'):
                 picking.show_check_availability = False
                 continue
             picking.show_check_availability = any(
@@ -648,24 +646,15 @@ class Picking(models.Model):
                 for move in picking.move_ids
             )
 
-    @api.depends('state', 'move_ids')
-    def _compute_show_mark_as_todo(self):
-        for picking in self:
-            if picking.immediate_transfer or picking.state != 'draft':
-                picking.show_mark_as_todo = False
-            else:
-                picking.show_mark_as_todo = True
-
     @api.depends('state')
     def _compute_show_validate(self):
         for picking in self:
-            if not (picking.immediate_transfer) and picking.state == 'draft':
+            if picking.state == 'draft':
                 picking.show_validate = False
             elif picking.state not in ('draft', 'waiting', 'confirmed', 'assigned'):
                 picking.show_validate = False
             else:
                 picking.show_validate = True
-
     @api.depends('state', 'move_ids', 'picking_type_id')
     def _compute_show_allocation(self):
         self.show_allocation = False
@@ -678,7 +667,7 @@ class Picking(models.Model):
     def _compute_location_id(self):
         for picking in self:
             picking = picking.with_company(picking.company_id)
-            if picking.picking_type_id and picking.state == 'draft':
+            if picking.picking_type_id:
                 if picking.picking_type_id.default_location_src_id:
                     location_id = picking.picking_type_id.default_location_src_id.id
                 elif picking.partner_id:
@@ -776,6 +765,12 @@ class Picking(models.Model):
             # order to get a determinist execution of `_set_scheduled_date`
             scheduled_dates.append(vals.pop('scheduled_date', False))
 
+            # immediate transfer is a default value allow in specific cases (interface only)
+            if vals.get('state', 'assigned') != 'assigned':
+                vals['immediate_transfer'] = False
+            if self.env['ir.config_parameter'].sudo().get_param('stock.no_default_immediate_tranfer'):
+                vals['immediate_transfer'] = False
+
         pickings = super().create(vals_list)
 
         for picking, scheduled_date in zip(pickings, scheduled_dates):
@@ -842,6 +837,8 @@ class Picking(models.Model):
 
     def action_confirm(self):
         self._check_company()
+        if not self.env.context.get('skip_draft'):
+            self.filtered(lambda p: p.state in ['assigned', 'draft'] and p.immediate_transfer).action_reset_draft()
         self.mapped('package_level_ids').filtered(lambda pl: pl.state == 'draft' and not pl.move_ids)._generate_moves()
         # call `_action_confirm` on every draft move
         self.move_ids.filtered(lambda move: move.state == 'draft')._action_confirm()
@@ -856,6 +853,7 @@ class Picking(models.Model):
         also impact the state of the picking as it is computed based on move's states.
         @return: True
         """
+        self.mapped('package_level_ids').filtered(lambda pl: pl.state == 'draft' and not pl.move_ids)._generate_moves()
         self.filtered(lambda picking: picking.state == 'draft').action_confirm()
         moves = self.move_ids.filtered(lambda move: move.state not in ('draft', 'cancel', 'done')).sorted(
             key=lambda move: (-int(move.priority), not bool(move.date_deadline), move.date_deadline, move.date, move.id)
@@ -877,6 +875,13 @@ class Picking(models.Model):
         self.filtered(lambda x: not x.move_ids).state = 'cancel'
         return True
 
+    def action_reset_draft(self):
+        picking_to_reset = self.filtered(lambda p: p.state not in ('done', 'cancel'))
+        picking_to_reset.do_unreserve()
+        picking_to_reset.immediate_transfer = False
+        picking_to_reset.move_ids.quantity_done = 0
+        picking_to_reset.move_ids.state = 'draft'
+
     def _action_done(self):
         """Call `_action_done` on the `stock.move` of the `stock.picking` in `self`.
         This method makes sure every `stock.move.line` is linked to a `stock.move` by either
@@ -936,7 +941,7 @@ class Picking(models.Model):
         else:
             for move in self.move_ids:
                 if not move.package_level_id:
-                    if move.state == 'assigned' and move.picking_id and not move.picking_id.immediate_transfer or move.state == 'done':
+                    if move.state == 'assigned' and move.picking_id or move.state == 'done':
                         if any(not ml.package_level_id for ml in move.move_line_ids):
                             move_ids_without_package |= move
                     else:
@@ -1223,9 +1228,8 @@ class Picking(models.Model):
                 continue
             if not picking.move_ids and not picking.package_level_ids:
                 continue
-            if picking.immediate_transfer or any(move.additional for move in picking.move_ids):
-                picking.action_confirm()
-                # Make sure the reservation is bypassed in immediate transfer mode.
+            if any(move.additional for move in picking.move_ids):
+                picking.with_context(skip_draft=picking.immediate_transfer).action_confirm()
                 if picking.immediate_transfer:
                     picking.move_ids.write({'state': 'assigned'})
 
@@ -1498,7 +1502,6 @@ class Picking(models.Model):
             picking_move_lines = self.move_line_ids
             if (
                 not self.picking_type_id.show_reserved
-                and not self.immediate_transfer
                 and not self.env.context.get('barcode_view')
             ):
                 picking_move_lines = self.move_line_nosuggest_ids
