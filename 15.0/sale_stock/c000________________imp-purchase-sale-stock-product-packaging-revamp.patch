PR: https://github.com/odoo/odoo/pull/

From: 688d65530575a6b2a69db404e3f11aaf84ef0035
From: yhu-odoo
Date: 2021-05-06 13:36:28

Structural Changes: 1
Total Changes: 39

[IMP] {purchase, sale}_stock, product: packaging revamp

1. add packaging to PO lines
2. packaging on PO/SO lines can be propagate to MO
3. add package type to packaging
4. on picking types, we can choose to only reserve full packaging. That
means if you want 1 pallet(100 units) and you have 50 units in stock. It
won't be reserved.
5. suggest suitable packaging for PO/SO/MO line according to the product
qty

Task-2357259
PR #68654
UPG PR odoo/upgrade#2444

================================= pseudo patch: =================================

--- a/addons/sale_stock/models/sale_order.py
+++ b/addons/sale_stock/models/sale_order.py
@@ -261,7 +261,6 @@ class SaleOrderLine(models.Model):
     _inherit = 'sale.order.line'
 
     qty_delivered_method = fields.Selection(selection_add=[('stock_move', 'Stock Moves')])
-    product_packaging = fields.Many2one( 'product.packaging', string='Package', default=False, check_company=True)
     route_id = fields.Many2one('stock.location.route', string='Route', domain=[('sale_selectable', '=', True)], ondelete='restrict', check_company=True)
     move_ids = fields.One2many('stock.move', 'sale_line_id', string='Stock Moves')
     product_type = fields.Selection(related='product_id.type')
@@ -461,11 +460,6 @@ class SaleOrderLine(models.Model):
     def _onchange_product_id_set_customer_lead(self):
         self.customer_lead = self.product_id.sale_delay
 
-    @api.onchange('product_packaging')
-    def _onchange_product_packaging(self):
-        if self.product_packaging:
-            return self._check_package()
-
     @api.onchange('product_uom_qty')
     def _onchange_product_uom_qty(self):
         # When modifying a one2many, _origin doesn't guarantee that its values will be the ones
@@ -507,6 +501,7 @@ class SaleOrderLine(models.Model):
             'partner_id': self.order_id.partner_shipping_id.id,
             'product_description_variants': self._get_sale_order_line_multiline_description_variants(),
             'company_id': self.order_id.company_id,
+            'product_packaging_id': self.product_packaging_id.id,
         })
         return values
 
@@ -597,38 +592,6 @@ class SaleOrderLine(models.Model):
                 pickings_to_confirm.action_confirm()
         return True
 
-    def _check_package(self):
-        default_uom = self.product_id.uom_id
-        pack = self.product_packaging
-        qty = self.product_uom_qty
-        q = default_uom._compute_quantity(pack.qty, self.product_uom)
-        # We do not use the modulo operator to check if qty is a mltiple of q. Indeed the quantity
-        # per package might be a float, leading to incorrect results. For example:
-        # 8 % 1.6 = 1.5999999999999996
-        # 5.4 % 1.8 = 2.220446049250313e-16
-        if (
-            qty
-            and q
-            and float_compare(
-                qty / q, float_round(qty / q, precision_rounding=1.0), precision_rounding=0.001
-            )
-            != 0
-        ):
-            newqty = qty - (qty % q) + q
-            return {
-                'warning': {
-                    'title': _('Warning'),
-                    'message': _(
-                        "This product is packaged by %(pack_size).2f %(pack_name)s. You should sell %(quantity).2f %(unit)s.",
-                        pack_size=pack.qty,
-                        pack_name=default_uom.name,
-                        quantity=newqty,
-                        unit=self.product_uom.name
-                    ),
-                },
-            }
-        return {}
-
     def _update_line_quantity(self, values):
         precision = self.env['decimal.precision'].precision_get('Product Unit of Measure')
         line_products = self.filtered(lambda l: l.product_id.type in ['product', 'consu'])
