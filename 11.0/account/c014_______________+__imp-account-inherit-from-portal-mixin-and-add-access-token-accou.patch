PR: https://github.com/odoo/odoo/pull/

From: 6f39672eb686f07ca3941a878c24895c79f2c889
From: Thibault Delavall√©e
Date: 2017-08-25 13:33:17

Structural Changes: 3
Total Changes: 45

[IMP] account: inherit from portal.mixin and add access_token account.invoice

Purpose is to allow customers to access their invoice without having an
user account created. Using an access token they will be able to see
their invoice on the customer portal, like what is already done for
quotations for example.

Invoices now inherit from portal.mixin. This means they have a share url
and a method that generates correctly the /mail/view url using the
access token and signup parameters. This url is used in the email template
used to send email in the invoicing flow.

================================= pseudo patch: =================================

--- a/addons/account/models/account_invoice.py
+++ b/addons/account/models/account_invoice.py
@@ -2,6 +2,8 @@
 
 import json
 import re
+import uuid
+
 from lxml import etree
 from datetime import datetime
 from dateutil.relativedelta import relativedelta
@@ -38,10 +40,13 @@ MAGIC_COLUMNS = ('id', 'create_uid', 'create_date', 'write_uid', 'write_date')
 
 class AccountInvoice(models.Model):
     _name = "account.invoice"
-    _inherit = ['mail.thread', 'mail.activity.mixin']
+    _inherit = ['mail.thread', 'mail.activity.mixin', 'portal.mixin']
     _description = "Invoice"
     _order = "date_invoice desc, number desc, id desc"
 
+    def _get_default_access_token(self):
+        return str(uuid.uuid4())
+
     @api.one
     @api.depends('invoice_line_ids.price_subtotal', 'tax_line_ids.amount', 'currency_id', 'company_id', 'date_invoice', 'type')
     def _compute_amount(self):
@@ -231,6 +236,9 @@ class AccountInvoice(models.Model):
         ], readonly=True, index=True, change_default=True,
         default=lambda self: self._context.get('type', 'out_invoice'),
         track_visibility='always')
+    access_token = fields.Char(
+        'Security Token', copy=False,
+        default=_get_default_access_token)
 
     refund_invoice_id = fields.Many2one('account.invoice', string="Invoice for which this invoice is the credit note")
     number = fields.Char(related='move_id.name', store=True, readonly=True, copy=False)
@@ -353,6 +361,11 @@ class AccountInvoice(models.Model):
         ('number_uniq', 'unique(number, company_id, journal_id, type)', 'Invoice Number must be unique per Company!'),
     ]
 
+    def _compute_portal_url(self):
+        super(AccountInvoice, self)._compute_portal_url()
+        for order in self:
+            order.portal_url = '/my/invoices/%s' % (order.id)
+
     def _no_existing_validated_invoice(self):
         self.ensure_one()
         if self.journal_id.refund_sequence:
@@ -480,6 +493,27 @@ class AccountInvoice(models.Model):
                     view_id = get_view_id('invoice_form', 'account.invoice.form').id
         return super(AccountInvoice, self).fields_view_get(view_id=view_id, view_type=view_type, toolbar=toolbar, submenu=submenu)
 
+    @api.model_cr_context
+    def _init_column(self, column_name):
+        """ Initialize the value of the given column for existing rows.
+
+            Overridden here because we need to generate different access tokens
+            and by default _init_column calls the default method once and applies
+            it for every record.
+        """
+        if column_name != 'access_token':
+            super(AccountInvoice, self)._init_column(column_name)
+        else:
+            query = """UPDATE %(table_name)s
+                          SET %(column_name)s = md5(md5(random()::varchar || id::varchar) || clock_timestamp()::varchar)::uuid::varchar
+                        WHERE %(column_name)s IS NULL
+                    """ % {'table_name': self._name, 'column_name': column_name}
+            self.env.cr.execute(query)
+
+    def _generate_access_token(self):
+        for invoice in self:
+            invoice.access_token = self._get_default_access_token()
+
     @api.multi
     def invoice_print(self):
         """ Print the invoice and mark it as sent, so that we can see more
@@ -692,7 +726,6 @@ class AccountInvoice(models.Model):
             raise UserError(_("Invoice must be in draft or open state in order to be cancelled."))
         return self.action_cancel()
 
-
     @api.multi
     def _notification_recipients(self, message, groups):
         groups = super(AccountInvoice, self)._notification_recipients(message, groups)
@@ -726,13 +759,7 @@ class AccountInvoice(models.Model):
         return super(AccountInvoice, self).get_access_action(access_uid)
 
     def get_mail_url(self):
-        self.ensure_one()
-        params = {
-            'model': self._name,
-            'res_id': self.id,
-        }
-        params.update(self.partner_id.signup_get_auth_param()[self.partner_id.id])
-        return '/mail/view?' + url_encode(params)
+        return self.get_share_url()
 
     @api.multi
     def get_formview_id(self, access_uid=None):
