PR: https://github.com/odoo/odoo/pull/

From: 913f22f73f208b0fa8ca947cf410e32c65adfc93
From: Benjamin Frantzen (bfr)
Date: 2020-05-29 07:16:30

Structural Changes: 11
Total Changes: 440

[ADD] account_edi: generic module to manage EDI (factur-x)

- account_edi is the base module to manage EDIs. It manages the generic worflow of import/export and defines the methods for import/export that should be overridden by each types of EDI (in different modules).
- On export, the files are added as attachment and can be embeded into pdf (format specific).
- On export, the exported format are set on the journal to allow different settings based on journal (different companies, countries, etc).
- On import, depending on the import method (from message_post or upload button in invoice tree view) a new invoice is created or an existing one is updated (only allowed draft invoices with no invoice lines).
- Adapted factur-x

================================= pseudo patch: =================================

--- a/None
+++ b/addons/account_edi/models/__init__.py
@@ -0,0 +1,8 @@
+# -*- encoding: utf-8 -*-
+
+from . import account_move
+from . import account_journal
+from . import account_edi_format
+from . import ir_actions_report
+from . import ir_attachment
+from . import mail_template

--- a/None
+++ b/addons/account_edi/models/account_edi_format.py
@@ -0,0 +1,300 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from odoo import models, fields, api
+from odoo.exceptions import UserError
+from odoo.tools.pdf import OdooPdfFileReader, OdooPdfFileWriter
+
+from lxml import etree
+import base64
+import io
+import logging
+
+_logger = logging.getLogger(__name__)
+
+
+class AccountEdiFormat(models.Model):
+    _name = 'account.edi.format'
+    _description = 'EDI format'
+
+    name = fields.Char()
+    code = fields.Char()
+    hide_on_journal = fields.Selection([('import_export', 'Import/Export'), ('import', 'Import Only')], default='import_export', help='used to hide this EDI format on journals')
+
+    _sql_constraints = [
+        ('unique_code', 'unique (code)', 'This code already exists')
+    ]
+
+    ####################################################
+    # Export method to override based on EDI Format
+    ####################################################
+
+    def _export_invoice_to_attachment(self, invoice):
+        """ Create the file content representing the invoice.
+
+        :param invoice: the invoice to encode.
+        :returns: a dictionary (values are compatible to create an ir.attachment)
+        * name : the name of the file
+        * datas : the content of the file,
+        * res_model : 'account.move',
+        * res_id: the id of invoice
+        * mimetype : the mimetype of the attachment
+        """
+        # TO OVERRIDE
+        self.ensure_one()
+        return False
+
+    def _export_invoice_to_embed_to_pdf(self, pdf_content, invoice):
+        """ Create the file content representing the invoice when it's destined
+            to be embed into a pdf.
+            - default: creates the default EDI document (_export_invoice_to_attachment).
+            - Should return False if this EDI format should not be embedded.
+            - Should be overriden only if a specific behavior (for example,
+            include the pdf content inside the file).
+
+            :param pdf_content: the pdf before any EDI format was added.
+            :param invoice: the invoice to add.
+            :returns: a dictionary or False if this EDI format must not be embedded to pdf.
+            * name : the name of the file
+            * datas : the content of the file,
+            * res_model : 'account.move',
+            * res_id: the id of invoice
+            * mimetype : the mimetype of the attachment
+        """
+        # TO OVERRIDE
+        self.ensure_one()
+        return self._export_invoice_to_attachment(invoice)
+
+    ####################################################
+    # Import methods to override based on EDI Format
+    ####################################################
+
+    def _create_invoice_from_xml_tree(self, filename, tree):
+        """ Create a new invoice with the data inside the xml.
+
+        :param filename: The name of the xml.
+        :param tree:     The tree of the xml to import.
+        :returns:        The created invoice.
+        """
+        # TO OVERRIDE
+        self.ensure_one()
+        return self.env['account.move']
+
+    def _update_invoice_from_xml_tree(self, filename, tree, invoice):
+        """ Update an existing invoice with the data inside the xml.
+
+        :param filename: The name of the xml.
+        :param tree:     The tree of the xml to import.
+        :param invoice:  The invoice to update.
+        :returns:        The updated invoice.
+        """
+        # TO OVERRIDE
+        self.ensure_one()
+        return self.env['account.move']
+
+    def _create_invoice_from_pdf_reader(self, filename, reader):
+        """ Create a new invoice with the data inside a pdf.
+
+        :param filename: The name of the pdf.
+        :param reader:   The OdooPdfFileReader of the pdf to import.
+        :returns:        The created invoice.
+        """
+        # TO OVERRIDE
+        self.ensure_one()
+
+        return self.env['account.move']
+
+    def _update_invoice_from_pdf_reader(self, filename, reader, invoice):
+        """ Update an existing invoice with the data inside the pdf.
+
+        :param filename: The name of the pdf.
+        :param reader:   The OdooPdfFileReader of the pdf to import.
+        :param invoice:  The invoice to update.
+        :returns:        The updated invoice.
+        """
+        # TO OVERRIDE
+        self.ensure_one()
+        return self.env['account.move']
+
+    ####################################################
+    # Export Internal methods (not meant to be overridden)
+    ####################################################
+
+    def _embed_edis_to_pdf(self, pdf_content, invoice):
+        """ Create the EDI document of the invoice and embed it in the pdf_content.
+
+        :param pdf_content: the bytes representing the pdf to add the EDIs to.
+        :param invoice: the invoice to generate the EDI from.
+        :returns: the same pdf_content with the EDI of the invoice embed in it.
+        """
+        attachments = []
+        for edi_format in self:
+            try:
+                vals = edi_format._export_invoice_to_embed_to_pdf(pdf_content, invoice)
+            except:
+                continue
+            if vals:
+                attachments.append(vals)
+
+        if attachments:
+            # Add the attachments to the pdf file
+            reader_buffer = io.BytesIO(pdf_content)
+            reader = OdooPdfFileReader(reader_buffer)
+            writer = OdooPdfFileWriter()
+            writer.cloneReaderDocumentRoot(reader)
+            for vals in attachments:
+                writer.addAttachment(vals['name'], vals['datas'])
+            buffer = io.BytesIO()
+            writer.write(buffer)
+            pdf_content = buffer.getvalue()
+            reader_buffer.close()
+            buffer.close()
+        return pdf_content
+
+    def _create_ir_attachments(self, invoice):
+        """ Create ir.attachment for the EDIs from invoice.
+
+        :param invoice: the invoice to generate the EDI from.
+        :returns: the newly created attachments.
+        """
+        attachment_vals_list = []
+        for edi_format in self:
+            vals = edi_format._export_invoice_to_attachment(invoice)
+            if vals:
+                vals['datas'] = base64.encodebytes(vals['datas'])
+                vals['edi_format_id'] = edi_format._origin.id
+                attachment_vals_list.append(vals)
+        res = self.env['ir.attachment'].create(attachment_vals_list)
+        invoice.edi_document_ids |= res
+        return res
+
+    ####################################################
+    # Import Internal methods (not meant to be overridden)
+    ####################################################
+
+    def _decode_xml(self, filename, content):
+        """Decodes an xml into a list of one dictionary representing an attachment.
+
+        :param filename:    The name of the xml.
+        :param attachment:  The xml as a string.
+        :returns:           A list with a dictionary.
+        * filename:         The name of the attachment.
+        * content:          The content of the attachment.
+        * type:             The type of the attachment.
+        * xml_tree:         The tree of the xml if type is xml.
+        * pdf_reader:       The pdf_reader if type is pdf.
+        """
+        to_process = []
+        try:
+            xml_tree = etree.fromstring(content)
+        except Exception as e:
+            _logger.exception("Error when converting the xml content to etree: %s" % e)
+            return to_process
+        if len(xml_tree):
+            to_process.append({
+                'filename': filename,
+                'content': content,
+                'type': 'xml',
+                'xml_tree': xml_tree,
+            })
+        return to_process
+
+    def _decode_pdf(self, filename, content):
+        """Decodes a pdf and unwrap sub-attachment into a list of dictionary each representing an attachment.
+
+        :param filename:    The name of the pdf.
+        :param content:     The bytes representing the pdf.
+        :returns:           A list of dictionary for each attachment.
+        * filename:         The name of the attachment.
+        * content:          The content of the attachment.
+        * type:             The type of the attachment.
+        * xml_tree:         The tree of the xml if type is xml.
+        * pdf_reader:       The pdf_reader if type is pdf.
+        """
+        to_process = []
+        try:
+            buffer = io.BytesIO(content)
+            pdf_reader = OdooPdfFileReader(buffer)
+        except Exception as e:
+            # Malformed pdf
+            _logger.exception("Error when reading the pdf: %s" % e)
+            return to_process
+
+        # Process embedded files.
+        for xml_name, content in pdf_reader.getAttachments():
+            to_process.extend(self._decode_xml(xml_name, content))
+
+        # Process the pdf itself.
+        to_process.append({
+            'filename': filename,
+            'content': content,
+            'type': 'pdf',
+            'pdf_reader': pdf_reader,
+        })
+
+        return to_process
+
+    def _decode_attachment(self, attachment):
+        """Decodes an ir.attachment and unwrap sub-attachment into a list of dictionary each representing an attachment.
+
+        :param attachment:  An ir.attachment record.
+        :returns:           A list of dictionary for each attachment.
+        * filename:         The name of the attachment.
+        * content:          The content of the attachment.
+        * type:             The type of the attachment.
+        * xml_tree:         The tree of the xml if type is xml.
+        * pdf_reader:       The pdf_reader if type is pdf.
+        """
+        content = base64.b64decode(attachment.with_context(bin_size=False).datas)
+        to_process = []
+
+        if 'pdf' in attachment.mimetype:
+            to_process.extend(self._decode_pdf(attachment.name, content))
+        elif 'xml' in attachment.mimetype:
+            to_process.extend(self._decode_xml(attachment.name, content))
+
+        return to_process
+
+    def _create_invoice_from_attachment(self, attachment):
+        """Decodes an ir.attachment to create an invoice.
+
+        :param attachment:  An ir.attachment record.
+        :returns:           The invoice where to import data.
+        """
+        for file_data in self._decode_attachment(attachment):
+            for edi_format in self:
+                res = False
+                if file_data['type'] == 'xml':
+                    res = edi_format._create_invoice_from_xml_tree(file_data['filename'], file_data['xml_tree'])
+                elif file_data['type'] == 'pdf':
+                    res = edi_format._create_invoice_from_pdf_reader(file_data['filename'], file_data['pdf_reader'])
+                    file_data['pdf_reader'].stream.close()
+                if res:
+                    if 'extract_state' in res:
+                        # Bypass the OCR to prevent overwriting data when an EDI was succesfully imported.
+                        # TODO : remove when we integrate the OCR to the EDI flow.
+                        res.write({'extract_state': 'done'})
+                    return res
+        return self.env['account.move']
+
+    def _update_invoice_from_attachment(self, attachment, invoice):
+        """Decodes an ir.attachment to update an invoice.
+
+        :param attachment:  An ir.attachment record.
+        :returns:           The invoice where to import data.
+        """
+        for file_data in self._decode_attachment(attachment):
+            for edi_format in self:
+                res = False
+                if file_data['type'] == 'xml':
+                    res = edi_format._update_invoice_from_xml_tree(file_data['filename'], file_data['xml_tree'], invoice)
+                elif file_data['type'] == 'pdf':
+                    res = edi_format._update_invoice_from_pdf_reader(file_data['filename'], file_data['pdf_reader'], invoice)
+                    file_data['pdf_reader'].stream.close()
+                if res:
+                    if 'extract_state' in res:
+                        # Bypass the OCR to prevent overwriting data when an EDI was succesfully imported.
+                        # TODO : remove when we integrate the OCR to the EDI flow.
+                        res.write({'extract_state': 'done'})
+                    return res
+        return self.env['account.move']

--- a/None
+++ b/addons/account_edi/models/account_journal.py
@@ -0,0 +1,21 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from odoo import models, fields
+
+
+class AccountJournal(models.Model):
+    _inherit = 'account.journal'
+
+    edi_format_ids = fields.Many2many(comodel_name='account.edi.format',
+                                      string='Electronic invoicing',
+                                      help='Send XML/EDI invoices',
+                                      domain="[('hide_on_journal', '=', 'import_export')]")
+
+    def _create_invoice_from_single_attachment(self, attachment):
+        invoice = self.env['account.edi.format'].search([])._create_invoice_from_attachment(attachment)
+        if invoice:
+            # with_context: we don't want to import the attachment since the invoice was just created from it.
+            invoice.with_context(no_new_invoice=True).message_post(attachment_ids=[attachment.id])
+            return invoice
+        return super()._create_invoice_from_single_attachment(attachment)

--- a/None
+++ b/addons/account_edi/models/account_move.py
@@ -0,0 +1,53 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from odoo import api, models, fields
+
+
+class AccountMove(models.Model):
+    _inherit = 'account.move'
+
+    edi_document_ids = fields.One2many('ir.attachment', 'res_id', domain=[('res_model', '=', 'account.move'), ('edi_format_id', '!=', False)])
+
+    def post(self):
+        # OVERRIDE
+        # Generate the electronic documents for the move.
+        existing_attachments = self.env['ir.attachment'].search([
+            ('res_model', '=', 'account.move'),
+            ('res_id', 'in', self.ids),
+            ('edi_format_id', 'in', self.journal_id.edi_format_ids.ids)])
+        existing_attachments.unlink()
+        res = super(AccountMove, self).post()
+        for move in self:
+            move.journal_id.edi_format_ids._create_ir_attachments(move)
+
+    @api.returns('mail.message', lambda value: value.id)
+    def message_post(self, **kwargs):
+        # OVERRIDE
+        # When posting a message, analyse the attachment to check if it is an EDI document and update the invoice
+        # with the data.
+        res = super(AccountMove, self).message_post(**kwargs)
+
+        if len(self) != 1 or self.env.context.get('no_new_invoice') or not self.is_invoice(include_receipts=True):
+            return res
+
+        attachments = self.env['ir.attachment'].browse(kwargs.get('attachment_ids', []))
+        odoobot = self.env.ref('base.partner_root')
+        if attachments and self.state != 'draft':
+            self.message_post(body='The invoice is not a draft, it was not updated from the attachment.',
+                              message_type='comment',
+                              subtype_xmlid='mail.mt_note',
+                              author_id=odoobot.id)
+            return res
+        if attachments and self.line_ids:
+            self.message_post(body='The invoice already contains lines, it was not updated from the attachment.',
+                              message_type='comment',
+                              subtype_xmlid='mail.mt_note',
+                              author_id=odoobot.id)
+            return res
+
+        for attachment in attachments:
+            invoice = self.env['account.edi.format'].search([])._update_invoice_from_attachment(attachment, self)
+            break
+
+        return res

--- a/None
+++ b/addons/account_edi/models/ir_actions_report.py
@@ -0,0 +1,16 @@
+# -*- coding: utf-8 -*-
+
+from odoo import models, fields, api, _
+
+
+class IrActionsReport(models.Model):
+    _inherit = 'ir.actions.report'
+
+    def _post_pdf(self, save_in_attachment, pdf_content=None, res_ids=None):
+        # OVERRIDE to embed some EDI documents inside the PDF.
+        if self.model == 'account.move' and res_ids and len(res_ids) == 1 and pdf_content:
+            invoice = self.env['account.move'].browse(res_ids)
+            if invoice.is_sale_document() and invoice.state != 'draft':
+                pdf_content = invoice.journal_id.edi_format_ids._embed_edis_to_pdf(pdf_content, invoice)
+
+        return super(IrActionsReport, self)._post_pdf(save_in_attachment, pdf_content=pdf_content, res_ids=res_ids)

--- a/None
+++ b/addons/account_edi/models/ir_attachment.py
@@ -0,0 +1,10 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from odoo import models, fields
+
+
+class IrAttachment(models.Model):
+    _inherit = 'ir.attachment'
+
+    edi_format_id = fields.Many2one('account.edi.format')

--- a/None
+++ b/addons/account_edi/models/mail_template.py
@@ -0,0 +1,32 @@
+# -*- coding: utf-8 -*-
+
+from odoo import api, models
+
+
+class MailTemplate(models.Model):
+    _inherit = "mail.template"
+
+    def generate_email(self, res_ids, fields):
+        res = super().generate_email(res_ids, fields)
+
+        multi_mode = True
+        if isinstance(res_ids, int):
+            res_ids = [res_ids]
+            multi_mode = False
+
+        if self.model != 'account.move':
+            return res
+
+        existing_attachments = self.env['ir.attachment'].search([
+                ('res_model', '=', 'account.move'),
+                ('res_id', 'in', res_ids),
+                ('edi_format_id', '!=', False)])
+
+        for record in self.env[self.model].browse(res_ids):
+            available_formats = existing_attachments.filtered(lambda a: a.res_id == record.id)
+            missing_formats = record.journal_id.edi_format_ids.filtered(lambda f: f._origin.id not in available_formats.edi_format_id.ids)
+            new_attachments = missing_formats._create_ir_attachments(record)
+            available_formats |= new_attachments
+            (res[record.id] if multi_mode else res).setdefault('attachments', []).extend([(a.name, a.datas) for a in available_formats])
+
+        return res
