PR: https://github.com/odoo/odoo/pull/

From: 573ed74c121c1572b3fab6f9553ed7f93f7b3f99
From: Antoine Vandevenne (anv)
Date: 2021-03-30 07:25:51

Structural Changes: 153.8
Total Changes: 2998

[REF] payment, *: refactor online payments API

This commit replaces the old online payments API of the `payment`
module with the new one and adapts to it all the implementing modules.

See the merge commit for more details.

task-2085989
task-2119838
task-2165982
task-2289255

Co-authored-by: Victor Feyens <vfe@odoo.com>

================================= pseudo patch: =================================

--- a/addons/payment/models/__init__.py
+++ b/addons/payment/models/__init__.py
@@ -1,9 +1,12 @@
-# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
 
-from . import payment_acquirer
-from . import account_invoice
-from . import res_partner
+from . import account_chart_template
 from . import account_payment
-from . import chart_template
+from . import account_move
 from . import ir_http
+from . import payment_acquirer
+from . import payment_icon
+from . import payment_token
+from . import payment_transaction
 from . import res_company
+from . import res_partner

--- a/addons/payment/models/chart_template.py
+++ b/addons/payment/models/account_chart_template.py
@@ -1,13 +1,13 @@
-# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
 
-from odoo import api, fields, models, _
+from odoo import models
 
 
 class AccountChartTemplate(models.Model):
     _inherit = 'account.chart.template'
 
     def _create_bank_journals(self, company, acc_template_ref):
-        res = super(AccountChartTemplate, self)._create_bank_journals(company, acc_template_ref)
+        res = super()._create_bank_journals(company, acc_template_ref)
 
         # Try to generate the missing journals
-        return res + self.env['payment.acquirer']._create_missing_journal_for_acquirers(company=company)
+        return res + self.env['payment.acquirer']._create_missing_journals(company=company)

--- a/addons/payment/models/account_invoice.py
+++ b/None
@@ -1,94 +0,0 @@
-# -*- coding: utf-8 -*-
-# Part of Odoo. See LICENSE file for full copyright and licensing details.
-
-from odoo import api, fields, models, _
-from odoo.exceptions import ValidationError
-
-
-class AccountMove(models.Model):
-    _inherit = 'account.move'
-
-    transaction_ids = fields.Many2many('payment.transaction', 'account_invoice_transaction_rel', 'invoice_id', 'transaction_id',
-                                       string='Transactions', copy=False, readonly=True)
-    authorized_transaction_ids = fields.Many2many('payment.transaction', compute='_compute_authorized_transaction_ids',
-                                                  string='Authorized Transactions', copy=False, readonly=True)
-
-    @api.depends('transaction_ids')
-    def _compute_authorized_transaction_ids(self):
-        for trans in self:
-            trans.authorized_transaction_ids = trans.transaction_ids.filtered(lambda t: t.state == 'authorized')
-
-    def get_portal_last_transaction(self):
-        self.ensure_one()
-        return self.with_context(active_test=False).transaction_ids.get_last_transaction()
-
-    def _create_payment_transaction(self, vals):
-        '''Similar to self.env['payment.transaction'].create(vals) but the values are filled with the
-        current invoices fields (e.g. the partner or the currency).
-        :param vals: The values to create a new payment.transaction.
-        :return: The newly created payment.transaction record.
-        '''
-        # Ensure the currencies are the same.
-        currency = self[0].currency_id
-        if any(inv.currency_id != currency for inv in self):
-            raise ValidationError(_('A transaction can\'t be linked to invoices having different currencies.'))
-
-        # Ensure the partner are the same.
-        partner = self[0].partner_id
-        if any(inv.partner_id != partner for inv in self):
-            raise ValidationError(_('A transaction can\'t be linked to invoices having different partners.'))
-
-        # Try to retrieve the acquirer. However, fallback to the token's acquirer.
-        acquirer_id = vals.get('acquirer_id')
-        acquirer = None
-        payment_token_id = vals.get('payment_token_id')
-
-        if payment_token_id:
-            payment_token = self.env['payment.token'].sudo().browse(payment_token_id)
-
-            # Check payment_token/acquirer matching or take the acquirer from token
-            if acquirer_id:
-                acquirer = self.env['payment.acquirer'].browse(acquirer_id)
-                if payment_token and payment_token.acquirer_id != acquirer:
-                    raise ValidationError(_('Invalid token found! Token acquirer %s != %s') % (
-                    payment_token.acquirer_id.name, acquirer.name))
-                if payment_token and payment_token.partner_id != partner:
-                    raise ValidationError(_('Invalid token found! Token partner %s != %s') % (
-                    payment_token.partner.name, partner.name))
-            else:
-                acquirer = payment_token.acquirer_id
-
-        # Check an acquirer is there.
-        if not acquirer_id and not acquirer:
-            raise ValidationError(_('A payment acquirer is required to create a transaction.'))
-
-        if not acquirer:
-            acquirer = self.env['payment.acquirer'].browse(acquirer_id)
-
-        # Check a journal is set on acquirer.
-        if not acquirer.journal_id:
-            raise ValidationError(_('A journal must be specified for the acquirer %s.', acquirer.name))
-
-        if not acquirer_id and acquirer:
-            vals['acquirer_id'] = acquirer.id
-
-        vals.update({
-            'amount': sum(self.mapped('amount_residual')),
-            'currency_id': currency.id,
-            'partner_id': partner.id,
-            'invoice_ids': [(6, 0, self.ids)],
-        })
-
-        transaction = self.env['payment.transaction'].create(vals)
-
-        # Process directly if payment_token
-        if transaction.payment_token_id:
-            transaction.s2s_do_transaction()
-
-        return transaction
-
-    def payment_action_capture(self):
-        self.authorized_transaction_ids.s2s_capture_transaction()
-
-    def payment_action_void(self):
-        self.authorized_transaction_ids.s2s_void_transaction()

--- a/None
+++ b/addons/payment/models/account_move.py
@@ -0,0 +1,32 @@
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from odoo import api, fields, models
+
+
+class AccountMove(models.Model):
+    _inherit = 'account.move'
+
+    transaction_ids = fields.Many2many(
+        string="Transactions", comodel_name='payment.transaction',
+        relation='account_invoice_transaction_rel', column1='invoice_id', column2='transaction_id',
+        readonly=True, copy=False)
+    authorized_transaction_ids = fields.Many2many(
+        string="Authorized Transactions", comodel_name='payment.transaction',
+        compute='_compute_authorized_transaction_ids', readonly=True, copy=False)
+
+    @api.depends('transaction_ids')
+    def _compute_authorized_transaction_ids(self):
+        for invoice in self:
+            invoice.authorized_transaction_ids = invoice.transaction_ids.filtered(
+                lambda tx: tx.state == 'authorized'
+            )
+
+    def get_portal_last_transaction(self):
+        self.ensure_one()
+        return self.with_context(active_test=False).transaction_ids._get_last()
+
+    def payment_action_capture(self):
+        self.authorized_transaction_ids._send_capture_request()
+
+    def payment_action_void(self):
+        self.authorized_transaction_ids._send_void_request()

--- a/addons/payment/models/account_payment.py
+++ b/addons/payment/models/account_payment.py
@@ -1,6 +1,4 @@
-# coding: utf-8
-
-import datetime
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
 
 from odoo import _, api, fields, models
 from odoo.exceptions import ValidationError
@@ -9,30 +7,27 @@ from odoo.exceptions import ValidationError
 class AccountPayment(models.Model):
     _inherit = 'account.payment'
 
-    payment_transaction_id = fields.Many2one('payment.transaction', string='Payment Transaction', readonly=True)
+    payment_transaction_id = fields.Many2one(
+        string="Payment Transaction", comodel_name='payment.transaction', readonly=True)
     payment_token_id = fields.Many2one(
-        'payment.token', string="Saved payment token",
-        domain="""[
+        string="Saved Payment Token", comodel_name='payment.token', domain="""[
             (payment_method_code == 'electronic', '=', 1),
             ('company_id', '=', company_id),
             ('acquirer_id.capture_manually', '=', False),
             ('acquirer_id.journal_id', '=', journal_id),
             ('partner_id', 'in', related_partner_ids),
         ]""",
-        help="Note that tokens from acquirers set to only authorize transactions (instead of capturing the amount) are not available.")
-    related_partner_ids = fields.Many2many('res.partner', compute='_compute_related_partners')
-
-    def _get_payment_chatter_link(self):
-        self.ensure_one()
-        return '<a href=# data-oe-model=account.payment data-oe-id=%d>%s</a>' % (self.id, self.name)
+        help="Note that only tokens from acquirers allowing to capture the amount are available.")
+    related_partner_ids = fields.Many2many(
+        comodel_name='res.partner', compute='_compute_related_partners')
 
     @api.depends('partner_id.commercial_partner_id.child_ids')
     def _compute_related_partners(self):
-        for p in self:
-            p.related_partner_ids = (
-                p.partner_id
-              | p.partner_id.commercial_partner_id
-              | p.partner_id.commercial_partner_id.child_ids
+        for payment in self:
+            payment.related_partner_ids = (
+                    payment.partner_id
+                    | payment.partner_id.commercial_partner_id
+                    | payment.partner_id.commercial_partner_id.child_ids
             )._origin
 
     @api.onchange('partner_id', 'payment_method_id', 'journal_id')
@@ -47,72 +42,65 @@ class AccountPayment(models.Model):
             ('acquirer_id.journal_id', '=', self.journal_id.id),
          ], limit=1)
 
-    def _prepare_payment_transaction_vals(self):
+    def _get_payment_chatter_link(self):
+        self.ensure_one()
+        return f'<a href=# data-oe-model=account.payment data-oe-id={self.id}>{self.name}</a>'
+
+    def _create_payment_transaction(self, **extra_create_values):
+        for payment in self:
+            if payment.payment_transaction_id:
+                raise ValidationError(_(
+                    "A payment transaction with reference %s already exists.",
+                    payment.payment_transaction_id.reference
+                ))
+            elif not payment.payment_token_id:
+                raise ValidationError(_("A token is required to create a new payment transaction."))
+
+        transactions = self.env['payment.transaction']
+        for payment in self:
+            transaction_vals = payment._prepare_payment_transaction_vals(**extra_create_values)
+            transaction = self.env['payment.transaction'].create(transaction_vals)
+            transactions += transaction
+            payment.payment_transaction_id = transaction  # Link the transaction to the payment
+        return transactions
+
+    def _prepare_payment_transaction_vals(self, **extra_create_values):
         self.ensure_one()
         return {
-            'amount': self.amount,
+            'acquirer_id': self.payment_token_id.acquirer_id.id,
             'reference': self.ref,
+            'amount': self.amount,
             'currency_id': self.currency_id.id,
             'partner_id': self.partner_id.id,
-            'partner_country_id': self.partner_id.country_id.id,
-            'payment_token_id': self.payment_token_id.id,
-            'acquirer_id': self.payment_token_id.acquirer_id.id,
+            'token_id': self.payment_token_id.id,
+            'operation': 'offline',
             'payment_id': self.id,
-            'type': 'server2server',
+            **extra_create_values,
         }
 
-    def _create_payment_transaction(self, vals=None):
-        for pay in self:
-            if pay.payment_transaction_id:
-                raise ValidationError(_('A payment transaction already exists.'))
-            elif not pay.payment_token_id:
-                raise ValidationError(_('A token is required to create a new payment transaction.'))
-
-        transactions = self.env['payment.transaction']
-        for pay in self:
-            transaction_vals = pay._prepare_payment_transaction_vals()
-
-            if vals:
-                transaction_vals.update(vals)
-
-            transaction = self.env['payment.transaction'].create(transaction_vals)
-            transactions += transaction
-
-            # Link the transaction to the payment.
-            pay.payment_transaction_id = transaction
-
-        return transactions
-
     def action_post(self):
         # Post the payments "normally" if no transactions are needed.
-        # If not, let the acquirer updates the state.
-        #                                __________            ______________
-        #                               | Payments |          | Transactions |
-        #                               |__________|          |______________|
-        #                                  ||                      |    |
-        #                                  ||                      |    |
-        #                                  ||                      |    |
-        #  __________  no s2s required   __\/______   s2s required |    | s2s_do_transaction()
-        # |  Posted  |<-----------------|  post()  |----------------    |
-        # |__________|                  |__________|<-----              |
-        #                                                |              |
-        #                                               OR---------------
-        #  __________                    __________      |
-        # | Cancelled|<-----------------| cancel() |<-----
-        # |__________|                  |__________|
-
-        payments_need_trans = self.filtered(lambda pay: pay.payment_token_id and not pay.payment_transaction_id)
-        transactions = payments_need_trans._create_payment_transaction()
-
-        res = super(AccountPayment, self - payments_need_trans).action_post()
-
-        transactions.s2s_do_transaction()
-
-        # Post payments for issued transactions.
-        transactions._post_process_after_done()
-        payments_trans_done = payments_need_trans.filtered(lambda pay: pay.payment_transaction_id.state == 'done')
-        super(AccountPayment, payments_trans_done).action_post()
-        payments_trans_not_done = payments_need_trans.filtered(lambda pay: pay.payment_transaction_id.state != 'done')
-        payments_trans_not_done.action_cancel()
+        # If not, let the acquirer update the state.
+
+        payments_need_tx = self.filtered(
+            lambda p: p.payment_token_id and not p.payment_transaction_id
+        )
+        transactions = payments_need_tx._create_payment_transaction()
+
+        res = super(AccountPayment, self - payments_need_tx).action_post()
+
+        for tx in transactions:  # Process the transactions with a payment by token
+            tx._send_payment_request()
+
+        # Post payments for issued transactions
+        transactions._finalize_post_processing()
+        payments_tx_done = payments_need_tx.filtered(
+            lambda p: p.payment_transaction_id.state == 'done'
+        )
+        super(AccountPayment, payments_tx_done).action_post()
+        payments_tx_not_done = payments_need_tx.filtered(
+            lambda p: p.payment_transaction_id.state != 'done'
+        )
+        payments_tx_not_done.action_cancel()
 
         return res

--- a/addons/payment/models/ir_http.py
+++ b/addons/payment/models/ir_http.py
@@ -1,4 +1,3 @@
-# -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
 from odoo import models

--- a/addons/payment/models/payment_acquirer.py
+++ b/addons/payment/models/payment_acquirer.py
@@ -1,205 +1,144 @@
-# coding: utf-8
-from collections import defaultdict
-import hashlib
-import hmac
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
 import logging
-from datetime import datetime
-from dateutil import relativedelta
-import pprint
 import psycopg2
 
-from odoo import api, exceptions, fields, models, _, SUPERUSER_ID
-from odoo.tools import consteq, float_round, image_process, ustr
+from odoo import _, api, fields, models, SUPERUSER_ID
 from odoo.exceptions import ValidationError
-from odoo.tools.misc import DEFAULT_SERVER_DATETIME_FORMAT
-from odoo.tools.misc import formatLang
-from odoo.http import request
 from odoo.osv import expression
 
 _logger = logging.getLogger(__name__)
 
 
-def _partner_format_address(address1=False, address2=False):
-    return ' '.join((address1 or '', address2 or '')).strip()
-
-
-def _partner_split_name(partner_name):
-    return [' '.join(partner_name.split()[:-1]), ' '.join(partner_name.split()[-1:])]
-
-
-def create_missing_journal_for_acquirers(cr, registry):
+def create_missing_journals(cr, registry):
+    """ Post-init hook responsible for the creation of a journal for all acquirers missing one. """
     env = api.Environment(cr, SUPERUSER_ID, {})
-    env['payment.acquirer']._create_missing_journal_for_acquirers()
+    env['payment.acquirer']._create_missing_journals()
 
 
 class PaymentAcquirer(models.Model):
-    """ Acquirer Model. Each specific acquirer can extend the model by adding
-    its own fields, using the acquirer_name as a prefix for the new fields.
-    Using the required_if_provider='<name>' attribute on fields it is possible
-    to have required fields that depend on a specific acquirer.
-
-    Each acquirer has a link to an ir.ui.view record that is a template of
-    a button used to display the payment form. See examples in ``payment_ingenico``
-    and ``payment_paypal`` modules.
-
-    Methods that should be added in an acquirer-specific implementation:
-
-     - ``<name>_form_generate_values(self, reference, amount, currency,
-       partner_id=False, partner_values=None, tx_custom_values=None)``:
-       method that generates the values used to render the form button template.
-     - ``<name>_get_form_action_url(self):``: method that returns the url of
-       the button form. It is used for example in ecommerce application if you
-       want to post some data to the acquirer.
-     - ``<name>_compute_fees(self, amount, currency_id, country_id)``: computes
-       the fees of the acquirer, using generic fields defined on the acquirer
-       model (see fields definition).
-
-    Each acquirer should also define controllers to handle communication between
-    OpenERP and the acquirer. It generally consists in return urls given to the
-    button form and that the acquirer uses to send the customer back after the
-    transaction, with transaction details given as a POST request.
-    """
     _name = 'payment.acquirer'
     _description = 'Payment Acquirer'
-    _order = 'module_state, state, sequence, name'
+    _order = 'module_state, state desc, sequence, name'
 
     def _valid_field_parameter(self, field, name):
         return name == 'required_if_provider' or super()._valid_field_parameter(field, name)
 
-    def _get_default_view_template_id(self):
-        return self.env.ref('payment.default_acquirer_button', raise_if_not_found=False)
-
-    name = fields.Char('Name', required=True, translate=True)
-    color = fields.Integer('Color', compute='_compute_color', store=True)
-    display_as = fields.Char('Displayed as', translate=True, help="How the acquirer is displayed to the customers.")
-    description = fields.Html('Description')
-    sequence = fields.Integer('Sequence', default=10, help="Determine the display order")
+    # Configuration fields
+    name = fields.Char(string="Name", required=True, translate=True)
+    sequence = fields.Integer(string="Sequence", help="Define the display order")
     provider = fields.Selection(
-        selection=[('manual', 'Custom Payment Form')], string='Provider',
-        default='manual', required=True)
-    company_id = fields.Many2one(
-        'res.company', 'Company',
-        default=lambda self: self.env.company.id, required=True)
-    view_template_id = fields.Many2one(
-        'ir.ui.view', 'Form Button Template',
-        default=_get_default_view_template_id,
-        help="This template renders the acquirer button with all necessary values.\n"
-        "It is rendered with qWeb with the following evaluation context:\n"
-        "tx_url: transaction URL to post the form\n"
-        "acquirer: payment.acquirer browse record\n"
-        "user: current user browse record\n"
-        "reference: the transaction reference number\n"
-        "currency: the transaction currency browse record\n"
-        "amount: the transaction amount, a float\n"
-        "partner: the buyer partner browse record, not necessarily set\n"
-        "partner_values: specific values about the buyer, for example coming from a shipping form\n"
-        "tx_values: transaction values\n"
-        "context: the current context dictionary")
-    registration_view_template_id = fields.Many2one(
-        'ir.ui.view', 'S2S Form Template', domain=[('type', '=', 'qweb')],
-        help="Template for method registration")
-    state = fields.Selection([
-        ('disabled', 'Disabled'),
-        ('enabled', 'Enabled'),
-        ('test', 'Test Mode')], required=True, default='disabled', copy=False,
-        help="""In test mode, a fake payment is processed through a test
-             payment interface. This mode is advised when setting up the
-             acquirer. Watch out, test and production modes require
-             different credentials.""")
-    capture_manually = fields.Boolean(string="Capture Amount Manually",
-        help="Capture the amount from Odoo, when the delivery is completed. Use this if you want to charge your customers cards only once you are sure you can ship the goods to them.")
-    journal_id = fields.Many2one(
-        'account.journal', 'Payment Journal', domain="[('type', 'in', ['bank', 'cash']), ('company_id', '=', company_id)]",
-        help="""Journal where the successful transactions will be posted""")
-    check_validity = fields.Boolean(string="Verify Card Validity",
-        help="""Trigger a transaction of 1 currency unit and its refund to check the validity of new credit cards entered in the customer portal.
-        Without this check, the validity will be verified at the very first transaction.""")
+        string="Provider", help="The Payment Service Provider to use with this acquirer",
+        selection=[('none', "No Provider Set")], default='none', required=True)
+    state = fields.Selection(
+        string="State",
+        help="In test mode, a fake payment is processed through a test payment interface.\n"
+             "This mode is advised when setting up the acquirer.",
+        selection=[('disabled', "Disabled"), ('enabled', "Enabled"), ('test', "Test Mode")],
+        default='disabled', required=True, copy=False)
+    company_id = fields.Many2one(  # Indexed to speed-up ORM searches (from ir_rule or others)
+        string="Company", comodel_name='res.company', default=lambda self: self.env.company.id,
+        required=True, index=True)
+    payment_icon_ids = fields.Many2many(
+        string="Supported Payment Icons", comodel_name='payment.icon')
+    allow_tokenization = fields.Boolean(
+        string="Allow Saving Payment Methods",
+        help="This controls whether customers can save their payment methods as payment tokens.\n"
+             "A payment token is an anonymous link to the payment method details saved in the\n"
+             "acquirer's database, allowing the customer to reuse it for a next purchase.")
+    capture_manually = fields.Boolean(
+        string="Capture Amount Manually",
+        help="Capture the amount from Odoo, when the delivery is completed.\n"
+             "Use this if you want to charge your customers cards only when\n"
+             "you are sure you can ship the goods to them.")
+    redirect_form_view_id = fields.Many2one(
+        name="Redirect Form Template", comodel_name='ir.ui.view',
+        help="The template rendering a form submitted to redirect the user when making a payment",
+        domain=[('type', '=', 'qweb')], ondelete='restrict')
+    inline_form_view_id = fields.Many2one(
+        string="Inline Form Template", comodel_name='ir.ui.view',
+        help="The template rendering the inline payment form when making a direct payment",
+        domain=[('type', '=', 'qweb')], ondelete='restrict')
     country_ids = fields.Many2many(
-        'res.country', 'payment_country_rel',
-        'payment_id', 'country_id', 'Countries',
-        help="This payment gateway is available for selected countries. If none is selected it is available for all countries.")
-
+        string="Countries", comodel_name='res.country', relation='payment_country_rel',
+        column1='payment_id', column2='country_id',
+        help="The countries for which this payment acquirer is available.\n"
+             "If none is set, it is available for all countries.")
+    journal_id = fields.Many2one(
+        string="Payment Journal", comodel_name='account.journal',
+        help="The journal in which the successful transactions are posted",
+        domain="[('type', 'in', ['bank', 'cash']), ('company_id', '=', company_id)]")
+
+    # Fees fields
+    fees_active = fields.Boolean(string="Add Extra Fees")
+    fees_dom_fixed = fields.Float(string="Fixed domestic fees")
+    fees_dom_var = fields.Float(string="Variable domestic fees (in percents)")
+    fees_int_fixed = fields.Float(string="Fixed international fees")
+    fees_int_var = fields.Float(string="Variable international fees (in percents)")
+
+    # Message fields
+    display_as = fields.Char(
+        string="Displayed as", help="Description of the acquirer for customers",
+        translate=True)
     pre_msg = fields.Html(
-        'Help Message', translate=True,
-        help='Message displayed to explain and help the payment process.')
-    auth_msg = fields.Html(
-        'Authorize Message', translate=True,
-        default=lambda s: _('Your payment has been authorized.'),
-        help='Message displayed if payment is authorized.')
+        string="Help Message", help="The message displayed to explain and help the payment process",
+        translate=True)
     pending_msg = fields.Html(
-        'Pending Message', translate=True,
-        default=lambda s: _('Your payment has been successfully processed but is waiting for approval.'),
-        help='Message displayed, if order is in pending state after having done the payment process.')
+        string="Pending Message",
+        help="The message displayed if the order pending after the payment process",
+        default=lambda self: _(
+            "Your payment has been successfully processed but is waiting for approval."
+        ), translate=True)
+    auth_msg = fields.Html(
+        string="Authorize Message", help="The message displayed if payment is authorized",
+        default=lambda self: _("Your payment has been authorized."), translate=True)
     done_msg = fields.Html(
-        'Done Message', translate=True,
-        default=lambda s: _('Your payment has been successfully processed. Thank you!'),
-        help='Message displayed, if order is done successfully after having done the payment process.')
+        string="Done Message",
+        help="The message displayed if the order is successfully done after the payment process",
+        default=lambda self: _("Your payment has been successfully processed. Thank you!"),
+        translate=True)
     cancel_msg = fields.Html(
-        'Cancel Message', translate=True,
-        default=lambda s: _('Your payment has been cancelled.'),
-        help='Message displayed, if order is cancel during the payment process.')
-    save_token = fields.Selection([
-        ('none', 'Never'),
-        ('ask', 'Let the customer decide'),
-        ('always', 'Always')],
-        string='Save Cards', default='none',
-        help="This option allows customers to save their credit card as a payment token and to reuse it for a later purchase. "
-             "If you manage subscriptions (recurring invoicing), you need it to automatically charge the customer when you "
-             "issue an invoice.")
-    token_implemented = fields.Boolean('Saving Card Data supported', compute='_compute_feature_support', search='_search_is_tokenized')
-    authorize_implemented = fields.Boolean('Authorize Mechanism Supported', compute='_compute_feature_support')
-    fees_implemented = fields.Boolean('Fees Computation Supported', compute='_compute_feature_support')
-    fees_active = fields.Boolean('Add Extra Fees')
-    fees_dom_fixed = fields.Float('Fixed domestic fees')
-    fees_dom_var = fields.Float('Variable domestic fees (in percents)')
-    fees_int_fixed = fields.Float('Fixed international fees')
-    fees_int_var = fields.Float('Variable international fees (in percents)')
-    qr_code = fields.Boolean('Enable QR Codes', help="Enable the use of QR-codes for payments made on this provider.")
-
-    # TDE FIXME: remove that brol
-    module_id = fields.Many2one('ir.module.module', string='Corresponding Module')
-    module_state = fields.Selection(string='Installation State', related='module_id.state', store=True)
-    module_to_buy = fields.Boolean(string='Odoo Enterprise Module', related='module_id.to_buy', readonly=True, store=False)
-
-    image_128 = fields.Image("Image", max_width=128, max_height=128)
-
-    payment_icon_ids = fields.Many2many('payment.icon', string='Supported Payment Icons')
-    payment_flow = fields.Selection(selection=[('form', 'Redirection to the acquirer website'),
-        ('s2s','Payment from Odoo')],
-        default='form', required=True, string='Payment Flow',
-        help="""Note: Subscriptions does not take this field in account, it uses server to server by default.""")
-    inbound_payment_method_ids = fields.Many2many('account.payment.method', related='journal_id.inbound_payment_method_ids', readonly=False)
-
-    @api.onchange('payment_flow')
-    def _onchange_payment_flow(self):
-        electronic = self.env.ref('payment.account_payment_method_electronic_in')
-        if self.token_implemented and self.payment_flow == 's2s':
-            if electronic not in self.inbound_payment_method_ids:
-                self.inbound_payment_method_ids = [(4, electronic.id)]
-        elif electronic in self.inbound_payment_method_ids:
-            self.inbound_payment_method_ids = [(2, electronic.id)]
-
-    @api.onchange('state')
-    def onchange_state(self):
-        """Disable dashboard display for test acquirer journal."""
-        self.journal_id.update({'show_on_dashboard': self.state == 'enabled'})
-
-    def _search_is_tokenized(self, operator, value):
-        tokenized = self._get_feature_support()['tokenize']
-        if (operator, value) in [('=', True), ('!=', False)]:
-            return [('provider', 'in', tokenized)]
-        return [('provider', 'not in', tokenized)]
-
-    @api.depends('provider')
-    def _compute_feature_support(self):
-        feature_support = self._get_feature_support()
-        for acquirer in self:
-            acquirer.fees_implemented = acquirer.provider in feature_support['fees']
-            acquirer.authorize_implemented = acquirer.provider in feature_support['authorize']
-            acquirer.token_implemented = acquirer.provider in feature_support['tokenize']
+        string="Canceled Message",
+        help="The message displayed if the order is canceled during the payment process",
+        default=lambda self: _("Your payment has been cancelled."), translate=True)
+
+    # Feature support fields
+    support_authorization = fields.Boolean(string="Authorize Mechanism Supported")
+    support_fees_computation = fields.Boolean(string="Fees Computation Supported")
+    support_tokenization = fields.Boolean(string="Tokenization supported")
+
+    # Kanban view fields
+    description = fields.Html(
+        string="Description", help="The description shown in the card in kanban view ")
+    image_128 = fields.Image(string="Image", max_width=128, max_height=128)
+    color = fields.Integer(
+        string="Color", help="The color of the card in kanban view", compute='_compute_color',
+        store=True)
+
+    # Module-related fields
+    module_id = fields.Many2one(string="Corresponding Module", comodel_name='ir.module.module')
+    module_state = fields.Selection(
+        string="Installation State", related='module_id.state', store=True)  # Stored for sorting
+    module_to_buy = fields.Boolean(string="Odoo Enterprise Module", related='module_id.to_buy')
+
+    # View configuration fields
+    show_credentials_page = fields.Boolean(compute='_compute_view_configuration_fields')
+    show_allow_tokenization = fields.Boolean(compute='_compute_view_configuration_fields')
+    show_payment_icon_ids = fields.Boolean(compute='_compute_view_configuration_fields')
+    show_pre_msg = fields.Boolean(compute='_compute_view_configuration_fields')
+    show_pending_msg = fields.Boolean(compute='_compute_view_configuration_fields')
+    show_auth_msg = fields.Boolean(compute='_compute_view_configuration_fields')
+    show_done_msg = fields.Boolean(compute='_compute_view_configuration_fields')
+    show_cancel_msg = fields.Boolean(compute='_compute_view_configuration_fields')
+
+    #=== COMPUTE METHODS ===#
 
     @api.depends('state', 'module_state')
     def _compute_color(self):
+        """ Update the color of the kanban card based on the state of the acquirer.
+
+        :return: None
+        """
         for acquirer in self:
             if acquirer.module_id and not acquirer.module_state == 'installed':
                 acquirer.color = 4  # blue
@@ -210,58 +149,164 @@ class PaymentAcquirer(models.Model):
             elif acquirer.state == 'enabled':
                 acquirer.color = 7  # green
 
+    @api.depends('provider')
+    def _compute_view_configuration_fields(self):
+        """ Compute view configuration fields based on the provider.
+
+        By default, all fields are set to `True`.
+        For an acquirer to hide generic elements (pages, fields) in a view, it must override this
+        method and set their corresponding view configuration field to `False`.
+
+        :return: None
+        """
+        self.write({
+            'show_credentials_page': True,
+            'show_allow_tokenization': True,
+            'show_payment_icon_ids': True,
+            'show_pre_msg': True,
+            'show_pending_msg': True,
+            'show_auth_msg': True,
+            'show_done_msg': True,
+            'show_cancel_msg': True,
+        })
+
+    #=== ONCHANGE METHODS ===#
+
+    @api.onchange('state')
+    def _onchange_state(self):
+        """ Only enable dashboard display for journals of enabled acquirers.
+
+        :return: None
+        """
+        for acquirer in self:
+            acquirer.journal_id.show_on_dashboard = acquirer.state == 'enabled'
+
+    @api.onchange('allow_tokenization')
+    def _onchange_allow_tokenization(self):
+        """ Add (remove) the electronic payment method for acquirers (not) allowing tokenization.
+
+        :return: None
+        """
+        electronic = self.env.ref('payment.account_payment_method_electronic_in')
+        for acquirer in self:
+            if acquirer.allow_tokenization:
+                if electronic not in acquirer.journal_id.inbound_payment_method_ids:
+                    acquirer.journal_id.inbound_payment_method_ids = [(4, electronic.id)]
+            elif electronic in acquirer.journal_id.inbound_payment_method_ids:
+                acquirer.journal_id.inbound_payment_method_ids = [(3, electronic.id)]
+
+    #=== CONSTRAINT METHODS ===#
+
+    @api.constrains('fees_dom_var', 'fees_int_var')
+    def _check_fee_var_within_boundaries(self):
+        """ Check that variable fees are within realistic boundaries.
+
+        Variable fees values should always be positive and below 100% to respectively avoid negative
+        and infinite (division by zero) fees amount.
+
+        :return None
+        """
+        for acquirer in self:
+            if any(not 0 <= fee < 100 for fee in (acquirer.fees_dom_var, acquirer.fees_int_var)):
+                raise ValidationError(_("Variable fees must always be positive and below 100%."))
+
+    #=== CRUD METHODS ===#
+
+    @api.model_create_multi
+    def create(self, values_list):
+        acquirers = super().create(values_list)
+        acquirers._check_required_if_provider()
+        return acquirers
+
+    def write(self, values):
+        result = super().write(values)
+        self._check_required_if_provider()
+        return result
+
     def _check_required_if_provider(self):
-        """ If the field has 'required_if_provider="<provider>"' attribute, then it
-        required if record.provider is <provider>. """
+        """ Check that acquirer-specific required fields have been filled.
+
+        The fields that have the `required_if_provider="<provider>"` attribute are made required
+        for all payment.acquirer records with the `provider` field equal to <provider> and with the
+        `state` field equal to 'enabled' or 'test'.
+        Acquirer-specific views should make the form fields required under the same conditions.
+
+        :return: None
+        :raise ValidationError: if an acquirer-specific required field is empty
+        """
         field_names = []
         enabled_acquirers = self.filtered(lambda acq: acq.state in ['enabled', 'test'])
-        for k, f in self._fields.items():
-            provider = getattr(f, 'required_if_provider', None)
-            if provider and any(
-                acquirer.provider == provider and not acquirer[k]
+        for name, field in self._fields.items():
+            required_provider = getattr(field, 'required_if_provider', None)
+            if required_provider and any(
+                required_provider == acquirer.provider and not acquirer[name]
                 for acquirer in enabled_acquirers
             ):
-                ir_field = self.env['ir.model.fields']._get(self._name, k)
+                ir_field = self.env['ir.model.fields']._get(self._name, name)
                 field_names.append(ir_field.field_description)
         if field_names:
-            raise ValidationError(_("Required fields not filled: %s") % ", ".join(field_names))
+            raise ValidationError(
+                _("The following fields must be filled: %s", ", ".join(field_names))
+            )
 
-    def get_base_url(self):
-        self.ensure_one()
-        # priority is always given to url_root
-        # from the request
-        url = ''
-        if request:
-            url = request.httprequest.url_root
-
-        if not url and 'website_id' in self and self.website_id:
-            url = self.website_id._get_http_domain()
-
-        return url or self.env['ir.config_parameter'].sudo().get_param('web.base.url')
-
-    def _get_feature_support(self):
-        """Get advanced feature support by provider.
-
-        Each provider should add its technical in the corresponding
-        key for the following features:
-            * fees: support payment fees computations
-            * authorize: support authorizing payment (separates
-                         authorization and capture)
-            * tokenize: support saving payment data in a payment.tokenize
-                        object
+    @api.model
+    def _create_missing_journals(self, company=None):
+        """ Create a journal for installed acquirers missing one.
+
+        Each acquirer must have its own journal. It can't however be created along the
+        `payment.acquirer` record because there is no guarantee that the chart template is already
+        installed.
+
+        :param recordset company: The company for which the journals are created, as a `res.company`
+                                  recordset
+        :return: The created journals
+        :rtype: recordset of `account.journal`
         """
-        return dict(authorize=[], tokenize=[], fees=[])
+        # Search for installed acquirer modules having no journal for the current company
+        company = company or self.env.company
+        acquirers = self.env['payment.acquirer'].search([
+            ('journal_id', '=', False),
+            ('company_id', '=', company.id),
+            ('module_state', 'in', ('to install', 'installed')),
+        ])
 
-    def _prepare_account_journal_vals(self):
-        '''Prepare the values to create the acquirer's journal.
-        :return: a dictionary to create a account.journal record.
-        '''
+        # Create or find the missing journals.
+        # This is done in this order and not the other way around because the most common cause for
+        # a missing journal is the first install of an acquirer's module. The other (less common)
+        # cause is a re-install. In this last case, the creation will fail because of a unique
+        # constraint violation, we catch the error, and fallback on searching the previous journal.
+        Journal = journals = self.env['account.journal']
+        for acquirer in acquirers.filtered('company_id.chart_template_id'):
+            try:
+                with self.env.cr.savepoint():
+                    journal = Journal.create(acquirer._get_journal_create_values())
+            except psycopg2.IntegrityError as error:  # Journal already exists
+                if error.pgcode == psycopg2.errorcodes.UNIQUE_VIOLATION:
+                    journal = Journal.search(acquirer._get_journal_search_domain(), limit=1)
+                else:
+                    raise error
+            acquirer.journal_id = journal
+            journals += journal
+        return journals
+
+    def _get_journal_create_values(self):
+        """ Return a dict of values to create the acquirer's journal.
+
+        Note: self.ensure_one()
+
+        :return: The dict of create values for `account.journal`
+        :rtype: dict
+        """
         self.ensure_one()
-        account_vals = self.company_id.chart_template_id._prepare_transfer_account_for_direct_creation(self.name, self.company_id)
+
+        account_vals = self.company_id.chart_template_id. \
+            _prepare_transfer_account_for_direct_creation(self.name, self.company_id)
         account = self.env['account.account'].create(account_vals)
         inbound_payment_method_ids = []
-        if self.token_implemented and self.payment_flow == 's2s':
-            inbound_payment_method_ids.append((4, self.env.ref('payment.account_payment_method_electronic_in').id))
+        if self.allow_tokenization:
+            inbound_payment_method_ids.append(
+                (4, self.env.ref('payment.account_payment_method_electronic_in').id)
+            )
         return {
             'name': self.name,
             'code': self.name.upper(),
@@ -271,14 +316,21 @@ class PaymentAcquirer(models.Model):
             'default_account_id': account.id,
             # Show the journal on dashboard if the acquirer is published on the website.
             'show_on_dashboard': self.state == 'enabled',
-            # Don't show payment methods in the backend.
+            # Don't show payment methods in the backend
             'inbound_payment_method_ids': inbound_payment_method_ids,
             'outbound_payment_method_ids': [],
         }
 
-    def _get_acquirer_journal_domain(self):
-        """Returns a domain for finding a journal corresponding to an acquirer"""
+    def _get_journal_search_domain(self):
+        """ Return a domain for searching a journal corresponding to the acquirer.
+
+        Note: self.ensure_one()
+
+        :return: The search domain
+        :rtype: list
+        """
         self.ensure_one()
+
         code_cutoff = self.env['account.journal']._fields['code'].size
         return [
             ('name', '=', self.name),
@@ -286,257 +338,16 @@ class PaymentAcquirer(models.Model):
             ('company_id', '=', self.company_id.id),
         ]
 
-    @api.model
-    def _create_missing_journal_for_acquirers(self, company=None):
-        '''Create the journal for active acquirers.
-        We want one journal per acquirer. However, we can't create them during the 'create' of the payment.acquirer
-        because every acquirers are defined on the 'payment' module but is active only when installing their own module
-        (e.g. payment_paypal for Paypal). We can't do that in such modules because we have no guarantee the chart template
-        is already installed.
-        '''
-        # Search for installed acquirers modules that have no journal for the current company.
-        # If this method is triggered by a post_init_hook, the module is 'to install'.
-        # If the trigger comes from the chart template wizard, the modules are already installed.
-        company = company or self.env.company
-        acquirers = self.env['payment.acquirer'].search([
-            ('module_state', 'in', ('to install', 'installed')),
-            ('journal_id', '=', False),
-            ('company_id', '=', company.id),
-        ])
-
-        # Here we will attempt to first create the journal since the most common case (first
-        # install) is to successfully to create the journal for the acquirer, in the case of a
-        # reinstall (least common case), the creation will fail because of a unique constraint
-        # violation, this is ok as we catch the error and then perform a search if need be
-        # and assign the existing journal to our reinstalled acquirer. It is better to ask for
-        # forgiveness than to ask for permission as this saves us the overhead of doing a select
-        # that would be useless in most cases.
-        Journal = journals = self.env['account.journal']
-        for acquirer in acquirers.filtered(lambda l: not l.journal_id and l.company_id.chart_template_id):
-            try:
-                with self.env.cr.savepoint():
-                    journal = Journal.create(acquirer._prepare_account_journal_vals())
-            except psycopg2.IntegrityError as e:
-                if e.pgcode == psycopg2.errorcodes.UNIQUE_VIOLATION:
-                    journal = Journal.search(acquirer._get_acquirer_journal_domain(), limit=1)
-                else:
-                    raise
-            acquirer.journal_id = journal
-            journals += journal
-        return journals
-
-    @api.model_create_multi
-    def create(self, vals_list):
-        records = super(PaymentAcquirer, self).create(vals_list)
-        records._check_required_if_provider()
-        return records
-
-    def write(self, vals):
-        result = super(PaymentAcquirer, self).write(vals)
-        self._check_required_if_provider()
-        return result
-
-    def get_acquirer_extra_fees(self, amount, currency_id, country_id):
-        extra_fees = {
-            'currency_id': currency_id
-        }
-        acquirers = self.filtered(lambda x: x.fees_active)
-        for acq in acquirers:
-            custom_method_name = '%s_compute_fees' % acq.provider
-            if hasattr(acq, custom_method_name):
-                fees = getattr(acq, custom_method_name)(amount, currency_id, country_id)
-                extra_fees[acq] = fees
-        return extra_fees
-
-    def get_form_action_url(self):
-        """ Returns the form action URL, for form-based acquirer implementations. """
-        if hasattr(self, '%s_get_form_action_url' % self.provider):
-            return getattr(self, '%s_get_form_action_url' % self.provider)()
-        return False
-
-    def _get_available_payment_input(self, partner=None, company=None):
-        """ Generic (model) method that fetches available payment mechanisms
-        to use in all portal / eshop pages that want to use the payment form.
-
-        It contains
+    #=== ACTION METHODS ===#
 
-         * acquirers: record set of both form and s2s acquirers;
-         * pms: record set of stored credit card data (aka payment.token)
-                connected to a given partner to allow customers to reuse them """
-        if not company:
-            company = self.env.company
-        if not partner:
-            partner = self.env.user.partner_id
-
-        domain = expression.AND([
-            ['&', ('state', 'in', ['enabled', 'test']), ('company_id', '=', company.id)],
-            ['|', ('country_ids', '=', False), ('country_ids', 'in', [partner.country_id.id])]
-        ])
-        active_acquirers = self.search(domain)
-        acquirers = active_acquirers.filtered(lambda acq: (acq.payment_flow == 'form' and acq.view_template_id) or
-                                                               (acq.payment_flow == 's2s' and acq.registration_view_template_id))
-        return {
-            'acquirers': acquirers,
-            'pms': self.env['payment.token'].search([
-                ('partner_id', '=', partner.id),
-                ('acquirer_id', 'in', acquirers.ids)]),
-        }
+    def button_immediate_install(self):
+        """ Install the acquirer's module and reload the page.
 
-    def render(self, reference, amount, currency_id, partner_id=False, values=None):
-        """ Renders the form template of the given acquirer as a qWeb template.
-        :param string reference: the transaction reference
-        :param float amount: the amount the buyer has to pay
-        :param currency_id: currency id
-        :param dict partner_id: optional partner_id to fill values
-        :param dict values: a dictionary of values for the transction that is
-        given to the acquirer-specific method generating the form values
-
-        All templates will receive:
-
-         - acquirer: the payment.acquirer browse record
-         - user: the current user browse record
-         - currency_id: id of the transaction currency
-         - amount: amount of the transaction
-         - reference: reference of the transaction
-         - partner_*: partner-related values
-         - partner: optional partner browse record
-         - 'feedback_url': feedback URL, controler that manage answer of the acquirer (without base url) -> FIXME
-         - 'return_url': URL for coming back after payment validation (wihout base url) -> FIXME
-         - 'cancel_url': URL if the client cancels the payment -> FIXME
-         - 'error_url': URL if there is an issue with the payment -> FIXME
-         - context: Odoo context
+        Note: self.ensure_one()
 
+        :return: The action to reload the page
+        :rtype: dict
         """
-        if values is None:
-            values = {}
-
-        if not self.view_template_id:
-            return None
-
-        values.setdefault('return_url', '/payment/process')
-        # reference and amount
-        values.setdefault('reference', reference)
-        amount = float_round(amount, 2)
-        values.setdefault('amount', amount)
-
-        # currency id
-        currency_id = values.setdefault('currency_id', currency_id)
-        if currency_id:
-            currency = self.env['res.currency'].browse(currency_id)
-        else:
-            currency = self.env.company.currency_id
-        values['currency'] = currency
-
-        # Fill partner_* using values['partner_id'] or partner_id argument
-        partner_id = values.get('partner_id', partner_id)
-        billing_partner_id = values.get('billing_partner_id', partner_id)
-        if partner_id:
-            partner = self.env['res.partner'].browse(partner_id)
-            if partner_id != billing_partner_id:
-                billing_partner = self.env['res.partner'].browse(billing_partner_id)
-            else:
-                billing_partner = partner
-            values.update({
-                'partner': partner,
-                'partner_id': partner_id,
-                'partner_name': partner.name,
-                'partner_lang': partner.lang,
-                'partner_email': partner.email,
-                'partner_zip': partner.zip,
-                'partner_city': partner.city,
-                'partner_address': _partner_format_address(partner.street, partner.street2),
-                'partner_country_id': partner.country_id.id or self.env['res.company']._company_default_get().country_id.id,
-                'partner_country': partner.country_id,
-                'partner_phone': partner.phone,
-                'partner_state': partner.state_id,
-                'billing_partner': billing_partner,
-                'billing_partner_id': billing_partner_id,
-                'billing_partner_name': billing_partner.name,
-                'billing_partner_commercial_company_name': billing_partner.commercial_company_name,
-                'billing_partner_lang': billing_partner.lang,
-                'billing_partner_email': billing_partner.email,
-                'billing_partner_zip': billing_partner.zip,
-                'billing_partner_city': billing_partner.city,
-                'billing_partner_address': _partner_format_address(billing_partner.street, billing_partner.street2),
-                'billing_partner_country_id': billing_partner.country_id.id,
-                'billing_partner_country': billing_partner.country_id,
-                'billing_partner_phone': billing_partner.phone,
-                'billing_partner_state': billing_partner.state_id,
-            })
-        if values.get('partner_name'):
-            values.update({
-                'partner_first_name': _partner_split_name(values.get('partner_name'))[0],
-                'partner_last_name': _partner_split_name(values.get('partner_name'))[1],
-            })
-        if values.get('billing_partner_name'):
-            values.update({
-                'billing_partner_first_name': _partner_split_name(values.get('billing_partner_name'))[0],
-                'billing_partner_last_name': _partner_split_name(values.get('billing_partner_name'))[1],
-            })
-
-        # Fix address, country fields
-        if not values.get('partner_address'):
-            values['address'] = _partner_format_address(values.get('partner_street', ''), values.get('partner_street2', ''))
-        if not values.get('partner_country') and values.get('partner_country_id'):
-            values['country'] = self.env['res.country'].browse(values.get('partner_country_id'))
-        if not values.get('billing_partner_address'):
-            values['billing_address'] = _partner_format_address(values.get('billing_partner_street', ''), values.get('billing_partner_street2', ''))
-        if not values.get('billing_partner_country') and values.get('billing_partner_country_id'):
-            values['billing_country'] = self.env['res.country'].browse(values.get('billing_partner_country_id'))
-
-        # compute fees
-        fees_method_name = '%s_compute_fees' % self.provider
-        if hasattr(self, fees_method_name):
-            fees = getattr(self, fees_method_name)(values['amount'], values['currency_id'], values.get('partner_country_id'))
-            values['fees'] = float_round(fees, 2)
-
-        # call <name>_form_generate_values to update the tx dict with acqurier specific values
-        cust_method_name = '%s_form_generate_values' % (self.provider)
-        if hasattr(self, cust_method_name):
-            method = getattr(self, cust_method_name)
-            values = method(values)
-
-        values.update({
-            'tx_url': self._context.get('tx_url', self.get_form_action_url()),
-            'submit_class': self._context.get('submit_class', 'btn btn-link'),
-            'submit_txt': self._context.get('submit_txt'),
-            'acquirer': self,
-            'user': self.env.user,
-            'context': self._context,
-            'type': values.get('type') or 'form',
-        })
-
-        _logger.info('payment.acquirer.render: <%s> values rendered for form payment:\n%s', self.provider, pprint.pformat(values))
-        return self.view_template_id._render(values, engine='ir.qweb')
-
-    def get_s2s_form_xml_id(self):
-        if self.registration_view_template_id:
-            model_data = self.env['ir.model.data'].search([('model', '=', 'ir.ui.view'), ('res_id', '=', self.registration_view_template_id.id)])
-            return ('%s.%s') % (model_data.module, model_data.name)
-        return False
-
-    def s2s_process(self, data):
-        cust_method_name = '%s_s2s_form_process' % (self.provider)
-        if not self.s2s_validate(data):
-            return False
-        if hasattr(self, cust_method_name):
-            # As this method may be called in JSON and overridden in various addons
-            # let us raise interesting errors before having stranges crashes
-            if not data.get('partner_id'):
-                raise ValueError(_('Missing partner reference when trying to create a new payment token'))
-            method = getattr(self, cust_method_name)
-            return method(data)
-        return True
-
-    def s2s_validate(self, data):
-        cust_method_name = '%s_s2s_form_validate' % (self.provider)
-        if hasattr(self, cust_method_name):
-            method = getattr(self, cust_method_name)
-            return method(data)
-        return True
-
-    def button_immediate_install(self):
-        # TDE FIXME: remove that brol
         if self.module_id and self.module_state != 'installed':
             self.module_id.button_immediate_install()
             return {
@@ -544,701 +355,153 @@ class PaymentAcquirer(models.Model):
                 'tag': 'reload',
             }
 
-class PaymentIcon(models.Model):
-    _name = 'payment.icon'
-    _description = 'Payment Icon'
-
-    name = fields.Char(string='Name')
-    acquirer_ids = fields.Many2many('payment.acquirer', string="Acquirers", help="List of Acquirers supporting this payment icon.")
-    image = fields.Binary(
-        "Image", help="This field holds the image used for this payment icon, limited to 1024x1024px")
-
-    image_payment_form = fields.Binary(
-        "Image displayed on the payment form", attachment=True)
-
-    @api.model_create_multi
-    def create(self, vals_list):
-        for vals in vals_list:
-            if 'image' in vals:
-                image = ustr(vals['image'] or '').encode('utf-8')
-                vals['image_payment_form'] = image_process(image, size=(45,30))
-                vals['image'] = image_process(image, size=(64,64))
-        return super(PaymentIcon, self).create(vals_list)
-
-    def write(self, vals):
-        if 'image' in vals:
-            image = ustr(vals['image'] or '').encode('utf-8')
-            vals['image_payment_form'] = image_process(image, size=(45,30))
-            vals['image'] = image_process(image, size=(64,64))
-        return super(PaymentIcon, self).write(vals)
-
-class PaymentTransaction(models.Model):
-    """ Transaction Model. Each specific acquirer can extend the model by adding
-    its own fields.
-
-    Methods that can be added in an acquirer-specific implementation:
-
-     - ``<name>_create``: method receiving values used when creating a new
-       transaction and that returns a dictionary that will update those values.
-       This method can be used to tweak some transaction values.
-
-    Methods defined for convention, depending on your controllers:
-
-     - ``<name>_form_feedback(self, data)``: method that handles the data coming
-       from the acquirer after the transaction. It will generally receives data
-       posted by the acquirer after the transaction.
-    """
-    _name = 'payment.transaction'
-    _description = 'Payment Transaction'
-    _order = 'id desc'
-    _rec_name = 'reference'
+    #=== BUSINESS METHODS ===#
 
     @api.model
-    def _lang_get(self):
-        return self.env['res.lang'].get_installed()
+    def _get_compatible_acquirers(
+        self, company_id, partner_id, currency_id=None, force_tokenization=False,
+        preferred_acquirer_id=None, **kwargs
+    ):
+        """ Select and return the acquirers matching the criteria.
+
+        The base criteria are that acquirers must not be disabled, be in the company that is
+        provided, and support the country of the partner if it exists.
+
+        If a `preferred_acquirer_id` is specified, only the corresponding acquirer is returned *if*
+        it exists and matches the criteria. Otherwise, we fallback on the default behavior that is
+        returning only the acquirers that do match the criteria.
+
+        :param int company_id: The company to which acquirers must belong, as a `res.company` id
+        :param int partner_id: The partner making the payment, as a `res.partner` id
+        :param int currency_id: The payment currency if known beforehand, as a `res.currency` id
+        :param bool force_tokenization: Whether only acquirers allowing tokenization can be matched
+        :param int preferred_acquirer_id: The preferred acquirer, as a `payment.acquirer` id
+        :param dict kwargs: Optional data. This parameter is not used here
+        :return: The compatible acquirers
+        :rtype: recordset of `payment.acquirer`
+        """
+        # Compute the base domain for compatible acquirers
+        domain = ['&', ('state', 'in', ['enabled', 'test']), ('company_id', '=', company_id)]
+
+        # Handle partner country
+        partner = self.env['res.partner'].browse(partner_id)
+        if partner.country_id:  # The partner country must either not be set or be supported
+            domain = expression.AND([
+                domain,
+                ['|', ('country_ids', '=', False), ('country_ids', 'in', [partner.country_id.id])]
+            ])
+
+        # Handle tokenization support requirements
+        if force_tokenization or self._is_tokenization_required(**kwargs):
+            domain = expression.AND([domain, [('allow_tokenization', '=', True)]])
+
+        # Handle preferred acquirer
+        compatible_acquirers = self.env['payment.acquirer']
+        if preferred_acquirer_id:  # If an acquirer is preferred, check that it matches the criteria
+            compatible_acquirers = self.env['payment.acquirer'].search(expression.AND([
+                domain, [('id', '=', preferred_acquirer_id)]
+            ]))
+        if not compatible_acquirers:  # If not found or incompatible, fallback on the others
+            compatible_acquirers = self.env['payment.acquirer'].search(domain)
+
+        return compatible_acquirers
 
     @api.model
-    def _get_default_partner_country_id(self):
-        return self.env.company.country_id.id
-
-    date = fields.Datetime('Validation Date', readonly=True)
-    acquirer_id = fields.Many2one('payment.acquirer', string='Acquirer', readonly=True, required=True)
-    provider = fields.Selection(string='Provider', related='acquirer_id.provider', readonly=True)
-    type = fields.Selection([
-        ('validation', 'Validation of the bank card'),
-        ('server2server', 'Server To Server'),
-        ('form', 'Form'),
-        ('form_save', 'Form with tokenization')], 'Type',
-        default='form', required=True, readonly=True)
-    state = fields.Selection([
-        ('draft', 'Draft'),
-        ('pending', 'Pending'),
-        ('authorized', 'Authorized'),
-        ('done', 'Done'),
-        ('cancel', 'Canceled'),
-        ('error', 'Error'),],
-        string='Status', copy=False, default='draft', required=True, readonly=True)
-    state_message = fields.Text(string='Message', readonly=True,
-                                help='Field used to store error and/or validation messages for information')
-    amount = fields.Monetary(string='Amount', currency_field='currency_id', required=True, readonly=True)
-    fees = fields.Monetary(string='Fees', currency_field='currency_id', readonly=True,
-                           help='Fees amount; set by the system because depends on the acquirer')
-    currency_id = fields.Many2one('res.currency', 'Currency', required=True, readonly=True)
-    reference = fields.Char(string='Reference', required=True, readonly=True, index=True,
-                            help='Internal reference of the TX')
-    acquirer_reference = fields.Char(string='Acquirer Reference', readonly=True, help='Reference of the TX as stored in the acquirer database')
-    # duplicate partner / transaction data to store the values at transaction time
-    partner_id = fields.Many2one('res.partner', 'Customer')
-    partner_name = fields.Char('Partner Name')
-    partner_lang = fields.Selection(_lang_get, 'Language', default=lambda self: self.env.lang)
-    partner_email = fields.Char('Email')
-    partner_zip = fields.Char('Zip')
-    partner_address = fields.Char('Address')
-    partner_city = fields.Char('City')
-    partner_country_id = fields.Many2one('res.country', 'Country', default=_get_default_partner_country_id, required=True)
-    partner_phone = fields.Char('Phone')
-    html_3ds = fields.Char('3D Secure HTML')
-
-    callback_model_id = fields.Many2one('ir.model', 'Callback Document Model', groups="base.group_system")
-    callback_res_id = fields.Integer('Callback Document ID', groups="base.group_system")
-    callback_method = fields.Char('Callback Method', groups="base.group_system")
-    callback_hash = fields.Char('Callback Hash', groups="base.group_system")
-
-    # Fields used for user redirection & payment post processing
-    return_url = fields.Char('Return URL after payment')
-    is_processed = fields.Boolean('Has the payment been post processed', default=False)
-
-    # Fields used for payment.transaction traceability.
-
-    payment_token_id = fields.Many2one('payment.token', 'Payment Token', readonly=True,
-                                       domain="[('acquirer_id', '=', acquirer_id)]")
-
-    payment_id = fields.Many2one('account.payment', string='Payment', readonly=True)
-    invoice_ids = fields.Many2many('account.move', 'account_invoice_transaction_rel', 'transaction_id', 'invoice_id',
-        string='Invoices', copy=False, readonly=True,
-        domain=[('move_type', 'in', ('out_invoice', 'out_refund', 'in_invoice', 'in_refund'))])
-    invoice_ids_nbr = fields.Integer(compute='_compute_invoice_ids_nbr', string='# of Invoices')
-
-    _sql_constraints = [
-        ('reference_uniq', 'unique(reference)', 'Reference must be unique!'),
-    ]
-
-    @api.depends('invoice_ids')
-    def _compute_invoice_ids_nbr(self):
-        for trans in self:
-            trans.invoice_ids_nbr = len(trans.invoice_ids)
-
-    def _create_payment(self, add_payment_vals={}):
-        ''' Create an account.payment record for the current payment.transaction.
-        If the transaction is linked to some invoices, the reconciliation will be done automatically.
-        :param add_payment_vals:    Optional additional values to be passed to the account.payment.create method.
-        :return:                    An account.payment record.
-        '''
-        self.ensure_one()
-
-        payment_vals = {
-            'amount': self.amount,
-            'payment_type': 'inbound' if self.amount > 0 else 'outbound',
-            'currency_id': self.currency_id.id,
-            'partner_id': self.partner_id.commercial_partner_id.id,
-            'partner_type': 'customer',
-            'journal_id': self.acquirer_id.journal_id.id,
-            'company_id': self.acquirer_id.company_id.id,
-            'payment_method_id': self.env.ref('payment.account_payment_method_electronic_in').id,
-            'payment_token_id': self.payment_token_id and self.payment_token_id.id or None,
-            'payment_transaction_id': self.id,
-            'ref': self.reference,
-            **add_payment_vals,
-        }
-        payment = self.env['account.payment'].create(payment_vals)
-        payment.action_post()
-
-        # Track the payment to make a one2one.
-        self.payment_id = payment
+    def _is_tokenization_required(self, provider=None, **kwargs):
+        """ Return whether tokenizing the transaction is required given its context.
 
-        if self.invoice_ids:
-            self.invoice_ids.filtered(lambda move: move.state == 'draft')._post()
+        For a module to make the tokenization required based on the transaction context, it must
+        override this method and return whether it is required.
 
-            (payment.line_ids + self.invoice_ids.line_ids)\
-                .filtered(lambda line: line.account_id == payment.destination_account_id and not line.reconciled)\
-                .reconcile()
-
-        return payment
+        :param str provider: The provider of the acquirer handling the transaction
+        :param dict kwargs: The transaction context. This parameter is not used here
+        :return: Whether tokenizing the transaction is required
+        :rtype: bool
+        """
+        return False
 
-    def get_last_transaction(self):
-        transactions = self.filtered(lambda t: t.state != 'draft')
-        return transactions and transactions[0] or transactions
+    def _should_build_inline_form(self, is_validation=False):
+        """ Return whether the inline form should be instantiated if it exists.
 
-    def _get_processing_info(self):
-        """ Extensible method for providers if they need specific fields/info regarding a tx in the payment processing page. """
-        return dict()
+        For an acquirer to handle both direct payments and payment with redirection, it should
+        override this method and return whether the inline form should be instantiated (i.e. if the
+        payment should be direct) based on the operation (online payment or validation).
 
-    def _get_payment_transaction_sent_message(self):
-        self.ensure_one()
-        if self.payment_token_id:
-            message = _('A transaction %s with %s initiated using %s credit card.')
-            message_vals = (self.reference, self.acquirer_id.name, self.payment_token_id.name)
-        elif self.provider in ('manual', 'transfer'):
-            message = _('The customer has selected %s to pay this document.')
-            message_vals = (self.acquirer_id.name)
-        else:
-            message = _('A transaction %s with %s initiated.')
-            message_vals = (self.reference, self.acquirer_id.name)
-        if self.provider not in ('manual', 'transfer'):
-            message += ' ' + _('Waiting for payment confirmation...')
-        return message % message_vals
-
-    def _get_payment_transaction_received_message(self):
-        self.ensure_one()
-        amount = formatLang(self.env, self.amount, currency_obj=self.currency_id)
-        message_vals = [self.reference, self.acquirer_id.name, amount]
-        if self.state == 'pending':
-            message = _('The transaction %s with %s for %s is pending.')
-        elif self.state == 'authorized':
-            message = _('The transaction %s with %s for %s has been authorized. Waiting for capture...')
-        elif self.state == 'done':
-            message = _('The transaction %s with %s for %s has been confirmed. The related payment is posted: %s')
-            message_vals.append(self.payment_id._get_payment_chatter_link())
-        elif self.state == 'cancel' and self.state_message:
-            message = _('The transaction %s with %s for %s has been cancelled with the following message: %s')
-            message_vals.append(self.state_message)
-        elif self.state == 'error' and self.state_message:
-            message = _('The transaction %s with %s for %s has return failed with the following error message: %s')
-            message_vals.append(self.state_message)
-        else:
-            message = _('The transaction %s with %s for %s has been cancelled.')
-        return message % tuple(message_vals)
-
-    def _log_payment_transaction_sent(self):
-        '''Log the message saying the transaction has been sent to the remote server to be
-        processed by the acquirer.
-        '''
-        for trans in self:
-            post_message = trans._get_payment_transaction_sent_message()
-            for inv in trans.invoice_ids:
-                inv.message_post(body=post_message)
-
-    def _log_payment_transaction_received(self):
-        '''Log the message saying a response has been received from the remote server and some
-        additional informations like the old/new state, the reference of the payment... etc.
-        :param old_state:       The state of the transaction before the response.
-        :param add_messages:    Optional additional messages to log like the capture status.
-        '''
-        for trans in self.filtered(lambda t: t.provider not in ('manual', 'transfer')):
-            post_message = trans._get_payment_transaction_received_message()
-            for inv in trans.invoice_ids:
-                inv.message_post(body=post_message)
-
-    def _filter_transaction_state(self, allowed_states, target_state):
-        """Divide a set of transactions according to their state.
-
-        :param tuple(string) allowed_states: tuple of allowed states for the target state (strings)
-        :param string target_state: target state for the filtering
-        :return: tuple of transactions divided by their state, in that order
-                    tx_to_process: tx that were in the allowed states
-                    tx_already_processed: tx that were already in the target state
-                    tx_wrong_state: tx that were not in the allowed state for the transition
-        :rtype: tuple(recordset)
+        :param bool is_validation: Whether the operation is a validation
+        :return: Whether the inline form should be instantiated
+        :rtype: bool
         """
-        tx_to_process = self.filtered(lambda tx: tx.state in allowed_states)
-        tx_already_processed = self.filtered(lambda tx: tx.state == target_state)
-        tx_wrong_state = self -tx_to_process - tx_already_processed
-        return (tx_to_process, tx_already_processed, tx_wrong_state)
-
-    def _set_transaction_pending(self):
-        '''Move the transaction to the pending state(e.g. Wire Transfer).'''
-        allowed_states = ('draft',)
-        target_state = 'pending'
-        (tx_to_process, tx_already_processed, tx_wrong_state) = self._filter_transaction_state(allowed_states, target_state)
-        for tx in tx_already_processed:
-            _logger.info('Trying to write the same state twice on tx (ref: %s, state: %s' % (tx.reference, tx.state))
-        for tx in tx_wrong_state:
-            _logger.warning('Processed tx with abnormal state (ref: %s, target state: %s, previous state %s, expected previous states: %s)' % (tx.reference, target_state, tx.state, allowed_states))
-
-        tx_to_process.write({
-            'state': target_state,
-            'date': fields.Datetime.now(),
-            'state_message': '',
-        })
-        tx_to_process._log_payment_transaction_received()
-
-    def _set_transaction_authorized(self):
-        '''Move the transaction to the authorized state(e.g. Authorize).'''
-        allowed_states = ('draft', 'pending')
-        target_state = 'authorized'
-        (tx_to_process, tx_already_processed, tx_wrong_state) = self._filter_transaction_state(allowed_states, target_state)
-        for tx in tx_already_processed:
-            _logger.info('Trying to write the same state twice on tx (ref: %s, state: %s' % (tx.reference, tx.state))
-        for tx in tx_wrong_state:
-            _logger.warning('Processed tx with abnormal state (ref: %s, target state: %s, previous state %s, expected previous states: %s)' % (tx.reference, target_state, tx.state, allowed_states))
-        tx_to_process.write({
-            'state': target_state,
-            'date': fields.Datetime.now(),
-            'state_message': '',
-        })
-        tx_to_process._log_payment_transaction_received()
-
-    def _set_transaction_done(self):
-        '''Move the transaction's payment to the done state(e.g. Paypal).'''
-        allowed_states = ('draft', 'authorized', 'pending', 'error')
-        target_state = 'done'
-        (tx_to_process, tx_already_processed, tx_wrong_state) = self._filter_transaction_state(allowed_states, target_state)
-        for tx in tx_already_processed:
-            _logger.info('Trying to write the same state twice on tx (ref: %s, state: %s' % (tx.reference, tx.state))
-        for tx in tx_wrong_state:
-            _logger.warning('Processed tx with abnormal state (ref: %s, target state: %s, previous state %s, expected previous states: %s)' % (tx.reference, target_state, tx.state, allowed_states))
-
-        tx_to_process.write({
-            'state': target_state,
-            'date': fields.Datetime.now(),
-            'state_message': '',
-        })
-
-    def _reconcile_after_transaction_done(self):
-        # Validate invoices automatically upon the transaction is posted.
-        invoices = self.mapped('invoice_ids').filtered(lambda inv: inv.state == 'draft')
-        invoices._post()
-
-        # Create & Post the payments.
-        for trans in self:
-            if trans.payment_id:
-                continue
-
-            trans._create_payment()
-
-    def _set_transaction_cancel(self):
-        '''Move the transaction's payment to the cancel state(e.g. Paypal).'''
-        allowed_states = ('draft', 'authorized')
-        target_state = 'cancel'
-        (tx_to_process, tx_already_processed, tx_wrong_state) = self._filter_transaction_state(allowed_states, target_state)
-        for tx in tx_already_processed:
-            _logger.info('Trying to write the same state twice on tx (ref: %s, state: %s' % (tx.reference, tx.state))
-        for tx in tx_wrong_state:
-            _logger.warning('Processed tx with abnormal state (ref: %s, target state: %s, previous state %s, expected previous states: %s)' % (tx.reference, target_state, tx.state, allowed_states))
-
-        # Cancel the existing payments.
-        tx_to_process.mapped('payment_id').action_cancel()
-
-        tx_to_process.write({'state': target_state, 'date': fields.Datetime.now()})
-        tx_to_process._log_payment_transaction_received()
-
-    def _set_transaction_error(self, msg):
-        '''Move the transaction to the error state (Third party returning error e.g. Paypal).'''
-        allowed_states = ('draft', 'authorized', 'pending')
-        target_state = 'error'
-        (tx_to_process, tx_already_processed, tx_wrong_state) = self._filter_transaction_state(allowed_states, target_state)
-        for tx in tx_already_processed:
-            _logger.info('Trying to write the same state twice on tx (ref: %s, state: %s' % (tx.reference, tx.state))
-        for tx in tx_wrong_state:
-            _logger.warning('Processed tx with abnormal state (ref: %s, target state: %s, previous state %s, expected previous states: %s)' % (tx.reference, target_state, tx.state, allowed_states))
-
-        tx_to_process.write({
-            'state': target_state,
-            'date': fields.Datetime.now(),
-            'state_message': msg,
-        })
-        self._log_payment_transaction_received()
-
-    def _post_process_after_done(self):
-        self._reconcile_after_transaction_done()
-        self._log_payment_transaction_received()
-        self.write({'is_processed': True})
         return True
 
-    def _cron_post_process_after_done(self):
-        if not self:
-            ten_minutes_ago = datetime.now() - relativedelta.relativedelta(minutes=10)
-            # we don't want to forever try to process a transaction that doesn't go through
-            retry_limit_date = datetime.now() - relativedelta.relativedelta(days=2)
-            # we retrieve all the payment tx that need to be post processed
-            self = self.search([('state', '=', 'done'),
-                                ('is_processed', '=', False),
-                                ('date', '<=', ten_minutes_ago),
-                                ('date', '>=', retry_limit_date),
-                            ])
-        for tx in self:
-            try:
-                tx._post_process_after_done()
-                self.env.cr.commit()
-            except Exception as e:
-                _logger.exception("Transaction post processing failed. Reason: %s", str(e))
-                self.env.cr.rollback()
+    def _get_base_url(self):
+        """ Get the base url of the website on which the payment is made.
 
-    @api.model
-    def _compute_reference_prefix(self, values):
-        if values and values.get('invoice_ids'):
-            invoices = self.new({'invoice_ids': values['invoice_ids']}).invoice_ids
-            return ','.join(invoices.mapped('name'))
-        return None
-
-    @api.model
-    def _compute_reference(self, values=None, prefix=None):
-        '''Compute a unique reference for the transaction.
-        If prefix:
-            prefix-\d+
-        If some invoices:
-            <inv_number_0>.number,<inv_number_1>,...,<inv_number_n>-x
-        If some sale orders:
-            <so_name_0>.number,<so_name_1>,...,<so_name_n>-x
-        Else:
-            tx-\d+
-        :param values: values used to create a new transaction.
-        :param prefix: custom transaction prefix.
-        :return: A unique reference for the transaction.
-        '''
-        if not prefix:
-            prefix = self._compute_reference_prefix(values)
-            if not prefix:
-                prefix = 'tx'
-
-        # Fetch the last reference
-        # E.g. If the last reference is SO42-5, this query will return '-5'
-        self._cr.execute('''
-                SELECT CAST(SUBSTRING(reference FROM '-\d+$') AS INTEGER) AS suffix
-                FROM payment_transaction WHERE reference LIKE %s ORDER BY suffix
-            ''', [prefix + '-%'])
-        query_res = self._cr.fetchone()
-        if query_res:
-            # Increment the last reference by one
-            suffix = '%s' % (-query_res[0] + 1)
-        else:
-            # Start a new indexing from 1
-            suffix = '1'
-
-        return '%s-%s' % (prefix, suffix)
-
-    def action_view_invoices(self):
-        action = {
-            'name': _('Invoices'),
-            'type': 'ir.actions.act_window',
-            'res_model': 'account.move',
-            'target': 'current',
-        }
-        invoice_ids = self.invoice_ids.ids
-        if len(invoice_ids) == 1:
-            invoice = invoice_ids[0]
-            action['res_id'] = invoice
-            action['view_mode'] = 'form'
-            form_view = [(self.env.ref('account.view_move_form').id, 'form')]
-            if 'views' in action:
-                action['views'] = form_view + [(state,view) for state,view in action['views'] if view != 'form']
-            else:
-                action['views'] = form_view
-        else:
-            action['view_mode'] = 'tree,form'
-            action['domain'] = [('id', 'in', invoice_ids)]
-        return action
-
-    @api.constrains('state', 'acquirer_id')
-    def _check_authorize_state(self):
-        failed_tx = self.filtered(lambda tx: tx.state == 'authorized' and tx.acquirer_id.provider not in self.env['payment.acquirer']._get_feature_support()['authorize'])
-        if failed_tx:
-            raise exceptions.ValidationError(_('The %s payment acquirers are not allowed to manual capture mode!', failed_tx.mapped('acquirer_id.name')))
+        Note: self.ensure_one()
 
-    @api.model
-    def create(self, values):
-        # call custom create method if defined
-        acquirer = self.env['payment.acquirer'].browse(values['acquirer_id'])
-        if values.get('partner_id'):
-            partner = self.env['res.partner'].browse(values['partner_id'])
-
-            values.update({
-                'partner_name': partner.name,
-                'partner_lang': partner.lang or self.env.user.lang,
-                'partner_email': partner.email,
-                'partner_zip': partner.zip,
-                'partner_address': _partner_format_address(partner.street or '', partner.street2 or ''),
-                'partner_city': partner.city,
-                'partner_country_id': partner.country_id.id or self._get_default_partner_country_id(),
-                'partner_phone': partner.phone,
-            })
-
-        # compute fees
-        custom_method_name = '%s_compute_fees' % acquirer.provider
-        if hasattr(acquirer, custom_method_name):
-            fees = getattr(acquirer, custom_method_name)(
-                values.get('amount', 0.0), values.get('currency_id'), values.get('partner_country_id', self._get_default_partner_country_id()))
-            values['fees'] = fees
-
-        # custom create
-        custom_method_name = '%s_create' % acquirer.provider
-        if hasattr(self, custom_method_name):
-            values.update(getattr(self, custom_method_name)(values))
-
-        if not values.get('reference'):
-            values['reference'] = self._compute_reference(values=values)
-
-        # Default value of reference is
-        tx = super(PaymentTransaction, self).create(values)
-
-        # Generate callback hash if it is configured on the tx; avoid generating unnecessary stuff
-        # (limited sudo env for checking callback presence, must work for manual transactions too)
-        tx_sudo = tx.sudo()
-        if tx_sudo.callback_model_id and tx_sudo.callback_res_id and tx_sudo.callback_method:
-            tx.write({'callback_hash': tx._generate_callback_hash()})
-
-        return tx
-
-    def _generate_callback_hash(self):
+        :return: The website base url
+        :rtype: str
+        """
         self.ensure_one()
-        secret = self.env['ir.config_parameter'].sudo().get_param('database.secret')
-        token = '%s%s%s' % (self.callback_model_id.model,
-                            self.callback_res_id,
-                            self.sudo().callback_method)
-        return hmac.new(secret.encode('utf-8'), token.encode('utf-8'), hashlib.sha256).hexdigest()
+        return self.env['ir.config_parameter'].sudo().get_param('web.base.url')
 
-    # --------------------------------------------------
-    # FORM RELATED METHODS
-    # --------------------------------------------------
+    def _compute_fees(self, amount, currency, country):
+        """ Compute the transaction fees.
 
-    @api.model
-    def form_feedback(self, data, acquirer_name):
-        invalid_parameters, tx = None, None
-
-        tx_find_method_name = '_%s_form_get_tx_from_data' % acquirer_name
-        if hasattr(self, tx_find_method_name):
-            tx = getattr(self, tx_find_method_name)(data)
-
-        # TDE TODO: form_get_invalid_parameters from model to multi
-        invalid_param_method_name = '_%s_form_get_invalid_parameters' % acquirer_name
-        if hasattr(self, invalid_param_method_name):
-            invalid_parameters = getattr(tx, invalid_param_method_name)(data)
-
-        if invalid_parameters:
-            _error_message = '%s: incorrect tx data:\n' % (acquirer_name)
-            for item in invalid_parameters:
-                _error_message += '\t%s: received %s instead of %s\n' % (item[0], item[1], item[2])
-            _logger.error(_error_message)
-            return False
-
-        # TDE TODO: form_validate from model to multi
-        feedback_method_name = '_%s_form_validate' % acquirer_name
-        if hasattr(self, feedback_method_name):
-            return getattr(tx, feedback_method_name)(data)
+        The computation is based on the generic fields `fees_dom_fixed`, `fees_dom_var`,
+        `fees_int_fixed` and `fees_int_var` and is done according to the following formula:
 
-        return True
+        `fees = (amount * variable / 100.0 + fixed) / (1 - variable / 100.0)` where the value
+        of `fixed` and `variable` is taken either from the domestic (dom) or international (int)
+        field depending on whether the country matches the company's country.
 
-    # --------------------------------------------------
-    # SERVER2SERVER RELATED METHODS
-    # --------------------------------------------------
-
-    def s2s_do_transaction(self, **kwargs):
-        custom_method_name = '%s_s2s_do_transaction' % self.acquirer_id.provider
-        for trans in self:
-            trans._log_payment_transaction_sent()
-            if hasattr(trans, custom_method_name):
-                return getattr(trans, custom_method_name)(**kwargs)
-
-    def s2s_do_refund(self, **kwargs):
-        custom_method_name = '%s_s2s_do_refund' % self.acquirer_id.provider
-        if hasattr(self, custom_method_name):
-            return getattr(self, custom_method_name)(**kwargs)
-
-    def s2s_capture_transaction(self, **kwargs):
-        custom_method_name = '%s_s2s_capture_transaction' % self.acquirer_id.provider
-        if hasattr(self, custom_method_name):
-            return getattr(self, custom_method_name)(**kwargs)
-
-    def s2s_void_transaction(self, **kwargs):
-        custom_method_name = '%s_s2s_void_transaction' % self.acquirer_id.provider
-        if hasattr(self, custom_method_name):
-            return getattr(self, custom_method_name)(**kwargs)
-
-    def s2s_get_tx_status(self):
-        """ Get the tx status. """
-        invalid_param_method_name = '_%s_s2s_get_tx_status' % self.acquirer_id.provider
-        if hasattr(self, invalid_param_method_name):
-            return getattr(self, invalid_param_method_name)()
-        return True
+        For an acquirer to base the computation on different variables, or to use a different
+        formula, it must override this method and return the resulting fees as a float.
+
+        :param float amount: The amount to pay for the transaction
+        :param recordset currency: The currency of the transaction, as a `res.currency` record
+        :param recordset country: The customer country, as a `res.country` record
+        :return: The computed fees
+        :rtype: float
+        """
+        self.ensure_one()
 
-    def execute_callback(self):
-        res = None
-        for transaction in self:
-            # limited sudo env, only for checking callback presence, not for running it!
-            # manual transactions have no callback, and can pass without being run by admin user
-            tx_sudo = transaction.sudo()
-            if not (tx_sudo.callback_model_id and tx_sudo.callback_res_id and tx_sudo.callback_method):
-                continue
-
-            valid_token = transaction._generate_callback_hash()
-            if not consteq(ustr(valid_token), transaction.callback_hash):
-                _logger.warning("Invalid callback signature for transaction %d" % (transaction.id))
-                continue
-
-            record = self.env[transaction.callback_model_id.model].browse(transaction.callback_res_id).exists()
-            if record:
-                res = getattr(record, transaction.callback_method)(transaction)
+        fees = 0.0
+        if self.fees_active:
+            if country == self.company_id.country_id:
+                fixed = self.fees_dom_fixed
+                variable = self.fees_dom_var
             else:
-                _logger.warning("Did not found record %s.%s for callback of transaction %d" % (transaction.callback_model_id.model, transaction.callback_res_id, transaction.id))
-        return res
-
-    def action_capture(self):
-        if any(t.state != 'authorized' for t in self):
-            raise ValidationError(_('Only transactions having the authorized status can be captured.'))
-        for tx in self:
-            tx.s2s_capture_transaction()
-
-    def action_void(self):
-        if any(t.state != 'authorized' for t in self):
-            raise ValidationError(_('Only transactions having the capture status can be voided.'))
-        for tx in self:
-            tx.s2s_void_transaction()
-
-
-class PaymentToken(models.Model):
-    _name = 'payment.token'
-    _order = 'partner_id, id desc'
-    _description = 'Payment Token'
-
-    name = fields.Char('Name', help='Name of the payment token')
-    short_name = fields.Char('Short name', compute='_compute_short_name')
-    partner_id = fields.Many2one('res.partner', 'Partner', required=True)
-    acquirer_id = fields.Many2one('payment.acquirer', 'Acquirer Account', required=True)
-    company_id = fields.Many2one(related='acquirer_id.company_id', store=True, index=True)
-    acquirer_ref = fields.Char('Acquirer Ref.', required=True)
-    active = fields.Boolean('Active', default=True)
-    payment_ids = fields.One2many('payment.transaction', 'payment_token_id', 'Payment Transactions')
-    verified = fields.Boolean(string='Verified', default=False)
+                fixed = self.fees_int_fixed
+                variable = self.fees_int_var
+            fees = (amount * variable / 100.0 + fixed) / (1 - variable / 100.0)
+        return fees
 
-    @api.model
-    def create(self, values):
-        # call custom create method if defined
-        if values.get('acquirer_id'):
-            acquirer = self.env['payment.acquirer'].browse(values['acquirer_id'])
-
-            # custom create
-            custom_method_name = '%s_create' % acquirer.provider
-            if hasattr(self, custom_method_name):
-                values.update(getattr(self, custom_method_name)(values))
-                # remove all non-model fields used by (provider)_create method to avoid warning
-                fields_wl = set(self._fields) & set(values)
-                values = {field: values[field] for field in fields_wl}
-        return super(PaymentToken, self).create(values)
-    """
-        @TBE: stolen shamelessly from there https://www.paypal.com/us/selfhelp/article/why-is-there-a-$1.95-charge-on-my-card-statement-faq554
-        Most of them are ~1.50s
-    """
-    VALIDATION_AMOUNTS = {
-        'CAD': 2.45,
-        'EUR': 1.50,
-        'GBP': 1.00,
-        'JPY': 200,
-        'AUD': 2.00,
-        'NZD': 3.00,
-        'CHF': 3.00,
-        'HKD': 15.00,
-        'SEK': 15.00,
-        'DKK': 12.50,
-        'PLN': 6.50,
-        'NOK': 15.00,
-        'HUF': 400.00,
-        'CZK': 50.00,
-        'BRL': 4.00,
-        'MYR': 10.00,
-        'MXN': 20.00,
-        'ILS': 8.00,
-        'PHP': 100.00,
-        'TWD': 70.00,
-        'THB': 70.00
-        }
+    def _get_validation_amount(self):
+        """ Get the amount to transfer in a payment method validation operation.
 
-    @api.model
-    def validate(self, **kwargs):
-        """
-            This method allow to verify if this payment method is valid or not.
-            It does this by withdrawing a certain amount and then refund it right after.
-        """
-        currency = self.partner_id.currency_id
-
-        if self.VALIDATION_AMOUNTS.get(currency.name):
-            amount = self.VALIDATION_AMOUNTS.get(currency.name)
-        else:
-            # If we don't find the user's currency, then we set the currency to EUR and the amount to 150.
-            currency = self.env['res.currency'].search([('name', '=', 'EUR')])
-            amount = 1.5
-
-        if len(currency) != 1:
-            _logger.error("Error 'EUR' currency not found for payment method validation!")
-            return False
-
-        reference = "VALIDATION-%s-%s" % (self.id, datetime.now().strftime('%y%m%d_%H%M%S'))
-        tx = self.env['payment.transaction'].sudo().create({
-            'amount': amount,
-            'acquirer_id': self.acquirer_id.id,
-            'type': 'validation',
-            'currency_id': currency.id,
-            'reference': reference,
-            'payment_token_id': self.id,
-            'partner_id': self.partner_id.id,
-            'partner_country_id': self.partner_id.country_id.id,
-            'state_message': _('This Transaction was automatically processed & refunded in order to validate a new credit card.'),
-        })
+        For an acquirer to support tokenization, it must override this method and return the amount
+        to be transferred in a payment method validation operation *if the validation amount is not
+        null*.
 
-        kwargs.update({'3d_secure': True})
-        tx.s2s_do_transaction(**kwargs)
+        Note: self.ensure_one()
 
-        # if 3D secure is called, then we do not refund right now
-        if not tx.html_3ds:
-            tx.s2s_do_refund()
+        :return: The validation amount
+        :rtype: float
+        """
+        self.ensure_one()
+        return 0.0
 
-        return tx
+    def _get_validation_currency(self):
+        """ Get the currency of the transfer in a payment method validation operation.
 
-    @api.depends('name')
-    def _compute_short_name(self):
-        for token in self:
-            token.short_name = token.name.replace('XXXXXXXXXXXX', '***')
+        For an acquirer to support tokenization, it must override this method and return the
+        currency to be used in a payment method validation operation *if the validation amount is
+        not null*.
 
-    def get_linked_records(self):
-        """ This method returns a dict containing all the records linked to the payment.token (e.g Subscriptions),
-            the key is the id of the payment.token and the value is an array that must follow the scheme below.
+        Note: self.ensure_one()
 
-            {
-                token_id: [
-                    'description': The model description (e.g 'Sale Subscription'),
-                    'id': The id of the record,
-                    'name': The name of the record,
-                    'url': The url to access to this record.
-                ]
-            }
+        :return: The validation currency
+        :rtype: recordset of `res.currency`
         """
-        return {r.id:[] for r in self}
+        self.ensure_one()
+        return self.journal_id.currency_id or self.company_id.currency_id

--- a/None
+++ b/addons/payment/models/payment_icon.py
@@ -0,0 +1,19 @@
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from odoo import fields, models
+
+
+class PaymentIcon(models.Model):
+    _name = 'payment.icon'
+    _description = 'Payment Icon'
+
+    name = fields.Char(string="Name")
+    acquirer_ids = fields.Many2many(
+        string="Acquirers", comodel_name='payment.acquirer',
+        help="The list of acquirers supporting this payment icon")
+    image = fields.Image(
+        string="Image", max_width=64, max_height=64,
+        help="This field holds the image used for this payment icon, limited to 64x64 px")
+    image_payment_form = fields.Image(
+        string="Image displayed on the payment form", related='image', store=True, max_width=45,
+        max_height=30)

--- a/None
+++ b/addons/payment/models/payment_token.py
@@ -0,0 +1,130 @@
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+import logging
+
+from odoo import api, fields, models
+
+_logger = logging.getLogger(__name__)
+
+
+class PaymentToken(models.Model):
+    _name = 'payment.token'
+    _order = 'partner_id, id desc'
+    _description = 'Payment Token'
+
+    acquirer_id = fields.Many2one(
+        string="Acquirer Account", comodel_name='payment.acquirer', required=True)
+    provider = fields.Selection(related='acquirer_id.provider')
+    name = fields.Char(
+        string="Name", help="The anonymized acquirer reference of the payment method",
+        required=True)
+    partner_id = fields.Many2one(string="Partner", comodel_name='res.partner', required=True)
+    company_id = fields.Many2one(  # Indexed to speed-up ORM searches (from ir_rule or others)
+        related='acquirer_id.company_id', store=True, index=True)
+    acquirer_ref = fields.Char(
+        string="Acquirer Reference", help="The acquirer reference of the token of the transaction",
+        required=True)  # This is not the same thing as the acquirer reference of the transaction
+    transaction_ids = fields.One2many(
+        string="Payment Transactions", comodel_name='payment.transaction', inverse_name='token_id')
+    verified = fields.Boolean(string="Verified")
+    active = fields.Boolean(string="Active", default=True)
+
+    #=== CRUD METHODS ===#
+
+    @api.model_create_multi
+    def create(self, values_list):
+        for values in values_list:
+            if 'acquirer_id' in values:
+                acquirer = self.env['payment.acquirer'].browse(values['acquirer_id'])
+
+                # Include acquirer-specific create values
+                values.update(self._get_specific_create_values(acquirer.provider, values))
+            else:
+                pass  # Let psycopg warn about the missing required field
+
+        return super().create(values_list)
+
+    @api.model
+    def _get_specific_create_values(self, provider, values):
+        """ Complete the values of the `create` method with acquirer-specific values.
+
+        For an acquirer to add its own create values, it must overwrite this method and return a
+        dict of values. Acquirer-specific values take precedence over those of the dict of generic
+        create values.
+
+        :param str provider: The provider of the acquirer managing the token
+        :param dict values: The original create values
+        :return: The dict of acquirer-specific create values
+        :rtype: dict
+        """
+        return dict()
+
+    def write(self, values):
+        """ Delegate the handling of active state switch to dedicated methods.
+
+        Unless an exception is raised in the handling methods, the toggling proceeds no matter what.
+        This is because allowing users to hide their saved payment methods comes before making sure
+        that the recorded payment details effectively get deleted.
+
+        :return: The result of the write
+        :rtype: bool
+        """
+        # Let acquirers handle activation/deactivation requests
+        if 'active' in values:
+            for token in self:
+                # Call handlers in sudo mode because this method might have been called by RPC
+                if values['active'] and not token.active:
+                    token.sudo()._handle_reactivation_request()
+                elif not values['active'] and token.active:
+                    token.sudo()._handle_deactivation_request()
+
+        # Proceed with the toggling of the active state
+        return super().write(values)
+
+    #=== BUSINESS METHODS ===#
+
+    def _handle_deactivation_request(self):
+        """ Handle the request for deactivation of the token.
+
+        For an acquirer to support deactivation of tokens, or perform additional operations when a
+        token is deactivated, it must overwrite this method and raise an UserError if the token
+        cannot be deactivated.
+
+        Note: self.ensure_one()
+
+        :return: None
+        """
+        self.ensure_one()
+
+    def _handle_reactivation_request(self):
+        """ Handle the request for reactivation of the token.
+
+        For an acquirer to support reactivation of tokens, or perform additional operations when a
+        token is reactivated, it must overwrite this method and raise an UserError if the token
+        cannot be reactivated.
+
+        Note: self.ensure_one()
+
+        :return: None
+        """
+        self.ensure_one()
+
+    def get_linked_records_info(self):
+        """ Return a list of information about records linked to the current token.
+
+        For a module to implement payments and link documents to a token, it must override this
+        method and add information about linked records to the returned list.
+
+        The information must be structured as a dict with the following keys:
+          - description: The description of the record's model (e.g. "Subscription")
+          - id: The id of the record
+          - name: The name of the record
+          - url: The url to access the record.
+
+        Note: self.ensure_one()
+
+        :return: The list of information about linked documents
+        :rtype: list
+        """
+        self.ensure_one()
+        return []

--- a/None
+++ b/addons/payment/models/payment_transaction.py
@@ -0,0 +1,970 @@
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+import logging
+import pprint
+import re
+import unicodedata
+from datetime import datetime
+
+import psycopg2
+from dateutil import relativedelta
+
+from odoo import _, api, fields, models
+from odoo.exceptions import ValidationError
+from odoo.tools import consteq, ustr
+from odoo.tools.misc import formatLang, hmac as hmac_tool
+
+from odoo.addons.payment import utils as payment_utils
+
+_logger = logging.getLogger(__name__)
+
+
+class PaymentTransaction(models.Model):
+    _name = 'payment.transaction'
+    _description = 'Payment Transaction'
+    _order = 'id desc'
+    _rec_name = 'reference'
+
+    @api.model
+    def _lang_get(self):
+        return self.env['res.lang'].get_installed()
+
+    acquirer_id = fields.Many2one(
+        string="Acquirer", comodel_name='payment.acquirer', readonly=True, required=True)
+    provider = fields.Selection(related='acquirer_id.provider')
+    company_id = fields.Many2one(  # Indexed to speed-up ORM searches (from ir_rule or others)
+        related='acquirer_id.company_id', store=True, index=True)
+    reference = fields.Char(
+        string="Reference", help="The internal reference of the transaction", readonly=True,
+        required=True)  # Already has an index from the UNIQUE SQL constraint
+    acquirer_reference = fields.Char(
+        string="Acquirer Reference", help="The acquirer reference of the transaction",
+        readonly=True)  # This is not the same thing as the acquirer reference of the token
+    amount = fields.Monetary(
+        string="Amount", currency_field='currency_id', readonly=True, required=True)
+    currency_id = fields.Many2one(
+        string="Currency", comodel_name='res.currency', readonly=True, required=True)
+    fees = fields.Monetary(
+        string="Fees", currency_field='currency_id',
+        help="The fees amount; set by the system as it depends on the acquirer", readonly=True)
+    token_id = fields.Many2one(
+        string="Payment Token", comodel_name='payment.token', readonly=True,
+        domain='[("acquirer_id", "=", "acquirer_id")]', ondelete='restrict')
+    state = fields.Selection(
+        string="Status",
+        selection=[('draft', "Draft"), ('pending', "Pending"), ('authorized', "Authorized"),
+                   ('done', "Confirmed"), ('cancel', "Canceled"), ('error', "Error")],
+        default='draft', readonly=True, required=True, copy=False)
+    state_message = fields.Text(
+        string="Message", help="The complementary information message about the state",
+        readonly=True)
+    last_state_change = fields.Datetime(
+        string="Last State Change Date", readonly=True, default=fields.Datetime.now)
+
+    # Fields used for traceability
+    operation = fields.Selection(  # This should not be trusted if the state is 'draft' or 'pending'
+        string="Operation",
+        selection=[('online_redirect', "Online payment with redirection"),
+                   ('online_direct', "Online direct payment"),
+                   ('online_token', "Online payment by token"),
+                   ('validation', "Validation of the payment method"),
+                   ('offline', "Offline payment by token")],
+        readonly=True)
+    payment_id = fields.Many2one(string="Payment", comodel_name='account.payment', readonly=True)
+    invoice_ids = fields.Many2many(
+        string="Invoices", comodel_name='account.move', relation='account_invoice_transaction_rel',
+        column1='transaction_id', column2='invoice_id', readonly=True, copy=False,
+        domain=[('move_type', 'in', ('out_invoice', 'out_refund', 'in_invoice', 'in_refund'))])
+    invoices_count = fields.Integer(string="Invoices Count", compute='_compute_invoices_count')
+
+    # Fields used for user redirection & payment post-processing
+    is_post_processed = fields.Boolean(
+        string="Is Post-processed", help="Has the payment been post-processed")
+    tokenize = fields.Boolean(
+        string="Create Token",
+        help="Whether a payment token should be created when post-processing the transaction")
+    validation_route = fields.Char(
+        string="Validation Route",
+        help="The route the user is redirected to in order to refund a validation transaction")
+    landing_route = fields.Char(
+        string="Landing Route",
+        help="The route the user is redirected to after the transaction")
+    callback_model_id = fields.Many2one(
+        string="Callback Document Model", comodel_name='ir.model', groups='base.group_system')
+    callback_res_id = fields.Integer(string="Callback Record ID", groups='base.group_system')
+    callback_method = fields.Char(string="Callback Method", groups='base.group_system')
+    # Hash for additional security on top of the callback fields' group in case a bug exposes a sudo
+    callback_hash = fields.Char(string="Callback Hash", groups='base.group_system')
+    callback_is_done = fields.Boolean(
+        string="Callback Done", help="Whether the callback has already been executed",
+        groups="base.group_system", readonly=True)
+
+    # Duplicated partner values allowing to keep a record of them, should they be later updated
+    partner_id = fields.Many2one(
+        string="Customer", comodel_name='res.partner', readonly=True, required=True,
+        ondelete='restrict')
+    partner_name = fields.Char(string="Partner Name")
+    partner_lang = fields.Selection(string="Language", selection=_lang_get)
+    partner_email = fields.Char(string="Email")
+    partner_address = fields.Char(string="Address")
+    partner_zip = fields.Char(string="Zip")
+    partner_city = fields.Char(string="City")
+    partner_state_id = fields.Many2one(string="State", comodel_name='res.country.state')
+    partner_country_id = fields.Many2one(string="Country", comodel_name='res.country')
+    partner_phone = fields.Char(string="Phone")
+
+    _sql_constraints = [
+        ('reference_uniq', 'unique(reference)', "Reference must be unique!"),
+    ]
+
+    #=== COMPUTE METHODS ===#
+
+    @api.depends('invoice_ids')
+    def _compute_invoices_count(self):
+        self.env.cr.execute(
+            '''
+            SELECT transaction_id, count(invoice_id)
+            FROM account_invoice_transaction_rel
+            WHERE transaction_id IN %s
+            GROUP BY transaction_id
+            ''',
+            [tuple(self.ids)]
+        )
+        tx_data = dict(self.env.cr.fetchall())  # {id: count}
+        for tx in self:
+            tx.invoices_count = tx_data.get(tx.id, 0)
+
+    #=== CONSTRAINT METHODS ===#
+
+    @api.constrains('state')
+    def _check_state_authorized_supported(self):
+        """ Check that authorization is supported for a transaction in the 'authorized' state. """
+        illegal_authorize_state_txs = self.filtered(
+            lambda tx: tx.state == 'authorized' and not tx.acquirer_id.support_authorization
+        )
+        if illegal_authorize_state_txs:
+            raise ValidationError(_(
+                "Transaction authorization is not supported by the following payment acquirers: %s",
+                ', '.join(set(illegal_authorize_state_txs.mapped('acquirer_id.name')))
+            ))
+
+    #=== CRUD METHODS ===#
+
+    @api.model_create_multi
+    def create(self, values_list):
+        for values in values_list:
+            acquirer = self.env['payment.acquirer'].browse(values['acquirer_id'])
+
+            if not values.get('reference'):
+                values['reference'] = self._compute_reference(acquirer.provider, **values)
+
+            # Duplicate partner values
+            partner = self.env['res.partner'].browse(values['partner_id'])
+            values.update({
+                'partner_name': partner.name,
+                'partner_lang': partner.lang,
+                'partner_email': partner.email,
+                'partner_address': payment_utils.format_partner_address(
+                    partner.street, partner.street2
+                ),
+                'partner_zip': partner.zip,
+                'partner_city': partner.city,
+                'partner_state_id': partner.state_id.id,
+                'partner_country_id': partner.country_id.id,
+                'partner_phone': partner.phone,
+            })
+
+            # Compute fees
+            currency = self.env['res.currency'].browse(values.get('currency_id')).exists()
+            values['fees'] = acquirer._compute_fees(
+                values.get('amount', 0), currency, partner.country_id
+            )
+
+            # Include acquirer-specific create values
+            values.update(self._get_specific_create_values(acquirer.provider, values))
+
+            # Generate the hash for the callback if one has be configured on the tx
+            values['callback_hash'] = self._generate_callback_hash(
+                values.get('callback_model_id'),
+                values.get('callback_res_id'),
+                values.get('callback_method'),
+            )
+
+        txs = super().create(values_list)
+
+        # Monetary fields are rounded with the currency at creation time by the ORM. Sometimes, this
+        # can lead to inconsistent string representation of the amounts sent to the providers.
+        # E.g., tx.create(amount=1111.11) -> tx.amount == 1111.1100000000001
+        # To ensure a proper string representation, we invalidate this request's cache values of the
+        # `amount` and `fees` fields for the created transactions. This forces the ORM to read the
+        # values from the DB where there were stored using `float_repr`, which produces a result
+        # consistent with the format expected by providers.
+        # E.g., tx.create(amount=1111.11) ; tx.invalidate_cache() -> tx.amount == 1111.11
+        txs.invalidate_cache(['amount', 'fees'])
+
+        return txs
+
+    @api.model
+    def _get_specific_create_values(self, provider, values):
+        """ Complete the values of the `create` method with acquirer-specific values.
+
+        For an acquirer to add its own create values, it must overwrite this method and return a
+        dict of values. Acquirer-specific values take precedence over those of the dict of generic
+        create values.
+
+        :param str provider: The provider of the acquirer that handled the transaction
+        :param dict values: The original create values
+        :return: The dict of acquirer-specific create values
+        :rtype: dict
+        """
+        return dict()
+
+    #=== ACTION METHODS ===#
+
+    def action_view_invoices(self):
+        """ Return the action for the views of the invoices linked to the transaction.
+
+        Note: self.ensure_one()
+
+        :return: The action
+        :rtype: dict
+        """
+        self.ensure_one()
+
+        action = {
+            'name': _("Invoices"),
+            'type': 'ir.actions.act_window',
+            'res_model': 'account.move',
+            'target': 'current',
+        }
+        invoice_ids = self.invoice_ids.ids
+        if len(invoice_ids) == 1:
+            invoice = invoice_ids[0]
+            action['res_id'] = invoice
+            action['view_mode'] = 'form'
+            action['views'] = [(self.env.ref('account.view_move_form').id, 'form')]
+        else:
+            action['view_mode'] = 'tree,form'
+            action['domain'] = [('id', 'in', invoice_ids)]
+        return action
+
+    def action_capture(self):
+        """ Check the state of the transactions and request their capture. """
+        if any(tx.state != 'authorized' for tx in self):
+            raise ValidationError(_("Only authorized transactions can be captured."))
+
+        for tx in self:
+            tx._send_capture_request()
+
+    def action_void(self):
+        """ Check the state of the transaction and request to have them voided. """
+        if any(tx.state != 'authorized' for tx in self):
+            raise ValidationError(_("Only authorized transactions can be voided."))
+
+        for tx in self:
+            tx._send_void_request()
+
+    #=== BUSINESS METHODS - PAYMENT FLOW ===#
+
+    @api.model
+    def _compute_reference(self, provider, prefix=None, separator='-', **kwargs):
+        """ Compute a unique reference for the transaction.
+
+        The reference either corresponds to the prefix if no other transaction with that prefix
+        already exists, or follows the pattern `{computed_prefix}{separator}{sequence_number}` where
+          - {computed_prefix} is:
+            - The provided custom prefix, if any.
+            - The computation result of `_compute_reference_prefix` if the custom prefix is not
+              filled but the kwargs are.
+            - 'tx-{datetime}', if neither the custom prefix nor the kwargs are filled.
+          - {separator} is a custom string also used in `_compute_reference_prefix`.
+          - {sequence_number} is the next integer in the sequence of references sharing the exact
+            same prefix, '1' if there is only one matching reference (hence without sequence number)
+
+        Examples:
+          - Given the custom prefix 'example' which has no match with an existing reference, the
+            full reference will be 'example'.
+          - Given the custom prefix 'example' which matches the existing reference 'example', and
+            the custom separator '-', the full reference will be 'example-1'.
+          - Given the kwargs {'invoice_ids': [1, 2]}, the custom separator '-' and no custom prefix,
+            the full reference will be 'INV1-INV2' (or similar) if no existing reference has the
+            same prefix, or 'INV1-INV2-n' if n existing references have the same prefix.
+
+        :param str provider: The provider of the acquirer handling the transaction
+        :param str prefix: The custom prefix used to compute the full reference
+        :param str separator: The custom separator used to separate the prefix from the suffix, and
+                              passed to `_compute_reference_prefix` if it is called
+        :param dict kwargs: Optional values passed to `_compute_reference_prefix` if no custom
+                            prefix is provided
+        :return: The unique reference for the transaction
+        :rtype: str
+        """
+        # Compute the prefix
+        if prefix:
+            # Replace special characters by their ASCII alternative ( -> e ;  -> a ; ...)
+            prefix = unicodedata.normalize('NFKD', prefix).encode('ascii', 'ignore').decode('utf-8')
+        if not prefix:  # Prefix not provided or voided above, compute it based on the kwargs
+            prefix = self.sudo()._compute_reference_prefix(provider, separator, **kwargs)
+        if not prefix:  # Prefix not computed from the kwargs, fallback on time-based value
+            prefix = payment_utils.singularize_reference_prefix()
+
+        # Compute the sequence number
+        reference = prefix  # The first reference of a sequence has no sequence number
+        if self.sudo().search([('reference', '=', prefix)]):  # The reference already has a match
+            # We now execute a second search on `payment.transaction` to fetch all the references
+            # starting with the given prefix. The load of these two searches is mitigated by the
+            # index on `reference`. Although not ideal, this solution allows for quickly knowing
+            # whether the sequence for a given prefix is already started or not, usually not. An SQL
+            # query wouldn't help either as the selector is arbitrary and doing that would be an
+            # open-door to SQL injections.
+            same_prefix_references = self.sudo().search(
+                [('reference', 'like', f'{prefix}{separator}%')]
+            ).with_context(prefetch_fields=False).mapped('reference')
+
+            # A final regex search is necessary to figure out the next sequence number. The previous
+            # search could not rely on alphabetically sorting the reference to infer the largest
+            # sequence number because both the prefix and the separator are arbitrary. A given
+            # prefix could happen to be a substring of the reference from a different sequence.
+            # For instance, the prefix 'example' is a valid match for the existing references
+            # 'example', 'example-1' and 'example-ref', in that order. Trusting the order to infer
+            # the sequence number would lead to a collision with 'example-1'.
+            search_pattern = re.compile(rf'^{prefix}{separator}(\d+)$')
+            max_sequence_number = 0  # If no match is found, start the sequence with this reference
+            for existing_reference in same_prefix_references:
+                search_result = re.search(search_pattern, existing_reference)
+                if search_result:  # The reference has the same prefix and is from the same sequence
+                    # Find the largest sequence number, if any
+                    current_sequence = int(search_result.group(1))
+                    if current_sequence > max_sequence_number:
+                        max_sequence_number = current_sequence
+
+            # Compute the full reference
+            reference = f'{prefix}{separator}{max_sequence_number + 1}'
+        return reference
+
+    @api.model
+    def _compute_reference_prefix(self, provider, separator, **values):
+        """ Compute the reference prefix from the transaction values.
+
+        If the `values` parameter has an entry with 'invoice_ids' as key and a list of (4, id, O) or
+        (6, 0, ids) X2M command as value, the prefix is computed based on the invoice name(s).
+        Otherwise, an empty string is returned.
+
+        Note: This method should be called in sudo mode to give access to documents (INV, SO, ...).
+
+        :param str provider: The provider of the acquirer handling the transaction
+        :param str separator: The custom separator used to separate data references
+        :param dict values: The transaction values used to compute the reference prefix. It should
+                            have the structure {'invoice_ids': [(X2M command), ...], ...}.
+        :return: The computed reference prefix if invoice ids are found, an empty string otherwise
+        :rtype: str
+        """
+        command_list = values.get('invoice_ids')
+        if command_list:
+            # Extract invoice id(s) from the X2M commands
+            invoice_ids = self._fields['invoice_ids'].convert_to_cache(command_list, self)
+            invoices = self.env['account.move'].browse(invoice_ids).exists()
+            if len(invoices) == len(invoice_ids):  # All ids are valid
+                return separator.join(invoices.mapped('name'))
+        return ''
+
+    @api.model
+    def _generate_callback_hash(self, callback_model_id, callback_res_id, callback_method):
+        """ Return the hash for the callback on the transaction.
+
+        :param int callback_model_id: The model on which the callback method is defined, as a
+                                      `res.model` id
+        :param int callback_res_id: The record on which the callback method must be called, as an id
+                                    of the callback model
+        :param str callback_method: The name of the callback method
+        :return: The callback hash
+        :retype: str
+        """
+        if callback_model_id and callback_res_id and callback_method:
+            model_name = self.env['ir.model'].sudo().browse(callback_model_id).model
+            token = f'{model_name}|{callback_res_id}|{callback_method}'
+            callback_hash = hmac_tool(self.env(su=True), 'generate_callback_hash', token)
+            return callback_hash
+        return None
+
+    def _get_processing_values(self):
+        """ Return a dict of values used to process the transaction.
+
+        The returned dict contains the following entries:
+            - tx_id: The transaction, as a `payment.transaction` id
+            - acquirer_id: The acquirer handling the transaction, as a `payment.acquirer` id
+            - provider: The provider of the acquirer
+            - reference: The reference of the transaction
+            - amount: The rounded amount of the transaction
+            - currency_id: The currency of the transaction, as a res.currency id
+            - partner_id: The partner making the transaction, as a res.partner id
+            - Additional acquirer-specific entries
+
+        Note: self.ensure_one()
+
+        :return: The dict of processing values
+        :rtype: dict
+        """
+        self.ensure_one()
+
+        processing_values = {
+            'acquirer_id': self.acquirer_id.id,
+            'provider': self.provider,
+            'reference': self.reference,
+            'amount': self.amount,
+            'currency_id': self.currency_id.id,
+            'partner_id': self.partner_id.id,
+        }
+
+        # Complete generic processing values with acquirer-specific values
+        processing_values.update(self._get_specific_processing_values(processing_values))
+        _logger.info(
+            "generic and acquirer-specific processing values for transaction with id %s:\n%s",
+            self.id, pprint.pformat(processing_values)
+        )
+
+        # Render the html form for the redirect flow if available
+        if self.operation in ('online_redirect', 'validation') \
+                and self.acquirer_id.redirect_form_view_id:
+            rendering_values = self._get_specific_rendering_values(processing_values)
+            _logger.info(
+                "acquirer-specific rendering values for transaction with id %s:\n%s",
+                self.id, pprint.pformat(rendering_values)
+            )
+            redirect_form_html = self.acquirer_id.redirect_form_view_id._render(
+                rendering_values, engine='ir.qweb'
+            )
+            processing_values.update(redirect_form_html=redirect_form_html)
+
+        return processing_values
+
+    def _get_specific_processing_values(self, processing_values):
+        """ Return a dict of acquirer-specific values used to process the transaction.
+
+        For an acquirer to add its own processing values, it must overwrite this method and return a
+        dict of acquirer-specific values based on the generic values returned by this method.
+        Acquirer-specific values take precedence over those of the dict of generic processing
+        values.
+
+        :param dict processing_values: The generic processing values of the transaction
+        :return: The dict of acquirer-specific processing values
+        :rtype: dict
+        """
+        return dict()
+
+    def _get_specific_rendering_values(self, processing_values):
+        """ Return a dict of acquirer-specific values used to render the redirect form.
+
+        For an acquirer to add its own rendering values, it must overwrite this method and return a
+        dict of acquirer-specific values based on the processing values (acquirer-specific
+        processing values included).
+
+        :param dict processing_values: The processing values of the transaction
+        :return: The dict of acquirer-specific rendering values
+        :rtype: dict
+        """
+        return dict()
+
+    def _send_payment_request(self):
+        """ Request the provider of the acquirer handling the transaction to execute the payment.
+
+        For an acquirer to support tokenization, it must override this method and call it to log the
+        'sent' message, then request a money transfer to its provider.
+
+        Note: self.ensure_one()
+
+        :return: None
+        """
+        self.ensure_one()
+        self._log_sent_message()
+
+    @api.model
+    def _handle_feedback_data(self, provider, data):
+        """ Match the transaction with the feedback data, update its state and return it.
+
+        :param str provider: The provider of the acquirer that handled the transaction
+        :param dict data: The feedback data sent by the provider
+        :return: The transaction
+        :rtype: recordset of `payment.transaction`
+        """
+        tx = self._get_tx_from_feedback_data(provider, data)
+        tx._process_feedback_data(data)
+        tx._execute_callback()
+        return tx
+
+    @api.model
+    def _get_tx_from_feedback_data(self, provider, data):
+        """ Find the transaction based on the feedback data.
+
+        For an acquirer to handle transaction post-processing, it must overwrite this method and
+        return the transaction matching the data.
+
+        :param str provider: The provider of the acquirer that handled the transaction
+        :param dict data: The feedback data sent by the acquirer
+        :return: The transaction if found
+        :rtype: recordset of `payment.transaction`
+        """
+        return self
+
+    def _process_feedback_data(self, data):
+        """ Update the transaction state and the acquirer reference based on the feedback data.
+
+        For an acquirer to handle transaction post-processing, it must overwrite this method and
+        process the feedback data.
+
+        Note: self.ensure_one()
+
+        :param dict data: The feedback data sent by the acquirer
+        :return: None
+        """
+        self.ensure_one()
+
+    def _set_pending(self, state_message=None):
+        """ Update the transactions' state to 'pending'.
+
+        :param str state_message: The reason for which the transaction is set in 'pending' state
+        :return: None
+        """
+        allowed_states = ('draft',)
+        target_state = 'pending'
+        txs_to_process = self._update_state(allowed_states, target_state, state_message)
+        txs_to_process._log_received_message()
+
+    def _set_authorized(self, state_message=None):
+        """ Update the transactions' state to 'authorized'.
+
+        :param str state_message: The reason for which the transaction is set in 'authorized' state
+        :return: None
+        """
+        allowed_states = ('draft', 'pending')
+        target_state = 'authorized'
+        txs_to_process = self._update_state(allowed_states, target_state, state_message)
+        txs_to_process._log_received_message()
+
+    def _set_done(self, state_message=None):
+        """ Update the transactions' state to 'done'.
+
+        :return: None
+        """
+        allowed_states = ('draft', 'pending', 'authorized', 'error')
+        target_state = 'done'
+        txs_to_process = self._update_state(allowed_states, target_state, state_message)
+        txs_to_process._log_received_message()
+
+    def _set_canceled(self, state_message=None):
+        """ Update the transactions' state to 'cancel'.
+
+        :param str state_message: The reason for which the transaction is set in 'cancel' state
+        :return: None
+        """
+        allowed_states = ('draft', 'pending', 'authorized')
+        target_state = 'cancel'
+        txs_to_process = self._update_state(allowed_states, target_state, state_message)
+        # Cancel the existing payments
+        txs_to_process.mapped('payment_id').action_cancel()
+        txs_to_process._log_received_message()
+
+    def _set_error(self, state_message):
+        """ Update the transactions' state to 'error'.
+
+        :param str state_message: The reason for which the transaction is set in 'error' state
+        :return: None
+        """
+        allowed_states = ('draft', 'pending', 'authorized')
+        target_state = 'error'
+        txs_to_process = self._update_state(allowed_states, target_state, state_message)
+        txs_to_process._log_received_message()
+
+    def _update_state(self, allowed_states, target_state, state_message):
+        """ Update the transactions' state to the target state if the current state allows it.
+
+        If the current state is the same as the target state, the transaction is skipped.
+
+        :param tuple[str] allowed_states: The allowed source states for the target state
+        :param str target_state: The target state
+        :param str state_message: The message to set as `state_message`
+        :return: The recordset of transactions whose state was correctly updated
+        :rtype: recordset of `payment.transaction`
+        """
+
+        def _classify_by_state(_transactions):
+            """Classify the transactions according to their current state.
+
+            For each transaction of the current recordset, if:
+                - The state is an allowed state: the transaction is flagged as 'to process'.
+                - The state is equal to the target state: the transaction is flagged as 'processed'.
+                - The state matches none of above: the transaction is flagged as 'in wrong state'.
+
+            :param recordset _transactions: The transactions to classify, as a `payment.transaction`
+                                            recordset
+            :return: A 3-items tuple of recordsets of classified transactions, in this order:
+                     transactions 'to process', 'processed', and 'in wrong state'
+            :rtype: tuple(recordset)
+            """
+            _txs_to_process = _transactions.filtered(lambda _tx: _tx.state in allowed_states)
+            _txs_already_processed = _transactions.filtered(lambda _tx: _tx.state == target_state)
+            _txs_wrong_state = _transactions - _txs_to_process - _txs_already_processed
+
+            return _txs_to_process, _txs_already_processed, _txs_wrong_state
+
+        txs_to_process, txs_already_processed, txs_wrong_state = _classify_by_state(self)
+        for tx in txs_already_processed:
+            _logger.info(
+                "tried to write tx state with same value (ref: %s, state: %s)",
+                tx.reference, tx.state
+            )
+        for tx in txs_wrong_state:
+            logging_values = {
+                'reference': tx.reference,
+                'tx_state': tx.state,
+                'target_state': target_state,
+                'allowed_states': allowed_states,
+            }
+            _logger.warning(
+                "tried to write tx state with illegal value (ref: %(reference)s, previous state "
+                "%(tx_state)s, target state: %(target_state)s, expected previous state to be in: "
+                "%(allowed_states)s)", logging_values
+            )
+        txs_to_process.write({
+            'state': target_state,
+            'state_message': state_message,
+            'last_state_change': fields.Datetime.now(),
+        })
+        return txs_to_process
+
+    def _execute_callback(self):
+        """ Execute the callbacks defined on the transactions.
+
+        Callbacks that have already been executed are silently ignored. This case can happen when a
+        transaction is first authorized before being confirmed, for instance. In this case, both
+        status updates try to execute the callback.
+
+        Only successful callbacks are marked as done. This allows callbacks to reschedule themselves
+        should the conditions not be met in the present call.
+
+        :return: None
+        """
+        for tx in self.filtered(lambda t: not t.sudo().callback_is_done):
+            # Only use sudo to check, not to execute
+            model_sudo = tx.sudo().callback_model_id
+            res_id = tx.sudo().callback_res_id
+            method = tx.sudo().callback_method
+            if not (model_sudo and res_id and method):
+                continue  # Skip transactions with unset (or not properly defined) callbacks
+
+            valid_callback_hash = self._generate_callback_hash(model_sudo.id, res_id, method)
+            if not consteq(ustr(valid_callback_hash), tx.callback_hash):
+                _logger.warning("invalid callback signature for transaction with id %s", tx.id)
+                continue  # Ignore tampered callbacks
+
+            record = self.env[model_sudo.model].browse(res_id).exists()
+            if not record:
+                logging_values = {
+                    'model': model_sudo.model,
+                    'record_id': res_id,
+                    'tx_id': tx.id,
+                }
+                _logger.warning(
+                    "invalid callback record %(model)s.%(record_id)s for transaction with id "
+                    "%(tx_id)s", logging_values
+                )
+                continue  # Ignore invalidated callbacks
+
+            success = getattr(record, method)(tx)  # Execute the callback
+            tx.callback_is_done = success or success is None  # Missing returns are successful
+
+    def _send_refund_request(self):
+        """ Request the provider of the acquirer handling the transaction to refund it.
+
+        For an acquirer to support tokenization, it must override this method and request a refund
+        to its provider *if the validation amount is not null*.
+
+        Note: self.ensure_one()
+
+        :return: None
+        """
+        self.ensure_one()
+
+    def _send_capture_request(self):
+        """ Request the provider of the acquirer handling the transaction to capture it.
+
+        For an acquirer to support authorization, it must override this method and request a capture
+        to its provider.
+
+        Note: self.ensure_one()
+
+        :return: None
+        """
+        self.ensure_one()
+
+    def _send_void_request(self):
+        """ Request the provider of the acquirer handling the transaction to void it.
+
+        For an acquirer to support authorization, it must override this method and request the
+        transaction to be voided to its provider.
+
+        Note: self.ensure_one()
+
+        :return: None
+        """
+        self.ensure_one()
+
+    #=== BUSINESS METHODS - POST-PROCESSING ===#
+
+    def _get_post_processing_values(self):
+        """ Return a dict of values used to display the status of the transaction.
+
+        For an acquirer to handle transaction status display, it must override this method and
+        return a dict of values. Acquirer-specific values take precedence over those of the dict of
+        generic post-processing values.
+
+        The returned dict contains the following entries:
+            - provider: The provider of the acquirer
+            - reference: The reference of the transaction
+            - amount: The rounded amount of the transaction
+            - currency_id: The currency of the transaction, as a res.currency id
+            - state: The transaction state: draft, pending, authorized, done, cancel or error
+            - state_message: The information message about the state
+            - is_post_processed: Whether the transaction has already been post-processed
+            - landing_route: The route the user is redirected to after the transaction
+            - Additional acquirer-specific entries
+
+        Note: self.ensure_one()
+
+        :return: The dict of processing values
+        :rtype: dict
+        """
+        self.ensure_one()
+
+        post_processing_values = {
+            'provider': self.provider,
+            'reference': self.reference,
+            'amount': self.amount,
+            'currency_code': self.currency_id.name,
+            'state': self.state,
+            'state_message': self.state_message,
+            'is_validation': self.operation == 'validation',
+            'is_post_processed': self.is_post_processed,
+            'validation_route': self.validation_route,
+            'landing_route': self.landing_route,
+        }
+        _logger.debug(
+            "post-processing values for acquirer with id %s:\n%s",
+            self.acquirer_id.id, pprint.pformat(post_processing_values)
+        )  # DEBUG level because this can get spammy with transactions in non-final states
+        return post_processing_values
+
+    def _finalize_post_processing(self):
+        """ Trigger the final post-processing tasks and mark the transactions as post-processed.
+
+        :return: None
+        """
+        self._reconcile_after_done()
+        self._log_received_message()  # 2nd call to link the created account.payment in the chatter
+        self.is_post_processed = True
+
+    def _cron_finalize_post_processing(self):
+        """ Finalize the post-processing of recently done transactions not handled by the client.
+
+        :return: None
+        """
+        txs_to_post_process = self
+        if not txs_to_post_process:
+            # Let the client post-process transactions so that they remain available in the portal
+            client_handling_limit_date = datetime.now() - relativedelta.relativedelta(minutes=1)
+            # Don't try forever to post-process a transaction that doesn't go through
+            retry_limit_date = datetime.now() - relativedelta.relativedelta(days=2)
+            # Retrieve all transactions matching the criteria for post-processing
+            txs_to_post_process = self.search([
+                ('state', '=', 'done'),
+                ('is_post_processed', '=', False),
+                ('last_state_change', '<=', client_handling_limit_date),
+                ('last_state_change', '>=', retry_limit_date),
+            ])
+        for tx in txs_to_post_process:
+            try:
+                tx._finalize_post_processing()
+                self.env.cr.commit()
+            except psycopg2.OperationalError:  # A collision of accounting sequences occurred
+                self.env.cr.rollback()  # Rollback and try later
+            except Exception as e:
+                _logger.exception(
+                    "encountered an error while post-processing transaction with id %s:\n%s",
+                    tx.id, e
+                )
+                self.env.cr.rollback()
+
+    def _reconcile_after_done(self):
+        """ Post relevant fiscal documents and create missing payments.
+
+        :return: None
+        """
+        # Validate invoices automatically once the transaction is confirmed
+        self.invoice_ids.filtered(lambda inv: inv.state == 'draft').action_post()
+
+        # Create and post missing payments
+        for tx in self.filtered(lambda t: not t.payment_id):
+            tx._create_payment()
+
+    def _create_payment(self, **extra_create_values):
+        """Create an `account.payment` record for the current transaction.
+
+        If the transaction is linked to some invoices, their reconciliation is done automatically.
+
+        Note: self.ensure_one()
+
+        :param dict extra_create_values: Optional extra create values
+        :return: The created payment
+        :rtype: recordset of `account.payment`
+        """
+        self.ensure_one()
+
+        payment_values = {
+            'amount': self.amount,
+            'payment_type': 'inbound' if self.amount > 0 else 'outbound',
+            'currency_id': self.currency_id.id,
+            'partner_id': self.partner_id.commercial_partner_id.id,
+            'partner_type': 'customer',
+            'journal_id': self.acquirer_id.journal_id.id,
+            'company_id': self.acquirer_id.company_id.id,
+            'payment_method_id': self.env.ref('payment.account_payment_method_electronic_in').id,
+            'payment_token_id': self.token_id.id,
+            'payment_transaction_id': self.id,
+            'ref': self.reference,
+            **extra_create_values,
+        }
+        payment = self.env['account.payment'].create(payment_values)
+        payment.action_post()
+
+        # Track the payment to make a one2one.
+        self.payment_id = payment
+
+        if self.invoice_ids:
+            self.invoice_ids.filtered(lambda inv: inv.state == 'draft').action_post()
+
+            (payment.line_ids + self.invoice_ids.line_ids).filtered(
+                lambda line: line.account_id == payment.destination_account_id
+                and not line.reconciled
+            ).reconcile()
+
+        return payment
+
+    #=== BUSINESS METHODS - LOGGING ===#
+
+    def _log_sent_message(self):
+        """ Log in the chatter of relevant documents that the transactions have been initiated.
+
+        :return: None
+        """
+        for tx in self:
+            message = tx._get_sent_message()
+            tx._log_message_on_linked_documents(message)
+
+    def _log_received_message(self):
+        """ Log in the chatter of relevant documents that the transactions have been received.
+
+        A transaction is 'received' when a response is received from the provider of the acquirer
+        handling the transaction.
+
+        :return: None
+        """
+        for tx in self:
+            message = tx._get_received_message()
+            tx._log_message_on_linked_documents(message)
+
+    def _log_message_on_linked_documents(self, message):
+        """ Log a message on the invoices linked to the transaction.
+
+        For a module to implement payments and link documents to a transaction, it must override
+        this method and call super, then log the message on documents linked to the transaction.
+
+        Note: self.ensure_one()
+
+        :param str message: The message to be logged
+        :return: None
+        """
+        self.ensure_one()
+
+        for invoice in self.invoice_ids:
+            invoice.message_post(body=message)
+
+    #=== BUSINESS METHODS - GETTERS ===#
+
+    def _get_sent_message(self):
+        """ Return the message stating that the transaction has been requested.
+
+        Note: self.ensure_one()
+
+        :return: The 'transaction sent' message
+        :rtype: str
+        """
+        self.ensure_one()
+
+        # Choose the message based on the payment flow
+        if self.operation in ('online_redirect', 'online_direct'):
+            message = _(
+                "A transaction with reference %(ref)s has been initiated (%(acq_name)s).",
+                ref=self.reference, acq_name=self.acquirer_id.name
+            )
+        else:  # 'online_token'
+            message = _(
+                "A transaction with reference %(ref)s has been initiated using the payment method "
+                "%(token_name)s (%(acq_name)s).",
+                ref=self.reference, token_name=self.token_id.name, acq_name=self.acquirer_id.name
+            )
+        return message
+
+    def _get_received_message(self):
+        """ Return the message stating that the transaction has been received by the provider.
+
+        Note: self.ensure_one()
+        """
+        self.ensure_one()
+
+        formatted_amount = formatLang(self.env, self.amount, currency_obj=self.currency_id)
+        if self.state == 'pending':
+            message = _(
+                "The transaction with reference %(ref)s for %(amount)s is pending (%(acq_name)s).",
+                ref=self.reference, amount=formatted_amount, acq_name=self.acquirer_id.name
+            )
+        elif self.state == 'authorized':
+            message = _(
+                "The transaction with reference %(ref)s for %(amount)s has been authorized "
+                "(%(acq_name)s).", ref=self.reference, amount=formatted_amount,
+                acq_name=self.acquirer_id.name
+            )
+        elif self.state == 'done':
+            message = _(
+                "The transaction with reference %(ref)s for %(amount)s has been confirmed "
+                "(%(acq_name)s).", ref=self.reference, amount=formatted_amount,
+                acq_name=self.acquirer_id.name
+            )
+            if self.payment_id:
+                message += _(
+                    "\nThe related payment is posted: %s",
+                    self.payment_id._get_payment_chatter_link()
+                )
+        elif self.state == 'error':
+            message = _(
+                "The transaction with reference %(ref)s for %(amount)s encountered an error"
+                " (%(acq_name)s).",
+                ref=self.reference, amount=formatted_amount, acq_name=self.acquirer_id.name
+            )
+            if self.state_message:
+                message += _("\nError: %s", self.state_message)
+        else:
+            message = _(
+                "The transaction with reference %(ref)s for %(amount)s is canceled (%(acq_name)s).",
+                ref=self.reference, amount=formatted_amount, acq_name=self.acquirer_id.name
+            )
+            if self.state_message:
+                message += _("\nReason: %s", self.state_message)
+        return message
+
+    def _get_last(self):
+        """ Return the last transaction of the recordset.
+
+        :return: The last transaction of the recordset, sorted by id
+        :rtype: recordset of `payment.transaction`
+        """
+        return self.filtered(lambda t: t.state != 'draft').sorted()[:1]

--- a/addons/payment/models/res_company.py
+++ b/addons/payment/models/res_company.py
@@ -1,4 +1,3 @@
-# -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
 from odoo import api, fields, models
@@ -7,25 +6,31 @@ from odoo import api, fields, models
 class ResCompany(models.Model):
     _inherit = 'res.company'
 
-    payment_acquirer_onboarding_state = fields.Selection([('not_done', "Not done"), ('just_done', "Just done"), ('done', "Done")], string="State of the onboarding payment acquirer step", default='not_done')
-    # YTI FIXME: Check if it's really needed on the company. Should be enough on the wizard
-    payment_onboarding_payment_method = fields.Selection([
-        ('paypal', "PayPal"),
-        ('stripe', "Stripe"),
-        ('manual', "Manual"),
-        ('other', "Other"),
-    ], string="Selected onboarding payment method")
+    payment_acquirer_onboarding_state = fields.Selection(
+        string="State of the onboarding payment acquirer step",
+        selection=[('not_done', "Not done"), ('just_done', "Just done"), ('done', "Done")],
+        default='not_done')
+    payment_onboarding_payment_method = fields.Selection(
+        string="Selected onboarding payment method",
+        selection=[
+            ('paypal', "PayPal"),
+            ('stripe', "Stripe"),
+            ('manual', "Manual"),
+            ('other', "Other"),
+        ])
 
     @api.model
     def action_open_payment_onboarding_payment_acquirer(self):
-        """ Called by onboarding panel above the customer invoice list."""
+        """ Called by onboarding panel above the customer invoice list. """
         # Fail if there are no existing accounts
         self.env.company.get_chart_of_accounts_or_fail()
 
-        action = self.env["ir.actions.actions"]._for_xml_id("payment.action_open_payment_onboarding_payment_acquirer_wizard")
+        action = self.env['ir.actions.actions']._for_xml_id(
+            'payment.action_open_payment_onboarding_payment_acquirer_wizard'
+        )
         return action
 
     def get_account_invoice_onboarding_steps_states_names(self):
-        """ Override. """
-        steps = super(ResCompany, self).get_account_invoice_onboarding_steps_states_names()
+        """ Override of account. """
+        steps = super().get_account_invoice_onboarding_steps_states_names()
         return steps + ['payment_acquirer_onboarding_state']

--- a/addons/payment/models/res_partner.py
+++ b/addons/payment/models/res_partner.py
@@ -1,19 +1,22 @@
-# coding: utf-8
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
 
 from odoo import api, fields, models
 
 
-class res_partner(models.Model):
-    _name = 'res.partner'
+class ResPartner(models.Model):
     _inherit = 'res.partner'
 
-    payment_token_ids = fields.One2many('payment.token', 'partner_id', 'Payment Tokens')
-    payment_token_count = fields.Integer('Count Payment Token', compute='_compute_payment_token_count')
+    payment_token_ids = fields.One2many(
+        string="Payment Tokens", comodel_name='payment.token', inverse_name='partner_id')
+    payment_token_count = fields.Integer(
+        string="Payment Token Count", compute='_compute_payment_token_count')
 
     @api.depends('payment_token_ids')
     def _compute_payment_token_count(self):
-        payment_data = self.env['payment.token'].read_group([
-            ('partner_id', 'in', self.ids)], ['partner_id'], ['partner_id'])
-        mapped_data = dict([(payment['partner_id'][0], payment['partner_id_count']) for payment in payment_data])
+        payments_data = self.env['payment.token'].read_group(
+            [('partner_id', 'in', self.ids)], ['partner_id'], ['partner_id']
+        )
+        partners_data = {payment_data['partner_id'][0]: payment_data['partner_id_count']
+                         for payment_data in payments_data}
         for partner in self:
-            partner.payment_token_count = mapped_data.get(partner.id, 0)
+            partner.payment_token_count = partners_data.get(partner.id, 0)
