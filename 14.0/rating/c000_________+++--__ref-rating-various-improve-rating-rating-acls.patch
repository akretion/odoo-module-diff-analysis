PR: https://github.com/odoo/odoo/pull/

From: c7a1a2d964c5bb132b717b8b80f630b68861631d
From: ryv-odoo
Date: 2019-11-19 15:46:51

Structural Changes: 22
Total Changes: 75

[REF] rating, various: improve rating.rating ACLs

PURPOSE

Rating model should be available only for internal users. External users
access them only through dedicated routes or controllers using sudo and/or
granting access through tokens. Therefore simplifying ACLs should be feasible.

SPECIFICATIONS

Remove access to rating.rating for public and portal users. Only employees
can access it, with full access given to system admins.

Update various functional flows to use sudo() and check that access is
verified before using sudo.

Impacted modules

  * rating / mail: add groups on some rating related fields as only
    internal users should access them now;
  * rating / mail: set some statistics fields using compute_sudo as their
    value should be accessible for external people even without access to
    the underlying rating.rating records;
  * project: makes some use of rating and has to be updated, notably for
    the public rating page;
  * website_{livechat, rating, slides}: add sudo in public routes as access
    is already granted;
  * website_slides: set statistics field using compute_sudo as their
    value should be accessible for external people;

TASK ID 2053096
PR #36592

Signed-off-by: Thibault Delavallee (tde) <tde@openerp.com>

================================= pseudo patch: =================================

--- a/addons/rating/models/mail_message.py
+++ b/addons/rating/models/mail_message.py
@@ -7,8 +7,10 @@ from odoo import api, fields, models
 class MailMessage(models.Model):
     _inherit = 'mail.message'
 
-    rating_ids = fields.One2many('rating.rating', 'message_id', string='Related ratings')
-    rating_value = fields.Float("Rating Value", compute='_compute_rating_value', store=False, search='_search_rating_value')
+    rating_ids = fields.One2many('rating.rating', 'message_id', groups='base.group_user', string='Related ratings')
+    rating_value = fields.Float(
+        'Rating Value', compute='_compute_rating_value', compute_sudo=True,
+        store=False, search='_search_rating_value')
 
     @api.depends('rating_ids', 'rating_ids.rating')
     def _compute_rating_value(self):

--- a/addons/rating/models/mail_thread.py
+++ b/addons/rating/models/mail_thread.py
@@ -12,9 +12,12 @@ class MailThread(models.AbstractModel):
         rating_value = kwargs.pop('rating_value', False)
         rating_feedback = kwargs.pop('rating_feedback', False)
         message = super(MailThread, self).message_post(**kwargs)
+
+        # create rating.rating record linked to given rating_value. Using sudo as portal users may have
+        # rights to create messages and therefore ratings (security should be checked beforehand)
         if rating_value:
             ir_model = self.env['ir.model'].sudo().search([('model', '=', self._name)])
-            self.env['rating.rating'].create({
+            self.env['rating.rating'].sudo().create({
                 'rating': float(rating_value) if rating_value is not None else False,
                 'feedback': rating_feedback,
                 'res_model_id': ir_model.id,

--- a/addons/rating/models/rating_mixin.py
+++ b/addons/rating/models/rating_mixin.py
@@ -12,8 +12,14 @@ class RatingParentMixin(models.AbstractModel):
     _description = "Rating Parent Mixin"
     _rating_satisfaction_days = False  # Number of last days used to compute parent satisfaction. Set to False to include all existing rating.
 
-    rating_ids = fields.One2many('rating.rating', 'parent_res_id', string='Ratings', domain=lambda self: [('parent_res_model', '=', self._name)], auto_join=True)
-    rating_percentage_satisfaction = fields.Integer("Rating Satisfaction", compute="_compute_rating_percentage_satisfaction", store=False, help="Percentage of happy ratings")
+    rating_ids = fields.One2many(
+        'rating.rating', 'parent_res_id', string='Ratings',
+        auto_join=True, groups='base.group_user',
+        domain=lambda self: [('parent_res_model', '=', self._name)])
+    rating_percentage_satisfaction = fields.Integer(
+        "Rating Satisfaction",
+        compute="_compute_rating_percentage_satisfaction", compute_sudo=True,
+        store=False, help="Percentage of happy ratings")
 
     @api.depends('rating_ids.rating', 'rating_ids.consumed')
     def _compute_rating_percentage_satisfaction(self):
@@ -46,12 +52,12 @@ class RatingMixin(models.AbstractModel):
     _name = 'rating.mixin'
     _description = "Rating Mixin"
 
-    rating_ids = fields.One2many('rating.rating', 'res_id', string='Rating', domain=lambda self: [('res_model', '=', self._name)], auto_join=True)
-    rating_last_value = fields.Float('Rating Last Value', compute='_compute_rating_last_value', compute_sudo=True, store=True)
-    rating_last_feedback = fields.Text('Rating Last Feedback', related='rating_ids.feedback')
-    rating_last_image = fields.Binary('Rating Last Image', related='rating_ids.rating_image')
-    rating_count = fields.Integer('Rating count', compute="_compute_rating_stats")
-    rating_avg = fields.Float("Rating Average", compute='_compute_rating_stats')
+    rating_ids = fields.One2many('rating.rating', 'res_id', string='Rating', groups='base.group_user', domain=lambda self: [('res_model', '=', self._name)], auto_join=True)
+    rating_last_value = fields.Float('Rating Last Value', groups='base.group_user', compute='_compute_rating_last_value', compute_sudo=True, store=True)
+    rating_last_feedback = fields.Text('Rating Last Feedback', groups='base.group_user', related='rating_ids.feedback')
+    rating_last_image = fields.Binary('Rating Last Image', groups='base.group_user', related='rating_ids.rating_image')
+    rating_count = fields.Integer('Rating count', compute="_compute_rating_stats", compute_sudo=True)
+    rating_avg = fields.Float("Rating Average", compute='_compute_rating_stats', compute_sudo=True)
 
     @api.depends('rating_ids.rating')
     def _compute_rating_last_value(self):
@@ -59,7 +65,7 @@ class RatingMixin(models.AbstractModel):
             ratings = self.env['rating.rating'].search([('res_model', '=', self._name), ('res_id', '=', record.id)], limit=1)
             record.rating_last_value = ratings and ratings.rating or 0
 
-    @api.depends('rating_ids')
+    @api.depends('rating_ids.res_id', 'rating_ids.rating')
     def _compute_rating_stats(self):
         """ Compute avg and count in one query, as thoses fields will be used together most of the time. """
         domain = self._rating_domain()
@@ -79,7 +85,7 @@ class RatingMixin(models.AbstractModel):
                     res_name_field = self.env['rating.rating']._fields['res_name']
                     self.env.add_to_compute(res_name_field, record.rating_ids)
                 if record._rating_get_parent_field_name() in values:
-                    record.rating_ids.write({'parent_res_id': record[record._rating_get_parent_field_name()].id})
+                    record.rating_ids.sudo().write({'parent_res_id': record[record._rating_get_parent_field_name()].id})
 
         return result
 
@@ -112,13 +118,19 @@ class RatingMixin(models.AbstractModel):
         return self.env['res.partner']
 
     def rating_get_access_token(self, partner=None):
+        """ Return access token linked to existing ratings, or create a new rating
+        that will create the asked token. An explicit call to access rights is
+        performed as sudo is used afterwards as this method could be used from
+        different sources, notably templates. """
+        self.check_access_rights('read')
+        self.check_access_rule('read')
         if not partner:
             partner = self.rating_get_partner_id()
         rated_partner = self.rating_get_rated_partner_id()
-        ratings = self.rating_ids.filtered(lambda x: x.partner_id.id == partner.id and not x.consumed)
+        ratings = self.rating_ids.sudo().filtered(lambda x: x.partner_id.id == partner.id and not x.consumed)
         if not ratings:
             record_model_id = self.env['ir.model'].sudo().search([('model', '=', self._name)], limit=1).id
-            rating = self.env['rating.rating'].create({
+            rating = self.env['rating.rating'].sudo().create({
                 'partner_id': partner.id,
                 'rated_partner_id': rated_partner.id,
                 'res_model_id': record_model_id,
@@ -158,21 +170,23 @@ class RatingMixin(models.AbstractModel):
 
     def rating_apply(self, rate, token=None, feedback=None, subtype=None):
         """ Apply a rating given a token. If the current model inherits from
-        mail.thread mixing, a message is posted on its chatter.
-        :param rate : the rating value to apply
-        :type rate : float
-        :param token : access token
-        :param feedback : additional feedback
-        :type feedback : string
-        :param subtype : subtype for mail
-        :type subtype : string
+        mail.thread mixin, a message is posted on its chatter. User going through
+        this method should have at least employee rights because of rating
+        manipulation (either employee, either sudo-ed in public controllers after
+        security check granting access).
+
+        :param float rate : the rating value to apply
+        :param string token : access token
+        :param string feedback : additional feedback
+        :param string subtype : xml id of a valid mail.message.subtype
+
         :returns rating.rating record
         """
-        Rating, rating = self.env['rating.rating'], None
+        rating = None
         if token:
             rating = self.env['rating.rating'].search([('access_token', '=', token)], limit=1)
         else:
-            rating = Rating.search([('res_model', '=', self._name), ('res_id', '=', self.ids[0])], limit=1)
+            rating = self.env['rating.rating'].search([('res_model', '=', self._name), ('res_id', '=', self.ids[0])], limit=1)
         if rating:
             rating.write({'rating': rate, 'feedback': feedback, 'consumed': True})
             if hasattr(self, 'message_post'):
@@ -190,7 +204,7 @@ class RatingMixin(models.AbstractModel):
                     self.write({'kanban_state': 'blocked'})
         return rating
 
-    def rating_get_repartition(self, add_stats=False, domain=None):
+    def _rating_get_repartition(self, add_stats=False, domain=None):
         """ get the repatition of rating grade for the given res_ids.
             :param add_stats : flag to add stat to the result
             :type add_stats : boolean
@@ -228,7 +242,7 @@ class RatingMixin(models.AbstractModel):
                                                 31-69%: Okay
                                                 70-100%: Great
         """
-        data = self.rating_get_repartition(domain=domain)
+        data = self._rating_get_repartition(domain=domain)
         res = dict.fromkeys(['great', 'okay', 'bad'], 0)
         for key in data:
             if key >= RATING_LIMIT_SATISFIED:
@@ -247,7 +261,7 @@ class RatingMixin(models.AbstractModel):
                 - value is statistic value : 'percent' contains the repartition in percentage, 'avg' is the average rate
                   and 'total' is the number of rating
         """
-        data = self.rating_get_repartition(domain=domain, add_stats=True)
+        data = self._rating_get_repartition(domain=domain, add_stats=True)
         result = {
             'avg': data['avg'],
             'total': data['total'],
