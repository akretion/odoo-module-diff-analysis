PR: https://github.com/odoo/odoo/pull/32253

From: d3d58b60dc8c67d0b9926821ca13f0e6a3832a1d
From: Sébastien Theys
Date: 2019-03-30 11:25:19

Structural Changes: 15
Total Changes: 133

[IMP] base,product,website_sale: move image fallback mixin -> variant

Only the variant is using this code, so it was a bad idea to make the mixin
more complicated than it had to be.

Update the image tests to make sure this is working correctly. The test were
only testing the size of the images, now they also test the actual content.

Part of task-1949729

closes odoo/odoo#32253

Signed-off-by: Jérémy Kersten (jke) <jke@openerp.com>

================================= pseudo patch: =================================

--- a/addons/product/models/product.py
+++ b/addons/product/models/product.py
@@ -83,7 +83,7 @@ class ProductProduct(models.Model):
     _name = "product.product"
     _description = "Product"
     _inherits = {'product.template': 'product_tmpl_id'}
-    _inherit = ['mail.thread', 'mail.activity.mixin', 'image.mixin']
+    _inherit = ['mail.thread', 'mail.activity.mixin']
     _order = 'default_code, name, id'
 
     # price: total price, context dependent (partner, pricelist, quantity)
@@ -137,6 +137,113 @@ class ProductProduct(models.Model):
         'product.packaging', 'product_id', 'Product Packages',
         help="Gives the different ways to package the same product.")
 
+    # all image fields are base64 encoded and PIL-supported
+
+    # all image_raw fields are technical and should not be displayed to the user
+    image_raw_original = fields.Binary("Raw Original Image")
+
+    # resized fields stored (as attachment) for performance
+    image_raw_big = fields.Binary("Raw Big-sized Image", compute='_compute_images', store=True)
+    image_raw_large = fields.Binary("Raw Large-sized Image", compute='_compute_images', store=True)
+    image_raw_medium = fields.Binary("Raw Medium-sized Image", compute='_compute_images', store=True)
+    image_raw_small = fields.Binary("Raw Small-sized Image", compute='_compute_images', store=True)
+
+    can_image_raw_be_zoomed = fields.Boolean("Can image raw be zoomed", compute='_compute_images', store=True)
+
+    # Computed fields that are used to create a fallback to the template if
+    # necessary, it's recommended to display those fields to the user.
+    image_original = fields.Binary("Original Image", compute='_compute_image_original', inverse='_set_image_original', help="Image in its original size, as it was uploaded.")
+    image_big = fields.Binary("Big-sized Image", compute='_compute_image_big', help="1024px * 1024px")
+    image_large = fields.Binary("Large-sized Image", compute='_compute_image_large', help="256px * 256px")
+    image_medium = fields.Binary("Medium-sized Image", compute='_compute_image_medium', help="128px * 128px")
+    image_small = fields.Binary("Small-sized Image", compute='_compute_image_small', help="64px * 64px")
+    can_image_be_zoomed = fields.Boolean("Can image be zoomed", compute='_compute_can_image_be_zoomed')
+
+    image = fields.Binary("Image", compute='_compute_image', inverse='_set_image')
+
+    @api.multi
+    @api.depends('image_raw_original')
+    def _compute_images(self):
+        for record in self:
+            images = tools.image_get_resized_images(record.image_raw_original, big_name=False)
+            record.image_raw_big = tools.image_get_resized_images(record.image_raw_original,
+                large_name=False, medium_name=False, small_name=False, preserve_aspect_ratio=True)['image']
+            record.image_raw_large = images['image_large']
+            record.image_raw_medium = images['image_medium']
+            record.image_raw_small = images['image_small']
+            record.can_image_raw_be_zoomed = tools.is_image_size_above(record.image_raw_original)
+
+    @api.multi
+    def _compute_image_original(self):
+        """Get the image from the template if no image is set on the variant."""
+        for record in self:
+            record.image_original = record.image_raw_original or record.product_tmpl_id.image_original
+
+    @api.multi
+    def _set_image_original(self):
+        for record in self:
+            if (
+                # We are trying to remove an image even though it is already
+                # not set, remove it from the template instead.
+                not record.image_original and not record.image_raw_original or
+                # We are trying to add an image, but the template image is
+                # not set, write on the template instead.
+                record.image_original and not record.product_tmpl_id.image_original or
+                # There is only one variant, always write on the template.
+                self.search_count([
+                    ('product_tmpl_id', '=', record.product_tmpl_id.id),
+                    ('active', '=', True),
+                ]) <= 1
+            ):
+                record.product_tmpl_id.image_original = record.image_original
+            else:
+                record.image_raw_original = record.image_original
+
+    @api.multi
+    def _compute_image_big(self):
+        """Get the image from the template if no image is set on the variant."""
+        for record in self:
+            record.image_big = record.image_raw_big or record.product_tmpl_id.image_big
+
+    @api.multi
+    def _compute_image_large(self):
+        """Get the image from the template if no image is set on the variant."""
+        for record in self:
+            record.image_large = record.image_raw_large or record.product_tmpl_id.image_large
+
+    @api.multi
+    def _compute_image_medium(self):
+        """Get the image from the template if no image is set on the variant."""
+        for record in self:
+            record.image_medium = record.image_raw_medium or record.product_tmpl_id.image_medium
+
+    @api.multi
+    def _compute_image_small(self):
+        """Get the image from the template if no image is set on the variant."""
+        for record in self:
+            record.image_small = record.image_raw_small or record.product_tmpl_id.image_small
+
+    @api.multi
+    def _compute_can_image_be_zoomed(self):
+        """Get the image from the template if no image is set on the variant."""
+        for record in self:
+            record.can_image_be_zoomed = record.can_image_raw_be_zoomed if record.image_raw_original else record.product_tmpl_id.can_image_be_zoomed
+
+    @api.multi
+    @api.depends('image_big')
+    def _compute_image(self):
+        for record in self:
+            record.image = record.image_big
+
+    @api.multi
+    def _set_image(self):
+        for record in self:
+            record.image_original = record.image
+        # We want the image field to be recomputed to have a correct size.
+        # Without this `invalidate_cache`, the image field will keep holding the
+        # image_original instead of the big-sized image.
+        self.invalidate_cache()
+
     _sql_constraints = [
         ('barcode_uniq', 'unique(barcode)', "A barcode can only be assigned to one product !"),
     ]
@@ -251,26 +358,6 @@ class ProductProduct(models.Model):
                 else:
                     product.product_template_attribute_value_ids += values_per_template[product.product_tmpl_id.id][pav.id]
 
-    @api.multi
-    def _get_image_fallback_record(self):
-        """Override to get the image from the template if no image is set on the
-        variant."""
-        return self.product_tmpl_id
-
-    @api.multi
-    def _force_write_image_on_fallback(self):
-        """Override to always write on the template if there is only one
-        variant.
-
-        This is needed because when there is only one variant, the user doesn't
-        know there is a difference between template and variant, he expects both
-        images to be the same.
-        """
-        return self.env['product.product'].search_count([
-            ('product_tmpl_id', '=', self.product_tmpl_id.id),
-            ('active', '=', True),
-        ]) <= 1
-
     @api.one
     def _get_pricelist_items(self):
         self.pricelist_item_ids = self.env['product.pricelist.item'].search([
@@ -327,6 +414,10 @@ class ProductProduct(models.Model):
         unlink_products = self.env['product.product']
         unlink_templates = self.env['product.template']
         for product in self:
+            # If there is an image set on the variant and no image set on the
+            # template, move the image to the template.
+            if product.image_raw_original and not product.product_tmpl_id.image_original:
+                product.product_tmpl_id.image_original = product.image_raw_original
             # Check if product still exists, in case it has been unlinked by unlinking its template
             if not product.exists():
                 continue
