PR: https://github.com/odoo/odoo/pull/

From: 38294dbc99a344ea1a3c7e534ddf7d92b17b0be9
From: Laurent Stukkens (LTU)
Date: 2020-03-31 08:08:22

Structural Changes: 5
Total Changes: 25

[IMP] purchase, purchase_requisition: improve UX

Several improvements in order to improve user interface are done here.

[IMP] purchase: Prevent create PO&RFQ in calendar
   It was possible to create PO's and RFQ's from the calendar view.
   The Product Owner wanted to prevent the users from doing so.

[IMP] purchase: Add tooltip to Receipt Date

[FIX] purchase: Align report & stat button data on product form
   The use of Last 365 days time_range in the purchase analysis was automatically
   excluding today's purchases wich was confusing users as the stat button info
   was taking those into account.

   Different behaviours were implemented for product template and product product
   in the filters that were used which makes no sense.

   Use of context_today() instead of datetime.now() in order to take the user's
   timezone into account.

[IMP] purchase: Use relevant dates for RFQ's and PO's in calendar view
   The date used in order to display RFQs and POs in the calendar was date_planned
   which is not mandatory and so not always filled. It has been decided to use the
   order_date for the RFQ's and date_approve for PO's.

[IMP] purchase_requisition: Making Agreement selection type more explicit

[IMP] purchase: Show UOM menu only if installed

[IMP] purchase: Add product variant in settings

[IMP] purchase: Remove Favorites predefined filters

[IMP] purchase: Rephrase PO action helper

[IMP] purchase: Allow open/edit Agreement Type

[IMP] purchase: Rephrase RFQ action helper

[IMP] purchase: Remove PO's and RFQ's name from fields in calendar
   The Product Owner originally wanted to have a link on the PO name field
   that was shown in the calendat popover. As the Edit button already allows
   to edit the PO's or RFQ's from the popover it was decided to simply remove
   the field (as it was already displayed at the top of the popover)

[IMP] purchase: Open the right view when click on Reporting top menu

Task ID #2196688
Closes #47810

Related: odoo/enterprise#9294
Related: odoo/upgrade#961
Signed-off-by: Thibault Delavallee (tde) <tde@openerp.com>

================================= pseudo patch: =================================

--- a/addons/purchase/models/product.py
+++ b/addons/purchase/models/product.py
@@ -5,6 +5,7 @@ from datetime import timedelta
 from odoo import api, fields, models, _
 from odoo.addons.base.models.res_partner import WARNING_MESSAGE, WARNING_HELP
 from odoo.tools.float_utils import float_round
+from dateutil.relativedelta import relativedelta
 
 
 class ProductTemplate(models.Model):
@@ -43,8 +44,7 @@ class ProductTemplate(models.Model):
         action['domain'] = ['&', ('state', 'in', ['purchase', 'done']), ('product_tmpl_id', 'in', self.ids)]
         action['context'] = {
             'graph_measure': 'qty_ordered',
-            'search_default_orders': 1,
-            'time_ranges': {'field': 'date_approve', 'range': 'last_365_days'}
+            'search_default_later_than_a_year_ago': True
         }
         return action
 
@@ -56,13 +56,12 @@ class ProductProduct(models.Model):
     purchased_product_qty = fields.Float(compute='_compute_purchased_product_qty', string='Purchased')
 
     def _compute_purchased_product_qty(self):
-        date_from = fields.Datetime.to_string(fields.datetime.now() - timedelta(days=365))
+        date_from = fields.Datetime.to_string(fields.Date.context_today(self) - relativedelta(years=1))
         domain = [
-            ('state', 'in', ['purchase', 'done']),
+            ('order_id.state', 'in', ['purchase', 'done']),
             ('product_id', 'in', self.ids),
-            ('date_order', '>', date_from)
+            ('order_id.date_approve', '>=', date_from)
         ]
-        PurchaseOrderLines = self.env['purchase.order.line'].search(domain)
         order_lines = self.env['purchase.order.line'].read_group(domain, ['product_id', 'product_uom_qty'], ['product_id'])
         purchased_data = dict([(data['product_id'][0], data['product_uom_qty']) for data in order_lines])
         for product in self:
@@ -75,9 +74,8 @@ class ProductProduct(models.Model):
         action = self.env.ref('purchase.action_purchase_order_report_all').read()[0]
         action['domain'] = ['&', ('state', 'in', ['purchase', 'done']), ('product_id', 'in', self.ids)]
         action['context'] = {
-            'search_default_last_year_purchase': 1,
-            'search_default_status': 1, 'search_default_order_month': 1,
-            'graph_measure': 'qty_ordered'
+            'graph_measure': 'qty_ordered',
+            'search_default_later_than_a_year_ago': True
         }
         return action
 

--- a/addons/purchase/models/purchase.py
+++ b/addons/purchase/models/purchase.py
@@ -98,7 +98,9 @@ class PurchaseOrder(models.Model):
     ], string='Billing Status', compute='_get_invoiced', store=True, readonly=True, copy=False, default='no')
 
     # There is no inverse function on purpose since the date may be different on each line
-    date_planned = fields.Datetime(string='Receipt Date', index=True)
+    date_planned = fields.Datetime(string='Receipt Date', index=True,
+                                   help='This is the Receipt Date promised by the supplier. If set, the receipt will be scheduled at this date.')
+    date_calendar_start = fields.Datetime(compute='_compute_date_calendar_start', readonly=True, store=True)
 
     amount_untaxed = fields.Monetary(string='Untaxed Amount', store=True, readonly=True, compute='_amount_all', tracking=True)
     amount_tax = fields.Monetary(string='Taxes', store=True, readonly=True, compute='_amount_all')
@@ -128,6 +130,11 @@ class PurchaseOrder(models.Model):
         for order in self:
             order.access_url = '/my/purchase/%s' % (order.id)
 
+    @api.depends('state', 'date_order', 'date_approve')
+    def _compute_date_calendar_start(self):
+        for order in self:
+            order.date_calendar_start = order.date_approve if (order.state in ['purchase', 'done']) else order.date_order
+
     @api.model
     def _name_search(self, name, args=None, operator='ilike', limit=100, name_get_uid=None):
         args = args or []
