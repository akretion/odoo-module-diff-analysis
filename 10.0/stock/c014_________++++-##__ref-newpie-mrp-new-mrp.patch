PR: https://github.com/odoo/odoo/pull/

From: 2ddc35a5300e89981c0572ae6749aee946f34e9d
From: Josse Colpaert
Date: 2016-07-04 14:22:37

Structural Changes: 23
Total Changes: 237

[REF][NEWPIE] mrp: new MRP

This commit contains the core of the new MRP. It contains a whole refactoring
of the MRP application, with improved and new features, written in new API.
Among other here are the main manufacturing workflow improvements :

 - Picking type not only for pickings but also for manufacturing orders
 - Properties replaced by picking type
 - BoM can only be produced with its routing (no other)
 - Either produce without routing with only production orders, or produce with
   routing
 - By default, there is an order in the work orders (serially), but you can
   override it to be able to work in parallel
 - Time clocking on work orders and block time on work centers with reporting
   on OEE, performance, losses, ...
 - Real-time adaptation of timings on operations
 - Lots/serial numbers can be inputted like in the pickings on manufacturing
   orders.  It is also possible to input them in the work orders.
 - Material availability independent of production order state (possibility to
   start production when only part of it is there)
 - Work sheets on work orders
 - Put messages on work orders to make your workers pay attention to something
 - Full traceability link to see for each produced piece of stock, the
   consumed pieces, ...
 - Separate scrap object (a scrap is not done based on an original move
   anymore)
 - Separate unbuild system (if you want to unbuild into its original
   components)

Thanks to all people that helped during this development, notably but not
limited to Chirag A Dodiya (cod@odoo.com), Gaurav Panchal (gan@odoo.com),
Jignesh Rathod (jir@odoo.com), Mansi Trivedi (mtr@odoo.com), Pariket Trivedi
(ptr@odoo.com).

================================= pseudo patch: =================================

--- a/addons/stock/models/__init__.py
+++ b/addons/stock/models/__init__.py
@@ -17,4 +17,5 @@ import stock_production_lot
 import stock_picking
 import stock_quant
 import stock_warehouse
+import stock_scrap
 import web_planner

--- a/addons/stock/models/procurement.py
+++ b/addons/stock/models/procurement.py
@@ -32,7 +32,10 @@ class ProcurementRule(models.Model):
         default='make_to_stock', required=True,
         help="""Determines the procurement method of the stock move that will be generated: whether it will need to 'take from the available stock' in its source location or needs to ignore its stock and create a procurement over there.""")
     route_sequence = fields.Integer('Route Sequence', related='route_id.sequence', store=True)
-    picking_type_id = fields.Many2one('stock.picking.type', 'Picking Type', help="Picking Type determines the way the picking should be shown in the view, reports, ...")
+    picking_type_id = fields.Many2one(
+        'stock.picking.type', 'Picking Type',
+        required=True,
+        help="Picking Type determines the way the picking should be shown in the view, reports, ...")
     delay = fields.Integer('Number of Days', default=0)
     partner_address_id = fields.Many2one('res.partner', 'Partner Address')
     propagate = fields.Boolean(

--- a/addons/stock/models/stock_config_settings.py
+++ b/addons/stock/models/stock_config_settings.py
@@ -114,6 +114,10 @@ class StockSettings(models.TransientModel):
         ], "Warehouses and Locations usage level")
     group_stock_multi_locations = fields.Boolean('Manage several stock locations', implied_group='stock.group_stock_multi_locations')
     group_stock_multi_warehouses = fields.Boolean('Manage several warehouses', implied_group='stock.group_stock_multi_warehouses')
+    # module_mrp_plm = fields.Selection([
+    #     (0, "No product lifecycle management"),
+    #     (1, "Manage engineering changes, versions and documents")
+    #     ], "PLM")
 
     @api.onchange('warehouse_and_location_usage_level')
     def onchange_warehouse_and_location_usage_level(self):

--- a/addons/stock/models/stock_move.py
+++ b/addons/stock/models/stock_move.py
@@ -116,8 +116,7 @@ class StockMove(models.Model):
              "The other possibility allows you to directly create a procurement on the source location (and thus ignore "
              "its current stock) to gather products. If we want to chain moves and have this one to wait for the previous,"
              "this second option should be chosen.")
-    # used for colors in tree views - TDE FIXME: weird error - has a relation (comodel_name ?)
-    scrapped = fields.Boolean('Scrapped', related='location_dest_id.scrap_location', readonly=True)
+    scrapped = fields.Boolean('Scrapped', related='location_dest_id.scrap_location', readonly=True, store=True)
     quant_ids = fields.Many2many('stock.quant', 'stock_quant_move_rel', 'move_id', 'quant_id', 'Moved Quants', copy=False)
     reserved_quant_ids = fields.One2many('stock.quant', 'reservation_id', 'Reserved quants')
     linked_move_operation_ids = fields.One2many(
@@ -310,7 +309,6 @@ class StockMove(models.Model):
             pickings.message_track(pickings.fields_get(['state']), initial_values)
         return res
 
-
     # Misc tools
     # ------------------------------------------------------------
 
@@ -341,7 +339,17 @@ class StockMove(models.Model):
         return ancestors
     find_move_ancestors = get_ancestors
 
+    def _filter_closed_moves(self):
+        """ Helper methods when having to avoid working on moves that are
+        already done or canceled. In a lot of cases you may handle a batch
+        of stock moves, some being already done / canceled, other being still
+        under computation. Instead of having to use filtered everywhere and
+        forgot some of them, use this tool instead. """
+        return self.filtered(lambda move: move.state not in ('done', 'cancel'))
+
 
+    # Main actions
+    # ------------------------------------------------------------
 
     @api.multi
     def do_unreserve(self):
@@ -485,7 +493,7 @@ class StockMove(models.Model):
         for key, moves in to_assign.items():
             moves.assign_picking()
         self._push_apply()
-        return True
+        return self
 
     def set_default_price_unit_from_product(self):
         """ Set price to move, important in inter-company moves or receipts with only one partner """
@@ -891,42 +899,6 @@ class StockMove(models.Model):
             raise UserError(_('You can only delete draft moves.'))
         return super(StockMove, self).unlink()
 
-    @api.returns('self')
-    @api.multi
-    def action_scrap(self, quantity, location_id, restrict_lot_id=False, restrict_partner_id=False):
-        """ Move the scrap/damaged product into scrap location. Returns scrapped lines. """
-        # quantity should be given in MOVE UOM TDE FIXME: actually solve this comment
-        if quantity <= 0:
-            raise UserError(_('Please provide a positive quantity to scrap.'))
-
-        Quant = self.env["stock.quant"]
-        scrap_moves = self.env['stock.move']
-        for move in self:
-            new_move = move.copy({
-                'location_id': move.location_dest_id.id if move.state == 'done' else move.location_id.id,
-                'product_uom_qty': quantity,
-                'state': move.state,
-                'scrapped': True,
-                'location_dest_id': location_id,
-                'restrict_lot_id': restrict_lot_id,
-                'restrict_partner_id': restrict_partner_id,
-            })
-            scrap_moves |= new_move
-            if move.picking_id:
-                move.picking_id.message_post(body=_("%s %s %s has been <b>moved to</b> scrap.") % (quantity, move.product_id.uom_id.name or '', move.product_id.name))
-
-            # We "flag" the quant from which we want to scrap the products. To do so:
-            #    - we select the quants related to the move we scrap from
-            #    - we reserve the quants with the scrapped move
-            # See self.action_done, et particularly how is defined the "preferred_domain" for clarification
-
-            if move.state == 'done' and new_move.location_id.usage not in ('supplier', 'inventory', 'production'):
-                # We use scrap_move data since a reservation makes sense for a move not already done
-                quants = Quant.quants_get_preferred_domain(quantity, new_move, domain=[('qty', '>', 0), ('history_ids', 'in', [move.id])])
-                Quant.quants_reserve(quants, new_move)
-        scrap_moves.action_done()
-        return scrap_moves
-
     @api.multi
     def split(self, qty, restrict_lot_id=False, restrict_partner_id=False):
         """ Splits qty from move move into a new move

--- a/addons/stock/models/stock_picking.py
+++ b/addons/stock/models/stock_picking.py
@@ -227,6 +227,8 @@ class Picking(models.Model):
         readonly=True, required=True,
         states={'draft': [('readonly', False)]})
     move_lines = fields.One2many('stock.move', 'picking_id', string="Stock Moves", copy=True)
+    has_scrap_move = fields.Boolean(
+        'Has Scrap Moves', compute='_has_scrap_move')
     picking_type_id = fields.Many2one(
         'stock.picking.type', 'Picking Type',
         required=True,
@@ -341,6 +343,11 @@ class Picking(models.Model):
     def _set_min_date(self):
         self.move_lines.write({'date_expected': self.min_date})
 
+    @api.one
+    def _has_scrap_move(self):
+        # TDE FIXME: better implementation
+        self.has_scrap_move = bool(self.env['stock.move'].search_count([('picking_id', '=', self.id), ('scrapped', '=', True)]))
+
     @api.one
     def _compute_quant_reserved_exist(self):
         # TDE TODO: chould probably be cleaned with a search in quants
@@ -995,3 +1002,25 @@ class Picking(models.Model):
             else:
                 raise UserError(_('Please process some quantities to put in the pack first!'))
         return package
+
+    @api.multi
+    def button_scrap(self):
+        self.ensure_one()
+        return {
+            'name': _('Scrap'),
+            'view_type': 'form',
+            'view_mode': 'form',
+            'res_model': 'stock.scrap',
+            'view_id': self.env.ref('stock.stock_scrap_form_view2').id,
+            'type': 'ir.actions.act_window',
+            'context': {'default_picking_id': self.id, 'product_ids': self.pack_operation_product_ids.mapped('product_id').ids},
+            'target': 'new',
+        }
+
+    @api.multi
+    def action_see_move_scrap(self):
+        self.ensure_one()
+        action = self.env.ref('stock.action_stock_scrap').read()[0]
+        scraps = self.env['stock.scrap'].search([('picking_id', '=', self.id)])
+        action['domain'] = [('id', 'in', scraps.ids)]
+        return action

--- a/addons/stock/models/stock_production_lot.py
+++ b/addons/stock/models/stock_production_lot.py
@@ -16,13 +16,22 @@ class ProductionLot(models.Model):
     product_id = fields.Many2one(
         'product.product', 'Product',
         domain=[('type', 'in', ['product', 'consu'])], required=True)
+    product_uom_id = fields.Many2one(
+        'product.uom', 'Unit of Measure',
+        related='product_id.uom_id', store=True)
     quant_ids = fields.One2many('stock.quant', 'lot_id', 'Quants', readonly=True)
     create_date = fields.Datetime('Creation Date')
+    product_qty = fields.Float('Quantity', compute='_product_qty')
 
     _sql_constraints = [
         ('name_ref_uniq', 'unique (name, product_id)', 'The combination of serial number and product must be unique !'),
     ]
 
+    @api.one
+    @api.depends('quant_ids.qty')
+    def _product_qty(self):
+        self.product_qty = sum(self.quant_ids.mapped('qty'))
+
     @api.multi
     def action_traceability(self):
         move_ids = self.mapped('quant_ids').mapped('history_ids').ids

--- a/addons/stock/models/stock_quant.py
+++ b/addons/stock/models/stock_quant.py
@@ -377,7 +377,7 @@ class Quant(models.Model):
             return reservations
             # return self._Reservation(reserved_quants, qty, qty, move, None)
 
-        restrict_lot_id = lot_id if pack_operation else move.restrict_lot_id.id
+        restrict_lot_id = lot_id if pack_operation else move.restrict_lot_id.id or lot_id
         removal_strategy = move.get_removal_strategy()
 
         domain = self._quants_get_reservation_domain(

--- a/None
+++ b/addons/stock/models/stock_scrap.py
@@ -0,0 +1,135 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from openerp import api, fields, models, _
+from openerp.exceptions import UserError
+
+
+class StockScrap(models.Model):
+    _name = 'stock.scrap'
+    _order = 'id desc'
+
+    def _get_default_scrap_location_id(self):
+        return self.env['stock.location'].search([('scrap_location', '=', True)], limit=1).id
+
+    def _get_default_location_id(self):
+        return self.env.ref('stock.stock_location_stock', raise_if_not_found=False)
+
+    name = fields.Char(
+        'Reference',  default=lambda self: _('New'),
+        copy=False, readonly=True, required=True,
+        states={'done': [('readonly', True)]})
+    origin = fields.Char(string='Source Document')
+    product_id = fields.Many2one(
+        'product.product', 'Product',
+        required=True, states={'done': [('readonly', True)]})
+    product_uom_id = fields.Many2one(
+        'product.uom', 'Unit of Measure',
+        required=True, states={'done': [('readonly', True)]})
+    tracking = fields.Selection('Product Tracking', readonly=True, related="product_id.tracking")
+    lot_id = fields.Many2one(
+        'stock.production.lot', 'Lot',
+        states={'done': [('readonly', True)]}, domain="[('product_id', '=', product_id)]")
+    package_id = fields.Many2one(
+        'stock.quant.package', 'Package',
+        states={'done': [('readonly', True)]})
+    owner_id = fields.Many2one('res.partner', 'Owner', states={'done': [('readonly', True)]})
+    move_id = fields.Many2one('stock.move', 'Scrap Move', readonly=True)
+    picking_id = fields.Many2one('stock.picking', 'Picking', states={'done': [('readonly', True)]})
+    location_id = fields.Many2one(
+        'stock.location', 'Location', domain="[('usage', '=', 'internal')]",
+        required=True, states={'done': [('readonly', True)]}, default=_get_default_location_id)
+    scrap_location_id = fields.Many2one(
+        'stock.location', 'Scrap Location', default=_get_default_scrap_location_id,
+        domain="[('scrap_location', '=', True)]", states={'done': [('readonly', True)]})
+    scrap_qty = fields.Float('Quantity', default=1.0, required=True, states={'done': [('readonly', True)]})
+    state = fields.Selection([
+        ('draft', 'Draft'),
+        ('done', 'Done')], string='Status', default="draft")
+    date_expected = fields.Datetime('Expected Date', default=fields.Datetime.now)
+
+    @api.onchange('picking_id')
+    def _onchange_picking_id(self):
+        if self.picking_id:
+            self.location_id = (self.picking_id.state == 'done') and self.picking_id.location_dest_id.id or self.picking_id.location_id.id
+
+    @api.onchange('product_id')
+    def onchange_product_id(self):
+        if self.product_id:
+            self.product_uom_id = self.product_id.uom_id.id
+
+    @api.model
+    def create(self, vals):
+        if 'name' not in vals or vals['name'] == _('New'):
+            vals['name'] = self.env['ir.sequence'].next_by_code('stock.scrap') or _('New')
+        scrap = super(StockScrap, self).create(vals)
+        scrap.do_scrap()
+        return scrap
+
+    def _get_origin_moves(self):
+        return self.picking_id and self.picking_id.move_lines.filtered(lambda x: x.product_id == self.product_id)
+
+    @api.multi
+    def do_scrap(self):
+        for scrap in self:
+            moves = scrap._get_origin_moves() or self.env['stock.move']
+            move = self.env['stock.move'].create(scrap._prepare_move_values())
+            quants = self.env['stock.quant'].quants_get_preferred_domain(
+                move.product_qty, move,
+                domain=[
+                    ('qty', '>', 0),
+                    ('lot_id', '=', self.lot_id.id),
+                    ('package_id', '=', self.package_id.id)],
+                preferred_domain_list=scrap._get_preferred_domain())
+            if any([not x[0] for x in quants]):
+                raise UserError(_('You cannot scrap a move without having available stock for %s. You can correct it with an inventory adjustment.') % move.product_id.name)
+            self.env['stock.quant'].quants_reserve(quants, move)
+            move.action_done()
+            scrap.write({'move_id': move.id, 'state': 'done'})
+            moves.recalculate_move_state()
+        return True
+
+    def _prepare_move_values(self):
+        self.ensure_one()
+        return {
+            'name': self.name,
+            'origin': self.origin,
+            'product_id': self.product_id.id,
+            'product_uom': self.product_uom_id.id,
+            'product_uom_qty': self.scrap_qty,
+            'location_id': self.location_id.id,
+            'scrapped': True,
+            'location_dest_id': self.scrap_location_id.id,
+            'restrict_lot_id': self.lot_id.id,
+            'restrict_partner_id': self.owner_id.id,
+            'picking_id': self.picking_id.id
+        }
+
+    def _get_preferred_domain(self):
+        if not self.picking_id:
+            return []
+        if self.picking_id.state == 'done':
+            preferred_domain = [('history_ids', 'in', self.picking_id.move_lines.filtered(lambda x: x.state == 'done')).ids]
+            preferred_domain2 = [('history_ids', 'not in', self.picking_id.move_lines.filtered(lambda x: x.state == 'done')).ids]
+            return [preferred_domain, preferred_domain2]
+        else:
+            preferred_domain = [('reservation_id', 'in', self.picking_id.move_lines.ids)]
+            preferred_domain2 = [('reservation_id', '=', False)]
+            preferred_domain3 = ['&', ('reservation_id', 'not in', self.picking_id.move_lines.ids), ('reservation_id', '!=', False)]
+            return [preferred_domain, preferred_domain2, preferred_domain3]
+
+    @api.multi
+    def action_get_stock_picking(self):
+        action = self.env.ref('stock.action_picking_tree_all').read([])[0]
+        action['domain'] = [('id', '=', self.picking_id.id)]
+        return action
+
+    @api.multi
+    def action_get_stock_move(self):
+        action = self.env.ref('stock.stock_move_action').read([])[0]
+        action['domain'] = [('id', '=', self.move_id.id)]
+        return action
+
+    @api.multi
+    def action_done(self):
+        return {'type': 'ir.actions.act_window_close'}
