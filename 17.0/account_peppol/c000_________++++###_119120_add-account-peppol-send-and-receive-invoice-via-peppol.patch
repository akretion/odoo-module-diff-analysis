PR: https://github.com/odoo/odoo/pull/119120

From: be00ef8e37445738684cebb8b25d4bf226ae8f41
From: aliya
Date: 2023-05-11 16:25:03

Structural Changes: 25
Total Changes: 457

[ADD] account_peppol: send and receive invoice via peppol

This commits adds `account_peppol` module that allows:
- Registering as an account edi user and send an application to the peppol proxy,
  where the participant can be approved or rejected after reviewing the documents attached.
- Sending invoices by selecting 'Send via Peppol' option in the send & print wizard.
- Receiving peppol documents.

task-3159912

closes odoo/odoo#119120

Signed-off-by: Laurent Smet <las@odoo.com>

================================= pseudo patch: =================================

--- a/None
+++ b/addons/account_peppol/models/__init__.py
@@ -0,0 +1,8 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from . import account_edi_proxy_user
+from . import account_move
+from . import res_company
+from . import res_config_settings
+from . import res_partner

--- a/None
+++ b/addons/account_peppol/models/account_edi_proxy_user.py
@@ -0,0 +1,209 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+import logging
+
+from odoo import fields, models, _
+from odoo.addons.account_edi_proxy_client.models.account_edi_proxy_user import AccountEdiProxyError
+from odoo.exceptions import UserError
+
+_logger = logging.getLogger(__name__)
+
+
+class AccountEdiProxyClientUser(models.Model):
+    _inherit = 'account_edi_proxy_client.user'
+
+    proxy_type = fields.Selection(
+        selection_add=[('peppol', 'PEPPOL')],
+    )
+
+    def _get_proxy_urls(self):
+        urls = super()._get_proxy_urls()
+        urls['peppol'] = {
+            'prod': '',
+            'test': 'https://l10n-pe-edi.test.odoo.com',
+        }
+        return urls
+
+    def _get_server_url(self, proxy_type=None, edi_mode=None):
+        proxy_type = proxy_type or self.proxy_type
+        if not proxy_type == 'peppol':
+            return super()._get_server_url(proxy_type, edi_mode)
+
+        peppol_param = self.env['ir.config_parameter'].sudo().get_param(
+            'account_peppol.edi.mode', False
+        )
+        if peppol_param == 'test':
+            edi_mode = 'test'
+
+        return super()._get_server_url(proxy_type, edi_mode)
+
+    def _compute_proxy_type(self):
+        # Extends account_edi_proxy_client
+        super()._compute_proxy_type()
+        for user in self:
+            if user.company_id.is_account_peppol_participant:
+                user.proxy_type = 'peppol'
+
+    def _get_proxy_identification(self, company):
+        if not company.peppol_eas or not company.peppol_endpoint:
+            raise UserError(
+                _("Please fill in the EAS code and the Participant ID code in the company's partner form."))
+        return f'{company.peppol_eas}:{company.peppol_endpoint}'
+
+    def _cron_peppol_get_new_documents(self):
+        # Retrieve all new Peppol documents for every edi user in the database
+        edi_users = self.env['account_edi_proxy_client.user'].search(
+            [('company_id.account_peppol_proxy_state', '=', 'active')])
+
+        for edi_user in edi_users:
+            proxy_acks = []
+            try:
+                # request all messages that haven't been acknowledged
+                messages = edi_user._make_request(
+                    f"{edi_user._get_server_url()}/api/peppol/1/get_all_documents")
+            except AccountEdiProxyError as e:
+                _logger.error(
+                    'Error while receiving the document from Peppol Proxy: %s', e.message)
+                continue
+
+            message_uuids = [
+                message['uuid']
+                for message in messages['messages']
+                if message['direction'] == 'incoming'
+                and message['receiver'] == edi_user.edi_identification
+            ]
+            if not message_uuids:
+                continue
+
+            company = edi_user.company_id
+            # retrieve attachments for filtered messages
+            all_messages = edi_user._make_request(
+                f"{edi_user._get_server_url()}/api/peppol/1/get_document",
+                {'message_uuids': message_uuids},
+            )
+
+            for uuid, content in all_messages.items():
+                error_move_vals = {
+                    'move_type': 'in_invoice',
+                    'peppol_move_state': 'error',
+                    'company_id': company.id,
+                    'extract_can_show_send_button': False,
+                    'peppol_message_uuid': uuid,
+                }
+                if content.get('error'):
+                    # in this case there is no attachment that we could add to the account move
+                    move = self.env['account.move'].create(error_move_vals)
+                    move._message_log(body=_('Error when receiving via Peppol: %s', content['error']['message']))
+                    proxy_acks.append(uuid)
+                    continue
+
+                enc_key = content["enc_key"]
+                document_content = content["document"]
+                filename = content["filename"]
+                partner_endpoint = content["accounting_supplier_party"]
+                decoded_document = edi_user._decrypt_data(document_content, enc_key)
+
+                journal_id = company.peppol_purchase_journal_id
+                # use the first purchase journal if the Peppol journal is not set up
+                # to create the move anyway
+                if not journal_id:
+                    journal_id = self.env['account.journal'].search(
+                        [('company_id', '=', company.id), ('type', '=', 'purchase')],
+                        limit=1,
+                    )
+
+                attachment_vals = {
+                    'name': f'{filename}.xml',
+                    'raw': decoded_document,
+                    'type': 'binary',
+                    'mimetype': 'application/xml',
+                }
+
+                try:
+                    attachment = self.env['ir.attachment'].create(attachment_vals)
+                    move = journal_id\
+                        .with_context(
+                            default_move_type='in_invoice',
+                            default_peppol_move_state='done',
+                            default_extract_can_show_send_button=False,
+                            default_peppol_message_uuid=uuid,
+                        )\
+                        ._create_document_from_attachment(attachment.id)
+                    if partner_endpoint:
+                        move._message_log(body=_(
+                            'Peppol document has been received successfully. Sender endpoint: %s', partner_endpoint))
+                    else:
+                        move._message_log(
+                            body=_('Peppol document has been received successfully'))
+                except Exception:
+                    # if the invoice creation fails for any reason,
+                    # we want to create an empty invoice with the attachment
+                    move = self.env['account.move'].create(error_move_vals)
+                    attachment_vals.update({
+                        'res_model': 'account.move',
+                        'res_id': move.id,
+                    })
+                    self.env['ir.attachment'].create(attachment_vals)
+                    if partner_endpoint:
+                        move._message_log(body=_(
+                            'Failed to import a Peppol document. Sender endpoint: %s', partner_endpoint))
+                    else:
+                        move._message_log(body=_('Failed to import a Peppol document.'))
+
+                proxy_acks.append(uuid)
+
+            self.env.cr.commit()
+            if proxy_acks:
+                edi_user._make_request(
+                    f"{edi_user._get_server_url()}/api/peppol/1/ack",
+                    {'message_uuids': proxy_acks},
+                )
+
+    def _cron_peppol_get_message_status(self):
+        edi_users = self.env['account_edi_proxy_client.user'].search(
+            [('company_id.account_peppol_proxy_state', '=', 'active')])
+
+        for edi_user in edi_users:
+            edi_user_moves = self.env['account.move'].search([
+                ('peppol_move_state', '=', 'processing'),
+                ('company_id', '=', edi_user.company_id.id),
+            ])
+            if not edi_user_moves:
+                continue
+
+            message_uuids = {move.peppol_message_uuid: move for move in edi_user_moves}
+            messages_to_process = edi_user._make_request(
+                f"{edi_user._get_server_url()}/api/peppol/1/get_document",
+                {'message_uuids': list(message_uuids.keys())},
+            )
+
+            for uuid, content in messages_to_process.items():
+                move = message_uuids[uuid]
+                if content.get('error'):
+                    move.peppol_move_state = 'error'
+                    move._message_log(body=_('Peppol error: %s', content['error']['message']))
+                    continue
+                move.peppol_move_state = content['state']
+                move._message_log(body=_('Peppol update: %s', content['state']))
+
+            if message_uuids:
+                edi_user._make_request(
+                    f"{edi_user._get_server_url()}/api/peppol/1/ack",
+                    {'message_uuids': list(message_uuids.keys())},
+                )
+
+    def _cron_peppol_get_participant_status(self):
+        edi_users = self.env['account_edi_proxy_client.user'].search(
+            [('company_id.account_peppol_proxy_state', '=', 'pending')])
+
+        for edi_user in edi_users:
+            try:
+                proxy_user = edi_user._make_request(
+                    f"{edi_user._get_server_url()}/api/peppol/1/participant_status")
+            except AccountEdiProxyError as e:
+                _logger.error('Error while updating Peppol participant status: %s', e)
+                continue
+
+            if proxy_user['peppol_state'] != 'draft':
+                edi_user.company_id.account_peppol_proxy_state = proxy_user['peppol_state']

--- a/None
+++ b/addons/account_peppol/models/account_move.py
@@ -0,0 +1,30 @@
+# -*- coding:utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from odoo import fields, models, _
+from odoo.exceptions import UserError
+
+
+class AccountMove(models.Model):
+    _inherit = 'account.move'
+
+    peppol_message_uuid = fields.Char(string='PEPPOL message ID')
+    peppol_move_state = fields.Selection(
+        selection=[
+            ('to_send', 'To Send'),
+            ('processing', 'Processing'),
+            ('canceled', 'Canceled'),
+            ('done', 'Done'),
+            ('error', 'Error'),
+        ],
+        string='PEPPOL status',
+        copy=False,
+        readonly=True,
+    )
+
+    def action_cancel_peppol_documents(self):
+        # if the peppol_move_state is processing/done
+        # then it means it has been already sent to peppol proxy and we can't cancel
+        if any(move.peppol_move_state in {'processing', 'done'} for move in self):
+            raise UserError(_("Cannot cancel an entry that has already been sent to PEPPOL"))
+        self.peppol_move_state = 'canceled'

--- a/None
+++ b/addons/account_peppol/models/res_company.py
@@ -0,0 +1,50 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from odoo import api, fields, models
+
+
+class ResCompany(models.Model):
+    _inherit = 'res.company'
+
+    account_peppol_attachment_ids = fields.Many2many(
+        comodel_name='ir.attachment',
+        string='Peppol Identification Documents',
+    )
+    account_peppol_proxy_state = fields.Selection(
+        selection=[
+            ('not_registered', 'Not registered'),
+            ('pending', 'Pending'),
+            ('manually_approved', 'Approved'),
+            ('active', 'Active'),
+            ('rejected', 'Rejected'),
+        ],
+        string='PEPPOL status',
+        compute='_compute_account_peppol_proxy_state', required=True, readonly=False, store=True, precompute=True,
+    )
+    is_account_peppol_participant = fields.Boolean(string='PEPPOL Participant')
+    peppol_eas = fields.Selection(related='partner_id.peppol_eas', readonly=False)
+    peppol_endpoint = fields.Char(related='partner_id.peppol_endpoint', readonly=False)
+    peppol_purchase_journal_id = fields.Many2one(
+        comodel_name='account.journal',
+        string='PEPPOL Purchase Journal',
+        domain=[('type', '=', 'purchase')],
+        compute='_compute_peppol_purchase_journal_id', store=True, readonly=False,
+    )
+
+    @api.depends('is_account_peppol_participant')
+    def _compute_account_peppol_proxy_state(self):
+        for company in self:
+            if not company.account_peppol_proxy_state:
+                company.account_peppol_proxy_state = 'not_registered'
+
+    @api.depends('is_account_peppol_participant')
+    def _compute_peppol_purchase_journal_id(self):
+        for company in self:
+            if company.is_account_peppol_participant and not company.peppol_purchase_journal_id:
+                company.peppol_purchase_journal_id = self.env['account.journal'].search(
+                    [('company_id', '=', company.id), ('type', '=', 'purchase')],
+                    limit=1,
+                )
+            else:
+                company.peppol_purchase_journal_id = False

--- a/None
+++ b/addons/account_peppol/models/res_config_settings.py
@@ -0,0 +1,75 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from base64 import b64encode
+
+from odoo import api, fields, models, _
+from odoo.addons.account_edi_proxy_client.models.account_edi_proxy_user import AccountEdiProxyError
+from odoo.exceptions import UserError, ValidationError
+
+
+class ResConfigSettings(models.TransientModel):
+    _inherit = 'res.config.settings'
+
+    account_peppol_eas = fields.Selection(related='company_id.peppol_eas', readonly=False)
+    account_peppol_endpoint = fields.Char(related='company_id.peppol_endpoint', readonly=False)
+    account_peppol_proxy_state = fields.Selection(related='company_id.account_peppol_proxy_state')
+    account_peppol_purchase_journal_id = fields.Many2one(related='company_id.peppol_purchase_journal_id', readonly=False)
+    account_peppol_attachment_ids = fields.Many2many(
+        comodel_name='ir.attachment',
+        string='Peppol Identification Documents',
+        related='company_id.account_peppol_attachment_ids', readonly=False,
+    )
+    is_account_peppol_eligible = fields.Boolean(
+        string='PEPPOL eligible',
+        compute='_compute_is_account_peppol_eligible',
+    ) # technical field used for showing the Peppol settings conditionally
+    is_account_peppol_participant = fields.Boolean(
+        string='Use PEPPOL',
+        related='company_id.is_account_peppol_participant', readonly=False,
+        help='Register as a PEPPOL user',
+    )
+
+    @api.depends("company_id.country_id")
+    def _compute_is_account_peppol_eligible(self):
+        # we want to show Peppol settings only to BE and LU customers at first
+        # but keeping an option to see them for testing purposes using a config param
+        for config in self:
+            peppol_param = config.env['ir.config_parameter'].sudo().get_param(
+                'account_peppol.edi.mode', False
+            )
+            config.is_account_peppol_eligible = config.company_id.country_id.code in {'BE', 'LU'} \
+                or peppol_param == 'test'
+
+    def button_create_peppol_proxy_user(self):
+        self.ensure_one()
+
+        if self.account_peppol_proxy_state != 'not_registered':
+            raise UserError(
+                _('Cannot register a user with a %s application', self.account_peppol_proxy_state))
+
+        if not self.company_id.account_peppol_attachment_ids:
+            raise ValidationError(
+                _('Please upload a document that would help verifying your application'))
+        edi_proxy_client = self.env['account_edi_proxy_client.user']
+        edi_identification = edi_proxy_client._get_proxy_identification(self.company_id)
+        edi_user = edi_proxy_client.sudo()._register_proxy_user(
+            self.company_id, 'peppol', 'prod', edi_identification)
+
+        params = {'documents': []}
+        for attachment in self.company_id.account_peppol_attachment_ids:
+            params['documents'].append((attachment.name, b64encode(attachment.raw).decode()))
+
+        try:
+            response = edi_user._make_request(
+                f"{edi_user._get_server_url()}/api/peppol/1/activate_participant",
+                params=params,
+            )
+        except AccountEdiProxyError as e:
+            raise UserError(e.message)
+        if 'error' in response:
+            raise UserError(response['error'])
+
+        self.company_id.account_peppol_proxy_state = 'pending'
+        # we don't need to store the attachments once they've been sent to the proxy
+        self.company_id.account_peppol_attachment_ids.unlink()

--- a/None
+++ b/addons/account_peppol/models/res_partner.py
@@ -0,0 +1,85 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+import requests
+from lxml import etree
+from hashlib import md5
+from urllib import parse
+
+from odoo import api, fields, models
+
+TIMEOUT = 10
+
+class ResPartner(models.Model):
+    _inherit = 'res.partner'
+
+    account_peppol_is_endpoint_valid = fields.Boolean(
+        string="PEPPOL endpoint validity",
+        help="The partner's EAS code and PEPPOL endpoint are valid",
+        compute="_compute_account_peppol_is_endpoint_valid", store=True,
+        copy=False,
+    )
+    account_peppol_validity_last_check = fields.Date(
+        string="Checked on",
+        help="Last Peppol endpoint verification",
+        readonly=True,
+        copy=False,
+    )
+    account_peppol_verification_label = fields.Selection(
+        selection=[
+            ('not_verified', 'Not verified yet'),
+            ('not_valid', 'Not valid'),
+            ('valid', 'Valid'),
+        ],
+        string='Peppol endpoint validity',
+        compute='_compute_account_peppol_verification_label',
+        copy=False,
+    ) # field to compute the label to show for partner endpoint
+
+    @api.depends('peppol_eas', 'peppol_endpoint')
+    def _compute_account_peppol_is_endpoint_valid(self):
+        # Every change in peppol_eas or peppol_endpoint should set the validity back to False
+        self.account_peppol_is_endpoint_valid = False
+
+    @api.depends('account_peppol_is_endpoint_valid', 'account_peppol_validity_last_check')
+    def _compute_account_peppol_verification_label(self):
+        for partner in self:
+            if not partner.account_peppol_validity_last_check:
+                partner.account_peppol_verification_label = 'not_verified'
+            elif partner.account_peppol_is_endpoint_valid:
+                partner.account_peppol_verification_label = 'valid'
+            else:
+                partner.account_peppol_verification_label = 'not_valid'
+
+    def button_account_peppol_check_partner_endpoint(self):
+        """ A basic check for whether a participant is reachable at the given
+        Peppol participant ID - peppol_eas:peppol_endpoint (ex: '9999:test')
+        The SML (Service Metadata Locator) assigns a DNS name to each peppol participant.
+        This DNS name resolves into the SMP (Service Metadata Publisher) of the participant.
+        The DNS address is of the following form:
+        - "http://B-" + hexstring(md5(lowercase(ID-VALUE))) + "." + ID-SCHEME + "." + SML-ZONE-NAME + "/" + url_encoded(ID-SCHEME + "::" + ID-VALUE)
+        (ref:https://peppol.helger.com/public/locale-en_US/menuitem-docs-doc-exchange)
+        """
+        self.ensure_one()
+
+        participant = f'{self.peppol_eas}:{self.peppol_endpoint}'.lower()
+        hash_participant = md5(participant.lower().encode()).hexdigest()
+        endpoint_participant = parse.quote_plus(f"iso6523-actorid-upis::{participant}")
+        smp_url = f"http://B-{hash_participant}.iso6523-actorid-upis.edelivery.tech.ec.europa.eu/{endpoint_participant}"
+        self.account_peppol_validity_last_check = fields.Date.context_today(self)
+        try:
+            response = requests.get(smp_url, timeout=TIMEOUT)
+        except requests.exceptions.ConnectionError:
+            self.account_peppol_is_endpoint_valid = False
+        else:
+            if response.status_code != 200:
+                self.account_peppol_is_endpoint_valid = False
+                return
+
+            participant_info = etree.XML(response.content)
+            participant_identifier = participant_info.find('{*}ParticipantIdentifier').text
+            if participant != participant_identifier:
+                self.account_peppol_is_endpoint_valid = False
+                return
+
+            self.account_peppol_is_endpoint_valid = True
