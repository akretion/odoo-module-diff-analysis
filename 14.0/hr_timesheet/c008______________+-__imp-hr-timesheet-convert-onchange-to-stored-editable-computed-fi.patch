PR: https://github.com/odoo/odoo/pull/

From: d924d89ab81d347937db48e4fb03cce408fb2cab
From: RÃ©my Baranx (bar)
Date: 2020-06-23 07:00:10

Structural Changes: 5
Total Changes: 41

[IMP] hr_timesheet: convert onchange to stored-editable computed fields

The fields 'project_id' and 'user_id' have been converted to
stored-editable computed fields.

Convert the 'allow_timesheets' field.

Improvement of the _compute_task_id method to check the task_id field before using it.

Update hr_timesheet tests by removing calls to onchange methods because
now, compute methods are always called.

Get back the onchange on the 'project_id' to compute the task_id field due to a complex
bug found in sale_timesheet tests.

================================= pseudo patch: =================================

--- a/addons/hr_timesheet/models/hr_timesheet.py
+++ b/addons/hr_timesheet/models/hr_timesheet.py
@@ -40,10 +40,11 @@ class AccountAnalyticLine(models.Model):
 
     task_id = fields.Many2one(
         'project.task', 'Task', index=True,
-        domain="[('company_id', '=', company_id), ('project_id.allow_timesheets', '=', True), ('project_id', '=?', project_id)]"
-    )
-    project_id = fields.Many2one('project.project', 'Project', domain=_domain_project_id)
-
+        domain="[('company_id', '=', company_id), ('project_id.allow_timesheets', '=', True), ('project_id', '=?', project_id)]")
+    project_id = fields.Many2one(
+        'project.project', 'Project', compute='_compute_project_id', store=True, readonly=False,
+        domain=_domain_project_id)
+    user_id = fields.Many2one(compute='_compute_user_id', store=True, readonly=False)
     employee_id = fields.Many2one('hr.employee', "Employee", check_company=True, domain=_domain_employee_id)
     department_id = fields.Many2one('hr.department', "Department", compute='_compute_department_id', store=True, compute_sudo=True)
     encoding_uom_id = fields.Many2one('uom.uom', compute='_compute_encoding_uom_id')
@@ -58,17 +59,15 @@ class AccountAnalyticLine(models.Model):
             # reset task when changing project
             self.task_id = False
 
-    @api.onchange('task_id')
-    def _onchange_task_id(self):
-        if not self.project_id:
-            self.project_id = self.task_id.project_id
-
-    @api.onchange('employee_id')
-    def _onchange_employee_id(self):
-        if self.employee_id:
-            self.user_id = self.employee_id.user_id
-        else:
-            self.user_id = self._default_user()
+    @api.depends('task_id.project_id')
+    def _compute_project_id(self):
+        for line in self.filtered(lambda line: not line.project_id):
+            line.project_id = line.task_id.project_id
+
+    @api.depends('employee_id')
+    def _compute_user_id(self):
+        for line in self:
+            line.user_id = line.employee_id.user_id if line.employee_id else line._default_user()
 
     @api.depends('employee_id')
     def _compute_department_id(self):

--- a/addons/hr_timesheet/models/project.py
+++ b/addons/hr_timesheet/models/project.py
@@ -8,7 +8,9 @@ from odoo.exceptions import UserError, ValidationError, RedirectWarning
 class Project(models.Model):
     _inherit = "project.project"
 
-    allow_timesheets = fields.Boolean("Timesheets", default=True, help="Enable timesheeting on the project.")
+    allow_timesheets = fields.Boolean(
+        "Timesheets", compute='_compute_allow_timesheets', store=True, readonly=False,
+        default=True, help="Enable timesheeting on the project.")
     analytic_account_id = fields.Many2one(
         # note: replaces ['|', ('company_id', '=', False), ('company_id', '=', company_id)]
         domain="""[
@@ -23,10 +25,10 @@ class Project(models.Model):
         compute='_compute_total_timesheet_time',
         help="Total number of time (in the proper UoM) recorded in the project, rounded to the unit.")
 
-    @api.onchange('analytic_account_id')
-    def _onchange_analytic_account(self):
-        if not self.analytic_account_id and self._origin:
-            self.allow_timesheets = False
+    @api.depends('analytic_account_id')
+    def _compute_allow_timesheets(self):
+        without_account = self.filtered(lambda t: not t.analytic_account_id and t._origin)
+        without_account.update({'allow_timesheets': False})
 
     @api.constrains('allow_timesheets', 'analytic_account_id')
     def _check_allow_timesheet(self):
