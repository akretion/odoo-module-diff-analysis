PR: https://github.com/odoo/odoo/pull/27663

From: 3e3d6c3ce0577d0611c17d27b7a459fd7ec886e9
From: jem-odoo
Date: 2018-10-30 12:43:53

Structural Changes: 3
Total Changes: 35

[REF] purchase_*: change received qty api

The received quantity on Purchase Order line can be compared
to the delivered qty on Sales Order line. It is now time for
both to share the same mecanism (introduced in
3bf8a62e0dd99f7dad42718f895abf4fd53f996f).

This commit sets `qty_received` as a computed field, depending
of a method (`qty_received_method` field) to compute it. The
value can be computed based on
 - manual value; for services (all the time), and consummable
 products (when stock is not installed).
 - stock moves; for stockable and consummable products (when
 stock is installed)

This is now easier to extend the way the received quantity
need to be computed (like in sale).

Task #1850689

closes odoo/odoo#27663

================================= pseudo patch: =================================

--- a/addons/purchase/models/purchase.py
+++ b/addons/purchase/models/purchase.py
@@ -427,7 +427,13 @@ class PurchaseOrderLine(models.Model):
 
     # Replace by invoiced Qty
     qty_invoiced = fields.Float(compute='_compute_qty_invoiced', string="Billed Qty", digits=dp.get_precision('Product Unit of Measure'), store=True)
-    qty_received = fields.Float(string="Received Qty", digits=dp.get_precision('Product Unit of Measure'), copy=False)
+
+    qty_received_method = fields.Selection([('manual', 'Manual')], string="Received Qty Method", compute='_compute_qty_received_method', store=True,
+        help="According to product configuration, the recieved quantity can be automatically computed by mechanism :\n"
+             "  - Manual: the quantity is set manually on the line\n"
+             "  - Stock Moves: the quantity comes from confirmed pickings\n")
+    qty_received = fields.Float("Received Qty", compute='_compute_qty_received', inverse='_inverse_qty_received', compute_sudo=True, store=True, digits=dp.get_precision('Product Unit of Measure'))
+    qty_received_manual = fields.Float("Manual Received Qty", digits=dp.get_precision('Product Unit of Measure'), copy=False)
 
     partner_id = fields.Many2one('res.partner', related='order_id.partner_id', string='Partner', readonly=True, store=True)
     currency_id = fields.Many2one(related='order_id.currency_id', store=True, string='Currency', readonly=True)
@@ -484,6 +490,33 @@ class PurchaseOrderLine(models.Model):
                         qty -= inv_line.uom_id._compute_quantity(inv_line.quantity, line.product_uom)
             line.qty_invoiced = qty
 
+    @api.multi
+    @api.depends('product_id')
+    def _compute_qty_received_method(self):
+        for line in self:
+            if line.product_id.type in ['consu', 'service']:
+                line.qty_received_method = 'manual'
+
+    @api.multi
+    @api.depends('qty_received_method', 'qty_received_manual')
+    def _compute_qty_received(self):
+        for line in self:
+            if line.qty_received_method == 'manual':
+                line.qty_received = line.qty_received_manual or 0.0
+
+    @api.multi
+    @api.onchange('qty_received')
+    def _inverse_qty_received(self):
+        """ When writing on qty_received, if the value should be modify manually (`qty_received_method` = 'manual' only),
+            then we put the value in `qty_received_manual`. Otherwise, `qty_received_manual` should be False since the
+            received qty is automatically compute by other mecanisms.
+        """
+        for line in self:
+            if line.qty_received_method == 'manual':
+                line.qty_received_manual = line.qty_received
+            else:
+                line.qty_received_manual = 0.0
+
     @api.model
     def create(self, values):
         line = super(PurchaseOrderLine, self).create(values)
