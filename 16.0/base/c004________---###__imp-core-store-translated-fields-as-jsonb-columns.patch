PR: https://github.com/odoo/odoo/pull/

From: ef00294e7189359c47638c4a71626f1937395edb
From: Chong Wang (cwg)
Date: 2022-09-15 20:37:50

Structural Changes: 14
Total Changes: 1294

[IMP] core: store translated fields as JSONB columns

Translated fields no longer use the model ir.translation.  Instead they store
all their values as JSON, and store them into JSONB columns in the model's
table.  The field's column value is either NULL or a JSON dict mapping language
codes to text (the field's value in the corresponding language), and must
contain an entry for key 'en_US' (as it is used as a fallback for all other
languages).  Empty text is allowed in translation values, but not NULL.

Here are examples for a field with translate=True:

    NULL
    {"en_US": "Foo"}
    {"en_US": "Foo", "fr_FR": "Bar", "nl_NL": "Baz"}
    {"en_US": "Foo", "fr_FR": "", "nl_NL": "Baz"}

Like before, writing False to the field makes it NULL, i.e., False in all
languages.  However, writing "" to the field makes its value empty in the
current language, but does not discard the values in the other languages.

Here are examples for a field with translate=xml_translate:

    NULL
    {"en_US": "<div>Foo<p>Bar</p></div>", "fr_FR": "<div>Fou<p>Barre</p></div>"}

Change for callable(translate) fields: one can now write any value in any
language on such a field.  The new value will be adapted in all languages, based
on the mapping of terms between languages in the old values.  Basically the
structure of the value must remain the same in all languages, like before.

Reading a translated field is now both simpler and faster than the former
implementation.  We fetch the value of the field in the current language by
coalescing its value with the 'en_US' value of the field:

    SELECT id, COALESCE(name->>'fr_FR', name->>'en_US') AS name ...

The raw cache of the field contains either None or a dict which is conceptually
a subset of the JSON value in database (except for missing languages).  For the
sake of simplicity, most cache operations deal with the dict and return the text
value in the current language.

Trigram indexes have been adapted to the new storing strategy, and should enable
to search in any language.  Before this change, only the source value of the
field ('en_US') could be indexed.

Computed stored translated fields are not supported by the framework, because of
the complexity of the computation itself: the field would need to be computed in
all active languages.  We chose to not provide any hook to compute a field in
all languages at once, and the framework always invokes a compute method once to
recompute it.

Code translations are no longer stored into the database.  They become static,
and are extracted from the PO files when needed.  The worker simply uses a cache
with extracted code translations for performance.  This is reasonable, since
fr_FR code translations for all modules takes around 2MB of memory, and the
cache can be shared among all registries in the worker.  Changing code
translations requires to update the corresponding PO file and reloading the
worker(s).

Performance summary:
 (+) reading 'model' translated fields is faster
 (+) reading 'model_terms' translated fields is much faster (no need to inject
     translations into the source value)
 (+) searching translated fields with operator 'ilike' is much faster when the
     field is indexed with 'trigram'
 (+) updating translated fields requires less ORM flushing
 (-) importing translations from PO files is 2x slower

Some extra fixes:
 - make field 'name' of ir.actions.actions translated; because of the PG
   inheritance, this is necessary to make the column definition consistent in
   all models that inherit from ir.actions.actions.
 - add some backend API for the web/website client for editing translations
 - move methods get_field_string() to model ir.model.fields
 - move _load_module_terms to model ir.module.module
 - adapt tests in test_impex, test_new_api
 - because env.lang is injected into SQL queries, its returned value is
   now guaranteed to correspond to a valid active language or None
 - remove wizard to insert missing translations (no longer makes sense)

task-id: 2081307

Co-authored-by: Fabien Pinckaers <fp@openerp.com>
Co-authored-by: Raphael Collet <rco@odoo.com>

================================= pseudo patch: =================================

--- a/odoo/addons/base/models/__init__.py
+++ b/odoo/addons/base/models/__init__.py
@@ -14,7 +14,6 @@ from . import ir_binary
 from . import ir_cron
 from . import ir_filters
 from . import ir_default
-from . import ir_translation
 from . import ir_exports
 from . import ir_rule
 from . import ir_config_parameter

--- a/odoo/addons/base/models/ir_actions.py
+++ b/odoo/addons/base/models/ir_actions.py
@@ -25,7 +25,7 @@ class IrActions(models.Model):
     _table = 'ir_actions'
     _order = 'name'
 
-    name = fields.Char(required=True)
+    name = fields.Char(string='Action Name', required=True, translate=True)
     type = fields.Char(string='Action Type', required=True)
     xml_id = fields.Char(compute='_compute_xml_id', string="External ID")
     help = fields.Html(string='Action Description',
@@ -240,7 +240,6 @@ class IrActionsActWindow(models.Model):
             fvg = self.env[act.res_model].get_view(act.search_view_id.id, 'search')
             act.search_view = str(fvg)
 
-    name = fields.Char(string='Action Name', translate=True)
     type = fields.Char(default="ir.actions.act_window")
     view_id = fields.Many2one('ir.ui.view', string='View Ref.', ondelete='set null')
     domain = fields.Char(string='Domain Value',
@@ -372,7 +371,6 @@ class IrActionsActUrl(models.Model):
     _inherit = 'ir.actions.actions'
     _order = 'name'
 
-    name = fields.Char(string='Action Name', translate=True)
     type = fields.Char(default='ir.actions.act_url')
     url = fields.Text(string='Action URL', required=True)
     target = fields.Selection([('new', 'New Window'), ('self', 'This Window')],
@@ -421,7 +419,6 @@ class IrActionsServer(models.Model):
 #  - Command: x2Many commands namespace
 # To return an action, assign: action = {...}\n\n\n\n"""
 
-    name = fields.Char(string='Action Name', translate=True)
     type = fields.Char(default='ir.actions.server')
     usage = fields.Selection([
         ('ir_actions_server', 'Server Action'),
@@ -842,7 +839,6 @@ class IrActionsActClient(models.Model):
     _table = 'ir_act_client'
     _order = 'name'
 
-    name = fields.Char(string='Action Name', translate=True)
     type = fields.Char(default='ir.actions.client')
 
     tag = fields.Char(string='Client action tag', required=True,

--- a/odoo/addons/base/models/ir_actions_report.py
+++ b/odoo/addons/base/models/ir_actions_report.py
@@ -91,7 +91,6 @@ class IrActionsReport(models.Model):
     _table = 'ir_act_report_xml'
     _order = 'name'
 
-    name = fields.Char(translate=True)
     type = fields.Char(default='ir.actions.report')
     binding_type = fields.Selection(default='report')
     model = fields.Char(required=True, string='Model Name')

--- a/odoo/addons/base/models/ir_cron.py
+++ b/odoo/addons/base/models/ir_cron.py
@@ -179,7 +179,7 @@ class ir_cron(models.Model):
     def _get_all_ready_jobs(cls, cr):
         """ Return a list of all jobs that are ready to be executed """
         cr.execute("""
-            SELECT *
+            SELECT *, cron_name->>'en_US' as cron_name
             FROM ir_cron
             WHERE active = true
               AND numbercall != 0
@@ -241,7 +241,7 @@ class ir_cron(models.Model):
         # Learn more: https://www.postgresql.org/docs/current/explicit-locking.html#LOCKING-ROWS
 
         query = """
-            SELECT *
+            SELECT *, cron_name->>'en_US' as cron_name
             FROM ir_cron
             WHERE active = true
               AND numbercall != 0

--- a/odoo/addons/base/models/ir_fields.py
+++ b/odoo/addons/base/models/ir_fields.py
@@ -8,7 +8,8 @@ import psycopg2
 import pytz
 
 from odoo import api, Command, fields, models, _
-from odoo.tools import ustr
+from odoo.tools import ustr, OrderedSet
+from odoo.tools.translate import code_translations, _lt
 
 REFERENCING_FIELDS = {None, 'id', '.id'}
 def only_ref_fields(record):
@@ -16,6 +17,13 @@ def only_ref_fields(record):
 def exclude_ref_fields(record):
     return {k: v for k, v in record.items() if k not in REFERENCING_FIELDS}
 
+# these lazy translations promise translations for ['yes', 'no', 'true', 'false']
+BOOLEAN_TRANSLATIONS = (
+    _lt('yes'),
+    _lt('no'),
+    _lt('true'),
+    _lt('false')
+)
 
 class ImportWarning(Warning):
     """ Used to send warnings upwards the stack during the import process """
@@ -190,8 +198,8 @@ class IrFieldsConverter(models.AbstractModel):
         # potentially broken casefolding? What about locales?
         trues = set(word.lower() for word in itertools.chain(
             [u'1', u"true", u"yes"], # don't use potentially translated values
-            self._get_translations(['code'], u"true"),
-            self._get_translations(['code'], u"yes"),
+            self._get_boolean_translations(u"true"),
+            self._get_boolean_translations(u"yes"),
         ))
         if value.lower() in trues:
             return True, []
@@ -199,8 +207,8 @@ class IrFieldsConverter(models.AbstractModel):
         # potentially broken casefolding? What about locales?
         falses = set(word.lower() for word in itertools.chain(
             [u'', u"0", u"false", u"no"],
-            self._get_translations(['code'], u"false"),
-            self._get_translations(['code'], u"no"),
+            self._get_boolean_translations(u"false"),
+            self._get_boolean_translations(u"no"),
         ))
         if value.lower() in falses:
             return False, []
@@ -296,17 +304,46 @@ class IrFieldsConverter(models.AbstractModel):
         return fields.Datetime.to_string(dt.astimezone(pytz.UTC)), []
 
     @api.model
-    def _get_translations(self, types, src):
-        types = tuple(types)
+    def _get_boolean_translations(self, src):
         # Cache translations so they don't have to be reloaded from scratch on
         # every row of the file
         tnx_cache = self._cr.cache.setdefault(self._name, {})
-        if tnx_cache.setdefault(types, {}) and src in tnx_cache[types]:
-            return tnx_cache[types][src]
+        if src in tnx_cache:
+            return tnx_cache[src]
 
-        Translations = self.env['ir.translation']
-        tnx = Translations.search([('type', 'in', types), ('src', '=', src)])
-        result = tnx_cache[types][src] = [t.value for t in tnx if t.value is not False]
+        values = OrderedSet()
+        for lang, __ in self.env['res.lang'].get_installed():
+            translations = code_translations.get_python_translations('base', lang)
+            if src in translations:
+                values.add(translations[src])
+
+        result = tnx_cache[src] = list(values)
+        return result
+
+    @api.model
+    def _get_selection_translations(self, field, src):
+        if not src:
+            return []
+        # Cache translations so they don't have to be reloaded from scratch on
+        # every row of the file
+        tnx_cache = self._cr.cache.setdefault(self._name, {})
+        if src in tnx_cache:
+            return tnx_cache[src]
+
+        values = OrderedSet()
+        self.env['ir.model.fields.selection'].flush_model()
+        query = """
+            SELECT s.name
+            FROM ir_model_fields_selection s
+            JOIN ir_model_fields f ON s.field_id = f.id
+            WHERE f.model = %s AND f.name = %s AND s.name->>'en_US' = %s
+        """
+        self.env.cr.execute(query, [field.model_name, field.name, src])
+        for (name,) in self.env.cr.fetchall():
+            name.pop('en_US')
+            values.update(name.values())
+
+        result = tnx_cache[src] = list(values)
         return result
 
     @api.model
@@ -317,7 +354,14 @@ class IrFieldsConverter(models.AbstractModel):
 
         for item, label in selection:
             label = ustr(label)
-            labels = [label] + self._get_translations(('selection', 'model', 'code'), label)
+            if callable(field.selection):
+                labels = [label]
+                for item2, label2 in field._description_selection(self.env):
+                    if item2 == item:
+                        labels.append(label2)
+                        break
+            else:
+                labels = [label] + self._get_selection_translations(field, label)
             # case insensitive comparaison of string to allow to set the value even if the given 'value' param is not
             # exactly (case sensitive) the same as one of the selection item.
             if value.lower() == str(item).lower() or any(value.lower() == label.lower() for label in labels):

--- a/odoo/addons/base/models/ir_filters.py
+++ b/odoo/addons/base/models/ir_filters.py
@@ -11,7 +11,7 @@ class IrFilters(models.Model):
     _description = 'Filters'
     _order = 'model_id, name, id desc'
 
-    name = fields.Char(string='Filter Name', translate=True, required=True)
+    name = fields.Char(string='Filter Name', required=True)
     user_id = fields.Many2one('res.users', string='User', ondelete='cascade',
                               help="The user this filter is private to. When left empty the filter is public "
                                    "and available to all users.")
@@ -28,7 +28,11 @@ class IrFilters(models.Model):
 
     @api.model
     def _list_all_models(self):
-        self._cr.execute("SELECT model, name FROM ir_model ORDER BY name")
+        lang = self.env.lang or 'en_US'
+        self._cr.execute(
+            "SELECT model, COALESCE(name->>%s, name->>'en_US') FROM ir_model ORDER BY 2",
+            [lang],
+        )
         return self._cr.fetchall()
 
     def copy(self, default=None):

--- a/odoo/addons/base/models/ir_http.py
+++ b/odoo/addons/base/models/ir_http.py
@@ -4,6 +4,7 @@
 #----------------------------------------------------------
 import base64
 import hashlib
+import json
 import logging
 import mimetypes
 import os
@@ -22,6 +23,7 @@ from odoo.exceptions import AccessDenied, AccessError, MissingError
 from odoo.http import request, Response, ROUTING_KEYS, Stream
 from odoo.service import security
 from odoo.tools import consteq, submap
+from odoo.tools.translate import code_translations
 from odoo.modules.module import get_resource_path, get_module_path
 
 _logger = logging.getLogger(__name__)
@@ -198,3 +200,45 @@ class IrHttp(models.AbstractModel):
     @api.autovacuum
     def _gc_sessions(self):
         http.root.session_store.vacuum()
+
+    @api.model
+    def get_translations_for_webclient(self, modules, lang):
+        if not modules:
+            modules = self.pool._init_modules
+        if not lang:
+            lang = self._context.get("lang")
+        langs = self.env['res.lang']._lang_get(lang)
+        lang_params = None
+        if langs:
+            lang_params = {
+                "name": langs.name,
+                "direction": langs.direction,
+                "date_format": langs.date_format,
+                "time_format": langs.time_format,
+                "grouping": langs.grouping,
+                "decimal_point": langs.decimal_point,
+                "thousands_sep": langs.thousands_sep,
+                "week_start": langs.week_start,
+            }
+            lang_params['week_start'] = int(lang_params['week_start'])
+            lang_params['code'] = lang
+
+        # Regional languages (ll_CC) must inherit/override their parent lang (ll), but this is
+        # done server-side when the language is loaded, so we only need to load the user's lang.
+        translations_per_module = {}
+        for module in modules:
+            translations_per_module[module] = code_translations.get_web_translations(module, lang)
+
+        return translations_per_module, lang_params
+
+    @api.model
+    @tools.ormcache('frozenset(modules)', 'lang')
+    def get_web_translations_hash(self, modules, lang):
+        translations, lang_params = self.get_translations_for_webclient(modules, lang)
+        translation_cache = {
+            'lang_parameters': lang_params,
+            'modules': translations,
+            'lang': lang,
+            'multi_lang': len(self.env['res.lang'].sudo().get_installed()) > 1,
+        }
+        return hashlib.sha1(json.dumps(translation_cache, sort_keys=True).encode()).hexdigest()

--- a/odoo/addons/base/models/ir_model.py
+++ b/odoo/addons/base/models/ir_model.py
@@ -11,6 +11,7 @@ from collections.abc import Mapping
 from operator import itemgetter
 
 from psycopg2 import sql
+from psycopg2.extras import Json
 
 from odoo import api, fields, models, tools, _, _lt, Command
 from odoo.exceptions import AccessError, UserError, ValidationError
@@ -101,29 +102,55 @@ def query_update(cr, table, values, selectors):
     return [row[0] for row in cr.fetchall()]
 
 
-def upsert(cr, table, cols, rows, conflict):
+def select_en(model, fnames, where, params):
+    """ Select the given columns from the given model's table, with the given WHERE clause.
+    Translated fields are returned in 'en_US'.
+    """
+    table = quote(model._table)
+    cols = ", ".join(
+        f"{quote(fname)}->>'en_US'" if model._fields[fname].translate else quote(fname)
+        for fname in fnames
+    )
+    query = f"SELECT {cols} FROM {table} WHERE {where}"
+    model.env.cr.execute(query, params)
+    return model.env.cr.fetchall()
+
+
+def upsert_en(model, fnames, rows, conflict):
     """ Insert or update the table with the given rows.
 
-    :param cr: database cursor
-    :param table: table name
-    :param cols: list of column names
+    :param model: recordset of the model to query
+    :param fnames: list of column names
     :param rows: list of tuples, where each tuple value corresponds to a column name
     :param conflict: list of column names to put into the ON CONFLICT clause
     :return: the ids of the inserted or updated rows
     """
-    query = """
-        INSERT INTO {table} ({cols}) VALUES {rows}
-        ON CONFLICT ({conflict}) DO UPDATE SET ({cols}) = ({excluded})
+    table = quote(model._table)
+    cols = ", ".join(quote(fname) for fname in fnames)
+    values = ", ".join("%s" for row in rows)
+    conf = ", ".join(conflict)
+    excluded = ", ".join(f"EXCLUDED.{quote(fname)}" for fname in fnames)
+    query = f"""
+        INSERT INTO {table} ({cols}) VALUES {values}
+        ON CONFLICT ({conf}) DO UPDATE SET ({cols}) = ({excluded})
         RETURNING id
-    """.format(
-        table=quote(table),
-        cols=", ".join(quote(col) for col in cols),
-        rows=", ".join("%s" for row in rows),
-        conflict=", ".join(conflict),
-        excluded=", ".join("EXCLUDED." + quote(col) for col in cols),
-    )
-    cr.execute(query, rows)
-    return [row[0] for row in cr.fetchall()]
+    """
+
+    # for translated fields, we can actually erase the json value, as
+    # translations will be reloaded after this
+    def identity(val):
+        return val
+
+    def jsonify(val):
+        return Json({'en_US': val}) if val is not None else val
+
+    wrappers = [(jsonify if model._fields[fname].translate else identity) for fname in fnames]
+    params = [
+        tuple(func(val) for func, val in zip(wrappers, row))
+        for row in rows
+    ]
+    model.env.cr.execute(query, params)
+    return [row[0] for row in model.env.cr.fetchall()]
 
 
 #
@@ -260,11 +287,6 @@ class IrModel(models.Model):
                     self._cr.execute(sql.SQL('DROP VIEW {}').format(sql.Identifier(table)))
                 elif kind == 'r':
                     self._cr.execute(sql.SQL('DROP TABLE {} CASCADE').format(sql.Identifier(table)))
-                    # discard all translations for this model
-                    self._cr.execute("""
-                        DELETE FROM ir_translation
-                        WHERE type IN ('model', 'model_terms') AND name LIKE %s
-                    """, [model.model + ',%'])
             else:
                 _logger.runbot('The model %s could not be dropped because it did not exist in the registry.', model.model)
         return True
@@ -357,21 +379,16 @@ class IrModel(models.Model):
         cols = list(unique(['model'] + list(rows[0])))
         expected = [tuple(row[col] for col in cols) for row in rows]
 
-        cr = self.env.cr
-        query = "SELECT {}, id FROM ir_model WHERE model IN %s".format(
-            ", ".join(quote(col) for col in cols)
-        )
-        cr.execute(query, [tuple(model_names)])
         model_ids = {}
         existing = {}
-        for row in cr.fetchall():
-            model_ids[row[0]] = row[-1]
-            existing[row[0]] = row[:-1]
+        for row in select_en(self, ['id'] + cols, "model IN %s", [tuple(model_names)]):
+            model_ids[row[1]] = row[0]
+            existing[row[1]] = row[1:]
 
         # create or update rows
         rows = [row for row in expected if existing.get(row[0]) != row]
         if rows:
-            ids = upsert(self.env.cr, self._table, cols, rows, ['model'])
+            ids = upsert_en(self, cols, rows, ['model'])
             for row, id_ in zip(rows, ids):
                 model_ids[row[0]] = id_
             self.pool.post_init(mark_modified, self.browse(ids), cols[1:])
@@ -417,7 +434,8 @@ class IrModel(models.Model):
                         Parent._inherit_children.discard(name)
         # add manual models
         cr = self.env.cr
-        cr.execute('SELECT * FROM ir_model WHERE state=%s', ['manual'])
+        # we cannot use self._fields to determine translated fields, as it has not been set up yet
+        cr.execute("SELECT *, name->>'en_US' AS name FROM ir_model WHERE state = 'manual'")
         for model_data in cr.dictfetchall():
             model_class = self._instanciate(model_data)
             Model = model_class._build_model(self.pool, cr)
@@ -725,12 +743,6 @@ class IrModelFields(models.Model):
                     tables_to_drop.add(rel_name)
             if field.state == 'manual' and is_model:
                 model._pop_field(field.name)
-            if field.translate:
-                # discard all translations for this field
-                self._cr.execute("""
-                    DELETE FROM ir_translation
-                    WHERE type IN ('model', 'model_terms') AND name=%s
-                """, ['%s,%s' % (field.model, field.name)])
 
         if tables_to_drop:
             # drop the relation tables that are not used by other fields
@@ -911,9 +923,12 @@ class IrModelFields(models.Model):
         # names of the models to patch
         patched_models = set()
 
+        # write callable(self._fields[fname].translate) means changing content
+        translate_only = self.env.lang not in (None, 'en_US') and all(self._fields[fname].translate is True for fname in vals)
+
         if vals and self:
             for item in self:
-                if item.state != 'manual':
+                if item.state != 'manual' and not translate_only:
                     raise UserError(_('Properties of base fields cannot be altered in this manner! '
                                       'Please modify them through Python code, '
                                       'preferably through a custom addon!'))
@@ -1041,20 +1056,16 @@ class IrModelFields(models.Model):
         cols = list(unique(['model', 'name'] + list(rows[0])))
         expected = [tuple(row[col] for col in cols) for row in rows]
 
-        query = "SELECT {}, id FROM ir_model_fields WHERE model IN %s".format(
-            ", ".join(quote(col) for col in cols),
-        )
-        cr.execute(query, [tuple(model_names)])
         field_ids = {}
         existing = {}
-        for row in cr.fetchall():
-            field_ids[row[:2]] = row[-1]
-            existing[row[:2]] = row[:-1]
+        for row in select_en(self, ['id'] + cols, "model IN %s", [tuple(model_names)]):
+            field_ids[row[1:3]] = row[0]
+            existing[row[1:3]] = row[1:]
 
         # create or update rows
         rows = [row for row in expected if existing.get(row[:2]) != row]
         if rows:
-            ids = upsert(cr, self._table, cols, rows, ['model', 'name'])
+            ids = upsert_en(self, cols, rows, ['model', 'name'])
             for row, id_ in zip(rows, ids):
                 field_ids[row[:2]] = id_
             self.pool.post_init(mark_modified, self.browse(ids), cols[2:])
@@ -1086,7 +1097,12 @@ class IrModelFields(models.Model):
     @tools.ormcache()
     def _all_manual_field_data(self):
         cr = self._cr
-        cr.execute("SELECT * FROM ir_model_fields WHERE state='manual'")
+        # we cannot use self._fields to determine translated fields, as it has not been set up yet
+        cr.execute("""
+            SELECT *, field_description->>'en_US' AS field_description, help->>'en_US' AS help
+            FROM ir_model_fields
+            WHERE state = 'manual'
+        """)
         result = defaultdict(dict)
         for row in cr.dictfetchall():
             result[row['model']][row['name']] = row
@@ -1168,6 +1184,42 @@ class IrModelFields(models.Model):
                 except Exception:
                     _logger.exception("Failed to load field %s.%s: skipped", model._name, field_data['name'])
 
+    @api.model
+    @tools.ormcache_context('model_name', keys=('lang',))
+    def get_field_string(self, model_name):
+        """ Return the translation of fields strings in the context's language.
+        Note that the result contains the available translations only.
+
+        :param model_name: the name of a model
+        :return: the model's fields' strings as a dictionary `{field_name: field_string}`
+        """
+        fields = self.sudo().search([('model', '=', model_name)])
+        return {field.name: field.field_description for field in fields}
+
+    @api.model
+    @tools.ormcache_context('model_name', keys=('lang',))
+    def get_field_help(self, model_name):
+        """ Return the translation of fields help in the context's language.
+        Note that the result contains the available translations only.
+
+        :param model_name: the name of a model
+        :return: the model's fields' help as a dictionary `{field_name: field_help}`
+        """
+        fields = self.sudo().search([('model', '=', model_name)])
+        return {field.name: field.help for field in fields}
+
+    @api.model
+    @tools.ormcache_context('model_name', 'field_name', keys=('lang',))
+    def get_field_selection(self, model_name, field_name):
+        """ Return the translation of a field's selection in the context's language.
+        Note that the result contains the available translations only.
+
+        :param model_name: the name of the field's model
+        :param field_name: the name of the field
+        :return: the fields' selection as a list
+        """
+        field = self._get(model_name, field_name)
+        return [(sel.value, sel.name) for sel in field.selection_ids]
 
 class IrModelSelection(models.Model):
     _name = 'ir.model.fields.selection'
@@ -1192,8 +1244,9 @@ class IrModelSelection(models.Model):
         return self._get_selection_data(field_id)
 
     def _get_selection_data(self, field_id):
+        # return selection as expected on registry (no translations)
         self._cr.execute("""
-            SELECT value, name
+            SELECT value, name->>'en_US'
             FROM ir_model_fields_selection
             WHERE field_id=%s
             ORDER BY sequence, id
@@ -1223,7 +1276,7 @@ class IrModelSelection(models.Model):
 
         cr = self.env.cr
         query = """
-            SELECT s.field_id, s.value, s.name, s.sequence
+            SELECT s.field_id, s.value, s.name->>'en_US', s.sequence
             FROM ir_model_fields_selection s, ir_model_fields f
             WHERE s.field_id = f.id AND f.model IN %s
         """
@@ -1234,7 +1287,7 @@ class IrModelSelection(models.Model):
         cols = ['field_id', 'value', 'name', 'sequence']
         rows = [key + val for key, val in expected.items() if existing.get(key) != val]
         if rows:
-            ids = upsert(cr, self._table, cols, rows, ['field_id', 'value'])
+            ids = upsert_en(self, cols, rows, ['field_id', 'value'])
             self.pool.post_init(mark_modified, self.browse(ids), cols[2:])
 
         # update their XML ids
@@ -1285,8 +1338,10 @@ class IrModelSelection(models.Model):
                                     cur_row['value'], model_name, field_name)
                     rows_to_remove.append(cur_row['id'])
             elif cur_row is None:
+                new_row['name'] = Json({'en_US': new_row['name']})
                 rows_to_insert.append(dict(new_row, field_id=field_id))
             elif any(new_row[key] != cur_row[key] for key in new_row):
+                new_row['name'] = Json({'en_US': new_row['name']})
                 rows_to_update.append(dict(new_row, id=cur_row['id']))
 
         if rows_to_insert:
@@ -1308,7 +1363,7 @@ class IrModelSelection(models.Model):
             a dict {field_name: {value: row_values}}.
         """
         query = """
-            SELECT s.*
+            SELECT s.*, s.name->>'en_US' AS name
             FROM ir_model_fields_selection s
             JOIN ir_model_fields f ON s.field_id=f.id
             WHERE f.model=%s and f.name=%s
@@ -1556,7 +1611,7 @@ class IrModelConstraint(models.Model):
             return
         assert type in ('f', 'u')
         cr = self._cr
-        query = """ SELECT c.id, type, definition, message
+        query = """ SELECT c.id, type, definition, message->>'en_US' as message
                     FROM ir_model_constraint c, ir_module_module m
                     WHERE c.module=m.id AND c.name=%s AND m.name=%s """
         cr.execute(query, (conname, module))
@@ -1572,8 +1627,7 @@ class IrModelConstraint(models.Model):
                                 (SELECT id FROM ir_model WHERE model=%s),
                                 %s, %s, %s)
                         RETURNING id"""
-            cr.execute(query,
-                (conname, self.env.uid, self.env.uid, module, model._name, type, definition, message))
+            cr.execute(query, (conname, self.env.uid, self.env.uid, module, model._name, type, definition, Json({'en_US': message})))
             return self.browse(cr.fetchone()[0])
 
         cons_id = cons.pop('id')
@@ -1582,7 +1636,7 @@ class IrModelConstraint(models.Model):
                         SET write_date=now() AT TIME ZONE 'UTC',
                             write_uid=%s, type=%s, definition=%s, message=%s
                         WHERE id=%s"""
-            cr.execute(query, (self.env.uid, type, definition, message, cons_id))
+            cr.execute(query, (self.env.uid, type, definition, Json({'en_US': message}), cons_id))
         return self.browse(cons_id)
 
     def _reflect_constraints(self, model_names):
@@ -1735,17 +1789,18 @@ class IrModelAccess(models.Model):
            :rtype: list
         """
         assert access_mode in ('read', 'write', 'create', 'unlink'), 'Invalid access mode'
-        self._cr.execute("""
-            SELECT c.name, g.name
+        lang = self.env.lang or 'en_US'
+        self._cr.execute(f"""
+            SELECT COALESCE(c.name->>%s, c.name->>'en_US'), COALESCE(g.name->>%s, g.name->>'en_US')
               FROM ir_model_access a
               JOIN ir_model m ON (a.model_id = m.id)
               JOIN res_groups g ON (a.group_id = g.id)
          LEFT JOIN ir_module_category c ON (c.id = g.category_id)
-             WHERE m.model = %%s
+             WHERE m.model = %s
                AND a.active = TRUE
-               AND a.perm_%s = TRUE
+               AND a.perm_{access_mode} = TRUE
           ORDER BY c.name, g.name NULLS LAST
-        """ % access_mode, [model_name])
+        """, [lang, lang, model_name])
         return [('%s/%s' % x) if x[0] else x[1] for x in self._cr.fetchall()]
 
     # The context parameter is useful when the method translates error messages.

--- a/odoo/addons/base/models/ir_module.py
+++ b/odoo/addons/base/models/ir_module.py
@@ -32,6 +32,7 @@ from odoo.osv import expression
 from odoo.tools.parse_version import parse_version
 from odoo.tools.misc import topological_sort
 from odoo.http import request
+from odoo.modules import get_module_path, get_module_resource
 
 _logger = logging.getLogger(__name__)
 
@@ -947,7 +948,7 @@ class Module(models.Model):
             for mod in update_mods
         }
         mod_names = topological_sort(mod_dict)
-        self.env['ir.translation']._load_module_terms(mod_names, filter_lang, overwrite)
+        self.env['ir.module.module']._load_module_terms(mod_names, filter_lang, overwrite)
 
     def _check(self):
         for module in self:
@@ -1024,6 +1025,50 @@ class Module(models.Model):
 
         return super(Module, self).search_panel_select_range(field_name, **kwargs)
 
+    @api.model
+    def _load_module_terms(self, modules, langs, overwrite=False):
+        """ Load PO files of the given modules for the given languages. """
+        # load i18n files
+        for module_name in modules:
+            modpath = get_module_path(module_name)
+            if not modpath:
+                continue
+            for lang in langs:
+                lang_code = tools.get_iso_codes(lang)
+                lang_overwrite = overwrite
+                base_lang_code = None
+                if '_' in lang_code:
+                    base_lang_code = lang_code.split('_')[0]
+
+                # Step 1: for sub-languages, load base language first (e.g. es_CL.po is loaded over es.po)
+                if base_lang_code:
+                    base_trans_file = get_module_resource(module_name, 'i18n', base_lang_code + '.po')
+                    if base_trans_file:
+                        _logger.info('module %s: loading base translation file %s for language %s', module_name, base_lang_code, lang)
+                        tools.trans_load(self._cr, base_trans_file, lang, verbose=False, overwrite=lang_overwrite)
+                        lang_overwrite = True  # make sure the requested translation will override the base terms later
+
+                    # i18n_extra folder is for additional translations handle manually (eg: for l10n_be)
+                    base_trans_extra_file = get_module_resource(module_name, 'i18n_extra', base_lang_code + '.po')
+                    if base_trans_extra_file:
+                        _logger.info('module %s: loading extra base translation file %s for language %s', module_name, base_lang_code, lang)
+                        tools.trans_load(self._cr, base_trans_extra_file, lang, verbose=False, overwrite=lang_overwrite)
+                        lang_overwrite = True  # make sure the requested translation will override the base terms later
+
+                # Step 2: then load the main translation file, possibly overriding the terms coming from the base language
+                trans_file = get_module_resource(module_name, 'i18n', lang_code + '.po')
+                if trans_file:
+                    _logger.info('module %s: loading translation file (%s) for language %s', module_name, lang_code, lang)
+                    tools.trans_load(self._cr, trans_file, lang, verbose=False, overwrite=lang_overwrite)
+                elif lang_code != 'en_US':
+                    _logger.info('module %s: no translation for language %s', module_name, lang_code)
+
+                trans_extra_file = get_module_resource(module_name, 'i18n_extra', lang_code + '.po')
+                if trans_extra_file:
+                    _logger.info('module %s: loading extra translation file (%s) for language %s', module_name, lang_code, lang)
+                    tools.trans_load(self._cr, trans_extra_file, lang, verbose=False, overwrite=lang_overwrite)
+        return True
+
 
 DEP_STATES = STATES + [('unknown', 'Unknown')]
 

--- a/odoo/addons/base/models/ir_translation.py
+++ b/None
@@ -1,927 +0,0 @@
-# -*- coding: utf-8 -*-
-# Part of Odoo. See LICENSE file for full copyright and licensing details.
-import hashlib
-import itertools
-import json
-import logging
-import operator
-from collections import defaultdict
-from difflib import get_close_matches
-
-from odoo import api, fields, models, tools, SUPERUSER_ID, _
-from odoo.exceptions import AccessError, UserError, ValidationError
-from odoo.modules import get_module_path, get_module_resource
-
-_logger = logging.getLogger(__name__)
-
-TRANSLATION_TYPE = [
-    ('model', 'Model Field'),
-    ('model_terms', 'Structured Model Field'),
-    ('code', 'Code'),
-]
-
-
-class IrTranslationImport(object):
-    """ Temporary cursor for optimizing mass insert into model 'ir.translation'.
-
-    Open it (attached to a sql cursor), feed it with translation data and
-    finish() it in order to insert multiple translations in a batch.
-    """
-    _table = 'tmp_ir_translation_import'
-
-    def __init__(self, cr, overwrite=False):
-        """ Store some values, and also create a temporary SQL table to accept
-        the data.
-
-        :param model: the model to insert the data into (as a recordset)
-        """
-        self._cr = cr
-        self._model_table = "ir_translation"
-        self._overwrite = overwrite
-        self._debug = False
-        self._rows = []
-
-        # Note that Postgres will NOT inherit the constraints or indexes
-        # of ir_translation, so this copy will be much faster.
-        query = """ CREATE TEMP TABLE %s (
-                        imd_model VARCHAR(64),
-                        imd_name VARCHAR(128),
-                        noupdate BOOLEAN
-                    ) INHERITS (%s) """ % (self._table, self._model_table)
-        self._cr.execute(query)
-
-    def push(self, trans_dict):
-        """ Feed a translation, as a dictionary, into the cursor """
-        params = dict(trans_dict, state="translated")
-
-        self._rows.append((params['name'], params['lang'], params['res_id'],
-                           params['src'], params['type'], params['imd_model'],
-                           params['module'], params['imd_name'], params['value'],
-                           params['state'], params['comments']))
-
-    def finish(self):
-        """ Transfer the data from the temp table to ir.translation """
-        cr = self._cr
-
-        # Step 0: insert rows in batch
-        query = """ INSERT INTO %s (name, lang, res_id, src, type, imd_model,
-                                    module, imd_name, value, state, comments)
-                    VALUES """ % self._table
-        for rows in cr.split_for_in_conditions(self._rows):
-            cr.execute(query + ", ".join(["%s"] * len(rows)), rows)
-
-        _logger.debug("ir.translation.cursor: We have %d entries to process", len(self._rows))
-
-        # Step 1: resolve ir.model.data references to res_ids
-        cr.execute(""" UPDATE %s AS ti
-                          SET res_id = imd.res_id,
-                              noupdate = imd.noupdate
-                       FROM ir_model_data AS imd
-                       WHERE ti.res_id IS NULL
-                       AND ti.module IS NOT NULL AND ti.imd_name IS NOT NULL
-                       AND ti.module = imd.module AND ti.imd_name = imd.name
-                       AND ti.imd_model = imd.model; """ % self._table)
-
-        if self._debug:
-            cr.execute(""" SELECT module, imd_name, imd_model FROM %s
-                           WHERE res_id IS NULL AND module IS NOT NULL """ % self._table)
-            for row in cr.fetchall():
-                _logger.info("ir.translation.cursor: missing res_id for %s.%s <%s> ", *row)
-
-        # Records w/o res_id must _not_ be inserted into our db, because they are
-        # referencing non-existent data.
-        cr.execute("DELETE FROM %s WHERE res_id IS NULL AND module IS NOT NULL" % self._table)
-
-        count = 0
-        # Step 2: insert new or upsert non-noupdate translations
-        if self._overwrite:
-            cr.execute(""" INSERT INTO %s(name, lang, res_id, src, type, value, module, state, comments)
-                           SELECT name, lang, res_id, src, type, value, module, state, comments
-                           FROM %s
-                           WHERE type = 'code'
-                           AND noupdate IS NOT TRUE
-                           ON CONFLICT (type, lang, md5(src)) WHERE type = 'code'
-                            DO UPDATE SET (name, lang, res_id, src, type, value, module, state, comments) = (EXCLUDED.name, EXCLUDED.lang, EXCLUDED.res_id, EXCLUDED.src, EXCLUDED.type, EXCLUDED.value, EXCLUDED.module, EXCLUDED.state,
-                                                                                                             CASE WHEN %s.comments = 'openerp-web' THEN 'openerp-web' ELSE EXCLUDED.comments END
-                                                                                                            )
-                            WHERE EXCLUDED.value IS NOT NULL AND EXCLUDED.value != '';
-                       """ % (self._model_table, self._table, self._model_table))
-            count += cr.rowcount
-            cr.execute(""" INSERT INTO %s(name, lang, res_id, src, type, value, module, state, comments)
-                           SELECT name, lang, res_id, src, type, value, module, state, comments
-                           FROM %s
-                           WHERE type = 'model'
-                           AND noupdate IS NOT TRUE
-                           ON CONFLICT (type, lang, name, res_id) WHERE type = 'model'
-                            DO UPDATE SET (name, lang, res_id, src, type, value, module, state, comments) = (EXCLUDED.name, EXCLUDED.lang, EXCLUDED.res_id, EXCLUDED.src, EXCLUDED.type, EXCLUDED.value, EXCLUDED.module, EXCLUDED.state, EXCLUDED.comments)
-                            WHERE EXCLUDED.value IS NOT NULL AND EXCLUDED.value != '';
-                       """ % (self._model_table, self._table))
-            count += cr.rowcount
-
-            cr.execute(""" INSERT INTO %s(name, lang, res_id, src, type, value, module, state, comments)
-                           SELECT name, lang, res_id, src, type, value, module, state, comments
-                           FROM %s
-                           WHERE type = 'model_terms'
-                           AND noupdate IS NOT TRUE
-                           ON CONFLICT (type, name, lang, res_id, md5(src))
-                            DO UPDATE SET (name, lang, res_id, src, type, value, module, state, comments) = (EXCLUDED.name, EXCLUDED.lang, EXCLUDED.res_id, EXCLUDED.src, EXCLUDED.type, EXCLUDED.value, EXCLUDED.module, EXCLUDED.state, EXCLUDED.comments)
-                            WHERE EXCLUDED.value IS NOT NULL AND EXCLUDED.value != '';
-                       """ % (self._model_table, self._table))
-            count += cr.rowcount
-        cr.execute(""" INSERT INTO %s(name, lang, res_id, src, type, value, module, state, comments)
-                       SELECT name, lang, res_id, src, type, value, module, state, comments
-                       FROM %s
-                       WHERE %%s OR noupdate is true
-                       ON CONFLICT DO NOTHING;
-                   """ % (self._model_table, self._table), [not self._overwrite])
-        count += cr.rowcount
-
-        if self._debug:
-            cr.execute("SELECT COUNT(*) FROM ONLY %s" % self._model_table)
-            total = cr.fetchone()[0]
-            _logger.debug("ir.translation.cursor: %d entries now in ir.translation, %d common entries with tmp", total, count)
-
-        # Step 3: cleanup
-        cr.execute("DROP TABLE %s" % self._table)
-        self._rows.clear()
-        return True
-
-
-class IrTranslation(models.Model):
-    _name = "ir.translation"
-    _description = 'Translation'
-    _log_access = False
-
-    name = fields.Char(string='Translated field', required=True)
-    res_id = fields.Integer(string='Record ID', index=True)
-    lang = fields.Selection(selection='_get_languages', string='Language', validate=False)
-    type = fields.Selection(TRANSLATION_TYPE, string='Type', index=True)
-    src = fields.Text(string='Internal Source')  # stored in database, kept for backward compatibility
-    value = fields.Text(string='Translation Value')
-    module = fields.Char(index=True, help="Module this term belongs to")
-
-    state = fields.Selection([('to_translate', 'To Translate'),
-                              ('inprogress', 'Translation in Progress'),
-                              ('translated', 'Translated')],
-                             string="Status", default='to_translate',
-                             help="Automatically set to let administators find new terms that might need to be translated")
-
-    # aka gettext extracted-comments - we use them to flag openerp-web translation
-    # cfr: http://www.gnu.org/savannah-checkouts/gnu/gettext/manual/html_node/PO-Files.html
-    comments = fields.Text(string='Translation comments', index=True)
-
-    _sql_constraints = [
-        ('lang_fkey_res_lang', 'FOREIGN KEY(lang) REFERENCES res_lang(code)',
-         'Language code of translation item must be among known languages'),
-    ]
-
-    @api.model
-    def _get_languages(self):
-        return self.env['res.lang'].get_installed()
-
-    def _auto_init(self):
-        res = super(IrTranslation, self)._auto_init()
-        # Add separate md5 index on src (no size limit on values, and good performance).
-        tools.create_index(self._cr, 'ir_translation_src_md5', self._table, ['md5(src)'])
-        # Cover 'model_terms' type
-        tools.create_unique_index(self._cr, 'ir_translation_unique', self._table,
-                                  ['type', 'name', 'lang', 'res_id', 'md5(src)'])
-        if not tools.index_exists(self._cr, 'ir_translation_code_unique'):
-            self._cr.execute("CREATE UNIQUE INDEX ir_translation_code_unique ON ir_translation (type, lang, md5(src)) WHERE type = 'code'")
-        if not tools.index_exists(self._cr, 'ir_translation_model_unique'):
-            self._cr.execute("CREATE UNIQUE INDEX ir_translation_model_unique ON ir_translation (type, lang, name, res_id) WHERE type = 'model'")
-
-        return res
-
-    @api.model
-    def _get_ids(self, name, tt, lang, ids):
-        """ Return the translations of records.
-
-        :param name: a string defined as "<model_name>,<field_name>"
-        :param tt: the type of translation (should always be "model")
-        :param lang: the language code
-        :param ids: the ids of the given records
-        """
-        translations = dict.fromkeys(ids, False)
-        if ids:
-            self._cr.execute("""SELECT res_id, value FROM ir_translation
-                                WHERE lang=%s AND type=%s AND name=%s AND res_id IN %s""",
-                             (lang, tt, name, tuple(ids)))
-            for res_id, value in self._cr.fetchall():
-                translations[res_id] = value
-        return translations
-
-    CACHED_MODELS = {'ir.model.fields', 'ir.ui.view'}
-
-    def _modified_model(self, model_name):
-        """ Invalidate the ormcache if necessary, depending on ``model_name``.
-        This should be called when modifying translations of type 'model'.
-        """
-        if model_name in self.CACHED_MODELS:
-            self.clear_caches()
-
-    def _modified(self):
-        """ Invalidate the ormcache if necessary, depending on the translations ``self``. """
-        # DLE P63: test_views.py
-        for trans in self:
-            if trans.type == 'model_terms' and trans.res_id:
-                model, field = trans.name.split(',')
-                if model in self.env:
-                    model = self.env[model]
-                    if field in model._fields:
-                        field = model._fields[field]
-                        record = model.browse(trans.res_id)
-                        record.modified([field.name])
-        for trans in self:
-            if (trans.type != 'model' or
-               (trans.name.split(',')[0] in self.CACHED_MODELS) or
-               (trans.comments and 'openerp-web' in trans.comments)):  # clear get_web_trans_hash
-                        self.clear_caches()
-                        break
-
-    @api.model
-    def _set_ids(self, name, tt, lang, ids, value, src=None):
-        """ Update the translations of records.
-
-        :param name: a string defined as "<model_name>,<field_name>"
-        :param tt: the type of translation (should always be "model")
-        :param lang: the language code
-        :param ids: the ids of the given records
-        :param value: the value of the translation
-        :param src: the source of the translation
-        """
-        self._modified_model(name.split(',')[0])
-        self.flush_model()
-
-        # update existing translations
-        self._cr.execute("""UPDATE ir_translation
-                            SET value=%s, src=%s, state=%s
-                            WHERE lang=%s AND type=%s AND name=%s AND res_id IN %s
-                            RETURNING res_id""",
-                         (value, src, 'translated', lang, tt, name, tuple(ids)))
-        existing_ids = [row[0] for row in self._cr.fetchall()]
-        self.invalidate_model(['value', 'src', 'state'])
-
-        # create missing translations
-        self.sudo().create([{
-                'lang': lang,
-                'type': tt,
-                'name': name,
-                'res_id': res_id,
-                'value': value,
-                'src': src,
-                'state': 'translated',
-            }
-            for res_id in set(ids) - set(existing_ids)
-        ])
-        return len(ids)
-
-    def _set_source(self, name, ids, src):
-        """ Update the translation source of records.
-
-        :param name: a string defined as "<model_name>,<field_name>"
-        :param ids: the ids of the given records
-        :param src: the source of the translation
-        """
-        self.flush_model()
-        self._cr.execute("""UPDATE ir_translation
-                            SET src=%s
-                            WHERE type=%s AND name=%s AND res_id IN %s
-                            RETURNING id""",
-                         (src, 'model', name, tuple(ids)))
-        existing_ids = [row[0] for row in self._cr.fetchall()]
-        # invalidate src for updated translations
-        self.browse(existing_ids).invalidate_recordset(['src'])
-
-    @api.model
-    def _get_source_query(self, name, types, lang, source, res_id):
-        self.flush_model()
-        if source:
-            # Note: the extra test on md5(src) is a hint for postgres to use the
-            # index ir_translation_src_md5
-            query = """SELECT value FROM ir_translation
-                       WHERE lang=%s AND type in %s AND src=%s AND md5(src)=md5(%s)"""
-            source = tools.ustr(source)
-            params = (lang or '', types, source, source)
-            if res_id:
-                query += " AND res_id in %s"
-                params += (res_id,)
-            if name:
-                query += " AND name=%s"
-                params += (tools.ustr(name),)
-        else:
-            query = """ SELECT value FROM ir_translation
-                        WHERE lang=%s AND type in %s AND name=%s """
-            params = (lang or '', types, tools.ustr(name))
-
-        return (query, params)
-
-    @tools.ormcache('name', 'types', 'lang', 'source', 'res_id')
-    def __get_source(self, name, types, lang, source, res_id):
-        # res_id is a tuple or None, otherwise ormcache cannot cache it!
-        query, params = self._get_source_query(name, types, lang, source, res_id)
-        self._cr.execute(query, params)
-        res = self._cr.fetchone()
-        trad = res and res[0] or u''
-        if source and not trad:
-            return tools.ustr(source)
-        return trad
-
-    @api.model
-    def _get_source(self, name, types, lang, source=None, res_id=None):
-        """ Return the translation for the given combination of ``name``,
-        ``type``, ``language`` and ``source``. All values passed to this method
-        should be unicode (not byte strings), especially ``source``.
-
-        :param name: identification of the term to translate, such as field name (optional if source is passed)
-        :param types: single string defining type of term to translate (see ``type`` field on ir.translation), or sequence of allowed types (strings)
-        :param lang: language code of the desired translation
-        :param source: optional source term to translate (should be unicode)
-        :param res_id: optional resource id or a list of ids to translate (if used, ``source`` should be set)
-        :rtype: unicode
-        :return: the request translation, or an empty unicode string if no translation was
-                 found and `source` was not passed
-        """
-        # FIXME: should assert that `source` is unicode and fix all callers to
-        # always pass unicode so we can remove the string encoding/decoding.
-        if not lang:
-            return tools.ustr(source or '')
-        if isinstance(types, str):
-            types = (types,)
-        if res_id:
-            if isinstance(res_id, int):
-                res_id = (res_id,)
-            else:
-                res_id = tuple(res_id)
-        return self.__get_source(name, types, lang, source, res_id)
-
-    @api.model
-    def _get_terms_query(self, field, records):
-        """ Utility function that makes the query for field terms. """
-        self.flush_model()
-        query = """ SELECT * FROM ir_translation
-                    WHERE lang=%s AND type=%s AND name=%s AND res_id IN %s """
-        name = "%s,%s" % (field.model_name, field.name)
-        params = (records.env.lang, 'model_terms', name, tuple(records.ids))
-        return query, params
-
-    @api.model
-    def _get_terms_mapping(self, field, records):
-        """ Return a function mapping a ir_translation row (dict) to a value.
-        This method is called before querying the database for translations.
-        """
-        return lambda data: data['value']
-
-    @api.model
-    def _get_terms_translations(self, field, records):
-        """ Return the terms and translations of a given `field` on `records`.
-
-        :return: {record_id: {source: value}}
-        """
-        result = {rid: {} for rid in records.ids}
-        if records:
-            map_trans = self._get_terms_mapping(field, records)
-            query, params = self._get_terms_query(field, records)
-            self._cr.execute(query, params)
-            for data in self._cr.dictfetchall():
-                result[data['res_id']][data['src']] = map_trans(data)
-        return result
-
-    @api.model
-    def _sync_terms_translations(self, field, records):
-        """ Synchronize the translations to the terms to translate, after the
-        English value of a field is modified. The algorithm tries to match
-        existing translations to the terms to translate, provided the distance
-        between modified strings is not too large. It allows to not retranslate
-        data where a typo has been fixed in the English value.
-        """
-        if not callable(field.translate):
-            return
-
-        Translation = self.env['ir.translation']
-        outdated = Translation
-        discarded = Translation
-
-        for record in records:
-            # get field value and terms to translate
-            value = record[field.name]
-            terms = set(field.get_trans_terms(value))
-            translations = Translation.search([
-                ('type', '=', 'model_terms'),
-                ('name', '=', "%s,%s" % (field.model_name, field.name)),
-                ('res_id', '=', record.id),
-            ])
-
-            if not terms:
-                # discard all translations for that field
-                discarded += translations
-                continue
-
-            # remap existing translations on terms when possible; each term
-            # should be translated at most once per language
-            done = set()                # {(src, lang), ...}
-            translations_to_match = []
-
-            for translation in translations:
-                if not translation.value:
-                    discarded += translation
-                    # consider it done to avoid being matched against another term
-                    done.add((translation.src, translation.lang))
-                elif translation.src in terms:
-                    done.add((translation.src, translation.lang))
-                else:
-                    translations_to_match.append(translation)
-
-            if translations_to_match:
-                text2term = {field.get_text_content(term): term for term in terms}
-            for translation in translations_to_match:
-                # match the terms without formatting elements
-                src_text = field.get_text_content(translation.src)
-                matches = get_close_matches(src_text, text2term, 1, 0.9)
-                src = text2term[matches[0]] if matches else None
-                if not src:
-                    outdated += translation
-                elif (src, translation.lang) in done:
-                    discarded += translation
-                else:
-                    vals = {'src': src, 'state': translation.state}
-                    if translation.lang == records.env.lang:
-                        vals['value'] = src
-                    translation.write(vals)
-                    done.add((src, translation.lang))
-
-        # process outdated and discarded translations
-        outdated.write({'state': 'to_translate'})
-
-        if discarded:
-            # delete in SQL to avoid invalidating the whole cache
-            discarded._modified()
-            discarded.modified(self._fields)
-            discarded.flush_recordset()
-            discarded.invalidate_recordset()
-            self.env.cr.execute("DELETE FROM ir_translation WHERE id IN %s", [discarded._ids])
-
-    @api.model
-    @tools.ormcache_context('model_name', keys=('lang',))
-    def get_field_string(self, model_name):
-        """ Return the translation of fields strings in the context's language.
-        Note that the result contains the available translations only.
-
-        :param model_name: the name of a model
-        :return: the model's fields' strings as a dictionary `{field_name: field_string}`
-        """
-        fields = self.env['ir.model.fields'].sudo().search([('model', '=', model_name)])
-        return {field.name: field.field_description for field in fields}
-
-    @api.model
-    @tools.ormcache_context('model_name', keys=('lang',))
-    def get_field_help(self, model_name):
-        """ Return the translation of fields help in the context's language.
-        Note that the result contains the available translations only.
-
-        :param model_name: the name of a model
-        :return: the model's fields' help as a dictionary `{field_name: field_help}`
-        """
-        fields = self.env['ir.model.fields'].sudo().search([('model', '=', model_name)])
-        return {field.name: field.help for field in fields}
-
-    @api.model
-    @tools.ormcache_context('model_name', 'field_name', keys=('lang',))
-    def get_field_selection(self, model_name, field_name):
-        """ Return the translation of a field's selection in the context's language.
-        Note that the result contains the available translations only.
-
-        :param model_name: the name of the field's model
-        :param field_name: the name of the field
-        :return: the fields' selection as a list
-        """
-        field = self.env['ir.model.fields']._get(model_name, field_name)
-        return [(sel.value, sel.name) for sel in field.selection_ids]
-
-    def check(self, mode):
-        """ Check access rights of operation ``mode`` on ``self`` for the
-        current user. Raise an AccessError in case conditions are not met.
-        """
-        if self.env.is_superuser():
-            return
-
-        # collect translated field records (model_ids) and other translations
-        trans_ids = []
-        model_ids = defaultdict(set)
-        model_fields = defaultdict(set)
-        for trans in self:
-            if trans.type in ('model', 'model_terms'):
-                mname, fname = trans.name.split(',')
-                model_ids[mname].add(trans.res_id)
-                model_fields[mname].add(fname)
-            else:
-                trans_ids.append(trans.id)
-
-        # check for regular access rights on other translations
-        if trans_ids:
-            records = self.browse(trans_ids)
-            records.check_access_rights(mode)
-            records.check_access_rule(mode)
-
-        # check for read/write access on translated field records
-        fmode = 'read' if mode == 'read' else 'write'
-        for mname, ids in model_ids.items():
-            records = self.env[mname].browse(ids).exists()
-            records.check_access_rights(fmode)
-            records.check_field_access_rights(fmode, model_fields[mname])
-            if mode == 'create' and set(records._ids) != ids:
-                raise ValidationError(_("Creating translation on non existing records"))
-            if not records:
-                continue
-            records.check_access_rule(fmode)
-
-    @api.constrains('type', 'name', 'value')
-    def _check_value(self):
-        for trans in self.with_context(lang=None):
-            if trans.type == 'model' and trans.value:
-                mname, fname = trans.name.split(',')
-                record = trans.env[mname].browse(trans.res_id)
-                field = record._fields[fname]
-                if callable(field.translate):
-                    src = trans.src
-                    val = trans.value.strip()
-                    # check whether applying (src -> val) then (val -> src)
-                    # gives the original value back
-                    value0 = field.translate(lambda term: None, record[fname])
-                    value1 = field.translate({src: val}.get, value0)
-                    # don't check the reverse if no translation happened
-                    if value0 == value1:
-                        continue
-                    value2 = field.translate({val: src}.get, value1)
-                    if value2 != value0:
-                        raise ValidationError(_("Translation is not valid:\n%s", val))
-
-    @api.model_create_multi
-    def create(self, vals_list):
-        records = super(IrTranslation, self.sudo()).create(vals_list).with_env(self.env)
-        records.check('create')
-        records._modified()
-        # DLE P62: `test_translate.py`, `test_sync`
-        self.env.flush_all()
-        return records
-
-    def write(self, vals):
-        if vals.get('value'):
-            vals.setdefault('state', 'translated')
-        elif vals.get('src') or not vals.get('value', True):
-            vals.setdefault('state', 'to_translate')
-        self.check('write')
-        result = super(IrTranslation, self.sudo()).write(vals)
-        self.check('write')
-        self._modified()
-        # DLE P62: `test_translate.py`, `test_sync`
-        # when calling `flush` with a field list, if there is no value for one of these fields,
-        # the flush to database is not done.
-        # this causes issues when changing the src/value of a translation, as when we read, we ask the flush,
-        # but its not really the field which is in the towrite values, but its translation
-        self.env.flush_all()
-        return result
-
-    def unlink(self):
-        self.check('unlink')
-        self._modified()
-        return super(IrTranslation, self.sudo()).unlink()
-
-    @api.model
-    def _search(self, args, offset=0, limit=None, order=None, count=False, access_rights_uid=None):
-        # DLE P67, `test_new_fields.py`, `test_80_copy`
-        # When assigning a translation to a field
-        # e.g. email.with_context(lang='fr_FR').label = "bonjour"
-        # and then search on translations for this translation, must flush as the translation has not yet been written in database
-        if any(field.translate for field in self.env.cache.get_dirty_fields()):
-            self.env.flush_all()
-        return super(IrTranslation, self)._search(args, offset=offset, limit=limit, order=order, count=count, access_rights_uid=access_rights_uid)
-
-    @api.model
-    def insert_missing(self, field, records):
-        """ Insert missing translations for `field` on `records`. """
-        self.flush_model()
-        records = records.with_context(lang=None)
-        external_ids = records.get_external_id()  # if no xml_id, empty string
-        if callable(field.translate):
-            # insert missing translations for each term in src
-            query = """ INSERT INTO ir_translation (lang, type, name, res_id, src, value, module, state)
-                        SELECT l.code, 'model_terms', %(name)s, %(res_id)s, %(src)s, '', %(module)s, 'to_translate'
-                        FROM res_lang l
-                        WHERE l.active AND NOT EXISTS (
-                            SELECT 1 FROM ir_translation
-                            WHERE lang=l.code AND type='model' AND name=%(name)s AND res_id=%(res_id)s AND src=%(src)s
-                        )
-                        ON CONFLICT DO NOTHING;
-                    """
-            for record in records:
-                module = external_ids[record.id].split('.')[0]
-                src = record[field.name] or None
-                for term in set(field.get_trans_terms(src)):
-                    self._cr.execute(query, {
-                        'name': "%s,%s" % (field.model_name, field.name),
-                        'res_id': record.id,
-                        'src': term,
-                        'module': module
-                    })
-        else:
-            # insert missing translations for src
-            query = """ INSERT INTO ir_translation (lang, type, name, res_id, src, value, module, state)
-                        SELECT l.code, 'model', %(name)s, %(res_id)s, %(src)s, '', %(module)s, 'to_translate'
-                        FROM res_lang l
-                        WHERE l.active AND NOT EXISTS (
-                            SELECT 1 FROM ir_translation
-                            WHERE lang=l.code AND type='model' AND name=%(name)s AND res_id=%(res_id)s
-                        );
-
-                        DELETE FROM ir_translation dup
-                        WHERE type='model' AND name=%(name)s AND res_id=%(res_id)s
-                            AND dup.id NOT IN (SELECT MAX(t.id)
-                                       FROM ir_translation t
-                                       WHERE t.lang=dup.lang AND type='model' AND name=%(name)s AND res_id=%(res_id)s
-                            );
-
-                        UPDATE ir_translation SET src=%(src)s
-                        WHERE type='model' AND name=%(name)s AND res_id=%(res_id)s;
-                    """
-            for record in records:
-                module = external_ids[record.id].split('.')[0]
-                self._cr.execute(query, {
-                    'name': "%s,%s" % (field.model_name, field.name),
-                    'res_id': record.id,
-                    'src': record[field.name] or None,
-                    'module': module
-                })
-        self._modified_model(field.model_name)
-
-    @api.model
-    def _upsert_translations(self, vals_list):
-        """ Insert or update translations of type 'model' or 'model_terms'.
-
-            This method is used for creations of translations where the given
-            ``vals_list`` is trusted to be the right values and potential
-            conflicts should be updated to the new given value.
-            Mandatory values: name, lang, res_id, src, type
-            The other keys are ignored during update if not present
-        """
-        self.flush_model()
-        rows_by_type = defaultdict(list)
-        for vals in vals_list:
-            rows_by_type[vals['type']].append((
-                vals['name'], vals['lang'], vals['res_id'], vals['src'] or '', vals['type'],
-                vals.get('module'), vals['value'] or '', vals.get('state'), vals.get('comments'),
-            ))
-
-        if rows_by_type['model']:
-            query = """
-                INSERT INTO ir_translation (name, lang, res_id, src, type,
-                                            module, value, state, comments)
-                VALUES {}
-                ON CONFLICT (type, lang, name, res_id) WHERE type='model'
-                DO UPDATE SET (name, lang, res_id, src, type, value, module, state, comments) =
-                    (EXCLUDED.name, EXCLUDED.lang, EXCLUDED.res_id, EXCLUDED.src, EXCLUDED.type,
-                     EXCLUDED.value,
-                     COALESCE(EXCLUDED.module, ir_translation.module),
-                     COALESCE(EXCLUDED.state, ir_translation.state),
-                     COALESCE(EXCLUDED.comments, ir_translation.comments))
-                WHERE EXCLUDED.value IS NOT NULL AND EXCLUDED.value != '';
-            """.format(", ".join(["%s"] * len(rows_by_type['model'])))
-            self.env.cr.execute(query, rows_by_type['model'])
-
-        if rows_by_type['model_terms']:
-            query = """
-                INSERT INTO ir_translation (name, lang, res_id, src, type,
-                                            module, value, state, comments)
-                VALUES {}
-                ON CONFLICT (type, name, lang, res_id, md5(src))
-                DO UPDATE SET (name, lang, res_id, src, type, value, module, state, comments) =
-                    (EXCLUDED.name, EXCLUDED.lang, EXCLUDED.res_id, EXCLUDED.src, EXCLUDED.type,
-                     EXCLUDED.value, EXCLUDED.module, EXCLUDED.state, EXCLUDED.comments)
-                WHERE EXCLUDED.value IS NOT NULL AND EXCLUDED.value != '';
-            """.format(", ".join(["%s"] * len(rows_by_type['model_terms'])))
-            self.env.cr.execute(query, rows_by_type['model_terms'])
-
-    def _update_translations(self, vals_list):
-        """ Update translations of type 'model' or 'model_terms'.
-
-            This method is used for update of translations where the given
-            ``vals_list`` is trusted to be the right values
-            No new translation will be created
-        """
-        self.flush_model()
-        grouped_rows = {}
-        for vals in vals_list:
-            key = (vals['lang'], vals['type'], vals['name'])
-            grouped_rows.setdefault(key, [vals['value'], vals['src'], vals['state'], []])
-            grouped_rows[key][3].append(vals['res_id'])
-
-        for where, values in grouped_rows.items():
-            self._cr.execute(
-                """ UPDATE ir_translation
-                    SET value=%s,
-                        src=%s,
-                        state=%s
-                    WHERE lang=%s AND type=%s AND name=%s AND res_id in %s
-                """,
-                (values[0], values[1], values[2], where[0], where[1], where[2], tuple(values[3]))
-            )
-        self.invalidate_model(['value', 'src', 'state'])
-
-    @api.model
-    def translate_fields(self, model, id, field=None):
-        """ Open a view for translating the field(s) of the record (model, id). """
-        main_lang = 'en_US'
-        if not self.env['res.lang'].search_count([('code', '!=', main_lang)]):
-            raise UserError(_("Translation features are unavailable until you install an extra translation."))
-
-        # determine domain for selecting translations
-        record = self.env[model].with_context(lang=main_lang).browse(id)
-        domain = ['&', ('res_id', '=', id), ('name', '=like', model + ',%')]
-
-        def make_domain(fld, rec):
-            name = "%s,%s" % (fld.model_name, fld.name)
-            return ['&', ('res_id', '=', rec.id), ('name', '=', name)]
-
-        # insert missing translations, and extend domain for related fields
-        for name, fld in record._fields.items():
-            if not fld.translate:
-                continue
-
-            rec = record
-            if fld.related:
-                try:
-                    # traverse related fields up to their data source
-                    while fld.related:
-                        rec, fld = fld.traverse_related(rec)
-                    if rec:
-                        domain = ['|'] + domain + make_domain(fld, rec)
-                except AccessError:
-                    continue
-
-            assert fld.translate and rec._name == fld.model_name
-            self.insert_missing(fld, rec)
-
-        action = {
-            'name': _('Translate'),
-            'res_model': 'ir.translation',
-            'type': 'ir.actions.act_window',
-            'view_mode': 'tree',
-            'view_id': self.env.ref('base.view_translation_dialog_tree').id,
-            'target': 'current',
-            'domain': domain,
-            'context': {},
-        }
-        if field:
-            fld = record._fields[field]
-            if not fld.related:
-                action['context'] = {
-                    'search_default_name': "%s,%s" % (fld.model_name, fld.name),
-                }
-            else:
-                rec = record
-                try:
-                    while fld.related:
-                        rec, fld = fld.traverse_related(rec)
-                    if rec:
-                        action['context'] = {'search_default_name': "%s,%s" % (fld.model_name, fld.name),}
-                except AccessError:
-                    pass
-
-            action['target'] = 'new'
-            action['context']['translation_type'] = 'text' if fld.type in ['text', 'html'] else 'char'
-            action['context']['translation_show_src'] = False
-            if callable(fld.translate):
-                action['view_id'] = self.env.ref('base.view_translation_lang_src_value_tree').id,
-                action['context']['translation_show_src'] = True
-            else:
-                action['view_id'] = self.env.ref('base.view_translation_lang_value_tree').id,
-
-        return action
-
-    def _get_import_cursor(self, overwrite):
-        """ Return a cursor-like object for fast inserting translations """
-        return IrTranslationImport(self._cr, overwrite)
-
-    def _load_module_terms(self, modules, langs, overwrite=False):
-        """ Load PO files of the given modules for the given languages. """
-        # load i18n files
-        for module_name in modules:
-            modpath = get_module_path(module_name)
-            if not modpath:
-                continue
-            for lang in langs:
-                lang_code = tools.get_iso_codes(lang)
-                lang_overwrite = overwrite
-                base_lang_code = None
-                if '_' in lang_code:
-                    base_lang_code = lang_code.split('_')[0]
-
-                # Step 1: for sub-languages, load base language first (e.g. es_CL.po is loaded over es.po)
-                if base_lang_code:
-                    base_trans_file = get_module_resource(module_name, 'i18n', base_lang_code + '.po')
-                    if base_trans_file:
-                        _logger.info('module %s: loading base translation file %s for language %s', module_name, base_lang_code, lang)
-                        tools.trans_load(self._cr, base_trans_file, lang, verbose=False, overwrite=lang_overwrite)
-                        lang_overwrite = True  # make sure the requested translation will override the base terms later
-
-                    # i18n_extra folder is for additional translations handle manually (eg: for l10n_be)
-                    base_trans_extra_file = get_module_resource(module_name, 'i18n_extra', base_lang_code + '.po')
-                    if base_trans_extra_file:
-                        _logger.info('module %s: loading extra base translation file %s for language %s', module_name, base_lang_code, lang)
-                        tools.trans_load(self._cr, base_trans_extra_file, lang, verbose=False, overwrite=lang_overwrite)
-                        lang_overwrite = True  # make sure the requested translation will override the base terms later
-
-                # Step 2: then load the main translation file, possibly overriding the terms coming from the base language
-                trans_file = get_module_resource(module_name, 'i18n', lang_code + '.po')
-                if trans_file:
-                    _logger.info('module %s: loading translation file (%s) for language %s', module_name, lang_code, lang)
-                    tools.trans_load(self._cr, trans_file, lang, verbose=False, overwrite=lang_overwrite)
-                elif lang_code != 'en_US':
-                    _logger.info('module %s: no translation for language %s', module_name, lang_code)
-
-                trans_extra_file = get_module_resource(module_name, 'i18n_extra', lang_code + '.po')
-                if trans_extra_file:
-                    _logger.info('module %s: loading extra translation file (%s) for language %s', module_name, lang_code, lang)
-                    tools.trans_load(self._cr, trans_extra_file, lang, verbose=False, overwrite=lang_overwrite)
-        return True
-
-    @api.model
-    def get_technical_translations(self, model_name):
-        """ Find the translations for the fields of `model_name`
-
-        Find the technical translations for the fields of the model, including
-        string, tooltip and available selections.
-
-        :return: action definition to open the list of available translations
-        """
-        fields = self.env['ir.model.fields'].search([('model', '=', model_name)])
-        selection_ids = tools.flatten([field.selection_ids.ids for field in fields if field.ttype == 'selection'])
-        view = self.env.ref("base.view_translation_tree", False) or self.env['ir.ui.view']
-        return {
-            'name': _("Technical Translations"),
-            'view_mode': 'tree',
-            'views': [(view.id, "list")],
-            'res_model': 'ir.translation',
-            'type': 'ir.actions.act_window',
-            'domain': [
-                '&',
-                    ('type', '=', 'model'),
-                    '|',
-                        '&', ('res_id', 'in', fields.ids),
-                             ('name', 'like', 'ir.model.fields,'),
-                        '&', ('res_id', 'in', selection_ids),
-                             ('name', 'like', 'ir.model.fields.selection,')
-            ],
-        }
-
-    @api.model
-    def get_translations_for_webclient(self, mods, lang):
-        if not mods:
-            mods = [x['name'] for x in self.env['ir.module.module'].sudo().search_read(
-                [('state', '=', 'installed')], ['name'])]
-        if not lang:
-            lang = self._context.get("lang")
-        langs = self.env['res.lang']._lang_get(lang)
-        lang_params = None
-        if langs:
-            lang_params = {
-                "name": langs.name,
-                "direction": langs.direction,
-                "date_format": langs.date_format,
-                "time_format": langs.time_format,
-                "grouping": langs.grouping,
-                "decimal_point": langs.decimal_point,
-                "thousands_sep": langs.thousands_sep,
-                "week_start": langs.week_start,
-            }
-            lang_params['week_start'] = int(lang_params['week_start'])
-            lang_params['code'] = lang
-
-        # Regional languages (ll_CC) must inherit/override their parent lang (ll), but this is
-        # done server-side when the language is loaded, so we only need to load the user's lang.
-        translations_per_module = {}
-        messages = self.env['ir.translation'].sudo().search_read([
-            ('module', 'in', mods), ('lang', '=', lang),
-            ('comments', 'like', 'openerp-web'), ('value', '!=', False),
-            ('value', '!=', '')],
-            ['module', 'src', 'value', 'lang'], order='module')
-        for mod, msg_group in itertools.groupby(messages, key=operator.itemgetter('module')):
-            translations_per_module.setdefault(mod, {'messages': []})
-            translations_per_module[mod]['messages'].extend({
-                'id': m['src'],
-                'string': m['value']}
-                for m in msg_group)
-
-        return translations_per_module, lang_params
-
-    @api.model
-    @tools.ormcache('frozenset(mods)', 'lang')
-    def get_web_translations_hash(self, mods, lang):
-        translations, lang_params = self.get_translations_for_webclient(mods, lang)
-        translation_cache = {
-            'lang_parameters': lang_params,
-            'modules': translations,
-            'lang': lang,
-            'multi_lang': len(self.env['res.lang'].sudo().get_installed()) > 1,
-        }
-        return hashlib.sha1(json.dumps(translation_cache, sort_keys=True).encode()).hexdigest()

--- a/odoo/addons/base/models/ir_ui_view.py
+++ b/odoo/addons/base/models/ir_ui_view.py
@@ -320,6 +320,9 @@ actual arch.
                     data['arch_fs'] = '/'.join(path_info[0:2])
                     data['arch_updated'] = False
             view.write(data)
+            # the xml_translate will clean the arch_db when write (e.g. ('<div>') -> ('<div></div>'))
+            # view.arch should be reassigned here
+            view.arch = view.arch_db
         # the field 'arch' depends on the context and has been implicitly
         # modified in all languages; the invalidation below ensures that the
         # field does not keep an old value in another environment
@@ -566,6 +569,12 @@ actual arch.
             self.inherit_children_ids.unlink()
         return super(View, self).unlink()
 
+    def _update_field_translations(self, fname, translations, digest=None):
+        res = super()._update_field_translations(fname, translations, digest)
+        if fname == 'arch_db' and 'install_filename' not in self._context:
+            self.write({'arch_updated': True})
+        return res
+
     @api.returns('self', lambda value: value.id)
     def copy(self, default=None):
         self.ensure_one()

--- a/odoo/addons/base/models/res_lang.py
+++ b/odoo/addons/base/models/res_lang.py
@@ -305,8 +305,6 @@ class Lang(models.Model):
                 raise UserError(_("You cannot delete the language which is Active!\nPlease de-activate the language first."))
 
     def unlink(self):
-        for language in self:
-            self.env['ir.translation'].search([('lang', '=', language.code)]).unlink()
         self.clear_caches()
         return super(Lang, self).unlink()
 
