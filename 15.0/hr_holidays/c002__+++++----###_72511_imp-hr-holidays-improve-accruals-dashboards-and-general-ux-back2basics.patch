PR: https://github.com/odoo/odoo/pull/72511

From: 254d6a71e8d5e7bdf8b302d774e024646921b72d
From: jdoutreloux
Date: 2021-09-02 12:57:03

Structural Changes: 72.8
Total Changes: 1321

[IMP] hr_holidays: Improve Accruals, dashboards and general UX (Back2basics)

Purpose
=======

Time Off : New Dashboard, Accruals feature, Public holidays, New time off type configuration view.

- Review of Dashboard
- Accrual feature : Currently, when you create an allocation, it's possible to create an
  Accrual, but there is no appraisal Plan. An Appraisal plan is use to define steps of accruals
  for each employee.
  In Belgium, we use accrual Allocation for European Leaves, or compensatory hours, it's a
  simple use case.  But in USA, it's possible to change the calculation mode each year.
  Also, in USA, it's possible to deal your accrual plan when you arrive on the company. It's a
  HR Officer task to create the right Accrual allocation for each new employee.
- Public Holidays :
  Improvement of global time off feature located on Working hours calendar. Now, Time off
  application have to manage Public Holidays.
- Review of Time Off type configuration

COM PR: https://github.com/odoo/odoo/pull/72511
ENT PR: https://github.com/odoo/enterprise/pull/19157
UPG PR: https://github.com/odoo/upgrade/pull/2791
TaskID:2475413

closes odoo/odoo#72511

Related: odoo/enterprise#19157
Related: odoo/upgrade#2791
Signed-off-by: Yannick Tivisse (yti) <yti@odoo.com>
Co-authored-by: William Braeckman <wbr@odoo.com>
Co-authored-by: Xavier BOL (xbo) <xbo@odoo.com>
Co-authored-by: Laurent Stukkens (LTU) <ltu@odoo.com>
Co-authored-by: Yannick Tivisse <yti@odoo.com>

================================= pseudo patch: =================================

--- a/addons/hr_holidays/models/__init__.py
+++ b/addons/hr_holidays/models/__init__.py
@@ -7,6 +7,8 @@ from . import hr_department
 from . import hr_leave
 from . import hr_leave_allocation
 from . import hr_leave_type
+from . import hr_leave_accrual_plan_level
+from . import hr_leave_accrual_plan
 from . import mail_message_subtype
 from . import res_partner
 from . import res_users

--- a/addons/hr_holidays/models/hr_employee.py
+++ b/addons/hr_holidays/models/hr_employee.py
@@ -32,6 +32,7 @@ class HrEmployeeBase(models.AbstractModel):
     leave_date_to = fields.Date('To Date', compute='_compute_leave_status')
     leaves_count = fields.Float('Number of Time Off', compute='_compute_remaining_leaves')
     allocation_count = fields.Float('Total number of days allocated.', compute='_compute_allocation_count')
+    allocations_count = fields.Integer('Total number of allocations', compute="_compute_allocation_count")
     allocation_used_count = fields.Float('Total number of days off used', compute='_compute_total_allocation_used')
     show_leaves = fields.Boolean('Able to see Remaining Time Off', compute='_compute_show_leaves')
     is_absent = fields.Boolean('Absent Today', compute='_compute_leave_status', search='_search_absent_employee')
@@ -40,9 +41,6 @@ class HrEmployeeBase(models.AbstractModel):
     hr_icon_display = fields.Selection(selection_add=[('presence_holiday_absent', 'On leave'),
                                                       ('presence_holiday_present', 'Present but on leave')])
 
-    def _get_date_start_work(self):
-        return self.create_date
-
     def _get_remaining_leaves(self):
         """ Helper to compute the remaining leaves for the current employees
             :returns dict where the key is the employee id, and the value is the remain leaves
@@ -64,7 +62,7 @@ class HrEmployeeBase(models.AbstractModel):
                 join hr_leave_type s ON (s.id=h.holiday_status_id)
             WHERE
                 s.active = true AND h.state='validate' AND
-                (s.allocation_type='fixed' OR s.allocation_type='fixed_allocation') AND
+                s.requires_allocation='yes' AND
                 h.employee_id in %s
             GROUP BY h.employee_id""", (tuple(self.ids),))
         return dict((row['employee_id'], row['days']) for row in self._cr.dictfetchall())
@@ -84,10 +82,12 @@ class HrEmployeeBase(models.AbstractModel):
             ('holiday_status_id.active', '=', True),
             ('state', '=', 'validate'),
         ], ['number_of_days:sum', 'employee_id'], ['employee_id'])
-        rg_results = dict((d['employee_id'][0], d['number_of_days']) for d in data)
+        rg_results = dict((d['employee_id'][0], {"employee_id_count": d['employee_id_count'], "number_of_days": d['number_of_days']}) for d in data)
         for employee in self:
-            employee.allocation_count = float_round(rg_results.get(employee.id, 0.0), precision_digits=2)
+            result = rg_results.get(employee.id)
+            employee.allocation_count = float_round(result['number_of_days'], precision_digits=2) if result else 0.0
             employee.allocation_display = "%g" % employee.allocation_count
+            employee.allocations_count = result['employee_id_count'] if result else 0.0
 
     def _compute_total_allocation_used(self):
         for employee in self:

--- a/addons/hr_holidays/models/hr_leave.py
+++ b/addons/hr_holidays/models/hr_leave.py
@@ -5,12 +5,12 @@
 
 import logging
 
-from collections import namedtuple
+from collections import namedtuple, defaultdict
 
 from datetime import datetime, timedelta, time
 from pytz import timezone, UTC
 
-from odoo import api, fields, models, tools
+from odoo import api, fields, models, tools, SUPERUSER_ID
 from odoo.addons.base.models.res_partner import _tz_get
 from odoo.addons.resource.models.resource import float_to_time, HOURS_PER_DAY
 from odoo.exceptions import AccessError, UserError, ValidationError
@@ -72,7 +72,7 @@ class HolidaysRequest(models.Model):
         defaults = self._default_get_request_parameters(defaults)
 
         if 'holiday_status_id' in fields_list and not defaults.get('holiday_status_id'):
-            lt = self.env['hr.leave.type'].search([('valid', '=', True), ('allocation_type', 'in', ['no', 'fixed_allocation'])], limit=1)
+            lt = self.env['hr.leave.type'].search(['|', ('requires_allocation', '=', 'no'), ('has_valid_allocation', '=', True)], limit=1)
 
             if lt:
                 defaults['holiday_status_id'] = lt.id
@@ -112,7 +112,6 @@ class HolidaysRequest(models.Model):
     private_name = fields.Char('Time Off Description', groups='hr_holidays.group_hr_holidays_user')
     state = fields.Selection([
         ('draft', 'To Submit'),
-        ('cancel', 'Cancelled'),  # YTI This state seems to be unused. To remove
         ('confirm', 'To Approve'),
         ('refuse', 'Refused'),
         ('validate1', 'Second Approval'),
@@ -122,7 +121,6 @@ class HolidaysRequest(models.Model):
         "\nThe status is 'To Approve', when time off request is confirmed by user." +
         "\nThe status is 'Refused', when time off request is refused by manager." +
         "\nThe status is 'Approved', when time off request is approved by manager.")
-    payslip_status = fields.Boolean('Reported in last payslips', help='Green this button when the time off has been taken into account in the payslip.', copy=False)
     report_note = fields.Text('HR Comments', copy=False, groups="hr_holidays.group_hr_holidays_manager")
     user_id = fields.Many2one('res.users', string='User', related='employee_id.user_id', related_sudo=True, compute_sudo=True, store=True, default=lambda self: self.env.uid, readonly=True)
     manager_id = fields.Many2one('hr.employee', compute='_compute_from_employee_id', store=True, readonly=False)
@@ -130,14 +128,18 @@ class HolidaysRequest(models.Model):
     holiday_status_id = fields.Many2one(
         "hr.leave.type", compute='_compute_from_employee_id', store=True, string="Time Off Type", required=True, readonly=False,
         states={'cancel': [('readonly', True)], 'refuse': [('readonly', True)], 'validate1': [('readonly', True)], 'validate': [('readonly', True)]},
-        domain=[('valid', '=', True)])
+        domain=['|', ('requires_allocation', '=', 'no'), ('has_valid_allocation', '=', True)])
+    holiday_allocation_id = fields.Many2one(
+        'hr.leave.allocation', compute='_compute_from_holiday_status_id', string="Allocation", store=True, readonly=False)
+    color = fields.Integer("Color", related='holiday_status_id.color')
     validation_type = fields.Selection(string='Validation Type', related='holiday_status_id.leave_validation_type', readonly=False)
     # HR data
 
     employee_id = fields.Many2one(
-        'hr.employee', compute='_compute_from_holiday_type', store=True, string='Employee', index=True, readonly=False, ondelete="restrict",
+        'hr.employee', compute='_compute_from_employee_ids', store=True, string='Employee', index=True, readonly=False, ondelete="restrict",
         states={'cancel': [('readonly', True)], 'refuse': [('readonly', True)], 'validate1': [('readonly', True)], 'validate': [('readonly', True)]},
         tracking=True)
+    employee_company_id = fields.Many2one(related='employee_id.company_id', readonly=True, store=True)
     active_employee = fields.Boolean(related='employee_id.active', readonly=True)
     tz_mismatch = fields.Boolean(compute='_compute_tz_mismatch')
     tz = fields.Selection(_tz_get, compute='_compute_tz')
@@ -176,6 +178,12 @@ class HolidaysRequest(models.Model):
         string='Allocation Mode', readonly=True, required=True, default='employee',
         states={'draft': [('readonly', False)], 'confirm': [('readonly', False)]},
         help='By Employee: Allocation/Request for individual Employee, By Employee Tag: Allocation/Request for group of employees in category')
+    employee_ids = fields.Many2many(
+        'hr.employee', compute='_compute_from_holiday_type', store=True, string='Employees', readonly=False,
+        states={'cancel': [('readonly', True)], 'refuse': [('readonly', True)], 'validate1': [('readonly', True)], 'validate': [('readonly', True)]})
+    multi_employee = fields.Boolean(
+        compute='_compute_from_employee_ids', store=True,
+        help='Holds whether this allocation concerns more than 1 employee')
     category_id = fields.Many2one(
         'hr.employee.category', compute='_compute_from_holiday_type', store=True, string='Employee Tag',
         states={'draft': [('readonly', False)], 'confirm': [('readonly', False)]}, help='Category of Employee')
@@ -196,6 +204,7 @@ class HolidaysRequest(models.Model):
     supported_attachment_ids = fields.Many2many(
         'ir.attachment', string="Attach File", compute='_compute_supported_attachment_ids',
         inverse='_inverse_supported_attachment_ids')
+    supported_attachment_ids_count = fields.Integer(compute='_compute_supported_attachment_ids')
     # UX fields
     leave_type_request_unit = fields.Selection(related='holiday_status_id.request_unit', readonly=True)
     leave_type_support_document = fields.Boolean(related="holiday_status_id.support_document")
@@ -263,10 +272,11 @@ class HolidaysRequest(models.Model):
     request_unit_custom = fields.Boolean('Days-long custom hours', compute='_compute_request_unit_custom', store=True, readonly=False)
     # view
     is_hatched = fields.Boolean('Hatched', compute='_compute_is_hatched')
+    is_striked = fields.Boolean('Striked', compute='_compute_is_hatched')
 
     _sql_constraints = [
         ('type_value',
-         "CHECK((holiday_type='employee' AND employee_id IS NOT NULL) or "
+         "CHECK((holiday_type='employee' AND (employee_id IS NOT NULL OR multi_employee IS TRUE)) or "
          "(holiday_type='company' AND mode_company_id IS NOT NULL) or "
          "(holiday_type='category' AND category_id IS NOT NULL) or "
          "(holiday_type='department' AND department_id IS NOT NULL) )",
@@ -313,8 +323,46 @@ class HolidaysRequest(models.Model):
 
     @api.depends('holiday_status_id')
     def _compute_state(self):
-        for holiday in self:
-            holiday.state = 'confirm' if holiday.validation_type != 'no_validation' else 'draft'
+        for leave in self:
+            leave.state = 'confirm' if leave.validation_type != 'no_validation' else 'draft'
+
+    @api.depends('holiday_status_id.requires_allocation', 'validation_type', 'employee_id', 'date_from', 'date_to')
+    def _compute_from_holiday_status_id(self):
+        invalid_self = self.filtered(lambda leave: not leave.date_to or not leave.date_from)
+        if invalid_self:
+            invalid_self.update({'holiday_allocation_id': False})
+            self = self - invalid_self
+        if not self:
+            return
+        allocations = self.env['hr.leave.allocation'].search_read(
+            [
+                ('holiday_status_id', 'in', self.holiday_status_id.ids),
+                ('employee_id', 'in', self.employee_id.ids),
+                '|',
+                ('date_to', '>=', min(self.mapped('date_to'))),
+                '&',
+                ('date_to', '=', False),
+                ('date_from', '<=', max(self.mapped('date_from'))),
+            ], ['id', 'date_from', 'date_to', 'holiday_status_id', 'employee_id'], order="date_to, id"
+        )
+        allocations_dict = defaultdict(lambda: [])
+        for allocation in allocations:
+            allocations_dict[(allocation['holiday_status_id'][0], allocation['employee_id'][0])].append(allocation)
+
+        for leave in self:
+            if leave.holiday_status_id.requires_allocation == 'yes' and leave.date_from and leave.date_to:
+                found_allocation = False
+                date_to = leave.date_to.replace(tzinfo=UTC).astimezone(timezone(leave.tz)).date()
+                date_from = leave.date_from.replace(tzinfo=UTC).astimezone(timezone(leave.tz)).date()
+                for allocation in allocations_dict[(leave.holiday_status_id.id, leave.employee_id.id)]:
+                    date_to_check = allocation['date_to'] > date_to if allocation['date_to'] else False
+                    date_from_check = allocation['date_to'] is False and allocation['date_from'] <= date_from
+                    if (date_to_check or date_from_check):
+                        found_allocation = allocation['id']
+                        break
+                leave.holiday_allocation_id = self.env['hr.leave.allocation'].browse(found_allocation) if found_allocation else False
+            else:
+                leave.holiday_allocation_id = False
 
     @api.depends('request_date_from_period', 'request_hour_from', 'request_hour_to', 'request_date_from', 'request_date_to',
                 'request_unit_half', 'request_unit_hours', 'request_unit_custom', 'employee_id')
@@ -409,28 +457,37 @@ class HolidaysRequest(models.Model):
             if holiday.holiday_status_id or holiday.request_unit_half or holiday.request_unit_hours:
                 holiday.request_unit_custom = False
 
+    @api.depends('employee_ids')
+    def _compute_from_employee_ids(self):
+        for holiday in self:
+            if len(holiday.employee_ids) == 1:
+                holiday.employee_id = holiday.employee_ids[0]._origin
+            else:
+                holiday.employee_id = False
+            holiday.multi_employee = (len(holiday.employee_ids) > 1)
+
     @api.depends('holiday_type')
     def _compute_from_holiday_type(self):
         for holiday in self:
             if holiday.holiday_type == 'employee':
-                if not holiday.employee_id:
-                    holiday.employee_id = self.env.user.employee_id
+                if not holiday.employee_ids:
+                    holiday.employee_ids = self.env.user.employee_id
                 holiday.mode_company_id = False
                 holiday.category_id = False
             elif holiday.holiday_type == 'company':
-                holiday.employee_id = False
+                holiday.employee_ids = False
                 if not holiday.mode_company_id:
                     holiday.mode_company_id = self.env.company.id
                 holiday.category_id = False
             elif holiday.holiday_type == 'department':
-                holiday.employee_id = False
+                holiday.employee_ids = False
                 holiday.mode_company_id = False
                 holiday.category_id = False
             elif holiday.holiday_type == 'category':
-                holiday.employee_id = False
+                holiday.employee_ids = False
                 holiday.mode_company_id = False
             else:
-                holiday.employee_id = self.env.context.get('default_employee_id') or self.env.user.employee_id
+                holiday.employee_ids = self.env.context.get('default_employee_id') or self.env.user.employee_id
 
     @api.depends('employee_id')
     def _compute_from_employee_id(self):
@@ -559,12 +616,14 @@ class HolidaysRequest(models.Model):
     @api.depends('state')
     def _compute_is_hatched(self):
         for holiday in self:
+            holiday.is_striked = holiday.state == 'refuse'
             holiday.is_hatched = holiday.state not in ['refuse', 'validate']
 
     @api.depends('leave_type_support_document', 'attachment_ids')
     def _compute_supported_attachment_ids(self):
         for holiday in self:
             holiday.supported_attachment_ids = holiday.attachment_ids
+            holiday.supported_attachment_ids_count = len(holiday.attachment_ids.ids)
 
     def _inverse_supported_attachment_ids(self):
         for holiday in self:
@@ -590,7 +649,7 @@ class HolidaysRequest(models.Model):
     def _check_holidays(self):
         mapped_days = self.mapped('holiday_status_id').get_employees_days(self.mapped('employee_id').ids)
         for holiday in self:
-            if holiday.holiday_type != 'employee' or not holiday.employee_id or holiday.holiday_status_id.allocation_type == 'no':
+            if holiday.holiday_type != 'employee' or not holiday.employee_id or holiday.holiday_status_id.requires_allocation == 'no':
                 continue
             leave_days = mapped_days[holiday.employee_id.id][holiday.holiday_status_id.id]
             if float_compare(leave_days['remaining_leaves'], 0, precision_digits=2) == -1 or float_compare(leave_days['virtual_remaining_leaves'], 0, precision_digits=2) == -1:
@@ -664,8 +723,10 @@ class HolidaysRequest(models.Model):
                     target = leave.department_id.name
                 elif leave.holiday_type == 'category':
                     target = leave.category_id.name
-                else:
+                elif leave.employee_id:
                     target = leave.employee_id.name
+                else:
+                    target = ', '.join(leave.employee_ids.mapped('name'))
                 if leave.leave_type_request_unit == 'hour':
                     if self.env.context.get('hide_employee_name') and 'employee_id' in self.env.context.get('group_by', []):
                         res.append((
@@ -717,34 +778,43 @@ class HolidaysRequest(models.Model):
         if employee.user_id:
             self.message_subscribe(partner_ids=employee.user_id.partner_id.ids)
 
-    @api.constrains('holiday_status_id', 'date_to', 'date_from')
+    @api.constrains('holiday_allocation_id')
+    def _check_allocation_id(self):
+        for leave in self:
+            if leave.holiday_status_id.requires_allocation == 'yes' and not leave.holiday_allocation_id:
+                raise ValidationError(_(
+                    'Could not find an allocation of type %(leave_type)s for the requested time period.',
+                    leave_type=leave.holiday_status_id.display_name,
+                ))
+
+    @api.constrains('holiday_allocation_id', 'date_to', 'date_from')
     def _check_leave_type_validity(self):
         for leave in self:
-            vstart = leave.holiday_status_id.validity_start
-            vstop = leave.holiday_status_id.validity_stop
+            vstart = leave.holiday_allocation_id.date_from
+            vstop = leave.holiday_allocation_id.date_to
             dfrom = leave.date_from
             dto = leave.date_to
-            if leave.holiday_status_id.validity_start and leave.holiday_status_id.validity_stop:
+            if vstart and vstop:
                 if dfrom and dto and (dfrom.date() < vstart or dto.date() > vstop):
                     raise ValidationError(_(
                         '%(leave_type)s are only valid between %(start)s and %(end)s',
                         leave_type=leave.holiday_status_id.display_name,
-                        start=leave.holiday_status_id.validity_start,
-                        end=leave.holiday_status_id.validity_stop
+                        start=vstart,
+                        end=vstop
                     ))
-            elif leave.holiday_status_id.validity_start:
+            elif vstart:
                 if dfrom and (dfrom.date() < vstart):
                     raise ValidationError(_(
                         '%(leave_type)s are only valid starting from %(date)s',
                         leave_type=leave.holiday_status_id.display_name,
-                        date=leave.holiday_status_id.validity_start
+                        date=vstart
                     ))
-            elif leave.holiday_status_id.validity_stop:
+            elif vstop:
                 if dto and (dto.date() > vstop):
                     raise ValidationError(_(
                         '%(leave_type)s are only valid until %(date)s',
                         leave_type=leave.holiday_status_id.display_name,
-                        date=leave.holiday_status_id.validity_stop
+                        date=vstop
                     ))
 
     def _check_double_validation_rules(self, employees, state):
@@ -788,6 +858,8 @@ class HolidaysRequest(models.Model):
 
         holidays = super(HolidaysRequest, self.with_context(mail_create_nosubscribe=True)).create(vals_list)
 
+        holidays.filtered(lambda holiday: not holiday.holiday_allocation_id).with_user(SUPERUSER_ID)._compute_from_holiday_status_id()
+
         for holiday in holidays:
             if not self._context.get('leave_fast_create'):
                 # Everything that is done here must be done using sudo because we might
@@ -1019,94 +1091,107 @@ class HolidaysRequest(models.Model):
             raise UserError(_('Time off request must be confirmed in order to approve it.'))
 
         self.write({'state': 'validate'})
-        self.filtered(lambda holiday: holiday.validation_type == 'both').write({'second_approver_id': current_employee.id})
-        self.filtered(lambda holiday: holiday.validation_type != 'both').write({'first_approver_id': current_employee.id})
 
-        for holiday in self.filtered(lambda holiday: holiday.holiday_type != 'employee'):
-            if holiday.holiday_type == 'category':
-                employees = holiday.category_id.employee_ids
-            elif holiday.holiday_type == 'company':
-                employees = self.env['hr.employee'].search([('company_id', '=', holiday.mode_company_id.id)])
+        leaves_second_approver = self.env['hr.leave']
+        leaves_first_approver = self.env['hr.leave']
+
+        for leave in self:
+            if leave.validation_type == 'both':
+                leaves_second_approver += leave
             else:
-                employees = holiday.department_id.member_ids
-
-            conflicting_leaves = self.env['hr.leave'].with_context(
-                tracking_disable=True,
-                mail_activity_automation_skip=True,
-                leave_fast_create=True
-            ).search([
-                ('date_from', '<=', holiday.date_to),
-                ('date_to', '>', holiday.date_from),
-                ('state', 'not in', ['cancel', 'refuse']),
-                ('holiday_type', '=', 'employee'),
-                ('employee_id', 'in', employees.ids)])
-
-            if conflicting_leaves:
-                # YTI: More complex use cases could be managed in master
-                if holiday.leave_type_request_unit != 'day' or any(l.leave_type_request_unit == 'hour' for l in conflicting_leaves):
-                    raise ValidationError(_('You can not have 2 time off that overlaps on the same day.'))
-
-                # keep track of conflicting leaves states before refusal
-                target_states = {l.id: l.state for l in conflicting_leaves}
-                conflicting_leaves.action_refuse()
-                split_leaves_vals = []
-                for conflicting_leave in conflicting_leaves:
-                    if conflicting_leave.leave_type_request_unit == 'half_day' and conflicting_leave.request_unit_half:
-                        continue
+                leaves_first_approver += leave
 
-                    # Leaves in days
-                    if conflicting_leave.date_from < holiday.date_from:
-                        before_leave_vals = conflicting_leave.copy_data({
-                            'date_from': conflicting_leave.date_from.date(),
-                            'date_to': holiday.date_from.date() + timedelta(days=-1),
-                            'state': target_states[conflicting_leave.id],
-                        })[0]
-                        before_leave = self.env['hr.leave'].new(before_leave_vals)
-                        before_leave._compute_date_from_to()
-
-                        # Could happen for part-time contract, that time off is not necessary
-                        # anymore.
-                        # Imagine you work on monday-wednesday-friday only.
-                        # You take a time off on friday.
-                        # We create a company time off on friday.
-                        # By looking at the last attendance before the company time off
-                        # start date to compute the date_to, you would have a date_from > date_to.
-                        # Just don't create the leave at that time. That's the reason why we use
-                        # new instead of create. As the leave is not actually created yet, the sql
-                        # constraint didn't check date_from < date_to yet.
-                        if before_leave.date_from < before_leave.date_to:
-                            split_leaves_vals.append(before_leave._convert_to_write(before_leave._cache))
-                    if conflicting_leave.date_to > holiday.date_to:
-                        after_leave_vals = conflicting_leave.copy_data({
-                            'date_from': holiday.date_to.date() + timedelta(days=1),
-                            'date_to': conflicting_leave.date_to.date(),
-                            'state': target_states[conflicting_leave.id],
-                        })[0]
-                        after_leave = self.env['hr.leave'].new(after_leave_vals)
-                        after_leave._compute_date_from_to()
-                        # Could happen for part-time contract, that time off is not necessary
-                        # anymore.
-                        if after_leave.date_from < after_leave.date_to:
-                            split_leaves_vals.append(after_leave._convert_to_write(after_leave._cache))
-
-                split_leaves = self.env['hr.leave'].with_context(
+            if leave.holiday_type != 'employee' or\
+                (leave.holiday_type == 'employee' and len(leave.employee_ids) > 1):
+                if leave.holiday_type == 'employee':
+                    employees = leave.employee_ids
+                elif leave.holiday_type == 'category':
+                    employees = leave.category_id.employee_ids
+                elif leave.holiday_type == 'company':
+                    employees = self.env['hr.employee'].search([('company_id', '=', leave.mode_company_id.id)])
+                else:
+                    employees = leave.department_id.member_ids
+
+                conflicting_leaves = self.env['hr.leave'].with_context(
+                    tracking_disable=True,
+                    mail_activity_automation_skip=True,
+                    leave_fast_create=True
+                ).search([
+                    ('date_from', '<=', leave.date_to),
+                    ('date_to', '>', leave.date_from),
+                    ('state', 'not in', ['cancel', 'refuse']),
+                    ('holiday_type', '=', 'employee'),
+                    ('employee_id', 'in', employees.ids)])
+
+                if conflicting_leaves:
+                    # YTI: More complex use cases could be managed in master
+                    if leave.leave_type_request_unit != 'day' or any(l.leave_type_request_unit == 'hour' for l in conflicting_leaves):
+                        raise ValidationError(_('You can not have 2 time off that overlaps on the same day.'))
+
+                    # keep track of conflicting leaves states before refusal
+                    target_states = {l.id: l.state for l in conflicting_leaves}
+                    conflicting_leaves.action_refuse()
+                    split_leaves_vals = []
+                    for conflicting_leave in conflicting_leaves:
+                        if conflicting_leave.leave_type_request_unit == 'half_day' and conflicting_leave.request_unit_half:
+                            continue
+
+                        # Leaves in days
+                        if conflicting_leave.date_from < leave.date_from:
+                            before_leave_vals = conflicting_leave.copy_data({
+                                'date_from': conflicting_leave.date_from.date(),
+                                'date_to': leave.date_from.date() + timedelta(days=-1),
+                                'state': target_states[conflicting_leave.id],
+                            })[0]
+                            before_leave = self.env['hr.leave'].new(before_leave_vals)
+                            before_leave._compute_date_from_to()
+
+                            # Could happen for part-time contract, that time off is not necessary
+                            # anymore.
+                            # Imagine you work on monday-wednesday-friday only.
+                            # You take a time off on friday.
+                            # We create a company time off on friday.
+                            # By looking at the last attendance before the company time off
+                            # start date to compute the date_to, you would have a date_from > date_to.
+                            # Just don't create the leave at that time. That's the reason why we use
+                            # new instead of create. As the leave is not actually created yet, the sql
+                            # constraint didn't check date_from < date_to yet.
+                            if before_leave.date_from < before_leave.date_to:
+                                split_leaves_vals.append(before_leave._convert_to_write(before_leave._cache))
+                        if conflicting_leave.date_to > leave.date_to:
+                            after_leave_vals = conflicting_leave.copy_data({
+                                'date_from': leave.date_to.date() + timedelta(days=1),
+                                'date_to': conflicting_leave.date_to.date(),
+                                'state': target_states[conflicting_leave.id],
+                            })[0]
+                            after_leave = self.env['hr.leave'].new(after_leave_vals)
+                            after_leave._compute_date_from_to()
+                            # Could happen for part-time contract, that time off is not necessary
+                            # anymore.
+                            if after_leave.date_from < after_leave.date_to:
+                                split_leaves_vals.append(after_leave._convert_to_write(after_leave._cache))
+
+                    split_leaves = self.env['hr.leave'].with_context(
+                        tracking_disable=True,
+                        mail_activity_automation_skip=True,
+                        leave_fast_create=True,
+                        leave_skip_state_check=True
+                    ).create(split_leaves_vals)
+
+                    split_leaves.filtered(lambda l: l.state in 'validate')._validate_leave_request()
+
+                values = leave._prepare_employees_holiday_values(employees)
+                leaves = self.env['hr.leave'].with_context(
                     tracking_disable=True,
                     mail_activity_automation_skip=True,
                     leave_fast_create=True,
-                    leave_skip_state_check=True
-                ).create(split_leaves_vals)
-
-                split_leaves.filtered(lambda l: l.state in 'validate')._validate_leave_request()
+                    leave_skip_state_check=True,
+                ).create(values)
 
-            values = holiday._prepare_employees_holiday_values(employees)
-            leaves = self.env['hr.leave'].with_context(
-                tracking_disable=True,
-                mail_activity_automation_skip=True,
-                leave_fast_create=True,
-                leave_skip_state_check=True,
-            ).create(values)
+                leaves._validate_leave_request()
 
-            leaves._validate_leave_request()
+        leaves_second_approver.write({'second_approver_id': current_employee.id})
+        leaves_first_approver.write({'first_approver_id': current_employee.id})
 
         employee_requests = self.filtered(lambda hol: hol.holiday_type == 'employee')
         employee_requests._validate_leave_request()
@@ -1140,6 +1225,18 @@ class HolidaysRequest(models.Model):
         self.activity_update()
         return True
 
+    def action_documents(self):
+        domain = [('id', 'in', self.attachment_ids.ids)]
+        return {
+            'name': _("Supporting Documents"),
+            'type': 'ir.actions.act_window',
+            'res_model': 'ir.attachment',
+            'context': {'create': False},
+            'view_mode': 'list',
+            'domain': domain
+        }
+
+
     def _check_approval_update(self, state):
         """ Check if target state is achievable. """
         if self.env.is_superuser():

--- a/None
+++ b/addons/hr_holidays/models/hr_leave_accrual_plan.py
@@ -0,0 +1,43 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from odoo import api, fields, models, _
+
+
+class AccrualPlan(models.Model):
+    _name = "hr.leave.accrual.plan"
+    _description = "Accrual Plan"
+
+    name = fields.Char('Name', required=True)
+    time_off_type_id = fields.Many2one('hr.leave.type', string="Time Off Type")
+    employees_count = fields.Integer("Employees", compute='_compute_employee_count')
+    level_ids = fields.One2many('hr.leave.accrual.level', 'accrual_plan_id')
+    allocation_ids = fields.One2many('hr.leave.allocation', 'accrual_plan_id')
+    transition_mode = fields.Selection([
+        ('immediately', 'Immediately'),
+        ('end_of_accrual', "After this accrual's period")],
+        string="Level Transition", default="immediately", required=True,
+        help="""Immediately: When the date corresponds to the new level, your accrual is automatically computed, granted and you switch to new level
+                After this accrual's period: When the accrual is complete (a week, a month), and granted, you switch to next level if allocation date corresponds""")
+
+    @api.depends('allocation_ids')
+    def _compute_employee_count(self):
+        allocations_read_group = self.env['hr.leave.allocation'].read_group(
+            [('accrual_plan_id', 'in', self.ids)],
+            ['accrual_plan_id', 'employee_count:count_distinct(employee_id)'],
+            ['accrual_plan_id'],
+        )
+        allocations_dict = {res['accrual_plan_id'][0]: res['employee_count'] for res in allocations_read_group}
+        for plan in self:
+            plan.employees_count = allocations_dict.get(plan.id, 0)
+
+    def action_open_accrual_plan_employees(self):
+        self.ensure_one()
+
+        return {
+            'name': _("Accrual Plan's Employees"),
+            'type': 'ir.actions.act_window',
+            'view_mode': 'kanban,tree,form',
+            'res_model': 'hr.employee',
+            'domain': [('id', 'in', self.allocation_ids.employee_id.ids)],
+        }

--- a/None
+++ b/addons/hr_holidays/models/hr_leave_accrual_plan_level.py
@@ -0,0 +1,291 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+import datetime
+import calendar
+
+from dateutil.relativedelta import relativedelta
+
+from odoo import api, fields, models
+from odoo.tools.date_utils import get_timedelta
+
+
+DAYS = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat']
+MONTHS = ['jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul', 'aug', 'sep', 'oct', 'nov', 'dec']
+
+def _get_date_check_month(year, month, day):
+    """
+    Returns the last day of the month for the given date if the day is outside of the month's range, i.e 30 feb
+    """
+    month_range = calendar.monthrange(year, month)
+    if day > month_range[1]:
+        return datetime.date(year, month, min(day, month_range[1])) + relativedelta(days=(day - month_range[1]))
+    return datetime.date(year, month, day)
+
+class AccrualPlanLevel(models.Model):
+    _name = "hr.leave.accrual.level"
+    _description = "Accrual Plan Level"
+    _order = 'sequence asc'
+
+    sequence = fields.Integer(
+        string='sequence', compute='_compute_sequence', store=True,
+        help='Sequence is generated automatically by start time delta.')
+    level = fields.Integer(compute='_compute_level', help='Level computed through the sequence.')
+    accrual_plan_id = fields.Many2one('hr.leave.accrual.plan', "Accrual Plan", required=True)
+    start_count = fields.Integer(
+        "Start after",
+        help="The accrual starts after a defined period from the employee start date. This field define the number of days, month or years after which accrual is used.", default="1")
+    start_type = fields.Selection(
+        [('day', 'day(s)'),
+         ('month', 'month(s)'),
+         ('year', 'year(s)')],
+        default='day', string=" ", required=True,
+        help="This field define the unit of time after which the accrual starts.")
+    is_based_on_worked_time = fields.Boolean("Based on worked time")
+
+    # Accrue of
+    added_value = fields.Float(
+        "Gain", required=True,
+        help="The number of days that will be incremented for every period")
+    added_value_type = fields.Selection(
+        [('days', 'Days'),
+         ('hours', 'Hours')],
+        default='days', required=True)
+    frequency = fields.Selection([
+        ('daily', 'Daily'),
+        ('weekly', 'Weekly'),
+        ('bimonthly', 'Twice a month'),
+        ('monthly', 'Monthly'),
+        ('biyearly', 'Twice a year'),
+        ('yearly', 'Yearly'),
+    ], default='daily', required=True, string="Frequency")
+    week_day = fields.Selection([
+        ('mon', 'Monday'),
+        ('tue', 'Tuesday'),
+        ('wed', 'Wednesday'),
+        ('thu', 'Thursday'),
+        ('fri', 'Friday'),
+        ('sat', 'Saturday'),
+        ('sun', 'Sunday'),
+    ], default='mon', required=True, string="Allocation on")
+    first_day = fields.Integer(default=1)
+    second_day = fields.Integer(default=15)
+    first_month_day = fields.Integer(default=1)
+    first_month = fields.Selection([
+        ('jan', 'January'),
+        ('feb', 'February'),
+        ('mar', 'March'),
+        ('apr', 'April'),
+        ('may', 'May'),
+        ('jun', 'June'),
+    ], default="jan")
+    second_month_day = fields.Integer(default=1)
+    second_month = fields.Selection([
+        ('jul', 'July'),
+        ('aug', 'Augustus'),
+        ('sep', 'September'),
+        ('oct', 'October'),
+        ('nov', 'November'),
+        ('dec', 'December')
+    ], default="jul")
+    yearly_month = fields.Selection([
+        ('jan', 'January'),
+        ('feb', 'February'),
+        ('mar', 'March'),
+        ('apr', 'April'),
+        ('may', 'May'),
+        ('jun', 'June'),
+        ('jul', 'July'),
+        ('aug', 'Augustus'),
+        ('sep', 'September'),
+        ('oct', 'October'),
+        ('nov', 'November'),
+        ('dec', 'December')
+    ], default="jan")
+    yearly_day = fields.Integer(default=1)
+    maximum_leave = fields.Float(
+        'Limit to', required=False, default=100,
+        help="Choose a maximum limit of days for this accrual. 0 means no limit.")
+    parent_id = fields.Many2one(
+        'hr.leave.accrual.level', string="Previous Level",
+        help="If this field is empty, this level is the first one.")
+    action_with_unused_accruals = fields.Selection(
+        [('postponed', 'Postponed to next year'),
+         ('lost', 'Lost')],
+        string="At the end of the year, unused accruals will be",
+        default='postponed', required='True')
+
+    _sql_constraints = [
+        ('check_dates',
+         "CHECK( (frequency = 'daily') or"
+         "(week_day IS NOT NULL AND frequency = 'weekly') or "
+         "(first_day > 0 AND second_day > first_day AND first_day <= 31 AND second_day <= 31 AND frequency = 'bimonthly') or "
+         "(first_day > 0 AND first_day <= 31 AND frequency = 'monthly')or "
+         "(first_month_day > 0 AND first_month_day <= 31 AND second_month_day > 0 AND second_month_day <= 31 AND frequency = 'biyearly') or "
+         "(yearly_day > 0 AND yearly_day <= 31 AND frequency = 'yearly'))",
+         "The dates you've set up aren't correct. Please check them."),
+        ('start_count_check', "CHECK( start_count >= 1 )", "You must start after more than 0 days."),
+        ('added_value_greater_than_zero', 'CHECK(added_value > 0)', 'You must give the gain greater than 0 in accrual plan levels.')
+    ]
+
+    @api.depends('start_count', 'start_type')
+    def _compute_sequence(self):
+        # Not 100% accurate because of odd months/years, but good enough
+        start_type_multipliers = {
+            'day': 1,
+            'month': 30,
+            'year': 365,
+        }
+        for level in self:
+            level.sequence = level.start_count * start_type_multipliers[level.start_type]
+
+    @api.depends('sequence', 'accrual_plan_id')
+    def _compute_level(self):
+        #Mapped level_ids.ids ordered by sequence per plan
+        mapped_level_ids = {}
+        for plan in self.accrual_plan_id:
+            # We can not use .ids here because we also deal with NewIds
+            mapped_level_ids[plan] = [level.id for level in plan.level_ids.sorted('sequence')]
+        for level in self:
+            if level.accrual_plan_id:
+                level.level = mapped_level_ids[level.accrual_plan_id].index(level.id) + 1
+            else:
+                level.level = 1
+
+    def _get_accrual_values(self, allocation_create_date):
+        """
+        This method returns all the accrual linked to their accrual_plan with the updated dynamic parameters depending
+        on the date.
+        :return: dict: {accrual_id, accrual_start, accrual_stop, nextcall, sufficient_seniority}
+         where accrual_start and accrual_stop are start and stop of the current period
+        """
+        today = fields.Date.context_today(self, )
+        results = []
+        for accrual in self:
+            seniority = allocation_create_date + get_timedelta(accrual.start_count, accrual.start_type)
+            frequency = accrual.frequency
+            if frequency == 'daily':
+                accrual_start = max(today, seniority.date())
+                accrual_stop = accrual_start + relativedelta(days=1)
+                nextcall = accrual_stop
+            elif frequency == 'weekly':
+                min_accrual_date = max(today, seniority.date())
+                if min_accrual_date.isoweekday() == DAYS.index(accrual.week_day):
+                    accrual_stop = min_accrual_date
+                else:
+                    accrual_stop = accrual._get_next_weekday(min_accrual_date, accrual.week_day)
+                accrual_start = accrual_stop - relativedelta(days=7)
+                nextcall = accrual._get_next_weekday(min_accrual_date, accrual.week_day)
+            elif frequency == 'bimonthly':
+                if today.day <= accrual.first_day:
+                    accrual_start = datetime.date(today.year, today.month, accrual.second_day) - relativedelta(months=1)
+                    accrual_stop = datetime.date(today.year, today.month, accrual.first_day)
+                    nextcall = datetime.date(today.year, today.month, accrual.second_day)
+                else:
+                    if today.day <= accrual.second_day:
+                        accrual_start = datetime.date(today.year, today.month, accrual.first_day)
+                        accrual_stop = datetime.date(today.year, today.month, accrual.second_day)
+                        nextcall = datetime.date(today.year, today.month, accrual.first_day) + relativedelta(months=1)
+                    else:
+                        accrual_start = datetime.date(today.year, today.month, accrual.second_day)
+                        accrual_stop = datetime.date(today.year, today.month, accrual.first_day) + relativedelta(months=1)
+                        nextcall = datetime.date(today.year, today.month, accrual.second_day) + relativedelta(months=1)
+            elif frequency == 'monthly':
+                if today.day <= accrual.first_day:
+                    accrual_start = datetime.date(today.year, today.month, accrual.first_day) - relativedelta(months=1)
+                    accrual_stop = datetime.date(today.year, today.month, accrual.first_day)
+                    nextcall = datetime.date(today.year, today.month, accrual.first_day) + relativedelta(months=1)
+                else:
+                    accrual_start = datetime.date(today.year, today.month, accrual.first_day)
+                    accrual_stop = datetime.date(today.year, today.month, accrual.first_day) + relativedelta(months=1)
+                    nextcall = datetime.date(today.year, today.month, accrual.first_day) + relativedelta(months=2)
+            elif frequency == 'biyearly':
+                first_month = MONTHS.index(accrual.first_month) + 1
+                second_month = MONTHS.index(accrual.second_month) + 1
+                potential_first_accrual_date = datetime.date(today.year, first_month, accrual.first_month_day)
+                potential_second_accrual_date = datetime.date(today.year, second_month, accrual.second_month_day)
+                if today <= potential_first_accrual_date:
+                    accrual_start = potential_second_accrual_date - relativedelta(years=1)
+                    accrual_stop = potential_first_accrual_date
+                    nextcall = potential_second_accrual_date
+                else:
+                    if today <= potential_second_accrual_date:
+                        accrual_start = potential_first_accrual_date
+                        accrual_stop = potential_second_accrual_date
+                        nextcall = potential_first_accrual_date + relativedelta(years=1)
+                    else:
+                        accrual_start = potential_second_accrual_date
+                        accrual_stop = potential_first_accrual_date + relativedelta(years=1)
+                        nextcall = potential_first_accrual_date + relativedelta(years=1)
+            elif frequency == 'yearly':
+                month = MONTHS.index(accrual.yearly_month) + 1
+                potential_accrual_date = datetime.date(today.year, month, accrual.yearly_day)
+                if today <= potential_accrual_date:
+                    accrual_start = potential_accrual_date - relativedelta(years=1)
+                    accrual_stop = potential_accrual_date
+                    nextcall = potential_accrual_date + relativedelta(years=1)
+                else:
+                    accrual_start = potential_accrual_date
+                    accrual_stop = potential_accrual_date + relativedelta(years=1)
+                    nextcall = accrual_stop
+
+            results.append({'accrual_level_id': accrual.id,
+                            'start_after': accrual.start_count,
+                            'accrual_start': datetime.datetime.combine(accrual_start, datetime.datetime.min.time()),
+                            'accrual_stop': datetime.datetime.combine(accrual_stop, datetime.datetime.min.time()),
+                            'nextcall': nextcall,
+                            'sufficient_seniority': seniority.date() <= today})
+        return results
+
+    def _get_next_date(self, last_call):
+        """
+        Returns the next date with the given last call
+        """
+        self.ensure_one()
+        if self.frequency == 'daily':
+            return last_call + relativedelta(days=1)
+        elif self.frequency == 'weekly':
+            return self._get_next_weekday(last_call, self.week_day)
+        elif self.frequency == 'bimonthly':
+            if last_call.day < self.first_day:
+                return _get_date_check_month(last_call.year, last_call.month, self.first_day)
+            elif last_call.day < self.second_day:
+                return _get_date_check_month(last_call.year, last_call.month, self.second_day)
+            else:
+                return _get_date_check_month(last_call.year, last_call.month, self.first_day) + relativedelta(months=1)
+        elif self.frequency == 'monthly':
+            if last_call.day < self.first_day:
+                return _get_date_check_month(last_call.year, last_call.month, self.first_day)
+            else:
+                return _get_date_check_month(last_call.year, last_call.month, self.first_day) + relativedelta(months=1)
+        elif self.frequency == 'biyearly':
+            first_month = MONTHS.index(self.first_month) + 1
+            second_month = MONTHS.index(self.second_month) + 1
+            if last_call < _get_date_check_month(last_call.year, first_month, self.first_month_day):
+                return _get_date_check_month(last_call.year, first_month, self.first_month_day)
+            elif last_call < _get_date_check_month(last_call.year, second_month, self.second_month_day):
+                return _get_date_check_month(last_call.year, second_month, self.second_month_day)
+            else:
+                return _get_date_check_month(last_call.year, first_month, self.first_month_day) + relativedelta(years=1)
+        elif self.frequency == 'yearly':
+            month = MONTHS.index(self.yearly_month) + 1
+            if last_call < _get_date_check_month(last_call.year, month, self.yearly_day):
+                return _get_date_check_month(last_call.year, month, self.yearly_day)
+            else:
+                return _get_date_check_month(last_call.year, month, self.yearly_day) + relativedelta(years=1)
+        else:
+            return False
+
+    @api.model
+    def _get_next_weekday(self, day, weekday):
+        """
+        :param day: a datetime object
+        :param weekday: Weekday as a decimal number, where 0 is Sunday and 6 is Saturday.
+        :return: datetime of the next weekday
+        """
+        daynames = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat']
+        weekday = daynames.index(weekday)
+        days_ahead = weekday - day.isoweekday()
+        if days_ahead <= 0:
+            days_ahead += 7
+        return day + relativedelta(days=days_ahead)

--- a/addons/hr_holidays/models/hr_leave_allocation.py
+++ b/addons/hr_holidays/models/hr_leave_allocation.py
@@ -3,6 +3,7 @@
 
 # Copyright (c) 2005-2006 Axelor SARL. (http://www.axelor.com)
 
+from collections import defaultdict
 import logging
 
 from datetime import datetime, time
@@ -13,6 +14,7 @@ from odoo.addons.resource.models.resource import HOURS_PER_DAY
 from odoo.exceptions import AccessError, UserError, ValidationError
 from odoo.tools.translate import _
 from odoo.tools.float_utils import float_round
+from odoo.tools.date_utils import get_timedelta
 from odoo.osv import expression
 
 _logger = logging.getLogger(__name__)
@@ -28,15 +30,15 @@ class HolidaysAllocation(models.Model):
 
     def _default_holiday_status_id(self):
         if self.user_has_groups('hr_holidays.group_hr_holidays_user'):
-            domain = [('valid', '=', True), ('allocation_type', '!=', 'no')]
+            domain = [('has_valid_allocation', '=', True), ('requires_allocation', '=', 'yes')]
         else:
-            domain = [('valid', '=', True), ('allocation_type', '=', 'fixed_allocation')]
+            domain = [('has_valid_allocation', '=', True), ('requires_allocation', '=', 'yes'), ('employee_requests', '=', 'yes')]
         return self.env['hr.leave.type'].search(domain, limit=1)
 
-    def _holiday_status_id_domain(self):
-        if self.user_has_groups('hr_holidays.group_hr_holidays_manager'):
-            return [('valid', '=', True), ('allocation_type', '!=', 'no')]
-        return [('valid', '=', True), ('allocation_type', '=', 'fixed_allocation')]
+    def _domain_holiday_status_id(self):
+        if self.user_has_groups('hr_holidays.group_hr_holidays_user'):
+            return []
+        return [('employee_requests', '=', 'yes')]
 
     name = fields.Char('Description', compute='_compute_description', inverse='_inverse_description', search='_search_description', compute_sudo=False)
     active = fields.Boolean(default=True)
@@ -46,30 +48,28 @@ class HolidaysAllocation(models.Model):
         ('cancel', 'Cancelled'),
         ('confirm', 'To Approve'),
         ('refuse', 'Refused'),
-        ('validate1', 'Second Approval'),
         ('validate', 'Approved')
-        ], string='Status', readonly=True, tracking=True, copy=False, default='confirm',
+        ], string='Status', readonly=True, tracking=True, copy=False, default='draft',
         help="The status is set to 'To Submit', when an allocation request is created." +
         "\nThe status is 'To Approve', when an allocation request is confirmed by user." +
         "\nThe status is 'Refused', when an allocation request is refused by manager." +
         "\nThe status is 'Approved', when an allocation request is approved by manager.")
-    date_from = fields.Datetime(
-        'Start Date', readonly=True, index=True, copy=False, default=fields.Date.context_today,
-        states={'draft': [('readonly', False)], 'confirm': [('readonly', False)]}, tracking=True)
-    date_to = fields.Datetime(
-        'End Date', compute='_compute_from_holiday_status_id', store=True, readonly=False, copy=False, tracking=True,
+    date_from = fields.Date('Start Date', index=True, copy=False, default=fields.Date.context_today,
+        states={'draft': [('readonly', False)], 'confirm': [('readonly', False)]}, tracking=True, required=True)
+    date_to = fields.Date('End Date', copy=False, tracking=True,
         states={'cancel': [('readonly', True)], 'refuse': [('readonly', True)], 'validate1': [('readonly', True)], 'validate': [('readonly', True)]})
     holiday_status_id = fields.Many2one(
-        "hr.leave.type", compute='_compute_from_employee_id', store=True, string="Time Off Type", required=True, readonly=False,
+        "hr.leave.type", compute='_compute_holiday_status_id', store=True, string="Time Off Type", required=True, readonly=False,
         states={'cancel': [('readonly', True)], 'refuse': [('readonly', True)], 'validate1': [('readonly', True)], 'validate': [('readonly', True)]},
-        domain=_holiday_status_id_domain, default=_default_holiday_status_id)
+        domain=_domain_holiday_status_id,
+        default=_default_holiday_status_id)
     employee_id = fields.Many2one(
-        'hr.employee', compute='_compute_from_holiday_type', store=True, string='Employee', index=True, readonly=False, ondelete="restrict", tracking=True,
-        states={'cancel': [('readonly', True)], 'refuse': [('readonly', True)], 'validate1': [('readonly', True)], 'validate': [('readonly', True)]})
-    employee_company_id = fields.Many2one(related='employee_id.company_id', readonly=True)
+        'hr.employee', compute='_compute_from_employee_ids', store=True, string='Employee', index=True, readonly=False, ondelete="restrict", tracking=True,
+        states={'cancel': [('readonly', True)], 'refuse': [('readonly', True)], 'validate': [('readonly', True)]})
+    employee_company_id = fields.Many2one(related='employee_id.company_id', readonly=True, store=True)
     active_employee = fields.Boolean('Active Employee', related='employee_id.active', readonly=True)
-    manager_id = fields.Many2one('hr.employee', compute='_compute_from_employee_id', store=True, string='Manager')
-    notes = fields.Html('Reasons', readonly=True, states={'draft': [('readonly', False)], 'confirm': [('readonly', False)]})
+    manager_id = fields.Many2one('hr.employee', compute='_compute_manager_id', store=True, string='Manager')
+    notes = fields.Text('Reasons', readonly=True, states={'draft': [('readonly', False)], 'confirm': [('readonly', False)]})
     # duration
     number_of_days = fields.Float(
         'Number of Days', compute='_compute_from_holiday_status_id', store=True, readonly=False, tracking=True, default=1,
@@ -86,12 +86,9 @@ class HolidaysAllocation(models.Model):
     # details
     parent_id = fields.Many2one('hr.leave.allocation', string='Parent')
     linked_request_ids = fields.One2many('hr.leave.allocation', 'parent_id', string='Linked Requests')
-    first_approver_id = fields.Many2one(
+    approver_id = fields.Many2one(
         'hr.employee', string='First Approval', readonly=True, copy=False,
         help='This area is automatically filled by the user who validates the allocation')
-    second_approver_id = fields.Many2one(
-        'hr.employee', string='Second Approval', readonly=True, copy=False,
-        help='This area is automatically filled by the user who validates the allocation with second level (If allocation type need second validation)')
     validation_type = fields.Selection(string='Validation Type', related='holiday_status_id.allocation_validation_type', readonly=True)
     can_reset = fields.Boolean('Can reset', compute='_compute_can_reset')
     can_approve = fields.Boolean('Can Approve', compute='_compute_can_approve')
@@ -108,126 +105,49 @@ class HolidaysAllocation(models.Model):
              "\n- By Company: all employees of the specified company"
              "\n- By Department: all employees of the specified department"
              "\n- By Employee Tag: all employees of the specific employee group category")
+    employee_ids = fields.Many2many(
+        'hr.employee', compute='_compute_from_holiday_type', store=True, string='Employees', readonly=False,
+        states={'cancel': [('readonly', True)], 'refuse': [('readonly', True)], 'validate': [('readonly', True)]})
+    multi_employee = fields.Boolean(
+        compute='_compute_from_employee_ids', store=True,
+        help='Holds whether this allocation concerns more than 1 employee')
     mode_company_id = fields.Many2one(
         'res.company', compute='_compute_from_holiday_type', store=True, string='Company Mode', readonly=False,
-        states={'cancel': [('readonly', True)], 'refuse': [('readonly', True)], 'validate1': [('readonly', True)], 'validate': [('readonly', True)]})
+        states={'cancel': [('readonly', True)], 'refuse': [('readonly', True)], 'validate': [('readonly', True)]})
     department_id = fields.Many2one(
         'hr.department', compute='_compute_department_id', store=True, string='Department',
         states={'draft': [('readonly', False)], 'confirm': [('readonly', False)]})
     category_id = fields.Many2one(
         'hr.employee.category', compute='_compute_from_holiday_type', store=True, string='Employee Tag', readonly=False,
-        states={'cancel': [('readonly', True)], 'refuse': [('readonly', True)], 'validate1': [('readonly', True)], 'validate': [('readonly', True)]})
+        states={'cancel': [('readonly', True)], 'refuse': [('readonly', True)], 'validate': [('readonly', True)]})
     # accrual configuration
+    lastcall = fields.Date("Date of the last accrual allocation", readonly=True, default=fields.Date.context_today)
+    nextcall = fields.Date("Date of the next accrual allocation", default=False, readonly=True)
     allocation_type = fields.Selection(
         [
             ('regular', 'Regular Allocation'),
             ('accrual', 'Accrual Allocation')
         ], string="Allocation Type", default="regular", required=True, readonly=True,
         states={'draft': [('readonly', False)], 'confirm': [('readonly', False)]})
-    accrual_limit = fields.Integer('Balance limit', default=0, help="Maximum of allocation for accrual; 0 means no maximum.")
-    number_per_interval = fields.Float("Number of unit per interval", compute='_compute_from_holiday_status_id', store=True, readonly=False,
-        states={'cancel': [('readonly', True)], 'refuse': [('readonly', True)], 'validate1': [('readonly', True)], 'validate': [('readonly', True)]})
-    interval_number = fields.Integer("Number of unit between two intervals", compute='_compute_from_holiday_status_id', store=True, readonly=False,
-        states={'cancel': [('readonly', True)], 'refuse': [('readonly', True)], 'validate1': [('readonly', True)], 'validate': [('readonly', True)]})
-    unit_per_interval = fields.Selection([
-        ('hours', 'Hours'),
-        ('days', 'Days')
-        ], compute='_compute_from_holiday_status_id', store=True, string="Unit of time added at each interval", readonly=False,
-        states={'cancel': [('readonly', True)], 'refuse': [('readonly', True)], 'validate1': [('readonly', True)], 'validate': [('readonly', True)]})
-    interval_unit = fields.Selection([
-        ('days', 'Days'),
-        ('weeks', 'Weeks'),
-        ('months', 'Months'),
-        ('years', 'Years')
-        ], compute='_compute_from_holiday_status_id', store=True, string="Unit of time between two intervals", readonly=False,
-        states={'cancel': [('readonly', True)], 'refuse': [('readonly', True)], 'validate1': [('readonly', True)], 'validate': [('readonly', True)]})
-    nextcall = fields.Date("Date of the next accrual allocation", default=False, readonly=True)
+    is_officer = fields.Boolean(compute='_compute_is_officer')
+    accrual_plan_id = fields.Many2one('hr.leave.accrual.plan', compute="_compute_from_holiday_status_id", store=True, readonly=False, domain="[('time_off_type_id', '=?', holiday_status_id)]", tracking=True)
     max_leaves = fields.Float(compute='_compute_leaves')
     leaves_taken = fields.Float(compute='_compute_leaves')
+    taken_leave_ids = fields.One2many('hr.leave', 'holiday_allocation_id', domain="[('state', 'in', ['confirm', 'validate1', 'validate'])]")
 
     _sql_constraints = [
         ('type_value',
-         "CHECK( (holiday_type='employee' AND employee_id IS NOT NULL) or "
+         "CHECK( (holiday_type='employee' AND (employee_id IS NOT NULL OR multi_employee IS TRUE)) or "
          "(holiday_type='category' AND category_id IS NOT NULL) or "
          "(holiday_type='department' AND department_id IS NOT NULL) or "
          "(holiday_type='company' AND mode_company_id IS NOT NULL))",
          "The employee, department, company or employee category of this request is missing. Please make sure that your user login is linked to an employee."),
-        ('duration_check', "CHECK ( number_of_days >= 0 )", "The number of days must be greater than 0."),
-        ('number_per_interval_check', "CHECK(number_per_interval > 0)", "The number per interval should be greater than 0"),
-        ('interval_number_check', "CHECK(interval_number > 0)", "The interval number should be greater than 0"),
+        ('duration_check', "CHECK( ( number_of_days > 0 AND allocation_type='regular') or (allocation_type != 'regular'))", "The duration must be greater than 0."),
     ]
 
-    @api.model
-    def _update_accrual(self):
-        """
-            Method called by the cron task in order to increment the number_of_days when
-            necessary.
-        """
-        today = fields.Date.from_string(fields.Date.today())
-
-        holidays = self.search([('allocation_type', '=', 'accrual'), ('employee_id.active', '=', True), ('state', '=', 'validate'), ('holiday_type', '=', 'employee'),
-                                '|', ('date_to', '=', False), ('date_to', '>', fields.Datetime.now()),
-                                '|', ('nextcall', '=', False), ('nextcall', '<=', today)])
-
-        for holiday in holidays:
-            values = {}
-
-            delta = relativedelta(days=0)
-
-            if holiday.interval_unit == 'days':
-                delta = relativedelta(days=holiday.interval_number)
-            if holiday.interval_unit == 'weeks':
-                delta = relativedelta(weeks=holiday.interval_number)
-            if holiday.interval_unit == 'months':
-                delta = relativedelta(months=holiday.interval_number)
-            if holiday.interval_unit == 'years':
-                delta = relativedelta(years=holiday.interval_number)
-
-            if holiday.nextcall:
-                values['nextcall'] = holiday.nextcall + delta
-            else:
-                values['nextcall'] = holiday.date_from
-                while values['nextcall'] <= datetime.combine(today, time(0, 0, 0)):
-                    values['nextcall'] += delta
-
-            period_start = datetime.combine(today, time(0, 0, 0)) - delta
-            period_end = datetime.combine(today, time(0, 0, 0))
-
-            # We have to check when the employee has been created
-            # in order to not allocate him/her too much leaves
-            start_date = holiday.employee_id._get_date_start_work()
-            # If employee is created after the period, we cancel the computation
-            if period_end <= start_date or period_end < holiday.date_from:
-                holiday.write(values)
-                continue
-
-            # If employee created during the period, taking the date at which he has been created
-            if period_start <= start_date:
-                period_start = start_date
-
-            employee = holiday.employee_id
-            worked = employee._get_work_days_data_batch(
-                period_start, period_end,
-                domain=[('holiday_id.holiday_status_id.unpaid', '=', True), ('time_type', '=', 'leave')]
-            )[employee.id]['days']
-            left = employee._get_leave_days_data_batch(
-                period_start, period_end,
-                domain=[('holiday_id.holiday_status_id.unpaid', '=', True), ('time_type', '=', 'leave')]
-            )[employee.id]['days']
-            prorata = worked / (left + worked) if worked else 0
-
-            days_to_give = holiday.number_per_interval
-            if holiday.unit_per_interval == 'hours':
-                # As we encode everything in days in the database we need to convert
-                # the number of hours into days for this we use the
-                # mean number of hours set on the employee's calendar
-                days_to_give = days_to_give / (employee.resource_calendar_id.hours_per_day or HOURS_PER_DAY)
-
-            values['number_of_days'] = holiday.number_of_days + days_to_give * prorata
-            if holiday.accrual_limit > 0:
-                values['number_of_days'] = min(values['number_of_days'], holiday.accrual_limit)
-
-            holiday.write(values)
+    @api.depends_context('uid')
+    def _compute_is_officer(self):
+        self.is_officer = self.user_has_groups("hr_holidays.group_hr_holidays_user")
 
     @api.depends_context('uid')
     def _compute_description(self):
@@ -261,9 +181,8 @@ class HolidaysAllocation(models.Model):
     @api.depends('employee_id', 'holiday_status_id')
     def _compute_leaves(self):
         for allocation in self:
-            leave_type = allocation.holiday_status_id.with_context(employee_id=allocation.employee_id.id)
-            allocation.max_leaves = leave_type.max_leaves
-            allocation.leaves_taken = leave_type.leaves_taken
+            allocation.max_leaves = allocation.number_of_hours_display if allocation.type_request_unit == 'hour' else allocation.number_of_days
+            allocation.leaves_taken = sum(taken_leave.number_of_hours_display if taken_leave.leave_type_request_unit == 'hour' else taken_leave.number_of_days for taken_leave in allocation.taken_leave_ids)
 
     @api.depends('number_of_days')
     def _compute_number_of_days_display(self):
@@ -303,37 +222,44 @@ class HolidaysAllocation(models.Model):
     def _compute_can_approve(self):
         for allocation in self:
             try:
-                if allocation.state == 'confirm' and allocation.validation_type == 'both':
-                    allocation._check_approval_update('validate1')
-                else:
+                if allocation.state == 'confirm' and allocation.validation_type != 'no':
                     allocation._check_approval_update('validate')
             except (AccessError, UserError):
                 allocation.can_approve = False
             else:
                 allocation.can_approve = True
 
+    @api.depends('employee_ids')
+    def _compute_from_employee_ids(self):
+        for allocation in self:
+            if len(allocation.employee_ids) == 1:
+                allocation.employee_id = allocation.employee_ids[0]._origin
+            else:
+                allocation.employee_id = False
+            allocation.multi_employee = (len(allocation.employee_ids) > 1)
+
     @api.depends('holiday_type')
     def _compute_from_holiday_type(self):
         for allocation in self:
             if allocation.holiday_type == 'employee':
-                if not allocation.employee_id:
-                    allocation.employee_id = self.env.user.employee_id
+                if not allocation.employee_ids:
+                    allocation.employee_ids = self.env.user.employee_id
                 allocation.mode_company_id = False
                 allocation.category_id = False
             if allocation.holiday_type == 'company':
-                allocation.employee_id = False
+                allocation.employee_ids = False
                 if not allocation.mode_company_id:
                     allocation.mode_company_id = self.env.company
                 allocation.category_id = False
             elif allocation.holiday_type == 'department':
-                allocation.employee_id = False
+                allocation.employee_ids = False
                 allocation.mode_company_id = False
                 allocation.category_id = False
             elif allocation.holiday_type == 'category':
-                allocation.employee_id = False
+                allocation.employee_ids = False
                 allocation.mode_company_id = False
-            elif not allocation.employee_id and not allocation._origin.employee_id:
-                allocation.employee_id = self.env.context.get('default_employee_id') or self.env.user.employee_id
+            else:
+                allocation.employee_ids = self.env.context.get('default_employee_id') or self.env.user.employee_id
 
     @api.depends('holiday_type', 'employee_id')
     def _compute_department_id(self):
@@ -347,47 +273,207 @@ class HolidaysAllocation(models.Model):
                 allocation.department_id = False
 
     @api.depends('employee_id')
-    def _compute_from_employee_id(self):
-        default_holiday_status_id = self._default_holiday_status_id()
+    def _compute_manager_id(self):
+        for allocation in self:
+            allocation.manager_id = allocation.employee_id and allocation.employee_id.parent_id
+
+    @api.depends('employee_id', 'accrual_plan_id')
+    def _compute_holiday_status_id(self):
+        default_holiday_status_id = None
+        holiday_status_by_accrual = {accrual.id: accrual.time_off_type_id for accrual in self.accrual_plan_id}
         for holiday in self:
-            holiday.manager_id = holiday.employee_id and holiday.employee_id.parent_id
             if holiday.employee_id.user_id != self.env.user and holiday._origin.employee_id != holiday.employee_id:
                 holiday.holiday_status_id = False
-            elif not holiday.holiday_status_id and not holiday._origin.holiday_status_id:
-                holiday.holiday_status_id = default_holiday_status_id
-
-    @api.depends('holiday_status_id', 'allocation_type', 'number_of_hours_display', 'number_of_days_display')
+            elif not holiday.holiday_status_id:
+                holiday_status = None
+                if holiday.accrual_plan_id:
+                    holiday_status = holiday_status_by_accrual.get(holiday.accrual_plan_id.id)
+                if holiday_status:
+                    holiday.holiday_status_id = holiday_status
+                elif not holiday._origin.holiday_status_id:
+                    if not default_holiday_status_id:  # fetch when we need it
+                        default_holiday_status_id = self._default_holiday_status_id()
+                    holiday.holiday_status_id = default_holiday_status_id
+
+    @api.depends('holiday_status_id', 'allocation_type', 'number_of_hours_display', 'number_of_days_display', 'date_to')
     def _compute_from_holiday_status_id(self):
+        accrual_allocations = self.filtered(lambda alloc: alloc.allocation_type == 'accrual' and not alloc.accrual_plan_id and alloc.holiday_status_id)
+        accruals_dict = {}
+        default_accrual_plan = None
+        if accrual_allocations:
+            accruals_read_group = self.env['hr.leave.accrual.plan'].read_group(
+                [('time_off_type_id', 'in', accrual_allocations.holiday_status_id.ids)],
+                ['time_off_type_id', 'ids:array_agg(id)'],
+                ['time_off_type_id'],
+            )
+            accruals_dict = {res['time_off_type_id'][0]: res['ids'] for res in accruals_read_group}
         for allocation in self:
             allocation.number_of_days = allocation.number_of_days_display
             if allocation.type_request_unit == 'hour':
                 allocation.number_of_days = allocation.number_of_hours_display / (allocation.employee_id.sudo().resource_calendar_id.hours_per_day or HOURS_PER_DAY)
-
-            # set default values
-            if not allocation.interval_number and not allocation._origin.interval_number:
-                allocation.interval_number = 1
-            if not allocation.number_per_interval and not allocation._origin.number_per_interval:
-                allocation.number_per_interval = 1
-            if not allocation.unit_per_interval and not allocation._origin.unit_per_interval:
-                allocation.unit_per_interval = 'hours'
-            if not allocation.interval_unit and not allocation._origin.interval_unit:
-                allocation.interval_unit = 'weeks'
-
-            if allocation.holiday_status_id.validity_stop and allocation.date_to:
-                new_date_to = datetime.combine(allocation.holiday_status_id.validity_stop, time.max)
-                if new_date_to < allocation.date_to:
-                    allocation.date_to = new_date_to
-
-            if allocation.allocation_type == 'accrual':
-                if allocation.holiday_status_id.request_unit == 'hour':
-                    allocation.unit_per_interval = 'hours'
+            if allocation.accrual_plan_id.time_off_type_id != allocation.holiday_status_id:
+                allocation.accrual_plan_id = False
+            if allocation.allocation_type == 'accrual' and not allocation.accrual_plan_id:
+                accrual_plan = None
+                if allocation.holiday_status_id:
+                    accrual_plan = accruals_dict.get(allocation.holiday_status_id.id, [False])[0]
                 else:
-                    allocation.unit_per_interval = 'days'
+                    if not default_accrual_plan:  # fetch the first accrual plan only when we need
+                        default_accrual_plan = self.env['hr.leave.accrual.plan'].search([], limit=1)
+                    accrual_plan = default_accrual_plan
+                allocation.accrual_plan_id = accrual_plan
+
+    #TODO: remove after impl prorata in _process_accrual_plan_level
+    def _compute_accrual_days(self, first_day, start_date, end_date):
+        """
+        Increase the number of days depending on the period, the start date of the employee and how many days he worked according to his
+        work entry.
+        This method takes also in account if the employee started during the period to apply a prorata
+        """
+        for allocation in self.filtered(lambda i: i.employee_id and i.accrual_plan_id):
+            start_date_prorata = 1.0
+            if first_day > start_date:
+                # The employee was created during the period after the start_date
+                # This prorata depends on the number of days worked during this period
+                worked_days = end_date - first_day
+                period_days = end_date - start_date
+                start_date_prorata = worked_days.days / period_days.days
+                # We calculate from the first_day to end_date
+                start_date = first_day
+            if end_date <= first_day or end_date < datetime.combine(allocation.date_from, time(0, 0, 0)):
+                # Stop the calculation if
+                # * the user was created after the period
+                # * the period ends before the allocation is valid
+                return
+            # The prorata depends if the employee took holidays during the period.
+            # Unpaid holidays and work_entry_type.leave_right = False decrease the amount of holidays
+            if allocation.accrual_level_id.is_based_on_worked_time:
+                worked = allocation.employee_id._get_work_days_data_batch(start_date, end_date, calendar=allocation.employee_id.resource_calendar_id)\
+                    [allocation.employee_id.id]['days']
+                left = allocation.employee_id.sudo()._get_leave_days_data_batch(start_date, end_date,
+                    domain=[('time_type', '=', 'leave')])[allocation.employee_id.id]['days']
+                work_entry_prorata = worked / (left + worked) if worked else 0
+                # Calculate the number of days that could be added
+                added_value = work_entry_prorata * start_date_prorata * allocation.accrual_level_id.added_value
             else:
-                allocation.interval_number = 1
-                allocation.interval_unit = 'weeks'
-                allocation.number_per_interval = 1
-                allocation.unit_per_interval = 'hours'
+                added_value = allocation.accrual_level_id.added_value
+            number_of_days = min(allocation.number_of_days + added_value, allocation.accrual_level_id.maximum_leave)
+            allocation.write({'number_of_days': number_of_days})
+            # Do not send a message if the maximum number of days is already reached
+
+    def _end_of_year_accrual(self):
+        # to override in payroll
+        today = fields.Date.today()
+        for allocation in self:
+            current_level = allocation._get_current_accrual_plan_level_id(today)
+            if current_level and current_level.action_with_unused_accruals == 'lost':
+                # Allocations are lost but number_of_days should not be lower than leaves_taken
+                allocation.write({'number_of_days': allocation.leaves_taken, 'lastcall': today, 'nextcall': False})
+
+    def _get_current_accrual_plan_level_id(self, date):
+        """
+        Returns the accrual_plan_level for the given date of the record's accrual plan
+        """
+        self.ensure_one()
+        if not self.accrual_plan_id.level_ids:
+            return False
+        # Sort by sequence which should be equivalent to the level
+        level_ids = self.accrual_plan_id.level_ids.sorted('sequence')
+        current_level = False
+        current_level_idx = -1
+        for idx, level in enumerate(level_ids):
+            if date >= self.date_from + get_timedelta(level.start_count, level.start_type):
+                current_level = level
+                current_level_idx = idx
+        # If transition_mode is set to `immediately` or we are currently on the first level
+        # the current_level is simply the first level in the list.
+        if current_level_idx <= 0 or self.accrual_plan_id.transition_mode == "immediately":
+            return current_level
+        # In this case we have to verify that the 'previous level' is not the current one due to `end_of_accrual`
+        level_start_date = self.date_from + get_timedelta(current_level.start_count, current_level.start_type)
+        previous_level = level_ids[current_level_idx - 1]
+        # If the next date from the current level's start date is before the last call of the previous level
+        # return the previous level
+        if current_level._get_next_date(level_start_date) < previous_level._get_next_date(level_start_date):
+            return previous_level
+        return current_level
+
+    def _get_first_accrual_plan_level_start_date(self):
+        self.ensure_one()
+        level = self.accrual_plan_id.level_ids.sorted('sequence')[0]
+        if not level:
+            return False
+        return self.date_from + get_timedelta(level.start_count, level.start_type)
+
+    def _process_accrual_plan_level(self, level, start_date, end_date):
+        """
+        Returns the added days for that level
+        """
+        self.ensure_one()
+        #TODO: ask gmf about prorata stuff see `_compute_accrual_days`
+        if level.is_based_on_worked_time:
+            start_dt = datetime.combine(start_date, datetime.min.time())
+            end_dt = datetime.combine(end_date, datetime.min.time())
+            worked = self.employee_id._get_work_days_data_batch(start_dt, end_dt, calendar=self.employee_id.resource_calendar_id)\
+                [self.employee_id.id]['days']
+            left = self.employee_id.sudo()._get_leave_days_data_batch(start_dt, end_dt,
+                domain=[('time_type', '=', 'leave')])[self.employee_id.id]['days']
+            work_entry_prorata = worked / (left + worked) if worked else 0
+            added_value = work_entry_prorata * level.added_value
+        else:
+            added_value = level.added_value
+        # Convert time in hours to time in days in case the level is encoded in hours
+        if level.added_value_type == 'hours':
+            added_value = added_value / (self.employee_id.sudo().resource_id.calendar_id.hours_per_day or HOURS_PER_DAY)
+        return added_value
+
+    def _process_accrual_plans(self):
+        """
+        This method is part of the cron's process.
+        The goal of this method is to retroactively apply accrual plan levels and progress from nextcall to today
+        """
+        today = fields.Date.today()
+        for allocation in self:
+            if not allocation.nextcall:
+                current_level = allocation._get_current_accrual_plan_level_id(today)
+                if not current_level:
+                    # Accrual plan is not configured properly or has not started
+                    continue
+                allocation.lastcall = max(allocation.lastcall, allocation.date_from + get_timedelta(current_level.start_count, current_level.start_type))
+                allocation.nextcall = current_level._get_next_date(allocation.lastcall)
+            days_added_per_level = defaultdict(lambda: 0)
+            while allocation.nextcall <= today:
+                current_level = allocation._get_current_accrual_plan_level_id(allocation.nextcall)
+                nextcall = current_level._get_next_date(allocation.nextcall)
+                days_added_per_level[current_level] += allocation._process_accrual_plan_level(current_level, allocation.lastcall, allocation.nextcall)
+                allocation.lastcall = allocation.nextcall
+                allocation.nextcall = nextcall
+            if days_added_per_level:
+                number_of_days_to_add = 0
+                for value in days_added_per_level.values():
+                    number_of_days_to_add += value
+                # Let's assume the limit of the last level is the correct one
+                allocation.write({'number_of_days': min(allocation.number_of_days + number_of_days_to_add, current_level.maximum_leave)})
+
+    @api.model
+    def _update_accrual(self):
+        """
+            Method called by the cron task in order to increment the number_of_days when
+            necessary.
+        """
+        # Get the current date to determine the start and end of the accrual period
+        today = datetime.combine(fields.Date.today(), time(0, 0, 0))
+        if today.day == 1 and today.month == 1:
+            end_of_year_allocations = self.search(
+            [('allocation_type', '=', 'accrual'), ('state', '=', 'validate'), ('accrual_plan_id', '!=', False), ('employee_id', '!=', False),
+             '|', ('date_to', '=', False), ('date_to', '>', fields.Datetime.now())])
+            end_of_year_allocations._end_of_year_accrual()
+            end_of_year_allocations.flush()
+        allocations = self.search(
+        [('allocation_type', '=', 'accrual'), ('state', '=', 'validate'), ('accrual_plan_id', '!=', False), ('employee_id', '!=', False),
+            '|', ('date_to', '=', False), ('date_to', '>', fields.Datetime.now()),
+            '|', ('nextcall', '=', False), ('nextcall', '<=', today)])
+        allocations._process_accrual_plans()
 
     ####################################################
     # ORM Overrides methods
@@ -402,8 +488,10 @@ class HolidaysAllocation(models.Model):
                 target = allocation.department_id.name
             elif allocation.holiday_type == 'category':
                 target = allocation.category_id.name
+            elif allocation.employee_id:
+                target = allocation.employee_id.name
             else:
-                target = allocation.employee_id.sudo().name
+                target = ', '.join(allocation.employee_ids.sudo().mapped('name'))
 
             res.append(
                 (allocation.id,
@@ -421,20 +509,6 @@ class HolidaysAllocation(models.Model):
         if employee.user_id:
             self.message_subscribe(partner_ids=employee.user_id.partner_id.ids)
 
-    @api.constrains('holiday_status_id')
-    def _check_leave_type_validity(self):
-        for allocation in self:
-            if allocation.holiday_status_id.validity_stop:
-                vstop = allocation.holiday_status_id.validity_stop
-                today = fields.Date.today()
-
-                if vstop < today:
-                    raise ValidationError(_(
-                        'You can allocate %(allocation_type)s only before %(date)s.',
-                        allocation_type=allocation.holiday_status_id.display_name,
-                        date=allocation.holiday_status_id.validity_stop
-                    ))
-
     @api.model_create_multi
     def create(self, vals_list):
         """ Override to avoid automatic logging of creation """
@@ -442,6 +516,9 @@ class HolidaysAllocation(models.Model):
             employee_id = values.get('employee_id', False)
             if not values.get('department_id'):
                 values.update({'department_id': self.env['hr.employee'].browse(employee_id).department_id.id})
+            # default `lastcall` to `nextcall`
+            if 'date_from' in values and 'lastcall' not in values:
+                values['lastcall'] = values['date_from']
         holidays = super(HolidaysAllocation, self.with_context(mail_create_nosubscribe=True)).create(vals_list)
         for holiday in holidays:
             partners_to_subscribe = set()
@@ -453,6 +530,8 @@ class HolidaysAllocation(models.Model):
             holiday.message_subscribe(partner_ids=tuple(partners_to_subscribe))
             if not self._context.get('import_file'):
                 holiday.activity_update()
+            if holiday.validation_type == 'no':
+                holiday.state = 'validate'
         return holidays
 
     def write(self, values):
@@ -476,9 +555,9 @@ class HolidaysAllocation(models.Model):
     # Business methods
     ####################################################
 
-    def _prepare_holiday_values(self, employee):
+    def _prepare_holiday_values(self, employees):
         self.ensure_one()
-        values = {
+        return [{
             'name': self.name,
             'holiday_type': 'employee',
             'holiday_status_id': self.holiday_status_id.id,
@@ -486,23 +565,19 @@ class HolidaysAllocation(models.Model):
             'number_of_days': self.number_of_days,
             'parent_id': self.id,
             'employee_id': employee.id,
+            'state': 'confirm',
             'allocation_type': self.allocation_type,
             'date_from': self.date_from,
             'date_to': self.date_to,
-            'interval_unit': self.interval_unit,
-            'interval_number': self.interval_number,
-            'number_per_interval': self.number_per_interval,
-            'unit_per_interval': self.unit_per_interval,
-        }
-        return values
+            'accrual_plan_id': self.accrual_plan_id.id,
+        } for employee in employees]
 
     def action_draft(self):
         if any(holiday.state not in ['confirm', 'refuse'] for holiday in self):
             raise UserError(_('Allocation request state must be "Refused" or "To Approve" in order to be reset to Draft.'))
         self.write({
             'state': 'draft',
-            'first_approver_id': False,
-            'second_approver_id': False,
+            'approver_id': False,
         })
         linked_requests = self.mapped('linked_request_ids')
         if linked_requests:
@@ -518,29 +593,14 @@ class HolidaysAllocation(models.Model):
         self.activity_update()
         return res
 
-    def action_approve(self):
-        # if validation_type == 'both': this method is the first approval approval
-        # if validation_type != 'both': this method calls action_validate() below
-        if any(holiday.state != 'confirm' for holiday in self):
-            raise UserError(_('Allocation request must be confirmed ("To Approve") in order to approve it.'))
-
-        current_employee = self.env.user.employee_id
-
-        self.filtered(lambda hol: hol.validation_type == 'both').write({'state': 'validate1', 'first_approver_id': current_employee.id})
-        self.filtered(lambda hol: not hol.validation_type == 'both').action_validate()
-        self.activity_update()
-
     def action_validate(self):
         current_employee = self.env.user.employee_id
         for holiday in self:
-            if holiday.state not in ['confirm', 'validate1']:
+            if holiday.state != 'confirm':
                 raise UserError(_('Allocation request must be confirmed in order to approve it.'))
 
             holiday.write({'state': 'validate'})
-            if holiday.validation_type == 'both':
-                holiday.write({'second_approver_id': current_employee.id})
-            else:
-                holiday.write({'first_approver_id': current_employee.id})
+            holiday.write({'approver_id': current_employee.id})
 
             holiday._action_validate_create_childs()
         self.activity_update()
@@ -548,22 +608,26 @@ class HolidaysAllocation(models.Model):
 
     def _action_validate_create_childs(self):
         childs = self.env['hr.leave.allocation']
-        if self.state == 'validate' and self.holiday_type in ['category', 'department', 'company']:
-            if self.holiday_type == 'category':
+        # In the case we are in holiday_type `employee` and there is only one employee we can keep the same allocation
+        # Otherwise we do need to create an allocation for all employees to have a behaviour that is in line
+        # with the other holiday_type
+        if self.state == 'validate' and (self.holiday_type in ['category', 'department', 'company'] or
+            (self.holiday_type == 'employee' and len(self.employee_ids) > 1)):
+            if self.holiday_type == 'employee':
+                employees = self.employee_ids
+            elif self.holiday_type == 'category':
                 employees = self.category_id.employee_ids
             elif self.holiday_type == 'department':
                 employees = self.department_id.member_ids
             else:
                 employees = self.env['hr.employee'].search([('company_id', '=', self.mode_company_id.id)])
 
-            for employee in employees:
-                childs += self.with_context(
-                    mail_notify_force_send=False,
-                    mail_activity_automation_skip=True
-                ).create(self._prepare_holiday_values(employee))
-            # TODO is it necessary to interleave the calls?
-            childs.action_approve()
-            if childs and self.validation_type == 'both':
+            allocation_create_vals = self._prepare_holiday_values(employees)
+            childs += self.with_context(
+                mail_notify_force_send=False,
+                mail_activity_automation_skip=True
+            ).create(allocation_create_vals)
+            if childs and self.validation_type != 'no':
                 childs.action_validate()
         return childs
 
@@ -572,9 +636,7 @@ class HolidaysAllocation(models.Model):
         if any(holiday.state not in ['confirm', 'validate', 'validate1'] for holiday in self):
             raise UserError(_('Allocation request must be confirmed or validated in order to refuse it.'))
 
-        validated_holidays = self.filtered(lambda hol: hol.state == 'validate1')
-        validated_holidays.write({'state': 'refuse', 'first_approver_id': current_employee.id})
-        (self - validated_holidays).write({'state': 'refuse', 'second_approver_id': current_employee.id})
+        self.write({'state': 'refuse', 'approver_id': current_employee.id})
         # If a category that created several holidays, cancel all related
         linked_requests = self.mapped('linked_request_ids')
         if linked_requests:
@@ -622,6 +684,13 @@ class HolidaysAllocation(models.Model):
                 if not is_officer:
                     raise UserError(_('Only a Time off Approver can apply the second approval on allocation requests.'))
 
+    @api.onchange('allocation_type')
+    def _onchange_allocation_type(self):
+        if self.allocation_type == 'accrual':
+            self.number_of_days = 0.0
+        elif not self.number_of_days_display:
+            self.number_of_days = 1.0
+
     # ------------------------------------------------------------
     # Activity methods
     # ------------------------------------------------------------

--- a/addons/hr_holidays/models/hr_leave_type.py
+++ b/addons/hr_holidays/models/hr_leave_type.py
@@ -9,7 +9,6 @@ import logging
 from collections import defaultdict
 
 from odoo import api, fields, models
-from odoo.exceptions import ValidationError
 from odoo.osv import expression
 from odoo.tools.translate import _
 from odoo.tools.float_utils import float_round
@@ -26,10 +25,9 @@ class HolidaysType(models.Model):
     def _model_sorting_key(self, leave_type):
         remaining = leave_type.virtual_remaining_leaves > 0
         taken = leave_type.leaves_taken > 0
-        return -1*leave_type.sequence, leave_type.allocation_type == 'fixed' and remaining, leave_type.allocation_type == 'fixed_allocation' and remaining, taken
+        return -1*leave_type.sequence, leave_type.employee_requests == 'no' and remaining, leave_type.employee_requests == 'yes' and remaining, taken
 
     name = fields.Char('Time Off Type', required=True, translate=True)
-    code = fields.Char('Code')
     sequence = fields.Integer(default=100,
                               help='The type with the smallest sequence is the default value in time off request')
     create_calendar_meeting = fields.Boolean(string="Display Time Off in Calendar", default=True)
@@ -50,7 +48,9 @@ class HolidaysType(models.Model):
         ('lavender', 'Lavender'),
         ('wheat', 'Wheat'),
         ('ivory', 'Ivory')], string='Color in Report', required=True, default='red',
-        help='This color will be used in the time off summary located in Reporting > Time off by Department.')
+         help='This color will be used in the time off summary located in Reporting > Time off by Department.')
+    color = fields.Integer(string='Color', help="The color selected here will be used in every screen with the time off type.")
+    icon_id = fields.Many2one('ir.attachment', string='Cover Image', domain="[('res_model', '=', 'hr.leave.type'), ('res_field', '=', 'icon_id')]")
     active = fields.Boolean('Active', default=True,
                             help="If the active field is set to false, it will allow you to hide the time off type without removing it.")
     max_leaves = fields.Float(compute='_compute_leaves', string='Maximum Allowed', search='_search_max_leaves',
@@ -72,70 +72,86 @@ class HolidaysType(models.Model):
     group_days_leave = fields.Float(
         compute='_compute_group_days_leave', string='Group Time Off')
     company_id = fields.Many2one('res.company', string='Company', default=lambda self: self.env.company)
-    responsible_id = fields.Many2one('res.users', 'Responsible',
+    responsible_id = fields.Many2one(
+        'res.users', 'Responsible Time Off Officer',
         domain=lambda self: [('groups_id', 'in', self.env.ref('hr_holidays.group_hr_holidays_user').id)],
-        help="This user will be responsible for approving this type of time off. "
-        "This is only used when validation is 'By Time Off Officer' or 'By Employee's Manager and Time Off Officer'",)
+        help="Choose the Time Off Officer who will be notified to approve allocation or Time Off request")
     leave_validation_type = fields.Selection([
         ('no_validation', 'No Validation'),
         ('hr', 'By Time Off Officer'),
         ('manager', "By Employee's Approver"),
         ('both', "By Employee's Approver and Time Off Officer")], default='hr', string='Leave Validation')
+    requires_allocation = fields.Selection([
+        ('yes', 'Yes'),
+        ('no', 'No Limit')], default="yes", required=True, string='Requires allocation')
+    employee_requests = fields.Selection([
+        ('yes', 'Extra Days Requests Allowed'),
+        ('no', 'Not Allowed')], default="no", required=True, string="Employee Requests")
     allocation_validation_type = fields.Selection([
-        ('hr', 'By Time Off Officer'),
-        ('manager', "By Employee's Approver"),
-        ('both', "By Employee's Approver and Time Off Officer")], default='manager', string='Allocation Validation')
-    allocation_type = fields.Selection([
-        ('no', 'No Limit'),
-        ('fixed_allocation', 'Allow Employees Requests'),
-        ('fixed', 'Set by Time Off Officer')],
-        default='no', string='Mode',
-        help='\tNo Limit: no allocation by default, users can freely request time off; '
-             '\tAllow Employees Requests: allocated by HR and users can request time off and allocations; '
-             '\tSet by Time Off Officer: allocated by HR and cannot be bypassed; users can request time off;')
-    validity_start = fields.Date("From",
-                                 help='Adding validity to types of time off so that it cannot be selected outside this time period')
-    validity_stop = fields.Date("To")
-    valid = fields.Boolean(compute='_compute_valid', search='_search_valid', help='This indicates if it is still possible to use this type of leave')
+        ('no', 'No validation needed'),
+        ('officer', 'Approved by Time Off Officer'),
+        ('set', "Set by Time Off Officer")], default='officer', string='Approval')
+    has_valid_allocation = fields.Boolean(compute='_compute_valid', search='_search_valid', help='This indicates if it is still possible to use this type of leave')
     time_type = fields.Selection([('leave', 'Time Off'), ('other', 'Other')], default='leave', string="Kind of Leave",
                                  help="Whether this should be computed as a holiday or as work time (eg: formation)")
     request_unit = fields.Selection([
-        ('day', 'Day'), ('half_day', 'Half Day'), ('hour', 'Hours')],
-        default='day', string='Take Time Off in', required=True)
+        ('day', 'Day'),
+        ('half_day', 'Half Day'),
+        ('hour', 'Hours')], default='day', string='Take Time Off in', required=True)
     unpaid = fields.Boolean('Is Unpaid', default=False)
     leave_notif_subtype_id = fields.Many2one('mail.message.subtype', string='Time Off Notification Subtype', default=lambda self: self.env.ref('hr_holidays.mt_leave', raise_if_not_found=False))
     allocation_notif_subtype_id = fields.Many2one('mail.message.subtype', string='Allocation Notification Subtype', default=lambda self: self.env.ref('hr_holidays.mt_leave_allocation', raise_if_not_found=False))
     support_document = fields.Boolean(string='Supporting Document')
+    accruals_ids = fields.One2many('hr.leave.accrual.plan', 'time_off_type_id')
+    accrual_count = fields.Float(compute="_compute_accrual_count", string="Accruals count")
 
-    @api.constrains('validity_start', 'validity_stop')
-    def _check_validity_dates(self):
-        for leave_type in self:
-            if leave_type.validity_start and leave_type.validity_stop and \
-               leave_type.validity_start > leave_type.validity_stop:
-                raise ValidationError(_("End of validity period should be greater than start of validity period"))
 
-    @api.depends('validity_start', 'validity_stop')
-    def _compute_valid(self):
-        dt = self._context.get('default_date_from') or fields.Date.context_today(self)
+    @api.model
+    def _search_valid(self, operator, value):
+        """ Returns leave_type ids for which a valid allocation exists
+            or that don't need an allocation
+            return [('id', domain_operator, [x['id'] for x in res])]
+        """
+        date_to = self._context.get('default_date_from') or fields.Date.today().strftime('%Y-1-1')
+        date_from = self._context.get('default_date_to') or fields.Date.today().strftime('%Y-12-31')
 
-        for holiday_type in self:
-            if holiday_type.validity_start and holiday_type.validity_stop:
-                holiday_type.valid = ((dt < holiday_type.validity_stop) and (dt > holiday_type.validity_start))
-            elif holiday_type.validity_start and (dt > holiday_type.validity_start):
-                holiday_type.valid = False
-            else:
-                holiday_type.valid = True
+        if not isinstance(value, bool):
+            raise ValueError('Invalid value: %s' % (value))
+        if operator not in ['=', '!=']:
+            raise ValueError('Invalid operator: %s' % (operator))
+        new_operator = 'in' if operator == '=' else 'not in'
 
-    def _search_valid(self, operator, value):
-        dt = self._context.get('default_date_from', False)
+        query = '''
+        SELECT
+            holiday_status_id
+        FROM
+            hr_leave_allocation alloc
+        WHERE
+            alloc.date_to >= %s OR alloc.date_to IS NULL AND
+            alloc.date_from <= %s 
+        '''
 
-        if not dt:
-            return []
-        signs = ['>=', '<='] if operator == '=' else ['<=', '>=']
+        self._cr.execute(query, (date_to, date_from))
 
-        return ['|', ('validity_stop', operator, False), '&',
-                ('validity_stop', signs[0] if value else signs[1], dt),
-                ('validity_start', signs[1] if value else signs[0], dt)]
+        return [('id', new_operator, [x['holiday_status_id'] for x in self._cr.dictfetchall()])]
+
+
+    @api.depends('requires_allocation')
+    def _compute_valid(self):
+        date_to = self._context.get('default_date_to', fields.Datetime.today())
+        date_from = self._context.get('default_date_from', fields.Datetime.today())
+        for holiday_type in self:
+            if holiday_type.requires_allocation:
+                allocation = self.env['hr.leave.allocation'].search([
+                    ('holiday_status_id', '=', holiday_type.id),
+                    '|',
+                    ('date_to', '>=', date_to),
+                    '&',
+                    ('date_to', '=', False),
+                    ('date_from', '<=', date_from)])
+                holiday_type.has_valid_allocation = bool(allocation)
+            else:
+                holiday_type.has_valid_allocation = True
 
     def _search_max_leaves(self, operator, value):
         value = float(value)
@@ -172,7 +188,7 @@ class HolidaysType(models.Model):
         valid_leave_types = self.env['hr.leave.type']
 
         for leave_type in leave_types:
-            if leave_type.allocation_type != 'no':
+            if leave_type.requires_allocation == "yes":
                 if operator == '>' and leave_type.virtual_remaining_leaves > value:
                     valid_leave_types |= leave_type
                 elif operator == '<' and leave_type.virtual_remaining_leaves < value:
@@ -250,8 +266,7 @@ class HolidaysType(models.Model):
 
     @api.model
     def get_days_all_request(self):
-        leave_types = sorted(self.search([]).filtered(lambda x: ((not x.validity_stop or x.validity_stop >= fields.Date.today())
-                                                            and (x.virtual_remaining_leaves or x.max_leaves))), key=self._model_sorting_key, reverse=True)
+        leave_types = sorted(self.search([]).filtered(lambda x: ((x.virtual_remaining_leaves or x.max_leaves))), key=self._model_sorting_key, reverse=True)
         return [lt._get_days_request() for lt in leave_types]
 
     def _get_days_request(self):
@@ -263,7 +278,8 @@ class HolidaysType(models.Model):
                 'leaves_taken': ('%.2f' % self.leaves_taken).rstrip('0').rstrip('.'),
                 'virtual_leaves_taken': ('%.2f' % self.virtual_leaves_taken).rstrip('0').rstrip('.'),
                 'request_unit': self.request_unit,
-                }, self.allocation_type, self.validity_stop, self.id)
+                'icon': self.sudo().icon_id.url,
+                }, self.requires_allocation, self.id)
 
     def _get_contextual_employee_id(self):
         if 'employee_id' in self._context:
@@ -290,18 +306,16 @@ class HolidaysType(models.Model):
             holiday_status.virtual_leaves_taken = result.get('virtual_leaves_taken', 0)
 
     def _compute_group_days_allocation(self):
+        date_from = fields.Datetime.to_string(datetime.datetime.now().replace(month=1, day=1, hour=0, minute=0, second=0, microsecond=0))
         domain = [
             ('holiday_status_id', 'in', self.ids),
-            ('holiday_type', '!=', 'employee'),
             ('state', '=', 'validate'),
-        ]
-        domain2 = [
             '|',
-            ('date_from', '>=', fields.Datetime.to_string(datetime.datetime.now().replace(month=1, day=1, hour=0, minute=0, second=0, microsecond=0))),
+            ('date_from', '>=', date_from),
             ('date_from', '=', False),
         ]
         grouped_res = self.env['hr.leave.allocation'].read_group(
-            expression.AND([domain, domain2]),
+            domain,
             ['holiday_status_id', 'number_of_days'],
             ['holiday_status_id'],
         )
@@ -311,7 +325,7 @@ class HolidaysType(models.Model):
 
     def _compute_group_days_leave(self):
         grouped_res = self.env['hr.leave'].read_group(
-            [('holiday_status_id', 'in', self.ids), ('holiday_type', '=', 'employee'), ('state', '=', 'validate'),
+            [('holiday_status_id', 'in', self.ids), ('state', '=', 'validate'),
              ('date_from', '>=', fields.Datetime.to_string(datetime.datetime.now().replace(month=1, day=1, hour=0, minute=0, second=0, microsecond=0)))],
             ['holiday_status_id'],
             ['holiday_status_id'],
@@ -320,6 +334,12 @@ class HolidaysType(models.Model):
         for allocation in self:
             allocation.group_days_leave = grouped_dict.get(allocation.id, 0)
 
+    def _compute_accrual_count(self):
+        accrual_allocations = self.env['hr.leave.allocation'].read_group([('employee_id', '!=', False), ('accrual_plan_id', '!=', False), ('state', '=', 'validate')], ['id'], ['holiday_status_id'])
+        mapped_data = dict((data['holiday_status_id'][0], data['holiday_status_id_count']) for data in accrual_allocations)
+        for leave_type in self:
+            leave_type.accrual_count = mapped_data.get(leave_type.id, 0)
+
     def name_get(self):
         if not self._context.get('employee_id'):
             # leave counts is based on employee_id, would be inaccurate if not based on correct employee
@@ -327,7 +347,7 @@ class HolidaysType(models.Model):
         res = []
         for record in self:
             name = record.name
-            if record.allocation_type != 'no':
+            if record.requires_allocation == "yes":
                 name = "%(name)s (%(count)s)" % {
                     'name': name,
                     'count': _('%g remaining out of %g') % (
@@ -362,16 +382,14 @@ class HolidaysType(models.Model):
     def action_see_days_allocated(self):
         self.ensure_one()
         action = self.env["ir.actions.actions"]._for_xml_id("hr_holidays.hr_leave_allocation_action_all")
-        domain = [
+        date_from = fields.Datetime.to_string(
+                datetime.datetime.now().replace(month=1, day=1, hour=0, minute=0, second=0, microsecond=0))
+        action['domain'] = [
             ('holiday_status_id', 'in', self.ids),
-            ('holiday_type', '!=', 'employee'),
-        ]
-        domain2 = [
             '|',
-            ('date_from', '>=', fields.Datetime.to_string(datetime.datetime.now().replace(month=1, day=1, hour=0, minute=0, second=0, microsecond=0))),
+            ('date_from', '>=', date_from),
             ('date_from', '=', False),
         ]
-        action['domain'] = expression.AND([domain, domain2])
         action['context'] = {
             'default_holiday_type': 'department',
             'default_holiday_status_id': self.ids[0],
@@ -389,3 +407,10 @@ class HolidaysType(models.Model):
             'default_holiday_status_id': self.ids[0],
         }
         return action
+
+    def action_see_accrual_plans(self):
+        self.ensure_one()
+        action = self.env["ir.actions.actions"]._for_xml_id("hr.holidays.open_view_accrual_plans")
+        action['context'] = {
+            'default_time_off_type_id': self.id,
+        }
