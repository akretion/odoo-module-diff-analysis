PR: https://github.com/odoo/odoo/pull/

From: cd05983121e4edef7db8d46b7e29585857d03a80
From: Kinjal Mehta
Date: 2017-08-14 07:21:50

Structural Changes: 10
Total Changes: 34

[IMP] survey: ease use of "Date" questions

- ask questions about "Dates", not "Datetimes" anymore
- display dates according to website language

Thanks to Kinjal Mehta and Ravi Gadhia who contributed to this commit.

================================= pseudo patch: =================================

--- a/addons/survey/models/survey.py
+++ b/addons/survey/models/survey.py
@@ -7,13 +7,11 @@ import re
 import uuid
 from collections import Counter, OrderedDict
 from itertools import product
-
 from werkzeug import urls
 
 from odoo import api, fields, models, tools, SUPERUSER_ID, _
 from odoo.addons.http_routing.models.ir_http import slug
 from odoo.exceptions import UserError, ValidationError
-
 from odoo.tools import pycompat
 
 email_validator = re.compile(r"[^@]+@[^@]+\.[^@]+")
@@ -258,8 +256,8 @@ class Survey(models.Model):
                     comments.append(input_line)
             result_summary = {'answers': answers, 'rows': rows, 'result': res, 'comments': comments}
 
-        # Calculate and return statistics for free_text, textbox, datetime
-        if question.type in ['free_text', 'textbox', 'datetime']:
+        # Calculate and return statistics for free_text, textbox, date
+        if question.type in ['free_text', 'textbox', 'date']:
             result_summary = []
             for input_line in question.user_input_line_ids:
                 if not(current_filters) or input_line.user_input_id.id in current_filters:
@@ -442,7 +440,7 @@ class SurveyQuestion(models.Model):
             ('free_text', 'Multiple Lines Text Box'),
             ('textbox', 'Single Line Text Box'),
             ('numerical_box', 'Numerical Value'),
-            ('datetime', 'Date and Time'),
+            ('date', 'Date'),
             ('simple_choice', 'Multiple choice: only one answer'),
             ('multiple_choice', 'Multiple choice: multiple answers allowed'),
             ('matrix', 'Matrix')], string='Type of Question', default='free_text', required=True)
@@ -483,8 +481,8 @@ class SurveyQuestion(models.Model):
     validation_length_max = fields.Integer('Maximum Text Length')
     validation_min_float_value = fields.Float('Minimum value')
     validation_max_float_value = fields.Float('Maximum value')
-    validation_min_date = fields.Datetime('Minimum Date')
-    validation_max_date = fields.Datetime('Maximum Date')
+    validation_min_date = fields.Date('Minimum Date')
+    validation_max_date = fields.Date('Maximum Date')
     validation_error_msg = fields.Char('Validation Error message', oldname='validation_valid_err_msg',
                                         translate=True, default=lambda self: _("The answer you entered has an invalid format."))
 
@@ -577,28 +575,28 @@ class SurveyQuestion(models.Model):
         return errors
 
     @api.multi
-    def validate_datetime(self, post, answer_tag):
+    def validate_date(self, post, answer_tag):
         self.ensure_one()
         errors = {}
         answer = post[answer_tag].strip()
         # Empty answer to mandatory question
         if self.constr_mandatory and not answer:
             errors.update({answer_tag: self.constr_error_msg})
-        # Checks if user input is a datetime
+        # Checks if user input is a date
         if answer:
             try:
-                dateanswer = fields.Datetime.from_string(answer)
+                dateanswer = fields.Date.from_string(answer)
             except ValueError:
-                errors.update({answer_tag: _('This is not a date/time')})
+                errors.update({answer_tag: _('This is not a date')})
                 return errors
         # Answer validation (if properly defined)
         if answer and self.validation_required:
             # Answer is not in the right range
             try:
-                datetime_from_string = fields.Datetime.from_string
-                dateanswer = datetime_from_string(answer)
-                min_date = datetime_from_string(self.validation_min_date)
-                max_date = datetime_from_string(self.validation_max_date)
+                date_from_string = fields.Date.from_string
+                dateanswer = date_from_string(answer)
+                min_date = date_from_string(self.validation_min_date)
+                max_date = date_from_string(self.validation_max_date)
 
                 if min_date and max_date and not (min_date <= dateanswer <= max_date):
                     # If Minimum and Maximum Date are entered
@@ -609,7 +607,7 @@ class SurveyQuestion(models.Model):
                 elif max_date and not dateanswer <= max_date:
                     # If only Maximum Date is entered and not Define Minimum Date
                     errors.update({answer_tag: self.validation_error_msg})
-            except ValueError:  # check that it is a datetime has been done hereunder
+            except ValueError:  # check that it is a date has been done hereunder
                 pass
         return errors
 
@@ -797,7 +795,7 @@ class SurveyUserInputLine(models.Model):
         ('suggestion', 'Suggestion')], string='Answer Type')
     value_text = fields.Char('Text answer')
     value_number = fields.Float('Numerical answer')
-    value_date = fields.Datetime('Date answer')
+    value_date = fields.Date('Date answer')
     value_free_text = fields.Text('Free Text answer')
     value_suggested = fields.Many2one('survey.label', string="Suggested answer")
     value_suggested_row = fields.Many2one('survey.label', string="Row answer")
@@ -926,7 +924,7 @@ class SurveyUserInputLine(models.Model):
         return True
 
     @api.model
-    def save_line_datetime(self, user_input_id, question, post, answer_tag):
+    def save_line_date(self, user_input_id, question, post, answer_tag):
         vals = {
             'user_input_id': user_input_id,
             'question_id': question.id,
