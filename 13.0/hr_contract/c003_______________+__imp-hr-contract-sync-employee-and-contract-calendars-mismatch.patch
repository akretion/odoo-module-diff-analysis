PR: https://github.com/odoo/odoo/pull/

From: 22437e331a60c81a80d619c075a9d516e980c078
From: Lucas LefÃ¨vre
Date: 2019-06-13 08:02:10

Structural Changes: 3
Total Changes: 63

[IMP] hr_contract: Sync employee and contract calendars mismatch

Purpose
=======

An employee and its current contract should have the same
calendar. Currently, if the contract's calendar is changed,
the employee's calendar is not changed.
In the same way, if a contract is created directly in `open`
state, the employee's calendar is not changed.
Finally, the calendar synchronization when the employee
contract is changed is only done in payroll, for no reason.

Specification
=============

Fix the three issues described above.

If the employee's calendar is nonetheless manually changed, a warning
should be displayed if there is a mismatch between both calendars.

================================= pseudo patch: =================================

--- a/addons/hr_contract/models/__init__.py
+++ b/addons/hr_contract/models/__init__.py
@@ -4,3 +4,4 @@
 from . import hr_employee
 from . import hr_contract
 from . import res_users
+from . import resource

--- a/addons/hr_contract/models/hr_contract.py
+++ b/addons/hr_contract/models/hr_contract.py
@@ -47,6 +47,12 @@ class Contract(models.Model):
     visa_expire = fields.Date('Visa Expire Date', related="employee_id.visa_expire", readonly=False)
     hr_responsible_id = fields.Many2one('res.users', 'HR Responsible', tracking=True,
         help='Person responsible for validating the employee\'s contracts.')
+    calendar_mismatch = fields.Boolean(compute='_compute_calendar_mismatch')
+
+    @api.depends('employee_id.resource_calendar_id', 'resource_calendar_id')
+    def _compute_calendar_mismatch(self):
+        for contract in self:
+            contract.calendar_mismatch = contract.resource_calendar_id != contract.employee_id.resource_calendar_id
 
     def _expand_states(self, states, domain, order):
         return [key for key, val in type(self).state.selection]
@@ -113,12 +119,28 @@ class Contract(models.Model):
         })
         return True
 
+    @api.model
+    def create(self, vals_list):
+        contracts = super().create(vals_list)
+        open_contracts = contracts.filtered(lambda c: c.state in ['open', 'pending'])
+        # sync contract -> employee
+        for contract in open_contracts:
+            contract.employee_id.contract_id = contract
+        # sync contract calendar -> calendar employee
+        for contract in open_contracts.filtered(lambda c: c.resource_calendar_id):
+            contract.employee_id.resource_calendar_id = contract.resource_calendar_id
+        return contracts
+
     @api.multi
     def write(self, vals):
+        res = super(Contract, self).write(vals)
         if vals.get('state') == 'open':
             for contract in self:
                 contract.employee_id.sudo().write({'contract_id': contract.id})
-        return super(Contract, self).write(vals)
+        calendar = vals.get('resource_calendar_id')
+        if calendar and self.state in ['open', 'pending']:
+            self.mapped('employee_id').write({'resource_calendar_id': calendar})
+        return res
 
     @api.multi
     def _track_subtype(self, init_values):

--- a/addons/hr_contract/models/hr_employee.py
+++ b/addons/hr_contract/models/hr_employee.py
@@ -12,6 +12,7 @@ class Employee(models.Model):
     contract_ids = fields.One2many('hr.contract', 'employee_id', string='Employee Contracts')
     contract_id = fields.Many2one('hr.contract', string='Current Contract',
         groups="hr.group_hr_user", help='Current contract of the employee')
+    calendar_mismatch = fields.Boolean(related='contract_id.calendar_mismatch')
     contracts_count = fields.Integer(compute='_compute_contracts_count', string='Contract Count')
 
     def _compute_contracts_count(self):
@@ -39,3 +40,11 @@ class Employee(models.Model):
         Returns the contracts of all employees between date_from and date_to
         """
         return self.search([])._get_contracts(date_from, date_to, states=states)
+
+    def write(self, vals):
+        res = super(Employee, self).write(vals)
+        if vals.get('contract_id'):
+            for employee in self:
+                employee.resource_calendar_id.transfer_leaves_to(employee.contract_id.resource_calendar_id, employee.resource_id)
+                employee.resource_calendar_id = employee.contract_id.resource_calendar_id
+        return res

--- a/None
+++ b/addons/hr_contract/models/resource.py
@@ -0,0 +1,29 @@
+# -*- coding:utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+from datetime import datetime
+
+from odoo import models, fields, api
+from odoo.osv.expression import AND
+
+
+class ResourceCalendar(models.Model):
+    _inherit = 'resource.calendar'
+
+    @api.multi
+    def transfer_leaves_to(self, other_calendar, resources=None, from_date=None):
+        """
+            Transfer some resource.calendar.leaves from 'self' to another calendar 'other_calendar'.
+            Transfered leaves linked to `resources` (or all if `resources` is None) and starting
+            after 'from_date' (or today if None).
+        """
+        from_date = from_date or fields.Datetime.now().replace(hour=0, minute=0, second=0, microsecond=0)
+        domain = [
+            ('calendar_id', 'in', self.ids),
+            ('date_from', '>=', from_date),
+        ]
+        domain = AND([domain, [('resource_id', 'in', resources.ids)]]) if resources else domain
+
+        self.env['resource.calendar.leaves'].search(domain).write({
+            'calendar_id': other_calendar.id,
+        })
+
