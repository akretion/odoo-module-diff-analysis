PR: https://github.com/odoo/odoo/pull/

From: ba070781b897a856e2f1d6cc9f735ee5da394e9d
From: Martin Trigaux
Date: 2016-09-08 14:37:01

Structural Changes: 5
Total Changes: 104

[FIX] point_of_sale: restored removed report

The sale of the day report was removed during new api migration as it was
thought, it could be replaced by pivot view.
Due to the lack of some options and the problems to be printed, create similar
report.

This commit adds a report in the PoS interface to be printed on ESC/POS printers
and add a JS wizard to restore it in the backend with date selection.

The wizard is made in a new web widget because adding a wizard requires changes
not compatible with stable version.
Creating a proper wizard should be done in v10

opw-681833

================================= pseudo patch: =================================

--- a/addons/point_of_sale/models/pos_order.py
+++ b/addons/point_of_sale/models/pos_order.py
@@ -1,6 +1,7 @@
 # -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 import logging
+from datetime import timedelta
 from functools import partial
 
 import psycopg2
@@ -8,7 +9,7 @@ import psycopg2
 from odoo import api, fields, models, tools, _
 from odoo.tools import float_is_zero
 from odoo.exceptions import UserError
-
+from odoo.http import request
 import odoo.addons.decimal_precision as dp
 
 _logger = logging.getLogger(__name__)
@@ -733,3 +734,104 @@ class PosOrderLine(models.Model):
     def _get_tax_ids_after_fiscal_position(self):
         for line in self:
             line.tax_ids_after_fiscal_position = line.order_id.fiscal_position_id.map_tax(line.tax_ids)
+
+
+class ReportSaleDetails(models.AbstractModel):
+
+    _name = 'report.point_of_sale.report_saledetails'
+
+
+    @api.model
+    def get_sale_details(self, date_start=False, date_stop=False, company=False):
+        """ Serialise the orders of the day information
+
+        params: date_start, date_stop string representing the day of order
+        """
+        if not company:
+            company = self.env.user.company_id
+
+        today = fields.Datetime.from_string(fields.Date.context_today(self))
+        if date_start:
+            date_start = fields.Datetime.from_string(date_start)
+        else:
+            # start by default today 00:00:00
+            date_start = today
+
+        if date_stop:
+            # set time to 23:59:59
+            date_stop = fields.Datetime.from_string(date_stop) + timedelta(days=1, seconds=-1)
+        else:
+            # stop by default today 23:59:59
+            date_stop = today + timedelta(days=1, seconds=-1)
+
+        # avoid a date_stop smaller than date_start
+        date_stop = max(date_stop, date_start)
+
+        date_start = fields.Datetime.to_string(date_start)
+        date_stop = fields.Datetime.to_string(date_stop)
+        orders = self.env['pos.order'].search([('date_order', '>=', date_start), ('date_order', '<=', date_stop),
+                              ('state', 'in', ['paid','invoiced','done']),
+                              ('company_id', '=', company.id)])
+        user_currency = self.env.user.company_id.currency_id
+
+        total = 0.0
+        products_sold = {}
+        taxes = {}
+        for order in orders:
+            if user_currency != order.pricelist_id.currency_id:
+                total += order.pricelist_id.currency_id.compute(order.amount_total, user_currency)
+            else:
+                total += order.amount_total
+            currency = order.session_id.currency_id
+
+            for line in order.lines:
+                key = (line.product_id, line.price_unit, line.discount)
+                products_sold.setdefault(key, 0.0)
+                products_sold[key] += line.qty
+
+                if line.tax_ids_after_fiscal_position:
+                    line_taxes = line.tax_ids_after_fiscal_position.compute_all(line.price_unit * (1-(line.discount or 0.0)/100.0), currency, line.qty, product=line.product_id, partner=line.order_id.partner_id or False)
+                    for tax in line_taxes['taxes']:
+                        taxes.setdefault(tax['id'], {'name': tax['name'], 'total':0.0})
+                        taxes[tax['id']]['total'] += tax['amount']
+
+        st_line_ids = self.env["account.bank.statement.line"].search([('pos_statement_id', 'in', orders.ids)]).ids
+        if st_line_ids:
+            self.env.cr.execute("""
+                SELECT aj.name, sum(amount) total
+                FROM account_bank_statement_line AS absl,
+                     account_bank_statement AS abs,
+                     account_journal AS aj 
+                WHERE absl.statement_id = abs.id
+                    AND abs.journal_id = aj.id 
+                    AND absl.id IN %s 
+                GROUP BY aj.name
+            """, (tuple(st_line_ids),))
+            payments = self.env.cr.dictfetchall()
+        else:
+            payments = []
+
+        return {
+            'total_paid': user_currency.round(total),
+            'payments': payments,
+            'company_name': self.env.user.company_id.name,
+            'taxes': taxes.values(),
+            'products': [{
+                'product_id': product.id,
+                'product_name': product.name[:20],
+                'code': product.default_code,
+                'quantity': qty,
+                'price_unit': price_unit,
+                'discount': discount,
+                'uom': product.uom_id.name
+            } for (product, price_unit, discount), qty in products_sold.items()]
+        }
+
+    @api.multi
+    def render_html(self, data=None):
+        company = request.env.user.company_id
+        date_start = self.env.context.get('date_start', False)
+        date_stop = self.env.context.get('date_stop', False)
+        data = dict(data or {}, date_start=date_start, date_stop=date_stop)
+        data.update(self.get_sale_details(date_start, date_stop, company))
+        return self.env['report'].render('point_of_sale.report_saledetails', data)
\ No newline at end of file
