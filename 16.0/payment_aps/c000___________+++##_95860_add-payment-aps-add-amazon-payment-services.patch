PR: https://github.com/odoo/odoo/pull/95860

From: 5ac27efc723f6a48805a5d1a7562801731162701
From: Laura Schauer
Date: 2022-08-17 15:20:49

Structural Changes: 8
Total Changes: 230

[ADD] payment_aps: add Amazon Payment Services

See README for technical details.

task-2802678

Part-of: odoo/odoo#95860

================================= pseudo patch: =================================

--- a/None
+++ b/addons/payment_aps/models/__init__.py
@@ -0,0 +1,5 @@
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from . import account_payment_method
+from . import payment_acquirer
+from . import payment_transaction

--- a/None
+++ b/addons/payment_aps/models/account_payment_method.py
@@ -0,0 +1,13 @@
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from odoo import api, models
+
+
+class AccountPaymentMethod(models.Model):
+    _inherit = 'account.payment.method'
+
+    @api.model
+    def _get_payment_method_information(self):
+        res = super()._get_payment_method_information()
+        res['aps'] = {'mode': 'unique', 'domain': [('type', '=', 'bank')]}
+        return res

--- a/None
+++ b/addons/payment_aps/models/payment_acquirer.py
@@ -0,0 +1,75 @@
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+import hashlib
+import logging
+
+from odoo import fields, models
+
+
+_logger = logging.getLogger(__name__)
+
+
+class PaymentAcquirer(models.Model):
+    _inherit = 'payment.acquirer'
+
+    provider = fields.Selection(
+        selection_add=[('aps', "Amazon Payment Services")], ondelete={'aps': 'set default'}
+    )
+    aps_merchant_identifier = fields.Char(
+        string="APS Merchant Identifier",
+        help="The code of the merchant account to use with this acquirer.",
+        required_if_provider='aps',
+    )
+    aps_access_code = fields.Char(
+        string="APS Access Code",
+        help="The access code associated with the merchant account.",
+        required_if_provider='aps',
+        groups='base.group_system',
+    )
+    aps_sha_request = fields.Char(
+        string="APS SHA Request Phrase",
+        required_if_provider='aps',
+        groups='base.group_system',
+    )
+    aps_sha_response = fields.Char(
+        string="APS SHA Response Phrase",
+        required_if_provider='aps',
+        groups='base.group_system',
+    )
+
+    #=== BUSINESS METHODS ===#
+
+    def _aps_get_api_url(self):
+        if self.state == 'enabled':
+            return 'https://checkout.payfort.com/FortAPI/paymentPage'
+        else:  # 'test'
+            return 'https://sbcheckout.payfort.com/FortAPI/paymentPage'
+
+    def _aps_calculate_signature(self, data, incoming=True):
+        """ Compute the signature for the provided data according to the APS documentation.
+
+        :param dict data: The data to sign.
+        :param bool incoming: Whether the signature must be generated for an incoming (APS to Odoo)
+                              or outgoing (Odoo to APS) communication.
+        :return: The calculated signature.
+        :rtype: str
+        """
+        sign_data = ''.join([f'{k}={v}' for k, v in sorted(data.items()) if k != 'signature'])
+        key = self.aps_sha_response if incoming else self.aps_sha_request
+        signing_string = ''.join([key, sign_data, key])
+        return hashlib.sha256(signing_string.encode()).hexdigest()
+
+    def _get_default_payment_method_id(self):
+        self.ensure_one()
+        if self.provider != 'aps':
+            return super()._get_default_payment_method_id()
+        return self.env.ref('payment_aps.payment_method_aps').id
+
+    def _neutralize(self):
+        super()._neutralize()
+        self._neutralize_fields('aps', [
+            'aps_merchant_identifier',
+            'aps_access_code',
+            'aps_sha_request',
+            'aps_sha_response',
+        ])

--- a/None
+++ b/addons/payment_aps/models/payment_transaction.py
@@ -0,0 +1,137 @@
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+import logging
+
+from werkzeug import urls
+
+from odoo import _, api, models
+from odoo.exceptions import ValidationError
+
+from odoo.addons.payment import utils as payment_utils
+from odoo.addons.payment_aps.const import PAYMENT_STATUS_MAPPING
+from odoo.addons.payment_aps.controllers.main import APSController
+
+
+_logger = logging.getLogger(__name__)
+
+
+class PaymentTransaction(models.Model):
+    _inherit = 'payment.transaction'
+
+    @api.model
+    def _compute_reference(self, provider, prefix=None, separator='-', **kwargs):
+        """ Override of `payment` to ensure that APS' requirements for references are satisfied.
+
+        APS' requirements for transaction are as follows:
+        - References can only be made of alphanumeric characters and/or '-' and '_'.
+          The prefix is generated with 'tx' as default. This prevents the prefix from being
+          generated based on document names that may contain non-allowed characters
+          (eg: INV/2020/...).
+
+        :param str provider: The provider of the acquirer handling the transaction.
+        :param str prefix: The custom prefix used to compute the full reference.
+        :param str separator: The custom separator used to separate the prefix from the suffix.
+        :return: The unique reference for the transaction.
+        :rtype: str
+        """
+        if provider == 'aps':
+            prefix = payment_utils.singularize_reference_prefix()
+
+        return super()._compute_reference(provider, prefix=prefix, separator=separator, **kwargs)
+
+    def _get_specific_rendering_values(self, processing_values):
+        """ Override of `payment` to return APS-specific processing values.
+
+        Note: self.ensure_one() from `_get_processing_values`
+
+        :param dict processing_values: The generic processing values of the transaction.
+        :return: The dict of acquirer-specific processing values.
+        :rtype: dict
+        """
+        res = super()._get_specific_rendering_values(processing_values)
+        if self.provider != 'aps':
+            return res
+
+        converted_amount = payment_utils.to_minor_currency_units(self.amount, self.currency_id)
+        base_url = self.acquirer_id.get_base_url()
+        rendering_values = {
+            'command': 'PURCHASE',
+            'access_code': self.acquirer_id.aps_access_code,
+            'merchant_identifier': self.acquirer_id.aps_merchant_identifier,
+            'merchant_reference': self.reference,
+            'amount': str(converted_amount),
+            'currency': self.currency_id.name,
+            'language': self.partner_lang[:2],
+            'customer_email': self.partner_id.email_normalized,
+            'return_url': urls.url_join(base_url, APSController._return_url),
+        }
+        rendering_values.update({
+            'signature': self.acquirer_id._aps_calculate_signature(
+                rendering_values, incoming=False
+            ),
+            'api_url': self.acquirer_id._aps_get_api_url(),
+        })
+        return rendering_values
+
+    def _get_tx_from_notification_data(self, provider, notification_data):
+        """ Override of `payment` to find the transaction based on APS data.
+
+        :param str provider: The provider of the acquirer that handled the transaction.
+        :param dict notification_data: The notification data sent by the provider.
+        :return: The transaction if found.
+        :rtype: recordset of `payment.transaction`
+        :raise ValidationError: If inconsistent data are received.
+        :raise ValidationError: If the data match no transaction.
+        """
+        tx = super()._get_tx_from_notification_data(provider, notification_data)
+        if provider != 'aps' or len(tx) == 1:
+            return tx
+
+        reference = notification_data.get('merchant_reference')
+        if not reference:
+            raise ValidationError(
+                "APS: " + _("Received data with missing reference %(ref)s.", ref=reference)
+            )
+
+        tx = self.search([('reference', '=', reference), ('provider', '=', 'aps')])
+        if not tx:
+            raise ValidationError(
+                "APS: " + _("No transaction found matching reference %s.", reference)
+            )
+
+        return tx
+
+    def _process_notification_data(self, notification_data):
+        """ Override of `payment' to process the transaction based on APS data.
+
+        Note: self.ensure_one()
+
+        :param dict notification_data: The notification data sent by the provider.
+        :return: None
+        :raise ValidationError: If inconsistent data are received.
+        """
+        super()._process_notification_data(notification_data)
+        if self.provider != 'aps':
+            return
+
+        self.acquirer_reference = notification_data.get('fort_id')
+
+        status = notification_data.get('status')
+        if not status:
+            raise ValidationError("APS: " + _("Received data with missing payment state."))
+
+        if status in PAYMENT_STATUS_MAPPING['pending']:
+            self._set_pending()
+        elif status in PAYMENT_STATUS_MAPPING['done']:
+            self._set_done()
+        else:  # Classify unsupported payment state as `error` tx state.
+            status_description = notification_data.get('response_message')
+            _logger.info(
+                "Received data with invalid payment status (%(status)s) and reason '%(reason)s' "
+                "for transaction with reference %(ref)s",
+                {'status': status, 'reason': status_description, 'ref': self.reference},
+            )
+            self._set_error("APS: " + _(
+                "Received invalid transaction status %(status)s and reason '%(reason)s'.",
+                status=status, reason=status_description
+            ))
