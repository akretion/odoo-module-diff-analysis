PR: https://github.com/odoo/odoo/pull/

From: 98ee15977a3d9d84d41a98b8d74cf3a7f7b96b78
From: Olivier Colson
Date: 2018-03-28 11:45:47

Structural Changes: 1
Total Changes: 95

[IMP] stock_account, anglo-saxon accounting: help to clear out interim accounts

Accounting entries made for invoices and stock valuation on the interim accounts (stock input/output accounts) are now reconciled together for both sales and purchases. This will definitively help to have those accounts zero-outed when all operations are processed.

The reconciliation is made as long as the stock valuation is set in real-time, whatever the costing method.

Note that change change also allow a particular use case to be solved: when a purchase is made in a foreign currency whose rate change between the incoming shipment reception and the bill validation (there will be an automated exchange rate entry created).

Was task 32331. Was PR #22483

================================= pseudo patch: =================================

--- a/addons/stock_account/models/account_invoice.py
+++ b/addons/stock_account/models/account_invoice.py
@@ -38,6 +38,56 @@ class AccountInvoice(models.Model):
 
         return self.env['product.product']._anglo_saxon_sale_move_lines(i_line.name, i_line.product_id, i_line.uom_id, i_line.quantity, price_unit, currency=currency, amount_currency=amount_currency, fiscal_position=inv.fiscal_position_id, account_analytic=i_line.account_analytic_id, analytic_tags=i_line.analytic_tag_ids)
 
+    def _get_last_step_stock_moves(self):
+        """ To be overridden for customer invoices and vendor bills in order to
+        return the stock moves related to the invoices in self.
+        """
+        return self.env['stock.move']
+
+    def _get_products_set(self):
+        """ Returns a recordset of the products contained in this invoice's lines """
+        return self.mapped('invoice_line_ids.product_id')
+
+    def _get_anglosaxon_interim_account(self, product):
+        """ Returns the interim account used in anglosaxon accounting for
+        this invoice"""
+        if self.type in ('out_invoice', 'out_refund'):
+            return product.product_tmpl_id._get_product_accounts()['stock_output']
+        return product.product_tmpl_id.get_product_accounts()['stock_input']
+
+    def invoice_validate(self):
+        res = super(AccountInvoice, self).invoice_validate()
+        self.filtered(lambda i: i.company_id.anglo_saxon_accounting)._anglo_saxon_reconcile_valuation()
+        return res
+
+    def _anglo_saxon_reconcile_valuation(self, product=False):
+        """ Reconciles the entries made in the interim accounts in anglosaxon accounting,
+        reconciling stock valuation move lines with the invoice's.
+        """
+        for invoice in self:
+            if invoice.company_id.anglo_saxon_accounting:
+                stock_moves = invoice._get_last_step_stock_moves()
+                product_set = product or invoice._get_products_set()
+                for prod in product_set:
+                    if prod.valuation == 'real_time' and stock_moves:
+                        # We first get the invoices move lines (taking the invoice and the previous ones into account)...
+                        product_interim_account = invoice._get_anglosaxon_interim_account(prod)
+                        to_reconcile = self.env['account.move.line'].search([
+                            ('move_id', '=', invoice.move_id.id),
+                            ('product_id', '=', prod.id),
+                            ('account_id','=', product_interim_account.id),
+                            ('reconciled','=', False)
+                        ])
+
+                        # And then the stock valuation ones.
+                        product_stock_moves = stock_moves.filtered(lambda s: s.product_id.id == prod.id)
+                        for valuation_line in product_stock_moves.mapped('account_move_ids.line_ids'):
+                            if valuation_line.account_id == product_interim_account and not valuation_line.reconciled:
+                                to_reconcile += valuation_line
+
+                        if to_reconcile:
+                            to_reconcile.reconcile()
+
 
 class AccountInvoiceLine(models.Model):
     _inherit = "account.invoice.line"

--- a/addons/stock_account/models/account_move.py
+++ b/addons/stock_account/models/account_move.py
@@ -1,10 +1,12 @@
 # -*- coding: utf-8 -*-
 
-from odoo import fields, models
+from odoo import fields, models, _
 
+from odoo.tools.float_utils import float_is_zero
+
+from odoo.exceptions import UserError
 
 class AccountMove(models.Model):
     _inherit = 'account.move'
 
     stock_move_id = fields.Many2one('stock.move', string='Stock Move')
-

--- a/addons/stock_account/models/stock.py
+++ b/addons/stock_account/models/stock.py
@@ -71,7 +71,7 @@ class StockMoveLine(models.Model):
             if move.product_id.valuation == 'real_time' and (move._is_in() or move._is_out()):
                 move.with_context(force_valuation_amount=correction_value)._account_entry_move()
         return res
-    
+
     @api.multi
     def write(self, vals):
         if 'qty_done' in vals:
@@ -489,7 +489,7 @@ class StockMove(models.Model):
             raise UserError(_('You don\'t have any stock valuation account defined on your product category. You must define one before processing this operation.'))
         journal_id = accounts_data['stock_journal'].id
         return journal_id, acc_src, acc_dest, acc_valuation
-    
+
     def _prepare_account_move_line(self, qty, cost, credit_account_id, debit_account_id):
         """
         Generate the account.move.line values to post to track the stock valuation difference due to the
@@ -522,7 +522,16 @@ class StockMove(models.Model):
             if self.location_id.usage == 'customer' and self.origin_returned_move_id:
                 debit_value = self.origin_returned_move_id.price_unit * qty
                 credit_value = debit_value
-        partner_id = (self.picking_id.partner_id and self.env['res.partner']._find_accounting_partner(self.picking_id.partner_id).id) or False
+
+        valuation_partner_id = self._get_partner_id_for_valuation_lines()
+        res = [(0, 0, line_vals) for line_vals in self._generate_valuation_lines_data(valuation_partner_id, qty, debit_value, credit_value, debit_account_id, credit_account_id).values()]
+
+        return res
+
+    def _generate_valuation_lines_data(self, partner_id, qty, debit_value, credit_value, debit_account_id, credit_account_id):
+        # This method returns a dictonary to provide an easy extension hook to modify the valuation lines (see purchase for an example)
+        self.ensure_one()
+
         debit_line_vals = {
             'name': self.name,
             'product_id': self.product_id.id,
@@ -534,6 +543,7 @@ class StockMove(models.Model):
             'credit': -debit_value if debit_value < 0 else 0,
             'account_id': debit_account_id,
         }
+
         credit_line_vals = {
             'name': self.name,
             'product_id': self.product_id.id,
@@ -545,16 +555,19 @@ class StockMove(models.Model):
             'debit': -credit_value if credit_value < 0 else 0,
             'account_id': credit_account_id,
         }
-        res = [(0, 0, debit_line_vals), (0, 0, credit_line_vals)]
+
+        rslt = {'credit_line_vals': credit_line_vals, 'debit_line_vals': debit_line_vals}
         if credit_value != debit_value:
             # for supplier returns of product in average costing method, in anglo saxon mode
             diff_amount = debit_value - credit_value
             price_diff_account = self.product_id.property_account_creditor_price_difference
+
             if not price_diff_account:
                 price_diff_account = self.product_id.categ_id.property_account_creditor_price_difference_categ
             if not price_diff_account:
                 raise UserError(_('Configuration error. Please configure the price difference account on the product or its category to process this operation.'))
-            price_diff_line = {
+
+            rslt['price_diff_line_vals'] = {
                 'name': self.name,
                 'product_id': self.product_id.id,
                 'quantity': qty,
@@ -565,8 +578,10 @@ class StockMove(models.Model):
                 'debit': diff_amount < 0 and -diff_amount or 0,
                 'account_id': price_diff_account.id,
             }
-            res.append((0, 0, price_diff_line))
-        return res
+        return rslt
+
+    def _get_partner_id_for_valuation_lines(self):
+        return (self.picking_id.partner_id and self.env['res.partner']._find_accounting_partner(self.picking_id.partner_id).id) or False
 
     def _create_account_move_line(self, credit_account_id, debit_account_id, journal_id):
         self.ensure_one()
@@ -620,6 +635,16 @@ class StockMove(models.Model):
             journal_id, acc_src, acc_dest, acc_valuation = self._get_accounting_data_for_valuation()
             self.with_context(force_company=self.company_id.id)._create_account_move_line(acc_src, acc_dest, journal_id)
 
+        if self.company_id.anglo_saxon_accounting:
+            #eventually reconcile together the invoice and valuation accounting entries on the stock interim accounts
+            self._get_related_invoices()._anglo_saxon_reconcile_valuation(product=self.product_id)
+
+    def _get_related_invoices(self): # To be overridden in purchase and sale_stock
+        """ This method is overrided in both purchase and sale_stock modules to adapt
+        to the way they mix stock moves with invoices.
+        """
+        return self.env['account.invoice']
+
 
 class StockReturnPicking(models.TransientModel):
     _inherit = "stock.return.picking"
