PR: https://github.com/odoo/odoo/pull/

From: f0db2d72f71e2133f80c6cef0184029ee8e107bf
From: Kinjal Mehta
Date: 2015-12-16 11:20:45

Structural Changes: 2
Total Changes: 281

[IMP] auth_signup: split files.

================================= pseudo patch: =================================

--- a/addons/auth_signup/models/__init__.py
+++ b/addons/auth_signup/models/__init__.py
@@ -2,3 +2,4 @@
 
 import res_config
 import res_users
+import res_partner

--- a/None
+++ b/addons/auth_signup/models/res_partner.py
@@ -0,0 +1,149 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from datetime import datetime, timedelta
+import random
+from urlparse import urljoin
+import werkzeug
+
+from openerp.osv import osv, fields
+from openerp.tools.misc import DEFAULT_SERVER_DATETIME_FORMAT, ustr
+from openerp.tools.translate import _
+
+class SignupError(Exception):
+    pass
+
+def random_token():
+    # the token has an entropy of about 120 bits (6 bits/char * 20 chars)
+    chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'
+    return ''.join(random.SystemRandom().choice(chars) for i in xrange(20))
+
+def now(**kwargs):
+    dt = datetime.now() + timedelta(**kwargs)
+    return dt.strftime(DEFAULT_SERVER_DATETIME_FORMAT)
+
+class res_partner(osv.Model):
+    _inherit = 'res.partner'
+
+    def _get_signup_valid(self, cr, uid, ids, name, arg, context=None):
+        dt = now()
+        res = {}
+        for partner in self.browse(cr, uid, ids, context):
+            res[partner.id] = bool(partner.signup_token) and \
+                                (not partner.signup_expiration or dt <= partner.signup_expiration)
+        return res
+
+    def _get_signup_url_for_action(self, cr, uid, ids, action=None, view_type=None, menu_id=None, res_id=None, model=None, context=None):
+        """ generate a signup url for the given partner ids and action, possibly overriding
+            the url state components (menu_id, id, view_type) """
+        if context is None:
+            context= {}
+        res = dict.fromkeys(ids, False)
+        base_url = self.pool.get('ir.config_parameter').get_param(cr, uid, 'web.base.url')
+        for partner in self.browse(cr, uid, ids, context):
+            # when required, make sure the partner has a valid signup token
+            if context.get('signup_valid') and not partner.user_ids:
+                self.signup_prepare(cr, uid, [partner.id], context=context)
+
+            route = 'login'
+            # the parameters to encode for the query
+            query = dict(db=cr.dbname)
+            signup_type = context.get('signup_force_type_in_url', partner.signup_type or '')
+            if signup_type:
+                route = 'reset_password' if signup_type == 'reset' else signup_type
+
+            if partner.signup_token and signup_type:
+                query['token'] = partner.signup_token
+            elif partner.user_ids:
+                query['login'] = partner.user_ids[0].login
+            else:
+                continue        # no signup token, no user, thus no signup url!
+
+            fragment = dict()
+            if action:
+                fragment['action'] = action
+            if view_type:
+                fragment['view_type'] = view_type
+            if menu_id:
+                fragment['menu_id'] = menu_id
+            if model:
+                fragment['model'] = model
+            if res_id:
+                fragment['id'] = res_id
+
+            if fragment:
+                query['redirect'] = '/web#' + werkzeug.url_encode(fragment)
+
+            res[partner.id] = urljoin(base_url, "/web/%s?%s" % (route, werkzeug.url_encode(query)))
+
+        return res
+
+    def _get_signup_url(self, cr, uid, ids, name, arg, context=None):
+        """ proxy for function field towards actual implementation """
+        return self._get_signup_url_for_action(cr, uid, ids, context=context)
+
+    _columns = {
+        'signup_token': fields.char('Signup Token', copy=False),
+        'signup_type': fields.char('Signup Token Type', copy=False),
+        'signup_expiration': fields.datetime('Signup Expiration', copy=False),
+        'signup_valid': fields.function(_get_signup_valid, type='boolean', string='Signup Token is Valid'),
+        'signup_url': fields.function(_get_signup_url, type='char', string='Signup URL'),
+    }
+
+    def action_signup_prepare(self, cr, uid, ids, context=None):
+        return self.signup_prepare(cr, uid, ids, context=context)
+
+    def signup_cancel(self, cr, uid, ids, context=None):
+        return self.write(cr, uid, ids, {'signup_token': False, 'signup_type': False, 'signup_expiration': False}, context=context)
+
+    def signup_prepare(self, cr, uid, ids, signup_type="signup", expiration=False, context=None):
+        """ generate a new token for the partners with the given validity, if necessary
+            :param expiration: the expiration datetime of the token (string, optional)
+        """
+        for partner in self.browse(cr, uid, ids, context):
+            if expiration or not partner.signup_valid:
+                token = random_token()
+                while self._signup_retrieve_partner(cr, uid, token, context=context):
+                    token = random_token()
+                partner.write({'signup_token': token, 'signup_type': signup_type, 'signup_expiration': expiration})
+        return True
+
+    def _signup_retrieve_partner(self, cr, uid, token,
+            check_validity=False, raise_exception=False, context=None):
+        """ find the partner corresponding to a token, and possibly check its validity
+            :param token: the token to resolve
+            :param check_validity: if True, also check validity
+            :param raise_exception: if True, raise exception instead of returning False
+            :return: partner (browse record) or False (if raise_exception is False)
+        """
+        partner_ids = self.search(cr, uid, [('signup_token', '=', token)], context=context)
+        if not partner_ids:
+            if raise_exception:
+                raise SignupError("Signup token '%s' is not valid" % token)
+            return False
+        partner = self.browse(cr, uid, partner_ids[0], context)
+        if check_validity and not partner.signup_valid:
+            if raise_exception:
+                raise SignupError("Signup token '%s' is no longer valid" % token)
+            return False
+        return partner
+
+    def signup_retrieve_info(self, cr, uid, token, context=None):
+        """ retrieve the user info about the token
+            :return: a dictionary with the user information:
+                - 'db': the name of the database
+                - 'token': the token, if token is valid
+                - 'name': the name of the partner, if token is valid
+                - 'login': the user login, if the user already exists
+                - 'email': the partner email, if the user does not exist
+        """
+        partner = self._signup_retrieve_partner(cr, uid, token, raise_exception=True, context=None)
+        res = {'db': cr.dbname}
+        if partner.signup_valid:
+            res['token'] = token
+            res['name'] = partner.name
+        if partner.user_ids:
+            res['login'] = partner.user_ids[0].login
+        else:
+            res['email'] = partner.email or ''
+        return res
\ No newline at end of file

--- a/addons/auth_signup/models/res_users.py
+++ b/addons/auth_signup/models/res_users.py
@@ -3,7 +3,6 @@
 
 from datetime import datetime, timedelta
 import random
-from urlparse import urljoin
 import werkzeug
 
 from openerp.addons.base.ir.ir_mail_server import MailDeliveryException
@@ -25,136 +24,6 @@ def now(**kwargs):
     dt = datetime.now() + timedelta(**kwargs)
     return dt.strftime(DEFAULT_SERVER_DATETIME_FORMAT)
 
-
-class res_partner(osv.Model):
-    _inherit = 'res.partner'
-
-    def _get_signup_valid(self, cr, uid, ids, name, arg, context=None):
-        dt = now()
-        res = {}
-        for partner in self.browse(cr, uid, ids, context):
-            res[partner.id] = bool(partner.signup_token) and \
-                                (not partner.signup_expiration or dt <= partner.signup_expiration)
-        return res
-
-    def _get_signup_url_for_action(self, cr, uid, ids, action=None, view_type=None, menu_id=None, res_id=None, model=None, context=None):
-        """ generate a signup url for the given partner ids and action, possibly overriding
-            the url state components (menu_id, id, view_type) """
-        if context is None:
-            context= {}
-        res = dict.fromkeys(ids, False)
-        base_url = self.pool.get('ir.config_parameter').get_param(cr, uid, 'web.base.url')
-        for partner in self.browse(cr, uid, ids, context):
-            # when required, make sure the partner has a valid signup token
-            if context.get('signup_valid') and not partner.user_ids:
-                self.signup_prepare(cr, uid, [partner.id], context=context)
-
-            route = 'login'
-            # the parameters to encode for the query
-            query = dict(db=cr.dbname)
-            signup_type = context.get('signup_force_type_in_url', partner.signup_type or '')
-            if signup_type:
-                route = 'reset_password' if signup_type == 'reset' else signup_type
-
-            if partner.signup_token and signup_type:
-                query['token'] = partner.signup_token
-            elif partner.user_ids:
-                query['login'] = partner.user_ids[0].login
-            else:
-                continue        # no signup token, no user, thus no signup url!
-
-            fragment = dict()
-            base = '/web#'
-            if action == '/mail/view':
-                base = '/mail/view?'
-            elif action:
-                fragment['action'] = action
-            if view_type:
-                fragment['view_type'] = view_type
-            if menu_id:
-                fragment['menu_id'] = menu_id
-            if model:
-                fragment['model'] = model
-            if res_id:
-                fragment['res_id'] = res_id
-
-            if fragment:
-                query['redirect'] = base + werkzeug.url_encode(fragment)
-
-            res[partner.id] = urljoin(base_url, "/web/%s?%s" % (route, werkzeug.url_encode(query)))
-
-        return res
-
-    def _get_signup_url(self, cr, uid, ids, name, arg, context=None):
-        """ proxy for function field towards actual implementation """
-        return self._get_signup_url_for_action(cr, uid, ids, context=context)
-
-    _columns = {
-        'signup_token': fields.char('Signup Token', copy=False),
-        'signup_type': fields.char('Signup Token Type', copy=False),
-        'signup_expiration': fields.datetime('Signup Expiration', copy=False),
-        'signup_valid': fields.function(_get_signup_valid, type='boolean', string='Signup Token is Valid'),
-        'signup_url': fields.function(_get_signup_url, type='char', string='Signup URL'),
-    }
-
-    def action_signup_prepare(self, cr, uid, ids, context=None):
-        return self.signup_prepare(cr, uid, ids, context=context)
-
-    def signup_cancel(self, cr, uid, ids, context=None):
-        return self.write(cr, uid, ids, {'signup_token': False, 'signup_type': False, 'signup_expiration': False}, context=context)
-
-    def signup_prepare(self, cr, uid, ids, signup_type="signup", expiration=False, context=None):
-        """ generate a new token for the partners with the given validity, if necessary
-            :param expiration: the expiration datetime of the token (string, optional)
-        """
-        for partner in self.browse(cr, uid, ids, context):
-            if expiration or not partner.signup_valid:
-                token = random_token()
-                while self._signup_retrieve_partner(cr, uid, token, context=context):
-                    token = random_token()
-                partner.write({'signup_token': token, 'signup_type': signup_type, 'signup_expiration': expiration})
-        return True
-
-    def _signup_retrieve_partner(self, cr, uid, token,
-            check_validity=False, raise_exception=False, context=None):
-        """ find the partner corresponding to a token, and possibly check its validity
-            :param token: the token to resolve
-            :param check_validity: if True, also check validity
-            :param raise_exception: if True, raise exception instead of returning False
-            :return: partner (browse record) or False (if raise_exception is False)
-        """
-        partner_ids = self.search(cr, uid, [('signup_token', '=', token)], context=context)
-        if not partner_ids:
-            if raise_exception:
-                raise SignupError("Signup token '%s' is not valid" % token)
-            return False
-        partner = self.browse(cr, uid, partner_ids[0], context)
-        if check_validity and not partner.signup_valid:
-            if raise_exception:
-                raise SignupError("Signup token '%s' is no longer valid" % token)
-            return False
-        return partner
-
-    def signup_retrieve_info(self, cr, uid, token, context=None):
-        """ retrieve the user info about the token
-            :return: a dictionary with the user information:
-                - 'db': the name of the database
-                - 'token': the token, if token is valid
-                - 'name': the name of the partner, if token is valid
-                - 'login': the user login, if the user already exists
-                - 'email': the partner email, if the user does not exist
-        """
-        partner = self._signup_retrieve_partner(cr, uid, token, raise_exception=True, context=None)
-        res = {'db': cr.dbname}
-        if partner.signup_valid:
-            res['token'] = token
-            res['name'] = partner.name
-        if partner.user_ids:
-            res['login'] = partner.user_ids[0].login
-        else:
-            res['email'] = res['login'] = partner.email or ''
-        return res
-
 class res_users(osv.Model):
     _inherit = 'res.users'
 
