PR: https://github.com/odoo/odoo/pull/61246

From: 646457d761571b1fd32d82b6529f6a05306085ff
From: Victor Feyens
Date: 2020-12-03 10:18:47

Structural Changes: 2
Total Changes: 104

[IMP] mail, digest, fetchmail, hr_holidays, snailmail: support batch creation

See merge commit for more details.

Note that mail.alias model will be done in a separate commit.

Task ID-2330149
COM PR odoo/odoo#61246
ENT PR odoo/enterprise#14561

================================= pseudo patch: =================================

--- a/addons/mail/models/mail_activity.py
+++ b/addons/mail/models/mail_activity.py
@@ -346,34 +346,35 @@ class MailActivity(models.Model):
     # ORM overrides
     # ------------------------------------------------------
 
-    @api.model
-    def create(self, values):
-        activity = super(MailActivity, self).create(values)
-        need_sudo = False
-        try:  # in multicompany, reading the partner might break
-            partner_id = activity.user_id.partner_id.id
-        except exceptions.AccessError:
-            need_sudo = True
-            partner_id = activity.user_id.sudo().partner_id.id
-
-        # send a notification to assigned user; in case of manually done activity also check
-        # target has rights on document otherwise we prevent its creation. Automated activities
-        # are checked since they are integrated into business flows that should not crash.
-        if activity.user_id != self.env.user:
-            if not activity.automated:
-                activity._check_access_assignation()
-            if not self.env.context.get('mail_activity_quick_update', False):
-                if need_sudo:
-                    activity.sudo().action_notify()
-                else:
-                    activity.action_notify()
-
-        self.env[activity.res_model].browse(activity.res_id).message_subscribe(partner_ids=[partner_id])
-        if activity.date_deadline <= fields.Date.today():
-            self.env['bus.bus'].sendone(
-                (self._cr.dbname, 'res.partner', activity.user_id.partner_id.id),
-                {'type': 'activity_updated', 'activity_created': True})
-        return activity
+    @api.model_create_multi
+    def create(self, vals_list):
+        activities = super(MailActivity, self).create(vals_list)
+        for activity in activities:
+            need_sudo = False
+            try:  # in multicompany, reading the partner might break
+                partner_id = activity.user_id.partner_id.id
+            except exceptions.AccessError:
+                need_sudo = True
+                partner_id = activity.user_id.sudo().partner_id.id
+
+            # send a notification to assigned user; in case of manually done activity also check
+            # target has rights on document otherwise we prevent its creation. Automated activities
+            # are checked since they are integrated into business flows that should not crash.
+            if activity.user_id != self.env.user:
+                if not activity.automated:
+                    activity._check_access_assignation()
+                if not self.env.context.get('mail_activity_quick_update', False):
+                    if need_sudo:
+                        activity.sudo().action_notify()
+                    else:
+                        activity.action_notify()
+
+            self.env[activity.res_model].browse(activity.res_id).message_subscribe(partner_ids=[partner_id])
+            if activity.date_deadline <= fields.Date.today():
+                self.env['bus.bus'].sendone(
+                    (self._cr.dbname, 'res.partner', activity.user_id.partner_id.id),
+                    {'type': 'activity_updated', 'activity_created': True})
+        return activities
 
     def write(self, values):
         if values.get('user_id'):

--- a/addons/mail/models/mail_channel.py
+++ b/addons/mail/models/mail_channel.py
@@ -204,26 +204,27 @@ class Channel(models.Model):
         else:
             self.moderator_ids |= self.env.user
 
-    @api.model
-    def create(self, vals):
-        # ensure image at quick create
-        if not vals.get('image_128'):
-            defaults = self.default_get(['image_128'])
-            vals['image_128'] = defaults['image_128']
+    @api.model_create_multi
+    def create(self, vals_list):
+        defaults = self.default_get(['image_128'])
+        for vals in vals_list:
+            # ensure image at quick create
+            if not vals.get('image_128'):
+                vals['image_128'] = defaults['image_128']
 
         # Create channel and alias
-        channel = super(Channel, self.with_context(
+        channels = super(Channel, self.with_context(
             mail_create_nolog=True, mail_create_nosubscribe=True)
-        ).create(vals)
+        ).create(vals_list)
 
-        if vals.get('group_ids'):
-            channel._subscribe_users()
+        channels._subscribe_users()
 
         # make channel listen itself: posting on a channel notifies the channel
         if not self._context.get('mail_channel_noautofollow'):
-            channel.message_subscribe(channel_ids=[channel.id])
+            for channel in channels:
+                channel.message_subscribe(channel_ids=[channel.id])
 
-        return channel
+        return channels
 
     def unlink(self):
         # Delete mail.channel
@@ -266,13 +267,15 @@ class Channel(models.Model):
     def _subscribe_users(self):
         to_create = []
         for mail_channel in self:
-            partners_to_add = mail_channel.group_ids.users.partner_id - mail_channel.channel_partner_ids
-            to_create += [{
-                'channel_id': mail_channel.id,
-                'partner_id': partner.id,
-            } for partner in partners_to_add]
-
-        self.env['mail.channel.partner'].create(to_create)
+            if mail_channel.group_ids:
+                partners_to_add = mail_channel.group_ids.users.partner_id - mail_channel.channel_partner_ids
+                to_create += [{
+                    'channel_id': mail_channel.id,
+                    'partner_id': partner.id,
+                } for partner in partners_to_add]
+
+        if to_create:
+            self.env['mail.channel.partner'].create(to_create)
 
     def action_follow(self):
         self.ensure_one()

--- a/addons/mail/models/mail_message_subtype.py
+++ b/addons/mail/models/mail_message_subtype.py
@@ -41,10 +41,10 @@ class MailMessageSubtype(models.Model):
     sequence = fields.Integer('Sequence', default=1, help="Used to order subtypes.")
     hidden = fields.Boolean('Hidden', help="Hide the subtype in the follower options")
 
-    @api.model
-    def create(self, vals):
+    @api.model_create_multi
+    def create(self, vals_list):
         self.clear_caches()
-        return super(MailMessageSubtype, self).create(vals)
+        return super(MailMessageSubtype, self).create(vals_list)
 
     def write(self, vals):
         self.clear_caches()
