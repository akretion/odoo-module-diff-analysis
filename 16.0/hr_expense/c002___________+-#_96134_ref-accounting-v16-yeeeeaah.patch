PR: https://github.com/odoo/odoo/pull/96134

From: d8d47f9ff8554f4b39487fd2f13c153c7d6f958d
From: william-andre
Date: 2022-08-03 11:44:49

Structural Changes: 2
Total Changes: 266

[REF] accounting v16. Yeeeeaah

TLDR:
* invoices are implemented using computed methods instead of onchange
* the synchronization only happens when switching tabs in the Form view
  to improve perfs.

_______________________________________________________________________

The whole engine of the synchronization of Invoices to the Journal
Entries has been refactored
* by using computed fields instead of onchange functions
* by synchronizing only from invoice to journal entry in `create` and
  `write`
* by saving when switching tabs on the Invoice form, to synchronize
  before showing the values

This comes with numerous advantages:
* no need to call the onchange methods manually
* no need to use the Form emulator to build invoices (i.e. EDI, OCR,
  intercompany, ...)
* the performance for invoices with many lines improves drastically, going
  from 2 minutes to 4 seconds to create an invoice with 500 lines
* the model is more declarative, we can now see how the values are computed
  instead of having the values being copied from various places.
* remove the hack in `onchange` that disabled the recursivity of it,
  which was unexpected and needed to be managed manually in all the
  onchange methods

This means that:
* Some fields need to be exclusively computed on journal entries values
  or invoice values, more specifically the Tax Summary widget.
  It is now
    - computed from entry lines, when opening the view
    - computed from invoice lines when changing those, because the tax lines
      will need to be recomputed anyways, erasing previously set values
    - set with an inverse function when saving; after the sync has been done
* Some possible operations previously possible have been dropped.
  (i.e. look at the removed test test_in_invoice_line_onchange_accounting_fields_1)
  This is because such a behavior was undefined (how is changing the balance going
  to affect the unit price? How is the amount currency going to affect it?)

_______________________________________________________________________

Implementation Details
----------------------

The "dynamic lines", meaning the payment terms and the tax lines are now
only created in the `create` and `write` functions.
In order to reduce code duplication, it has been implemented using
context managers used in both `account.move` and `account.move.line`
These context managers help comparing the values before/after, acting
like a local `onchange`, but getting benefit from the dirty flags from
the `compute` dependences.
This is relying on computed fields on the move (`needed_terms`) and on
the lines (`compute_all_tax`) which contain the values needed for the
related move.
Depending on the needed values and the existing values (`term_key` and
`tax_key`, respectively) the context manager will determine what needs
to be created/updated/deleted.

Some related changes are to produce a `dict` instead of a `str` for the
`tax_totals` (previously `tax_totals_json`) fields, by simplicity to
reduce the complexity of IO, and simplicity of debugging, because the
logic of the field needed to change (cannot be computed at the same time
anymore since it needed the lines to be synced)

By simplicity, and also because it makes more sense, some boolean fields
have been merged into `display_type`:
* `is_rounding_line`
* `exclude_from_invoice_tab`
* `is_anglo_saxon_line`

The `price_unit`, `quantity` and other "invoice fields" are now not set
anymore on lines that are not product lines since it didn't make any
sense to have it.

Performances
------------

You have to keep in mind that a simple `create` didn't compute a lot of
fields, for instance not taxes were set, no payment terms,...
Now it does.

```python
import random
from timeit import timeit
from odoo import Command
domain = [('company_id', 'in', (False, self.env.company.id))]
products = self.env['product.product'].search(domain).ids
partners = self.env['res.partner'].search(domain).ids
taxes = self.env['account.tax'].search(domain).ids
def create(nmove, nline):
    self.env['account.move'].create([
        {
            'move_type': 'out_invoice',
            'partner_id': random.choice(partners),
            'invoice_line_ids': [
                Command.create({
                    'name': f'line{i}',
                    'product_id': random.choice(products),
                    'tax_ids': [Command.set([random.choice(taxes)])],
                })
                for i in range(nline)
            ]
        }
        for j in range(nmove)
    ])
                                                             # After  | Before
print(timeit("create(1, 1)", globals=globals(), number=1))   # 0.11   | 0.09
print(timeit("create(100, 1)", globals=globals(), number=1)) # 2.76   | 2.50
print(timeit("create(500, 1)", globals=globals(), number=1)) # 14.56  | 12.34
print(timeit("create(1, 100)", globals=globals(), number=1)) # 1.03   | 5.52
print(timeit("create(1, 500)", globals=globals(), number=1)) # 3.99   | 125.02
print(timeit("create(50, 50)", globals=globals(), number=1)) # 19.44  | 79.55
```

Another metric that can be used is running the test suite with
`--test-tags=/account` (only `account` installed)
* before: 404s, 267127 queries (366 tests)
* after: 318s, 232125 queries (362 tests)

Why this commit title?
----------------------

Someone told me that this was the perfect way of naming your commits.
c04065abd8f62c9a211c8fa824f5eecf68e61b73

task-2711317

closes odoo/odoo#96134

Related: odoo/upgrade#3715
Related: odoo/enterprise#29758
Signed-off-by: Laurent Smet <las@odoo.com>

================================= pseudo patch: =================================

--- a/addons/hr_expense/models/account_move.py
+++ b/addons/hr_expense/models/account_move.py
@@ -1,7 +1,10 @@
 # -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
-from odoo import models, fields
+from collections import defaultdict
+
+from odoo import models, fields, api, _
+from odoo.tools.misc import frozendict
 
 
 class AccountMove(models.Model):
@@ -20,8 +23,39 @@ class AccountMove(models.Model):
             'res_id': self.expense_sheet_id.id
         }
 
-    def _payment_state_matters(self):
-        self.ensure_one()
+    # Behave exactly like a receipt for everything except the display
+    # This enables the synchronisation of payment terms, and sets the taxes and accounts based on the product
+    def is_purchase_document(self, include_receipts=False):
+        return bool(self.expense_sheet_id and include_receipts) or super().is_purchase_document(include_receipts)
+
+    def _creation_message(self):
         if self.line_ids.expense_id:
-            return True
-        return super()._payment_state_matters()
+            return _("Expense entry Created")
+        return super()._creation_message()
+
+    @api.depends('expense_sheet_id')
+    def _compute_needed_terms(self):
+        # EXTENDS account
+        # The needed terms need to be computed for journal entries, depending on the expense and the currency
+        # since one expense sheet can contain multiple currencies.
+        super()._compute_needed_terms()
+        for move in self:
+            if move.expense_sheet_id:
+                move.needed_terms = {}
+                agg = defaultdict(lambda: {'company': 0.0, 'foreign': 0.0})
+                for line in move.line_ids:
+                    if line.display_type != 'payment_term':
+                        agg[line.expense_id]['company'] += line.balance
+                        agg[line.expense_id]['foreign'] += line.amount_currency
+                for expense in move.line_ids.expense_id:
+                    move.needed_terms[frozendict({
+                        'move_id': move.id,
+                        'date_maturity': expense.sheet_id.accounting_date or expense.date or fields.Date.context_today(expense),
+                        'expense_id': expense.id,
+                    })] = {
+                        'balance': -agg[expense]['company'],
+                        'amount_currency': -agg[expense]['foreign'],
+                        'name': '',
+                        'currency_id': expense.currency_id.id,
+                        'account_id': expense._get_expense_account_destination(),
+                    }

--- a/addons/hr_expense/models/account_move_line.py
+++ b/addons/hr_expense/models/account_move_line.py
@@ -2,6 +2,7 @@
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
 from odoo import fields, models
+from odoo.tools.misc import frozendict
 
 
 class AccountMoveLine(models.Model):
@@ -25,3 +26,23 @@ class AccountMoveLine(models.Model):
         if self.expense_id:
             attachment_domains.append([('res_model', '=', 'hr.expense'), ('res_id', '=', self.expense_id.id)])
         return attachment_domains
+
+    def _compute_tax_key(self):
+        super()._compute_tax_key()
+        for line in self:
+            if line.expense_id:
+                line.tax_key = frozendict(**line.tax_key, expense_id=line.expense_id.id)
+
+    def _compute_all_tax(self):
+        super()._compute_all_tax()
+        for line in self:
+            if line.expense_id:
+                for key in list(line.compute_all_tax.keys()):
+                    new_key = frozendict(**key, expense_id=line.expense_id.id)
+                    line.compute_all_tax[new_key] = line.compute_all_tax.pop(key)
+
+    def _compute_term_key(self):
+        super()._compute_term_key()
+        for line in self:
+            if line.expense_id:
+                line.term_key = line.term_key and frozendict(**line.term_key, expense_id=line.expense_id.id)

--- a/addons/hr_expense/models/hr_expense.py
+++ b/addons/hr_expense/models/hr_expense.py
@@ -8,7 +8,6 @@ from odoo.tools import float_round
 from odoo.exceptions import UserError, ValidationError
 from odoo.tools import email_split, float_is_zero, float_repr, float_compare, is_html_empty
 from odoo.tools.misc import clean_context, format_date
-from odoo.addons.account.models.account_move import PAYMENT_STATE_SELECTION
 
 
 class HrExpense(models.Model):
@@ -560,54 +559,6 @@ Or send your receipts at <a href="mailto:%(email)s?subject=Lunch%%20with%%20cust
     # Business
     # ----------------------------------------
 
-    def _prepare_move_values(self):
-        """
-        This function prepares move values related to an expense
-        """
-        self.ensure_one()
-        journal = self.sheet_id.bank_journal_id if self.payment_mode == 'company_account' else self.sheet_id.journal_id
-        account_date = self.sheet_id.accounting_date or self.date
-        move_values = {
-            'journal_id': journal.id,
-            'company_id': self.sheet_id.company_id.id,
-            'date': account_date,
-            'ref': self.sheet_id.name,
-            # force the name to the default value, to avoid an eventual 'default_name' in the context
-            # to set it to '' which cause no number to be given to the account.move when posted.
-            'name': '/',
-        }
-        return move_values
-
-    def _get_account_move_by_sheet(self):
-        """ Return a mapping between the expense sheet of current expense and its account move
-            :returns dict where key is a sheet id, and value is an account move record
-        """
-        move_grouped_by_sheet = {}
-        for expense in self:
-            # create the move that will contain the accounting entries
-            if expense.sheet_id.id not in move_grouped_by_sheet:
-                move_vals = expense._prepare_move_values()
-                move = self.env['account.move'].with_context(default_journal_id=move_vals['journal_id']).create(move_vals)
-                move_grouped_by_sheet[expense.sheet_id.id] = move
-            else:
-                move = move_grouped_by_sheet[expense.sheet_id.id]
-        return move_grouped_by_sheet
-
-    def _get_expense_account_source(self):
-        self.ensure_one()
-        if self.account_id:
-            account = self.account_id
-        elif self.product_id:
-            account = self.product_id.product_tmpl_id.with_company(self.company_id)._get_product_accounts()['expense']
-            if not account:
-                raise UserError(
-                    _("No Expense account found for the product %s (or for its category), please configure one.") % (self.product_id.name))
-        else:
-            account = self.env['ir.property'].with_company(self.company_id)._get('property_account_expense_categ_id', 'product.category')
-            if not account:
-                raise UserError(_('Please configure Default Expense account for Category expense: `property_account_expense_categ_id`.'))
-        return account
-
     def _get_expense_account_destination(self):
         self.ensure_one()
         account_dest = self.env['account.account']
@@ -624,126 +575,52 @@ Or send your receipts at <a href="mailto:%(email)s?subject=Lunch%%20with%%20cust
             account_dest = partner.property_account_payable_id or partner.parent_id.property_account_payable_id
         return account_dest.id
 
-    def _get_account_move_line_values(self):
-        move_line_values_by_expense = {}
-        for expense in self:
-            move_line_name = expense.employee_id.name + ': ' + expense.name.split('\n')[0][:64]
-            account_src = expense._get_expense_account_source()
-            account_dst = expense._get_expense_account_destination()
-            account_date = expense.sheet_id.accounting_date or expense.date or fields.Date.context_today(expense)
-
-            company_currency = expense.company_id.currency_id
-
-            move_line_values = []
-            unit_amount = expense.total_amount
-            quantity = 1
-
-            taxes = expense._get_taxes(price=unit_amount, quantity=quantity)
-            total_amount = 0.0
-            total_amount_currency = 0.0
-            partner_id = expense.employee_id.sudo().address_home_id.commercial_partner_id.id
-
-            # source move line
-            balance = expense.currency_id._convert(taxes['total_excluded'], company_currency, expense.company_id, account_date)
-            amount_currency = taxes['total_excluded']
-            move_line_src = {
-                'name': move_line_name,
-                'quantity': expense.quantity or 1,
-                'debit': balance if balance > 0 else 0,
-                'credit': -balance if balance < 0 else 0,
-                'amount_currency': amount_currency,
-                'account_id': account_src.id,
-                'product_id': expense.product_id.id,
-                'product_uom_id': expense.product_uom_id.id,
-                'analytic_account_id': expense.analytic_account_id.id,
-                'analytic_tag_ids': [(6, 0, expense.analytic_tag_ids.ids)],
-                'expense_id': expense.id,
-                'partner_id': partner_id,
-                'tax_ids': [(6, 0, expense.tax_ids.ids)],
-                'tax_tag_ids': [(6, 0, taxes['base_tags'])],
-                'currency_id': expense.currency_id.id,
-            }
-            move_line_values.append(move_line_src)
-            total_amount -= balance
-            total_amount_currency -= move_line_src['amount_currency']
-
-            # taxes move lines
-            for tax in taxes['taxes']:
-                balance = expense.currency_id._convert(tax['amount'], company_currency, expense.company_id, account_date)
-                amount_currency = tax['amount']
-
-                if tax['tax_repartition_line_id']:
-                    rep_ln = self.env['account.tax.repartition.line'].browse(tax['tax_repartition_line_id'])
-                    base_amount = self.env['account.move']._get_base_amount_to_display(tax['base'], rep_ln)
-                    base_amount = expense.currency_id._convert(base_amount, company_currency, expense.company_id, account_date)
-                else:
-                    base_amount = None
-
-                move_line_tax_values = {
-                    'name': tax['name'],
-                    'quantity': 1,
-                    'debit': balance if balance > 0 else 0,
-                    'credit': -balance if balance < 0 else 0,
-                    'amount_currency': amount_currency,
-                    'account_id': tax['account_id'] or move_line_src['account_id'],
-                    'tax_repartition_line_id': tax['tax_repartition_line_id'],
-                    'tax_tag_ids': tax['tag_ids'],
-                    'tax_base_amount': base_amount,
-                    'expense_id': expense.id,
-                    'partner_id': partner_id,
-                    'currency_id': expense.currency_id.id,
-                    'analytic_account_id': expense.analytic_account_id.id if tax['analytic'] else False,
-                    'analytic_tag_ids': [(6, 0, expense.analytic_tag_ids.ids)] if tax['analytic'] else False,
-                }
-                total_amount -= balance
-                total_amount_currency -= move_line_tax_values['amount_currency']
-                move_line_values.append(move_line_tax_values)
-
-            # destination move line
-            move_line_dst = {
-                'name': move_line_name,
-                'debit': total_amount > 0 and total_amount,
-                'credit': total_amount < 0 and -total_amount,
-                'account_id': account_dst,
-                'date_maturity': account_date,
-                'amount_currency': total_amount_currency,
-                'currency_id': expense.currency_id.id,
-                'expense_id': expense.id,
-                'partner_id': partner_id,
-                'exclude_from_invoice_tab': True,
-            }
-            move_line_values.append(move_line_dst)
-
-            move_line_values_by_expense[expense.id] = move_line_values
-        return move_line_values_by_expense
-
     def action_move_create(self):
         '''
         main function that is called when trying to create the accounting entries related to an expense
         '''
-        move_group_by_sheet = self._get_account_move_by_sheet()
-
-        move_line_values_by_expense = self._get_account_move_line_values()
+        moves = self.env['account.move'].create([
+            {
+                'journal_id': (
+                    sheet.bank_journal_id
+                    if sheet.payment_mode == 'company_account' else
+                    sheet.journal_id
+                ).id,
+                'move_type': 'in_receipt',
+                'company_id': sheet.company_id.id,
+                'date': sheet.accounting_date or fields.Date.context_today(sheet),
+                'invoice_date': sheet.accounting_date or fields.Date.context_today(sheet),
+                'ref': sheet.name,
+                # force the name to the default value, to avoid an eventual 'default_name' in the context
+                # to set it to '' which cause no number to be given to the account.move when posted.
+                'name': '/',
+                'expense_sheet_id': [Command.set(sheet.ids)],
+                'line_ids':[
+                    Command.create({
+                        'name': expense.employee_id.name + ': ' + expense.name.split('\n')[0][:64],
+                        'quantity': expense.quantity or 1,
+                        'price_unit': expense.total_amount,
+                        'product_id': expense.product_id.id,
+                        'product_uom_id': expense.product_uom_id.id,
+                        'analytic_account_id': expense.analytic_account_id.id,
+                        'analytic_tag_ids': [(6, 0, expense.analytic_tag_ids.ids)],
+                        'expense_id': expense.id,
+                        'partner_id': expense.employee_id.sudo().address_home_id.commercial_partner_id.id,
+                        'tax_ids': [(6, 0, expense.tax_ids.ids)],
+                        'currency_id': expense.currency_id.id,
+                    })
+                    for expense in sheet.expense_line_ids
+                ]
+            }
+            for sheet in self.sheet_id
+        ])
+        moves._post()
 
         for expense in self:
-            # get the account move of the related sheet
-            move = move_group_by_sheet[expense.sheet_id.id]
-
-            # get move line values
-            move_line_values = move_line_values_by_expense.get(expense.id)
-
-            # link move lines to move, and move to expense sheet
-            move.write({'line_ids': [(0, 0, line) for line in move_line_values]})
-            expense.sheet_id.write({'account_move_id': move.id})
-
             if expense.payment_mode == 'company_account':
                 expense.sheet_id.paid_expense_sheets()
 
-        # post the moves
-        for move in move_group_by_sheet.values():
-            move._post()
-
-        return move_group_by_sheet
+        return {move.expense_sheet_id.id: move for move in moves}
 
     def refuse_expense(self, reason):
         self.write({'is_refused': True})
@@ -981,7 +858,9 @@ class HrExpenseSheet(models.Model):
         ('done', 'Done'),
         ('cancel', 'Refused')
     ], string='Status', index=True, readonly=True, tracking=True, copy=False, default='draft', required=True)
-    payment_state = fields.Selection(selection=PAYMENT_STATE_SELECTION, string="Payment Status",
+    payment_state = fields.Selection(
+        selection=lambda self: self.env["account.move"]._fields["payment_state"].selection,
+        string="Payment Status",
         store=True, readonly=True, copy=False, tracking=True, compute='_compute_payment_state')
     employee_id = fields.Many2one('hr.employee', string="Employee", required=True, readonly=True, tracking=True, states={'draft': [('readonly', False)]}, default=_default_employee_id, check_company=True, domain= lambda self: self.env['hr.expense']._get_employee_id_domain())
     address_id = fields.Many2one('res.partner', compute='_compute_from_employee_id', store=True, readonly=False, copy=True, string="Employee Home Address", check_company=True)
