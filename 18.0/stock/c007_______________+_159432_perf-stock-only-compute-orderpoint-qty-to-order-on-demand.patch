PR: https://github.com/odoo/odoo/pull/159432

From: 156bed3f430d706e13822bbd95d91c8dfd3ea42d
From: Pieter Claeys (clpi)
Date: 2024-03-29 08:32:10

Structural Changes: 4
Total Changes: 42

[PERF] stock: only compute orderpoint qty_to_order on demand

Due to the `qty_to_order` field on `stock.orderpoint` being a stored
computed field, it needs to be recalculated every time one or more of
its dependencies could have changed, to keep a consistent record in the
database.
It is, however, dependent on the `qty_forecast` field which is a
non-stored computed field, depending itself on all the stock moves that
are linked to the product set on the orderpoint.
This results in a complete recalculation of the `qty_on_hand`,
`qty_forecast` and `qty_to_order` on ALL the orderpoints linked to a
product every time some `stock.move ` has been touched or created with
that product. Even if many of those orderpoints may not even be located
in the concerned warehouse.
This situation can create a performance bottleneck when just processing
pickings, as its constantly (and often pointlessly) recalculating these
field values to store. This becomes a major issue in case the concerned
database contains many warehouses with many different orderpoints.

To remedy this issue, we make the `qty_to_order` field on
`stock.orderpoint` no longer stored. It will instead now be calculated
'on demand' when using the reordering rules.
We prefer to have a potential small performance decrease here instead of
constantly pre-computing these values during day-to-day logistics
operations.
To enable user modification of the qty_to_order field, it is split in a
computed version of the field `qty_to_order_computed` and a noncomputed
float field `qty_to_order_manual` where the manually adapted value is
saved. The field `qty_to_order` provides the user provided value if
available and the computed value otherwise.

task-3822497

closes odoo/odoo#159432

Signed-off-by: Arnold Moyaux (arm) <arm@odoo.com>

================================= pseudo patch: =================================

--- a/addons/stock/models/stock_orderpoint.py
+++ b/addons/stock/models/stock_orderpoint.py
@@ -78,7 +78,9 @@ class StockWarehouseOrderpoint(models.Model):
         'stock.route', string='Route', domain="[('product_selectable', '=', True)]")
     qty_on_hand = fields.Float('On Hand', readonly=True, compute='_compute_qty', digits='Product Unit of Measure')
     qty_forecast = fields.Float('Forecast', readonly=True, compute='_compute_qty', digits='Product Unit of Measure')
-    qty_to_order = fields.Float('To Order', compute='_compute_qty_to_order', store=True, readonly=False, digits='Product Unit of Measure')
+    qty_to_order = fields.Float('To Order', compute='_compute_qty_to_order', inverse='_inverse_qty_to_order', search='_search_qty_to_order', digits='Product Unit of Measure')
+    qty_to_order_computed = fields.Float('To Order Computed', compute='_compute_qty_to_order_computed', digits='Product Unit of Measure')
+    qty_to_order_manual = fields.Float('To Order Manual', digits='Product Unit of Measure')
 
     days_to_order = fields.Float(compute='_compute_days_to_order', help="Numbers of days  in advance that replenishments demands are created.")
     visibility_days = fields.Float(
@@ -239,7 +241,8 @@ class StockWarehouseOrderpoint(models.Model):
         if len(self) == 1:
             notification = self.with_context(written_after=now)._get_replenishment_order_notification()
         # Forced to call compute quantity because we don't have a link.
-        self._compute_qty()
+        self.action_remove_manual_qty_to_order()
+        self._compute_qty_to_order()
         self.filtered(lambda o: o.create_uid.id == SUPERUSER_ID and o.qty_to_order <= 0.0 and o.trigger == 'manual').unlink()
         return notification
 
@@ -268,11 +271,28 @@ class StockWarehouseOrderpoint(models.Model):
                 orderpoint.qty_on_hand = products_qty[orderpoint.product_id.id]['qty_available']
                 orderpoint.qty_forecast = products_qty[orderpoint.product_id.id]['virtual_available'] + products_qty_in_progress[orderpoint.id]
 
-    @api.depends('qty_multiple', 'qty_forecast', 'product_min_qty', 'product_max_qty', 'visibility_days')
+    @api.depends('qty_to_order_manual', 'qty_to_order_computed')
     def _compute_qty_to_order(self):
+        for orderpoint in self:
+            orderpoint.qty_to_order = orderpoint.qty_to_order_manual if orderpoint.qty_to_order_manual else orderpoint.qty_to_order_computed
+
+    def _inverse_qty_to_order(self):
+        for orderpoint in self:
+            orderpoint.qty_to_order_manual = orderpoint.qty_to_order
+
+    def _search_qty_to_order(self, operator, value):
+        records = self.search_fetch([('qty_to_order_manual', '=', '0')], ['qty_to_order_computed'])
+        matched_ids = records.filtered_domain([('qty_to_order_computed', operator, value)]).ids
+        return ['|',
+                    '&', ('qty_to_order_manual', '=', '0'), ('qty_to_order_manual', operator, value),
+                    ('id', 'in', matched_ids)
+                ]
+
+    @api.depends('qty_multiple', 'qty_forecast', 'product_min_qty', 'product_max_qty', 'visibility_days')
+    def _compute_qty_to_order_computed(self):
         for orderpoint in self:
             if not orderpoint.product_id or not orderpoint.location_id:
-                orderpoint.qty_to_order = False
+                orderpoint.qty_to_order_computed = False
                 continue
             qty_to_order = 0.0
             rounding = orderpoint.product_uom.rounding
@@ -286,7 +306,7 @@ class StockWarehouseOrderpoint(models.Model):
                 if (float_compare(remainder, 0.0, precision_rounding=rounding) > 0
                         and float_compare(orderpoint.qty_multiple - remainder, 0.0, precision_rounding=rounding) > 0):
                     qty_to_order -= remainder
-            orderpoint.qty_to_order = qty_to_order
+            orderpoint.qty_to_order_computed = qty_to_order
 
     def _get_qty_multiple_to_order(self):
         """ Calculates the minimum quantity that can be ordered according to the PO UoM or BoM
@@ -409,10 +429,10 @@ class StockWarehouseOrderpoint(models.Model):
         orderpoint_by_product_location = self.env['stock.warehouse.orderpoint']._read_group(
             [('id', 'in', orderpoints.ids)],
             ['product_id', 'location_id'],
-            ['qty_to_order:sum'])
+            ['id:recordset'])
         orderpoint_by_product_location = {
-            (product.id, location.id): qty_to_order_sum
-            for product, location, qty_to_order_sum in orderpoint_by_product_location
+            (product.id, location.id): orderpoint.qty_to_order
+            for product, location, orderpoint in orderpoint_by_product_location
         }
         for (product, location), product_qty in to_refill.items():
             qty_in_progress = qty_by_product_loc.get((product, location)) or 0.0
@@ -455,6 +475,9 @@ class StockWarehouseOrderpoint(models.Model):
             orderpoint.qty_multiple = orderpoint._get_qty_multiple_to_order()
         return action
 
+    def action_remove_manual_qty_to_order(self):
+        self.qty_to_order_manual = 0
+
     @api.model
     def _get_orderpoint_values(self, product, location):
         return {

--- a/addons/stock/models/stock_rule.py
+++ b/addons/stock/models/stock_rule.py
@@ -578,9 +578,6 @@ class ProcurementGroup(models.Model):
         # Minimum stock rules
         domain = self._get_orderpoint_domain(company_id=company_id)
         orderpoints = self.env['stock.warehouse.orderpoint'].search(domain)
-        # ensure that qty_* which depends on datetime.now() are correctly
-        # recomputed
-        orderpoints.sudo()._compute_qty_to_order()
         if use_new_cursor:
             self._cr.commit()
         orderpoints.sudo()._procure_orderpoint_confirm(use_new_cursor=use_new_cursor, company_id=company_id, raise_user_error=False)
