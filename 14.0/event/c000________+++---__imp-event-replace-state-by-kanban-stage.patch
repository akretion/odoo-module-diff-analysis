PR: https://github.com/odoo/odoo/pull/

From: 412ff994f1120457c912aad487265e3de8a9f35a
From: Debauche StÃ©phane
Date: 2020-01-08 09:11:50

Structural Changes: 15.3
Total Changes: 147

[IMP] event: replace state by kanban stage

Purpose
=======
Remove the state on the event and add a stage.
So, we can have more control on the event flow, and we will have less constrains.

Website event
=============
Before
------
People can register for an event if "seats are available" and if the state is "confirmed".

After
-----
People can register for an event if `event_registrations_open` is True,
- Event: seats are available and the event is not finished
- Event sale:  One or more ticket has `sale_available` set to True

Task #2088538

================================= pseudo patch: =================================

--- a/addons/event/models/__init__.py
+++ b/addons/event/models/__init__.py
@@ -3,5 +3,6 @@
 
 from . import event
 from . import event_mail
+from . import event_stage
 from . import res_config_settings
 from . import res_partner

--- a/addons/event/models/event.py
+++ b/addons/event/models/event.py
@@ -95,19 +95,23 @@ class EventEvent(models.Model):
     _inherit = ['mail.thread', 'mail.activity.mixin']
     _order = 'date_begin'
 
+    def _get_default_stage_id(self):
+        event_stages = self.env['event.stage'].search([])
+        return event_stages[0] if event_stages else False
+
     name = fields.Char(
         string='Event', translate=True, required=True,
-        readonly=False, states={'done': [('readonly', True)]})
+        readonly=False)
     active = fields.Boolean(default=True)
     user_id = fields.Many2one(
         'res.users', string='Responsible',
         default=lambda self: self.env.user,
         tracking=True,
-        readonly=False, states={'done': [('readonly', True)]})
+        readonly=False)
     company_id = fields.Many2one(
         'res.company', string='Company', change_default=True,
         default=lambda self: self.env.company,
-        required=False, readonly=False, states={'done': [('readonly', True)]})
+        required=False, readonly=False)
     organizer_id = fields.Many2one(
         'res.partner', string='Organizer',
         tracking=True,
@@ -115,14 +119,22 @@ class EventEvent(models.Model):
         domain="['|', ('company_id', '=', False), ('company_id', '=', company_id)]")
     event_type_id = fields.Many2one(
         'event.type', string='Category',
-        readonly=False, states={'done': [('readonly', True)]})
+        readonly=False)
     color = fields.Integer('Kanban Color Index')
     event_mail_ids = fields.One2many('event.mail', 'event_id', string='Mail Schedule', copy=True)
-
+    # Kanban fields
+    kanban_state = fields.Selection([('normal', 'In Progress'), ('done', 'Done'), ('blocked', 'Blocked')])
+    kanban_state_label = fields.Char(compute='_compute_kanban_state_label', string='Kanban State Label', tracking=True, store=True)
+    stage_id = fields.Many2one(
+        'event.stage', ondelete='restrict', default=_get_default_stage_id,
+        group_expand='_read_group_stage_ids', tracking=True)
+    legend_blocked = fields.Char(related='stage_id.legend_blocked', string='Kanban Blocked Explanation', readonly=True)
+    legend_done = fields.Char(related='stage_id.legend_done', string='Kanban Valid Explanation', readonly=True)
+    legend_normal = fields.Char(related='stage_id.legend_normal', string='Kanban Ongoing Explanation', readonly=True)
     # Seats and computation
     seats_max = fields.Integer(
         string='Maximum Attendees Number',
-        readonly=True, states={'draft': [('readonly', False)], 'confirm': [('readonly', False)]},
+        readonly=True,
         help="For each event you can define a maximum registration of seats(number of attendees), above this numbers the registrations are not accepted.")
     seats_availability = fields.Selection(
         [('limited', 'Limited'), ('unlimited', 'Unlimited')],
@@ -145,41 +157,35 @@ class EventEvent(models.Model):
     seats_expected = fields.Integer(
         string='Number of Expected Attendees',
         compute_sudo=True, readonly=True, compute='_compute_seats')
-
     # Registration fields
     registration_ids = fields.One2many(
         'event.registration', 'event_id', string='Attendees',
-        readonly=False, states={'done': [('readonly', True)]})
+        readonly=False)
+    event_registrations_open = fields.Boolean('Registration open', compute='_compute_event_registrations_open')
     # Date fields
     date_tz = fields.Selection('_tz_get', string='Timezone', required=True, default=lambda self: self.env.user.tz or 'UTC')
     date_begin = fields.Datetime(
         string='Start Date', required=True,
-        tracking=True, states={'done': [('readonly', True)]})
+        tracking=True)
     date_end = fields.Datetime(
         string='End Date', required=True,
-        tracking=True, states={'done': [('readonly', True)]})
+        tracking=True)
     date_begin_located = fields.Char(string='Start Date Located', compute='_compute_date_begin_tz')
     date_end_located = fields.Char(string='End Date Located', compute='_compute_date_end_tz')
     is_one_day = fields.Boolean(compute='_compute_field_is_one_day')
-
-    state = fields.Selection([
-        ('draft', 'Unconfirmed'), ('cancel', 'Cancelled'),
-        ('confirm', 'Confirmed'), ('done', 'Done')],
-        string='Status', default='draft', readonly=True, required=True, copy=False,
-        help="If event is created, the status is 'Draft'. If event is confirmed for the particular dates the status is set to 'Confirmed'. If the event is over, the status is set to 'Done'. If event is cancelled the status is set to 'Cancelled'.")
     auto_confirm = fields.Boolean(string='Autoconfirm Registrations')
     is_online = fields.Boolean('Online Event')
     address_id = fields.Many2one(
         'res.partner', string='Location',
         default=lambda self: self.env.company.partner_id,
-        readonly=False, states={'done': [('readonly', True)]},
+        readonly=False,
         domain="['|', ('company_id', '=', False), ('company_id', '=', company_id)]",
         tracking=True)
     country_id = fields.Many2one('res.country', 'Country',  related='address_id.country_id', store=True, readonly=False)
     twitter_hashtag = fields.Char('Twitter Hashtag')
     description = fields.Html(
         string='Description', translate=html_translate, sanitize_attributes=False,
-        readonly=False, states={'done': [('readonly', True)]})
+        readonly=False)
     # badge fields
     badge_front = fields.Html(string='Badge Front')
     badge_back = fields.Html(string='Badge Back')
@@ -216,6 +222,21 @@ class EventEvent(models.Model):
                 event.seats_available = event.seats_max - (event.seats_reserved + event.seats_used)
             event.seats_expected = event.seats_unconfirmed + event.seats_reserved + event.seats_used
 
+    @api.depends('date_end', 'seats_available', 'seats_availability')
+    def _compute_event_registrations_open(self):
+        for event in self:
+            event.event_registrations_open = event.date_end > fields.Datetime.now() and (event.seats_available or event.seats_availability == 'unlimited')
+
+    @api.depends('stage_id', 'kanban_state')
+    def _compute_kanban_state_label(self):
+        for event in self:
+            if event.kanban_state == 'normal':
+                event.kanban_state_label = event.stage_id.legend_normal
+            elif event.kanban_state == 'blocked':
+                event.kanban_state_label = event.stage_id.legend_blocked
+            else:
+                event.kanban_state_label = event.stage_id.legend_done
+
     @api.model
     def _tz_get(self):
         return [(x, x) for x in pytz.all_timezones]
@@ -307,13 +328,15 @@ class EventEvent(models.Model):
             result.append((event.id, '%s (%s)' % (event.name, ' - '.join(dates))))
         return result
 
+    @api.model
+    def _read_group_stage_ids(self, stages, domain, order):
+        return self.env['event.stage'].search([])
+
     @api.model
     def create(self, vals):
         res = super(EventEvent, self).create(vals)
         if res.organizer_id:
             res.message_subscribe([res.organizer_id.id])
-        if res.auto_confirm:
-            res.button_confirm()
         return res
 
     def write(self, vals):
@@ -328,29 +351,21 @@ class EventEvent(models.Model):
         default = dict(default or {}, name=_("%s (copy)") % (self.name))
         return super(EventEvent, self).copy(default)
 
-    def button_draft(self):
-        self.write({'state': 'draft'})
-
-    def button_cancel(self):
-        if any('done' in event.mapped('registration_ids.state') for event in self):
-            raise UserError(_("There are already attendees who attended this event. Please reset it to draft if you want to cancel this event."))
-        self.registration_ids.write({'state': 'cancel'})
-        self.state = 'cancel'
-
-    def button_done(self):
-        self.write({'state': 'done'})
-
-    def button_confirm(self):
-        self.write({'state': 'confirm'})
+    def action_set_done(self):
+        """
+        Action which will move the events
+        into the first next (by sequence) stage defined as "Ended"
+        (if they are not already in an ended stage)
+        """
+        first_ended_stage = self.env['event.stage'].search([('pipe_end', '=', True)], order='sequence')
+        if first_ended_stage:
+            self.write({'stage_id': first_ended_stage[0].id})
 
     def mail_attendees(self, template_id, force_send=False, filter_func=lambda self: self.state != 'cancel'):
         for event in self:
             for attendee in event.registration_ids.filtered(filter_func):
                 self.env['mail.template'].browse(template_id).send_mail(attendee.id, force_send=force_send)
 
-    def _is_event_registrable(self):
-        return self.date_end > fields.Datetime.now()
-
     def _get_ics_file(self):
         """ Returns iCalendar file for the event invitation.
             :returns a dict of .ics file content for each event
@@ -417,8 +432,7 @@ class EventRegistration(models.Model):
     def _check_auto_confirmation(self):
         if self._context.get('registration_force_draft'):
             return False
-        if any(registration.event_id.state != 'confirm' or
-               not registration.event_id.auto_confirm or
+        if any(not registration.event_id.auto_confirm or
                (not registration.event_id.seats_available and registration.event_id.seats_availability == 'limited') for registration in self):
             return False
         return True
@@ -463,13 +477,7 @@ class EventRegistration(models.Model):
     def button_reg_close(self):
         """ Close Registration """
         for registration in self:
-            today = fields.Datetime.now()
-            if registration.event_id.date_begin <= today and registration.event_id.state == 'confirm':
-                registration.write({'state': 'done', 'date_closed': today})
-            elif registration.event_id.state == 'draft':
-                raise UserError(_("You must wait the event confirmation before doing this action."))
-            else:
-                raise UserError(_("You must wait the event starting day before doing this action."))
+            registration.write({'state': 'done', 'date_closed': fields.Datetime.now()})
 
     def button_reg_cancel(self):
         self.write({'state': 'cancel'})

--- a/addons/event/models/event_mail.py
+++ b/addons/event/models/event_mail.py
@@ -92,19 +92,17 @@ class EventMailScheduler(models.Model):
             else:
                 mail.done = len(mail.mail_registration_ids) == len(mail.event_id.registration_ids) and all(mail.mail_sent for mail in mail.mail_registration_ids)
 
-    @api.depends('event_id.state', 'event_id.date_begin', 'interval_type', 'interval_unit', 'interval_nbr')
+    @api.depends('event_id.date_begin', 'interval_type', 'interval_unit', 'interval_nbr')
     def _compute_scheduled_date(self):
         for mail in self:
-            if mail.event_id.state not in ['confirm', 'done']:
-                mail.scheduled_date = False
+            if mail.interval_type == 'after_sub':
+                date, sign = mail.event_id.create_date, 1
+            elif mail.interval_type == 'before_event':
+                date, sign = mail.event_id.date_begin, -1
             else:
-                if mail.interval_type == 'after_sub':
-                    date, sign = mail.event_id.create_date, 1
-                elif mail.interval_type == 'before_event':
-                    date, sign = mail.event_id.date_begin, -1
-                else:
-                    date, sign = mail.event_id.date_end, 1
-                mail.scheduled_date = date + _INTERVALS[mail.interval_unit](sign * mail.interval_nbr)
+                date, sign = mail.event_id.date_end, 1
+
+            mail.scheduled_date = date + _INTERVALS[mail.interval_unit](sign * mail.interval_nbr) if date else False
 
     def execute(self):
         for mail in self:

--- a/None
+++ b/addons/event/models/event_stage.py
@@ -0,0 +1,28 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from odoo import _, fields, models
+
+
+class EventStage(models.Model):
+    _name = 'event.stage'
+    _description = 'Event Stage'
+    _order = 'sequence, name'
+
+    name = fields.Char(string='Stage Name', required=True, translate=True)
+    description = fields.Text(string='Stage description', translate=True)
+    sequence = fields.Integer('Sequence', default=1)
+    fold = fields.Boolean(string='Folded in Kanban', default=False)
+    pipe_end = fields.Boolean(
+        string='End Stage', default=False,
+        help='Events will be automatically be moved into this stage their are passed and event moved in the stage will be automatically greened')
+
+    legend_blocked = fields.Char(
+        'Red Kanban Label', default=lambda s: _('Blocked'), translate=True, required=True,
+        help='Override the default value displayed for the blocked state for kanban selection.')
+    legend_done = fields.Char(
+        'Green Kanban Label', default=lambda s: _('Ready for Next Stage'), translate=True, required=True,
+        help='Override the default value displayed for the done state for kanban selection.')
+    legend_normal = fields.Char(
+        'Grey Kanban Label', default=lambda s: _('In Progress'), translate=True, required=True,
+        help='Override the default value displayed for the normal state for kanban selection.')
