PR: https://github.com/odoo/odoo/pull/

From: 904f14120c918e1e57278ac023b0633a11b51aed
From: Jainik Patel
Date: 2016-07-12 15:52:28

Structural Changes: 32
Total Changes: 547

[MIG] stock_landed_costs: new API

================================= pseudo patch: =================================

--- a/addons/stock_landed_costs/models/product.py
+++ b/addons/stock_landed_costs/models/product.py
@@ -1,7 +1,7 @@
 # -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
-from openerp.osv import fields, osv
+from odoo import fields, models
 
 SPLIT_METHOD = [
     ('equal', 'Equal'),
@@ -11,19 +11,15 @@ SPLIT_METHOD = [
     ('by_volume', 'By Volume'),
 ]
 
-class product_template(osv.osv):
-    _inherit = "product.template"
 
-    _columns = {
-        'landed_cost_ok': fields.boolean('Landed Costs'),
-        'split_method': fields.selection(SPLIT_METHOD, 'Split Method', help="Equal : Cost will be equally divided.\n"\
-            "By Quantity : Cost will be divided according to product's quantity.\n"\
-            "By Current cost : Cost will be divided according to product's current cost.\n"\
-            "By Weight : Cost will be divided depending on its weight.\n"\
-            "By Volume : Cost will be divided depending on its volume."),
-    }
+class ProductTemplate(models.Model):
+    _inherit = "product.template"
 
-    _defaults = {
-        'landed_cost_ok': False,
-        'split_method': 'equal',
-    }
+    landed_cost_ok = fields.Boolean('Landed Costs')
+    split_method = fields.Selection(
+        selection=SPLIT_METHOD, string='Split Method', default='equal',
+        help="Equal : Cost will be equally divided.\n"
+             "By Quantity : Cost will be divided according to product's quantity.\n"
+             "By Current cost : Cost will be divided according to product's current cost.\n"
+             "By Weight : Cost will be divided depending on its weight.\n"
+             "By Volume : Cost will be divided depending on its volume.")

--- a/addons/stock_landed_costs/models/purchase_config_settings.py
+++ b/addons/stock_landed_costs/models/purchase_config_settings.py
@@ -1,8 +1,7 @@
 # -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
-from openerp import api, models
-from openerp.tools.translate import _
+from odoo import api, models, _
 
 
 class PurchaseConfigSettings(models.TransientModel):
@@ -12,13 +11,10 @@ class PurchaseConfigSettings(models.TransientModel):
     @api.onchange('group_costing_method')
     def onchange_costing_method(self):
         if self.group_costing_method == 0:
+            self.group_costing_method = 1
             return {
                 'warning': {
                     'title': _('Warning!'),
                     'message': _('Disabling the costing methods will prevent you to use the landed costs feature.'),
-                },
-                'value': {
-                    'group_costing_method': 1
                 }
             }
-        return {}

--- a/addons/stock_landed_costs/models/stock_landed_cost.py
+++ b/addons/stock_landed_costs/models/stock_landed_cost.py
@@ -1,124 +1,90 @@
 # -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
-from openerp.osv import fields, osv
-import openerp.addons.decimal_precision as dp
-from openerp.tools import float_compare, float_round
-from openerp.tools.translate import _
-import product
-from openerp import SUPERUSER_ID
-from openerp.exceptions import UserError
+from collections import defaultdict
 
+from odoo import api, fields, models, tools, _
+from odoo.addons import decimal_precision as dp
+from odoo.addons.stock_landed_costs.models import product
+from odoo.exceptions import UserError
 
-class stock_landed_cost(osv.osv):
+
+class LandedCost(models.Model):
     _name = 'stock.landed.cost'
     _description = 'Stock Landed Cost'
     _inherit = 'mail.thread'
 
-    def _total_amount(self, cr, uid, ids, name, args, context=None):
-        result = {}
-        for cost in self.browse(cr, uid, ids, context=context):
-            total = 0.0
-            for line in cost.cost_lines:
-                total += line.price_unit
-            result[cost.id] = total
-        return result
-
-    def _get_cost_line(self, cr, uid, ids, context=None):
-        cost_to_recompute = []
-        for line in self.pool.get('stock.landed.cost.lines').browse(cr, uid, ids, context=context):
-            cost_to_recompute.append(line.cost_id.id)
-        return cost_to_recompute
-
-    def get_valuation_lines(self, cr, uid, ids, context=None):
-        pickings = [picking for landed_cost in self.browse(cr, uid, ids, context=context) for picking in landed_cost.picking_ids]
-        lines = []
-
-        for picking in pickings:
-            for move in picking.move_lines:
-                # it doesn't make sense to make a landed cost for a product that isn't set as being valuated in real time at real cost
-                if move.product_id.valuation != 'real_time' or move.product_id.cost_method != 'real':
-                    continue
-                total_cost = 0.0
-                weight = move.product_id and move.product_id.weight * move.product_qty
-                volume = move.product_id and move.product_id.volume * move.product_qty
-                for quant in move.quant_ids:
-                    total_cost += quant.cost * quant.qty
-                vals = dict(product_id=move.product_id.id, move_id=move.id, quantity=move.product_qty, former_cost=total_cost, weight=weight, volume=volume)
-                lines.append(vals)
-
-        if not lines and pickings:
-            raise UserError(_('The selected picking does not contain any move that would be impacted by landed costs. Landed costs are only possible for products configured in real time valuation with real price costing method. Please make sure it is the case, or you selected the correct picking'))
-        return lines
-
-    _columns = {
-        'name': fields.char('Name', track_visibility='always', readonly=True, copy=False),
-        'date': fields.date('Date', required=True, states={'done': [('readonly', True)]}, track_visibility='onchange', copy=False),
-        'picking_ids': fields.many2many('stock.picking', string='Pickings', states={'done': [('readonly', True)]}, copy=False),
-        'cost_lines': fields.one2many('stock.landed.cost.lines', 'cost_id', 'Cost Lines', states={'done': [('readonly', True)]}, copy=True),
-        'valuation_adjustment_lines': fields.one2many('stock.valuation.adjustment.lines', 'cost_id', 'Valuation Adjustments', states={'done': [('readonly', True)]}),
-        'description': fields.text('Item Description', states={'done': [('readonly', True)]}),
-        'amount_total': fields.function(_total_amount, type='float', string='Total', digits=0,
-            store={
-                'stock.landed.cost': (lambda self, cr, uid, ids, c={}: ids, ['cost_lines'], 20),
-                'stock.landed.cost.lines': (_get_cost_line, ['price_unit', 'quantity', 'cost_id'], 20),
-            }, track_visibility='always'
-        ),
-        'state': fields.selection([('draft', 'Draft'), ('done', 'Posted'), ('cancel', 'Cancelled')], 'State', readonly=True, track_visibility='onchange', copy=False),
-        'account_move_id': fields.many2one('account.move', 'Journal Entry', readonly=True, copy=False),
-        'account_journal_id': fields.many2one('account.journal', 'Account Journal', required=True, states={'done': [('readonly', True)]}),
-    }
-
-    _defaults = {
-        'name': lambda obj, cr, uid, context: obj.pool.get('ir.sequence').next_by_code(cr, uid, 'stock.landed.cost'),
-        'state': 'draft',
-        'date': fields.date.context_today,
-    }
-
-    def _create_account_move(self, cr, uid, ids, context=None):
-        cost = self.browse(cr, uid, ids, context=context)[0]
-        vals = {
-            'journal_id': cost.account_journal_id.id,
-            'date': cost.date,
-            'ref': cost.name
-        }
-        return self.pool.get('account.move').create(cr, uid, vals, context=context)
-
-    def _check_sum(self, cr, uid, ids, context=None):
-        """
-        Will check if each cost line its valuation lines sum to the correct amount
-        and if the overall total amount is correct also
-        """
-        landed_cost = self.browse(cr, uid, ids, context=context)[0]
-        costcor = {}
-        tot = 0
-        for valuation_line in landed_cost.valuation_adjustment_lines:
-            if costcor.get(valuation_line.cost_line_id):
-                costcor[valuation_line.cost_line_id] += valuation_line.additional_landed_cost
-            else:
-                costcor[valuation_line.cost_line_id] = valuation_line.additional_landed_cost
-            tot += valuation_line.additional_landed_cost
-
-        prec = self.pool['decimal.precision'].precision_get(cr, uid, 'Account')
-        # float_compare returns 0 for equal amounts
-        res = not bool(float_compare(tot, landed_cost.amount_total, precision_digits=prec))
-        for costl in costcor.keys():
-            if float_compare(costcor[costl], costl.price_unit, precision_digits=prec):
-                res = False
-        return res
-
-    def button_validate(self, cr, uid, ids, context=None):
-        quant_obj = self.pool.get('stock.quant')
-
-        for cost in self.browse(cr, uid, ids, context=context):
-            if cost.state != 'draft':
-                raise UserError(_('Only draft landed costs can be validated'))
-            if not cost.valuation_adjustment_lines or not self._check_sum(cr, uid, [cost.id], context=context):
-                raise UserError(_('You cannot validate a landed cost which has no valid valuation adjustments lines. Did you click on Compute?'))
-            move_id = self._create_account_move(cr, uid, [cost.id], context=context)
-            for line in cost.valuation_adjustment_lines:
-                if not line.move_id:
-                    continue
+    name = fields.Char(
+        'Name', default=lambda self: self.env['ir.sequence'].next_by_code('stock.landed.cost'),
+        copy=False, readonly=True, track_visibility='always')
+    date = fields.Date(
+        'Date', default=fields.Date.context_today,
+        copy=False, required=True, states={'done': [('readonly', True)]}, track_visibility='onchange')
+    picking_ids = fields.Many2many(
+        'stock.picking', string='Pickings',
+        copy=False, states={'done': [('readonly', True)]})
+    cost_lines = fields.One2many(
+        'stock.landed.cost.lines', 'cost_id', 'Cost Lines',
+        copy=True, states={'done': [('readonly', True)]})
+    valuation_adjustment_lines = fields.One2many(
+        'stock.valuation.adjustment.lines', 'cost_id', 'Valuation Adjustments',
+        states={'done': [('readonly', True)]})
+    description = fields.Text(
+        'Item Description', states={'done': [('readonly', True)]})
+    amount_total = fields.Float(
+        'Total', compute='_compute_total_amount',
+        digits=0, store=True, track_visibility='always')
+    state = fields.Selection([
+        ('draft', 'Draft'),
+        ('done', 'Posted'),
+        ('cancel', 'Cancelled')], 'State', default='draft',
+        copy=False, readonly=True, track_visibility='onchange')
+    account_move_id = fields.Many2one(
+        'account.move', 'Journal Entry',
+        copy=False, readonly=True)
+    account_journal_id = fields.Many2one(
+        'account.journal', 'Account Journal',
+        required=True, states={'done': [('readonly', True)]})
+
+    @api.one
+    @api.depends('cost_lines.price_unit')
+    def _compute_total_amount(self):
+        self.amount_total = sum(line.price_unit for line in self.cost_lines)
+
+    @api.multi
+    def unlink(self):
+        self.button_cancel()
+        return super(LandedCost, self).unlink()
+
+    @api.multi
+    def _track_subtype(self, init_values):
+        if 'state' in init_values and self.state == 'done':
+            return 'stock_landed_costs.mt_stock_landed_cost_open'
+        return super(LandedCost, self)._track_subtype(init_values)
+
+    @api.multi
+    def button_cancel(self):
+        if any(cost.state == 'done' for cost in self):
+            raise UserError(
+                _('Validated landed costs cannot be cancelled, but you could create negative landed costs to reverse them'))
+        return self.write({'state': 'cancel'})
+
+    @api.multi
+    def button_validate(self):
+        if any(cost.state != 'draft' for cost in self):
+            raise UserError(_('Only draft landed costs can be validated'))
+        if any(not cost.valuation_adjustment_lines for cost in self):
+            raise UserError(_('No valuation adjustments lines. You should maybe recompute the landed costs.'))
+        if not self._check_sum():
+            raise UserError(_('Cost and adjustments lines do not match. You should maybe recompute the landed costs.'))
+
+        for cost in self:
+            move = self.env['account.move'].create({
+                'journal_id': cost.account_journal_id.id,
+                'date': cost.date,
+                'ref': cost.name
+            })
+            for line in cost.valuation_adjustment_lines.filtered(lambda line: line.move_id):
                 per_unit = line.final_cost / line.quantity
                 diff = per_unit - line.former_cost_per_unit
 
@@ -133,16 +99,16 @@ class stock_landed_cost(osv.osv):
                 # an arbitrary minimum quantity set to 2.0 from which we consider we can extract a
                 # unit and adapt the cost.
                 curr_rounding = line.move_id.company_id.currency_id.rounding
-                diff_rounded = float_round(diff, precision_rounding=curr_rounding)
+                diff_rounded = tools.float_round(diff, precision_rounding=curr_rounding)
                 diff_correct = diff_rounded
                 quants = line.move_id.quant_ids.sorted(key=lambda r: r.qty, reverse=True)
                 quant_correct = False
                 if quants\
-                        and float_compare(quants[0].product_id.uom_id.rounding, 1.0, precision_digits=1) == 0\
-                        and float_compare(line.quantity * diff, line.quantity * diff_rounded, precision_rounding=curr_rounding) != 0\
-                        and float_compare(quants[0].qty, 2.0, precision_rounding=quants[0].product_id.uom_id.rounding) >= 0:
+                        and tools.float_compare(quants[0].product_id.uom_id.rounding, 1.0, precision_digits=1) == 0\
+                        and tools.float_compare(line.quantity * diff, line.quantity * diff_rounded, precision_rounding=curr_rounding) != 0\
+                        and tools.float_compare(quants[0].qty, 2.0, precision_rounding=quants[0].product_id.uom_id.rounding) >= 0:
                     # Search for existing quant of quantity = 1.0 to avoid creating a new one
-                    quant_correct = quants.filtered(lambda r: float_compare(r.qty, 1.0, precision_rounding=quants[0].product_id.uom_id.rounding) == 0)
+                    quant_correct = quants.filtered(lambda r: tools.float_compare(r.qty, 1.0, precision_rounding=quants[0].product_id.uom_id.rounding) == 0)
                     if not quant_correct:
                         quant_correct = quants[0]._quant_split(quants[0].qty - 1.0)
                     else:
@@ -153,55 +119,80 @@ class stock_landed_cost(osv.osv):
 
                 quant_dict = {}
                 for quant in quants:
-                    quant_dict[quant.id] = quant.cost + diff
+                    quant_dict[quant] = quant.cost + diff
                 if quant_correct:
-                    quant_dict[quant_correct.id] = quant_correct.cost + diff_correct
-                for key, value in quant_dict.items():
-                    quant_obj.write(cr, SUPERUSER_ID, key, {'cost': value}, context=context)
+                    quant_dict[quant_correct] = quant_correct.cost + diff_correct
+                for quant, value in quant_dict.items():
+                    quant.sudo().write({'cost': value})
                 qty_out = 0
                 for quant in line.move_id.quant_ids:
                     if quant.location_id.usage != 'internal':
                         qty_out += quant.qty
-                line._create_accounting_entries(move_id, qty_out)
-            self.write(cr, uid, cost.id, {'state': 'done', 'account_move_id': move_id}, context=context)
-            self.pool.get('account.move').post(cr, uid, [move_id], context=context)
+                line._create_accounting_entries(move, qty_out)
+            cost.write({'state': 'done', 'account_move_id': move.id})
+            move.post()
         return True
 
-    def button_cancel(self, cr, uid, ids, context=None):
-        cost = self.browse(cr, uid, ids, context=context)
-        if cost.state == 'done':
-            raise UserError(_('Validated landed costs cannot be cancelled, '
-                            'but you could create negative landed costs to reverse them'))
-        return cost.write({'state': 'cancel'})
-
-    def unlink(self, cr, uid, ids, context=None):
-        # cancel or raise first
-        self.button_cancel(cr, uid, ids, context)
-        return super(stock_landed_cost, self).unlink(cr, uid, ids, context=context)
-
-    def compute_landed_cost(self, cr, uid, ids, context=None):
-        line_obj = self.pool.get('stock.valuation.adjustment.lines')
-        unlink_ids = line_obj.search(cr, uid, [('cost_id', 'in', ids)], context=context)
-        line_obj.unlink(cr, uid, unlink_ids, context=context)
-        digits = dp.get_precision('Product Price')(cr)
-        towrite_dict = {}
-        for cost in self.browse(cr, uid, ids, context=None):
-            if not cost.picking_ids:
+    def _check_sum(self):
+        """ Check if each cost line its valuation lines sum to the correct amount
+        and if the overall total amount is correct also """
+        prec_digits = self.env['decimal.precision'].precision_get('Account')
+        for landed_cost in self:
+            total_amount = sum(landed_cost.valuation_adjustment_lines.mapped('additional_landed_cost'))
+            if not tools.float_compare(total_amount, landed_cost.amount_total, precision_digits=prec_digits) == 0:
+                return False
+
+            val_to_cost_lines = defaultdict(lambda: 0.0)
+            for val_line in landed_cost.valuation_adjustment_lines:
+                val_to_cost_lines[val_line.cost_line_id] += val_line.additional_landed_cost
+            if any(tools.float_compare(cost_line.price_unit, val_amount, precision_digits=prec_digits) != 0
+                   for cost_line, val_amount in val_to_cost_lines.iteritems()):
+                return False
+        return True
+
+    def get_valuation_lines(self):
+        lines = []
+
+        for move in self.mapped('picking_ids').mapped('move_lines'):
+            # it doesn't make sense to make a landed cost for a product that isn't set as being valuated in real time at real cost
+            if move.product_id.valuation != 'real_time' or move.product_id.cost_method != 'real':
                 continue
+            vals = {
+                'product_id': move.product_id.id,
+                'move_id': move.id,
+                'quantity': move.product_qty,
+                'former_cost': sum(quant.cost * quant.qty for quant in move.quant_ids),
+                'weight': move.product_id.weight * move.product_qty,
+                'volume': move.product_id.volume * move.product_qty
+            }
+            lines.append(vals)
+
+        if not lines and self.mapped('picking_ids'):
+            raise UserError(_('The selected picking does not contain any move that would be impacted by landed costs. Landed costs are only possible for products configured in real time valuation with real price costing method. Please make sure it is the case, or you selected the correct picking'))
+        return lines
+
+    @api.multi
+    def compute_landed_cost(self):
+        AdjustementLines = self.env['stock.valuation.adjustment.lines']
+        AdjustementLines.search([('cost_id', 'in', self.ids)]).unlink()
+
+        digits = dp.get_precision('Product Price')(self._cr)
+        towrite_dict = {}
+        for cost in self.filtered(lambda cost: cost.picking_ids):
             total_qty = 0.0
             total_cost = 0.0
             total_weight = 0.0
             total_volume = 0.0
             total_line = 0.0
-            vals = self.get_valuation_lines(cr, uid, [cost.id], context=context)
-            for v in vals:
-                for line in cost.cost_lines:
-                    v.update({'cost_id': cost.id, 'cost_line_id': line.id})
-                    self.pool.get('stock.valuation.adjustment.lines').create(cr, uid, v, context=context)
-                total_qty += v.get('quantity', 0.0)
-                total_cost += v.get('former_cost', 0.0)
-                total_weight += v.get('weight', 0.0)
-                total_volume += v.get('volume', 0.0)
+            all_val_line_values = cost.get_valuation_lines()
+            for val_line_values in all_val_line_values:
+                for cost_line in cost.cost_lines:
+                    val_line_values.update({'cost_id': cost.id, 'cost_line_id': cost_line.id})
+                    self.env['stock.valuation.adjustment.lines'].create(val_line_values)
+                total_qty += val_line_values.get('quantity', 0.0)
+                total_cost += val_line_values.get('former_cost', 0.0)
+                total_weight += val_line_values.get('weight', 0.0)
+                total_volume += val_line_values.get('volume', 0.0)
                 total_line += 1
 
             for line in cost.cost_lines:
@@ -227,7 +218,7 @@ class stock_landed_cost(osv.osv):
                             value = (line.price_unit / total_line)
 
                         if digits:
-                            value = float_round(value, precision_digits=digits[1], rounding_method='UP')
+                            value = tools.float_round(value, precision_digits=digits[1], rounding_method='UP')
                             fnc = min if line.price_unit > 0 else max
                             value = fnc(value, line.price_unit - value_split)
                             value_split += value
@@ -238,123 +229,116 @@ class stock_landed_cost(osv.osv):
                             towrite_dict[valuation.id] += value
         if towrite_dict:
             for key, value in towrite_dict.items():
-                line_obj.write(cr, uid, key, {'additional_landed_cost': value}, context=context)
+                AdjustementLines.browse(key).write({'additional_landed_cost': value})
         return True
 
-    def _track_subtype(self, cr, uid, ids, init_values, context=None):
-        record = self.browse(cr, uid, ids[0], context=context)
-        if 'state' in init_values and record.state == 'done':
-            return 'stock_landed_costs.mt_stock_landed_cost_open'
-        return super(stock_landed_cost, self)._track_subtype(cr, uid, ids, init_values, context=context)
-
 
-class stock_landed_cost_lines(osv.osv):
+class LandedCostLine(models.Model):
     _name = 'stock.landed.cost.lines'
     _description = 'Stock Landed Cost Lines'
 
-    def onchange_product_id(self, cr, uid, ids, product_id=False, context=None):
-        result = {}
-        if not product_id:
-            return {'value': {'quantity': 0.0, 'price_unit': 0.0}}
-
-        product = self.pool.get('product.product').browse(cr, uid, product_id, context=context)
-        result['name'] = product.name
-        result['split_method'] = product.split_method
-        result['price_unit'] = product.standard_price
-        result['account_id'] = product.property_account_expense_id and product.property_account_expense_id.id or product.categ_id.property_account_expense_categ_id.id
-        return {'value': result}
-
-    _columns = {
-        'name': fields.char('Description'),
-        'cost_id': fields.many2one('stock.landed.cost', 'Landed Cost', required=True, ondelete='cascade'),
-        'product_id': fields.many2one('product.product', 'Product', required=True),
-        'price_unit': fields.float('Cost', required=True, digits_compute=dp.get_precision('Product Price')),
-        'split_method': fields.selection(product.SPLIT_METHOD, string='Split Method', required=True),
-        'account_id': fields.many2one('account.account', 'Account', domain=[('internal_type', '!=', 'view'), ('internal_type', '!=', 'closed'), ('deprecated', '=', False)]),
-    }
-
-class stock_valuation_adjustment_lines(osv.osv):
+    name = fields.Char('Description')
+    cost_id = fields.Many2one(
+        'stock.landed.cost', 'Landed Cost',
+        required=True, ondelete='cascade')
+    product_id = fields.Many2one('product.product', 'Product', required=True)
+    price_unit = fields.Float('Cost', digits_compute=dp.get_precision('Product Price'), required=True)
+    split_method = fields.Selection(product.SPLIT_METHOD, string='Split Method', required=True)
+    account_id = fields.Many2one(
+        'account.account', 'Account',
+        domain=[('internal_type', '!=', 'view'), ('internal_type', '!=', 'closed'), ('deprecated', '=', False)])
+
+    @api.onchange('product_id')
+    def onchange_product_id(self):
+        if not self.product_id:
+            self.quantity = 0.0
+        self.name = self.product_id.name or ''
+        self.split_method = self.product_id.split_method or 'equal'
+        self.price_unit = self.product_id.standard_price or 0.0
+        self.account_id = self.product_id.property_account_expense_id.id or self.product_id.categ_id.property_account_expense_categ_id.id
+
+
+class AdjustmentLines(models.Model):
     _name = 'stock.valuation.adjustment.lines'
     _description = 'Stock Valuation Adjustment Lines'
 
-    def _amount_final(self, cr, uid, ids, name, args, context=None):
-        result = {}
-        for line in self.browse(cr, uid, ids, context=context):
-            result[line.id] = {
-                'former_cost_per_unit': 0.0,
-                'final_cost': 0.0,
-            }
-            result[line.id]['former_cost_per_unit'] = (line.former_cost / line.quantity if line.quantity else 1.0)
-            result[line.id]['final_cost'] = (line.former_cost + line.additional_landed_cost)
-        return result
-
-    def _get_name(self, cr, uid, ids, name, arg, context=None):
-        res = {}
-        for line in self.browse(cr, uid, ids, context=context):
-            res[line.id] = line.product_id.code or line.product_id.name or ''
-            if line.cost_line_id:
-                res[line.id] += ' - ' + line.cost_line_id.name
-        return res
-
-    _columns = {
-        'name': fields.function(_get_name, type='char', string='Description', store=True),
-        'cost_id': fields.many2one('stock.landed.cost', 'Landed Cost', required=True, ondelete='cascade'),
-        'cost_line_id': fields.many2one('stock.landed.cost.lines', 'Cost Line', readonly=True),
-        'move_id': fields.many2one('stock.move', 'Stock Move', readonly=True),
-        'product_id': fields.many2one('product.product', 'Product', required=True),
-        'quantity': fields.float('Quantity', digits_compute=dp.get_precision('Product Unit of Measure'), required=True),
-        'weight': fields.float('Weight', digits_compute=dp.get_precision('Product Unit of Measure')),
-        'volume': fields.float('Volume', digits_compute=dp.get_precision('Product Unit of Measure')),
-        'former_cost': fields.float('Former Cost', digits_compute=dp.get_precision('Product Price')),
-        'former_cost_per_unit': fields.function(_amount_final, multi='cost', string='Former Cost(Per Unit)', type='float', store=True, digits=0),
-        'additional_landed_cost': fields.float('Additional Landed Cost', digits_compute=dp.get_precision('Product Price')),
-        'final_cost': fields.function(_amount_final, multi='cost', string='Final Cost', type='float', store=True, digits=0),
-    }
-
-    _defaults = {
-        'quantity': 1.0,
-        'weight': 1.0,
-        'volume': 1.0,
-    }
-
-    def _create_accounting_entries(self, cr, uid, ids, move_id, qty_out, context=None):
+    name = fields.Char(
+        'Description', compute='_compute_name', store=True)
+    cost_id = fields.Many2one(
+        'stock.landed.cost', 'Landed Cost',
+        ondelete='cascade', required=True)
+    cost_line_id = fields.Many2one(
+        'stock.landed.cost.lines', 'Cost Line', readonly=True)
+    move_id = fields.Many2one('stock.move', 'Stock Move', readonly=True)
+    product_id = fields.Many2one('product.product', 'Product', required=True)
+    quantity = fields.Float(
+        'Quantity', default=1.0,
+        digits_compute=dp.get_precision('Product Unit of Measure'), required=True)
+    weight = fields.Float(
+        'Weight', default=1.0,
+        digits_compute=dp.get_precision('Product Unit of Measure'))
+    volume = fields.Float(
+        'Volume', default=1.0,
+        digits_compute=dp.get_precision('Product Unit of Measure'))
+    former_cost = fields.Float(
+        'Former Cost', digits_compute=dp.get_precision('Product Price'))
+    former_cost_per_unit = fields.Float(
+        'Former Cost(Per Unit)', compute='_compute_former_cost_per_unit',
+        digits=0, store=True)
+    additional_landed_cost = fields.Float(
+        'Additional Landed Cost',
+        digits_compute=dp.get_precision('Product Price'))
+    final_cost = fields.Float(
+        'Final Cost', compute='_compute_final_cost',
+        digits=0, store=True)
+
+    @api.one
+    @api.depends('cost_line_id.name', 'product_id.code', 'product_id.name')
+    def _compute_name(self):
+        name = '%s - ' % (self.cost_line_id.name if self.cost_line_id else '')
+        self.name = name + (self.product_id.code or self.product_id.name or '')
+
+    @api.one
+    @api.depends('former_cost', 'quantity')
+    def _compute_former_cost_per_unit(self):
+        self.former_cost_per_unit = self.former_cost / (self.quantity or 1.0)
+
+    @api.one
+    @api.depends('former_cost', 'additional_landed_cost')
+    def _compute_final_cost(self):
+        self.final_cost = self.former_cost + self.additional_landed_cost
+
+    def _create_accounting_entries(self, move, qty_out):
         # TDE CLEANME: product chosen for computation ?
-        line = self.browse(cr, uid, ids, context=context)[0]
-        product_obj = self.pool.get('product.template')
-        cost_product = line.cost_line_id and line.cost_line_id.product_id
+        cost_product = self.cost_line_id.product_id
         if not cost_product:
             return False
-        accounts = product_obj.browse(cr, uid, line.product_id.product_tmpl_id.id, context=context).get_product_accounts()
-        debit_account_id = accounts.get('stock_valuation', False) and accounts['stock_valuation'].id or False
+        accounts = self.product_id.product_tmpl_id.get_product_accounts()
+        debit_account_id = accounts.get('stock_valuation') and accounts['stock_valuation'].id or False
         already_out_account_id = accounts['stock_output'].id
-        credit_account_id = line.cost_line_id.account_id.id or cost_product.property_account_expense_id.id or cost_product.categ_id.property_account_expense_categ_id.id
+        credit_account_id = self.cost_line_id.account_id.id or cost_product.property_account_expense_id.id or cost_product.categ_id.property_account_expense_categ_id.id
 
         if not credit_account_id:
             raise UserError(_('Please configure Stock Expense Account for product: %s.') % (cost_product.name))
 
-        return self._create_account_move_line(cr, uid, [line.id], move_id, credit_account_id, debit_account_id, qty_out, already_out_account_id, context=context)
+        return self._create_account_move_line(move, credit_account_id, debit_account_id, qty_out, already_out_account_id)
 
-    def _create_account_move_line(self, cr, uid, ids, move_id, credit_account_id, debit_account_id, qty_out, already_out_account_id, context=None):
+    def _create_account_move_line(self, move, credit_account_id, debit_account_id, qty_out, already_out_account_id):
         """
         Generate the account.move.line values to track the landed cost.
         Afterwards, for the goods that are already out of stock, we should create the out moves
         """
-        line = self.browse(cr, uid, ids, context=context)[0]
-        aml_obj = self.pool.get('account.move.line')
-        user_obj = self.pool.get('res.users')
-        if context is None:
-            context = {}
-        ctx = context.copy()
-        ctx['check_move_validity'] = False
+        AccountMoveLine = self.env['account.move.line'].with_context(check_move_validity=False)
+
         base_line = {
-            'name': line.name,
-            'move_id': move_id,
-            'product_id': line.product_id.id,
-            'quantity': line.quantity,
+            'name': self.name,
+            'move_id': move.id,
+            'product_id': self.product_id.id,
+            'quantity': self.quantity,
         }
         debit_line = dict(base_line, account_id=debit_account_id)
         credit_line = dict(base_line, account_id=credit_account_id)
-        diff = line.additional_landed_cost
+        diff = self.additional_landed_cost
         if diff > 0:
             debit_line['debit'] = diff
             credit_line['credit'] = diff
@@ -362,20 +346,20 @@ class stock_valuation_adjustment_lines(osv.osv):
             # negative cost, reverse the entry
             debit_line['credit'] = -diff
             credit_line['debit'] = -diff
-        aml_obj.create(cr, uid, debit_line, context=ctx)
-        aml_obj.create(cr, uid, credit_line, context=ctx)
-        
-        #Create account move lines for quants already out of stock
+        AccountMoveLine.create(debit_line)
+        AccountMoveLine.create(credit_line)
+
+        # Create account move lines for quants already out of stock
         if qty_out > 0:
             debit_line = dict(base_line,
-                              name=(line.name + ": " + str(qty_out) + _(' already out')),
+                              name=(self.name + ": " + str(qty_out) + _(' already out')),
                               quantity=qty_out,
                               account_id=already_out_account_id)
             credit_line = dict(base_line,
-                              name=(line.name + ": " + str(qty_out) + _(' already out')),
-                              quantity=qty_out,
-                              account_id=debit_account_id)
-            diff = diff * qty_out / line.quantity
+                               name=(self.name + ": " + str(qty_out) + _(' already out')),
+                               quantity=qty_out,
+                               account_id=debit_account_id)
+            diff = diff * qty_out / self.quantity
             if diff > 0:
                 debit_line['debit'] = diff
                 credit_line['credit'] = diff
@@ -383,18 +367,19 @@ class stock_valuation_adjustment_lines(osv.osv):
                 # negative cost, reverse the entry
                 debit_line['credit'] = -diff
                 credit_line['debit'] = -diff
-            aml_obj.create(cr, uid, debit_line, context=ctx)
-            aml_obj.create(cr, uid, credit_line, context=ctx)
+            AccountMoveLine.create(debit_line)
+            AccountMoveLine.create(credit_line)
 
-            if user_obj.browse(cr, uid, [uid], context=context).company_id.anglo_saxon_accounting:
+            # TDE FIXME: oh dear
+            if self.env.user.company_id.anglo_saxon_accounting:
                 debit_line = dict(base_line,
-                                  name=(line.name + ": " + str(qty_out) + _(' already out')),
+                                  name=(self.name + ": " + str(qty_out) + _(' already out')),
                                   quantity=qty_out,
                                   account_id=credit_account_id)
                 credit_line = dict(base_line,
-                                  name=(line.name + ": " + str(qty_out) + _(' already out')),
-                                  quantity=qty_out,
-                                  account_id=already_out_account_id)
+                                   name=(self.name + ": " + str(qty_out) + _(' already out')),
+                                   quantity=qty_out,
+                                   account_id=already_out_account_id)
 
                 if diff > 0:
                     debit_line['debit'] = diff
@@ -403,8 +388,8 @@ class stock_valuation_adjustment_lines(osv.osv):
                     # negative cost, reverse the entry
                     debit_line['credit'] = -diff
                     credit_line['debit'] = -diff
-                aml_obj.create(cr, uid, debit_line, context=ctx)
-                aml_obj.create(cr, uid, credit_line, context=ctx)
+                AccountMoveLine.create(debit_line)
+                AccountMoveLine.create(credit_line)
 
-        self.pool.get('account.move').assert_balanced(cr, uid, [move_id], context=context)
+        move.assert_balanced()
         return True
