PR: https://github.com/odoo/odoo/pull/63695

From: 0a8f4b6cda06806f18781d173a53da4fd57ff12f
From: fw-bot
Date: 2020-12-22 13:40:28

Structural Changes: 5
Total Changes: 187

Purpose
=======

This PR is in the continuity of odoo#62360.

- Display remaining hours in task sales_line_id (name_get + task form view)
- Remove internal reference from services demo data
- Display sol in project timesheets list if project is billable
- Remove use of non_allow_billable in timesheets as it has been removed from project and task in previous PR (see above)
- Only recompute planned_hours for service product
- Determine the correct SOL for timesheet
- Set the last SOL of customer on timesheet if none is set on task or project
- Allow edition of so_line in timesheet
- Restrict SOL on project to sale lines with a service product
- Use same widget on partner_id many2One than in sale.order (using ranking)
- Remove timesheets table in SO and invoice portal.They were added in previous PR (see above). This introduces the use of links to /my/timesheets/.
- Review portal timesheets (my/timesheets/ and link from orders and invoices)
- Activate group_uom "Units of Measure" on sale_timesheet install
- Hide partner phone number in task form view
- Only determine SOL of task and timesheet if allow_billable=True
- Filter SOL in task so that it matches the SOL of the project SO
- Display red label if remaining hours is negative
- Change SO compute behavior
- Only open SO for salesman on project overview

task-2409761

--
I confirm I have signed the CLA and read the PR guidelines at www.odoo.com/submit-pr

closes odoo/odoo#63695

Forward-port-of: #62900
X-original-commit: b1985773f3a67e28049f9e2bb635bcab059ad9c0
Related: odoo/enterprise#15427
Signed-off-by: Yannick Tivisse (yti) <yti@odoo.com>

================================= pseudo patch: =================================

--- a/addons/sale_timesheet/models/account.py
+++ b/addons/sale_timesheet/models/account.py
@@ -22,7 +22,9 @@ class AccountAnalyticLine(models.Model):
         ('non_billable_project', 'No task found')], string="Billable Type", compute='_compute_timesheet_invoice_type', compute_sudo=True, store=True, readonly=True)
     timesheet_invoice_id = fields.Many2one('account.move', string="Invoice", readonly=True, copy=False, help="Invoice created from the timesheet")
     non_allow_billable = fields.Boolean("Non-Billable", help="Your timesheet will not be billed.")
+    so_line = fields.Many2one(compute="_compute_so_line", store=True, readonly=False)
 
+    # TODO: [XBO] Since the task_id is not required in this model,  then it should more efficient to depends to bill_type and pricing_type of project (See in master)
     @api.depends('so_line.product_id', 'project_id', 'task_id', 'non_allow_billable', 'task_id.bill_type', 'task_id.pricing_type', 'task_id.non_allow_billable')
     def _compute_timesheet_invoice_type(self):
         non_allowed_billable = self.filtered('non_allow_billable')
@@ -55,12 +57,21 @@ class AccountAnalyticLine(models.Model):
             else:
                 self.so_line = False
 
+    @api.depends('task_id.sale_line_id', 'project_id.sale_line_id', 'employee_id', 'project_id.allow_billable')
+    def _compute_so_line(self):
+        for timesheet in self._get_not_billed():  # Get only the timesheets are not yet invoiced
+            timesheet.so_line = timesheet.project_id.allow_billable and timesheet._timesheet_determine_sale_line(timesheet.task_id, timesheet.employee_id, timesheet.project_id)
+
+    def _get_not_billed(self):
+        return self.filtered(lambda t: not t.timesheet_invoice_id or t.timesheet_invoice_id.state == 'cancel')
+
+    def _check_timesheet_can_be_billed(self):
+        return self.so_line in self.project_id.mapped('sale_line_employee_ids.sale_line_id') | self.task_id.sale_line_id | self.project_id.sale_line_id
+
     @api.constrains('so_line', 'project_id')
     def _check_sale_line_in_project_map(self):
-        for timesheet in self:
-            if timesheet.project_id and timesheet.so_line:  # billed timesheet
-                if timesheet.so_line not in timesheet.project_id.mapped('sale_line_employee_ids.sale_line_id') | timesheet.task_id.sale_line_id | timesheet.project_id.sale_line_id:
-                    raise ValidationError(_("This timesheet line cannot be billed: there is no Sale Order Item defined on the task, nor on the project. Please define one to save your timesheet line."))
+        if not all(t._check_timesheet_can_be_billed() for t in self._get_not_billed().filtered(lambda t: t.project_id and t.so_line)):
+            raise ValidationError(_("This timesheet line cannot be billed: there is no Sale Order Item defined on the task, nor on the project. Please define one to save your timesheet line."))
 
     def write(self, values):
         # prevent to update invoiced timesheets if one line is of type delivery
@@ -81,26 +92,8 @@ class AccountAnalyticLine(models.Model):
                 values['account_id'] = task.analytic_account_id.id
                 values['company_id'] = task.analytic_account_id.company_id.id
         values = super(AccountAnalyticLine, self)._timesheet_preprocess(values)
-        # task implies so line (at create)
-        if any([field_name in values for field_name in ['task_id', 'project_id']]) and not values.get('so_line') and (values.get('employee_id') or self.mapped('employee_id')):
-            if not values.get('employee_id') and len(self.mapped('employee_id')) > 1:
-                raise UserError(_('You can not modify timesheets from different employees'))
-            task = self.env['project.task'].sudo().browse(values['task_id']) if values.get('task_id') else self.env['project.task']
-            employee = self.env['hr.employee'].sudo().browse(values['employee_id']) if values.get('employee_id') else self.mapped('employee_id')
-            project = self.env['project.project'].sudo().browse(values['project_id']) if values.get('project_id') else task.project_id
-            values['so_line'] = self._timesheet_determine_sale_line(task, employee, project).id
         return values
 
-    def _timesheet_postprocess_values(self, values):
-        result = super(AccountAnalyticLine, self)._timesheet_postprocess_values(values)
-        # (re)compute the sale line
-        if any(field_name in values for field_name in ['task_id', 'employee_id', 'project_id']):
-            for timesheet in self:
-                result[timesheet.id].update({
-                    'so_line': timesheet._timesheet_determine_sale_line(timesheet.task_id, timesheet.employee_id, timesheet.project_id).id,
-                })
-        return result
-
     @api.model
     def _timesheet_determine_sale_line(self, task, employee, project):
         """ Deduce the SO line associated to the timesheet line:
@@ -108,19 +101,20 @@ class AccountAnalyticLine(models.Model):
             2/ timesheet on employee rate task: find the SO line in the map of the project (even for subtask), or fallback on the SO line of the task, or fallback
                 on the one on the project
         """
-        if project.sale_line_id and not task:
+        if not task:
             if project.bill_type == 'customer_project' and project.pricing_type == 'employee_rate':
                 map_entry = self.env['project.sale.line.employee.map'].search([('project_id', '=', project.id), ('employee_id', '=', employee.id)])
                 if map_entry:
                     return map_entry.sale_line_id
-            return project.sale_line_id
+            if project.sale_line_id:
+                return project.sale_line_id
         if task.allow_billable:
             if task.bill_type == 'customer_task':
                 return task.sale_line_id
             if task.pricing_type == 'fixed_rate':
                 return task.sale_line_id
             elif task.pricing_type == 'employee_rate' and not task.non_allow_billable:
-                map_entry = self.env['project.sale.line.employee.map'].search([('project_id', '=', task.project_id.id), ('employee_id', '=', employee.id)])
+                map_entry = project.sale_line_employee_ids.filtered(lambda map_entry: map_entry.employee_id == employee)
                 if map_entry:
                     return map_entry.sale_line_id
                 if task.sale_line_id or project.sale_line_id:
@@ -137,6 +131,9 @@ class AccountAnalyticLine(models.Model):
 
     @api.model
     def _timesheet_get_sale_domain(self, order_lines_ids, invoice_ids):
+        if not invoice_ids:
+            return [('so_line', 'in', order_lines_ids.ids)]
+
         return [
             '|',
             '&',

--- a/addons/sale_timesheet/models/project.py
+++ b/addons/sale_timesheet/models/project.py
@@ -47,6 +47,7 @@ class Project(models.Model):
             ('service_type', '=', 'timesheet'),
             '|', ('company_id', '=', False), ('company_id', '=', company_id)]""",
         help='Select a Service product with which you would like to bill your time spent on tasks.',
+        compute="_compute_timesheet_product_id", store=True, readonly=False,
         default=_default_timesheet_product_id)
     warning_employee_rate = fields.Boolean(compute='_compute_warning_employee_rate')
 
@@ -237,6 +238,28 @@ class ProjectTask(models.Model):
 
     # TODO: [XBO] remove me in master
     non_allow_billable = fields.Boolean("Non-Billable", help="Your timesheets linked to this task will not be billed.")
+    remaining_hours_so = fields.Float('Remaining Hours on SO', compute='_compute_remaining_hours_so')
+    remaining_hours_available = fields.Boolean(related="sale_line_id.remaining_hours_available")
+
+    @api.depends('sale_line_id', 'timesheet_ids', 'timesheet_ids.unit_amount')
+    def _compute_remaining_hours_so(self):
+        # TODO This is not yet perfectly working as timesheet.so_line stick to its old value although changed
+        #      in the task From View.
+        timesheets = self.timesheet_ids.filtered(lambda t: t.task_id.sale_line_id in (t.so_line, t._origin.so_line) and t.so_line.remaining_hours_available)
+
+        mapped_remaining_hours = {task._origin.id: task.sale_line_id and task.sale_line_id.remaining_hours or 0.0 for task in self}
+        uom_hour = self.env.ref('uom.product_uom_hour')
+        for timesheet in timesheets:
+            delta = 0
+            if timesheet._origin.so_line == timesheet.task_id.sale_line_id:
+                delta += timesheet._origin.unit_amount
+            if timesheet.so_line == timesheet.task_id.sale_line_id:
+                delta -= timesheet.unit_amount
+            if delta:
+                mapped_remaining_hours[timesheet.task_id._origin.id] += timesheet.so_line.product_uom._compute_quantity(delta, uom_hour)
+
+        for task in self:
+            task.remaining_hours_so = mapped_remaining_hours[task._origin.id]
 
     @api.depends(
         'allow_billable', 'allow_timesheets', 'sale_order_id')
@@ -265,17 +288,25 @@ class ProjectTask(models.Model):
         for task in self:
             task.analytic_account_active = task.analytic_account_active or task.analytic_account_id.active
 
-    @api.depends('sale_line_id', 'project_id', 'allow_billable', 'bill_type', 'pricing_type', 'non_allow_billable')
+    @api.depends('sale_line_id', 'project_id', 'allow_billable', 'non_allow_billable')
     def _compute_sale_order_id(self):
         for task in self:
-            if task.allow_billable and task.bill_type == 'customer_project' and task.pricing_type == 'employee_rate' and task.non_allow_billable:
-                task.sale_order_id = False
-            elif task.allow_billable and task.bill_type == 'customer_project':
-                task.sale_order_id = task.project_id.sale_order_id
-            elif task.allow_billable and task.bill_type == 'customer_task':
-                task.sale_order_id = task.sale_line_id.sudo().order_id
-            elif not task.sale_order_id:
+            if not task.allow_billable or task.non_allow_billable:
                 task.sale_order_id = False
+            elif task.allow_billable:
+                if task.sale_line_id:
+                    task.sale_order_id = task.sale_line_id.sudo().order_id
+                elif task.project_id.sale_order_id:
+                    task.sale_order_id = task.project_id.sale_order_id
+                if task.sale_order_id and not task.partner_id:
+                    task.partner_id = task.sale_order_id.partner_id
+
+    @api.depends('commercial_partner_id', 'sale_line_id.order_partner_id.commercial_partner_id', 'parent_id.sale_line_id', 'project_id.sale_line_id', 'allow_billable')
+    def _compute_sale_line(self):
+        billable_tasks = self.filtered('allow_billable')
+        super(ProjectTask, billable_tasks)._compute_sale_line()
+        for task in billable_tasks.filtered(lambda t: not t.sale_line_id):
+            task.sale_line_id = task._get_last_sol_of_customer()
 
     @api.depends('project_id.sale_line_employee_ids')
     def _compute_is_project_map_empty(self):
@@ -302,22 +333,6 @@ class ProjectTask(models.Model):
             project_dest = self.env['project.project'].browse(values['project_id'])
             if project_dest.bill_type == 'customer_project' and project_dest.pricing_type == 'employee_rate':
                 self.write({'sale_line_id': False})
-        if 'sale_line_id' in values and self.filtered('allow_timesheets').sudo().timesheet_ids:
-            so = self.env['sale.order.line'].browse(values['sale_line_id']).order_id
-            if so and not so.analytic_account_id:
-                so.analytic_account_id = self.project_id.analytic_account_id
-            timesheet_ids = self.filtered('allow_timesheets').timesheet_ids.filtered(
-                lambda t: (not t.timesheet_invoice_id or t.timesheet_invoice_id.state == 'cancel')
-            )
-            timesheet_ids.write({'so_line': values['sale_line_id']})
-            if 'project_id' in values:
-
-                # Special case when we edit SOL an project in same time, as we edit SOL of
-                # timesheet lines, function '_get_timesheet' won't find the right timesheet
-                # to edit so we must edit those here.
-                project = self.env['project.project'].browse(values.get('project_id'))
-                if project.allow_timesheets:
-                    timesheet_ids.write({'project_id': values.get('project_id')})
         if 'non_allow_billable' in values and self.filtered('allow_timesheets').sudo().timesheet_ids:
             timesheet_ids = self.filtered('allow_timesheets').timesheet_ids.filtered(
                 lambda t: (not t.timesheet_invoice_id or t.timesheet_invoice_id.state == 'cancel')
@@ -335,6 +350,20 @@ class ProjectTask(models.Model):
 
         return res
 
+    def _get_last_sol_of_customer(self):
+        # Get the last SOL made for the customer in the current task where we need to compute
+        self.ensure_one()
+        if not self.commercial_partner_id or not self.allow_billable:
+            return False
+        domain = [('is_service', '=', True), ('order_partner_id', 'child_of', self.commercial_partner_id.id), ('is_expense', '=', False), ('state', 'in', ['sale', 'done'])]
+        if self.project_id.bill_type == 'customer_type' and self.project_sale_order_id:
+            domain.append(('order_id', '=?', self.project_sale_order_id.id))
+        sale_lines = self.env['sale.order.line'].search(domain)
+        for line in sale_lines:
+            if line.remaining_hours_available and line.remaining_hours > 0:
+                return line
+        return False
+
     def action_make_billable(self):
         return {
             "name": _("Create Sales Order"),

--- a/addons/sale_timesheet/models/sale_order.py
+++ b/addons/sale_timesheet/models/sale_order.py
@@ -1,8 +1,9 @@
 # -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
-from odoo import api, fields, models
+from odoo import api, fields, models, _
 from odoo.osv import expression
+import math
 
 
 class SaleOrder(models.Model):
@@ -77,6 +78,66 @@ class SaleOrderLine(models.Model):
 
     qty_delivered_method = fields.Selection(selection_add=[('timesheet', 'Timesheets')])
     analytic_line_ids = fields.One2many(domain=[('project_id', '=', False)])  # only analytic lines, not timesheets (since this field determine if SO line came from expense)
+    remaining_hours_available = fields.Boolean(compute='_compute_remaining_hours_available')
+    remaining_hours = fields.Float('Remaining Hours on SO', compute='_compute_remaining_hours')
+
+    def name_get(self):
+        res = super(SaleOrderLine, self).name_get()
+        if self.env.context.get('with_remaining_hours'):
+            names = dict(res)
+            result = []
+            uom_hour = self.env.ref('uom.product_uom_hour')
+            uom_day = self.env.ref('uom.product_uom_day')
+            for line in self:
+                name = names.get(line.id)
+                if line.remaining_hours_available:
+                    company = self.env.company
+                    encoding_uom = company.timesheet_encode_uom_id
+                    remaining_time = ''
+                    if encoding_uom == uom_hour:
+                        hours, minutes = divmod(abs(line.remaining_hours) * 60, 60)
+                        round_minutes = minutes / 30
+                        minutes = math.ceil(round_minutes) if line.remaining_hours >= 0 else math.floor(round_minutes)
+                        if minutes > 1:
+                            minutes = 0
+                            hours += 1
+                        else:
+                            minutes = minutes * 30
+                        remaining_time =' ({sign}{hours:02.0f}:{minutes:02.0f})'.format(
+                            sign='-' if line.remaining_hours < 0 else '',
+                            hours=hours,
+                            minutes=minutes)
+                    elif encoding_uom == uom_day:
+                        remaining_days = company.project_time_mode_id._compute_quantity(line.remaining_hours, encoding_uom, round=False)
+                        remaining_time = ' ({qty:.02f} {unit})'.format(
+                            qty=remaining_days,
+                            unit=_('days') if abs(remaining_days) > 1 else _('day')
+                        )
+                    name = '{name}{remaining_time}'.format(
+                        name=name,
+                        remaining_time=remaining_time
+                    )
+                result.append((line.id, name))
+            return result
+        return res
+
+    @api.depends('product_id.service_policy')
+    def _compute_remaining_hours_available(self):
+        uom_hour = self.env.ref('uom.product_uom_hour')
+        for line in self:
+            is_ordered_timesheet = line.product_id.service_policy == 'ordered_timesheet'
+            is_time_product = line.product_uom.category_id == uom_hour.category_id
+            line.remaining_hours_available = is_ordered_timesheet and is_time_product
+
+    @api.depends('qty_delivered', 'product_uom_qty', 'analytic_line_ids')
+    def _compute_remaining_hours(self):
+        uom_hour = self.env.ref('uom.product_uom_hour')
+        for line in self:
+            remaining_hours = None
+            if line.remaining_hours_available:
+                qty_left = line.product_uom_qty - line.qty_delivered
+                remaining_hours = line.product_uom._compute_quantity(qty_left, uom_hour)
+            line.remaining_hours = remaining_hours
 
     @api.depends('product_id')
     def _compute_qty_delivered_method(self):
