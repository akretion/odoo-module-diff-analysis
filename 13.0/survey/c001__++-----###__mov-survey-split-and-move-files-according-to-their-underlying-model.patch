PR: https://github.com/odoo/odoo/pull/

From: 6da632a68e0e99e25b52cc43e6993252881d6461
From: Thibault Delavall√©e
Date: 2018-11-14 14:57:27

Breaking data model changes scores: del:44.4 + add:4, change matches:
+    question_ids = fields.One2many('survey.question', 'page_id', string='Questions', copy=True)
+    labels_ids = fields.One2many('survey.label', 'question_id', string='Types of answers', oldname='answer_choice_ids', copy=True)
+    labels_ids_2 = fields.One2many('survey.label', 'question_id_2', string='Rows of the Matrix', copy=True)
+    user_input_line_ids = fields.One2many('survey.user_input_line', 'question_id', string='Answers', domain=[('skipped', '=', False)])
-    name = fields.Char(required=True, translate=True)
-    sequence = fields.Integer(default=1)
-    closed = fields.Boolean(help="If closed, people won't be able to answer to surveys in this column.")
-    fold = fields.Boolean(string="Folded in kanban view")
-    title = fields.Char('Page Title', required=True, translate=True)
-    question_ids = fields.One2many('survey.question', 'page_id', string='Questions', copy=True)
-    sequence = fields.Integer('Page number', default=10)
-    description = fields.Html('Description', translate=True, oldname="note", help="An introductory text to your page")
-    survey_id = fields.Many2one('survey.survey', related='page_id.survey_id', string='Survey', readonly=False)
-    sequence = fields.Integer('Sequence', default=10)
-    question = fields.Char('Question Name', required=True, translate=True)
-    description = fields.Html('Description', help="Use this field to add \
-    question_type = fields.Selection([
-    matrix_subtype = fields.Selection([('simple', 'One choice per row'),
-    labels_ids = fields.One2many('survey.label', 'question_id', string='Types of answers', oldname='answer_choice_ids', copy=True)
-    labels_ids_2 = fields.One2many('survey.label', 'question_id_2', string='Rows of the Matrix', copy=True)
-    column_nb = fields.Selection([('12', '1'),
-    display_mode = fields.Selection([('columns', 'Radio Buttons'),
-    comments_allowed = fields.Boolean('Show Comments Field',
-    comments_message = fields.Char('Comment Message', translate=True, default=lambda self: _("If other, please specify:"))
-    comment_count_as_answer = fields.Boolean('Comment Field is an Answer Choice',
-    validation_required = fields.Boolean('Validate entry', oldname='is_validation_require')
-    validation_email = fields.Boolean('Input must be an email')
-    validation_length_min = fields.Integer('Minimum Text Length')
-    validation_length_max = fields.Integer('Maximum Text Length')
-    validation_min_float_value = fields.Float('Minimum value')
-    validation_max_float_value = fields.Float('Maximum value')
-    validation_min_date = fields.Date('Minimum Date')
-    validation_max_date = fields.Date('Maximum Date')
-    validation_error_msg = fields.Char('Validation Error message', oldname='validation_valid_err_msg',
-    constr_mandatory = fields.Boolean('Mandatory Answer', oldname="is_require_answer")
-    constr_error_msg = fields.Char('Error message', oldname='req_error_msg', translate=True, default=lambda self: _("This question requires an answer."))
-    question_id_2 = fields.Many2one('survey.question', string='Question 2', ondelete='cascade')
-    sequence = fields.Integer('Label Sequence order', default=10)
-    value = fields.Char('Suggested value', translate=True, required=True)
-    survey_id = fields.Many2one('survey.survey', string='Survey', required=True, readonly=True, ondelete='restrict')
-    user_input_line_ids = fields.One2many('survey.user_input_line', 'user_input_id', string='Answers', copy=True)
-    question_id = fields.Many2one('survey.question', string='Question', ondelete='restrict', required=True)
-    page_id = fields.Many2one(related='question_id.page_id', string="Page", readonly=False)
-    survey_id = fields.Many2one(related='user_input_id.survey_id', string='Survey', store=True, readonly=False)
-    quizz_mark = fields.Float('Score given for this choice')
+    survey_id = fields.Many2one(related='user_input_id.survey_id', string='Survey', store=True, readonly=False)

Total Changes: 1442

[MOV] survey: split and move files according to their underlying model

Purpose of this commit is to polish a bit this old module before working
on it. Contains

 * split python model into separate main files to ease models understanding;
 * split views into separate main files to ease views finding;
 * move data lost in views to data files (server action notably);
 * merge templates in the same file to have all available at hand;
 * move assets in their own file in order to remove noise from templates;

No functional behavior change should occur with this commit. Only move
has been performed.

This commit is linked to task ID 1903617 and PR #28166.

================================= pseudo patch: =================================

--- a/addons/survey/models/__init__.py
+++ b/addons/survey/models/__init__.py
@@ -1,5 +1,9 @@
 # -*- encoding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
-from . import survey_survey
 from . import ir_autovacuum
+from . import survey_survey
+from . import survey_page
+from . import survey_question
+from . import survey_stage
+from . import survey_user

--- a/None
+++ b/addons/survey/models/survey_page.py
@@ -0,0 +1,27 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from odoo import fields, models
+
+
+class SurveyPage(models.Model):
+    """ A page for a survey.
+
+        Pages are essentially containers, allowing to group questions by ordered
+        screens.
+
+        .. note::
+            A page should be deleted if the survey it belongs to is deleted.
+    """
+    _name = 'survey.page'
+    _description = 'Survey Page'
+    _rec_name = 'title'
+    _order = 'sequence,id'
+
+    # Model Fields #
+
+    title = fields.Char('Page Title', required=True, translate=True)
+    survey_id = fields.Many2one('survey.survey', string='Survey', ondelete='cascade', required=True)
+    question_ids = fields.One2many('survey.question', 'page_id', string='Questions', copy=True)
+    sequence = fields.Integer('Page number', default=10)
+    description = fields.Html('Description', translate=True, oldname="note", help="An introductory text to your page")
\ No newline at end of file

--- a/None
+++ b/addons/survey/models/survey_question.py
@@ -0,0 +1,299 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+import logging
+import re
+
+from odoo import api, fields, models, tools, _
+from odoo.exceptions import ValidationError
+
+email_validator = re.compile(r"[^@]+@[^@]+\.[^@]+")
+_logger = logging.getLogger(__name__)
+
+
+def dict_keys_startswith(dictionary, string):
+    """Returns a dictionary containing the elements of <dict> whose keys start with <string>.
+        .. note::
+            This function uses dictionary comprehensions (Python >= 2.7)
+    """
+    return {k: v for k, v in dictionary.items() if k.startswith(string)}
+
+
+class SurveyQuestion(models.Model):
+    """ Questions that will be asked in a survey.
+
+        Each question can have one of more suggested answers (eg. in case of
+        dropdown choices, multi-answer checkboxes, radio buttons...).
+    """
+
+    _name = 'survey.question'
+    _description = 'Survey Question'
+    _rec_name = 'question'
+    _order = 'sequence,id'
+
+    # Model fields #
+
+    # Question metadata
+    page_id = fields.Many2one('survey.page', string='Survey page',
+            ondelete='cascade', required=True, default=lambda self: self.env.context.get('page_id'))
+    survey_id = fields.Many2one('survey.survey', related='page_id.survey_id', string='Survey', readonly=False)
+    sequence = fields.Integer('Sequence', default=10)
+
+    # Question
+    question = fields.Char('Question Name', required=True, translate=True)
+    description = fields.Html('Description', help="Use this field to add \
+        additional explanations about your question", translate=True,
+        oldname='descriptive_text')
+
+    # Answer
+    question_type = fields.Selection([
+            ('free_text', 'Multiple Lines Text Box'),
+            ('textbox', 'Single Line Text Box'),
+            ('numerical_box', 'Numerical Value'),
+            ('date', 'Date'),
+            ('simple_choice', 'Multiple choice: only one answer'),
+            ('multiple_choice', 'Multiple choice: multiple answers allowed'),
+            ('matrix', 'Matrix')], string='Type of Question', default='free_text', required=True, oldname='type')
+    matrix_subtype = fields.Selection([('simple', 'One choice per row'),
+        ('multiple', 'Multiple choices per row')], string='Matrix Type', default='simple')
+    labels_ids = fields.One2many('survey.label', 'question_id', string='Types of answers', oldname='answer_choice_ids', copy=True)
+    labels_ids_2 = fields.One2many('survey.label', 'question_id_2', string='Rows of the Matrix', copy=True)
+    # labels are used for proposed choices
+    # if question.type == simple choice | multiple choice
+    #                    -> only labels_ids is used
+    # if question.type == matrix
+    #                    -> labels_ids are the columns of the matrix
+    #                    -> labels_ids_2 are the rows of the matrix
+
+    # Display options
+    column_nb = fields.Selection([('12', '1'),
+                                   ('6', '2'),
+                                   ('4', '3'),
+                                   ('3', '4'),
+                                   ('2', '6')],
+        'Number of columns', default='12')
+    # These options refer to col-xx-[12|6|4|3|2] classes in Bootstrap
+    display_mode = fields.Selection([('columns', 'Radio Buttons'),
+                                      ('dropdown', 'Selection Box')],
+                                    default='columns')
+
+    # Comments
+    comments_allowed = fields.Boolean('Show Comments Field',
+        oldname="allow_comment")
+    comments_message = fields.Char('Comment Message', translate=True, default=lambda self: _("If other, please specify:"))
+    comment_count_as_answer = fields.Boolean('Comment Field is an Answer Choice',
+        oldname='make_comment_field')
+
+    # Validation
+    validation_required = fields.Boolean('Validate entry', oldname='is_validation_require')
+    validation_email = fields.Boolean('Input must be an email')
+    validation_length_min = fields.Integer('Minimum Text Length')
+    validation_length_max = fields.Integer('Maximum Text Length')
+    validation_min_float_value = fields.Float('Minimum value')
+    validation_max_float_value = fields.Float('Maximum value')
+    validation_min_date = fields.Date('Minimum Date')
+    validation_max_date = fields.Date('Maximum Date')
+    validation_error_msg = fields.Char('Validation Error message', oldname='validation_valid_err_msg',
+                                        translate=True, default=lambda self: _("The answer you entered has an invalid format."))
+
+    # Constraints on number of answers (matrices)
+    constr_mandatory = fields.Boolean('Mandatory Answer', oldname="is_require_answer")
+    constr_error_msg = fields.Char('Error message', oldname='req_error_msg', translate=True, default=lambda self: _("This question requires an answer."))
+    user_input_line_ids = fields.One2many('survey.user_input_line', 'question_id', string='Answers', domain=[('skipped', '=', False)])
+
+    _sql_constraints = [
+        ('positive_len_min', 'CHECK (validation_length_min >= 0)', 'A length must be positive!'),
+        ('positive_len_max', 'CHECK (validation_length_max >= 0)', 'A length must be positive!'),
+        ('validation_length', 'CHECK (validation_length_min <= validation_length_max)', 'Max length cannot be smaller than min length!'),
+        ('validation_float', 'CHECK (validation_min_float_value <= validation_max_float_value)', 'Max value cannot be smaller than min value!'),
+        ('validation_date', 'CHECK (validation_min_date <= validation_max_date)', 'Max date cannot be smaller than min date!')
+    ]
+
+    @api.onchange('validation_email')
+    def onchange_validation_email(self):
+        if self.validation_email:
+            self.validation_required = False
+
+    # Validation methods
+
+    @api.multi
+    def validate_question(self, post, answer_tag):
+        """ Validate question, depending on question type and parameters """
+        self.ensure_one()
+        try:
+            checker = getattr(self, 'validate_' + self.question_type)
+        except AttributeError:
+            _logger.warning(self.question_type + ": This type of question has no validation method")
+            return {}
+        else:
+            return checker(post, answer_tag)
+
+    @api.multi
+    def validate_free_text(self, post, answer_tag):
+        self.ensure_one()
+        errors = {}
+        answer = post[answer_tag].strip()
+        # Empty answer to mandatory question
+        if self.constr_mandatory and not answer:
+            errors.update({answer_tag: self.constr_error_msg})
+        return errors
+
+    @api.multi
+    def validate_textbox(self, post, answer_tag):
+        self.ensure_one()
+        errors = {}
+        answer = post[answer_tag].strip()
+        # Empty answer to mandatory question
+        if self.constr_mandatory and not answer:
+            errors.update({answer_tag: self.constr_error_msg})
+        # Email format validation
+        # Note: this validation is very basic:
+        #     all the strings of the form
+        #     <something>@<anything>.<extension>
+        #     will be accepted
+        if answer and self.validation_email:
+            if not email_validator.match(answer):
+                errors.update({answer_tag: _('This answer must be an email address')})
+        # Answer validation (if properly defined)
+        # Length of the answer must be in a range
+        if answer and self.validation_required:
+            if not (self.validation_length_min <= len(answer) <= self.validation_length_max):
+                errors.update({answer_tag: self.validation_error_msg})
+        return errors
+
+    @api.multi
+    def validate_numerical_box(self, post, answer_tag):
+        self.ensure_one()
+        errors = {}
+        answer = post[answer_tag].strip()
+        # Empty answer to mandatory question
+        if self.constr_mandatory and not answer:
+            errors.update({answer_tag: self.constr_error_msg})
+        # Checks if user input is a number
+        if answer:
+            try:
+                floatanswer = float(answer)
+            except ValueError:
+                errors.update({answer_tag: _('This is not a number')})
+        # Answer validation (if properly defined)
+        if answer and self.validation_required:
+            # Answer is not in the right range
+            with tools.ignore(Exception):
+                floatanswer = float(answer)  # check that it is a float has been done hereunder
+                if not (self.validation_min_float_value <= floatanswer <= self.validation_max_float_value):
+                    errors.update({answer_tag: self.validation_error_msg})
+        return errors
+
+    @api.multi
+    def validate_date(self, post, answer_tag):
+        self.ensure_one()
+        errors = {}
+        answer = post[answer_tag].strip()
+        # Empty answer to mandatory question
+        if self.constr_mandatory and not answer:
+            errors.update({answer_tag: self.constr_error_msg})
+        # Checks if user input is a date
+        if answer:
+            try:
+                dateanswer = fields.Date.from_string(answer)
+            except ValueError:
+                errors.update({answer_tag: _('This is not a date')})
+                return errors
+        # Answer validation (if properly defined)
+        if answer and self.validation_required:
+            # Answer is not in the right range
+            try:
+                date_from_string = fields.Date.from_string
+                dateanswer = date_from_string(answer)
+                min_date = date_from_string(self.validation_min_date)
+                max_date = date_from_string(self.validation_max_date)
+
+                if min_date and max_date and not (min_date <= dateanswer <= max_date):
+                    # If Minimum and Maximum Date are entered
+                    errors.update({answer_tag: self.validation_error_msg})
+                elif min_date and not min_date <= dateanswer:
+                    # If only Minimum Date is entered and not Define Maximum Date
+                    errors.update({answer_tag: self.validation_error_msg})
+                elif max_date and not dateanswer <= max_date:
+                    # If only Maximum Date is entered and not Define Minimum Date
+                    errors.update({answer_tag: self.validation_error_msg})
+            except ValueError:  # check that it is a date has been done hereunder
+                pass
+        return errors
+
+    @api.multi
+    def validate_simple_choice(self, post, answer_tag):
+        self.ensure_one()
+        errors = {}
+        if self.comments_allowed:
+            comment_tag = "%s_%s" % (answer_tag, 'comment')
+        # Empty answer to mandatory self
+        if self.constr_mandatory and answer_tag not in post:
+            errors.update({answer_tag: self.constr_error_msg})
+        if self.constr_mandatory and answer_tag in post and not post[answer_tag].strip():
+            errors.update({answer_tag: self.constr_error_msg})
+        # Answer is a comment and is empty
+        if self.constr_mandatory and answer_tag in post and post[answer_tag] == "-1" and self.comment_count_as_answer and comment_tag in post and not post[comment_tag].strip():
+            errors.update({answer_tag: self.constr_error_msg})
+        return errors
+
+    @api.multi
+    def validate_multiple_choice(self, post, answer_tag):
+        self.ensure_one()
+        errors = {}
+        if self.constr_mandatory:
+            answer_candidates = dict_keys_startswith(post, answer_tag)
+            comment_flag = answer_candidates.pop(("%s_%s" % (answer_tag, -1)), None)
+            if self.comments_allowed:
+                comment_answer = answer_candidates.pop(("%s_%s" % (answer_tag, 'comment')), '').strip()
+            # Preventing answers with blank value
+            if all(not answer.strip() for answer in answer_candidates.values()) and answer_candidates:
+                errors.update({answer_tag: self.constr_error_msg})
+            # There is no answer neither comments (if comments count as answer)
+            if not answer_candidates and self.comment_count_as_answer and (not comment_flag or not comment_answer):
+                errors.update({answer_tag: self.constr_error_msg})
+            # There is no answer at all
+            if not answer_candidates and not self.comment_count_as_answer:
+                errors.update({answer_tag: self.constr_error_msg})
+        return errors
+
+    @api.multi
+    def validate_matrix(self, post, answer_tag):
+        self.ensure_one()
+        errors = {}
+        if self.constr_mandatory:
+            lines_number = len(self.labels_ids_2)
+            answer_candidates = dict_keys_startswith(post, answer_tag)
+            answer_candidates.pop(("%s_%s" % (answer_tag, 'comment')), '').strip()
+            # Number of lines that have been answered
+            if self.matrix_subtype == 'simple':
+                answer_number = len(answer_candidates)
+            elif self.matrix_subtype == 'multiple':
+                answer_number = len({sk.rsplit('_', 1)[0] for sk in answer_candidates})
+            else:
+                raise RuntimeError("Invalid matrix subtype")
+            # Validate that each line has been answered
+            if answer_number != lines_number:
+                errors.update({answer_tag: self.constr_error_msg})
+        return errors
+
+class SurveyLabel(models.Model):
+    """ A suggested answer for a question """
+
+    _name = 'survey.label'
+    _rec_name = 'value'
+    _order = 'sequence,id'
+    _description = 'Survey Label'
+
+    question_id = fields.Many2one('survey.question', string='Question', ondelete='cascade')
+    question_id_2 = fields.Many2one('survey.question', string='Question 2', ondelete='cascade')
+    sequence = fields.Integer('Label Sequence order', default=10)
+    value = fields.Char('Suggested value', translate=True, required=True)
+    quizz_mark = fields.Float('Score for this choice', help="A positive score indicates a correct choice; a negative or null score indicates a wrong answer")
+
+    @api.one
+    @api.constrains('question_id', 'question_id_2')
+    def _check_question_not_empty(self):
+        """Ensure that field question_id XOR field question_id_2 is not null"""
+        if not bool(self.question_id) != bool(self.question_id_2):
+            raise ValidationError(_("A label must be attached to only one question."))

--- a/None
+++ b/addons/survey/models/survey_stage.py
@@ -0,0 +1,21 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from odoo import fields, models
+
+
+class SurveyStage(models.Model):
+    """Stages for Kanban view of surveys"""
+
+    _name = 'survey.stage'
+    _description = 'Survey Stage'
+    _order = 'sequence,id'
+
+    name = fields.Char(required=True, translate=True)
+    sequence = fields.Integer(default=1)
+    closed = fields.Boolean(help="If closed, people won't be able to answer to surveys in this column.")
+    fold = fields.Boolean(string="Folded in kanban view")
+
+    _sql_constraints = [
+        ('positive_sequence', 'CHECK(sequence >= 0)', 'Sequence number MUST be a natural')
+    ]

--- a/addons/survey/models/survey_survey.py
+++ b/addons/survey/models/survey_survey.py
@@ -1,44 +1,13 @@
 # -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
-import datetime
-import logging
-import re
-import uuid
 from collections import Counter, OrderedDict
 from itertools import product
 from werkzeug import urls
 
-from odoo import api, fields, models, tools, SUPERUSER_ID, _
+from odoo import api, fields, models, SUPERUSER_ID, _
 from odoo.addons.http_routing.models.ir_http import slug
-from odoo.exceptions import UserError, ValidationError
-email_validator = re.compile(r"[^@]+@[^@]+\.[^@]+")
-_logger = logging.getLogger(__name__)
-
-
-def dict_keys_startswith(dictionary, string):
-    """Returns a dictionary containing the elements of <dict> whose keys start with <string>.
-        .. note::
-            This function uses dictionary comprehensions (Python >= 2.7)
-    """
-    return {k: v for k, v in dictionary.items() if k.startswith(string)}
-
-
-class SurveyStage(models.Model):
-    """Stages for Kanban view of surveys"""
-
-    _name = 'survey.stage'
-    _description = 'Survey Stage'
-    _order = 'sequence,id'
-
-    name = fields.Char(required=True, translate=True)
-    sequence = fields.Integer(default=1)
-    closed = fields.Boolean(help="If closed, people won't be able to answer to surveys in this column.")
-    fold = fields.Boolean(string="Folded in kanban view")
-
-    _sql_constraints = [
-        ('positive_sequence', 'CHECK(sequence >= 0)', 'Sequence number MUST be a natural')
-    ]
+from odoo.exceptions import UserError
 
 
 class Survey(models.Model):
@@ -383,671 +352,3 @@ class Survey(models.Model):
         action['context'] = ctx
         return action
 
-
-class SurveyPage(models.Model):
-    """ A page for a survey.
-
-        Pages are essentially containers, allowing to group questions by ordered
-        screens.
-
-        .. note::
-            A page should be deleted if the survey it belongs to is deleted.
-    """
-    _name = 'survey.page'
-    _description = 'Survey Page'
-    _rec_name = 'title'
-    _order = 'sequence,id'
-
-    # Model Fields #
-
-    title = fields.Char('Page Title', required=True, translate=True)
-    survey_id = fields.Many2one('survey.survey', string='Survey', ondelete='cascade', required=True)
-    question_ids = fields.One2many('survey.question', 'page_id', string='Questions', copy=True)
-    sequence = fields.Integer('Page number', default=10)
-    description = fields.Html('Description', translate=True, oldname="note", help="An introductory text to your page")
-
-
-class SurveyQuestion(models.Model):
-    """ Questions that will be asked in a survey.
-
-        Each question can have one of more suggested answers (eg. in case of
-        dropdown choices, multi-answer checkboxes, radio buttons...).
-    """
-
-    _name = 'survey.question'
-    _description = 'Survey Question'
-    _rec_name = 'question'
-    _order = 'sequence,id'
-
-    # Model fields #
-
-    # Question metadata
-    page_id = fields.Many2one('survey.page', string='Survey page',
-            ondelete='cascade', required=True, default=lambda self: self.env.context.get('page_id'))
-    survey_id = fields.Many2one('survey.survey', related='page_id.survey_id', string='Survey', readonly=False)
-    sequence = fields.Integer('Sequence', default=10)
-
-    # Question
-    question = fields.Char('Question Name', required=True, translate=True)
-    description = fields.Html('Description', help="Use this field to add \
-        additional explanations about your question", translate=True,
-        oldname='descriptive_text')
-
-    # Answer
-    question_type = fields.Selection([
-            ('free_text', 'Multiple Lines Text Box'),
-            ('textbox', 'Single Line Text Box'),
-            ('numerical_box', 'Numerical Value'),
-            ('date', 'Date'),
-            ('simple_choice', 'Multiple choice: only one answer'),
-            ('multiple_choice', 'Multiple choice: multiple answers allowed'),
-            ('matrix', 'Matrix')], string='Type of Question', default='free_text', required=True, oldname='type')
-    matrix_subtype = fields.Selection([('simple', 'One choice per row'),
-        ('multiple', 'Multiple choices per row')], string='Matrix Type', default='simple')
-    labels_ids = fields.One2many('survey.label', 'question_id', string='Types of answers', oldname='answer_choice_ids', copy=True)
-    labels_ids_2 = fields.One2many('survey.label', 'question_id_2', string='Rows of the Matrix', copy=True)
-    # labels are used for proposed choices
-    # if question.type == simple choice | multiple choice
-    #                    -> only labels_ids is used
-    # if question.type == matrix
-    #                    -> labels_ids are the columns of the matrix
-    #                    -> labels_ids_2 are the rows of the matrix
-
-    # Display options
-    column_nb = fields.Selection([('12', '1'),
-                                   ('6', '2'),
-                                   ('4', '3'),
-                                   ('3', '4'),
-                                   ('2', '6')],
-        'Number of columns', default='12')
-    # These options refer to col-xx-[12|6|4|3|2] classes in Bootstrap
-    display_mode = fields.Selection([('columns', 'Radio Buttons'),
-                                      ('dropdown', 'Selection Box')],
-                                    default='columns')
-
-    # Comments
-    comments_allowed = fields.Boolean('Show Comments Field',
-        oldname="allow_comment")
-    comments_message = fields.Char('Comment Message', translate=True, default=lambda self: _("If other, please specify:"))
-    comment_count_as_answer = fields.Boolean('Comment Field is an Answer Choice',
-        oldname='make_comment_field')
-
-    # Validation
-    validation_required = fields.Boolean('Validate entry', oldname='is_validation_require')
-    validation_email = fields.Boolean('Input must be an email')
-    validation_length_min = fields.Integer('Minimum Text Length')
-    validation_length_max = fields.Integer('Maximum Text Length')
-    validation_min_float_value = fields.Float('Minimum value')
-    validation_max_float_value = fields.Float('Maximum value')
-    validation_min_date = fields.Date('Minimum Date')
-    validation_max_date = fields.Date('Maximum Date')
-    validation_error_msg = fields.Char('Validation Error message', oldname='validation_valid_err_msg',
-                                        translate=True, default=lambda self: _("The answer you entered has an invalid format."))
-
-    # Constraints on number of answers (matrices)
-    constr_mandatory = fields.Boolean('Mandatory Answer', oldname="is_require_answer")
-    constr_error_msg = fields.Char('Error message', oldname='req_error_msg', translate=True, default=lambda self: _("This question requires an answer."))
-    user_input_line_ids = fields.One2many('survey.user_input_line', 'question_id', string='Answers', domain=[('skipped', '=', False)])
-
-    _sql_constraints = [
-        ('positive_len_min', 'CHECK (validation_length_min >= 0)', 'A length must be positive!'),
-        ('positive_len_max', 'CHECK (validation_length_max >= 0)', 'A length must be positive!'),
-        ('validation_length', 'CHECK (validation_length_min <= validation_length_max)', 'Max length cannot be smaller than min length!'),
-        ('validation_float', 'CHECK (validation_min_float_value <= validation_max_float_value)', 'Max value cannot be smaller than min value!'),
-        ('validation_date', 'CHECK (validation_min_date <= validation_max_date)', 'Max date cannot be smaller than min date!')
-    ]
-
-    @api.onchange('validation_email')
-    def onchange_validation_email(self):
-        if self.validation_email:
-            self.validation_required = False
-
-    # Validation methods
-
-    @api.multi
-    def validate_question(self, post, answer_tag):
-        """ Validate question, depending on question type and parameters """
-        self.ensure_one()
-        try:
-            checker = getattr(self, 'validate_' + self.question_type)
-        except AttributeError:
-            _logger.warning(self.question_type + ": This type of question has no validation method")
-            return {}
-        else:
-            return checker(post, answer_tag)
-
-    @api.multi
-    def validate_free_text(self, post, answer_tag):
-        self.ensure_one()
-        errors = {}
-        answer = post[answer_tag].strip()
-        # Empty answer to mandatory question
-        if self.constr_mandatory and not answer:
-            errors.update({answer_tag: self.constr_error_msg})
-        return errors
-
-    @api.multi
-    def validate_textbox(self, post, answer_tag):
-        self.ensure_one()
-        errors = {}
-        answer = post[answer_tag].strip()
-        # Empty answer to mandatory question
-        if self.constr_mandatory and not answer:
-            errors.update({answer_tag: self.constr_error_msg})
-        # Email format validation
-        # Note: this validation is very basic:
-        #     all the strings of the form
-        #     <something>@<anything>.<extension>
-        #     will be accepted
-        if answer and self.validation_email:
-            if not email_validator.match(answer):
-                errors.update({answer_tag: _('This answer must be an email address')})
-        # Answer validation (if properly defined)
-        # Length of the answer must be in a range
-        if answer and self.validation_required:
-            if not (self.validation_length_min <= len(answer) <= self.validation_length_max):
-                errors.update({answer_tag: self.validation_error_msg})
-        return errors
-
-    @api.multi
-    def validate_numerical_box(self, post, answer_tag):
-        self.ensure_one()
-        errors = {}
-        answer = post[answer_tag].strip()
-        # Empty answer to mandatory question
-        if self.constr_mandatory and not answer:
-            errors.update({answer_tag: self.constr_error_msg})
-        # Checks if user input is a number
-        if answer:
-            try:
-                floatanswer = float(answer)
-            except ValueError:
-                errors.update({answer_tag: _('This is not a number')})
-        # Answer validation (if properly defined)
-        if answer and self.validation_required:
-            # Answer is not in the right range
-            with tools.ignore(Exception):
-                floatanswer = float(answer)  # check that it is a float has been done hereunder
-                if not (self.validation_min_float_value <= floatanswer <= self.validation_max_float_value):
-                    errors.update({answer_tag: self.validation_error_msg})
-        return errors
-
-    @api.multi
-    def validate_date(self, post, answer_tag):
-        self.ensure_one()
-        errors = {}
-        answer = post[answer_tag].strip()
-        # Empty answer to mandatory question
-        if self.constr_mandatory and not answer:
-            errors.update({answer_tag: self.constr_error_msg})
-        # Checks if user input is a date
-        if answer:
-            try:
-                dateanswer = fields.Date.from_string(answer)
-            except ValueError:
-                errors.update({answer_tag: _('This is not a date')})
-                return errors
-        # Answer validation (if properly defined)
-        if answer and self.validation_required:
-            # Answer is not in the right range
-            try:
-                date_from_string = fields.Date.from_string
-                dateanswer = date_from_string(answer)
-                min_date = date_from_string(self.validation_min_date)
-                max_date = date_from_string(self.validation_max_date)
-
-                if min_date and max_date and not (min_date <= dateanswer <= max_date):
-                    # If Minimum and Maximum Date are entered
-                    errors.update({answer_tag: self.validation_error_msg})
-                elif min_date and not min_date <= dateanswer:
-                    # If only Minimum Date is entered and not Define Maximum Date
-                    errors.update({answer_tag: self.validation_error_msg})
-                elif max_date and not dateanswer <= max_date:
-                    # If only Maximum Date is entered and not Define Minimum Date
-                    errors.update({answer_tag: self.validation_error_msg})
-            except ValueError:  # check that it is a date has been done hereunder
-                pass
-        return errors
-
-    @api.multi
-    def validate_simple_choice(self, post, answer_tag):
-        self.ensure_one()
-        errors = {}
-        if self.comments_allowed:
-            comment_tag = "%s_%s" % (answer_tag, 'comment')
-        # Empty answer to mandatory self
-        if self.constr_mandatory and answer_tag not in post:
-            errors.update({answer_tag: self.constr_error_msg})
-        if self.constr_mandatory and answer_tag in post and not post[answer_tag].strip():
-            errors.update({answer_tag: self.constr_error_msg})
-        # Answer is a comment and is empty
-        if self.constr_mandatory and answer_tag in post and post[answer_tag] == "-1" and self.comment_count_as_answer and comment_tag in post and not post[comment_tag].strip():
-            errors.update({answer_tag: self.constr_error_msg})
-        return errors
-
-    @api.multi
-    def validate_multiple_choice(self, post, answer_tag):
-        self.ensure_one()
-        errors = {}
-        if self.constr_mandatory:
-            answer_candidates = dict_keys_startswith(post, answer_tag)
-            comment_flag = answer_candidates.pop(("%s_%s" % (answer_tag, -1)), None)
-            if self.comments_allowed:
-                comment_answer = answer_candidates.pop(("%s_%s" % (answer_tag, 'comment')), '').strip()
-            # Preventing answers with blank value
-            if all(not answer.strip() for answer in answer_candidates.values()) and answer_candidates:
-                errors.update({answer_tag: self.constr_error_msg})
-            # There is no answer neither comments (if comments count as answer)
-            if not answer_candidates and self.comment_count_as_answer and (not comment_flag or not comment_answer):
-                errors.update({answer_tag: self.constr_error_msg})
-            # There is no answer at all
-            if not answer_candidates and not self.comment_count_as_answer:
-                errors.update({answer_tag: self.constr_error_msg})
-        return errors
-
-    @api.multi
-    def validate_matrix(self, post, answer_tag):
-        self.ensure_one()
-        errors = {}
-        if self.constr_mandatory:
-            lines_number = len(self.labels_ids_2)
-            answer_candidates = dict_keys_startswith(post, answer_tag)
-            answer_candidates.pop(("%s_%s" % (answer_tag, 'comment')), '').strip()
-            # Number of lines that have been answered
-            if self.matrix_subtype == 'simple':
-                answer_number = len(answer_candidates)
-            elif self.matrix_subtype == 'multiple':
-                answer_number = len({sk.rsplit('_', 1)[0] for sk in answer_candidates})
-            else:
-                raise RuntimeError("Invalid matrix subtype")
-            # Validate that each line has been answered
-            if answer_number != lines_number:
-                errors.update({answer_tag: self.constr_error_msg})
-        return errors
-
-
-class SurveyLabel(models.Model):
-    """ A suggested answer for a question """
-
-    _name = 'survey.label'
-    _rec_name = 'value'
-    _order = 'sequence,id'
-    _description = 'Survey Label'
-
-    question_id = fields.Many2one('survey.question', string='Question', ondelete='cascade')
-    question_id_2 = fields.Many2one('survey.question', string='Question 2', ondelete='cascade')
-    sequence = fields.Integer('Label Sequence order', default=10)
-    value = fields.Char('Suggested value', translate=True, required=True)
-    quizz_mark = fields.Float('Score for this choice', help="A positive score indicates a correct choice; a negative or null score indicates a wrong answer")
-
-    @api.one
-    @api.constrains('question_id', 'question_id_2')
-    def _check_question_not_empty(self):
-        """Ensure that field question_id XOR field question_id_2 is not null"""
-        if not bool(self.question_id) != bool(self.question_id_2):
-            raise ValidationError(_("A label must be attached to only one question."))
-
-
-class SurveyUserInput(models.Model):
-    """ Metadata for a set of one user's answers to a particular survey """
-
-    _name = "survey.user_input"
-    _rec_name = 'date_create'
-    _description = 'Survey User Input'
-
-    survey_id = fields.Many2one('survey.survey', string='Survey', required=True, readonly=True, ondelete='restrict')
-    date_create = fields.Datetime('Creation Date', default=fields.Datetime.now, required=True, readonly=True, copy=False)
-    deadline = fields.Datetime('Deadline', help="Date by which the person can open the survey and submit answers", oldname="date_deadline")
-    input_type = fields.Selection([('manually', 'Manually'), ('link', 'Link')], string='Answer Type', default='manually', required=True, readonly=True, oldname="type")
-    state = fields.Selection([
-        ('new', 'Not started yet'),
-        ('skip', 'Partially completed'),
-        ('done', 'Completed')], string='Status', default='new', readonly=True)
-    test_entry = fields.Boolean(readonly=True)
-    token = fields.Char('Identification token', default=lambda self: str(uuid.uuid4()), readonly=True, required=True, copy=False)
-
-    # Optional Identification data
-    partner_id = fields.Many2one('res.partner', string='Partner', readonly=True)
-    email = fields.Char('E-mail', readonly=True)
-
-    # Displaying data
-    last_displayed_page_id = fields.Many2one('survey.page', string='Last displayed page')
-    # The answers !
-    user_input_line_ids = fields.One2many('survey.user_input_line', 'user_input_id', string='Answers', copy=True)
-
-    # URLs used to display the answers
-    result_url = fields.Char("Public link to the survey results", related='survey_id.result_url', readonly=False)
-    print_url = fields.Char("Public link to the empty survey", related='survey_id.print_url', readonly=False)
-
-    quizz_score = fields.Float("Score for the quiz", compute="_compute_quizz_score", default=0.0)
-
-    @api.depends('user_input_line_ids.quizz_mark')
-    def _compute_quizz_score(self):
-        for user_input in self:
-            user_input.quizz_score = sum(user_input.user_input_line_ids.mapped('quizz_mark'))
-
-    _sql_constraints = [
-        ('unique_token', 'UNIQUE (token)', 'A token must be unique!'),
-    ]
-
-    @api.model
-    def do_clean_emptys(self):
-        """ Remove empty user inputs that have been created manually
-            (used as a cronjob declared in data/survey_cron.xml)
-        """
-        an_hour_ago = fields.Datetime.to_string(datetime.datetime.now() - datetime.timedelta(hours=1))
-        self.search([('input_type', '=', 'manually'), ('state', '=', 'new'),
-                    ('date_create', '<', an_hour_ago)]).unlink()
-
-    @api.multi
-    def action_survey_resend(self):
-        """ Send again the invitation """
-        self.ensure_one()
-        local_context = {
-            'survey_resent_token': True,
-            'default_partner_ids': self.partner_id and [self.partner_id.id] or [],
-            'default_multi_email': self.email or "",
-            'default_public': 'email_private',
-        }
-        return self.survey_id.with_context(local_context).action_send_survey()
-
-    @api.multi
-    def action_view_answers(self):
-        """ Open the website page with the survey form """
-        self.ensure_one()
-        return {
-            'type': 'ir.actions.act_url',
-            'name': "View Answers",
-            'target': 'self',
-            'url': '%s/%s' % (self.print_url, self.token)
-        }
-
-    @api.multi
-    def action_survey_results(self):
-        """ Open the website page with the survey results """
-        self.ensure_one()
-        return {
-            'type': 'ir.actions.act_url',
-            'name': "Survey Results",
-            'target': 'self',
-            'url': self.result_url
-        }
-
-
-class SurveyUserInputLine(models.Model):
-    _name = 'survey.user_input_line'
-    _description = 'Survey User Input Line'
-    _rec_name = 'date_create'
-
-    user_input_id = fields.Many2one('survey.user_input', string='User Input', ondelete='cascade', required=True)
-    question_id = fields.Many2one('survey.question', string='Question', ondelete='restrict', required=True)
-    page_id = fields.Many2one(related='question_id.page_id', string="Page", readonly=False)
-    survey_id = fields.Many2one(related='user_input_id.survey_id', string='Survey', store=True, readonly=False)
-    date_create = fields.Datetime('Create Date', default=fields.Datetime.now, required=True)
-    skipped = fields.Boolean('Skipped')
-    answer_type = fields.Selection([
-        ('text', 'Text'),
-        ('number', 'Number'),
-        ('date', 'Date'),
-        ('free_text', 'Free Text'),
-        ('suggestion', 'Suggestion')], string='Answer Type')
-    value_text = fields.Char('Text answer')
-    value_number = fields.Float('Numerical answer')
-    value_date = fields.Date('Date answer')
-    value_free_text = fields.Text('Free Text answer')
-    value_suggested = fields.Many2one('survey.label', string="Suggested answer")
-    value_suggested_row = fields.Many2one('survey.label', string="Row answer")
-    quizz_mark = fields.Float('Score given for this choice')
-
-    @api.constrains('skipped', 'answer_type')
-    def _answered_or_skipped(self):
-        for uil in self:
-            if not uil.skipped != bool(uil.answer_type):
-                raise ValidationError(_('This question cannot be unanswered or skipped.'))
-
-    @api.constrains('answer_type')
-    def _check_answer_type(self):
-        for uil in self:
-            fields_type = {
-                'text': bool(uil.value_text),
-                'number': (bool(uil.value_number) or uil.value_number == 0),
-                'date': bool(uil.value_date),
-                'free_text': bool(uil.value_free_text),
-                'suggestion': bool(uil.value_suggested)
-            }
-            if not fields_type.get(uil.answer_type, True):
-                raise ValidationError(_('The answer must be in the right type'))
-
-    def _get_mark(self, value_suggested):
-        label = self.env['survey.label'].browse(int(value_suggested))
-        mark = label.quizz_mark if label.exists() else 0.0
-        return mark
-
-    @api.model_create_multi
-    def create(self, vals_list):
-        for vals in vals_list:
-            value_suggested = vals.get('value_suggested')
-            if value_suggested:
-                vals.update({'quizz_mark': self._get_mark(value_suggested)})
-        return super(SurveyUserInputLine, self).create(vals_list)
-
-    @api.multi
-    def write(self, vals):
-        value_suggested = vals.get('value_suggested')
-        if value_suggested:
-            vals.update({'quizz_mark': self._get_mark(value_suggested)})
-        return super(SurveyUserInputLine, self).write(vals)
-
-    @api.model
-    def save_lines(self, user_input_id, question, post, answer_tag):
-        """ Save answers to questions, depending on question type
-
-            If an answer already exists for question and user_input_id, it will be
-            overwritten (in order to maintain data consistency).
-        """
-        try:
-            saver = getattr(self, 'save_line_' + question.question_type)
-        except AttributeError:
-            _logger.error(question.question_type + ": This type of question has no saving function")
-            return False
-        else:
-            saver(user_input_id, question, post, answer_tag)
-
-    @api.model
-    def save_line_free_text(self, user_input_id, question, post, answer_tag):
-        vals = {
-            'user_input_id': user_input_id,
-            'question_id': question.id,
-            'survey_id': question.survey_id.id,
-            'skipped': False,
-        }
-        if answer_tag in post and post[answer_tag].strip():
-            vals.update({'answer_type': 'free_text', 'value_free_text': post[answer_tag]})
-        else:
-            vals.update({'answer_type': None, 'skipped': True})
-        old_uil = self.search([
-            ('user_input_id', '=', user_input_id),
-            ('survey_id', '=', question.survey_id.id),
-            ('question_id', '=', question.id)
-        ])
-        if old_uil:
-            old_uil.write(vals)
-        else:
-            old_uil.create(vals)
-        return True
-
-    @api.model
-    def save_line_textbox(self, user_input_id, question, post, answer_tag):
-        vals = {
-            'user_input_id': user_input_id,
-            'question_id': question.id,
-            'survey_id': question.survey_id.id,
-            'skipped': False
-        }
-        if answer_tag in post and post[answer_tag].strip():
-            vals.update({'answer_type': 'text', 'value_text': post[answer_tag]})
-        else:
-            vals.update({'answer_type': None, 'skipped': True})
-        old_uil = self.search([
-            ('user_input_id', '=', user_input_id),
-            ('survey_id', '=', question.survey_id.id),
-            ('question_id', '=', question.id)
-        ])
-        if old_uil:
-            old_uil.write(vals)
-        else:
-            old_uil.create(vals)
-        return True
-
-    @api.model
-    def save_line_numerical_box(self, user_input_id, question, post, answer_tag):
-        vals = {
-            'user_input_id': user_input_id,
-            'question_id': question.id,
-            'survey_id': question.survey_id.id,
-            'skipped': False
-        }
-        if answer_tag in post and post[answer_tag].strip():
-            vals.update({'answer_type': 'number', 'value_number': float(post[answer_tag])})
-        else:
-            vals.update({'answer_type': None, 'skipped': True})
-        old_uil = self.search([
-            ('user_input_id', '=', user_input_id),
-            ('survey_id', '=', question.survey_id.id),
-            ('question_id', '=', question.id)
-        ])
-        if old_uil:
-            old_uil.write(vals)
-        else:
-            old_uil.create(vals)
-        return True
-
-    @api.model
-    def save_line_date(self, user_input_id, question, post, answer_tag):
-        vals = {
-            'user_input_id': user_input_id,
-            'question_id': question.id,
-            'survey_id': question.survey_id.id,
-            'skipped': False
-        }
-        if answer_tag in post and post[answer_tag].strip():
-            vals.update({'answer_type': 'date', 'value_date': post[answer_tag]})
-        else:
-            vals.update({'answer_type': None, 'skipped': True})
-        old_uil = self.search([
-            ('user_input_id', '=', user_input_id),
-            ('survey_id', '=', question.survey_id.id),
-            ('question_id', '=', question.id)
-        ])
-        if old_uil:
-            old_uil.write(vals)
-        else:
-            old_uil.create(vals)
-        return True
-
-    @api.model
-    def save_line_simple_choice(self, user_input_id, question, post, answer_tag):
-        vals = {
-            'user_input_id': user_input_id,
-            'question_id': question.id,
-            'survey_id': question.survey_id.id,
-            'skipped': False
-        }
-        old_uil = self.search([
-            ('user_input_id', '=', user_input_id),
-            ('survey_id', '=', question.survey_id.id),
-            ('question_id', '=', question.id)
-        ])
-        old_uil.sudo().unlink()
-
-        if answer_tag in post and post[answer_tag].strip():
-            vals.update({'answer_type': 'suggestion', 'value_suggested': post[answer_tag]})
-        else:
-            vals.update({'answer_type': None, 'skipped': True})
-
-        # '-1' indicates 'comment count as an answer' so do not need to record it
-        if post.get(answer_tag) and post.get(answer_tag) != '-1':
-            self.create(vals)
-
-        comment_answer = post.pop(("%s_%s" % (answer_tag, 'comment')), '').strip()
-        if comment_answer:
-            vals.update({'answer_type': 'text', 'value_text': comment_answer, 'skipped': False, 'value_suggested': False})
-            self.create(vals)
-
-        return True
-
-    @api.model
-    def save_line_multiple_choice(self, user_input_id, question, post, answer_tag):
-        vals = {
-            'user_input_id': user_input_id,
-            'question_id': question.id,
-            'survey_id': question.survey_id.id,
-            'skipped': False
-        }
-        old_uil = self.search([
-            ('user_input_id', '=', user_input_id),
-            ('survey_id', '=', question.survey_id.id),
-            ('question_id', '=', question.id)
-        ])
-        old_uil.sudo().unlink()
-
-        ca_dict = dict_keys_startswith(post, answer_tag + '_')
-        comment_answer = ca_dict.pop(("%s_%s" % (answer_tag, 'comment')), '').strip()
-        if len(ca_dict) > 0:
-            for key in ca_dict:
-                # '-1' indicates 'comment count as an answer' so do not need to record it
-                if key != ('%s_%s' % (answer_tag, '-1')):
-                    vals.update({'answer_type': 'suggestion', 'value_suggested': ca_dict[key]})
-                    self.create(vals)
-        if comment_answer:
-            vals.update({'answer_type': 'text', 'value_text': comment_answer, 'value_suggested': False})
-            self.create(vals)
-        if not ca_dict and not comment_answer:
-            vals.update({'answer_type': None, 'skipped': True})
-            self.create(vals)
-        return True
-
-    @api.model
-    def save_line_matrix(self, user_input_id, question, post, answer_tag):
-        vals = {
-            'user_input_id': user_input_id,
-            'question_id': question.id,
-            'survey_id': question.survey_id.id,
-            'skipped': False
-        }
-        old_uil = self.search([
-            ('user_input_id', '=', user_input_id),
-            ('survey_id', '=', question.survey_id.id),
-            ('question_id', '=', question.id)
-        ])
-        old_uil.sudo().unlink()
-
-        no_answers = True
-        ca_dict = dict_keys_startswith(post, answer_tag + '_')
-
-        comment_answer = ca_dict.pop(("%s_%s" % (answer_tag, 'comment')), '').strip()
-        if comment_answer:
-            vals.update({'answer_type': 'text', 'value_text': comment_answer})
-            self.create(vals)
-            no_answers = False
-
-        if question.matrix_subtype == 'simple':
-            for row in question.labels_ids_2:
-                a_tag = "%s_%s" % (answer_tag, row.id)
-                if a_tag in ca_dict:
-                    no_answers = False
-                    vals.update({'answer_type': 'suggestion', 'value_suggested': ca_dict[a_tag], 'value_suggested_row': row.id})
-                    self.create(vals)
-
-        elif question.matrix_subtype == 'multiple':
-            for col in question.labels_ids:
-                for row in question.labels_ids_2:
-                    a_tag = "%s_%s_%s" % (answer_tag, row.id, col.id)
-                    if a_tag in ca_dict:
-                        no_answers = False
-                        vals.update({'answer_type': 'suggestion', 'value_suggested': col.id, 'value_suggested_row': row.id})
-                        self.create(vals)
-        if no_answers:
-            vals.update({'answer_type': None, 'skipped': True})
-            self.create(vals)
-        return True

--- a/None
+++ b/addons/survey/models/survey_user.py
@@ -0,0 +1,386 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+import datetime
+import logging
+import re
+import uuid
+
+from odoo import api, fields, models, _
+from odoo.exceptions import ValidationError
+
+email_validator = re.compile(r"[^@]+@[^@]+\.[^@]+")
+_logger = logging.getLogger(__name__)
+
+
+def dict_keys_startswith(dictionary, string):
+    """Returns a dictionary containing the elements of <dict> whose keys start with <string>.
+        .. note::
+            This function uses dictionary comprehensions (Python >= 2.7)
+    """
+    return {k: v for k, v in dictionary.items() if k.startswith(string)}
+
+
+class SurveyUserInput(models.Model):
+    """ Metadata for a set of one user's answers to a particular survey """
+
+    _name = "survey.user_input"
+    _rec_name = 'date_create'
+    _description = 'Survey User Input'
+
+    survey_id = fields.Many2one('survey.survey', string='Survey', required=True, readonly=True, ondelete='restrict')
+    date_create = fields.Datetime('Creation Date', default=fields.Datetime.now, required=True, readonly=True, copy=False)
+    deadline = fields.Datetime('Deadline', help="Date by which the person can open the survey and submit answers", oldname="date_deadline")
+    input_type = fields.Selection([('manually', 'Manually'), ('link', 'Link')], string='Answer Type', default='manually', required=True, readonly=True, oldname="type")
+    state = fields.Selection([
+        ('new', 'Not started yet'),
+        ('skip', 'Partially completed'),
+        ('done', 'Completed')], string='Status', default='new', readonly=True)
+    test_entry = fields.Boolean(readonly=True)
+    token = fields.Char('Identification token', default=lambda self: str(uuid.uuid4()), readonly=True, required=True, copy=False)
+
+    # Optional Identification data
+    partner_id = fields.Many2one('res.partner', string='Partner', readonly=True)
+    email = fields.Char('E-mail', readonly=True)
+
+    # Displaying data
+    last_displayed_page_id = fields.Many2one('survey.page', string='Last displayed page')
+    # The answers !
+    user_input_line_ids = fields.One2many('survey.user_input_line', 'user_input_id', string='Answers', copy=True)
+
+    # URLs used to display the answers
+    result_url = fields.Char("Public link to the survey results", related='survey_id.result_url', readonly=False)
+    print_url = fields.Char("Public link to the empty survey", related='survey_id.print_url', readonly=False)
+
+    quizz_score = fields.Float("Score for the quiz", compute="_compute_quizz_score", default=0.0)
+
+    @api.depends('user_input_line_ids.quizz_mark')
+    def _compute_quizz_score(self):
+        for user_input in self:
+            user_input.quizz_score = sum(user_input.user_input_line_ids.mapped('quizz_mark'))
+
+    _sql_constraints = [
+        ('unique_token', 'UNIQUE (token)', 'A token must be unique!'),
+    ]
+
+    @api.model
+    def do_clean_emptys(self):
+        """ Remove empty user inputs that have been created manually
+            (used as a cronjob declared in data/survey_cron.xml)
+        """
+        an_hour_ago = fields.Datetime.to_string(datetime.datetime.now() - datetime.timedelta(hours=1))
+        self.search([('input_type', '=', 'manually'), ('state', '=', 'new'),
+                    ('date_create', '<', an_hour_ago)]).unlink()
+
+    @api.multi
+    def action_survey_resend(self):
+        """ Send again the invitation """
+        self.ensure_one()
+        local_context = {
+            'survey_resent_token': True,
+            'default_partner_ids': self.partner_id and [self.partner_id.id] or [],
+            'default_multi_email': self.email or "",
+            'default_public': 'email_private',
+        }
+        return self.survey_id.with_context(local_context).action_send_survey()
+
+    @api.multi
+    def action_view_answers(self):
+        """ Open the website page with the survey form """
+        self.ensure_one()
+        return {
+            'type': 'ir.actions.act_url',
+            'name': "View Answers",
+            'target': 'self',
+            'url': '%s/%s' % (self.print_url, self.token)
+        }
+
+    @api.multi
+    def action_survey_results(self):
+        """ Open the website page with the survey results """
+        self.ensure_one()
+        return {
+            'type': 'ir.actions.act_url',
+            'name': "Survey Results",
+            'target': 'self',
+            'url': self.result_url
+        }
+
+
+class SurveyUserInputLine(models.Model):
+    _name = 'survey.user_input_line'
+    _description = 'Survey User Input Line'
+    _rec_name = 'date_create'
+
+    user_input_id = fields.Many2one('survey.user_input', string='User Input', ondelete='cascade', required=True)
+    question_id = fields.Many2one('survey.question', string='Question', ondelete='restrict', required=True)
+    page_id = fields.Many2one(related='question_id.page_id', string="Page", readonly=False)
+    survey_id = fields.Many2one(related='user_input_id.survey_id', string='Survey', store=True, readonly=False)
+    date_create = fields.Datetime('Create Date', default=fields.Datetime.now, required=True)
+    skipped = fields.Boolean('Skipped')
+    answer_type = fields.Selection([
+        ('text', 'Text'),
+        ('number', 'Number'),
+        ('date', 'Date'),
+        ('free_text', 'Free Text'),
+        ('suggestion', 'Suggestion')], string='Answer Type')
+    value_text = fields.Char('Text answer')
+    value_number = fields.Float('Numerical answer')
+    value_date = fields.Date('Date answer')
+    value_free_text = fields.Text('Free Text answer')
+    value_suggested = fields.Many2one('survey.label', string="Suggested answer")
+    value_suggested_row = fields.Many2one('survey.label', string="Row answer")
+    quizz_mark = fields.Float('Score given for this choice')
+
+    @api.constrains('skipped', 'answer_type')
+    def _answered_or_skipped(self):
+        for uil in self:
+            if not uil.skipped != bool(uil.answer_type):
+                raise ValidationError(_('This question cannot be unanswered or skipped.'))
+
+    @api.constrains('answer_type')
+    def _check_answer_type(self):
+        for uil in self:
+            fields_type = {
+                'text': bool(uil.value_text),
+                'number': (bool(uil.value_number) or uil.value_number == 0),
+                'date': bool(uil.value_date),
+                'free_text': bool(uil.value_free_text),
+                'suggestion': bool(uil.value_suggested)
+            }
+            if not fields_type.get(uil.answer_type, True):
+                raise ValidationError(_('The answer must be in the right type'))
+
+    def _get_mark(self, value_suggested):
+        label = self.env['survey.label'].browse(int(value_suggested))
+        mark = label.quizz_mark if label.exists() else 0.0
+        return mark
+
+    @api.model_create_multi
+    def create(self, vals_list):
+        for vals in vals_list:
+            value_suggested = vals.get('value_suggested')
+            if value_suggested:
+                vals.update({'quizz_mark': self._get_mark(value_suggested)})
+        return super(SurveyUserInputLine, self).create(vals_list)
+
+    @api.multi
+    def write(self, vals):
+        value_suggested = vals.get('value_suggested')
+        if value_suggested:
+            vals.update({'quizz_mark': self._get_mark(value_suggested)})
+        return super(SurveyUserInputLine, self).write(vals)
+
+    @api.model
+    def save_lines(self, user_input_id, question, post, answer_tag):
+        """ Save answers to questions, depending on question type
+
+            If an answer already exists for question and user_input_id, it will be
+            overwritten (in order to maintain data consistency).
+        """
+        try:
+            saver = getattr(self, 'save_line_' + question.question_type)
+        except AttributeError:
+            _logger.error(question.question_type + ": This type of question has no saving function")
+            return False
+        else:
+            saver(user_input_id, question, post, answer_tag)
+
+    @api.model
+    def save_line_free_text(self, user_input_id, question, post, answer_tag):
+        vals = {
+            'user_input_id': user_input_id,
+            'question_id': question.id,
+            'survey_id': question.survey_id.id,
+            'skipped': False,
+        }
+        if answer_tag in post and post[answer_tag].strip():
+            vals.update({'answer_type': 'free_text', 'value_free_text': post[answer_tag]})
+        else:
+            vals.update({'answer_type': None, 'skipped': True})
+        old_uil = self.search([
+            ('user_input_id', '=', user_input_id),
+            ('survey_id', '=', question.survey_id.id),
+            ('question_id', '=', question.id)
+        ])
+        if old_uil:
+            old_uil.write(vals)
+        else:
+            old_uil.create(vals)
+        return True
+
+    @api.model
+    def save_line_textbox(self, user_input_id, question, post, answer_tag):
+        vals = {
+            'user_input_id': user_input_id,
+            'question_id': question.id,
+            'survey_id': question.survey_id.id,
+            'skipped': False
+        }
+        if answer_tag in post and post[answer_tag].strip():
+            vals.update({'answer_type': 'text', 'value_text': post[answer_tag]})
+        else:
+            vals.update({'answer_type': None, 'skipped': True})
+        old_uil = self.search([
+            ('user_input_id', '=', user_input_id),
+            ('survey_id', '=', question.survey_id.id),
+            ('question_id', '=', question.id)
+        ])
+        if old_uil:
+            old_uil.write(vals)
+        else:
+            old_uil.create(vals)
+        return True
+
+    @api.model
+    def save_line_numerical_box(self, user_input_id, question, post, answer_tag):
+        vals = {
+            'user_input_id': user_input_id,
+            'question_id': question.id,
+            'survey_id': question.survey_id.id,
+            'skipped': False
+        }
+        if answer_tag in post and post[answer_tag].strip():
+            vals.update({'answer_type': 'number', 'value_number': float(post[answer_tag])})
+        else:
+            vals.update({'answer_type': None, 'skipped': True})
+        old_uil = self.search([
+            ('user_input_id', '=', user_input_id),
+            ('survey_id', '=', question.survey_id.id),
+            ('question_id', '=', question.id)
+        ])
+        if old_uil:
+            old_uil.write(vals)
+        else:
+            old_uil.create(vals)
+        return True
+
+    @api.model
+    def save_line_date(self, user_input_id, question, post, answer_tag):
+        vals = {
+            'user_input_id': user_input_id,
+            'question_id': question.id,
+            'survey_id': question.survey_id.id,
+            'skipped': False
+        }
+        if answer_tag in post and post[answer_tag].strip():
+            vals.update({'answer_type': 'date', 'value_date': post[answer_tag]})
+        else:
+            vals.update({'answer_type': None, 'skipped': True})
+        old_uil = self.search([
+            ('user_input_id', '=', user_input_id),
+            ('survey_id', '=', question.survey_id.id),
+            ('question_id', '=', question.id)
+        ])
+        if old_uil:
+            old_uil.write(vals)
+        else:
+            old_uil.create(vals)
+        return True
+
+    @api.model
+    def save_line_simple_choice(self, user_input_id, question, post, answer_tag):
+        vals = {
+            'user_input_id': user_input_id,
+            'question_id': question.id,
+            'survey_id': question.survey_id.id,
+            'skipped': False
+        }
+        old_uil = self.search([
+            ('user_input_id', '=', user_input_id),
+            ('survey_id', '=', question.survey_id.id),
+            ('question_id', '=', question.id)
+        ])
+        old_uil.sudo().unlink()
+
+        if answer_tag in post and post[answer_tag].strip():
+            vals.update({'answer_type': 'suggestion', 'value_suggested': post[answer_tag]})
+        else:
+            vals.update({'answer_type': None, 'skipped': True})
+
+        # '-1' indicates 'comment count as an answer' so do not need to record it
+        if post.get(answer_tag) and post.get(answer_tag) != '-1':
+            self.create(vals)
+
+        comment_answer = post.pop(("%s_%s" % (answer_tag, 'comment')), '').strip()
+        if comment_answer:
+            vals.update({'answer_type': 'text', 'value_text': comment_answer, 'skipped': False, 'value_suggested': False})
+            self.create(vals)
+
+        return True
+
+    @api.model
+    def save_line_multiple_choice(self, user_input_id, question, post, answer_tag):
+        vals = {
+            'user_input_id': user_input_id,
+            'question_id': question.id,
+            'survey_id': question.survey_id.id,
+            'skipped': False
+        }
+        old_uil = self.search([
+            ('user_input_id', '=', user_input_id),
+            ('survey_id', '=', question.survey_id.id),
+            ('question_id', '=', question.id)
+        ])
+        old_uil.sudo().unlink()
+
+        ca_dict = dict_keys_startswith(post, answer_tag + '_')
+        comment_answer = ca_dict.pop(("%s_%s" % (answer_tag, 'comment')), '').strip()
+        if len(ca_dict) > 0:
+            for key in ca_dict:
+                # '-1' indicates 'comment count as an answer' so do not need to record it
+                if key != ('%s_%s' % (answer_tag, '-1')):
+                    vals.update({'answer_type': 'suggestion', 'value_suggested': ca_dict[key]})
+                    self.create(vals)
+        if comment_answer:
+            vals.update({'answer_type': 'text', 'value_text': comment_answer, 'value_suggested': False})
+            self.create(vals)
+        if not ca_dict and not comment_answer:
+            vals.update({'answer_type': None, 'skipped': True})
+            self.create(vals)
+        return True
+
+    @api.model
+    def save_line_matrix(self, user_input_id, question, post, answer_tag):
+        vals = {
+            'user_input_id': user_input_id,
+            'question_id': question.id,
+            'survey_id': question.survey_id.id,
+            'skipped': False
+        }
+        old_uil = self.search([
+            ('user_input_id', '=', user_input_id),
+            ('survey_id', '=', question.survey_id.id),
+            ('question_id', '=', question.id)
+        ])
+        old_uil.sudo().unlink()
+
+        no_answers = True
+        ca_dict = dict_keys_startswith(post, answer_tag + '_')
+
+        comment_answer = ca_dict.pop(("%s_%s" % (answer_tag, 'comment')), '').strip()
+        if comment_answer:
+            vals.update({'answer_type': 'text', 'value_text': comment_answer})
+            self.create(vals)
+            no_answers = False
+
+        if question.matrix_subtype == 'simple':
+            for row in question.labels_ids_2:
+                a_tag = "%s_%s" % (answer_tag, row.id)
+                if a_tag in ca_dict:
+                    no_answers = False
+                    vals.update({'answer_type': 'suggestion', 'value_suggested': ca_dict[a_tag], 'value_suggested_row': row.id})
+                    self.create(vals)
+
+        elif question.matrix_subtype == 'multiple':
+            for col in question.labels_ids:
+                for row in question.labels_ids_2:
+                    a_tag = "%s_%s_%s" % (answer_tag, row.id, col.id)
+                    if a_tag in ca_dict:
+                        no_answers = False
+                        vals.update({'answer_type': 'suggestion', 'value_suggested': col.id, 'value_suggested_row': row.id})
+                        self.create(vals)
+        if no_answers:
+            vals.update({'answer_type': None, 'skipped': True})
+            self.create(vals)
+        return True
