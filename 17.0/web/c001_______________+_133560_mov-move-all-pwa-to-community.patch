PR: https://github.com/odoo/odoo/pull/133560

From: 0903ef7bb2117623cf6cbbd2375f56ca91babe6a
From: Romeo Fragomeli
Date: 2023-09-11 16:32:30

Structural Changes: 3
Total Changes: 91

[MOV] *: move all PWA to community

In this commit, we moved all features related to the PWA and the PWA
itself to the community.

This includes:
* PWA
* Web Push Notification
* VCARD

Note from original commits:
===========================

PWA (part 1)
------------
This commit adds a ServiceWorker to complement the WebManifest to
complete the setup of the backend as a Progressive Web App.

More precisely, it adds the route, registration and the most basic
ServiceWorker to allow the backend to be recognized as an installable
PWA.

References:
- https://web.dev/install-criteria/
- https://developer.mozilla.org/en-US/docs/Web/Progressive_web_apps/Installable_PWAs
- https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers

Task ID: 3063485

PWA (part 2)
------------
This commit adds a WebManifest as a first step toward setuping the
backend as a Progressive Web App.

In a nutshell:
- the web app's name is configurable through a config parameter
  (available in the Settings, in debug); defaulting to "Odoo".
- the web app's icon has been revamped to accommodate the required sizes;
  also its design matches the one from the Android app.
- "theme-color" is used to color part of the browser/system UI to match
  Enterprise brand color; also supports the dark mode.

References:
- https://web.dev/learn/pwa/web-app-manifest/
- https://web.dev/install-criteria/
- https://developer.mozilla.org/en-US/docs/Web/Manifest

Task ID: 3063485

PWA shortcuts
-------------
The main goal of this commit is like we did inside the `Android Odoo
Mobile App`, allowing users to have some Odoo application shortcuts.
We added the following apps in the key `shortcuts` on `web.manifest` in
these orders: `Discuss`, `CRM`, `Project`, `To-Do` (old `Notes`).

Links:
- https://w3c.github.io/manifest/#shortcuts-member
- https://developer.mozilla.org/en-US/docs/Web/Manifest/shortcuts

Task ID: 3123607

Offline mode
------------
This commit introduces a way to notify the user that he's "offline"
(aka. cannot reach its Odoo server) and that Odoo doesn't work in a
graceful way in this circumstance.

To do so, the Service-Worker will return the response of the
´web/offline´ route, which is cached at its setup.

Note: this screen is only show when launched while "offline" and fails
to load the requested page. It does not "interrupt" the WebClient to
show this screen when the connection drops off (cf. not a replacement
for the existing notification).

Task ID: 3203639

WebPush
-------

WebPush allows sending data to the user browser/app(PWA) even when
tab/app is closed. Web push is a "constant" link between the
ServiceWorker of browser/app and a WebPush server.

Note that each browser has its own custom WebPush server.
e.g.:
Chrome: https://fcm.googleapis.com/
Firefox: https://updates.push.services.mozilla.com/
Safari: https://web.push.apple.com/
Edge: https://wns2-ln2p.notify.windows.com/
WebPush introduces some cryptographic notion to ensure some the
reliability of the data sent:

VAPID: "Voluntary Application Server Identification" is the standard
used to generate the public and the private to sign the message
between the browser and the WebPush server
JWT: "JSON Web Token" is the standard used to sign the payload to the
WebPush server
ECE: "Encrypted Content-Encoding" is the standard used by WebPush to
encrypt the data of the payload to avoid sending RAW data
outside trusted network.
Simplified steps how to WebPush works:

The Javascript code of a web page subscribes to the WebPush server
(using the VAPID key generated at mail_entreprise install).
The WebPush server replay with a subscription (and some other info
like the unique URL endpoint per subscription where to send a
notification)
The application (odoo-bin in our case) sends a post request to the
WebPush server using the specific URL endpoint of the user (using JWT
and ECE).
The WebPush server sends back to the browser the encrypted payload.
The browser decrypts the payload and sends it to the ServiceWorker
linked to the subscription.
Here is a Sequence diagram of all interactions to process a web push
notification.
In Odoo, we use WebPush to send Notification to the user.

This commit aims to have a parity with the Android/iOS Mobile App at
the notification level.

Notes:

There are some ways to encrypt (ECE) the message for WebPush:

AESGCM128: this is a draft
AESGCM: very well documented
AES128GCM: RFC8188 Standard encoding
We implement only the RFC one as it is the only one implemented in all
major updated browsers (Chrome, Firefox, Safari, Edge, ...)
You need to allow the desktop "Notification" and "Push" inside your
browser. For iOS Devices, it only works on iOS 16.4+ and it's requiring
Odoo to first be added to the Home Screen. It's delivered silently,
meaning no sound, vibration, haptics or screen wake.

Note:
Notifications are sent directly if there are less than five
notifications, otherwise we use a cron triggered immediately.
Also, we have changed the value of the "QueryCount" as mail_enterprise
executes a new query to search the devices associated with the partner.

We have added a "try/except" for any Exception before the
push_to_end_point method as we want to avoid blocking a normal flow
just for a not mandatory push notification if something happens during
the push to the endpoint.
See: odoo/enterprise@d0ae70103dd1c169debe8fcb0918f80310c85e42

Links:
https://www.rfc-editor.org/rfc/rfc8030
https://www.rfc-editor.org/rfc/rfc8188
https://www.rfc-editor.org/rfc/rfc8291
https://www.rfc-editor.org/rfc/rfc8292
https://w3c.github.io/push-api/index.html
https://autopush.readthedocs.io/en/latest/http.html
https://web.dev/push-notifications-web-push-protocol/
https://github.com/web-push-libs/encrypted-content-encoding
https://github.com/web-push-libs/pywebpush
https://github.com/web-push-libs/vapid
https://caniuse.com/push-api
Task ID: 3123678

VCARD
-----
In the process of replacing the native methods exposed in the mobile
apps, this commit implements the download of a vCard containing a
partner's information.

By using this standard format, both regular web users and mobile ones
are now able to save the partner's details to use them with their usual
address book software.

On a mobile device, the actual import of those informations is delegated
to the operating system.

References:
- https://datatracker.ietf.org/doc/html/rfc6350
- https://en.wikipedia.org/wiki/VCard
- https://github.com/eventable/vobject#vcards

Task ID: 2583916

===========
End of note
===========

Task ID: 3478014

closes odoo/odoo#133560

Related: odoo/enterprise#46530
Related: odoo/upgrade#5086
Signed-off-by: Adrien Dieudonné (adr) <adr@odoo.com>
Co-authored-by: Romeo Fragomeli <rfr@odoo.com>
Co-authored-by: Romain Estievenart <res@odoo.com>
Co-authored-by: Pierre Paridans <app@odoo.com>

================================= pseudo patch: =================================

--- a/addons/web/models/__init__.py
+++ b/addons/web/models/__init__.py
@@ -7,4 +7,6 @@ from . import ir_model
 from . import ir_ui_menu
 from . import models
 from . import base_document_layout
+from . import res_config_settings
+from . import res_partner
 from . import res_users

--- a/None
+++ b/addons/web/models/res_config_settings.py
@@ -0,0 +1,10 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from odoo import fields, models
+
+
+class ResConfigSettings(models.TransientModel):
+    _inherit = 'res.config.settings'
+
+    web_app_name = fields.Char('Web App Name', config_parameter='web.web_app_name')

--- a/None
+++ b/addons/web/models/res_partner.py
@@ -0,0 +1,79 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+import logging
+from base64 import b64decode
+
+from odoo import models
+
+_logger = logging.getLogger(__name__)
+
+try:
+    import vobject
+except ImportError:
+    _logger.warning("`vobject` Python module not found, vcard file generation disabled. Consider installing this module if you want to generate vcard files")
+    vobject = None
+
+
+class ResPartner(models.Model):
+    _inherit = 'res.partner'
+
+    def _build_vcard(self):
+        """ Build the partner's vCard.
+            :returns a vobject.vCard object
+        """
+        if not vobject:
+            return False
+        vcard = vobject.vCard()
+        # Name
+        n = vcard.add('n')
+        n.value = vobject.vcard.Name(family=self.name)
+        if self.title:
+            n.value.prefix = self.title.name
+        # Formatted Name
+        fn = vcard.add('fn')
+        fn.value = self.name
+        # Address
+        adr = vcard.add('adr')
+        adr.value = vobject.vcard.Address(street=self.street or '', city=self.city or '', code=self.zip or '')
+        if self.state_id:
+            adr.value.region = self.state_id.name
+        if self.country_id:
+            adr.value.country = self.country_id.name
+        # Email
+        if self.email:
+            email = vcard.add('email')
+            email.value = self.email
+            email.type_param = 'INTERNET'
+        # Telephone numbers
+        if self.phone:
+            tel = vcard.add('tel')
+            tel.type_param = 'work'
+            tel.value = self.phone
+        if self.mobile:
+            tel = vcard.add('tel')
+            tel.type_param = 'cell'
+            tel.value = self.mobile
+        # URL
+        if self.website:
+            url = vcard.add('url')
+            url.value = self.website
+        # Organisation
+        if self.commercial_company_name:
+            org = vcard.add('org')
+            org.value = [self.commercial_company_name]
+        if self.function:
+            function = vcard.add('title')
+            function.value = self.function
+        # Photo
+        photo = vcard.add('photo')
+        photo.value = b64decode(self.avatar_512)
+        photo.encoding_param = 'B'
+        photo.type_param = 'JPG'
+        return vcard
+
+    def _get_vcard_file(self):
+        vcard = self._build_vcard()
+        if vcard:
+            return vcard.serialize().encode()
+        return False
