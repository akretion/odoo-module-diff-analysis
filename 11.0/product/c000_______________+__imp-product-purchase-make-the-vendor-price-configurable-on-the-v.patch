PR: https://github.com/odoo/odoo/pull/

From: d5c24abee57a347422800b560b7de1fbcb7de22a
From: mdi-odoo
Date: 2016-12-01 13:59:20

Structural Changes: 3
Total Changes: 57

[IMP] product,purchase: Make the vendor price configurable on the variants too.

=======
Purpose
=======

There are some confusion about the use of the vendor price and the cost price.
Moreover, in the purchase app, the RFQ should take the variant vendor price, if one is set

==========
Specification
==========

Add a clear tooltip on the Cost field (standard_price) : "The cost price is used for valuate stocks or to asses the price of manufacturing a product. The purchase orders are fetching the vendor prices."
In the simplified view, add the vendor cost o2m : https://drive.google.com/a/openerp.com/file/d/0BxqHe5rtIxY0LVZHZXFWcWFHckk/view?usp=drivesdk
Variant vendor prices should be indenpendant from each other, and from the template ones.
In the purchase app, when creating an RFQ : the system fetches the variant cost price (from vendor o2m), if no price on variant, it takes the vendor price on template.

NB: fp request

================================= pseudo patch: =================================

--- a/addons/product/models/product.py
+++ b/addons/product/models/product.py
@@ -162,6 +162,7 @@ class ProductProduct(models.Model):
 
     pricelist_item_ids = fields.Many2many(
         'product.pricelist.item', 'Pricelist Items', compute='_get_pricelist_items')
+    product_seller_ids = fields.One2many('product.supplierinfo', 'product_id', 'Variant Vendors')
 
     _sql_constraints = [
         ('barcode_uniq', 'unique(barcode)', _("A barcode can only be assigned to one product !")),
@@ -478,29 +479,11 @@ class ProductProduct(models.Model):
     @api.multi
     def _select_seller(self, partner_id=False, quantity=0.0, date=None, uom_id=False):
         self.ensure_one()
-        if date is None:
-            date = fields.Date.today()
-        res = self.env['product.supplierinfo']
-        for seller in self.seller_ids:
-            # Set quantity in UoM of seller
-            quantity_uom_seller = quantity
-            if quantity_uom_seller and uom_id and uom_id != seller.product_uom:
-                quantity_uom_seller = uom_id._compute_quantity(quantity_uom_seller, seller.product_uom)
-
-            if seller.date_start and seller.date_start > date:
-                continue
-            if seller.date_end and seller.date_end < date:
-                continue
-            if partner_id and seller.name not in [partner_id, partner_id.parent_id]:
-                continue
-            if quantity_uom_seller < seller.min_qty:
-                continue
-            if seller.product_id and seller.product_id != self:
-                continue
-
-            res |= seller
-            break
-        return res
+        SupInfo = self.env['product.supplierinfo']
+        seller = SupInfo.find_seller(self.product_seller_ids, self, partner_id, quantity, date, uom_id)
+        if not seller:
+            seller = SupInfo.find_seller(self.seller_ids, self, partner_id, quantity, date, uom_id)
+        return seller
 
     @api.multi
     def price_compute(self, price_type, uom=False, currency=False, company=False):
@@ -621,3 +604,29 @@ class SuppliferInfo(models.Model):
     delay = fields.Integer(
         'Delivery Lead Time', default=1, required=True,
         help="Lead time in days between the confirmation of the purchase order and the receipt of the products in your warehouse. Used by the scheduler for automatic computation of the purchase order planning.")
+
+    @api.model
+    def find_seller(self, sellers, product, partner_id=False, quantity=0.0, date=None, uom_id=False):
+        if date is None:
+            date = fields.Date.today()
+        res = self
+        for seller in sellers:
+            # Set quantity in UoM of seller
+            quantity_uom_seller = quantity
+            seller_uom = seller.product_uom or seller.product_id.product_tmpl_id.uom_id
+            if quantity_uom_seller and uom_id and uom_id != seller_uom:
+                quantity_uom_seller = uom_id._compute_quantity(quantity_uom_seller, seller_uom)
+            if seller.date_start and seller.date_start > date:
+                continue
+            if seller.date_end and seller.date_end < date:
+                continue
+            if partner_id and seller.name not in [partner_id, partner_id.parent_id]:
+                continue
+            if quantity_uom_seller < seller.min_qty:
+                continue
+            if seller.product_id and seller.product_id != product:
+                continue
+
+            res |= seller
+            break
+        return res

--- a/addons/product/models/product_template.py
+++ b/addons/product/models/product_template.py
@@ -70,7 +70,7 @@ class ProductTemplate(models.Model):
         'Cost', compute='_compute_standard_price',
         inverse='_set_standard_price', search='_search_standard_price',
         digits=dp.get_precision('Product Price'), groups="base.group_user",
-        help="Cost of the product, in the default unit of measure of the product.")
+        help="The cost price is used for valuate stocks or to assess the price of manufacturing a product. The purchase orders are fetching the vendor prices.")
 
     volume = fields.Float(
         'Volume', compute='_compute_volume', inverse='_set_volume',
