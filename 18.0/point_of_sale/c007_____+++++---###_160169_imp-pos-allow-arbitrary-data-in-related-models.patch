PR: https://github.com/odoo/odoo/pull/160169

From: 02f756d061f1e52a2265e051ac57b13b311fb115
From: David Monnom (moda)
Date: 2024-04-29 23:21:31

Structural Changes: 51
Total Changes: 1034

[IMP] pos_*: allow arbitrary data in related models

*: All pos related modules

This commit allows to access arbitrary data in related models. This is
useful for data that are computed on the server side and that are not
recomputed on the client side.

Before this commit, it was only possible to access data that are linked
to a field in the model.

Now custom data coming from the server can be added to any record with
the prefix `_` in the key. For example, if the server sends the
following data for `pos.order`:

Classic fields:
```
{
  id: 1,
  name: 'Order 1',
  partner_id: 1,
  partner_name: 'Partner 1',
}
```

Custom fields:
```
{
  id: 1,
  name: 'Order 1',
  partner_id: 1,
  partner_name: 'Partner 1',
  _custom_field: 'Custom value',
}
```

closes odoo/odoo#160169

Related: odoo/enterprise#60017
Signed-off-by: Adrien Guilliams (adgu) <adgu@odoo.com>

================================= pseudo patch: =================================

--- a/addons/point_of_sale/models/__init__.py
+++ b/addons/point_of_sale/models/__init__.py
@@ -2,6 +2,7 @@
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
 from . import account_bank_statement
+from . import pos_load_mixin
 from . import account_payment
 from . import account_journal
 from . import account_tax
@@ -29,3 +30,12 @@ from . import pos_bill
 from . import report_sale_details
 from . import pos_printer
 from . import pos_note
+from . import res_users
+from . import decimal_precision
+from . import res_country
+from . import res_country_state
+from . import res_lang
+from . import account_fiscal_position
+from . import account_fiscal_position_tax
+from . import res_currency
+from . import ir_ui_view

--- a/None
+++ b/addons/point_of_sale/models/account_fiscal_position.py
@@ -0,0 +1,36 @@
+from odoo import models, api
+
+
+class AccountFiscalPosition(models.Model):
+    _name = 'account.fiscal.position'
+    _inherit = ['account.fiscal.position', 'pos.load.mixin']
+
+    @api.model
+    def _load_pos_data_domain(self, data):
+        return [('id', 'in', data['pos.config']['data'][0]['fiscal_position_ids'])]
+
+    @api.model
+    def _load_pos_data_fields(self, config_id):
+        return ['id', 'name', 'display_name']
+
+    def _load_pos_data(self, data):
+        domain = self._load_pos_data_domain(data)
+        fields = self._load_pos_data_fields(data['pos.config']['data'][0]['id'])
+        fiscal_position_ids = self.search(domain)
+        fp_list = []
+
+        for fiscal_position in fiscal_position_ids:
+            fp_dict = fiscal_position.read(fields)[0]
+            fp_dict['_tax_mapping_by_ids'] = {}
+
+            for fiscal_position_tax in fiscal_position.tax_ids:
+                if not fp_dict['_tax_mapping_by_ids'].get(fiscal_position_tax.tax_src_id.id):
+                    fp_dict['_tax_mapping_by_ids'][fiscal_position_tax.tax_src_id.id] = []
+                fp_dict['_tax_mapping_by_ids'][fiscal_position_tax.tax_src_id.id].append(fiscal_position_tax.tax_dest_id.id)
+
+            fp_list.append(fp_dict)
+
+        return {
+            'data': fp_list,
+            'fields': fields
+        }

--- a/None
+++ b/addons/point_of_sale/models/account_fiscal_position_tax.py
@@ -0,0 +1,10 @@
+from odoo import models, api
+
+
+class AccountFiscalPositionTax(models.Model):
+    _name = 'account.fiscal.position.tax'
+    _inherit = ['account.fiscal.position.tax', 'pos.load.mixin']
+
+    @api.model
+    def _load_pos_data_domain(self, data):
+        return [('position_id', 'in', [fpos['id'] for fpos in data['account.fiscal.position']['data']])]

--- a/addons/point_of_sale/models/account_tax.py
+++ b/addons/point_of_sale/models/account_tax.py
@@ -49,3 +49,34 @@ class AccountTax(models.Model):
             used_taxes.update([tax[0] for tax in self.env.cr.fetchall()])
 
         return used_taxes
+
+    @api.model
+    def _load_pos_data_domain(self, data):
+        return [('company_id', '=', data['pos.config']['data'][0]['company_id'])]
+
+    @api.model
+    def _load_pos_data_fields(self, config_id):
+        return [
+            'id', 'name', 'price_include', 'include_base_amount', 'is_base_affected',
+            'amount_type', 'children_tax_ids', 'amount', 'repartition_line_ids', 'id'
+        ]
+
+    def _load_pos_data(self, data):
+        domain = self._load_pos_data_domain(data)
+        tax_ids = self.search(domain)
+        taxes_list = []
+
+        for tax in tax_ids:
+            taxes_list.append(tax._prepare_dict_for_taxes_computation())
+
+        if data['pos.config']['data'][0]['current_session_id']:
+            product_fields = self.env['account.tax']._eval_taxes_computation_prepare_product_fields(taxes_list)
+            session_data = next(x for x in data['pos.session']['data'] if x['id'] == data['pos.config']['data'][0]['current_session_id'])
+            session_data['_product_default_values'] = self.env['account.tax']._eval_taxes_computation_prepare_product_default_values(
+                product_fields,
+            )
+
+        return {
+            'data': taxes_list,
+            'fields': self._load_pos_data_fields(data['pos.config']['data'][0]['id']),
+        }

--- a/None
+++ b/addons/point_of_sale/models/decimal_precision.py
@@ -0,0 +1,10 @@
+from odoo import models, api
+
+
+class DecimalPrecision(models.Model):
+    _name = 'decimal.precision'
+    _inherit = ['decimal.precision', 'pos.load.mixin']
+
+    @api.model
+    def _load_pos_data_fields(self, config_id):
+        return ['id', 'name', 'digits']

--- a/None
+++ b/addons/point_of_sale/models/ir_ui_view.py
@@ -0,0 +1,17 @@
+from odoo import models, api
+
+
+class IrUiView(models.Model):
+    _name = 'ir.ui.view'
+    _inherit = ['ir.ui.view', 'pos.load.mixin']
+
+    @api.model
+    def _load_pos_data_fields(self, config_id):
+        return ['id', 'name']
+
+    def _load_pos_data(self, data):
+        fields = self._load_pos_data_fields(data['pos.config']['data'][0]['id'])
+        return {
+            'data': self.env.ref('base.view_partner_form').sudo().read(fields),
+            'fields': fields
+        }

--- a/addons/point_of_sale/models/pos_bill.py
+++ b/addons/point_of_sale/models/pos_bill.py
@@ -1,11 +1,13 @@
 from odoo import api, fields, models, _
 from odoo.exceptions import UserError
+from odoo.osv.expression import OR
 
 
 class Bill(models.Model):
     _name = "pos.bill"
     _order = "value"
     _description = "Coins/Bills"
+    _inherit = ["pos.load.mixin"]
 
     name = fields.Char("Name")
     value = fields.Float("Coin/Bill Value", required=True, digits=0)
@@ -20,3 +22,14 @@ class Bill(models.Model):
             raise UserError(_("The name of the Coins/Bills must be a number."))
         result = super().create({"name": name, "value": value})
         return result.id, result.display_name
+
+    @api.model
+    def _load_pos_data_domain(self, data):
+        return OR([
+            [('id', 'in', data['pos.config']['data'][0]['default_bill_ids']), ('for_all_config', '=', False)],
+            [('for_all_config', '=', True)]
+        ])
+
+    @api.model
+    def _load_pos_data_fields(self, config_id):
+        return ['id', 'name', 'value']

--- a/addons/point_of_sale/models/pos_category.py
+++ b/addons/point_of_sale/models/pos_category.py
@@ -11,6 +11,7 @@ from odoo.exceptions import ValidationError, UserError
 class PosCategory(models.Model):
     _name = "pos.category"
     _description = "Point of Sale Category"
+    _inherit = ['pos.load.mixin']
     _order = "sequence, name"
 
     @api.constrains('parent_id')
@@ -32,6 +33,16 @@ class PosCategory(models.Model):
     # field to determine whether a pos.category has an image or not.
     has_image = fields.Boolean(compute='_compute_has_image')
 
+    @api.model
+    def _load_pos_data_domain(self, data):
+        config_id = self.env['pos.config'].browse(data['pos.config']['data'][0]['id'])
+        domain = [('id', 'in', config_id._get_available_categories().ids)] if config_id.limit_categories and config_id.iface_available_categ_ids else []
+        return domain
+
+    @api.model
+    def _load_pos_data_fields(self, config_id):
+        return ['id', 'name', 'parent_id', 'child_ids', 'write_date', 'has_image', 'color', 'sequence']
+
     def _get_hierarchy(self) -> List[str]:
         """ Returns a list representing the hierarchy of the categories. """
         self.ensure_one()

--- a/addons/point_of_sale/models/pos_combo.py
+++ b/addons/point_of_sale/models/pos_combo.py
@@ -19,6 +19,7 @@ class PosCombo(models.Model):
     _name = "pos.combo"
     _description = "Product combo choices"
     _order = "sequence, id"
+    _inherit = ['pos.load.mixin']
     name = fields.Char(string="Name", required=True)
     combo_line_ids = fields.One2many("pos.combo.line", "combo_id", string="Products in Combo", copy=True)
     num_of_products = fields.Integer("No of Products", compute="_compute_num_of_products")
@@ -29,6 +30,14 @@ class PosCombo(models.Model):
         help="The value from which pro-rating of the component price is based. This is to ensure that whatever product the user chooses for a component, it will always be they same price."
     )
 
+    @api.model
+    def _load_pos_data_domain(self, data):
+        return [('id', 'in', list(set().union(*[product.get('combo_ids') for product in data['product.product']['data']])))]
+
+    @api.model
+    def _load_pos_data_fields(self, config_id):
+        return ['id', 'name', 'combo_line_ids', 'base_price']
+
     @api.depends("combo_line_ids")
     def _compute_num_of_products(self):
         """

--- a/addons/point_of_sale/models/pos_combo_line.py
+++ b/addons/point_of_sale/models/pos_combo_line.py
@@ -1,11 +1,20 @@
-from odoo import fields, models
+from odoo import fields, models, api
 
 
 class PosComboLine(models.Model):
     _name = "pos.combo.line"
     _description = "Product Combo Items"
+    _inherit = ['pos.load.mixin']
 
     product_id = fields.Many2one("product.product", string="Product", required=True)
     combo_price = fields.Float("Price Extra", default=0.0)
     lst_price = fields.Float("Original Price", related="product_id.lst_price")
     combo_id = fields.Many2one("pos.combo")
+
+    @api.model
+    def _load_pos_data_domain(self, data):
+        return [('id', 'in', list(set().union(*[combo.get('combo_line_ids') for combo in data['pos.combo']['data']])))]
+
+    @api.model
+    def _load_pos_data_fields(self, config_id):
+        return ['id', 'product_id', 'combo_price', 'combo_id']

--- a/addons/point_of_sale/models/pos_config.py
+++ b/addons/point_of_sale/models/pos_config.py
@@ -12,7 +12,7 @@ from odoo.exceptions import AccessError, ValidationError, UserError
 
 class PosConfig(models.Model):
     _name = 'pos.config'
-    _inherit = ['pos.bus.mixin']
+    _inherit = ['pos.bus.mixin', 'pos.load.mixin']
     _description = 'Point of Sale Configuration'
     _check_company_auto = True
 
@@ -189,6 +189,23 @@ class PosConfig(models.Model):
     show_category_images = fields.Boolean(string="Show Category Images", help="Show category images in the Point of Sale interface.", default=True)
     note_ids = fields.Many2many('pos.note', string='Note Models', help='The predefined notes of this point of sale.')
 
+    @api.model
+    def _load_pos_data_domain(self, data):
+        return [('id', '=', data['pos.session']['data'][0]['config_id'])]
+
+    def _load_pos_data(self, data):
+        domain = self._load_pos_data_domain(data)
+        fields = self._load_pos_data_fields(self.id)
+        data = self.search_read(domain, fields, load=False)
+
+        if not data[0]['use_pricelist']:
+            data[0]['pricelist_id'] = False
+
+        return {
+            'data': data,
+            'fields': fields,
+        }
+
     @api.depends('payment_method_ids')
     def _compute_cash_control(self):
         for config in self:

--- a/None
+++ b/addons/point_of_sale/models/pos_load_mixin.py
@@ -0,0 +1,25 @@
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+from odoo import models, api
+
+
+class PosLoadMixin(models.AbstractModel):
+    _name = "pos.load.mixin"
+    _description = "PoS data loading mixin"
+
+    @api.model
+    def _load_pos_data_fields(self, config_id):
+        return []
+
+    @api.model
+    def _load_pos_data_domain(self, data):
+        return []
+
+    # If you need to adapt the data to be loaded in the PoS, you can
+    # override this method in your model.
+    def _load_pos_data(self, data):
+        domain = self._load_pos_data_domain(data)
+        fields = self._load_pos_data_fields(data['pos.config']['data'][0]['id'])
+        return {
+            'data': self.search_read(domain, fields, load=False),
+            'fields': fields,
+        }

--- a/addons/point_of_sale/models/pos_note.py
+++ b/addons/point_of_sale/models/pos_note.py
@@ -1,12 +1,22 @@
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
-from odoo import fields, models
+from odoo import fields, models, api
+
 
 class PosNote(models.Model):
     _name = 'pos.note'
     _description = 'PoS Note'
+    _inherit = ['pos.load.mixin']
 
     name = fields.Char(required=True)
     sequence = fields.Integer('Sequence', default=1)
 
     _sql_constraints = [('name_unique', 'unique (name)', "A note with this name already exists")]
+
+    @api.model
+    def _load_pos_data_domain(self, data):
+        return [('id', 'in', data['pos.config']['data'][0]['note_ids'])] if data['pos.config']['data'][0]['note_ids'] else []
+
+    @api.model
+    def _load_pos_data_fields(self, config_id):
+        return ['name']

--- a/addons/point_of_sale/models/pos_order.py
+++ b/addons/point_of_sale/models/pos_order.py
@@ -3,13 +3,11 @@
 import logging
 from datetime import datetime
 from markupsafe import Markup
-from functools import partial
 from itertools import groupby
 from collections import defaultdict
 
 import psycopg2
 import pytz
-import re
 
 from odoo import api, fields, models, tools, _
 from odoo.tools import float_is_zero, float_round, float_repr, float_compare
@@ -22,7 +20,7 @@ _logger = logging.getLogger(__name__)
 
 class PosOrder(models.Model):
     _name = "pos.order"
-    _inherit = ["portal.mixin", "pos.bus.mixin"]
+    _inherit = ["portal.mixin", "pos.bus.mixin", "pos.load.mixin"]
     _description = "Point of Sale Orders"
     _order = "date_order desc, name desc, id desc"
 
@@ -76,6 +74,10 @@ class PosOrder(models.Model):
         for record in self:
             record.tracking_number = str((record.session_id.id % 10) * 100 + record.sequence_number % 100).zfill(3)
 
+    @api.model
+    def _load_pos_data_domain(self, data):
+        return [('state', '=', 'draft'), ('session_id', '=', data['pos.session']['data'][0]['id'])]
+
     @api.model
     def _process_order(self, order, existing_order):
         """Create or update an pos.order from a given dictionary.
@@ -928,19 +930,13 @@ class PosOrder(models.Model):
 
         # Sometime pos_orders_ids can be empty.
         pos_order_ids = self.env['pos.order'].browse(order_ids)
-        config_id = False
-        if self.env.context.get('config_id'):
-            config_id = self.env['pos.config'].browse(self.env.context.get('config_id'))
-        else:
-            config_id = pos_order_ids[0].config_id
-        params = self.env["pos.session"]._load_data_params(config_id)
-
+        config_id = pos_order_ids[0].config_id.id if pos_order_ids else False
         return {
-            'pos.order': pos_order_ids.read(params["pos.order"]["fields"], load=False),
-            'pos.payment': pos_order_ids.payment_ids.read(params["pos.payment"]["fields"], load=False),
-            'pos.order.line': pos_order_ids.lines.read(params["pos.order.line"]["fields"], load=False),
-            'pos.pack.operation.lot': pos_order_ids.lines.pack_lot_ids.read(params["pos.pack.operation.lot"]["fields"], load=False),
-            "product.attribute.custom.value": pos_order_ids.lines.custom_attribute_value_ids.read(params["product.attribute.custom.value"]["fields"], load=False)
+            'pos.order': pos_order_ids.read(pos_order_ids._load_pos_data_fields(config_id), load=False) if config_id else [],
+            'pos.payment': pos_order_ids.payment_ids.read(pos_order_ids.payment_ids._load_pos_data_fields(config_id), load=False) if config_id else [],
+            'pos.order.line': pos_order_ids.lines.read(pos_order_ids.lines._load_pos_data_fields(config_id), load=False) if config_id else [],
+            'pos.pack.operation.lot': pos_order_ids.lines.pack_lot_ids.read(pos_order_ids.lines.pack_lot_ids._load_pos_data_fields(config_id), load=False) if config_id else [],
+            "product.attribute.custom.value": pos_order_ids.lines.custom_attribute_value_ids.read(pos_order_ids.lines.custom_attribute_value_ids._load_pos_data_fields(config_id), load=False) if config_id else [],
         }
 
     def _is_the_same_order(self, data, existing_order):
@@ -1152,6 +1148,7 @@ class PosOrderLine(models.Model):
     _name = "pos.order.line"
     _description = "Point of Sale Order Lines"
     _rec_name = "product_id"
+    _inherit = ['pos.load.mixin']
 
     company_id = fields.Many2one('res.company', string='Company', related="order_id.company_id", store=True)
     name = fields.Char(string='Line No', required=True, copy=False)
@@ -1194,6 +1191,17 @@ class PosOrderLine(models.Model):
 
     combo_line_id = fields.Many2one('pos.combo.line', string='Combo Line')
 
+    @api.model
+    def _load_pos_data_domain(self, data):
+        return [('order_id', 'in', [order['id'] for order in data['pos.order']['data']])]
+
+    @api.model
+    def _load_pos_data_fields(self, config_id):
+        return [
+            'qty', 'attribute_value_ids', 'custom_attribute_value_ids', 'price_unit', 'skip_change', 'uuid', 'price_subtotal', 'price_subtotal_incl', 'order_id', 'note',
+            'product_id', 'discount', 'tax_ids', 'combo_line_id', 'pack_lot_ids', 'customer_note', 'refunded_qty', 'price_extra', 'full_product_name', 'refunded_orderline_id', 'combo_parent_id', 'combo_line_ids', 'combo_line_id'
+        ]
+
     @api.model
     def _is_field_accepted(self, field):
         return field in self._fields and not field in ['combo_parent_id', 'combo_line_ids']
@@ -1472,15 +1480,24 @@ class PosOrderLineLot(models.Model):
     _name = "pos.pack.operation.lot"
     _description = "Specify product lot/serial number in pos order line"
     _rec_name = "lot_name"
+    _inherit = ['pos.load.mixin']
 
     pos_order_line_id = fields.Many2one('pos.order.line')
     order_id = fields.Many2one('pos.order', related="pos_order_line_id.order_id", readonly=False)
     lot_name = fields.Char('Lot Name')
     product_id = fields.Many2one('product.product', related='pos_order_line_id.product_id', readonly=False)
 
+    @api.model
+    def _load_pos_data_domain(self, data):
+        return [('pos_order_line_id', 'in', [line['id'] for line in data['pos.order.line']['data']])]
+
+    @api.model
+    def _load_pos_data_fields(self, config_id):
+        return ['lot_name', 'pos_order_line_id']
 
 class AccountCashRounding(models.Model):
-    _inherit = 'account.cash.rounding'
+    _name = 'account.cash.rounding'
+    _inherit = ['account.cash.rounding', 'pos.load.mixin']
 
     @api.constrains('rounding', 'rounding_method', 'strategy')
     def _check_session_state(self):
@@ -1488,3 +1505,11 @@ class AccountCashRounding(models.Model):
         if open_session:
             raise ValidationError(
                 _("You are not allowed to change the cash rounding configuration while a pos session using it is already opened."))
+
+    @api.model
+    def _load_pos_data_domain(self, data):
+        return [('id', '=', data['pos.config']['data'][0]['rounding_method'])]
+
+    @api.model
+    def _load_pos_data_fields(self, config_id):
+        return ['id', 'name', 'rounding', 'rounding_method']

--- a/addons/point_of_sale/models/pos_payment.py
+++ b/addons/point_of_sale/models/pos_payment.py
@@ -14,6 +14,7 @@ class PosPayment(models.Model):
     _name = "pos.payment"
     _description = "Point of Sale Payments"
     _order = "id desc"
+    _inherit = ['pos.load.mixin']
 
     name = fields.Char(string='Label', readonly=True)
     pos_order_id = fields.Many2one('pos.order', string='Order', required=True, index=True)
@@ -34,6 +35,10 @@ class PosPayment(models.Model):
     account_move_id = fields.Many2one('account.move')
     uuid = fields.Char(string='Uuid', readonly=True, copy=False)
 
+    @api.model
+    def _load_pos_data_domain(self, data):
+        return [('pos_order_id', 'in', [order['id'] for order in data['pos.order']['data']])]
+
     @api.depends('amount', 'currency_id')
     def _compute_display_name(self):
         for payment in self:

--- a/addons/point_of_sale/models/pos_payment_method.py
+++ b/addons/point_of_sale/models/pos_payment_method.py
@@ -6,6 +6,7 @@ class PosPaymentMethod(models.Model):
     _name = "pos.payment.method"
     _description = "Point of Sale Payment Methods"
     _order = "sequence, id"
+    _inherit = ['pos.load.mixin']
 
     def _get_payment_terminal_selection(self):
         return []
@@ -61,6 +62,14 @@ class PosPaymentMethod(models.Model):
     )
     hide_qr_code_method = fields.Boolean(compute='_compute_hide_qr_code_method')
 
+    @api.model
+    def _load_pos_data_domain(self, data):
+        return ['|', ('active', '=', False), ('active', '=', True)]
+
+    @api.model
+    def _load_pos_data_fields(self, config_id):
+        return ['id', 'name', 'is_cash_count', 'use_payment_terminal', 'split_transactions', 'type', 'image', 'sequence', 'payment_method_type', 'default_qr']
+
     @api.depends('type', 'payment_method_type')
     def _compute_hide_use_payment_terminal(self):
         no_terminals = not bool(self._fields['use_payment_terminal'].selection(self))

--- a/addons/point_of_sale/models/pos_printer.py
+++ b/addons/point_of_sale/models/pos_printer.py
@@ -1,12 +1,13 @@
 # -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
-from odoo import fields, models
+from odoo import fields, models, api
 
 class PosPrinter(models.Model):
 
     _name = 'pos.printer'
     _description = 'Point of Sale Printer'
+    _inherit = ['pos.load.mixin']
 
     name = fields.Char('Printer Name', required=True, default='Printer', help='An internal identification of the printer')
     printer_type = fields.Selection(string='Printer Type', default='iot',
@@ -14,3 +15,11 @@ class PosPrinter(models.Model):
     proxy_ip = fields.Char('Proxy IP Address', help="The IP Address or hostname of the Printer's hardware proxy")
     product_categories_ids = fields.Many2many('pos.category', 'printer_category_rel', 'printer_id', 'category_id', string='Printed Product Categories')
     company_id = fields.Many2one('res.company', string='Company', required=True, default=lambda self: self.env.company)
+
+    @api.model
+    def _load_pos_data_domain(self, data):
+        return [('id', 'in', data['pos.config']['data'][0]['printer_ids'])]
+
+    @api.model
+    def _load_pos_data_fields(self, config_id):
+        return ['id', 'name', 'proxy_ip', 'product_categories_ids', 'printer_type']

--- a/addons/point_of_sale/models/pos_session.py
+++ b/addons/point_of_sale/models/pos_session.py
@@ -9,14 +9,14 @@ from odoo import api, fields, models, _, Command
 from odoo.exceptions import AccessError, UserError, ValidationError
 from odoo.tools import float_is_zero, float_compare, convert
 from odoo.service.common import exp_version
-from odoo.osv.expression import AND, OR
+from odoo.osv.expression import AND
 
 
 class PosSession(models.Model):
     _name = 'pos.session'
     _order = 'id desc'
     _description = 'Point of Sale Session'
-    _inherit = ['mail.thread', 'mail.activity.mixin', "pos.bus.mixin"]
+    _inherit = ['mail.thread', 'mail.activity.mixin', "pos.bus.mixin", 'pos.load.mixin']
 
     POS_SESSION_STATE = [
         ('opening_control', 'Opening Control'),  # method action_pos_session_open
@@ -99,344 +99,87 @@ class PosSession(models.Model):
 
     _sql_constraints = [('uniq_name', 'unique(name)', "The name of this POS Session must be unique!")]
 
-    # We need to pass config_id because sometime params are needed without opened session (eg: closed self order).
-    # If we don't have a session, we can't get the config_id from the session.
-    def _load_data_params(self, config_id):
+    @api.model
+    def _load_pos_data_relations(self, model, response):
+        model_fields = self.env[model].fields_get(allfields=response[model]['fields'] or None, attributes=['relation', 'type', 'relation_field'])
+        if not response[model].get('relations'):
+            response[model]['relations'] = {}
+        for name, params in model_fields.items():
+            if params.get("relation"):
+                response[model]['relations'][name] = {
+                    'name': name,
+                    'model': model,
+                    'relation': params['relation'],
+                    'type': params['type'],
+                }
+
+                if params['type'] == 'one2many' and params.get('relation_field'):
+                    response[model]['relations'][name]['inverse_name'] = params['relation_field']
+                if params['type'] == 'many2many':
+                    response[model]['relations'][name]['relation_table'] = self.env[model]._fields[name].relation
+            else:
+                response[model]['relations'][name] = {
+                    'name': name,
+                    'type': params['type'],
+                }
+
+    @api.model
+    def _load_pos_data_models(self, config_id):
+        return ['pos.config', 'pos.order', 'pos.order.line', 'pos.pack.operation.lot', 'pos.payment', 'pos.payment.method', 'pos.printer',
+            'pos.category', 'pos.bill', 'res.company', 'account.tax', 'product.product', 'product.attribute', 'product.attribute.custom.value',
+            'product.template.attribute.line', 'product.template.attribute.value', 'pos.combo', 'pos.combo.line', 'product.packaging', 'res.users', 'res.partner',
+            'decimal.precision', 'uom.uom', 'uom.category', 'res.country', 'res.country.state', 'res.lang', 'product.pricelist', 'product.pricelist.item', 'product.category',
+            'account.cash.rounding', 'account.fiscal.position', 'account.fiscal.position.tax', 'stock.picking.type', 'res.currency', 'pos.note', 'ir.ui.view']
+
+    @api.model
+    def _load_pos_data_domain(self, data):
+        return [('id', '=', self.id)]
+
+    @api.model
+    def _load_pos_data_fields(self, config_id):
+        return [
+            'id', 'name', 'user_id', 'config_id', 'start_at', 'stop_at', 'sequence_number', 'login_number',
+            'payment_method_ids', 'state', 'update_stock_at_closing', 'cash_register_balance_start', 'access_token'
+        ]
+
+    def _load_pos_data(self, data):
+        domain = self._load_pos_data_domain(data)
+        fields = self._load_pos_data_fields(self.config_id.id)
+        data = self.search_read(domain, fields, load=False, limit=1)
+        data[0]['_partner_commercial_fields'] = self.env['res.partner']._commercial_fields()
+        data[0]['_server_version'] = exp_version()
+        data[0]['_base_url'] = self.get_base_url()
+        data[0]['_has_cash_move_perm'] = self.env.user.has_group('account.group_account_invoice')
+        data[0]['_has_available_products'] = self._pos_has_valid_product()
+        data[0]['_pos_special_products_ids'] = self.env['pos.config']._get_special_products().ids
         return {
-            'pos.config': {
-                'domain': [('id', '=', config_id.id)],
-                'fields': []
-            },
-            'pos.order': {
-                'fields': [],
-                'domain': [('state', '=', 'draft'), ('session_id', '=', self.id)],
-            },
-            'pos.payment': {
-                'fields': [],
-                'domain': lambda data: [('pos_order_id', 'in', [order['id'] for order in data['pos.order']])],
-            },
-            'pos.order.line': {
-                'domain': lambda data: [('order_id', 'in', [order['id'] for order in data['pos.order']])],
-                'fields': [
-                    'qty', 'attribute_value_ids', 'custom_attribute_value_ids', 'price_unit', 'skip_change', 'uuid', 'price_subtotal', 'price_subtotal_incl', 'order_id', 'note',
-                    'product_id', 'discount', 'tax_ids', 'combo_line_id', 'pack_lot_ids', 'customer_note', 'refunded_qty', 'price_extra', 'full_product_name', 'refunded_orderline_id', 'combo_parent_id', 'combo_line_ids', 'combo_line_id'],
-            },
-            'pos.pack.operation.lot': {
-                'domain': lambda data: [('pos_order_line_id', 'in', [line['id'] for line in data['pos.order.line']])],
-                'fields': ['lot_name', 'pos_order_line_id'],
-            },
-            'pos.session': {
-                'domain': [('id', '=', self.id)],
-                'fields': [
-                    'id', 'name', 'user_id', 'config_id', 'start_at', 'stop_at', 'sequence_number', 'login_number',
-                    'payment_method_ids', 'state', 'update_stock_at_closing', 'cash_register_balance_start', 'access_token'
-                ],
-            },
-            'pos.payment.method': {
-                'domain': ['|', ('active', '=', False), ('active', '=', True)],
-                'fields': ['id', 'name', 'is_cash_count', 'use_payment_terminal', 'split_transactions', 'type', 'image', 'sequence', 'payment_method_type', 'default_qr'],
-                'context': {**self.env.context},
-            },
-            'pos.printer': {
-                'domain': [('id', 'in', config_id.printer_ids.ids)],
-                'fields': ['id', 'name', 'proxy_ip', 'product_categories_ids', 'printer_type'],
-            },
-            'pos.category': {
-                'domain': [('id', 'in', self.config_id._get_available_categories().ids)] if config_id.limit_categories and config_id.iface_available_categ_ids else [],
-                'fields': ['id', 'name', 'parent_id', 'child_ids', 'write_date', 'has_image', 'color', 'sequence']
-            },
-            'pos.bill': {
-                'domain': OR([
-                    [('id', 'in', config_id.default_bill_ids.ids), ('for_all_config', '=', False)],
-                    [('for_all_config', '=', True)]
-                ]),
-                'fields': ['id', 'name', 'value']
-            },
-            'account.tax': {
-                'domain': [('company_id', '=', config_id.company_id.id)],
-                'fields': [
-                    'id', 'name', 'price_include', 'include_base_amount', 'is_base_affected',
-                    'amount_type', 'children_tax_ids', 'amount', 'repartition_line_ids', 'id'
-                ],
-            },
-            'product.product': {
-                'domain': config_id._get_available_product_domain(),
-                'fields': [
-                    'id',
-                    'display_name', 'lst_price', 'standard_price', 'categ_id', 'pos_categ_ids', 'taxes_id', 'barcode',
-                    'default_code', 'to_weight', 'uom_id', 'description_sale', 'description', 'product_tmpl_id', 'tracking',
-                    'write_date', 'available_in_pos', 'attribute_line_ids', 'active', 'image_128', 'combo_ids',
-                ],
-                'order': 'sequence,default_code,name',
-                'limit': config_id.get_limited_product_count(),
-                'context': {**self.env.context, 'display_default_code': False},
-            },
-            'product.attribute': {
-                'domain': [('create_variant', '=', 'no_variant')],
-                'fields': ['name', 'display_type', 'template_value_ids', 'attribute_line_ids'],
-            },
-            'product.attribute.custom.value': {
-                'domain':  lambda data: [('pos_order_line_id', 'in', [line['id'] for line in data['pos.order.line']])],
-                'fields': ['custom_value', 'custom_product_template_attribute_value_id', 'pos_order_line_id'],
-            },
-            'product.template.attribute.line': {
-                'domain': [],
-                'fields': ['display_name', 'attribute_id', 'product_template_value_ids'],
-            },
-            'product.template.attribute.value': {
-                'domain': lambda data: [('attribute_id', 'in', [attr['id'] for attr in data['product.attribute']])],
-                'fields': ['attribute_id', 'attribute_line_id', 'product_attribute_value_id', 'price_extra', 'name', 'is_custom', 'html_color', 'image']
-            },
-            'pos.combo': {
-                'domain': lambda data: [('id', 'in', list(set().union(*[product.get('combo_ids') for product in data['product.product']])))],
-                'fields': ['id', 'name', 'combo_line_ids', 'base_price']
-            },
-            'pos.combo.line': {
-                'domain': lambda data: [('id', 'in', list(set().union(*[combo.get('combo_line_ids') for combo in data['pos.combo']])))],
-                'fields': ['id', 'product_id', 'combo_price', 'combo_id']
-            },
-            'product.packaging': {
-                'domain': lambda data: AND([[('barcode', 'not in', ['', False])], [('product_id', 'in', [x['id'] for x in data['product.product']])] if data else []]),
-                'fields': ['id', 'name', 'barcode', 'product_id', 'qty'],
-            },
-            'res.users': {
-                'domain': [('id', '=', self.env.user.id)],
-                'fields': ['id', 'name', 'groups_id', 'partner_id'],
-            },
-            'res.partner': {
-                'domain': [('id', 'in', config_id.get_limited_partners_loading() + [self.env.user.partner_id.id])],
-                'fields': [
-                    'id',
-                    'name', 'street', 'city', 'state_id', 'country_id', 'vat', 'lang', 'phone', 'zip', 'mobile', 'email',
-                    'barcode', 'write_date', 'property_account_position_id', 'property_product_pricelist', 'parent_name'
-                ]
-            },
-            'res.company': {
-                'domain': [('id', '=', config_id.company_id.id)],
-                'fields': [
-                    'id',
-                    'currency_id', 'email', 'website', 'company_registry', 'vat', 'name', 'phone', 'partner_id',
-                    'country_id', 'state_id', 'tax_calculation_rounding_method', 'nomenclature_id', 'point_of_sale_use_ticket_qr_code',
-                    'point_of_sale_ticket_unique_code', 'street', 'city', 'zip',
-                ],
-            },
-            'decimal.precision': {
-                'domain': [],
-                'fields': ['id', 'name', 'digits'],
-            },
-            'uom.uom': {
-                'domain': [],
-                'fields': ['id', 'name', 'category_id', 'factor_inv', 'factor', 'is_pos_groupable', 'uom_type', 'rounding'],
-                'context': {**self.env.context},
-            },
-            'uom.category': {
-                'domain': lambda data: [('uom_ids', 'in', [uom['category_id'] for uom in data['uom.uom']])],
-                'fields': ['id', 'name', 'uom_ids'],
-            },
-            'res.country.state': {
-                'domain': [],
-                'fields': ['id', 'name', 'code', 'country_id'],
-            },
-            'res.country': {
-                'domain': [],
-                'fields': ['id', 'name', 'code', 'vat_label'],
-            },
-            'res.lang': {
-                'domain': [],
-                'fields': ['id', 'name', 'code'],
-            },
-            'product.pricelist' : {
-                'domain': [('id', 'in', config_id.available_pricelist_ids.ids)] if config_id.use_pricelist else [('id', '=', config_id.pricelist_id.id)],
-                'fields': ['id', 'name', 'display_name', 'discount_policy', 'item_ids']
-            },
-            'product.pricelist.item' : {
-                'domain': [('pricelist_id', 'in', config_id.available_pricelist_ids.ids)] if config_id.use_pricelist else [('pricelist_id', '=', config_id.pricelist_id.id)],
-                'fields': ['product_tmpl_id', 'product_id', 'pricelist_id', 'price_surcharge', 'price_discount', 'price_round',
-                    'price_min_margin', 'price_max_margin', 'company_id', 'currency_id', 'date_start', 'date_end', 'compute_price',
-                    'fixed_price', 'percent_price', 'base_pricelist_id', 'base', 'categ_id', 'min_quantity']
-            },
-            'product.category': {
-                'domain': [],
-                'fields': ['id', 'name', 'parent_id'],
-            },
-            'account.cash.rounding': {
-                'domain': [('id', '=', config_id.rounding_method.id)],
-                'fields': ['id', 'name', 'rounding', 'rounding_method'],
-            },
-            'account.fiscal.position': {
-                'domain': [('id', 'in', config_id.fiscal_position_ids.ids)],
-                'fields': ['id', 'name', 'display_name'],
-            },
-            'account.fiscal.position.tax': {
-                'domain': lambda data: [('position_id', 'in', [fpos['id'] for fpos in data['account.fiscal.position']])],
-                'fields': [],
-            },
-            'stock.picking.type': {
-                'domain': [('id', '=', config_id.picking_type_id.id)],
-                'fields': ['id', 'use_create_lots', 'use_existing_lots'],
-            },
-            'res.currency': {
-                'domain': [('id', '=', config_id.currency_id.id)],
-                'fields': ['id', 'name', 'iso_numeric', 'symbol', 'position', 'rounding', 'rate', 'decimal_places'],
-            },
-            'pos.note': {
-                'domain': [('id', '=', config_id.note_ids.ids)] if config_id.note_ids else [],
-                'fields': ['name'],
-            },
+            'data': data,
+            'fields': fields
         }
 
     def load_data(self, models_to_load, only_data=False):
-        params = self._load_data_params(self.config_id)
         response = {}
-        response['data'] = {}
-        response['relations'] = {}
-        response['custom'] = {}
-        response['errors'] = {}
-
-        if not only_data:
-            response['custom'] = {
-                'partner_commercial_fields': self.env['res.partner']._commercial_fields(),
-                'server_version': exp_version(),
-                'base_url': self.get_base_url(),
-                'has_cash_move_perm': self.env.user.has_group('account.group_account_invoice'),
-                'has_available_products': self._pos_has_valid_product(),
-                'pos_special_products_ids': self.env['pos.config']._get_special_products().ids,
-            }
-
-        if len(models_to_load) > 0:
-            response['fields'] = {name: params[name]['fields'] for name in models_to_load}
-        else:
-            response['fields'] = {name: data['fields'] for name, data in params.items()}
+        response['pos.session'] = self._load_pos_data(response)
+        self._load_pos_data_relations('pos.session', response)
 
-        # Load data from search_read
-        if len(params) > 0:
-            for key, value in params.items():
+        for model in self._load_pos_data_models(self.config_id.id):
+            if models_to_load and model not in models_to_load:
+                continue
 
-                if key not in models_to_load and len(models_to_load) > 0:
-                    continue
+            try:
+                response[model] = self.env[model]._load_pos_data(response)
+            except AccessError as e:
+                response[model] = {
+                    'data': [],
+                    'fields': self.env[model]._load_pos_data_fields(response['pos.config']['data'][0]['id']),
+                    'error': e.args[0]
+                }
 
-                try:
-                    response['data'][key] = [] if value.get('load_manually') else self.env[key].with_context(value.get('context', [])).search_read(
-                        value['domain'] if isinstance(value['domain'], list) else value['domain'](response['data']),
-                        value['fields'],
-                        order=value.get('order', []),
-                        limit=value.get('limit', None),
-                        load=False)
-                except AccessError as e:
-                    response['errors'][key] = e.args[0]
-                    response['data'][key] = []
-
-                if not only_data:
-                    model_fields = self.env[key].fields_get(allfields=value['fields'] or None)
-                    for name, field in model_fields.items():
-                        if not response['relations'].get(key):
-                            response['relations'][key] = {}
-
-                        if field.get("relation"):
-
-                            response['relations'][key][name] = {
-                                'name': name,
-                                'model': key,
-                                'relation': field['relation'],
-                                'type': field['type'],
-                            }
-                            if field['type'] == 'one2many' and field.get('relation_field'):
-                                response['relations'][key][name]['inverse_name'] = field['relation_field']
-                            if field['type'] == 'many2many':
-                                response['relations'][key][name]['relation_table'] = self.env[key]._fields[name].relation
-                        else:
-                            response['relations'][key][name] = {
-                                'name': name,
-                                'type': field['type'],
-                            }
-
-        # pos_config adaptation
-        if len(models_to_load) == 0 or 'pos.config' in models_to_load:
-            config = response['data']['pos.config'][0]
-
-            if not self.config_id.use_pricelist:
-                response['data']['pos.config'][0]['pricelist_id'] = False
-
-        # res_users adaptation
-        if len(models_to_load) == 0 or 'res.users' in models_to_load:
-            response['data']['res.users'][0]['role'] = 'manager' if any(id == self.config_id.group_pos_manager_id.id for id in response['data']['res.users'][0]['groups_id']) else 'cashier'
-            del response['data']['res.users'][0]['groups_id']
-
-        # product_product adapation
-        if len(models_to_load) == 0 or 'product.product' in models_to_load:
-            self._process_pos_ui_product_product(response['data']['product.product'])
-
-        # account_tax adaptation
-        if len(models_to_load) == 0 or 'account.tax' in models_to_load:
-            self._process_pos_ui_account_tax(
-                response['data']['account.tax'],
-                response['fields']['account.tax'],
-                response['relations']['account.tax']
-            )
-            AccountTax = self.env['account.tax']
-            product_fields = AccountTax._eval_taxes_computation_prepare_product_fields(
-                response['data']['account.tax'],
-            )
+            if not only_data:
+                self._load_pos_data_relations(model, response)
 
-            company_data = next(x for x in response['data']['res.company'] if x['id'] == self.config_id.company_id.id)
-            fake_field = {
-                'name': '_product_default_values',
-                'type': 'string',
-            }
-            company_data[fake_field['name']] = AccountTax._eval_taxes_computation_prepare_product_default_values(
-                product_fields,
-            )
-            response['fields']['res.company'].append(fake_field['name'])
-            response['relations']['res.company'][fake_field['name']] = fake_field
-
-            session_product_fields = set(response['fields']['product.product'])
-            session_product_fields.update(product_fields)
-            response['fields']['product.product'] = list(session_product_fields)
-
-        # account_fiscal_position adaptation
-        if len(models_to_load) == 0 or 'account.fiscal.position' in models_to_load:
-            self._process_pos_ui_account_fiscal_position(
-                response['data']['account.fiscal.position'],
-                response['fields']['account.fiscal.position'],
-                response['relations']['account.fiscal.position']
-            )
         return response
 
-    def _process_pos_ui_account_tax(self, account_tax, account_fields, account_relations):
-        tax_ids = self.env['account.tax'].browse([tax['id'] for tax in account_tax])
-
-        for tax in account_tax:
-            record = tax_ids.filtered(lambda t: t.id == tax['id'])
-            tax_dict = record._prepare_dict_for_taxes_computation()
-
-            for key, value in tax_dict.items():
-                if key not in account_fields:
-                    account_fields.append(key)
-                    account_relations[key] = {
-                        'name': key,
-                        'type': 'string',
-                    }
-                if key not in tax:
-                    tax[key] = value
-
-    def _process_pos_ui_account_fiscal_position(self, account_fiscal_position, account_fields, account_relations):
-        fiscal_position_ids = self.env['account.fiscal.position'].browse([f['id'] for f in account_fiscal_position])
-
-        account_fields.append('tax_mapping_by_ids')
-        account_relations['tax_mapping_by_ids'] = {
-            'name': 'tax_mapping_by_ids',
-            'type': 'selection',
-        }
-
-        for fiscal_position in account_fiscal_position:
-            record = fiscal_position_ids.filtered(lambda f: f.id == fiscal_position['id'])
-            fiscal_position['tax_mapping_by_ids'] = {}
-
-            for fiscal_position_tax in record.tax_ids:
-                if not fiscal_position['tax_mapping_by_ids'].get(fiscal_position_tax.tax_src_id.id):
-                    fiscal_position['tax_mapping_by_ids'][fiscal_position_tax.tax_src_id.id] = []
-                fiscal_position['tax_mapping_by_ids'][fiscal_position_tax.tax_src_id.id].append(fiscal_position_tax.tax_dest_id.id)
-
     def _prepare_pricelist_domain(self, data):
         product_tmpl_ids = [p['product_tmpl_id'] for p in data['product.product']]
         product_ids = [p['id'] for p in data['product.product']]
@@ -1976,31 +1719,16 @@ class PosSession(models.Model):
     def _get_partners_domain(self):
         return []
 
-    def _process_pos_ui_product_product(self, products):
-        if self.config_id.currency_id != self.company_id.currency_id:
-            for product in products:
-                product['lst_price'] = self.company_id.currency_id._convert(product['lst_price'], self.config_id.currency_id, self.company_id, fields.Date.today())
-                product['image_128'] = bool(product['image_128'])
-
-    def get_pos_ui_res_partner_by_params(self, custom_search_params):
-        """
-        :param custom_search_params: a dictionary containing params of a search_read()
-        """
-        params = self._load_data_params(self.config_id)['res.partner']
-        # custom_search_params will take priority
-        params = {**params, **custom_search_params}
-        partners = self.env['res.partner'].search_read(**params)
-        return partners
-
-    def find_product_by_barcode(self, barcode):
-        load_data_params = self._load_data_params(self.config_id)
+    def find_product_by_barcode(self, barcode, config_id):
+        product_fields = self.env['product.product']._load_pos_data_fields(config_id)
+        product_packaging_fields = self.env['product.packaging']._load_pos_data_fields(config_id)
         product = self.env['product.product'].search([
             ('barcode', '=', barcode),
             ('sale_ok', '=', True),
             ('available_in_pos', '=', True),
         ])
         if product:
-            return {'product.product': product.read(load_data_params['product.product']['fields'], load=False)}
+            return {'product.product': product.read(product_fields, load=False)}
 
         domain = [('barcode', 'not in', ['', False])]
         loaded_data = self._context.get('loaded_data')
@@ -2017,16 +1745,13 @@ class PosSession(models.Model):
         packaging_params['search_params']['domain'] = [['barcode', '=', barcode]]
         packaging = self.env['product.packaging'].search(packaging_params['search_params']['domain'])
 
-        if packaging:
-            if packaging.product_id:
-                product_fields = load_data_params['product.product']['fields']
-                packaging_fields = load_data_params['product.packaging']['fields']
-
-                return {'product.product': packaging.product_id.read(product_fields, load=False), 'product.packaging': packaging.read(packaging_fields, load=False)}
-        return {
-            'product.product': [],
-            'product.packaging': [],
-        }
+        if packaging and packaging.product_id:
+            return {'product.product': packaging.product_id.read(product_fields, load=False), 'product.packaging': packaging.read(product_packaging_fields, load=False)}
+        else:
+            return {
+                'product.product': [],
+                'product.packaging': [],
+            }
 
     def get_total_discount(self):
         amount = 0
@@ -2100,24 +1825,6 @@ class PosSession(models.Model):
     def _get_closed_orders(self):
         return self.order_ids.filtered(lambda o: o.state not in ['draft', 'cancel'])
 
-    def get_pos_ui_product_pricelist_item_by_product(self, product_tmpl_ids, product_ids):
-        params = self._load_data_params(self.config_id)
-        pricelist_params = params['product.pricelist']
-        pricelist_item_params = params['product.pricelist.item']
-
-        pricelist_item_domain = [
-            '|',
-            '&', ('product_id', '=', False), ('product_tmpl_id', 'in', product_tmpl_ids),
-            ('product_id', 'in', product_ids)]
-
-        pricelist_item = self.env['product.pricelist.item'].search(pricelist_item_domain)
-        pricelist = pricelist_item.pricelist_id
-
-        return {
-            'product.pricelist.item': pricelist_item.read(pricelist_item_params['fields'], load=False),
-            'product.pricelist': pricelist.read(pricelist_params['fields'], load=False)
-        }
-
 class ProcurementGroup(models.Model):
     _inherit = 'procurement.group'
 

--- a/addons/point_of_sale/models/product.py
+++ b/addons/point_of_sale/models/product.py
@@ -5,6 +5,7 @@ from odoo.exceptions import UserError
 from itertools import groupby
 from operator import itemgetter
 from datetime import date
+from odoo.osv.expression import AND
 
 
 class ProductTemplate(models.Model):
@@ -70,7 +71,44 @@ class ProductTemplate(models.Model):
 
 
 class ProductProduct(models.Model):
-    _inherit = 'product.product'
+    _name = 'product.product'
+    _inherit = ['product.product', 'pos.load.mixin']
+
+    @api.model
+    def _load_pos_data_domain(self, data):
+        config_id = self.env['pos.config'].browse(data['pos.config']['data'][0]['id'])
+        return config_id._get_available_product_domain()
+
+    @api.model
+    def _load_pos_data_fields(self, config_id):
+        return [
+            'id', 'display_name', 'lst_price', 'standard_price', 'categ_id', 'pos_categ_ids', 'taxes_id', 'barcode',
+            'default_code', 'to_weight', 'uom_id', 'description_sale', 'description', 'product_tmpl_id', 'tracking',
+            'write_date', 'available_in_pos', 'attribute_line_ids', 'active', 'image_128', 'combo_ids',
+        ]
+
+    def _load_pos_data(self, data):
+        domain = self._load_pos_data_domain(data)
+        fields = self._load_pos_data_fields(data['pos.config']['data'][0]['id'])
+        config_id = self.env['pos.config'].browse(data['pos.config']['data'][0]['id'])
+        products = self.with_context({**self.env.context, 'display_default_code': False}).search_read(
+            domain,
+            fields,
+            limit=config_id.get_limited_product_count(),
+            order='sequence,default_code,name',
+            load=False)
+
+        self._process_pos_ui_product_product(products, config_id)
+        return {
+            'data': products,
+            'fields': fields,
+        }
+
+    def _process_pos_ui_product_product(self, products, config_id):
+        for product in products:
+            product['image_128'] = bool(product['image_128'])
+            if config_id.currency_id != self.env.company.currency_id:
+                product['lst_price'] = self.env.company.currency_id._convert(product['lst_price'], config_id.currency_id, self.env.company, fields.Date.today())
 
     @api.ondelete(at_uninstall=False)
     def _unlink_except_active_pos_session(self):
@@ -145,19 +183,139 @@ class ProductProduct(models.Model):
             'variants': variant_list
         }
 
+
+class ProductAttribute(models.Model):
+    _name = 'product.attribute'
+    _inherit = ['product.attribute', 'pos.load.mixin']
+
+    @api.model
+    def _load_pos_data_domain(self, data):
+        return [('create_variant', '=', 'no_variant')]
+
+    @api.model
+    def _load_pos_data_fields(self, config_id):
+        return ['name', 'display_type', 'template_value_ids', 'attribute_line_ids']
+
+
 class ProductAttributeCustomValue(models.Model):
-    _inherit = "product.attribute.custom.value"
+    _name = 'product.attribute.custom.value'
+    _inherit = ["product.attribute.custom.value", "pos.load.mixin"]
 
     pos_order_line_id = fields.Many2one('pos.order.line', string="PoS Order Line", ondelete='cascade')
 
+    @api.model
+    def _load_pos_data_domain(self, data):
+        return [('pos_order_line_id', 'in', [line['id'] for line in data['pos.order.line']['data']])]
+
+    @api.model
+    def _load_pos_data_fields(self, config_id):
+        return ['custom_value', 'custom_product_template_attribute_value_id', 'pos_order_line_id']
+
+
+class ProductTemplateAttributeLine(models.Model):
+    _name = 'product.template.attribute.line'
+    _inherit = ['product.template.attribute.line', 'pos.load.mixin']
+
+    @api.model
+    def _load_pos_data_fields(self, config_id):
+        return ['display_name', 'attribute_id', 'product_template_value_ids']
+
+
+class ProductTemplateAttributeValue(models.Model):
+    _name = 'product.template.attribute.value'
+    _inherit = ['product.template.attribute.value', 'pos.load.mixin']
+
+    @api.model
+    def _load_pos_data_domain(self, data):
+        return [('attribute_id', 'in', [attr['id'] for attr in data['product.attribute']['data']])]
+
+    @api.model
+    def _load_pos_data_fields(self, config_id):
+        return ['attribute_id', 'attribute_line_id', 'product_attribute_value_id', 'price_extra', 'name', 'is_custom', 'html_color', 'image']
+
+
+class ProductPackaging(models.Model):
+    _name = 'product.packaging'
+    _inherit = ['product.packaging', 'pos.load.mixin']
+
+    @api.model
+    def _load_pos_data_domain(self, data):
+        return AND([[('barcode', 'not in', ['', False])], [('product_id', 'in', [x['id'] for x in data['product.product']['data']])] if data else []])
+
+    @api.model
+    def _load_pos_data_fields(self, config_id):
+        return ['id', 'name', 'barcode', 'product_id', 'qty']
+
+
 class UomCateg(models.Model):
-    _inherit = 'uom.category'
+    _name = 'uom.category'
+    _inherit = ['uom.category', 'pos.load.mixin']
 
     is_pos_groupable = fields.Boolean(string='Group Products in POS',
         help="Check if you want to group products of this category in point of sale orders")
 
+    @api.model
+    def _load_pos_data_domain(self, data):
+        return [('uom_ids', 'in', [uom['category_id'] for uom in data['uom.uom']['data']])]
+
+    @api.model
+    def _load_pos_data_fields(self, config_id):
+        return ['id', 'name', 'uom_ids']
+
 
 class Uom(models.Model):
-    _inherit = 'uom.uom'
+    _name = 'uom.uom'
+    _inherit = ['uom.uom', 'pos.load.mixin']
 
     is_pos_groupable = fields.Boolean(related='category_id.is_pos_groupable', readonly=False)
+
+    @api.model
+    def _load_pos_data_fields(self, config_id):
+        return ['id', 'name', 'category_id', 'factor_inv', 'factor', 'is_pos_groupable', 'uom_type', 'rounding']
+
+    def _load_pos_data(self, data):
+        domain = self._load_pos_data_domain(data)
+        fields = self._load_pos_data_fields(data['pos.config']['data'][0]['id'])
+        return {
+            'data': self.with_context({**self.env.context}).search_read(domain, fields, load=False),
+            'fields': fields,
+        }
+
+
+class ProductPricelist(models.Model):
+    _name = 'product.pricelist'
+    _inherit = ['product.pricelist', 'pos.load.mixin']
+
+    @api.model
+    def _load_pos_data_domain(self, data):
+        config_id = self.env['pos.config'].browse(data['pos.config']['data'][0]['id'])
+        return [('id', 'in', config_id.available_pricelist_ids.ids)] if config_id.use_pricelist else [('id', '=', config_id.pricelist_id.id)]
+
+    @api.model
+    def _load_pos_data_fields(self, config_id):
+        return ['id', 'name', 'display_name', 'discount_policy', 'item_ids']
+
+
+class ProductPricelistItem(models.Model):
+    _name = 'product.pricelist.item'
+    _inherit = ['product.pricelist.item', 'pos.load.mixin']
+
+    @api.model
+    def _load_pos_data_domain(self, data):
+        config_id = self.env['pos.config'].browse(data['pos.config']['data'][0]['id'])
+        return [('pricelist_id', 'in', config_id.available_pricelist_ids.ids)] if config_id.use_pricelist else [('pricelist_id', '=', config_id.pricelist_id.id)]
+
+    @api.model
+    def _load_pos_data_fields(self, config_id):
+        return ['product_tmpl_id', 'product_id', 'pricelist_id', 'price_surcharge', 'price_discount', 'price_round',
+                'price_min_margin', 'price_max_margin', 'company_id', 'currency_id', 'date_start', 'date_end', 'compute_price',
+                'fixed_price', 'percent_price', 'base_pricelist_id', 'base', 'categ_id', 'min_quantity']
+
+
+class ProductCategory(models.Model):
+    _name = 'product.category'
+    _inherit = ['product.category', 'pos.load.mixin']
+
+    @api.model
+    def _load_pos_data_fields(self, config_id):
+        return ['id', 'name', 'parent_id']

--- a/addons/point_of_sale/models/res_company.py
+++ b/addons/point_of_sale/models/res_company.py
@@ -4,7 +4,8 @@ from odoo import api, models, fields, _
 from odoo.exceptions import ValidationError
 
 class ResCompany(models.Model):
-    _inherit = 'res.company'
+    _name = 'res.company'
+    _inherit = ['res.company', 'pos.load.mixin']
 
     point_of_sale_update_stock_quantities = fields.Selection([
             ('closing', 'At the session closing (faster)'),
@@ -18,6 +19,18 @@ class ResCompany(models.Model):
         string='Generate a code on ticket',
         help="Add a 5-digit code on the receipt to allow the user to request the invoice for an order on the portal.")
 
+    @api.model
+    def _load_pos_data_domain(self, data):
+        return [('id', '=', data['pos.config']['data'][0]['company_id'])]
+
+    @api.model
+    def _load_pos_data_fields(self, config_id):
+        return [
+            'id', 'currency_id', 'email', 'website', 'company_registry', 'vat', 'name', 'phone', 'partner_id',
+            'country_id', 'state_id', 'tax_calculation_rounding_method', 'nomenclature_id', 'point_of_sale_use_ticket_qr_code',
+            'point_of_sale_ticket_unique_code', 'street', 'city', 'zip',
+        ]
+
     @api.constrains('period_lock_date', 'fiscalyear_lock_date')
     def validate_period_lock_date(self):
         """ This constrains makes it impossible to change the period lock date if

--- a/None
+++ b/addons/point_of_sale/models/res_country.py
@@ -0,0 +1,10 @@
+from odoo import models, api
+
+
+class ResCountry(models.Model):
+    _name = 'res.country'
+    _inherit = ['res.country', 'pos.load.mixin']
+
+    @api.model
+    def _load_pos_data_fields(self, config_id):
+        return ['id', 'name', 'code', 'vat_label']

--- a/None
+++ b/addons/point_of_sale/models/res_country_state.py
@@ -0,0 +1,10 @@
+from odoo import models, api
+
+
+class ResCountryState(models.Model):
+    _name = 'res.country.state'
+    _inherit = ['res.country.state', 'pos.load.mixin']
+
+    @api.model
+    def _load_pos_data_fields(self, config_id):
+        return ['id', 'name', 'code', 'country_id']

--- a/None
+++ b/addons/point_of_sale/models/res_currency.py
@@ -0,0 +1,14 @@
+from odoo import models, api
+
+
+class ResCurrency(models.Model):
+    _name = 'res.currency'
+    _inherit = ['res.currency', 'pos.load.mixin']
+
+    @api.model
+    def _load_pos_data_domain(self, data):
+        return [('id', '=', data['pos.config']['data'][0]['currency_id'])]
+
+    @api.model
+    def _load_pos_data_fields(self, config_id):
+        return ['id', 'name', 'symbol', 'position', 'rounding', 'rate', 'decimal_places', 'iso_numeric']

--- a/None
+++ b/addons/point_of_sale/models/res_lang.py
@@ -0,0 +1,10 @@
+from odoo import models, api
+
+
+class ResLang(models.Model):
+    _name = 'res.lang'
+    _inherit = ['res.lang', 'pos.load.mixin']
+
+    @api.model
+    def _load_pos_data_fields(self, config_id):
+        return ['id', 'name', 'code']

--- a/addons/point_of_sale/models/res_partner.py
+++ b/addons/point_of_sale/models/res_partner.py
@@ -1,11 +1,10 @@
-# -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
-from odoo import api, fields, models, _
-from odoo.exceptions import UserError
+from odoo import api, fields, models
 
 
 class ResPartner(models.Model):
-    _inherit = 'res.partner'
+    _name = 'res.partner'
+    _inherit = ['res.partner', 'pos.load.mixin']
 
     pos_order_count = fields.Integer(
         compute='_compute_pos_order',
@@ -14,6 +13,18 @@ class ResPartner(models.Model):
     )
     pos_order_ids = fields.One2many('pos.order', 'partner_id', readonly=True)
 
+    @api.model
+    def _load_pos_data_domain(self, data):
+        config_id = self.env['pos.config'].browse(data['pos.config']['data'][0]['id'])
+        return [('id', 'in', config_id.get_limited_partners_loading() + [self.env.user.partner_id.id])]
+
+    @api.model
+    def _load_pos_data_fields(self, config_id):
+        return [
+            'id', 'name', 'street', 'city', 'state_id', 'country_id', 'vat', 'lang', 'phone', 'zip', 'mobile', 'email',
+            'barcode', 'write_date', 'property_account_position_id', 'property_product_pricelist', 'parent_name'
+        ]
+
     def _compute_pos_order(self):
         # retrieve all children partners and prefetch 'parent_id' on them
         all_partners = self.with_context(active_test=False).search_fetch(

--- a/None
+++ b/addons/point_of_sale/models/res_users.py
@@ -0,0 +1,24 @@
+from odoo import models, api
+
+
+class ResUsers(models.Model):
+    _inherit = 'res.users'
+
+    @api.model
+    def _load_pos_data_domain(self, data):
+        return [('id', '=', self.env.uid)]
+
+    @api.model
+    def _load_pos_data_fields(self, config_id):
+        return ['id', 'name', 'partner_id', 'groups_id']
+
+    def _load_pos_data(self, data):
+        domain = self._load_pos_data_domain(data)
+        fields = self._load_pos_data_fields(data['pos.config']['data'][0]['id'])
+        user = self.search_read(domain, fields, load=False)
+        user[0]['role'] = 'manager' if data['pos.config']['data'][0]['group_pos_manager_id'] in user[0]['groups_id'] else 'cashier'
+        del user[0]['groups_id']
+        return {
+            'data': user,
+            'fields': fields,
+        }

--- a/addons/point_of_sale/models/stock_picking.py
+++ b/addons/point_of_sale/models/stock_picking.py
@@ -157,7 +157,8 @@ class StockPicking(models.Model):
         return res
 
 class StockPickingType(models.Model):
-    _inherit = 'stock.picking.type'
+    _name = 'stock.picking.type'
+    _inherit = ['stock.picking.type', 'pos.load.mixin']
 
     @api.depends('warehouse_id')
     def _compute_hide_reservation_method(self):
@@ -173,6 +174,14 @@ class StockPickingType(models.Model):
             if pos_config:
                 raise ValidationError(_("You cannot archive '%s' as it is used by a POS configuration '%s'.", picking_type.name, pos_config.name))
 
+    @api.model
+    def _load_pos_data_domain(self, data):
+        return [('id', '=', data['pos.config']['data'][0]['picking_type_id'])]
+
+    @api.model
+    def _load_pos_data_fields(self, config_id):
+        return ['id', 'use_create_lots', 'use_existing_lots']
+
 class ProcurementGroup(models.Model):
     _inherit = 'procurement.group'
 
