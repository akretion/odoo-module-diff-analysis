PR: https://github.com/odoo/odoo/pull/

From: 61a02a7330bfa654d5a913ee8750e59a796605b1
From: Arnaud Joset
Date: 2021-03-30 07:25:51

Structural Changes: 9
Total Changes: 534

[REF] payment_ogone: migrate Ogone to the new payment API

In this commit, we take the opportunity to replace the previous unsecure
API with the new FlexCheckout API that implements payment methods
validation in a hosted page. Payment processing is still done with the
DirectLink API.

This commit also renames the module `payment_ingenico` to
`payment_ogone` as well as the referring strings ("Ogone" instead
of "Ingenico", ...).
A dedicated [MOV] commit is not used because neither the [MOV] commit
nor the adapted [REF] would be valid on its own.

See the merge commit for more details.

task-2333029
task-2313907
task-2334015

Co-authored-by: Antoine Vandevenne <anv@odoo.com>

================================= pseudo patch: =================================

--- a/None
+++ b/addons/payment_ogone/models/__init__.py
@@ -0,0 +1,5 @@
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from . import payment_acquirer
+from . import payment_token
+from . import payment_transaction

--- a/None
+++ b/addons/payment_ogone/models/const.py
@@ -0,0 +1,97 @@
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+# See https://epayments-support.ingenico.com/en/integration/all-sales-channels/flexcheckout/guide#flexcheckout_integration_guides_sha_out
+FLEXCHECKOUT_KEYS = [
+    'ALIAS.ALIASID',
+    'ALIAS.NCERROR',
+    'ALIAS.NCERRORCARDNO',
+    'ALIAS.NCERRORCN',
+    'ALIAS.NCERRORCVC',
+    'ALIAS.NCERRORED',
+    'ALIAS.ORDERID',
+    'ALIAS.STATUS',
+    'ALIAS.STOREPERMANENTLY',
+    'CARD.BIC',
+    'CARD.BIN',
+    'CARD.BRAND',
+    'CARD.CARDHOLDERNAME',
+    'CARD.CARDNUMBER',
+    'CARD.CVC',
+    'CARD.EXPIRYDATE'
+]
+# See https://epayments-support.ingenico.com/en/integration-solutions/integrations/directlink#directlink_integration_guides_request_a_new_order
+# See https://epayments-support.ingenico.com/en/integration-solutions/integrations/directlink#directlink_integration_guides_order_response
+DIRECTLINK_KEYS = [
+    'AAVADDRESS',
+    'AAVCHECK',
+    'AAVMAIL',
+    'AAVNAME',
+    'AAVPHONE',
+    'AAVZIP',
+    'ACCEPTANCE',
+    'ALIAS',
+    'AMOUNT',
+    'BIC',
+    'BIN',
+    'BRAND',
+    'CARDNO',
+    'CCCTY',
+    'CN',
+    'COLLECTOR_BIC',
+    'COLLECTOR_IBAN',
+    'COMPLUS',
+    'CREATION_STATUS',
+    'CREDITDEBIT',
+    'CURRENCY',
+    'CVCCHECK',
+    'DCC_COMMPERCENTAGE',
+    'DCC_CONVAMOUNT',
+    'DCC_CONVCCY',
+    'DCC_EXCHRATE',
+    'DCC_EXCHRATESOURCE',
+    'DCC_EXCHRATETS',
+    'DCC_INDICATOR',
+    'DCC_MARGINPERCENTAGE',
+    'DCC_VALIDHOURS',
+    'DEVICEID',
+    'DIGESTCARDNO',
+    'ECI',
+    'ED',
+    'EMAIL',
+    'ENCCARDNO',
+    'FXAMOUNT',
+    'FXCURRENCY',
+    'IP',
+    'IPCTY',
+    'MANDATEID',
+    'MOBILEMODE',
+    'NBREMAILUSAGE',
+    'NBRIPUSAGE',
+    'NBRIPUSAGE_ALLTX',
+    'NBRUSAGE',
+    'NCERROR',
+    'ORDERID',
+    'PAYID',
+    'PAYIDSUB',
+    'PAYMENT_REFERENCE',
+    'PM',
+    'SCO_CATEGORY',
+    'SCORING',
+    'SEQUENCETYPE',
+    'SIGNDATE',
+    'STATUS',
+    'SUBBRAND',
+    'SUBSCRIPTION_ID',
+    'TICKET',
+    'TRXDATE',
+    'VC',
+]
+VALID_KEYS = DIRECTLINK_KEYS + FLEXCHECKOUT_KEYS
+
+
+# See https://epayments-support.ingenico.com/en/get-started/transaction-status-full/
+PAYMENT_STATUS_MAPPING = {
+    'pending': (41, 46, 50, 51, 52, 55, 56, 81, 82, 91, 92, 99),  # 46 = 3DS
+    'done': (5, 8, 9),
+    'cancel': (1,),
+}

--- a/None
+++ b/addons/payment_ogone/models/payment_acquirer.py
@@ -0,0 +1,122 @@
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+import logging
+from hashlib import sha256
+
+import requests
+
+from odoo import _, fields, models
+from odoo.exceptions import ValidationError
+
+from .const import VALID_KEYS
+
+_logger = logging.getLogger(__name__)
+
+
+class PaymentAcquirer(models.Model):
+    _inherit = 'payment.acquirer'
+
+    provider = fields.Selection(
+        selection_add=[('ogone', "Ogone")], ondelete={'ogone': 'set default'})
+    ogone_pspid = fields.Char(
+        string="PSPID", help="The ID solely used to identify the account with Ogone",
+        required_if_provider='ogone')
+    ogone_userid = fields.Char(
+        string="API User ID", help="The ID solely used to identify the API user with Ogone",
+        required_if_provider='ogone')
+    ogone_password = fields.Char(
+        string="API User Password", required_if_provider='ogone', groups='base.group_system')
+    ogone_shakey_in = fields.Char(
+        string="SHA Key IN", size=32, required_if_provider='ogone', groups='base.group_system')
+    ogone_shakey_out = fields.Char(
+        string="SHA Key OUT", size=32, required_if_provider='ogone', groups='base.group_system')
+
+    def _get_validation_amount(self):
+        """ Override of payment to return the amount for Ogone validation operations.
+
+        :return: The validation amount
+        :rtype: float
+        """
+        res = super()._get_validation_amount()
+        if self.provider != 'ogone':
+            return res
+
+        return 1.0
+
+    def _ogone_get_api_url(self, api_key):
+        """ Return the appropriate URL of the requested API for the acquirer state.
+
+        Note: self.ensure_one()
+
+        :param str api_key: The API whose URL to get: 'flexcheckout' or 'directlink'
+        :return: The API URL
+        :rtype: str
+        """
+        self.ensure_one()
+
+        if self.state == 'enabled':
+            api_urls = {
+                'flexcheckout': 'https://secure.ogone.com/Tokenization/HostedPage',
+                'directlink': 'https://secure.ogone.com/ncol/prod/orderdirect.asp',
+                'maintenancedirect': 'https://secure.ogone.com/ncol/prod/maintenancedirect.asp',
+            }
+        else:  # 'test'
+            api_urls = {
+                'flexcheckout': 'https://ogone.test.v-psp.com/Tokenization/HostedPage',
+                'directlink': 'https://ogone.test.v-psp.com/ncol/test/orderdirect.asp',
+                'maintenancedirect': 'https://ogone.test.v-psp.com/ncol/test/maintenancedirect.asp',
+            }
+        return api_urls.get(api_key)
+
+    def _ogone_generate_signature(self, values, incoming=True, format_keys=False):
+        """ Generate the signature for incoming or outgoing communications.
+
+        :param dict values: The values used to generate the signature
+        :param bool incoming: Whether the signature must be generated for an incoming (Ogone to
+                              Odoo) or outgoing (Odoo to Ogone) communication.
+        :param bool format_keys: Whether the keys must be formatted as uppercase, dot-separated
+                                 strings to comply with Ogone APIs. This must be used when the keys
+                                 are formatted as underscore-separated strings to be compliant with
+                                 QWeb's `t-att-value`.
+        :return: The signature
+        :rtype: str
+        """
+
+        def _filter_key(_key):
+            return not incoming or _key in VALID_KEYS
+
+        key = self.ogone_shakey_in if incoming else self.ogone_shakey_out
+        if format_keys:
+            formatted_items = [(k.upper().replace('_', '.'), v) for k, v in values.items()]
+        else:
+            formatted_items = [(k.upper(), v) for k, v in values.items()]
+        sorted_items = sorted(formatted_items)
+        signing_string = ''.join(f'{k}={v}{key}' for k, v in sorted_items if _filter_key(k) and v)
+        shasign = sha256(signing_string.encode("utf-8")).hexdigest()
+        return shasign
+
+    def _ogone_make_request(self, api_key, payload=None, method='POST'):
+        """ Make a request to one of Ogone APIs.
+
+        Note: self.ensure_one()
+
+        :param str api_key: The API to which the request is made: 'flexcheckout' or 'directlink'
+        :param dict payload: The payload of the request
+        :param str method: The HTTP method of the request
+        :return The content of the response
+        :rtype: bytes
+        :raise: ValidationError if an HTTP error occurs
+        """
+        self.ensure_one()
+
+        url = self._ogone_get_api_url(api_key)
+        try:
+            response = requests.request(method, url, data=payload, timeout=60)
+            response.raise_for_status()
+        except requests.exceptions.ConnectionError:
+            _logger.exception("unable to reach endpoint at %s", url)
+            raise ValidationError("Ogone: " + _("Could not establish the connection to the API."))
+        except requests.exceptions.HTTPError:
+            _logger.exception("invalid API request at %s with data %s", url, payload)
+            raise ValidationError("Ogone: " + _("The communication with the API failed."))
+        return response.content

--- a/None
+++ b/addons/payment_ogone/models/payment_token.py
@@ -0,0 +1,26 @@
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from odoo import _, models
+from odoo.exceptions import UserError
+
+
+class PaymentToken(models.Model):
+    _inherit = 'payment.token'
+
+    def _handle_reactivation_request(self):
+        """ Override of payment to raise an error informing that Ogone tokens cannot be restored.
+
+        More specifically, permanents tokens are never deleted in Ogone's backend but we don't
+        distinguish them from temporary tokens which are archived at creation time. So we simply
+        block the reactivation of every token.
+
+        Note: self.ensure_one()
+
+        :return: None
+        :raise: UserError if the token is managed by Ogone
+        """
+        super()._handle_reactivation_request()
+        if self.provider != 'ogone':
+            return
+
+        raise UserError(_("Saved payment methods cannot be restored once they have been archived."))

--- a/None
+++ b/addons/payment_ogone/models/payment_transaction.py
@@ -0,0 +1,284 @@
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+import logging
+import pprint
+
+from lxml import etree, objectify
+from werkzeug import urls
+
+from odoo import _, api, models
+from odoo.exceptions import UserError, ValidationError
+
+from . import const
+from odoo.addons.payment import utils as payment_utils
+from odoo.addons.payment_ogone.controllers.main import OgoneController
+
+_logger = logging.getLogger(__name__)
+
+
+class PaymentTransaction(models.Model):
+    _inherit = 'payment.transaction'
+
+    @api.model
+    def _compute_reference(self, provider, prefix=None, **kwargs):
+        """ Override of payment to ensure that Ogone requirements for references are satisfied.
+
+        Ogone requirements for references are as follows:
+        - References must be unique at provider level for a given merchant account.
+          This is satisfied by singularizing the prefix with the current datetime. If two
+          transactions are created simultaneously, `_compute_reference` ensures the uniqueness of
+          references by suffixing a sequence number.
+
+        :param str provider: The provider of the acquirer handling the transaction
+        :param str prefix: The custom prefix used to compute the full reference
+        :return: The unique reference for the transaction
+        :rtype: str
+        """
+        if provider != 'ogone':
+            return super()._compute_reference(provider, prefix=prefix, **kwargs)
+
+        prefix = payment_utils.singularize_reference_prefix(prefix=prefix, max_length=40)
+        return super()._compute_reference(provider, prefix=prefix, **kwargs)
+
+    def _get_specific_rendering_values(self, processing_values):
+        """ Override of payment to return Ogone-specific rendering values.
+
+        Note: self.ensure_one() from `_get_processing_values`
+
+        :param dict processing_values: The generic and specific processing values of the transaction
+        :return: The dict of acquirer-specific processing values
+        :rtype: dict
+        """
+        res = super()._get_specific_rendering_values(processing_values)
+        if self.acquirer_id.provider != 'ogone':
+            return res
+
+        base_url = self.acquirer_id._get_base_url()
+        return_url = urls.url_join(base_url, OgoneController._flexcheckout_return_url)
+        rendering_values = {
+            'ACCOUNT_PSPID': self.acquirer_id.ogone_pspid,
+            'ALIAS_ALIASID': payment_utils.singularize_reference_prefix(prefix='ODOO-ALIAS'),
+            'ALIAS_ORDERID': self.reference,
+            'ALIAS_STOREPERMANENTLY': 'Y' if self.tokenize else 'N',
+            'CARD_PAYMENTMETHOD': 'CreditCard',
+            'LAYOUT_LANGUAGE': self.partner_lang,
+            'PARAMETERS_ACCEPTURL': return_url,
+            'PARAMETERS_EXCEPTIONURL': return_url,
+        }
+        rendering_values.update({
+            'SHASIGNATURE_SHASIGN': self.acquirer_id._ogone_generate_signature(
+                rendering_values, incoming=False, format_keys=True
+            ).upper(),
+            'api_url': self.acquirer_id._ogone_get_api_url('flexcheckout'),
+        })
+        return rendering_values
+
+    def _send_payment_request(self):
+        """ Override of payment to send a payment request to Ogone.
+
+        Note: self.ensure_one()
+
+        :return: None
+        :raise: UserError if the transaction is not linked to a token
+        """
+        super()._send_payment_request()
+        if self.provider != 'ogone':
+            return
+
+        if not self.token_id:
+            raise UserError("Ogone: " + _("The transaction is not linked to a token."))
+
+        tree = self._ogone_send_order_request()
+        feedback_data = {
+            'FEEDBACK_TYPE': 'directlink',
+            'ORDERID': tree.get('orderID'),
+            'tree': tree,
+        }
+        _logger.info("entering _handle_feedback_data with data:\n%s", pprint.pformat(feedback_data))
+        self._handle_feedback_data('ogone', feedback_data)
+
+    def _ogone_send_order_request(self, request_3ds_authentication=False):
+        """ Make a new order request to Ogone and return the lxml etree parsed from the response.
+
+        :param bool request_3ds_authentication: Whether a 3DS authentication should be requested if
+                                                necessary to process the payment
+        :return: The lxml etree
+        :raise: ValidationError if the response can not be parsed to an lxml etree
+        """
+        base_url = self.acquirer_id.get_base_url()
+        return_url = urls.url_join(base_url, OgoneController._directlink_return_url)
+        data = {
+            # DirectLink parameters
+            'PSPID': self.acquirer_id.ogone_pspid,
+            'ORDERID': self.reference,
+            'USERID': self.acquirer_id.ogone_userid,
+            'PSWD': self.acquirer_id.ogone_password,
+            'AMOUNT': payment_utils.to_minor_currency_units(self.amount, None, 2),
+            'CURRENCY': self.currency_id.name,
+            'CN': self.partner_name or '',  # Cardholder Name
+            'EMAIL': self.partner_email or '',
+            'OWNERADDRESS': self.partner_address or '',
+            'OWNERZIP': self.partner_zip or '',
+            'OWNERTOWN': self.partner_city or '',
+            'OWNERCTY': self.partner_country_id.code or '',
+            'OWNERTELNO': self.partner_phone or '',
+            'OPERATION': 'SAL',  # direct sale
+            # Alias Manager parameters
+            'ALIAS': self.token_id.acquirer_ref,
+            'ALIASPERSISTEDAFTERUSE': 'Y' if self.token_id.active else 'N',
+            'ECI': 9,  # Recurring (from eCommerce)
+            # 3DS parameters
+            'ACCEPTURL': return_url,
+            'DECLINEURL': return_url,
+            'EXCEPTIONURL': return_url,
+            'LANGUAGE': self.partner_lang or 'en_US',
+            'FLAG3D': 'Y' if request_3ds_authentication else 'N',
+        }
+        data['SHASIGN'] = self.acquirer_id._ogone_generate_signature(data, incoming=False)
+
+        _logger.info(
+            "making payment request:\n%s",
+            pprint.pformat({k: v for k, v in data.items() if k != 'PSWD'})
+        )  # Log the payment request data without the password
+        response_content = self.acquirer_id._ogone_make_request('directlink', data)
+        try:
+            tree = objectify.fromstring(response_content)
+        except etree.XMLSyntaxError:
+            raise ValidationError("Ogone: " + "Received badly structured response from the API.")
+        _logger.info(
+            "received payment request response as an etree:\n%s",
+            etree.tostring(tree, pretty_print=True, encoding='utf-8')
+        )
+        return tree
+
+    @api.model
+    def _get_tx_from_feedback_data(self, provider, data):
+        """ Override of payment to find the transaction based on Ogone data.
+
+        :param str provider: The provider of the acquirer that handled the transaction
+        :param dict data: The feedback data sent by the provider
+        :return: The transaction if found
+        :rtype: recordset of `payment.transaction`
+        :raise: ValidationError if the data match no transaction
+        """
+        tx = super()._get_tx_from_feedback_data(provider, data)
+        if provider != 'ogone':
+            return tx
+
+        reference = data.get('ORDERID')
+        tx = self.search([('reference', '=', reference), ('provider', '=', 'ogone')])
+        if not tx:
+            raise ValidationError(
+                "Ogone: " + _("No transaction found matching reference %s.", reference)
+            )
+        return tx
+
+    def _process_feedback_data(self, data):
+        """ Override of payment to process the transaction based on Ogone data.
+
+        Note: self.ensure_one()
+
+        :param dict data: The feedback data sent by the provider
+        :return: None
+        :raise: ValidationError if inconsistent data were received
+        """
+        super()._process_feedback_data(data)
+        if self.provider != 'ogone':
+            return
+
+        feedback_type = data.get('FEEDBACK_TYPE')
+        if feedback_type == 'flexcheckout':
+            self._process_flexcheckout_data(data)
+        elif feedback_type == 'directlink':
+            self._process_directlink_data(data)
+        else:
+            raise ValidationError(
+                "Ogone: " + _("Received feedback data with unknown type: %s", feedback_type)
+            )
+
+    def _process_flexcheckout_data(self, data):
+        """ Create a token from Flexcheckout feedback data.
+
+        :param dict data: The feedback data from Flexcheckout
+        :return: None
+        """
+        token = self.env['payment.token'].create({
+            'acquirer_id': self.acquirer_id.id,
+            'name': data.get('CARDNUMBER'),  # Already padded with 'X's
+            'partner_id': self.partner_id.id,
+            'acquirer_ref': data['ALIASID'],
+            'verified': False,  # No payment has been processed through this token yet
+            'active': self.tokenize,  # Immediately archive the token if it was not requested
+        })
+        self.write({
+            'token_id': token.id,
+            'tokenize': False,
+        })
+
+    def _process_directlink_data(self, data):
+        """ Update the transaction state and the acquirer reference based on the feedback data.
+
+        :param dict data: The feedback data from DirectLink
+        :return: None
+        """
+        if 'tree' in data:
+            data = data['tree']
+        self.acquirer_reference = data.get('PAYID')
+        payment_status = int(data.get('STATUS', '0'))
+        if payment_status in const.PAYMENT_STATUS_MAPPING['pending']:
+            self._set_pending()
+        elif payment_status in const.PAYMENT_STATUS_MAPPING['done']:
+            self.token_id.verified = True  # The payment has been authorized, the token is valid
+            self._set_done()
+        elif payment_status in const.PAYMENT_STATUS_MAPPING['cancel']:
+            self._set_canceled()
+        else:  # Classify unknown payment statuses as `error` tx state
+            _logger.info("received data with invalid payment status: %s", payment_status)
+            self._set_error(
+                "Ogone: " + _("Received data with invalid payment status: %s", payment_status)
+            )
+
+    def _send_refund_request(self):
+        """ Override of payment to send a refund request to Authorize.
+
+        Note: self.ensure_one()
+
+        :return: None
+        :raise: ValidationError if a badly structured response is received
+        """
+        super()._send_refund_request()
+        if self.provider != 'ogone':
+            return
+
+        data = {
+            'PSPID': self.acquirer_id.ogone_pspid,
+            'ORDERID': self.reference,
+            'PAYID': self.acquirer_reference,
+            'USERID': self.acquirer_id.ogone_userid,
+            'PSWD': self.acquirer_id.ogone_password,
+            'AMOUNT': payment_utils.to_minor_currency_units(self.amount, None, 2),
+            'CURRENCY': self.currency_id.name,
+            'OPERATION': 'RFS',  # refund
+        }
+        data['SHASIGN'] = self.acquirer_id._ogone_generate_signature(data, incoming=False)
+
+        _logger.info(
+            "making refund request:\n%s",
+            pprint.pformat({k: v for k, v in data.items() if k != 'PSWD'})
+        )  # Log the refund request data without the password
+        response_content = self.acquirer_id._ogone_make_request('maintenancedirect', data)
+        try:
+            tree = objectify.fromstring(response_content)
+        except etree.XMLSyntaxError:
+            raise ValidationError("Ogone: " + "Received badly structured response from the API.")
+        _logger.info(
+            "received refund request response as an etree:\n%s",
+            etree.tostring(tree, pretty_print=True, encoding='utf-8')
+        )
+        feedback_data = {
+            'FEEDBACK_TYPE': 'directlink',
+            'ORDERID': tree.get('orderID'),
+            'tree': tree,
+        }
+        _logger.info("entering _handle_feedback_data with data:\n%s", pprint.pformat(feedback_data))
+        self._handle_feedback_data('ogone', feedback_data)
