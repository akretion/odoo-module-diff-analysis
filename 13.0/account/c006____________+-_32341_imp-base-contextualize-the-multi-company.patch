PR: https://github.com/odoo/odoo/pull/32341

From: a5b6f31cf28e5381e1c85f66730bcdb55998e643
From: Yannick Tivisse
Date: 2019-05-13 08:57:49

Structural Changes: 2.9
Total Changes: 124

[IMP] base: Contextualize the multi company

Purpose
=======

Allow the user to select the allowed companies for which he wants to see records
on top of selecting his current company.

It is confusing for users to see the records from the company he is connected to
and the records of the children companies.

Instead of using the hierarchy of companies to access records across companies,
the user can now select (from his set of allowed companies) the companies for
which he wants to access records.

/!\ This means that the user will interact with records from company A when in
company B.
Example: a SO has been created and confirmed in A. When in B, I create the
invoice from it.

Specifications
==============

1/ Deprecate the parent/children hierarchy on the res.company model. The fields are
kept on the res.company model to ensure the retro-compatibility, but won't be used
accross the standard code anymore. The only functional usage for this mechanism
was to allow to see records from several companies by creating a virtual parent
company, which will be possible with the new mechanism.

2/ By default, a user will only see the records of the company he is connected
to (or records without a company). (It is still editable by the user if needed).
For that, put this information in the user context, to allow having different
configurations on different browser tabs. Instead of having domains like
['|',
('company_id', '=', False),
('company_id', 'child_of', user.company_id.id)]
you'll have something like
['|',
('company_id', '=', False),
('company_id', 'in', company_ids)]
Note that the 'company_ids' is a value that is passed in the evaluation
context on the record rule, as we already have user, or time.
company_ids is a list of the ids of all the enabled companies in the
user's context.

3/ Out of the generic improvements brought by this task, this will illustrate
issues that could exist since several versions. For example, it should not be
possible to create a scrap order for the company A with a package of the company
B, or it should not be possible to create an invoice on the company A with
payment terms from the company B. Before the version 12.0, it was easy to
encounter this kind of issues as the admin was the SUPERUSER_ID. A positive side
effect of the fact that the SUPERUSER_ID has become an inactive user was to
make it more difficult to introduce mismatch on the records, but haven't solved
the issue, as it was still possible to do it with parent companies
configuration. Some of these issues have been fixed in this commit, but all the
business flows should be re-tested to check if an ir.rule should be introduced
(eg: a multi company rule for stock.quand.package), if the company of a record
is correctly transfered to another record created from the first record (eg:
From a SO, create an invoice and a payment, the company of the sales order
should be transfered on the invoice and the payment, even if the company of the
sales order is A and I'm logged into the company B with the company A enabled.

4/ Currently, if I click on a button on a notification email (example 'View
Task'), I face a traceback if I'm not logged into the company of the record.
Now, if you click on a button and if you have access to the record, the correct
company will be automatically set.

5/ If I display a kanban view with several records from several companies (and
an image), all the images should be displayed.

6/ Currently if you copy paste an url, this will crash if you're not in the
correct company. This won't be fixed because it's quite impossible to do it in
a clean way. This task brings a workaround. Copy/Paste -> Traceback -> Log into
the correct company, re-copy/paste -> Ok.

7/ 2 property methods have been added on the environment to retrieve the company
on which the user is logged in and the companies the user enabled, on a specific
tab.
That way, when creating a record, instead of doing
default=lambda self: self.env.user.company_id
do
default=lambda self: self.env.company_id
On the other hand, to retrieve the enabled companies, do
companies = self.env.company_ids

8/ Modify the Company Switcher widget to allow to log into another company
WITHOUT writing on the res.users (and thus bringing cache invalidation issues
and so on). Also allow to enable several companies and see records from several
companies, and independantly of the other browser's tabs.

9/ When focusing on a tab, save the current company configuration on the local
storage. That way, when doing 'CTRL+T' or a middle click, the context is
propagated to the new tab.

10/ Improve the error message in case of multi company access errors. Now, when
the user is in debug mode, display the related names of the records and the name
of the user who brings the issue.

11/ Remove the context erasing when writing on a res.users
This is probably coming from the migration to new API of the base module.
The context was not propagated at this moment, which was a common mistake at
that time. When migrating the module, probably by using the 'black box' method,
as the context was not propagated, it was erased on the new version. This is
now an issue because the context (i.e. the enabled companies) was erased when
writing on a res.users, leading to tracebacks.
See: https://github.com/odoo/odoo/commit/7eab8e26d3d46c53f4be924d6a34e80a66e74960#diff-4c2e738ee8f64f11806c889ea097b5e7R624

12/ Fix the crash manager on redirect warnings. The issue is the following
- Create an invoice on a company without a configured CoA.
- Set a partner
- On the onchange_partner_id, a redirect warning is raised to propose you
to configure a CoA
- Click on 'Go to the configuration panel'
- A generic warning says something like 'Do you want to discard your changes?'
- Click on yes, the page refreshes, but not on the redirect action.
Now, set correctly the action on the hash, and reload instead. The breadcrumb is
lost for example, but you reach the correct action at least.

13/ Introduce a res.group to enable/disable the multi company per tab
feature.

14/ To help the users to know which tab is in which company, add the
possibility to have a favicon per company. When creating a company,
the classical 'O' icon is colored by default in a random color.

15/ Remove the company switcher on the frontend. This was mainly there
to allow a user to swicth to the company linked to the website.
This behavior is now transparent to the user. If the website A is
activated, then the company set on the context is the company of the
website.

16/ Deprecated the _company_default_get method on the res.company
model. Remove the method _get_company on the res.users model.

17/ Add 'allowed_company_ids' and 'current_company_id' on the pyeval
context. You can now use those variables on domains in the views to
access directly to the activated company.ies on the current tab.

TaskID: 1960971

closes odoo/odoo#32341

Signed-off-by: Yannick Tivisse (yti) <yti@odoo.com>

================================= pseudo patch: =================================

--- a/addons/account/models/account.py
+++ b/addons/account/models/account.py
@@ -91,7 +91,7 @@ class AccountAccount(models.Model):
         'account_id', 'tax_id', string='Default Taxes')
     note = fields.Text('Internal Notes')
     company_id = fields.Many2one('res.company', string='Company', required=True,
-        default=lambda self: self.env['res.company']._company_default_get('account.account'))
+        default=lambda self: self.env.company_id)
     tag_ids = fields.Many2many('account.account.tag', 'account_account_account_tag', string='Tags', help="Optional tags you may want to assign for custom reporting")
     group_id = fields.Many2one('account.group')
 
@@ -390,7 +390,7 @@ class AccountJournalGroup(models.Model):
     _description = "Account Journal Group"
 
     name = fields.Char(required=True, translate=True)
-    company_id = fields.Many2one('res.company', required=True, default=lambda self: self.env['res.company']._company_default_get('account.account'))
+    company_id = fields.Many2one('res.company', required=True, default=lambda self: self.env.company_id)
     account_journal_ids = fields.Many2many('account.journal', string="Journals")
     sequence = fields.Integer(default=10)
 
@@ -457,7 +457,7 @@ class AccountJournal(models.Model):
 
     #groups_id = fields.Many2many('res.groups', 'account_journal_group_rel', 'journal_id', 'group_id', string='Groups')
     currency_id = fields.Many2one('res.currency', help='The currency used to enter statement', string="Currency", oldname='currency')
-    company_id = fields.Many2one('res.company', string='Company', required=True, index=True, default=lambda self: self.env.user.company_id,
+    company_id = fields.Many2one('res.company', string='Company', required=True, index=True, default=lambda self: self.env.company_id,
         help="Company related to this journal")
 
     refund_sequence = fields.Boolean(string='Dedicated Credit Note Sequence', help="Check this box if you don't want to share the same sequence for invoices and credit notes made from this journal", default=False)
@@ -760,7 +760,7 @@ class AccountJournal(models.Model):
 
     @api.model
     def create(self, vals):
-        company_id = vals.get('company_id', self.env.user.company_id.id)
+        company_id = vals.get('company_id', self.env.company_id.id)
         if vals.get('type') in ('bank', 'cash'):
             # For convenience, the name can be inferred from account number
             if not vals.get('name') and 'bank_acc_number' in vals:
@@ -832,16 +832,16 @@ class AccountJournal(models.Model):
     @api.depends('company_id')
     def _belong_to_company(self):
         for journal in self:
-            journal.belong_to_company = (journal.company_id.id == self.env.user.company_id.id)
+            journal.belong_to_company = (journal.company_id.id == self.env.company_id.id)
 
     @api.multi
     def _search_company_journals(self, operator, value):
         if value:
-            recs = self.search([('company_id', operator, self.env.user.company_id.id)])
+            recs = self.search([('company_id', operator, self.env.company_id.id)])
         elif operator == '=':
-            recs = self.search([('company_id', '!=', self.env.user.company_id.id)])
+            recs = self.search([('company_id', '!=', self.env.company_id.id)])
         else:
-            recs = self.search([('company_id', operator, self.env.user.company_id.id)])
+            recs = self.search([('company_id', operator, self.env.company_id.id)])
         return [('id', 'in', [x.id for x in recs])]
 
     @api.multi
@@ -899,7 +899,7 @@ class AccountTax(models.Model):
     amount_type = fields.Selection(default='percent', string="Tax Computation", required=True, oldname='type',
         selection=[('group', 'Group of Taxes'), ('fixed', 'Fixed'), ('percent', 'Percentage of Price'), ('division', 'Percentage of Price Tax Included')])
     active = fields.Boolean(default=True, help="Set active to false to hide the tax without removing it.")
-    company_id = fields.Many2one('res.company', string='Company', required=True, default=lambda self: self.env.user.company_id)
+    company_id = fields.Many2one('res.company', string='Company', required=True, default=lambda self: self.env.company_id)
     children_tax_ids = fields.Many2many('account.tax', 'account_tax_filiation_rel', 'parent_tax', 'child_tax', string='Children Taxes')
     sequence = fields.Integer(required=True, default=1,
         help="The sequence field is used to define order in which the tax lines are applied.")
@@ -1080,7 +1080,7 @@ class AccountTax(models.Model):
             }]
         } """
         if len(self) == 0:
-            company_id = self.env.user.company_id
+            company_id = self.env.company_id
         else:
             company_id = self[0].company_id
         if not currency:

--- a/addons/account/models/account_bank_statement.py
+++ b/addons/account/models/account_bank_statement.py
@@ -101,7 +101,7 @@ class AccountBankStatement(models.Model):
     @api.model
     def _default_journal(self):
         journal_type = self.env.context.get('journal_type', False)
-        company_id = self.env['res.company']._company_default_get('account.bank.statement').id
+        company_id = self.env.company_id.id
         if journal_type:
             journals = self.env['account.journal'].search([('type', '=', journal_type), ('company_id', '=', company_id)])
             if journals:
@@ -145,7 +145,7 @@ class AccountBankStatement(models.Model):
     journal_id = fields.Many2one('account.journal', string='Journal', required=True, states={'confirm': [('readonly', True)]}, default=_default_journal)
     journal_type = fields.Selection(related='journal_id.type', help="Technical field used for usability purposes", readonly=False)
     company_id = fields.Many2one('res.company', related='journal_id.company_id', string='Company', store=True, readonly=True,
-        default=lambda self: self.env['res.company']._company_default_get('account.bank.statement'))
+        default=lambda self: self.env.company_id)
 
     total_entry_encoding = fields.Monetary('Transactions Subtotal', compute='_end_balance', store=True, help="Total of transaction lines.")
     balance_end = fields.Monetary('Computed Balance', compute='_end_balance', store=True, help='Balance as calculated based on Opening Balance and transaction lines')

--- a/addons/account/models/account_fiscal_year.py
+++ b/addons/account/models/account_fiscal_year.py
@@ -17,7 +17,7 @@ class AccountFiscalYear(models.Model):
     date_to = fields.Date(string='End Date', required=True,
         help='Ending Date, included in the fiscal year.')
     company_id = fields.Many2one('res.company', string='Company', required=True,
-        default=lambda self: self.env.user.company_id)
+        default=lambda self: self.env.company_id)
 
     @api.constrains('date_from', 'date_to', 'company_id')
     def _check_dates(self):

--- a/addons/account/models/account_invoice.py
+++ b/addons/account/models/account_invoice.py
@@ -49,7 +49,7 @@ class AccountInvoice(models.Model):
 
 
     def _get_default_incoterm(self):
-        return self.env.user.company_id.incoterm_id
+        return self.env.company_id.incoterm_id
 
     @api.one
     @api.depends('invoice_line_ids.price_subtotal', 'tax_line_ids.amount', 'tax_line_ids.amount_rounding',
@@ -82,7 +82,7 @@ class AccountInvoice(models.Model):
             return self.env['account.journal'].browse(self._context.get('default_journal_id'))
         inv_type = self._context.get('type', 'out_invoice')
         inv_types = inv_type if isinstance(inv_type, list) else [inv_type]
-        company_id = self._context.get('company_id', self.env.user.company_id.id)
+        company_id = self._context.get('company_id', self.env.company_id.id)
         domain = [
             ('type', 'in', [TYPE2JOURNAL[ty] for ty in inv_types if ty in TYPE2JOURNAL]),
             ('company_id', '=', company_id),
@@ -96,12 +96,12 @@ class AccountInvoice(models.Model):
     @api.model
     def _default_currency(self):
         journal = self._default_journal()
-        return journal.currency_id or journal.company_id.currency_id or self.env.user.company_id.currency_id
+        return journal.currency_id or journal.company_id.currency_id or self.env.company_id.currency_id
 
     def _default_comment(self):
         invoice_type = self.env.context.get('type', 'out_invoice')
         if invoice_type == 'out_invoice' and self.env['ir.config_parameter'].sudo().get_param('account.use_invoice_terms'):
-            return self.env.user.company_id.invoice_terms
+            return self.env.company_id.invoice_terms
 
     def _get_aml_for_amount_residual(self):
         """ Get the aml to consider to compute the amount residual of invoices """
@@ -367,7 +367,7 @@ class AccountInvoice(models.Model):
         domain="[('type', 'in', {'out_invoice': ['sale'], 'out_refund': ['sale'], 'in_refund': ['purchase'], 'in_invoice': ['purchase']}.get(type, [])), ('company_id', '=', company_id)]")
     company_id = fields.Many2one('res.company', string='Company', change_default=True,
         required=True, readonly=True, states={'draft': [('readonly', False)]},
-        default=lambda self: self.env['res.company']._company_default_get('account.invoice'))
+        default=lambda self: self.env.company_id)
 
     reconciled = fields.Boolean(string='Paid/Reconciled', store=True, readonly=True, compute='_compute_residual',
         help="It indicates that the invoice has been paid and the journal entry of the invoice has been reconciled with one or several journal entries of payment.")
@@ -734,7 +734,7 @@ class AccountInvoice(models.Model):
     def message_post(self, **kwargs):
         if self.env.context.get('mark_invoice_as_sent'):
             self.filtered(lambda inv: not inv.sent).write({'sent': True})
-            self.env.user.company_id.set_onboarding_step_done('account_onboarding_sample_invoice_state')
+            self.env.company_id.set_onboarding_step_done('account_onboarding_sample_invoice_state')
         return super(AccountInvoice, self.with_context(mail_post_autofollow=True)).message_post(**kwargs)
 
     @api.model
@@ -1746,7 +1746,7 @@ class AccountInvoiceLine(models.Model):
         if self.invoice_id.currency_id and self.invoice_id.currency_id != self.invoice_id.company_id.currency_id:
             currency = self.invoice_id.currency_id
             date = self.invoice_id._get_currency_rate_date()
-            price_subtotal_signed = currency._convert(price_subtotal_signed, self.invoice_id.company_id.currency_id, self.company_id or self.env.user.company_id, date or fields.Date.today())
+            price_subtotal_signed = currency._convert(price_subtotal_signed, self.invoice_id.company_id.currency_id, self.company_id or self.env.company_id, date or fields.Date.today())
         sign = self.invoice_id.type in ['in_refund', 'out_refund'] and -1 or 1
         self.price_subtotal_signed = price_subtotal_signed * sign
 
@@ -1848,7 +1848,7 @@ class AccountInvoiceLine(models.Model):
             taxes = self.product_id.supplier_taxes_id or self.account_id.tax_ids or self.invoice_id.company_id.account_purchase_tax_id
 
         # Keep only taxes of the company
-        company_id = self.company_id or self.env.user.company_id
+        company_id = self.company_id or self.env.company_id
         taxes = taxes.filtered(lambda r: r.company_id == company_id)
 
         self.invoice_line_tax_ids = fp_taxes = self.invoice_id.fiscal_position_id.map_tax(taxes, self.product_id, self.invoice_id.partner_id)

--- a/addons/account/models/account_journal_dashboard.py
+++ b/addons/account/models/account_journal_dashboard.py
@@ -281,7 +281,7 @@ class account_journal(models.Model):
         curr_cache = {} if curr_cache is None else curr_cache
         for result in results_dict:
             cur = self.env['res.currency'].browse(result.get('currency'))
-            company = self.env['res.company'].browse(result.get('company_id')) or self.env.user.company_id
+            company = self.env['res.company'].browse(result.get('company_id')) or self.env.company_id
             rslt_count += 1
             date = result.get('date_invoice') or fields.Date.today()
 

--- a/addons/account/models/account_move.py
+++ b/addons/account/models/account_move.py
@@ -26,7 +26,7 @@ class AccountMove(models.Model):
     def default_get(self, fields):
         rec = super(AccountMove, self).default_get(fields)
         if not rec.get('journal_id'):
-            rec.update({'journal_id': self.env['account.journal'].search([('type', '=', 'general'), ('company_id', '=', self.env.user.company_id.id)], limit=1).id})
+            rec.update({'journal_id': self.env['account.journal'].search([('type', '=', 'general'), ('company_id', '=', self.env.company_id.id)], limit=1).id})
         return rec
 
     @api.multi
@@ -90,12 +90,12 @@ class AccountMove(models.Model):
     @api.one
     @api.depends('company_id')
     def _compute_currency(self):
-        self.currency_id = self.company_id.currency_id or self.env.user.company_id.currency_id
+        self.currency_id = self.company_id.currency_id or self.env.company_id.currency_id
 
     @api.multi
     def _get_default_journal(self):
         if self.env.context.get('default_journal_type'):
-            return self.env['account.journal'].search([('company_id', '=', self.env.user.company_id.id), ('type', '=', self.env.context['default_journal_type'])], limit=1).id
+            return self.env['account.journal'].search([('company_id', '=', self.env.company_id.id), ('type', '=', self.env.context['default_journal_type'])], limit=1).id
 
     @api.multi
     @api.depends('line_ids.partner_id')
@@ -402,7 +402,7 @@ class AccountMove(models.Model):
     def assert_balanced(self):
         if not self.ids:
             return True
-        prec = self.env.user.company_id.currency_id.decimal_places
+        prec = self.env.company_id.currency_id.decimal_places
 
         self._cr.execute("""\
             SELECT      move_id
@@ -484,7 +484,7 @@ class AccountMove(models.Model):
             ('reverse_entry_id', '=', False)])
         for move in records:
             date = None
-            if move.reverse_date and (not self.env.user.company_id.period_lock_date or move.reverse_date > self.env.user.company_id.period_lock_date):
+            if move.reverse_date and (not self.env.company_id.period_lock_date or move.reverse_date > self.env.company_id.period_lock_date):
                 date = move.reverse_date
             move.reverse_moves(date=date, auto=True)
 
@@ -1348,7 +1348,7 @@ class AccountMoveLine(models.Model):
         currency_id = False
         date = self.env.context.get('date') or fields.Date.today()
         company = self.env.context.get('company_id')
-        company = self.env['res.company'].browse(company) if company else self.env.user.company_id
+        company = self.env['res.company'].browse(company) if company else self.env.company_id
         if src_currency and src_currency != company_currency:
             amount_currency = amount
             amount = src_currency._convert(amount, company_currency, company, date)
@@ -1404,7 +1404,7 @@ class AccountMoveLine(models.Model):
                 'move_id': move_line.id,
                 'user_id': move_line.invoice_id.user_id.id or self._uid,
                 'partner_id': move_line.partner_id.id,
-                'company_id': move_line.analytic_account_id.company_id.id or self.env.user.company_id.id,
+                'company_id': move_line.analytic_account_id.company_id.id or self.env.company_id.id,
             })
         return result
 
@@ -1429,7 +1429,7 @@ class AccountMoveLine(models.Model):
             'ref': self.ref,
             'move_id': self.id,
             'user_id': self.invoice_id.user_id.id or self._uid,
-            'company_id': distribution.account_id.company_id.id or self.env.user.company_id.id,
+            'company_id': distribution.account_id.company_id.id or self.env.company_id.id,
         }
 
     @api.model

--- a/addons/account/models/account_payment.py
+++ b/addons/account/models/account_payment.py
@@ -72,7 +72,7 @@ class account_payment(models.Model):
     partner_id = fields.Many2one('res.partner', string='Partner', tracking=True, readonly=True, states={'draft': [('readonly', False)]})
 
     amount = fields.Monetary(string='Payment Amount', required=True, readonly=True, states={'draft': [('readonly', False)]}, tracking=True)
-    currency_id = fields.Many2one('res.currency', string='Currency', required=True, readonly=True, states={'draft': [('readonly', False)]}, default=lambda self: self.env.user.company_id.currency_id)
+    currency_id = fields.Many2one('res.currency', string='Currency', required=True, readonly=True, states={'draft': [('readonly', False)]}, default=lambda self: self.env.company_id.currency_id)
     payment_date = fields.Date(string='Payment Date', default=fields.Date.context_today, required=True, readonly=True, states={'draft': [('readonly', False)]}, copy=False, tracking=True)
     communication = fields.Char(string='Memo', readonly=True, states={'draft': [('readonly', False)]})
     journal_id = fields.Many2one('account.journal', string='Payment Journal', required=True, readonly=True, states={'draft': [('readonly', False)]}, tracking=True, domain=[('type', 'in', ('bank', 'cash'))])
@@ -304,7 +304,7 @@ class account_payment(models.Model):
             if payment_currency == currency:
                 total += amount_total
             else:
-                total += payment_currency._convert(amount_total, currency, self.env.user.company_id, self.payment_date or fields.Date.today())
+                total += payment_currency._convert(amount_total, currency, self.env.company_id, self.payment_date or fields.Date.today())
         return total
 
     @api.multi
@@ -693,7 +693,7 @@ class payment_register(models.TransientModel):
         if 'invoice_ids' not in rec:
             rec['invoice_ids'] = [(6, 0, invoices.ids)]
         if 'journal_id' not in rec:
-            rec['journal_id'] = self.env['account.journal'].search([('company_id', '=', self.env.user.company_id.id), ('type', 'in', ('bank', 'cash'))], limit=1).id
+            rec['journal_id'] = self.env['account.journal'].search([('company_id', '=', self.env.company_id.id), ('type', 'in', ('bank', 'cash'))], limit=1).id
         if 'payment_method_id' not in rec:
             if invoices[0].type in ('out_invoice', 'in_refund'):
                 domain = [('payment_type', '=', 'inbound')]

--- a/addons/account/models/account_payment_term.py
+++ b/addons/account/models/account_payment_term.py
@@ -42,7 +42,7 @@ class AccountPaymentTerm(models.Model):
         if self.env.context.get('currency_id'):
             currency = self.env['res.currency'].browse(self.env.context['currency_id'])
         else:
-            currency = self.env.user.company_id.currency_id
+            currency = self.env.company_id.currency_id
         for line in self.line_ids:
             if line.value == 'fixed':
                 amt = sign * currency.round(line.value_amount)

--- a/addons/account/models/account_reconcile_model.py
+++ b/addons/account/models/account_reconcile_model.py
@@ -13,7 +13,7 @@ class AccountReconcileModel(models.Model):
     # Base fields.
     name = fields.Char(string='Name', required=True)
     sequence = fields.Integer(required=True, default=10)
-    company_id = fields.Many2one('res.company', string='Company', required=True, default=lambda self: self.env.user.company_id)
+    company_id = fields.Many2one('res.company', string='Company', required=True, default=lambda self: self.env.company_id)
 
     rule_type = fields.Selection(selection=[
         ('writeoff_button', _('Manually create a write-off on clicked button.')),

--- a/addons/account/models/chart_template.py
+++ b/addons/account/models/chart_template.py
@@ -165,13 +165,10 @@ class AccountChartTemplate(models.Model):
         """
         self.ensure_one()
         # do not use `request.env` here, it can cause deadlocks
-        if request and request.session.uid:
-            current_user = self.env['res.users'].browse(request.uid)
-            company = current_user.company_id
+        if request and 'allowed_company_ids' in dir(request):
+            company = self.env['res.company'].browse(request.allowed_company_ids[0])
         else:
-            # fallback to company of current user, most likely __system__
-            # (won't work well for multi-company)
-            company = self.env.user.company_id
+            company = self.env.company_id
         # If we don't have any chart of account on this company, install this chart of account
         if not company.chart_template_id and not self.existing_accounting(company):
             self.load_for_current_company(15.0, 15.0)
@@ -186,13 +183,10 @@ class AccountChartTemplate(models.Model):
         """
         self.ensure_one()
         # do not use `request.env` here, it can cause deadlocks
-        if request and request.session.uid:
-            current_user = self.env['res.users'].browse(request.uid)
-            company = current_user.company_id
+        if request and 'allowed_company_ids' in dir(request):
+            company = self.env['res.company'].browse(request.allowed_company_ids[0])
         else:
-            # fallback to company of current user, most likely __system__
-            # (won't work well for multi-company)
-            company = self.env.user.company_id
+            company = self.env.company_id
         # Ensure everything is translated to the company's language, not the user's one.
         self = self.with_context(lang=company.partner_id.lang)
         if not self.env.user._is_admin():

--- a/addons/account/models/company.py
+++ b/addons/account/models/company.py
@@ -313,7 +313,7 @@ Best Regards,'''))
     @api.model
     def setting_init_fiscal_year_action(self):
         """ Called by the 'Fiscal Year Opening' button of the setup bar."""
-        company = self.env.user.company_id
+        company = self.env.company_id
         company.create_op_move_if_non_existant()
         new_wizard = self.env['account.financial.year.op'].create({'company_id': company.id})
         view_id = self.env.ref('account.setup_financial_year_opening_form').id
@@ -331,7 +331,7 @@ Best Regards,'''))
     @api.model
     def setting_chart_of_accounts_action(self):
         """ Called by the 'Chart of Accounts' button of the setup bar."""
-        company = self.env.user.company_id
+        company = self.env.company_id
         company.set_onboarding_step_done('account_setup_coa_state')
 
         # If an opening move has already been posted, we open the tree view showing all the accounts
@@ -455,25 +455,25 @@ Best Regards,'''))
     @api.model
     def action_close_account_invoice_onboarding(self):
         """ Mark the invoice onboarding panel as closed. """
-        self.env.user.company_id.account_invoice_onboarding_state = 'closed'
+        self.env.company_id.account_invoice_onboarding_state = 'closed'
 
     @api.model
     def action_close_account_dashboard_onboarding(self):
         """ Mark the dashboard onboarding panel as closed. """
-        self.env.user.company_id.account_dashboard_onboarding_state = 'closed'
+        self.env.company_id.account_dashboard_onboarding_state = 'closed'
 
     @api.model
     def action_open_account_onboarding_invoice_layout(self):
         """ Onboarding step for the invoice layout. """
         action = self.env.ref('account.action_open_account_onboarding_invoice_layout').read()[0]
-        action['res_id'] = self.env.user.company_id.id
+        action['res_id'] = self.env.company_id.id
         return action
 
     @api.model
     def action_open_account_onboarding_sale_tax(self):
         """ Onboarding step for the invoice layout. """
         action = self.env.ref('account.action_open_account_onboarding_sale_tax').read()[0]
-        action['res_id'] = self.env.user.company_id.id
+        action['res_id'] = self.env.company_id.id
         return action
 
     @api.model
@@ -482,7 +482,7 @@ Best Regards,'''))
         # use current user as partner
         partner = self.env.user.partner_id
 
-        company_id = self.env.user.company_id.id
+        company_id = self.env.company_id.id
         # try to find an existing sample invoice
         sample_invoice = self.env['account.invoice'].search(
             [('company_id', '=', company_id),
@@ -490,7 +490,7 @@ Best Regards,'''))
 
         if len(sample_invoice) == 0:
             # If there are no existing accounts or no journal, fail
-            account = self.env.user.company_id.get_chart_of_accounts_or_fail()
+            account = self.env.company_id.get_chart_of_accounts_or_fail()
 
             journal = self.env['account.journal'].search([('company_id', '=', company_id)], limit=1)
             if len(journal) == 0:

--- a/addons/account/models/partner.py
+++ b/addons/account/models/partner.py
@@ -204,7 +204,7 @@ class ResPartner(models.Model):
 
     @api.multi
     def _credit_debit_get(self):
-        tables, where_clause, where_params = self.env['account.move.line'].with_context(company_id=self.env.user.company_id.id)._query_get()
+        tables, where_clause, where_params = self.env['account.move.line'].with_context(company_id=self.env.company_id.id)._query_get()
         where_params = [tuple(self.ids)] + where_params
         if where_clause:
             where_clause = 'AND ' + where_clause
@@ -263,7 +263,7 @@ class ResPartner(models.Model):
             self.total_invoiced = 0.0
             return True
 
-        user_currency_id = self.env.user.company_id.currency_id.id
+        user_currency_id = self.env.company_id.currency_id.id
         all_partners_and_children = {}
         all_partner_ids = []
         for partner in self:
@@ -309,7 +309,7 @@ class ResPartner(models.Model):
             partner.contracts_count = AccountAnalyticAccount.search_count([('partner_id', '=', partner.id)])
 
     def get_followup_lines_domain(self, date, overdue_only=False, only_unblocked=False):
-        domain = [('reconciled', '=', False), ('account_id.deprecated', '=', False), ('account_id.internal_type', '=', 'receivable'), '|', ('debit', '!=', 0), ('credit', '!=', 0), ('company_id', '=', self.env.user.company_id.id)]
+        domain = [('reconciled', '=', False), ('account_id.deprecated', '=', False), ('account_id.internal_type', '=', 'receivable'), '|', ('debit', '!=', 0), ('credit', '!=', 0), ('company_id', '=', self.env.company_id.id)]
         if only_unblocked:
             domain += [('blocked', '=', False)]
         if self.ids:
@@ -362,14 +362,14 @@ class ResPartner(models.Model):
     @api.multi
     def mark_as_reconciled(self):
         self.env['account.partial.reconcile'].check_access_rights('write')
-        return self.sudo().with_context(company_id=self.env.user.company_id.id).write({'last_time_entries_checked': time.strftime(DEFAULT_SERVER_DATETIME_FORMAT)})
+        return self.sudo().with_context(company_id=self.env.company_id.id).write({'last_time_entries_checked': time.strftime(DEFAULT_SERVER_DATETIME_FORMAT)})
 
     @api.one
     def _get_company_currency(self):
         if self.company_id:
             self.currency_id = self.sudo().company_id.currency_id
         else:
-            self.currency_id = self.env.user.company_id.currency_id
+            self.currency_id = self.env.company_id.currency_id
 
     credit = fields.Monetary(compute='_credit_debit_get', search=_credit_search,
         string='Total Receivable', help="Total amount this customer owes you.")
@@ -448,7 +448,7 @@ class ResPartner(models.Model):
         if self.company_id:
             company = self.company_id
         else:
-            company = self.env.user.company_id
+            company = self.env.company_id
         return {'domain': {'property_account_position_id': [('company_id', 'in', [company.id, False])]}}
 
     def can_edit_vat(self):

--- a/addons/account/models/product.py
+++ b/addons/account/models/product.py
@@ -23,9 +23,9 @@ class ProductTemplate(models.Model):
     _inherit = "product.template"
 
     taxes_id = fields.Many2many('account.tax', 'product_taxes_rel', 'prod_id', 'tax_id', help="Default taxes used when selling the product.", string='Customer Taxes',
-        domain=[('type_tax_use', '=', 'sale')], default=lambda self: self.env.user.company_id.account_sale_tax_id)
+        domain=[('type_tax_use', '=', 'sale')], default=lambda self: self.env.company_id.account_sale_tax_id)
     supplier_taxes_id = fields.Many2many('account.tax', 'product_supplier_taxes_rel', 'prod_id', 'tax_id', string='Vendor Taxes', help='Default taxes used when buying the product.',
-        domain=[('type_tax_use', '=', 'purchase')], default=lambda self: self.env.user.company_id.account_purchase_tax_id)
+        domain=[('type_tax_use', '=', 'purchase')], default=lambda self: self.env.company_id.account_purchase_tax_id)
     property_account_income_id = fields.Many2one('account.account', company_dependent=True,
         string="Income Account", oldname="property_account_income",
         domain=[('deprecated', '=', False)],

--- a/addons/account/models/reconciliation_widget.py
+++ b/addons/account/models/reconciliation_widget.py
@@ -361,7 +361,7 @@ class AccountReconciliation(models.AbstractModel):
                 is_partner and ' ' or "AND at.type <> 'payable' AND at.type <> 'receivable'",
                 account_type and "AND at.type = %(account_type)s" or '',
                 res_ids and 'AND ' + res_alias + '.id in %(res_ids)s' or '',
-                self.env.user.company_id.id,
+                self.env.company_id.id,
                 is_partner and 'AND l.partner_id = p.id' or ' ',
                 aml_ids and 'AND l.id IN %(aml_ids)s' or '',
                 is_partner and 'l.partner_id, p.id,' or ' ',

--- a/addons/account/models/res_config_settings.py
+++ b/addons/account/models/res_config_settings.py
@@ -142,7 +142,7 @@ class ResConfigSettings(models.TransientModel):
     def _onchange_tax_exigibility(self):
         res = {}
         tax = self.env['account.tax'].search([
-            ('company_id', '=', self.env.user.company_id.id), ('tax_exigibility', '=', 'on_payment')
+            ('company_id', '=', self.env.company_id.id), ('tax_exigibility', '=', 'on_payment')
         ], limit=1)
         if not self.tax_exigibility and tax:
             self.tax_exigibility = True
