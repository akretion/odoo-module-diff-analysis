PR: https://github.com/odoo/odoo/pull/

From: d1c3948a05acbe73fc6965833a442a1b35efdbf8
From: Yannick Tivisse
Date: 2019-01-08 12:12:33

Breaking data model changes score: 49.8, change matches:
-    order_line_id = fields.Many2one('lunch.order.line', 'Order', ondelete='cascade')
+    previous_order_ids = fields.Many2many('lunch.order.line', compute='_compute_previous_order')
-    mail_sent = fields.Boolean('Mail Sent', readonly=True)
-    supplier_ids = fields.Many2many('lunch.supplier', compute='_compute_supplier_ids', store=True)
-    topping_ids = fields.Many2many('lunch.product', string='Toppings')
-    product_id = fields.Many2one('lunch.product', string="Product", domain=[('is_topping', '=', False)], required=True)
+    product_id = fields.Many2one('lunch.product', 'Product', required=True,
-    supplier_id = fields.Many2one('lunch.supplier', string='Vendor', related='product_id.supplier_id',
-    price = fields.Float('Total Price', compute='_compute_total_price', readonly=True, store=True,
+    price = fields.Float(related='product_id.price', readonly=True, store=True,
-    quantity = fields.Float('Quantity', required=True, default=1)
-    supplier_id = fields.Many2one('lunch.supplier', 'Vendor', required=True)
-    is_topping = fields.Boolean("This product is an extra garniture")
-    image = fields.Binary(
-    image_medium = fields.Binary(
-    image_small = fields.Binary(
-    already_ordered = fields.Boolean('Has Already Been Ordered', compute='_compute_already_ordered')
-    partner_id = fields.Many2one('res.partner', string='Linked partner', required=True)
-    name = fields.Char('Name', related='partner_id.name')
-    description = fields.Text('Description')
-    email = fields.Char(related='partner_id.email')
-    email_formatted = fields.Char(related='partner_id.email_formatted', readonly=True)
-    phone = fields.Char(related='partner_id.phone')
-    street = fields.Char(related='partner_id.street')
-    street2 = fields.Char(related='partner_id.street2')
-    zip_code = fields.Char(related='partner_id.zip')
-    city = fields.Char(related='partner_id.city')
-    state_id = fields.Many2one("res.country.state", related='partner_id.state_id')
-    country_id = fields.Many2one('res.country', related='partner_id.country_id')
-    vat = fields.Char(related='partner_id.vat')
-    image = fields.Binary(related='partner_id.image', readonly=False)
-    image_medium = fields.Binary(related='partner_id.image_medium', readonly=False)
-    image_small = fields.Binary(related='partner_id.image_small', readonly=False)
-    send_by = fields.Selection([
-    automatic_email_send = fields.Boolean('Automatic Email Sending')
-    automatic_email_time = fields.Float('Hour')
-    recurrency = fields.Selection([('once', 'Specific Day'), ('reccurent', 'Reccurent')], 'Recurrency', default='once')
-    recurrency_from = fields.Float('From')
-    recurrency_to = fields.Float('To')
-    recurrency_date = fields.Date('Day', default=fields.Date.today())
-    recurrency_date_from = fields.Datetime('from', compute='_compute_recurrency_date_from', store=True)
-    recurrency_date_to = fields.Datetime('to', compute='_compute_recurrency_date_to', store=True)
-    recurrency_monday = fields.Boolean('Monday')
-    recurrency_tuesday = fields.Boolean('Tuesday')
-    recurrency_wednesday = fields.Boolean('Wednesday')
-    recurrency_thursday = fields.Boolean('Thursday')
-    recurrency_friday = fields.Boolean('Friday')
-    recurrency_saturday = fields.Boolean('Saturday')
-    recurrency_sunday = fields.Boolean('Sunday')
-    available_today = fields.Boolean('This is True when if the supplier is available today',
-    tz = fields.Selection(_tz_get, string='Timezone', required=True, default='UTC')

Total Changes: 670

Revert "[IMP] lunch: automatize lunch orders"

This reverts commit f727b8f0b57aad49f2ea8c54600ab73bbd02570f.

================================= pseudo patch: =================================

--- a/addons/lunch/models/__init__.py
+++ b/addons/lunch/models/__init__.py
@@ -1,6 +1,6 @@
 # -*- coding: utf-8 -*-
 
+from . import lunch_alert
 from . import lunch_cashmove
 from . import lunch_order
 from . import lunch_product
-from . import lunch_supplier

--- a/None
+++ b/addons/lunch/models/lunch_alert.py
@@ -0,0 +1,85 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+import datetime
+
+from odoo import api, fields, models, _
+
+
+class LunchAlert(models.Model):
+    """ Alerts to display during a lunch order. An alert can be specific to a
+    given day, weekly or daily. The alert is displayed from start to end hour. """
+    _name = 'lunch.alert'
+    _description = 'Lunch Alert'
+    _rec_name = 'message'
+
+    display = fields.Boolean(compute='_compute_display_get')
+    message = fields.Text('Message', required=True)
+    alert_type = fields.Selection([('specific', 'Specific Day'),
+                                   ('week', 'Every Week'),
+                                   ('days', 'Every Day')],
+                                  string='Recurrence', required=True, index=True, default='specific')
+    partner_id = fields.Many2one('res.partner', string="Vendor",
+                                 help="If specified, the selected vendor can be ordered only on selected days")
+    specific_day = fields.Date('Day', default=fields.Date.context_today)
+    monday = fields.Boolean('Monday')
+    tuesday = fields.Boolean('Tuesday')
+    wednesday = fields.Boolean('Wednesday')
+    thursday = fields.Boolean('Thursday')
+    friday = fields.Boolean('Friday')
+    saturday = fields.Boolean('Saturday')
+    sunday = fields.Boolean('Sunday')
+    start_hour = fields.Float('Between', oldname='active_from', required=True, default=7)
+    end_hour = fields.Float('And', oldname='active_to', required=True, default=23)
+    active = fields.Boolean(default=True)
+
+    @api.multi
+    def name_get(self):
+        return [(alert.id, '%s %s' % (_('Alert'), '#%d' % alert.id)) for alert in self]
+
+    @api.depends('alert_type', 'specific_day', 'monday', 'tuesday', 'thursday',
+                 'friday', 'saturday', 'sunday', 'start_hour', 'end_hour')
+    def _compute_display_get(self):
+        """
+        This method check if the alert can be displayed today
+        if alert type is specific : compare specific_day(date) with today's date
+        if alert type is week : check today is set as alert (checkbox true) eg. self['monday']
+        if alert type is day : True
+        return : Message if can_display_alert is True else False
+        """
+        days_codes = {'0': 'sunday',
+                      '1': 'monday',
+                      '2': 'tuesday',
+                      '3': 'wednesday',
+                      '4': 'thursday',
+                      '5': 'friday',
+                      '6': 'saturday'}
+        fullday = False
+        now = datetime.datetime.now()
+        if self.env.context.get('lunch_date'):
+            # lunch_date is a fields.Date -> 00:00:00
+            lunch_date = fields.Datetime.from_string(self.env.context['lunch_date'])
+            # if lunch_date is in the future, planned lunch, ignore hours
+            fullday = lunch_date > now
+            now = max(lunch_date, now)
+        mynow = fields.Datetime.context_timestamp(self, now)
+
+        for alert in self:
+            can_display_alert = {
+                'specific': (str(alert.specific_day) == fields.Date.to_string(mynow)),
+                'week': alert[days_codes[mynow.strftime('%w')]],
+                'days': True
+            }
+
+            if can_display_alert[alert.alert_type]:
+                hour_to = int(alert.end_hour)
+                min_to = int((alert.end_hour - hour_to) * 60)
+                to_alert = datetime.time(hour_to, min_to)
+                hour_from = int(alert.start_hour)
+                min_from = int((alert.start_hour - hour_from) * 60)
+                from_alert = datetime.time(hour_from, min_from)
+
+                if fullday or (from_alert <= mynow.time() <= to_alert):
+                    alert.display = True
+                else:
+                    alert.display = False

--- a/addons/lunch/models/lunch_cashmove.py
+++ b/addons/lunch/models/lunch_cashmove.py
@@ -2,7 +2,6 @@
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
 from odoo import api, fields, models, _
-from odoo.tools import float_round
 
 
 class LunchCashMove(models.Model):
@@ -15,14 +14,10 @@ class LunchCashMove(models.Model):
     date = fields.Date('Date', required=True, default=fields.Date.context_today)
     amount = fields.Float('Amount', required=True, help='Can be positive (payment) or negative (order or payment if user wants to get his money back)')
     description = fields.Text('Description', help='Can be an order or a payment')
-    order_line_id = fields.Many2one('lunch.order.line', 'Order', ondelete='cascade')
+    order_id = fields.Many2one('lunch.order.line', 'Order', ondelete='cascade')
     state = fields.Selection([('order', 'Order'), ('payment', 'Payment')],
                              'Is an order or a payment', default='payment')
 
     @api.multi
     def name_get(self):
         return [(cashmove.id, '%s %s' % (_('Lunch Cashmove'), '#%d' % cashmove.id)) for cashmove in self]
-
-    @api.model
-    def get_wallet_balance(self, user):
-        return float_round(sum(move['amount'] for move in self.search_read([('user_id', '=', user.id)], ['amount'])), precision_digits=2)

--- a/addons/lunch/models/lunch_order.py
+++ b/addons/lunch/models/lunch_order.py
@@ -1,15 +1,19 @@
 # -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
+from collections import OrderedDict
+
+import json
+
 from odoo import api, fields, models, _
-from odoo.exceptions import UserError, ValidationError
+from odoo.exceptions import AccessError, ValidationError
 from odoo.addons import decimal_precision as dp
 
 
 class LunchOrder(models.Model):
     """
     A lunch order contains one or more lunch order line(s). It is associated to a user for a given
-    date.
+    date. When creating a lunch order, applicable lunch alerts are displayed.
     """
     _name = 'lunch.order'
     _description = 'Lunch Order'
@@ -35,29 +39,24 @@ class LunchOrder(models.Model):
                                      states={'new': [('readonly', False)], False: [('readonly', False)]})
     total = fields.Float(compute='_compute_total', string="Total", store=True)
     state = fields.Selection([('new', 'New'),
-                              ('ordered', 'Ordered'),
                               ('confirmed', 'Received'),
                               ('cancelled', 'Cancelled')],
-                             'Status', readonly=True, index=True, copy=False, default='new')
+                             'Status', readonly=True, index=True, copy=False,
+                             compute='_compute_order_state', store=True)
+    alerts = fields.Text(compute='_compute_alerts_get', string="Alerts")
     company_id = fields.Many2one('res.company', related='user_id.company_id', store=True, readonly=False)
     currency_id = fields.Many2one('res.currency', related='company_id.currency_id', readonly=True, store=True)
     cash_move_balance = fields.Monetary(compute='_compute_cash_move_balance', multi='cash_move_balance')
     balance_visible = fields.Boolean(compute='_compute_cash_move_balance', multi='cash_move_balance')
+    previous_order_ids = fields.Many2many('lunch.order.line', compute='_compute_previous_order')
+    previous_order_widget = fields.Text(compute='_compute_previous_order')
 
-    mail_sent = fields.Boolean('Mail Sent', readonly=True)
-    supplier_ids = fields.Many2many('lunch.supplier', compute='_compute_supplier_ids', store=True)
-
-    @api.depends('order_line_ids', 'order_line_ids.supplier_id', 'order_line_ids.product_id')
-    def _compute_supplier_ids(self):
-        for order in self:
-            order.supplier_ids = order.mapped('order_line_ids.supplier_id')
-
-    @api.depends('order_line_ids', 'order_line_ids.quantity', 'order_line_ids.price')
+    @api.one
+    @api.depends('order_line_ids')
     def _compute_total(self):
         """
         get and sum the order lines' price
         """
-        self.ensure_one()
         self.total = sum(
             orderline.price for orderline in self.order_line_ids)
 
@@ -65,55 +64,96 @@ class LunchOrder(models.Model):
     def name_get(self):
         return [(order.id, '%s %s' % (_('Lunch Order'), '#%d' % order.id)) for order in self]
 
+    @api.depends('state')
+    def _compute_alerts_get(self):
+        """
+        get the alerts to display on the order form
+        """
+        alert_msg = [alert.message
+                     for alert in self.env['lunch.alert'].search([])
+                     if alert.display]
+
+        if self.state == 'new':
+            self.alerts = alert_msg and '\n'.join(alert_msg) or False
+
+    @api.multi
+    @api.depends('user_id', 'state')
+    def _compute_previous_order(self):
+        self.ensure_one()
+        self.previous_order_widget = json.dumps(False)
+
+        prev_order = self.env['lunch.order.line'].search([('user_id', '=', self.env.uid), ('product_id.active', '!=', False)], limit=20, order='date desc, id desc')
+        # If we use prev_order.ids, we will have duplicates (identical orders).
+        # Therefore, this following part removes duplicates based on product_id and note.
+        self.previous_order_ids = list({
+            (order.product_id, order.note): order.id
+            for order in prev_order
+        }.values())
+
+        if self.previous_order_ids:
+            lunch_data = {}
+            for line in self.previous_order_ids:
+                lunch_data[line.id] = {
+                    'line_id': line.id,
+                    'product_id': line.product_id.id,
+                    'product_name': line.product_id.name,
+                    'supplier': line.supplier.name,
+                    'note': line.note,
+                    'price': line.price,
+                    'date': fields.Date.to_string(line.date),
+                    'currency_id': line.currency_id.id,
+                }
+            # sort the old lunch orders by (date, id)
+            lunch_data = OrderedDict(sorted(lunch_data.items(), key=lambda t: (t[1]['date'], t[0]), reverse=True))
+            self.previous_order_widget = json.dumps(lunch_data)
+
+    @api.one
     @api.depends('user_id')
     def _compute_cash_move_balance(self):
-        self.ensure_one()
         domain = [('user_id', '=', self.user_id.id)]
         lunch_cash = self.env['lunch.cashmove'].read_group(domain, ['amount', 'user_id'], ['user_id'])
-        if lunch_cash:
+        if len(lunch_cash):
             self.cash_move_balance = lunch_cash[0]['amount']
         self.balance_visible = (self.user_id == self.env.user) or self.user_has_groups('lunch.group_lunch_manager')
 
+    @api.one
     @api.constrains('date')
     def _check_date(self):
         """
         Prevents the user to create an order in the past
         """
-        self.ensure_one()
         date_order = self.date
         date_today = fields.Date.context_today(self)
         if date_order < date_today:
             raise ValidationError(_('The date of your order is in the past.'))
 
-    def action_order(self):
-        for order in self:
-            for line in order.order_line_ids:
-                self.env['lunch.cashmove'].sudo().create({
-                    'user_id': line.user_id.id,
-                    'amount': -line.price,
-                    'description': line.product_id.name,
-                    'order_line_id': line.id,
-                    'state': 'order',
-                    'date': line.date,
-                })
-
-        self.mapped('order_line_ids').write({'state': 'ordered'})
-        self.write({'state': 'ordered'})
+    @api.one
+    @api.depends('order_line_ids.state')
+    def _compute_order_state(self):
+        """
+        Update the state of lunch.order based on its orderlines. Here is the logic:
+        - if at least one order line is cancelled, the order is set as cancelled
+        - if no line is cancelled but at least one line is not confirmed, the order is set as new
+        - if all lines are confirmed, the order is set as confirmed
+        """
+        if not self.order_line_ids:
+            self.state = 'new'
+        else:
+            isConfirmed = True
+            for orderline in self.order_line_ids:
+                if orderline.state == 'cancelled':
+                    self.state = 'cancelled'
+                    return
+                elif orderline.state == 'confirmed':
+                    continue
+                else:
+                    isConfirmed = False
 
-    def action_confirm(self, supplier=None):
-        for order in self:
-            if supplier:
-                order.order_line_ids.filtered(lambda line: line.state == 'ordered' and line.supplier_id == supplier).write({'state': 'confirmed'})
+            if isConfirmed:
+                self.state = 'confirmed'
             else:
-                order.order_line_ids.filtered(lambda line: line.state == 'ordered').write({'state': 'confirmed'})
-            order.write({'state': 'confirmed',
-                         'mail_sent': True})
-
-    def action_cancel(self):
-        for order in self:
-            # RLI FIXME maybe we don't need to filter
-            order.order_line_ids.filtered(lambda line: line.state != 'confirmed').action_cancel()
-            order.write({'state': 'cancelled'})
+                self.state = 'new'
+        return
 
 
 class LunchOrderLine(models.Model):
@@ -123,58 +163,153 @@ class LunchOrderLine(models.Model):
 
     name = fields.Char(related='product_id.name', string="Product Name", readonly=True)
     order_id = fields.Many2one('lunch.order', 'Order', ondelete='cascade', required=True)
-    topping_ids = fields.Many2many('lunch.product', string='Toppings')
-    product_id = fields.Many2one('lunch.product', string="Product", domain=[('is_topping', '=', False)], required=True)
+    product_id = fields.Many2one('lunch.product', 'Product', required=True,
+                                 domain=[('available', '=', True)])
     category_id = fields.Many2one('lunch.product.category', string='Product Category',
                                   related='product_id.category_id', readonly=True, store=True)
     date = fields.Date(string='Date', related='order_id.date', readonly=True, store=True)
-    supplier_id = fields.Many2one('lunch.supplier', string='Vendor', related='product_id.supplier_id',
-                               readonly=True, store=True, index=True)
+    supplier = fields.Many2one('res.partner', string='Vendor', related='product_id.supplier',
+                               readonly=True, store=True)
     user_id = fields.Many2one('res.users', string='User', related='order_id.user_id',
                               readonly=True, store=True)
     note = fields.Text('Note')
-    price = fields.Float('Total Price', compute='_compute_total_price', readonly=True, store=True,
+    price = fields.Float(related='product_id.price', readonly=True, store=True,
                          digits=dp.get_precision('Account'))
     state = fields.Selection([('new', 'New'),
-                              ('ordered', 'Ordered'),
                               ('confirmed', 'Received'),
+                              ('ordered', 'Ordered'),
                               ('cancelled', 'Cancelled')],
                              'Status', readonly=True, index=True, default='new')
-    cashmove = fields.One2many('lunch.cashmove', 'order_line_id', 'Cash Move')
+    cashmove = fields.One2many('lunch.cashmove', 'order_id', 'Cash Move')
     currency_id = fields.Many2one('res.currency', related='order_id.currency_id', readonly=False)
-    quantity = fields.Float('Quantity', required=True, default=1)
-
-    @api.depends('topping_ids', 'product_id', 'quantity')
-    def _compute_total_price(self):
-        for line in self:
-            line.price = line.quantity * sum(product.price for product in line.product_id | line.topping_ids)
-
-    def update_quantity(self, increment):
-        for line in self:
-            old_cost = line.price
-            line.quantity += increment
-            new_cost = line.price
-            if new_cost - old_cost > self.env['lunch.cashmove'].get_wallet_balance(line.user_id):
-                raise UserError(_('Your wallet does not contain enough money to order that.'
-                                  'To add some money to your wallet, please contact your lunch manager.'))
-            cashmove = self.env['lunch.cashmove'].search([('order_line_id', '=', line.id)], limit=1)
-            if cashmove:
-                cashmove.amount = -new_cost
-            if line.quantity <= 0:
-                order_id = line.order_id
-                line.sudo().unlink()
-                if not order_id.order_line_ids:
-                    order_id.sudo().unlink()
-
-    def action_confirm(self):
-        self.write({'state': 'confirmed'})
-
-        for order in self.mapped('order_id'):
-            if all(line.state == 'confirmed' for line in order.order_line_ids):
-                order.write({'state': 'confirmed', 'mail_sent': True})
-
-    def action_cancel(self):
-        for line in self:
-            line.cashmove.sudo().unlink()
-
-        self.write({'state': 'cancelled'})
+
+    def _check_supplier_availibility(self):
+        products = self.mapped('product_id')
+        if not all(product.available for product in products):
+            supplier_name = ", ".join(product.supplier.display_name for product in products if not product.available)
+            raise ValidationError(_("Vendor(s) '%s' is not available today") % supplier_name)
+
+    @api.model
+    def create(self, vals):
+        """ Override as an onchange would not apply if using the history buttons """
+        res = super(LunchOrderLine, self).create(vals)
+        res.with_context(lunch_date=res.order_id.date)._check_supplier_availibility()
+        return res
+
+    @api.model
+    def write(self, vals):
+        """ Override as an onchange would not apply if using the history buttons """
+        res = super(LunchOrderLine, self).write(vals)
+        if vals.get('product_id'):
+            for line in self:
+                line.with_context(lunch_date=line.order_id.date)._check_supplier_availibility()
+        return res
+
+    def order(self):
+        """
+        The order_line is ordered to the vendor but isn't received yet
+        """
+        if self.user_has_groups("lunch.group_lunch_manager"):
+            self.write({'state': 'ordered'})
+
+            order = {
+                'supplier': False,
+                'company': False,
+                'currency': False,
+            }
+            group_lines = {}
+            for line in self:
+                if not line.supplier:
+                    # do not send emails for products with no suppliers
+                    continue
+
+                if order['supplier'] and line.supplier != order['supplier']:
+                    raise ValidationError(_("Validate order for one supplier at a time to send emails (mixed orders from %s and %s)") % (
+                                            order['supplier'].display_name, line.supplier.display_name))
+                order['supplier'] = line.supplier
+
+                if order['company'] and line.order_id.company_id != order['company']:
+                    raise ValidationError(_("Validate order for one company at a time to send emails (mixed orders from %s and %s)") % (
+                                            order['company'].name, line.order_id.company_id.name))
+                order['company'] = line.order_id.company_id
+
+                if order['currency'] and line.currency_id != order['currency']:
+                    raise ValidationError(_("Validate order for one currency at a time to send emails (mixed orders from %s and %s)") % (
+                                            order['currency'].name, line.currency_id.name))
+                order['currency'] = line.currency_id
+
+                # group the order by products and note
+                key = (line.product_id, line.note)
+                group_lines.setdefault(key, 0)
+                group_lines[key] += 1
+
+            order['company_name'] = order['company'].name
+            order['currency_id'] = order['currency'].id
+            order['supplier_id'] = order['supplier'].id
+            order['supplier_name'] = order['supplier'].name
+            order['supplier_email'] = order['supplier'].email_formatted
+
+            lines = []
+            # sort by product name, note
+            for product, note in sorted(group_lines, key=lambda k: (k[0].name, bool(k[1]))):
+                quantity = group_lines[(product, note)]
+                lines.append({
+                    'product': product.name,
+                    'note': note or '',
+                    'quantity': quantity,
+                    'price': product.price * quantity,
+                })
+
+            order['amount_total'] = sum(l['price'] for l in lines)
+
+            template = self.env.ref('lunch.lunch_order_mail_supplier', raise_if_not_found=False)
+            ctx = dict(
+                default_composition_mode='mass_mail',
+                default_use_template=bool(template),
+                default_template_id=template.id,
+                default_lang=order['supplier'].lang or self.env.user.lang,
+                order=order,
+                lines=lines,
+            )
+            return {
+                'type': 'ir.actions.act_window',
+                'view_type': 'form',
+                'view_mode': 'form',
+                'res_model': 'mail.compose.message',
+                'target': 'new',
+                'context': ctx,
+            }
+
+        else:
+            raise AccessError(_("Only your lunch manager processes the orders."))
+
+    @api.one
+    def confirm(self):
+        """
+        confirm one or more order line, update order status and create new cashmove
+        """
+        if self.user_has_groups("lunch.group_lunch_manager"):
+            if self.state != 'confirmed':
+                values = {
+                    'user_id': self.user_id.id,
+                    'amount': -self.price,
+                    'description': self.product_id.name,
+                    'order_id': self.id,
+                    'state': 'order',
+                    'date': self.date,
+                }
+                self.env['lunch.cashmove'].create(values)
+                self.state = 'confirmed'
+        else:
+            raise AccessError(_("Only your lunch manager sets the orders as received."))
+
+    @api.one
+    def cancel(self):
+        """
+        cancel one or more order.line, update order status and unlink existing cashmoves
+        """
+        if self.user_has_groups("lunch.group_lunch_manager"):
+            self.state = 'cancelled'
+            self.cashmove.unlink()
+        else:
+            raise AccessError(_("Only your lunch manager cancels the orders."))

--- a/addons/lunch/models/lunch_product.py
+++ b/addons/lunch/models/lunch_product.py
@@ -1,11 +1,10 @@
 # -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
-from dateutil.relativedelta import relativedelta
-
-from odoo import api, fields, models, tools, _
+from odoo import api, fields, models, _
 
 from odoo.addons import decimal_precision as dp
+from odoo.osv import expression
 
 
 class LunchProductCategory(models.Model):
@@ -21,52 +20,44 @@ class LunchProduct(models.Model):
     _name = 'lunch.product'
     _description = 'Lunch Product'
 
-    name = fields.Char('Name', required=True)
-    category_id = fields.Many2one('lunch.product.category', 'Product Category')
+    name = fields.Char('Product', required=True)
+    category_id = fields.Many2one('lunch.product.category', 'Product Category', required=True)
     description = fields.Text('Description')
-    price = fields.Float('Price', digits=dp.get_precision('Account'), required=True)
-    supplier_id = fields.Many2one('lunch.supplier', 'Vendor', required=True)
+    price = fields.Float('Price', digits=dp.get_precision('Account'))
+    supplier = fields.Many2one('res.partner', 'Vendor')
     active = fields.Boolean(default=True)
-    is_topping = fields.Boolean("This product is an extra garniture")
-
-    # image: all image fields are base64 encoded and PIL-supported
-    image = fields.Binary(
-        "Image", attachment=True,
-        help="This field holds the image used as image for the product, limited to 1024x1024px.")
-    image_medium = fields.Binary(
-        "Medium-sized image", attachment=True,
-        help="Medium-sized image of the product. It is automatically "
-             "resized as a 128x128px image, with aspect ratio preserved, "
-             "only when the image exceeds one of those sizes. Use this field in form views or some kanban views.")
-    image_small = fields.Binary(
-        "Small-sized image", attachment=True,
-        help="Small-sized image of the product. It is automatically "
-             "resized as a 64x64px image, with aspect ratio preserved. "
-             "Use this field anywhere a small image is required.")
-
-    already_ordered = fields.Boolean('Has Already Been Ordered', compute='_compute_already_ordered')
-
-    @api.model
-    def search_read(self, domain=None, fields=None, offset=0, limit=None, order=None):
-        res = super(LunchProduct, self).search_read(domain, fields, offset, limit, order)
-
-        if not order and 'already_ordered' in fields:
-            res = sorted(res, key=lambda x: x['already_ordered'], reverse=True)
-
-        return res
-
-    @api.model_create_multi
-    def create(self, vals_list):
-        for values in vals_list:
-            tools.image_resize_images(values)
-        return super(LunchProduct, self).create(vals_list)
-
-    def write(self, values):
-        tools.image_resize_images(values)
-        return super(LunchProduct, self).write(values)
+    available = fields.Boolean(compute='_get_available_product', search='_search_available_products')
 
-    def _compute_already_ordered(self):
-        last_ordered = fields.Date.today() - relativedelta(weeks=2)
+    @api.depends('supplier')
+    def _get_available_product(self):
         for product in self:
-            product.already_ordered = bool(self.env['lunch.order.line'].search_count(
-                [('product_id', '=', product.id), ('date', '>=', last_ordered), ('user_id', '=', self.env.user.id)]))
+            if not product.supplier:
+                product.available = True
+            else:
+                alerts = self.env['lunch.alert'].search([
+                    ('partner_id', '=', self.supplier.id)
+                ])
+                if alerts and not any(alert.display for alert in alerts):
+                    # every alert is not available
+                    product.available = False
+                else:
+                    # no alert for the supplier or at least one is not available
+                    product.available = True
+
+    def _search_available_products(self, operator, value):
+        alerts = self.env['lunch.alert'].search([])
+        supplier_w_alerts = alerts.mapped('partner_id')
+        available_suppliers = alerts.filtered(lambda a: a.display).mapped('partner_id')
+        available_products = self.search([
+            '|',
+                ('supplier', 'not in', supplier_w_alerts.ids),
+                ('supplier', 'in', available_suppliers.ids)
+        ])
+
+        if (operator in expression.NEGATIVE_TERM_OPERATORS and value) or \
+           (operator not in expression.NEGATIVE_TERM_OPERATORS and not value):
+            # e.g. (available = False) or (available != True)
+            return [('id', 'not in', available_products.ids)]
+        else:
+            # e.g. (available = True) or (available != False)
+            return [('id', 'in', available_products.ids)]

--- a/addons/lunch/models/lunch_supplier.py
+++ b/None
@@ -1,180 +0,0 @@
-# -*- coding: utf-8 -*-
-# Part of Odoo. See LICENSE file for full copyright and licensing details.
-
-import math
-import pytz
-
-from datetime import datetime, time
-
-from odoo import api, fields, models
-from odoo.osv import expression
-from odoo.tools import float_round
-
-from odoo.addons.base.models.res_partner import _tz_get
-
-
-WEEKDAY_TO_NAME = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday']
-
-def float_to_time(hours, tz=None):
-    """ Convert a number of hours into a time object. """
-    if hours == 24.0:
-        return time.max
-    fractional, integral = math.modf(hours)
-    res = time(int(integral), int(float_round(60 * fractional, precision_digits=0)), 0)
-    if tz:
-        res = res.replace(tzinfo=pytz.timezone(tz))
-    return res
-
-def time_to_float(t):
-    return float_round(t.hour + t.minute/60 + t.second/3600, precision_digits=2)
-
-class LunchSupplier(models.Model):
-    _name = 'lunch.supplier'
-    _description = 'Lunch Supplier'
-
-    partner_id = fields.Many2one('res.partner', string='Linked partner', required=True)
-
-    name = fields.Char('Name', related='partner_id.name')
-    description = fields.Text('Description')
-
-    email = fields.Char(related='partner_id.email')
-    email_formatted = fields.Char(related='partner_id.email_formatted', readonly=True)
-    phone = fields.Char(related='partner_id.phone')
-    street = fields.Char(related='partner_id.street')
-    street2 = fields.Char(related='partner_id.street2')
-    zip_code = fields.Char(related='partner_id.zip')
-    city = fields.Char(related='partner_id.city')
-    state_id = fields.Many2one("res.country.state", related='partner_id.state_id')
-    country_id = fields.Many2one('res.country', related='partner_id.country_id')
-
-    vat = fields.Char(related='partner_id.vat')
-
-    image = fields.Binary(related='partner_id.image', readonly=False)
-    image_medium = fields.Binary(related='partner_id.image_medium', readonly=False)
-    image_small = fields.Binary(related='partner_id.image_small', readonly=False)
-
-    send_by = fields.Selection([
-        ('phone', 'Phone'),
-        ('mail', 'Email'),
-    ], 'Send Order By', default='phone')
-    automatic_email_send = fields.Boolean('Automatic Email Sending')
-    automatic_email_time = fields.Float('Hour')
-
-    recurrency = fields.Selection([('once', 'Specific Day'), ('reccurent', 'Reccurent')], 'Recurrency', default='once')
-    recurrency_from = fields.Float('From')
-    recurrency_to = fields.Float('To')
-    recurrency_date = fields.Date('Day', default=fields.Date.today())
-    recurrency_date_from = fields.Datetime('from', compute='_compute_recurrency_date_from', store=True)
-    recurrency_date_to = fields.Datetime('to', compute='_compute_recurrency_date_to', store=True)
-    recurrency_monday = fields.Boolean('Monday')
-    recurrency_tuesday = fields.Boolean('Tuesday')
-    recurrency_wednesday = fields.Boolean('Wednesday')
-    recurrency_thursday = fields.Boolean('Thursday')
-    recurrency_friday = fields.Boolean('Friday')
-    recurrency_saturday = fields.Boolean('Saturday')
-    recurrency_sunday = fields.Boolean('Sunday')
-
-    available_today = fields.Boolean('This is True when if the supplier is available today',
-                                     compute='_compute_available_today', search='_search_available_today')
-
-    tz = fields.Selection(_tz_get, string='Timezone', required=True, default='UTC')
-
-    _sql_constraints = [
-        ('automatic_email_time_range', 'CHECK(automatic_email_time >= 0 AND automatic_email_time <= 24)', 'Automatic Email Sending Time should be between 0 and 24'),
-        ('recurrency_from', 'CHECK(recurrency_from >= 0 AND recurrency_from <= 24)', 'Recurrency From should be between 0 and 24'),
-        ('recurrency_to', 'CHECK(recurrency_to >= 0 AND recurrency_to <= 24)', 'Recurrency To should be between 0 and 24')
-    ]
-
-    @api.model
-    def _auto_email_send(self):
-        """
-            This method is called every 10 minutes via a cron.
-            Its job is simply to get all the orders made for each supplier and send an email
-            automatically to the supplier if the supplier is configured for it and we are ready
-            to send it (usually at 11am or so)
-        """
-        records = self.search([('automatic_email_send', '=', True)])
-
-        for supplier in records:
-            send_at = datetime.combine(fields.Date.today(), float_to_time(supplier.automatic_email_time, supplier.tz)).astimezone(pytz.UTC).replace(tzinfo=None)
-            if supplier.available_today and fields.Datetime.now() > send_at:
-                orders = self.env['lunch.order'].search([('mail_sent', '=', False), ('supplier_ids', 'in', [supplier.id]), ('state', '=', 'ordered')])
-
-                if orders:
-                    order = {
-                        'company_name': orders[0].company_id.name,
-                        'currency_id': orders[0].currency_id.id,
-                        'supplier_id': supplier.partner_id.id,
-                        'supplier_name': supplier.name,
-                        'supplier_email': supplier.email_formatted
-                    }
-
-                    lines = orders.mapped('order_line_ids').filtered(lambda line: line.supplier_id == supplier)
-                    lines = [{'product': line.product_id.name, 'note': line.note, 'quantity': line.quantity, 'price': line.price} for line in lines]
-
-                    order['amount_total'] = sum(line['price'] for line in lines)
-
-                    self.env.ref('lunch.lunch_order_mail_supplier').with_context(order=order, lines=lines).send_mail(supplier.id)
-
-                    orders.action_confirm(supplier)
-
-    @api.depends('recurrency_date', 'recurrency_from')
-    def _compute_recurrency_date_from(self):
-        for supplier in self:
-            if supplier.recurrency_date and supplier.recurrency_from:
-                supplier.recurrency_date_from = datetime.combine(supplier.recurrency_date, float_to_time(supplier.recurrency_from))
-
-    @api.depends('recurrency_date', 'recurrency_to')
-    def _compute_recurrency_date_to(self):
-        for supplier in self:
-            if supplier.recurrency_date and supplier.recurrency_to:
-                supplier.recurrency_date_to = datetime.combine(supplier.recurrency_date, float_to_time(supplier.recurrency_to))
-
-    @api.depends('recurrency', 'recurrency_date', 'recurrency_from', 'recurrency_to', 'recurrency_monday',
-                 'recurrency_tuesday', 'recurrency_wednesday', 'recurrency_thursday',
-                 'recurrency_friday', 'recurrency_saturday', 'recurrency_sunday')
-    def _compute_available_today(self):
-        now = fields.Datetime.now().replace(tzinfo=pytz.UTC)
-
-        for supplier in self:
-            now = now.astimezone(pytz.timezone(supplier.tz))
-            time_from = float_to_time(supplier.recurrency_from)
-            time_to = float_to_time(supplier.recurrency_to)
-
-            if supplier.recurrency == 'once':
-                supplier.available_today = (supplier.reccurrency_date_from <= now <= supplier.reccurrency_date_to)
-            else:
-                fieldname = 'recurrency_%s' % (WEEKDAY_TO_NAME[now.weekday()])
-                supplier.available_today = supplier[fieldname] and (time_from <= now.time() <= time_to)
-
-    def _search_available_today(self, operator, value):
-        if (not operator in ['=', '!=']) or (not value in [True, False]):
-            return []
-
-        searching_for_true = (operator == '=' and value) or (operator == '!=' and not value)
-        now = fields.Datetime.now()
-        float_now = time_to_float(now.time())
-        fieldname = 'recurrency_%s' % (WEEKDAY_TO_NAME[now.weekday()])
-
-        if searching_for_true:
-            specific = expression.AND([
-                [('recurrency', '=', 'once')],
-                [('recurrency_date_from', '<=', now)],
-                [('recurrency_date_to', '>=', now)]
-            ])
-        else:
-            specific = expression.AND([
-                [('recurrency', '=', 'once')],
-                expression.OR([
-                    [('recurrency_date_from', '>=', now)],
-                    [('recurrency_date_to', '<=', now)]
-                ])
-            ])
-
-        recurrence = expression.AND([
-            [(fieldname, operator, value)],
-            [('recurrency_from', '<=' if searching_for_true else '>=', float_now)],
-            [('recurrency_to', '>=' if searching_for_true else '<=', float_now)]
-        ])
-
-        return expression.OR([specific, recurrence])
