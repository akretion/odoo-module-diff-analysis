PR: https://github.com/odoo/odoo/pull/

From: b6f053b25ef80599086797a41521c9e5679a015e
From: Simon Lejeune
Date: 2019-09-03 15:05:03

Structural Changes: 93.5
Total Changes: 806

[REF] stock: multi company

Ensure proper domains are applied and enforced on relation fields thanks
to the `check_company` attributes.

product.template
- make responsible a property field in order to ensure proper next activities when a product
  is used between multiple companies
stock.putaway.rule
- added a company_id field
stock.move.line
- company_id is not related anymore since a move line can exist without a move until its validation
stock.package_level
- added a company_id field
stock.picking.type
- company_id is now required
stock.production.lot
- added a company_id field, adapted the constraint accordingly
stock.quant
- check the consistency only in inventory mode
stock.quant.package
- company_id is now empty if the package is empty
stock.picking
- company_id is now related to the one of its picking type

Added some tests.
Moved stock_traceability in the `report` directory.
Removed useless /tests/tours/route.js.

task-1985992

================================= pseudo patch: =================================

--- a/addons/stock/models/__init__.py
+++ b/addons/stock/models/__init__.py
@@ -14,7 +14,6 @@ from . import stock_production_lot
 from . import stock_picking
 from . import stock_quant
 from . import stock_rule
-from . import stock_traceability
 from . import stock_warehouse
 from . import stock_scrap
 from . import product

--- a/addons/stock/models/product.py
+++ b/addons/stock/models/product.py
@@ -548,18 +548,20 @@ class Product(models.Model):
 
 class ProductTemplate(models.Model):
     _inherit = 'product.template'
+    _check_company_auto = True
 
     responsible_id = fields.Many2one(
-        'res.users', string='Responsible', default=lambda self: self.env.uid,
+        'res.users', string='Responsible', default=lambda self: self.env.uid, company_dependent=True, check_company=True,
+        domain="['|', ('company_id', '=', False), ('company_ids', 'in', allowed_company_ids[0])]",
         help="This user will be responsible of the next activities related to logistic operations for this product.")
     type = fields.Selection(selection_add=[('product', 'Storable Product')])
     property_stock_production = fields.Many2one(
         'stock.location', "Production Location",
-        company_dependent=True, domain=[('usage', 'like', 'production')],
+        company_dependent=True, check_company=True, domain="[('usage', '=', 'production'), '|', ('company_id', '=', False), ('company_id', '=', allowed_company_ids[0])]",
         help="This stock location will be used, instead of the default one, as the source location for stock moves generated by manufacturing orders.")
     property_stock_inventory = fields.Many2one(
         'stock.location', "Inventory Location",
-        company_dependent=True, domain=[('usage', 'like', 'inventory')],
+        company_dependent=True, check_company=True, domain="[('usage', '=', 'inventory'), '|', ('company_id', '=', False), ('company_id', '=', allowed_company_ids[0])]",
         help="This stock location will be used, instead of the default one, as the source location for stock moves generated when you do an inventory.")
     sale_delay = fields.Float(
         'Customer Lead Time', default=0,
@@ -850,3 +852,4 @@ class UoM(models.Model):
         else:
             computed_qty = self._compute_quantity(qty, procurement_uom, rounding_method='HALF-UP')
         return (computed_qty, procurement_uom)
+

--- a/addons/stock/models/product_strategy.py
+++ b/addons/stock/models/product_strategy.py
@@ -1,7 +1,8 @@
 # -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
-from odoo import fields, models, api
+from odoo import fields, models, api, _
+from odoo.exceptions import UserError
 
 
 class RemovalStrategy(models.Model):
@@ -16,6 +17,7 @@ class StockPutawayRule(models.Model):
     _name = 'stock.putaway.rule'
     _order = 'sequence,product_id'
     _description = 'Putaway Rule'
+    _check_company_auto = True
 
     def _default_category_id(self):
         if self.env.context.get('active_model') == 'product.category':
@@ -44,19 +46,28 @@ class StockPutawayRule(models.Model):
         return []
 
     def _domain_product_id(self):
+        domain = "[('type', '!=', 'service'), '|', ('company_id', '=', False), ('company_id', '=', company_id)]"
         if self.env.context.get('active_model') == 'product.template':
             return [('product_tmpl_id', '=', self.env.context.get('active_id'))]
-        return []
+        return domain
 
-    product_id = fields.Many2one('product.product', 'Product',
+    product_id = fields.Many2one(
+        'product.product', 'Product', check_company=True,
         default=_default_product_id, domain=_domain_product_id, ondelete='cascade')
     category_id = fields.Many2one('product.category', 'Product Category',
         default=_default_category_id, domain=_domain_category_id, ondelete='cascade')
-    location_in_id = fields.Many2one('stock.location', 'When product arrives in',
+    location_in_id = fields.Many2one(
+        'stock.location', 'When product arrives in', check_company=True,
+        domain="[('child_ids', '!=', False), '|', ('company_id', '=', False), ('company_id', '=', company_id)]",
         default=_default_location_id, required=True, ondelete='cascade')
-    location_out_id = fields.Many2one('stock.location', 'Store to',
+    location_out_id = fields.Many2one(
+        'stock.location', 'Store to', check_company=True,
+        domain="[('id', 'child_of', location_in_id), ('id', '!=', location_in_id), '|', ('company_id', '=', False), ('company_id', '=', company_id)]",
         required=True, ondelete='cascade')
     sequence = fields.Integer('Priority', help="Give to the more specialized category, a higher priority to have them in top of the list.")
+    company_id = fields.Many2one(
+        'res.company', 'Company', required=True,
+        default=lambda s: s.env.company.id, index=True)
 
     @api.onchange('location_in_id')
     def _onchange_location_in(self):
@@ -68,3 +79,11 @@ class StockPutawayRule(models.Model):
             ])
             if not child_location_count:
                 self.location_out_id = None
+
+    def write(self, vals):
+        if 'company_id' in vals:
+            for rule in self:
+                if rule.company_id.id != vals['company_id']:
+                    raise UserError(_("Changing the company of this record is forbidden at this point, you should rather archive it and create a new one."))
+        return super(StockPutawayRule, self).write(vals)
+

--- a/addons/stock/models/res_company.py
+++ b/addons/stock/models/res_company.py
@@ -6,6 +6,7 @@ from odoo import api, fields, models, _
 
 class Company(models.Model):
     _inherit = "res.company"
+    _check_company_auto = True
 
     def _default_confirmation_mail_template(self):
         try:
@@ -14,7 +15,7 @@ class Company(models.Model):
             return False
 
     internal_transit_location_id = fields.Many2one(
-        'stock.location', 'Internal Transit Location', ondelete="restrict",
+        'stock.location', 'Internal Transit Location', ondelete="restrict", check_company=True,
         help="Technical field used for resupply routes between warehouses that belong to this company")
     stock_move_email_validation = fields.Boolean("Email Confirmation picking", default=False)
     stock_mail_confirmation_template_id = fields.Many2one('mail.template', string="Email Template confirmation picking",
@@ -169,10 +170,19 @@ class Company(models.Model):
         self.ensure_one()
         self._create_scrap_sequence()
 
+    def _create_per_company_picking_types(self):
+        self.ensure_one()
+
+    def _create_per_company_rules(self):
+        self.ensure_one()
+
     @api.model
     def create(self, vals):
         company = super(Company, self).create(vals)
         company.sudo()._create_per_company_locations()
         company.sudo()._create_per_company_sequences()
+        company.sudo()._create_per_company_picking_types()
+        company.sudo()._create_per_company_rules()
         self.env['stock.warehouse'].sudo().create({'name': company.name, 'code': company.name[:5], 'company_id': company.id, 'partner_id': company.partner_id.id})
         return company
+

--- a/addons/stock/models/res_partner.py
+++ b/addons/stock/models/res_partner.py
@@ -7,13 +7,16 @@ from odoo.addons.base.models.res_partner import WARNING_MESSAGE, WARNING_HELP
 
 class Partner(models.Model):
     _inherit = 'res.partner'
+    _check_company_auto = True
 
     property_stock_customer = fields.Many2one(
-        'stock.location', string="Customer Location", company_dependent=True,
+        'stock.location', string="Customer Location", company_dependent=True, check_company=True,
+        domain="['|', ('company_id', '=', False), ('company_id', '=', allowed_company_ids[0])]",
         help="The stock location used as destination when sending goods to this contact.")
     property_stock_supplier = fields.Many2one(
-        'stock.location', string="Vendor Location", company_dependent=True,
+        'stock.location', string="Vendor Location", company_dependent=True, check_company=True,
+        domain="['|', ('company_id', '=', False), ('company_id', '=', allowed_company_ids[0])]",
         help="The stock location used as source when receiving goods from this contact.")
     picking_warn = fields.Selection(WARNING_MESSAGE, 'Stock Picking', help=WARNING_HELP, default='no-message')
-    # TDE FIXME: expand this message / help
     picking_warn_msg = fields.Text('Message for Stock Picking')
+

--- a/addons/stock/models/stock_inventory.py
+++ b/addons/stock/models/stock_inventory.py
@@ -12,20 +12,6 @@ class Inventory(models.Model):
     _description = "Inventory"
     _order = "date desc, id desc"
 
-    @api.model
-    def _default_location_ids(self):
-        # If the multilocation group is not active, default the location to the one of the main
-        # warehouse.
-        if not self.user_has_groups('stock.group_stock_multi_locations'):
-            company_user = self.env.company
-            warehouse = self.env['stock.warehouse'].search([('company_id', '=', company_user.id)], limit=1)
-            if warehouse:
-                return [(4, warehouse.lot_stock_id.id)]
-
-    @api.model
-    def _domain_location_ids(self):
-        return [('company_id', '=', self.env.company.id), ('usage', 'in', ['internal', 'transit'])]
-
     name = fields.Char(
         'Inventory Reference', default="Inventory",
         readonly=True, required=True,
@@ -57,13 +43,12 @@ class Inventory(models.Model):
         default=lambda self: self.env.company)
     location_ids = fields.Many2many(
         'stock.location', string='Locations',
-        readonly=True,
+        readonly=True, check_company=True,
         states={'draft': [('readonly', False)]},
-        default=lambda self: self._default_location_ids(),
-        domain=lambda self: self._domain_location_ids())
+        domain="[('company_id', '=', company_id), ('usage', 'in', ['internal', 'transit'])]")
     product_ids = fields.Many2many(
-        'product.product', string='Products',
-        domain=[('type', '=', 'product')], readonly=True,
+        'product.product', string='Products', check_company=True,
+        domain="[('type', '=', 'product'), '|', ('company_id', '=', False), ('company_id', '=', company_id)]", readonly=True,
         states={'draft': [('readonly', False)]},
         help="Specify Products to focus your inventory on particular Products.")
     start_empty = fields.Boolean('Empty Inventory',
@@ -73,6 +58,15 @@ class Inventory(models.Model):
         "with all counted quantity set to zero.", default='counted',
         selection=[('counted', 'Default to stock on hand'), ('zero', 'Default to zero')])
 
+    @api.onchange('company_id')
+    def _onchange_company_id(self):
+        # If the multilocation group is not active, default the location to the one of the main
+        # warehouse.
+        if not self.user_has_groups('stock.group_stock_multi_locations'):
+            warehouse = self.env['stock.warehouse'].search([('company_id', '=', self.company_id.id)], limit=1)
+            if warehouse:
+                self.location_ids = warehouse.lot_stock_id
+
     def copy_data(self, default=None):
         name = _("%s (copy)") % (self.name)
         default = dict(default or {}, name=name)
@@ -108,7 +102,10 @@ class Inventory(models.Model):
                 'target': 'new',
                 'res_id': wiz.id,
             }
-        return self._action_done()
+        self._action_done()
+        self.line_ids._check_company()
+        self._check_company()
+        return True
 
     def _action_done(self):
         negative = next((line for line in self.mapped('line_ids') if line.product_qty < 0 and line.product_qty != line.theoretical_qty), False)
@@ -141,6 +138,7 @@ class Inventory(models.Model):
     def action_start(self):
         self.ensure_one()
         self._action_start()
+        self._check_company()
         return self.action_open_inventory_lines()
 
     def _action_start(self):
@@ -171,6 +169,7 @@ class Inventory(models.Model):
         context = {
             'default_is_editable': True,
             'default_inventory_id': self.id,
+            'default_company_id': self.company_id.id,
         }
         # Define domains and context
         domain = [
@@ -210,7 +209,7 @@ class Inventory(models.Model):
         if self.location_ids:
             locations = self.env['stock.location'].search([('id', 'child_of', self.location_ids.ids)])
         else:
-            locations = self.env['stock.location'].search(self._domain_location_ids())
+            locations = self.env['stock.location'].search([('company_id', '=', self.company_id.id), ('usage', 'in', ['internal', 'transit'])])
         domain = ' location_id in %s AND quantity != 0 AND active = TRUE'
         args = (tuple(locations.ids),)
 
@@ -237,6 +236,7 @@ class Inventory(models.Model):
             GROUP BY product_id, location_id, lot_id, package_id, partner_id """ % domain, args)
 
         for product_data in self.env.cr.dictfetchall():
+            product_data['company_id'] = self.company_id.id
             product_data['inventory_id'] = self.id
             # replace the None the dictionary by False, because falsy values are tested later on
             for void_field in [item[0] for item in product_data.items() if item[1] is None]:
@@ -258,35 +258,27 @@ class InventoryLine(models.Model):
 
     @api.model
     def _domain_location_id(self):
-        domain = self.env['stock.inventory']._domain_location_ids()
         if self.env.context.get('active_model') == 'stock.inventory':
             inventory = self.env['stock.inventory'].browse(self.env.context.get('active_id'))
             if inventory.exists() and inventory.location_ids:
-                domain = expression.AND([
-                    domain,
-                    [('id', 'child_of', inventory.location_ids.ids)]
-                ])
-        return domain
+                return "[('company_id', '=', company_id), ('usage', 'in', ['internal', 'transit']), ('id', 'child_of', %s)]" % inventory.location_ids.ids
+        return "[('company_id', '=', company_id), ('usage', 'in', ['internal', 'transit'])]"
 
     @api.model
     def _domain_product_id(self):
-        domain = [('type', '=', 'product')]
         if self.env.context.get('active_model') == 'stock.inventory':
             inventory = self.env['stock.inventory'].browse(self.env.context.get('active_id'))
             if inventory.exists() and len(inventory.product_ids) > 1:
-                domain = expression.AND([
-                    domain,
-                    [('id', 'in', inventory.product_ids.ids)]
-                ])
-        return domain
+                return "[('type', '=', 'product'), '|', ('company_id', '=', False), ('company_id', '=', company_id), ('id', 'in', %s)]" % inventory.product_ids.ids
+        return "[('type', '=', 'product'), '|', ('company_id', '=', False), ('company_id', '=', company_id)]"
 
     is_editable = fields.Boolean(help="Technical field to restrict the edition.")
     inventory_id = fields.Many2one(
-        'stock.inventory', 'Inventory',
+        'stock.inventory', 'Inventory', check_company=True,
         index=True, ondelete='cascade')
-    partner_id = fields.Many2one('res.partner', 'Owner')
+    partner_id = fields.Many2one('res.partner', 'Owner', check_company=True)
     product_id = fields.Many2one(
-        'product.product', 'Product',
+        'product.product', 'Product', check_company=True,
         domain=lambda self: self._domain_product_id(),
         index=True, required=True)
     product_uom_id = fields.Many2one(
@@ -297,14 +289,16 @@ class InventoryLine(models.Model):
         digits='Product Unit of Measure', default=0)
     categ_id = fields.Many2one(related='product_id.categ_id', store=True)
     location_id = fields.Many2one(
-        'stock.location', 'Location',
+        'stock.location', 'Location', check_company=True,
         domain=lambda self: self._domain_location_id(),
         index=True, required=True)
     package_id = fields.Many2one(
-        'stock.quant.package', 'Pack', index=True)
+        'stock.quant.package', 'Pack', index=True, check_company=True,
+        domain="[('location_id', '=', location_id)]",
+    )
     prod_lot_id = fields.Many2one(
-        'stock.production.lot', 'Lot/Serial Number',
-        domain="[('product_id','=',product_id)]")
+        'stock.production.lot', 'Lot/Serial Number', check_company=True,
+        domain="[('product_id','=',product_id), ('company_id', '=', company_id)]")
     company_id = fields.Many2one(
         'res.company', 'Company', related='inventory_id.company_id',
         index=True, readonly=True, store=True)
@@ -482,9 +476,9 @@ class InventoryLine(models.Model):
             if float_is_zero(line.difference_qty, precision_rounding=rounding):
                 continue
             if line.difference_qty > 0:  # found more than expected
-                vals = line._get_move_values(line.difference_qty, line.product_id.property_stock_inventory.id, line.location_id.id, False)
+                vals = line._get_move_values(line.difference_qty, line.product_id.with_context(force_company=line.company_id.id).property_stock_inventory.id, line.location_id.id, False)
             else:
-                vals = line._get_move_values(abs(line.difference_qty), line.location_id.id, line.product_id.property_stock_inventory.id, True)
+                vals = line._get_move_values(abs(line.difference_qty), line.location_id.id, line.product_id.with_context(force_company=line.company_id.id).property_stock_inventory.id, True)
             vals_list.append(vals)
         return self.env['stock.move'].create(vals_list)
 
@@ -533,3 +527,4 @@ class InventoryLine(models.Model):
         lines = self.search([('inventory_id', '=', self.env.context.get('default_inventory_id'))])
         line_ids = lines.filtered(lambda line: line.outdated == value).ids
         return [('id', 'in', line_ids)]
+

--- a/addons/stock/models/stock_location.py
+++ b/addons/stock/models/stock_location.py
@@ -17,6 +17,7 @@ class Location(models.Model):
     _parent_store = True
     _order = 'complete_name'
     _rec_name = 'complete_name'
+    _check_company_auto = True
 
     @api.model
     def default_get(self, fields):
@@ -45,7 +46,7 @@ class Location(models.Model):
              "\n* Production: Virtual counterpart location for production operations: this location consumes the components and produces finished products"
              "\n* Transit Location: Counterpart location that should be used in inter-company or inter-warehouses operations")
     location_id = fields.Many2one(
-        'stock.location', 'Parent Location', index=True, ondelete='cascade',
+        'stock.location', 'Parent Location', index=True, ondelete='cascade', check_company=True,
         help="The parent location that includes this location. Example : The 'Dispatch Zone' is the 'Gate 1' parent location.")
     child_ids = fields.One2many('stock.location', 'location_id', 'Contains')
     comment = fields.Text('Additional Information')
@@ -81,11 +82,14 @@ class Location(models.Model):
             self.scrap_location = False
 
     def write(self, values):
+        if 'company_id' in values:
+            for location in self:
+                if location.company_id.id != values['company_id']:
+                    raise UserError(_("Changing the company of this record is forbidden at this point, you should rather archive it and create a new one."))
         if 'usage' in values and values['usage'] == 'view':
             if self.mapped('quant_ids'):
                 raise UserError(_("This location's usage cannot be changed to view as it contains products."))
         if 'usage' in values or 'scrap_location' in values:
-
             modified_locations = self.filtered(
                 lambda l: any(l[f] != values[f] if f in values else False
                               for f in {'usage', 'scrap_location'}))
@@ -116,7 +120,6 @@ class Location(models.Model):
                         (','.join(children_quants.mapped('location_id.name'))))
                 else:
                     super(Location, children_location - self).with_context({'do_not_check_quant': True}).write(values)
-
         return super(Location, self).write(values)
 
     def name_get(self):
@@ -179,6 +182,7 @@ class Route(models.Model):
     _name = 'stock.location.route'
     _description = "Inventory Routes"
     _order = 'sequence'
+    _check_company_auto = True
 
     name = fields.Char('Route', required=True, translate=True)
     active = fields.Boolean('Active', default=True, help="If the active field is set to False, it will allow you to hide the route without removing it.")
@@ -193,9 +197,13 @@ class Route(models.Model):
         'res.company', 'Company',
         default=lambda self: self.env.company, index=True,
         help='Leave this field empty if this route is shared between all companies')
-    product_ids = fields.Many2many('product.template', 'stock_route_product', 'route_id', 'product_id', 'Products', copy=False)
+    product_ids = fields.Many2many(
+        'product.template', 'stock_route_product', 'route_id', 'product_id',
+        'Products', copy=False, check_company=True)
     categ_ids = fields.Many2many('product.category', 'stock_location_route_categ', 'route_id', 'categ_id', 'Product Categories', copy=False)
-    warehouse_ids = fields.Many2many('stock.warehouse', 'stock_route_warehouse', 'route_id', 'warehouse_id', 'Warehouses', copy=False)
+    warehouse_ids = fields.Many2many(
+        'stock.warehouse', 'stock_route_warehouse', 'route_id', 'warehouse_id',
+        'Warehouses', copy=False, check_company=True)
 
     @api.onchange('warehouse_selectable')
     def _onchange_warehouse_selectable(self):

--- a/addons/stock/models/stock_move.py
+++ b/addons/stock/models/stock_move.py
@@ -43,7 +43,8 @@ class StockMove(models.Model):
         help="Scheduled date for the processing of this move")
     product_id = fields.Many2one(
         'product.product', 'Product',
-        domain=[('type', 'in', ['product', 'consu'])], index=True, required=True,
+        check_company=True,
+        domain="[('type', 'in', ['product', 'consu']), '|', ('company_id', '=', False), ('company_id', '=', company_id)]", index=True, required=True,
         states={'done': [('readonly', True)]})
     description_picking = fields.Text('Description of Picking')
     product_qty = fields.Float(
@@ -68,16 +69,15 @@ class StockMove(models.Model):
         'product.template', 'Product Template',
         related='product_id.product_tmpl_id', readonly=False,
         help="Technical: used in views")
-    product_packaging = fields.Many2one(
-        'product.packaging', 'Preferred Packaging',
-        help="It specifies attributes of packaging like type, quantity of packaging,etc.")
     location_id = fields.Many2one(
         'stock.location', 'Source Location',
         auto_join=True, index=True, required=True,
+        check_company=True,
         help="Sets a location if you produce at a fixed location. This can be a partner location if you subcontract the manufacturing operations.")
     location_dest_id = fields.Many2one(
         'stock.location', 'Destination Location',
         auto_join=True, index=True, required=True,
+        check_company=True,
         help="Location where the system will stock the finished products.")
     partner_id = fields.Many2one(
         'res.partner', 'Destination Address ',
@@ -91,7 +91,7 @@ class StockMove(models.Model):
         'stock.move', 'stock_move_move_rel', 'move_dest_id', 'move_orig_id', 'Original Move',
         copy=False,
         help="Optional: previous stock move when chaining them")
-    picking_id = fields.Many2one('stock.picking', 'Transfer Reference', index=True, states={'done': [('readonly', True)]})
+    picking_id = fields.Many2one('stock.picking', 'Transfer Reference', index=True, states={'done': [('readonly', True)]}, check_company=True)
     picking_partner_id = fields.Many2one('res.partner', 'Transfer Destination Address', related='picking_id.partner_id', readonly=False)
     note = fields.Text('Notes')
     state = fields.Selection([
@@ -123,7 +123,9 @@ class StockMove(models.Model):
     scrapped = fields.Boolean('Scrapped', related='location_dest_id.scrap_location', readonly=True, store=True)
     scrap_ids = fields.One2many('stock.scrap', 'move_id')
     group_id = fields.Many2one('procurement.group', 'Procurement Group', default=_default_group_id)
-    rule_id = fields.Many2one('stock.rule', 'Stock Rule', ondelete='restrict', help='The stock rule that created this stock move')
+    rule_id = fields.Many2one(
+        'stock.rule', 'Stock Rule', ondelete='restrict', help='The stock rule that created this stock move',
+        check_company=True)
     propagate_cancel = fields.Boolean(
         'Propagate cancel and split', default=True,
         help='If checked, when this move is cancelled, cancel the linked move too')
@@ -132,11 +134,11 @@ class StockMove(models.Model):
     propagate_date_minimum_delta = fields.Integer(string='Reschedule if Higher Than',
         help='The change must be higher than this value to be propagated')
     delay_alert = fields.Boolean('Alert if Delay')
-    picking_type_id = fields.Many2one('stock.picking.type', 'Operation Type')
-    inventory_id = fields.Many2one('stock.inventory', 'Inventory')
+    picking_type_id = fields.Many2one('stock.picking.type', 'Operation Type', check_company=True)
+    inventory_id = fields.Many2one('stock.inventory', 'Inventory', check_company=True)
     move_line_ids = fields.One2many('stock.move.line', 'move_id')
     move_line_nosuggest_ids = fields.One2many('stock.move.line', 'move_id', domain=[('product_qty', '=', 0.0)])
-    origin_returned_move_id = fields.Many2one('stock.move', 'Origin return move', copy=False, help='Move that created the return move')
+    origin_returned_move_id = fields.Many2one('stock.move', 'Origin return move', copy=False, help='Move that created the return move', check_company=True)
     returned_move_ids = fields.One2many('stock.move', 'origin_returned_move_id', 'All returned moves', help='Optional: all returned moves created from this move')
     reserved_availability = fields.Float(
         'Quantity Reserved', compute='_compute_reserved_availability',
@@ -148,8 +150,12 @@ class StockMove(models.Model):
     string_availability_info = fields.Text(
         'Availability', compute='_compute_string_qty_information',
         readonly=True, help='Show various information on stock availability for this move')
-    restrict_partner_id = fields.Many2one('res.partner', 'Owner ', help="Technical field used to depict a restriction on the ownership of quants to consider when marking this move as 'done'")
-    route_ids = fields.Many2many('stock.location.route', 'stock_location_route_move', 'move_id', 'route_id', 'Destination route', help="Preferred route")
+    restrict_partner_id = fields.Many2one(
+        'res.partner', 'Owner ', help="Technical field used to depict a restriction on the ownership of quants to consider when marking this move as 'done'",
+        check_company=True)
+    route_ids = fields.Many2many(
+        'stock.location.route', 'stock_location_route_move', 'move_id', 'route_id', 'Destination route', help="Preferred route",
+        check_company=True)
     warehouse_id = fields.Many2one('stock.warehouse', 'Warehouse', help="Technical field depicting the warehouse to consider for the route selection on the next procurement (if any).")
     has_tracking = fields.Selection(related='product_id.tracking', string='Product with Tracking')
     quantity_done = fields.Float('Quantity Done', compute='_quantity_done_compute', digits='Product Unit of Measure', inverse='_quantity_done_set')
@@ -164,7 +170,7 @@ class StockMove(models.Model):
     is_quantity_done_editable = fields.Boolean('Is quantity done editable', compute='_compute_is_quantity_done_editable')
     reference = fields.Char(compute='_compute_reference', string="Reference", store=True)
     has_move_lines = fields.Boolean(compute='_compute_has_move_lines')
-    package_level_id = fields.Many2one('stock.package_level', 'Package Level')
+    package_level_id = fields.Many2one('stock.package_level', 'Package Level', check_company=True)
     picking_type_entire_packs = fields.Boolean(related='picking_type_id.show_entire_packs', readonly=True)
     display_assign_serial = fields.Boolean(compute='_compute_display_assign_serial')
     next_serial = fields.Char('First SN')
@@ -661,7 +667,7 @@ class StockMove(models.Model):
     @api.model
     def _prepare_merge_moves_distinct_fields(self):
         return [
-            'product_id', 'price_unit', 'product_packaging', 'procure_method',
+            'product_id', 'price_unit', 'procure_method',
             'product_uom', 'restrict_partner_id', 'scrapped', 'origin_returned_move_id',
             'package_level_id', 'propagate_cancel', 'propagate_date', 'propagate_date_minimum_delta',
             'delay_alert',
@@ -671,7 +677,7 @@ class StockMove(models.Model):
     def _prepare_merge_move_sort_method(self, move):
         move.ensure_one()
         return [
-            move.product_id.id, move.price_unit, move.product_packaging.id, move.procure_method, 
+            move.product_id.id, move.price_unit, move.procure_method,
             move.product_uom.id, move.restrict_partner_id.id, move.scrapped, move.origin_returned_move_id.id,
             move.package_level_id.id, move.propagate_cancel, move.propagate_date, move.propagate_date_minimum_delta,
             move.delay_alert,
@@ -940,6 +946,7 @@ class StockMove(models.Model):
         for moves in to_assign.values():
             moves._assign_picking()
         self._push_apply()
+        self._check_company()
         if merge:
             return self._merge_moves(merge_into=merge_into)
         return self
@@ -1288,6 +1295,7 @@ class StockMove(models.Model):
 
             moves_todo |= move._create_extra_move()
 
+        moves_todo._check_company()
         # Split moves where necessary and move quants
         for move in moves_todo:
             # To know whether we need to create a backorder or not, round to the general product's
@@ -1474,3 +1482,4 @@ class StockMove(models.Model):
                 move.procure_method = rules.procure_method
             else:
                 move.procure_method = 'make_to_stock'
+

--- a/addons/stock/models/stock_move_line.py
+++ b/addons/stock/models/stock_move_line.py
@@ -16,31 +16,41 @@ class StockMoveLine(models.Model):
 
     picking_id = fields.Many2one(
         'stock.picking', 'Stock Picking', auto_join=True,
+        check_company=True,
         help='The stock operation where the packing has been made')
     move_id = fields.Many2one(
         'stock.move', 'Stock Move',
+        check_company=True,
         help="Change to a better name", index=True)
-    company_id = fields.Many2one('res.company', string='Company', related='move_id.company_id', store=True, readonly=True)
-    product_id = fields.Many2one('product.product', 'Product', ondelete="cascade")
+    company_id = fields.Many2one('res.company', string='Company', readonly=True, required=True, index=True)
+    product_id = fields.Many2one('product.product', 'Product', ondelete="cascade", check_company=True)
     product_uom_id = fields.Many2one('uom.uom', 'Unit of Measure', required=True)
     product_qty = fields.Float(
         'Real Reserved Quantity', digits=0,
         compute='_compute_product_qty', inverse='_set_product_qty', store=True)
     product_uom_qty = fields.Float('Reserved', default=0.0, digits='Product Unit of Measure', required=True)
     qty_done = fields.Float('Done', default=0.0, digits='Product Unit of Measure', copy=False)
-    package_id = fields.Many2one('stock.quant.package', 'Source Package', ondelete='restrict')
-    package_level_id = fields.Many2one('stock.package_level', 'Package Level')
-    lot_id = fields.Many2one('stock.production.lot', 'Lot/Serial Number')
+    package_id = fields.Many2one(
+        'stock.quant.package', 'Source Package', ondelete='restrict',
+        check_company=True,
+        domain="[('location_id', '=', location_id)]")
+    package_level_id = fields.Many2one('stock.package_level', 'Package Level', check_company=True)
+    lot_id = fields.Many2one(
+        'stock.production.lot', 'Lot/Serial Number',
+        domain="[('product_id', '=', product_id), ('company_id', '=', company_id)]", check_company=True)
     lot_name = fields.Char('Lot/Serial Number Name')
     result_package_id = fields.Many2one(
         'stock.quant.package', 'Destination Package',
-        ondelete='restrict', required=False,
+        ondelete='restrict', required=False, check_company=True,
+        domain="['|', '|', ('location_id', '=', False), ('location_id', '=', location_dest_id), ('id', '=', package_id)]",
         help="If set, the operations are packed into this package")
     date = fields.Datetime('Date', default=fields.Datetime.now, required=True)
-    owner_id = fields.Many2one('res.partner', 'From Owner',
+    owner_id = fields.Many2one(
+        'res.partner', 'From Owner',
+        check_company=True,
         help="When validating the transfer, the products will be taken from this owner.")
-    location_id = fields.Many2one('stock.location', 'From', required=True)
-    location_dest_id = fields.Many2one('stock.location', 'To', required=True)
+    location_id = fields.Many2one('stock.location', 'From', check_company=True, required=True)
+    location_dest_id = fields.Many2one('stock.location', 'To', check_company=True, required=True)
     lots_visible = fields.Boolean(compute='_compute_lots_visible')
     picking_code = fields.Selection(related='picking_id.picking_type_id.code', readonly=True)
     picking_type_use_create_lots = fields.Boolean(related='picking_id.picking_type_id.use_create_lots', readonly=True)
@@ -163,7 +173,10 @@ class StockMoveLine(models.Model):
     @api.model_create_multi
     def create(self, vals_list):
         for vals in vals_list:
-
+            if vals.get('move_id'):
+                vals['company_id'] = self.env['stock.move'].browse(vals['move_id']).company_id.id
+            elif vals.get('picking_id'):
+                vals['company_id'] = self.env['stock.picking'].browse(vals['picking_id']).company_id.id
             # If the move line is directly create on the picking view.
             # If this picking is already done we should generate an
             # associated done move.
@@ -183,7 +196,6 @@ class StockMoveLine(models.Model):
                         'picking_id': picking.id,
                     })
                     vals['move_id'] = new_move.id
-        
         mls = super(StockMoveLine, self).create(vals_list)
 
         for ml in mls:
@@ -400,7 +412,7 @@ class StockMoveLine(models.Model):
                             # `use_create_lots` and `use_existing_lots`.
                             if ml.lot_name and not ml.lot_id:
                                 lot = self.env['stock.production.lot'].create(
-                                    {'name': ml.lot_name, 'product_id': ml.product_id.id}
+                                    {'name': ml.lot_name, 'product_id': ml.product_id.id, 'company_id': ml.move_id.company_id.id}
                                 )
                                 ml.write({'lot_id': lot.id})
                         elif not picking_type_id.use_create_lots and not picking_type_id.use_existing_lots:
@@ -421,6 +433,8 @@ class StockMoveLine(models.Model):
                 ml_to_delete |= ml
         ml_to_delete.unlink()
 
+        (self - ml_to_delete)._check_company()
+
         # Now, we can actually move the quant.
         done_ml = self.env['stock.move.line']
         for ml in self - ml_to_delete:
@@ -545,3 +559,4 @@ class StockMoveLine(models.Model):
     def _should_bypass_reservation(self, location):
         self.ensure_one()
         return location.should_bypass_reservation() or self.product_id.type != 'product'
+

--- a/addons/stock/models/stock_package_level.py
+++ b/addons/stock/models/stock_package_level.py
@@ -9,13 +9,18 @@ from operator import itemgetter
 class StockPackageLevel(models.Model):
     _name = 'stock.package_level'
     _description = 'Stock Package Level'
+    _check_company_auto = True
 
-    package_id = fields.Many2one('stock.quant.package', 'Package', required=True)
-    picking_id = fields.Many2one('stock.picking', 'Picking')
+    package_id = fields.Many2one(
+        'stock.quant.package', 'Package', required=True, check_company=True,
+        domain="[('location_id', 'child_of', parent.location_id), '|', ('company_id', '=', False), ('company_id', '=', company_id)]")
+    picking_id = fields.Many2one('stock.picking', 'Picking', check_company=True)
     move_ids = fields.One2many('stock.move', 'package_level_id')
     move_line_ids = fields.One2many('stock.move.line', 'package_level_id')
-    location_id = fields.Many2one('stock.location', 'From', compute='_compute_location_id')
-    location_dest_id = fields.Many2one('stock.location', 'To')
+    location_id = fields.Many2one('stock.location', 'From', compute='_compute_location_id', check_company=True)
+    location_dest_id = fields.Many2one(
+        'stock.location', 'To', check_company=True,
+        domain="[('id', 'child_of', parent.location_dest_id), '|', ('company_id', '=', False), ('company_id', '=', company_id)]")
     is_done = fields.Boolean('Done', compute='_compute_is_done', inverse='_set_is_done')
     state = fields.Selection([
         ('draft', 'Draft'),
@@ -30,6 +35,7 @@ class StockPackageLevel(models.Model):
     picking_type_code = fields.Selection(related='picking_id.picking_type_code')
     show_lots_m2o = fields.Boolean(compute='_compute_show_lot')
     show_lots_text = fields.Boolean(compute='_compute_show_lot')
+    company_id = fields.Many2one('res.company', 'Company', required=True, index=True)
 
     @api.depends('move_line_ids', 'move_line_ids.qty_done')
     def _compute_is_done(self):
@@ -40,7 +46,6 @@ class StockPackageLevel(models.Model):
             else:
                 package_level.is_done = package_level._check_move_lines_map_quant_package(package_level.package_id)
 
-
     def _set_is_done(self):
         for package_level in self:
             if package_level.is_done:
@@ -125,6 +130,7 @@ class StockPackageLevel(models.Model):
                         'location_id': package_level.location_id.id,
                         'location_dest_id': package_level.location_dest_id.id,
                         'package_level_id': package_level.id,
+                        'company_id': package_level.company_id.id,
                     })
 
     @api.model

--- a/addons/stock/models/stock_picking.py
+++ b/addons/stock/models/stock_picking.py
@@ -19,6 +19,7 @@ class PickingType(models.Model):
     _name = "stock.picking.type"
     _description = "Picking Type"
     _order = 'sequence, id'
+    _check_company_auto = True
 
     def _default_show_operations(self):
         return self.user_has_groups('stock.group_production_lot,'
@@ -28,20 +29,26 @@ class PickingType(models.Model):
     name = fields.Char('Operation Type', required=True, translate=True)
     color = fields.Integer('Color')
     sequence = fields.Integer('Sequence', help="Used to order the 'All Operations' kanban view")
-    sequence_id = fields.Many2one('ir.sequence', 'Reference Sequence', copy=False)
+    sequence_id = fields.Many2one(
+        'ir.sequence', 'Reference Sequence',
+        check_company=True, copy=False)
     sequence_code = fields.Char('Code', required=True)
     default_location_src_id = fields.Many2one(
         'stock.location', 'Default Source Location',
+        check_company=True,
         help="This is the default source location when you create a picking manually with this operation type. It is possible however to change it or that the routes put another location. If it is empty, it will check for the supplier location on the partner. ")
     default_location_dest_id = fields.Many2one(
         'stock.location', 'Default Destination Location',
+        check_company=True,
         help="This is the default destination location when you create a picking manually with this operation type. It is possible however to change it or that the routes put another location. If it is empty, it will check for the customer location on the partner. ")
     code = fields.Selection([('incoming', 'Receipt'), ('outgoing', 'Delivery'), ('internal', 'Internal Transfer')], 'Type of Operation', required=True)
-    return_picking_type_id = fields.Many2one('stock.picking.type', 'Operation Type for Returns')
+    return_picking_type_id = fields.Many2one(
+        'stock.picking.type', 'Operation Type for Returns',
+        check_company=True)
     show_entire_packs = fields.Boolean('Move Entire Packages', help="If ticked, you will be able to select entire packages to move")
     warehouse_id = fields.Many2one(
         'stock.warehouse', 'Warehouse', ondelete='cascade',
-        default=lambda self: self.env['stock.warehouse'].search([('company_id', '=', self.env.company.id)], limit=1))
+        check_company=True)
     active = fields.Boolean('Active', default=True)
     use_create_lots = fields.Boolean(
         'Create New Lots/Serial Numbers', default=True,
@@ -57,7 +64,6 @@ class PickingType(models.Model):
         help="If this checkbox is ticked, Odoo will automatically pre-fill the detailed "
         "operations with the corresponding products, locations and lot/serial numbers.")
 
-    # Statistics for the kanban view
     count_picking_draft = fields.Integer(compute='_compute_picking_count')
     count_picking_ready = fields.Integer(compute='_compute_picking_count')
     count_picking = fields.Integer(compute='_compute_picking_count')
@@ -67,7 +73,9 @@ class PickingType(models.Model):
     rate_picking_late = fields.Integer(compute='_compute_picking_count')
     rate_picking_backorders = fields.Integer(compute='_compute_picking_count')
     barcode = fields.Char('Barcode', copy=False)
-    company_id = fields.Many2one('res.company', 'Company', related='warehouse_id.company_id', store=True)
+    company_id = fields.Many2one(
+        'res.company', 'Company', required=True,
+        default=lambda s: s.env.company.id, index=True)
 
     @api.model
     def create(self, vals):
@@ -90,6 +98,10 @@ class PickingType(models.Model):
         return picking_type
 
     def write(self, vals):
+        if 'company_id' in vals:
+            for picking_type in self:
+                if picking_type.company_id.id != vals['company_id']:
+                    raise UserError(_("Changing the company of this record is forbidden at this point, you should rather archive it and create a new one."))
         if 'sequence_code' in vals:
             for picking_type in self:
                 if picking_type.warehouse_id:
@@ -104,9 +116,7 @@ class PickingType(models.Model):
                         'prefix': vals['sequence_code'], 'padding': 5,
                         'company_id': picking_type.env.company.id,
                     })
-
-        picking_type = super(PickingType, self).write(vals)
-        return picking_type
+        return super(PickingType, self).write(vals)
 
     def _compute_picking_count(self):
         # TDE TODO count picking can be done using previous two
@@ -153,12 +163,14 @@ class PickingType(models.Model):
         return self.browse(picking_ids).name_get()
 
     @api.onchange('code')
-    def onchange_picking_code(self):
+    def _onchange_picking_code(self):
+        warehouse = self.env['stock.warehouse'].search([('company_id', '=', self.company_id.id)], limit=1)
+        stock_location = warehouse.lot_stock_id
         if self.code == 'incoming':
             self.default_location_src_id = self.env.ref('stock.stock_location_suppliers').id
-            self.default_location_dest_id = self.env.ref('stock.stock_location_stock').id
+            self.default_location_dest_id = stock_location.id
         elif self.code == 'outgoing':
-            self.default_location_src_id = self.env.ref('stock.stock_location_stock').id
+            self.default_location_src_id = stock_location.id
             self.default_location_dest_id = self.env.ref('stock.stock_location_customers').id
         self.show_operations = self.code != 'incoming' and self.user_has_groups(
             'stock.group_production_lot,'
@@ -166,8 +178,16 @@ class PickingType(models.Model):
             'stock.group_tracking_lot'
         )
 
+    @api.onchange('company_id')
+    def _onchange_company_id(self):
+        if self.company_id:
+            warehouse = self.env['stock.warehouse'].search([('company_id', '=', self.company_id.id)], limit=1)
+            self.warehouse_id = warehouse
+        else:
+            self.warehouse_id = False
+
     @api.onchange('show_operations')
-    def onchange_show_operations(self):
+    def _onchange_show_operations(self):
         if self.show_operations and self.code != 'incoming':
             self.show_reserved = True
 
@@ -184,11 +204,13 @@ class PickingType(models.Model):
             'search_default_picking_type_id': [self.id],
             'default_picking_type_id': self.id,
             'default_immediate_transfer': default_immediate_tranfer,
+            'default_company_id': self.company_id.id,
         }
 
         action_context = literal_eval(action['context'])
-        action_context.update(context)
-        return dict(action, context=action_context)
+        context = {**action_context, **context}
+        action['context'] = context
+        return action
 
     def get_action_picking_tree_late(self):
         return self._get_action('stock.action_picking_tree_late')
@@ -221,21 +243,18 @@ class Picking(models.Model):
         states={'done': [('readonly', True)], 'cancel': [('readonly', True)]},
         help="Reference of the document")
     note = fields.Text('Notes')
-
     backorder_id = fields.Many2one(
         'stock.picking', 'Back Order of',
         copy=False, index=True,
         states={'done': [('readonly', True)], 'cancel': [('readonly', True)]},
+        check_company=True,
         help="If this shipment was split, then this field links to the shipment which contains the already processed part.")
-
     backorder_ids = fields.One2many('stock.picking', 'backorder_id', 'Back Orders')
-
     move_type = fields.Selection([
         ('direct', 'As soon as possible'), ('one', 'When all products are ready')], 'Shipping Policy',
         default='direct', required=True,
         states={'done': [('readonly', True)], 'cancel': [('readonly', True)]},
         help="It specifies goods to be deliver partially or all at once")
-
     state = fields.Selection([
         ('draft', 'Draft'),
         ('waiting', 'Waiting Another Operation'),
@@ -251,15 +270,12 @@ class Picking(models.Model):
              " * Ready: The transfer is ready to be processed.\n(a) The shipping policy is \"As soon as possible\": at least one product has been reserved.\n(b) The shipping policy is \"When all products are ready\": all product have been reserved.\n"
              " * Done: The transfer has been processed.\n"
              " * Cancelled: The transfer has been cancelled.")
-
     group_id = fields.Many2one(
         'procurement.group', 'Procurement Group',
         readonly=True, related='move_lines.group_id', store=True)
-
     priority = fields.Selection(
         PROCUREMENT_PRIORITIES, string='Priority',
         compute='_compute_priority', inverse='_set_priority', store=True,
-        # default='1', required=True,  # TDE: required, depending on moves ? strange
         index=True, tracking=True,
         states={'done': [('readonly', True)], 'cancel': [('readonly', True)]},
         help="Products will be reserved first for the transfers with the highest priorities.")
@@ -273,24 +289,23 @@ class Picking(models.Model):
         states={'done': [('readonly', True)], 'cancel': [('readonly', True)]},
         help="Creation Date, usually the time of the order")
     date_done = fields.Datetime('Date of Transfer', copy=False, readonly=True, help="Date at which the transfer has been processed or cancelled.")
-
     location_id = fields.Many2one(
         'stock.location', "Source Location",
         default=lambda self: self.env['stock.picking.type'].browse(self._context.get('default_picking_type_id')).default_location_src_id,
-        readonly=True, required=True,
+        check_company=True, readonly=True, required=True,
         states={'draft': [('readonly', False)]})
     location_dest_id = fields.Many2one(
         'stock.location', "Destination Location",
         default=lambda self: self.env['stock.picking.type'].browse(self._context.get('default_picking_type_id')).default_location_dest_id,
-        readonly=True, required=True,
+        check_company=True, readonly=True, required=True,
         states={'draft': [('readonly', False)]})
     move_lines = fields.One2many('stock.move', 'picking_id', string="Stock Moves", copy=True)
     move_ids_without_package = fields.One2many('stock.move', 'picking_id', string="Stock moves not in package", compute='_compute_move_without_package', inverse='_set_move_without_package')
     has_scrap_move = fields.Boolean(
         'Has Scrap Moves', compute='_has_scrap_move')
     picking_type_id = fields.Many2one(
-        'stock.picking.type', 'Operation Type', required=True, readonly=True,
-        domain=[('code', '!=', 'mrp_operation')],
+        'stock.picking.type', 'Operation Type',
+        required=True, readonly=True,
         states={'draft': [('readonly', False)]})
     picking_type_code = fields.Selection([
         ('incoming', 'Vendors'),
@@ -299,32 +314,26 @@ class Picking(models.Model):
         readonly=True)
     picking_type_entire_packs = fields.Boolean(related='picking_type_id.show_entire_packs',
         readonly=True)
-
     partner_id = fields.Many2one(
         'res.partner', 'Contact',
+        check_company=True,
         states={'done': [('readonly', True)], 'cancel': [('readonly', True)]})
     company_id = fields.Many2one(
-        'res.company', 'Company',
-        default=lambda self: self.env.company,
-        index=True, required=True,
-        states={'done': [('readonly', True)], 'cancel': [('readonly', True)]})
+        'res.company', string='Company', related='picking_type_id.company_id',
+        readonly=True, store=True, index=True)
     user_id = fields.Many2one(
         'res.users', 'Responsible', tracking=True,
         domain=lambda self: [('groups_id', 'in', self.env.ref('stock.group_stock_user').id)],
         default=lambda self: self.env.user)
-
     move_line_ids = fields.One2many('stock.move.line', 'picking_id', 'Operations')
     move_line_ids_without_package = fields.One2many('stock.move.line', 'picking_id', 'Operations without package', domain=['|',('package_level_id', '=', False), ('picking_type_entire_packs', '=', False)])
     move_line_nosuggest_ids = fields.One2many('stock.move.line', 'picking_id', domain=[('product_qty', '=', 0.0)])
-
     move_line_exist = fields.Boolean(
         'Has Pack Operations', compute='_compute_move_line_exist',
         help='Check the existence of pack operation on the picking')
-
     has_packages = fields.Boolean(
         'Has Packages', compute='_compute_has_packages',
         help='Check the existence of destination packages on move lines')
-
     show_check_availability = fields.Boolean(
         compute='_compute_show_check_availability',
         help='Technical field used to compute whether the check availability button should be shown.')
@@ -335,16 +344,15 @@ class Picking(models.Model):
         compute='_compute_show_validate',
         help='Technical field used to compute whether the validate should be shown.')
     use_create_lots = fields.Boolean(related='picking_type_id.use_create_lots')
-
     owner_id = fields.Many2one(
         'res.partner', 'Assign Owner',
         states={'done': [('readonly', True)], 'cancel': [('readonly', True)]},
+        check_company=True,
         help="When validating the transfer, the products will be assigned to this owner.")
     printed = fields.Boolean('Printed')
     is_locked = fields.Boolean(default=True, help='When the picking is not done this allows changing the '
                                'initial demand. When the picking is done this allows '
                                'changing the done quantities.')
-    # Used to search on pickings
     product_id = fields.Many2one('product.product', 'Product', related='move_lines.product_id', readonly=False)
     show_operations = fields.Boolean(compute='_compute_show_operations')
     show_reserved = fields.Boolean(related='picking_type_id.show_reserved')
@@ -512,6 +520,8 @@ class Picking(models.Model):
             if self.state == 'draft':
                 self.location_id = location_id
                 self.location_dest_id = location_dest_id
+                self.company_id = self.picking_type_id.company_id
+
         # TDE CLEANME move into onchange_partner_id
         if self.partner_id and self.partner_id.picking_warn:
             if self.partner_id.picking_warn == 'no-message' and self.partner_id.parent_id:
@@ -530,12 +540,11 @@ class Picking(models.Model):
 
     @api.model
     def create(self, vals):
-        # TDE FIXME: clean that brol
         defaults = self.default_get(['name', 'picking_type_id'])
+        picking_type = self.env['stock.picking.type'].browse(vals.get('picking_type_id', defaults.get('picking_type_id')))
         if vals.get('name', '/') == '/' and defaults.get('name', '/') == '/' and vals.get('picking_type_id', defaults.get('picking_type_id')):
-            vals['name'] = self.env['stock.picking.type'].browse(vals.get('picking_type_id', defaults.get('picking_type_id'))).sequence_id.next_by_id()
+            vals['name'] = picking_type.sequence_id.next_by_id()
 
-        # TDE FIXME: what ?
         # As the on_change in one2many list is WIP, we will overwrite the locations on the stock moves here
         # As it is a create the format will be a list of (0, 0, dict)
         moves = vals.get('move_lines') or vals.get('move_ids_without_package')
@@ -549,6 +558,8 @@ class Picking(models.Model):
         return res
 
     def write(self, vals):
+        if vals.get('picking_type_id') and self.state != 'draft':
+            raise UserError(_("Changing the operation type of this record is forbidden at this point."))
         res = super(Picking, self).write(vals)
         # Change locations of moves if those of the picking change
         after_vals = {}
@@ -578,9 +589,6 @@ class Picking(models.Model):
         self.mapped('move_lines').unlink() # Checks if moves are not done
         return super(Picking, self).unlink()
 
-    # Actions
-    # ----------------------------------------
-
     def action_assign_partner(self):
         for picking in self:
             picking.move_lines.write({'partner_id': picking.partner_id.id})
@@ -590,6 +598,7 @@ class Picking(models.Model):
         return self.env.ref('stock.action_report_picking').report_action(self)
 
     def action_confirm(self):
+        self._check_company()
         self.mapped('package_level_ids').filtered(lambda pl: pl.state == 'draft' and not pl.move_ids)._generate_moves()
         # call `_action_confirm` on every draft move
         self.mapped('move_lines')\
@@ -629,7 +638,8 @@ class Picking(models.Model):
         Normally that happens when the button "Done" is pressed on a Picking view.
         @return: True
         """
-        # TDE FIXME: remove decorator when migration the remaining
+        self._check_company()
+
         todo_moves = self.mapped('move_lines').filtered(lambda self: self.state in ['draft', 'waiting', 'partially_available', 'assigned', 'confirmed'])
         # Check if there are ops not linked to moves yet
         for pick in self:
@@ -670,7 +680,8 @@ class Picking(models.Model):
                                                     'location_dest_id': pick.location_dest_id.id,
                                                     'picking_id': pick.id,
                                                     'picking_type_id': pick.picking_type_id.id,
-                                                    'restrict_partner_id': pick.owner_id.id
+                                                    'restrict_partner_id': pick.owner_id.id,
+                                                    'company_id': pick.company_id.id,
                                                    })
                     ops.move_id = new_move.id
                     new_move._action_confirm()
@@ -738,7 +749,8 @@ class Picking(models.Model):
                             'package_id': pack.id,
                             'location_id': pack.location_id.id,
                             'location_dest_id': picking.move_line_ids.filtered(lambda ml: ml.package_id == pack).mapped('location_dest_id')[:1].id,
-                            'move_line_ids': [(6, 0, move_lines_to_pack.ids)]
+                            'move_line_ids': [(6, 0, move_lines_to_pack.ids)],
+                            'company_id': picking.company_id.id,
                         })
                         move_lines_to_pack.write({
                             'result_package_id': pack.id,
@@ -893,8 +905,8 @@ class Picking(models.Model):
     def _create_backorder(self):
 
         """ This method is called when the user chose to create a backorder. It will create a new
-        picking, the backorder, and move the stock.moves that are not `done` or `cancel` into it.
-        """
+        picking, the backorder, and move the stock.moves that are not `done` or `cancel` into it.
+        """
         backorders = self.env['stock.picking']
         for picking in self:
             moves_to_backorder = picking.move_lines.filtered(lambda x: x.state not in ('done', 'cancel'))
@@ -1126,7 +1138,8 @@ class Picking(models.Model):
                 'picking_id': pick.id,
                 'location_id': False,
                 'location_dest_id': move_line_ids.mapped('location_dest_id').id,
-                'move_line_ids': [(6, 0, move_lines_to_pack.ids)]
+                'move_line_ids': [(6, 0, move_lines_to_pack.ids)],
+                'company_id': pick.company_id.id,
             })
             move_lines_to_pack.write({
                 'result_package_id': package.id,
@@ -1196,3 +1209,4 @@ class Picking(models.Model):
         action['context'] = self.env.context
         action['domain'] = [('picking_id', 'in', self.ids)]
         return action
+

--- a/addons/stock/models/stock_production_lot.py
+++ b/addons/stock/models/stock_production_lot.py
@@ -10,6 +10,7 @@ class ProductionLot(models.Model):
     _name = 'stock.production.lot'
     _inherit = ['mail.thread','mail.activity.mixin']
     _description = 'Lot/Serial'
+    _check_company_auto = True
 
     name = fields.Char(
         'Lot/Serial Number', default=lambda self: self.env['ir.sequence'].next_by_code('stock.lot.serial'),
@@ -17,7 +18,7 @@ class ProductionLot(models.Model):
     ref = fields.Char('Internal Reference', help="Internal reference number in case it differs from the manufacturer's lot/serial number")
     product_id = fields.Many2one(
         'product.product', 'Product',
-        domain=lambda self: self._domain_product_id(), required=True)
+        domain=lambda self: self._domain_product_id(), required=True, check_company=True)
     product_uom_id = fields.Many2one(
         'uom.uom', 'Unit of Measure',
         related='product_id.uom_id', store=True, readonly=False)
@@ -25,15 +26,16 @@ class ProductionLot(models.Model):
     product_qty = fields.Float('Quantity', compute='_product_qty')
     note = fields.Html(string='Description')
     display_complete = fields.Boolean(compute='_compute_display_complete')
+    company_id = fields.Many2one('res.company', 'Company', required=True, stored=True, index=True)
 
     _sql_constraints = [
-        ('name_ref_uniq', 'unique (name, product_id)', 'The combination of serial number and product must be unique !'),
+        ('name_ref_uniq', 'unique (name, product_id, company_id)', 'The combination of serial number and product must be unique across a company !'),
     ]
 
     def _domain_product_id(self):
-        domain = [('type', '=', 'product')]
+        domain = "[('type', '=', 'product'), '|', ('company_id', '=', False), ('company_id', '=', company_id)]"
         if self.env.context.get('default_product_tmpl_id'):
-            domain = expression.AND([domain, [('product_tmpl_id', '=', self.env.context['default_product_tmpl_id'])]])
+            domain = "[('type', '=', 'product'), ('product_tmpl_id', '=', %s), '|', ('company_id', '=', False), ('company_id', '=', company_id)]" % self.env.context['default_product_tmpl_id']
         return domain
 
     def _check_create(self):
@@ -59,6 +61,10 @@ class ProductionLot(models.Model):
         return super(ProductionLot, self).create(vals_list)
 
     def write(self, vals):
+        if 'company_id' in vals:
+            for lot in self:
+                if lot.company_id.id != vals['company_id']:
+                    raise UserError(_("Changing the company of this record is forbidden at this point, you should rather archive it and create a new one."))
         if 'product_id' in vals and any([vals['product_id'] != lot.product_id.id for lot in self]):
             move_lines = self.env['stock.move.line'].search([('lot_id', 'in', self.ids), ('product_id', '!=', vals['product_id'])])
             if move_lines:
@@ -80,3 +86,4 @@ class ProductionLot(models.Model):
         if self.user_has_groups('stock.group_stock_manager'):
             self = self.with_context(inventory_mode=True)
         return self.env['stock.quant']._get_quants_action()
+

--- a/addons/stock/models/stock_quant.py
+++ b/addons/stock/models/stock_quant.py
@@ -21,7 +21,7 @@ class StockQuant(models.Model):
     def _domain_location_id(self):
         if not self._is_inventory_mode():
             return
-        return ['&', ('company_id', '=', self.env.company.id), ('usage', 'in', ['internal', 'transit'])]
+        return [('usage', 'in', ['internal', 'transit'])]
 
     def _domain_product_id(self):
         if not self._is_inventory_mode():
@@ -34,7 +34,7 @@ class StockQuant(models.Model):
     product_id = fields.Many2one(
         'product.product', 'Product',
         domain=lambda self: self._domain_product_id(),
-        ondelete='restrict', readonly=True, required=True)
+        ondelete='restrict', readonly=True, required=True, check_company=True)
     # so user can filter on template in webclient
     product_tmpl_id = fields.Many2one(
         'product.template', string='Product Template',
@@ -47,16 +47,17 @@ class StockQuant(models.Model):
     location_id = fields.Many2one(
         'stock.location', 'Location',
         domain=lambda self: self._domain_location_id(),
-        auto_join=True, ondelete='restrict', readonly=True, required=True)
+        auto_join=True, ondelete='restrict', readonly=True, required=True, check_company=True)
     lot_id = fields.Many2one(
         'stock.production.lot', 'Lot/Serial Number',
-        ondelete='restrict', readonly=True)
+        ondelete='restrict', readonly=True, check_company=True)
     package_id = fields.Many2one(
         'stock.quant.package', 'Package',
-        help='The package containing this quant', readonly=True, ondelete='restrict')
+        domain="[('location_id', '=', location_id)]",
+        help='The package containing this quant', readonly=True, ondelete='restrict', check_company=True)
     owner_id = fields.Many2one(
         'res.partner', 'Owner',
-        help='This is the owner of the quant', readonly=True)
+        help='This is the owner of the quant', readonly=True, check_company=True)
     quantity = fields.Float(
         'Quantity',
         help='Quantity of products in this quant, in the default unit of measure of the product',
@@ -95,9 +96,9 @@ class StockQuant(models.Model):
             if diff_float_compared == 0:
                 continue
             elif diff_float_compared > 0:
-                move_vals = quant._get_inventory_move_values(diff, quant.product_id.property_stock_inventory, quant.location_id)
+                move_vals = quant._get_inventory_move_values(diff, quant.product_id.with_context(force_company=quant.company_id.id or self.env.company.id).property_stock_inventory, quant.location_id)
             else:
-                move_vals = quant._get_inventory_move_values(-diff, quant.location_id, quant.product_id.property_stock_inventory, out=True)
+                move_vals = quant._get_inventory_move_values(-diff, quant.location_id, quant.product_id.with_context(force_company=quant.company_id.id or self.env.company.id).property_stock_inventory, out=True)
             move = quant.env['stock.move'].with_context(inventory_mode=False).create(move_vals)
             move._action_done()
 
@@ -126,7 +127,10 @@ class StockQuant(models.Model):
             # Set the `inventory_quantity` field to create the necessary move.
             quant.inventory_quantity = inventory_quantity
             return quant
-        return super(StockQuant, self).create(vals)
+        res = super(StockQuant, self).create(vals)
+        if self._is_inventory_mode():
+            res._check_company()
+        return res
 
     @api.model
     def read_group(self, domain, fields, groupby, offset=0, limit=None, orderby=False, lazy=True):
@@ -631,7 +635,7 @@ class QuantPackage(models.Model):
     quant_ids = fields.One2many('stock.quant', 'package_id', 'Bulk Content', readonly=True,
         domain=['|', ('quantity', '!=', 0), ('reserved_quantity', '!=', 0)])
     packaging_id = fields.Many2one(
-        'product.packaging', 'Package Type', index=True)
+        'product.packaging', 'Package Type', index=True, check_company=True)
     location_id = fields.Many2one(
         'stock.location', 'Location', compute='_compute_package_info',
         index=True, readonly=True, store=True)
@@ -645,7 +649,7 @@ class QuantPackage(models.Model):
     @api.depends('quant_ids.package_id', 'quant_ids.location_id', 'quant_ids.company_id', 'quant_ids.owner_id', 'quant_ids.quantity', 'quant_ids.reserved_quantity')
     def _compute_package_info(self):
         for package in self:
-            values = {'location_id': False, 'company_id': self.env.company.id, 'owner_id': False}
+            values = {'location_id': False, 'owner_id': False}
             if package.quant_ids:
                 values['location_id'] = package.quant_ids[0].location_id
                 if all(q.owner_id == package.quant_ids[0].owner_id for q in package.quant_ids):
@@ -653,7 +657,7 @@ class QuantPackage(models.Model):
                 if all(q.company_id == package.quant_ids[0].company_id for q in package.quant_ids):
                     values['company_id'] = package.quant_ids[0].company_id
             package.location_id = values['location_id']
-            package.company_id = values['company_id']
+            package.company_id = values.get('company_id')
             package.owner_id = values['owner_id']
 
     def name_get(self):
@@ -712,3 +716,4 @@ class QuantPackage(models.Model):
                 res[quant.product_id] = 0
             res[quant.product_id] += quant.quantity
         return res
+

--- a/addons/stock/models/stock_rule.py
+++ b/addons/stock/models/stock_rule.py
@@ -21,6 +21,7 @@ class StockRule(models.Model):
     _name = 'stock.rule'
     _description = "Stock Rule"
     _order = "sequence, id"
+    _check_company_auto = True
 
     name = fields.Char(
         'Name', required=True, translate=True,
@@ -39,8 +40,8 @@ class StockRule(models.Model):
     sequence = fields.Integer('Sequence', default=20)
     company_id = fields.Many2one('res.company', 'Company',
         default=lambda self: self.env.company)
-    location_id = fields.Many2one('stock.location', 'Destination Location', required=True)
-    location_src_id = fields.Many2one('stock.location', 'Source Location')
+    location_id = fields.Many2one('stock.location', 'Destination Location', required=True, check_company=True)
+    location_src_id = fields.Many2one('stock.location', 'Source Location', check_company=True)
     route_id = fields.Many2one('stock.location.route', 'Route', required=True, ondelete='cascade')
     procure_method = fields.Selection([
         ('make_to_stock', 'Take From Stock'),
@@ -53,13 +54,16 @@ class StockRule(models.Model):
     route_sequence = fields.Integer('Route Sequence', related='route_id.sequence', store=True, readonly=False)
     picking_type_id = fields.Many2one(
         'stock.picking.type', 'Operation Type',
-        required=True)
+        required=True, check_company=True)
     delay = fields.Integer('Delay', default=0, help="The expected date of the created transfer will be computed based on this delay.")
-    partner_address_id = fields.Many2one('res.partner', 'Partner Address', help="Address where goods should be delivered. Optional.")
+    partner_address_id = fields.Many2one(
+        'res.partner', 'Partner Address',
+        check_company=True,
+        help="Address where goods should be delivered. Optional.")
     propagate_cancel = fields.Boolean(
         'Cancel Next Move', default=False,
         help="When ticked, if the move created by this rule is cancelled, the next move will be cancelled too.")
-    warehouse_id = fields.Many2one('stock.warehouse', 'Warehouse')
+    warehouse_id = fields.Many2one('stock.warehouse', 'Warehouse', check_company=True)
     propagate_warehouse_id = fields.Many2one(
         'stock.warehouse', 'Warehouse to Propagate',
         help="The warehouse to propagate on the created move/procurement, which can be different of the warehouse this rule is for (e.g for resupplying rules from another warehouse)")
@@ -411,10 +415,26 @@ class ProcurementGroup(models.Model):
         result = False
         location = location_id
         while (not result) and location:
-            result = self._search_rule(values.get('route_ids', False), product_id, values.get('warehouse_id', False), [('location_id', '=', location.id), ('action', '!=', 'push')])
+            domain = self._get_rule_domain(location, values)
+            result = self._search_rule(values.get('route_ids', False), product_id, values.get('warehouse_id', False), domain)
             location = location.location_id
         return result
 
+    @api.model
+    def _get_rule_domain(self, location, values):
+        return [('location_id', '=', location.id), ('action', '!=', 'push')]
+
+    def _merge_domain(self, values, rule, group_id):
+        return [
+            ('group_id', '=', group_id), # extra logic?
+            ('location_id', '=', rule.location_src_id.id),
+            ('location_dest_id', '=', values['location_id'].id),
+            ('picking_type_id', '=', rule.picking_type_id.id),
+            ('picking_id.printed', '=', False),
+            ('picking_id.state', 'in', ['draft', 'confirmed', 'waiting', 'assigned']),
+            ('picking_id.backorder_id', '=', False),
+            ('product_id', '=', values['product_id'].id)]
+
     @api.model
     def _get_moves_to_assign_domain(self):
         return expression.AND([

--- a/addons/stock/models/stock_scrap.py
+++ b/addons/stock/models/stock_scrap.py
@@ -13,11 +13,12 @@ class StockScrap(models.Model):
     _description = 'Scrap'
 
     def _get_default_scrap_location_id(self):
-        return self.env['stock.location'].search([('scrap_location', '=', True), ('company_id', 'in', [self.env.company.id, False])], limit=1).id
+        company_id = self.env.context.get('default_company_id') or self.env.company.id
+        return self.env['stock.location'].search([('scrap_location', '=', True), ('company_id', 'in', [company_id, False])], limit=1).id
 
     def _get_default_location_id(self):
-        company_user = self.env.company
-        warehouse = self.env['stock.warehouse'].search([('company_id', '=', company_user.id)], limit=1)
+        company_id = self.env.context.get('default_company_id') or self.env.company.id
+        warehouse = self.env['stock.warehouse'].search([('company_id', '=', company_id)], limit=1)
         if warehouse:
             return warehouse.lot_stock_id.id
         return None
@@ -26,11 +27,11 @@ class StockScrap(models.Model):
         'Reference',  default=lambda self: _('New'),
         copy=False, readonly=True, required=True,
         states={'done': [('readonly', True)]})
-    company_id = fields.Many2one('res.company', string='Company', default=lambda self: self.env.company, required=True, readonly=True)
+    company_id = fields.Many2one('res.company', string='Company', default=lambda self: self.env.company, required=True, states={'done': [('readonly', True)]})
     origin = fields.Char(string='Source Document')
     product_id = fields.Many2one(
-        'product.product', 'Product', domain=[('type', 'in', ['product', 'consu'])],
-        required=True, states={'done': [('readonly', True)]})
+        'product.product', 'Product', domain="[('type', 'in', ['product', 'consu']), '|', ('company_id', '=', False), ('company_id', '=', company_id)]",
+        required=True, states={'done': [('readonly', True)]}, check_company=True)
     product_uom_id = fields.Many2one(
         'uom.uom', 'Unit of Measure',
         required=True, states={'done': [('readonly', True)]}, domain="[('category_id', '=', product_uom_category_id)]")
@@ -38,20 +39,19 @@ class StockScrap(models.Model):
     tracking = fields.Selection('Product Tracking', readonly=True, related="product_id.tracking")
     lot_id = fields.Many2one(
         'stock.production.lot', 'Lot/Serial',
-        states={'done': [('readonly', True)]}, domain="[('product_id', '=', product_id)]")
+        states={'done': [('readonly', True)]}, domain="[('product_id', '=', product_id), ('company_id', '=', company_id)]", check_company=True)
     package_id = fields.Many2one(
         'stock.quant.package', 'Package',
-        states={'done': [('readonly', True)]},
-        domain="[('company_id', '=', company_id)]")
-    owner_id = fields.Many2one('res.partner', 'Owner', states={'done': [('readonly', True)]})
-    move_id = fields.Many2one('stock.move', 'Scrap Move', readonly=True)
-    picking_id = fields.Many2one('stock.picking', 'Picking', states={'done': [('readonly', True)]}, domain="[('company_id', '=', company_id)]")
+        states={'done': [('readonly', True)]}, check_company=True)
+    owner_id = fields.Many2one('res.partner', 'Owner', states={'done': [('readonly', True)]}, check_company=True)
+    move_id = fields.Many2one('stock.move', 'Scrap Move', readonly=True, check_company=True)
+    picking_id = fields.Many2one('stock.picking', 'Picking', states={'done': [('readonly', True)]}, check_company=True)
     location_id = fields.Many2one(
         'stock.location', 'Source Location', domain="[('usage', '=', 'internal'), ('company_id', 'in', [company_id, False])]",
-        required=True, states={'done': [('readonly', True)]}, default=_get_default_location_id)
+        required=True, states={'done': [('readonly', True)]}, default=_get_default_location_id, check_company=True)
     scrap_location_id = fields.Many2one(
         'stock.location', 'Scrap Location', default=_get_default_scrap_location_id,
-        domain="[('scrap_location', '=', True), ('company_id', 'in', [company_id, False])]", required=True, states={'done': [('readonly', True)]})
+        domain="[('scrap_location', '=', True), ('company_id', 'in', [company_id, False])]", required=True, states={'done': [('readonly', True)]}, check_company=True)
     scrap_qty = fields.Float('Quantity', default=1.0, required=True, states={'done': [('readonly', True)]})
     state = fields.Selection([
         ('draft', 'Draft'),
@@ -64,7 +64,7 @@ class StockScrap(models.Model):
             self.location_id = (self.picking_id.state == 'done') and self.picking_id.location_dest_id.id or self.picking_id.location_id.id
 
     @api.onchange('product_id')
-    def onchange_product_id(self):
+    def _onchange_product_id(self):
         if self.product_id:
             self.product_uom_id = self.product_id.uom_id.id
             # Check if we can get a more precise location instead of
@@ -76,6 +76,19 @@ class StockScrap(models.Model):
                         self.location_id = move_line.location_id if move_line.state != 'done' else move_line.location_dest_id
                         break
 
+    @api.onchange('company_id')
+    def _onchange_company_id(self):
+        if self.company_id:
+            warehouse = self.env['stock.warehouse'].search([('company_id', '=', self.company_id.id)], limit=1)
+            self.location_id = warehouse.lot_stock_id
+            self.scrap_location_id = self.env['stock.location'].search([
+                ('scrap_location', '=', True),
+                ('company_id', 'in', [self.company_id.id, False]),
+            ], limit=1)
+        else:
+            self.location_id = False
+            self.scrap_location_id = False
+
     def unlink(self):
         if 'done' in self.mapped('state'):
             raise UserError(_('You cannot delete a scrap which is done.'))
@@ -113,6 +126,7 @@ class StockScrap(models.Model):
         }
 
     def do_scrap(self):
+        self._check_company()
         for scrap in self:
             scrap.name = self.env['ir.sequence'].next_by_code('stock.scrap') or _('New')
             move = self.env['stock.move'].create(scrap._prepare_move_values())
@@ -163,3 +177,4 @@ class StockScrap(models.Model):
                 },
                 'target': 'new'
             }
+

--- a/addons/stock/models/stock_traceability.py
+++ b/None
@@ -1,242 +0,0 @@
-# -*- coding: utf-8 -*-
-# Part of Odoo. See LICENSE file for full copyright and licensing details.
-
-from odoo import api, models, _
-from odoo.tools import config
-
-
-rec = 0
-def autoIncrement():
-    global rec
-    pStart = 1
-    pInterval = 1
-    if rec == 0:
-        rec = pStart
-    else:
-        rec += pInterval
-    return rec
-
-
-class MrpStockReport(models.TransientModel):
-    _name = 'stock.traceability.report'
-    _description = 'Traceability Report'
-
-    @api.model
-    def _get_move_lines(self, move_lines, line_id=None):
-        lines_seen = move_lines
-        lines_todo = list(move_lines)
-        while lines_todo:
-            move_line = lines_todo.pop(0)
-            # if MTO
-            if move_line.move_id.move_orig_ids:
-                lines = move_line.move_id.move_orig_ids.mapped('move_line_ids').filtered(
-                    lambda m: m.lot_id == move_line.lot_id and m.state == 'done'
-                ) - lines_seen
-            # if MTS
-            elif move_line.location_id.usage == 'internal':
-                lines = self.env['stock.move.line'].search([
-                    ('product_id', '=', move_line.product_id.id),
-                    ('lot_id', '=', move_line.lot_id.id),
-                    ('location_dest_id', '=', move_line.location_id.id),
-                    ('id', 'not in', lines_seen.ids),
-                    ('date', '<=', move_line.date),
-                    ('state', '=', 'done')
-                ])
-            else:
-                continue
-            if line_id is None or line_id in lines.ids:
-                lines_todo += list(lines)
-            lines_seen |= lines
-        return lines_seen - move_lines
-
-    @api.model
-    def get_lines(self, line_id=None, **kw):
-        context = dict(self.env.context)
-        model = kw and kw['model_name'] or context.get('model')
-        rec_id = kw and kw['model_id'] or context.get('active_id')
-        level = kw and kw['level'] or 1
-        lines = self.env['stock.move.line']
-        move_line = self.env['stock.move.line']
-        if rec_id and model == 'stock.production.lot':
-            lines = move_line.search([
-                ('lot_id', '=', context.get('lot_name') or rec_id),
-                ('state', '=', 'done'),
-            ])
-        elif  rec_id and model == 'stock.move.line' and context.get('lot_name'):
-            record = self.env[model].browse(rec_id)
-            dummy, is_used = self._get_linked_move_lines(record)
-            if is_used:
-                lines = is_used
-        elif rec_id and model in ('stock.picking', 'mrp.production'):
-            record = self.env[model].browse(rec_id)
-            if model == 'stock.picking':
-                lines = record.move_lines.mapped('move_line_ids').filtered(lambda m: m.lot_id and m.state == 'done')
-            else:
-                lines = record.move_finished_ids.mapped('move_line_ids').filtered(lambda m: m.state == 'done')
-        move_line_vals = self._lines(line_id, model_id=rec_id, model=model, level=level, move_lines=lines)
-        final_vals = sorted(move_line_vals, key=lambda v: v['date'], reverse=True)
-        lines = self._final_vals_to_lines(final_vals, level)
-        return lines
-
-    @api.model
-    def _get_reference(self, move_line):
-        res_model = ''
-        ref = ''
-        res_id = False
-        picking_id = move_line.picking_id or move_line.move_id.picking_id
-        if picking_id:
-            res_model = 'stock.picking'
-            res_id = picking_id.id
-            ref = picking_id.name
-        elif move_line.move_id.inventory_id:
-            res_model = 'stock.inventory'
-            res_id = move_line.move_id.inventory_id.id
-            ref = 'Inv. Adj.: ' + move_line.move_id.inventory_id.name
-        elif move_line.move_id.scrapped and move_line.move_id.scrap_ids:
-            res_model = 'stock.scrap'
-            res_id = move_line.move_id.scrap_ids[0].id
-            ref = move_line.move_id.scrap_ids[0].name
-        return res_model, res_id, ref
-
-    @api.model
-    def _quantity_to_str(self, from_uom, to_uom, qty):
-        """ workaround to apply the float rounding logic of t-esc on data prepared server side """
-        qty = from_uom._compute_quantity(qty, to_uom, rounding_method='HALF-UP')
-        return self.env['ir.qweb.field.float'].value_to_html(qty, {'decimal_precision': 'Product Unit of Measure'})
-
-    def _get_usage(self, move_line):
-        usage = ''
-        if (move_line.location_id.usage == 'internal') and (move_line.location_dest_id.usage == 'internal'):
-            usage = 'internal'
-        elif (move_line.location_id.usage != 'internal') and (move_line.location_dest_id.usage == 'internal'):
-            usage = 'in'
-        else:
-            usage = 'out'
-        return usage
-
-    def _make_dict_move(self, level, parent_id, move_line, unfoldable=False):
-        res_model, res_id, ref = self._get_reference(move_line)
-        dummy, is_used = self._get_linked_move_lines(move_line)
-        data = [{
-            'level': level,
-            'unfoldable': unfoldable,
-            'date': move_line.move_id.date,
-            'parent_id': parent_id,
-            'is_used': bool(is_used),
-            'usage': self._get_usage(move_line),
-            'model_id': move_line.id,
-            'model': 'stock.move.line',
-            'product_id': move_line.product_id.display_name,
-            'product_qty_uom': "%s %s" % (self._quantity_to_str(move_line.product_uom_id, move_line.product_id.uom_id, move_line.qty_done), move_line.product_id.uom_id.name),
-            'lot_name': move_line.lot_id.name,
-            'lot_id': move_line.lot_id.id,
-            'location_source': move_line.location_id.name,
-            'location_destination': move_line.location_dest_id.name,
-            'reference_id': ref,
-            'res_id': res_id,
-            'res_model': res_model}]
-        return data
-
-    @api.model
-    def _final_vals_to_lines(self, final_vals, level):
-        lines = []
-        for data in final_vals:
-            lines.append({
-                'id': autoIncrement(),
-                'model': data['model'],
-                'model_id': data['model_id'],
-                'parent_id': data['parent_id'],
-                'usage': data.get('usage', False),
-                'is_used': data.get('is_used', False),
-                'lot_name': data.get('lot_name', False),
-                'lot_id': data.get('lot_id', False),
-                'reference': data.get('reference_id', False),
-                'res_id': data.get('res_id', False),
-                'res_model': data.get('res_model', False),
-                'columns': [data.get('reference_id', False),
-                            data.get('product_id', False),
-                            data.get('date', False),
-                            data.get('lot_name', False),
-                            data.get('location_source', False),
-                            data.get('location_destination', False),
-                            data.get('product_qty_uom', 0)],
-                'level': level,
-                'unfoldable': data['unfoldable'],
-            })
-        return lines
-
-    def _get_linked_move_lines(self, move_line):
-        """ This method will return the consumed line or produced line for this operation."""
-        return False, False
-
-    @api.model
-    def _lines(self, line_id=None, model_id=False, model=False, level=0, move_lines=[], **kw):
-        final_vals = []
-        lines = move_lines or []
-        if model and line_id:
-            move_line = self.env[model].browse(model_id)
-            move_lines, is_used = self._get_linked_move_lines(move_line)
-            if move_lines:
-                lines = move_lines
-            else:
-                # Traceability in case of consumed in.
-                lines = self._get_move_lines(move_line, line_id=line_id)
-        for line in lines:
-            unfoldable = False
-            if line.consume_line_ids or ( line.lot_id and self._get_move_lines(line) and model != "stock.production.lot"):
-                unfoldable = True
-            final_vals += self._make_dict_move(level, parent_id=line_id, move_line=line, unfoldable=unfoldable)
-        return final_vals
-
-    def get_pdf_lines(self, line_data=[]):
-        lines = []
-        for line in line_data:
-            model = self.env[line['model_name']].browse(line['model_id'])
-            unfoldable = False
-            if line.get('unfoldable'):
-                unfoldable = True
-            final_vals = self._make_dict_move(line['level'], parent_id=line['id'], move_line=model, unfoldable=unfoldable)
-            lines.append(self._final_vals_to_lines(final_vals, line['level'])[0])
-        return lines
-
-    def get_pdf(self, line_data=[]):
-        lines = self.with_context(print_mode=True).get_pdf_lines(line_data)
-        base_url = self.env['ir.config_parameter'].sudo().get_param('web.base.url')
-        rcontext = {
-            'mode': 'print',
-            'base_url': base_url,
-        }
-
-        context = dict(self.env.context)
-        if not config['test_enable']:
-            context['commit_assetsbundle'] = True
-
-        body = self.env['ir.ui.view'].with_context(context).render_template(
-            "stock.report_stock_inventory_print",
-            values=dict(rcontext, lines=lines, report=self, context=self),
-        )
-
-        header = self.env['ir.actions.report'].render_template("web.internal_layout", values=rcontext)
-        header = self.env['ir.actions.report'].render_template("web.minimal_layout", values=dict(rcontext, subst=True, body=header))
-
-        return self.env['ir.actions.report']._run_wkhtmltopdf(
-            [body],
-            header=header,
-            landscape=True,
-            specific_paperformat_args={'data-report-margin-top': 10, 'data-report-header-spacing': 10}
-        )
-
-    def _get_html(self):
-        result = {}
-        rcontext = {}
-        context = dict(self.env.context)
-        rcontext['lines'] = self.with_context(context).get_lines()
-        result['html'] = self.env.ref('stock.report_stock_inventory').render(rcontext)
-        return result
-
-    @api.model
-    def get_html(self, given_context=None):
-        res = self.search([('create_uid', '=', self.env.uid)], limit=1)
-        if not res:
-            return self.create({}).with_context(given_context)._get_html()
-        return res.with_context(given_context)._get_html()

--- a/addons/stock/models/stock_warehouse.py
+++ b/addons/stock/models/stock_warehouse.py
@@ -19,6 +19,7 @@ class Warehouse(models.Model):
     _name = "stock.warehouse"
     _description = "Warehouse"
     _order = 'sequence,id'
+    _check_company_auto = True
     # namedtuple used in helper methods generating values for routes
     Routing = namedtuple('Routing', ['from_loc', 'dest_loc', 'picking_type', 'action'])
 
@@ -28,14 +29,21 @@ class Warehouse(models.Model):
         'res.company', 'Company', default=lambda self: self.env.company,
         index=True, readonly=True, required=True,
         help='The company is automatically set from your user preferences.')
-    partner_id = fields.Many2one('res.partner', 'Address', default=lambda self: self.env.company.partner_id)
-    view_location_id = fields.Many2one('stock.location', 'View Location', domain=[('usage', '=', 'view')], required=True)
-    lot_stock_id = fields.Many2one('stock.location', 'Location Stock', domain=[('usage', '=', 'internal')], required=True)
+    partner_id = fields.Many2one('res.partner', 'Address', default=lambda self: self.env.company.partner_id, check_company=True)
+    view_location_id = fields.Many2one(
+        'stock.location', 'View Location',
+        domain="[('usage', '=', 'view'), ('company_id', '=', company_id)]",
+        required=True, check_company=True)
+    lot_stock_id = fields.Many2one(
+        'stock.location', 'Location Stock',
+        domain="[('usage', '=', 'internal'), ('company_id', '=', company_id)]",
+        required=True, check_company=True)
     code = fields.Char('Short Name', required=True, size=5, help="Short name used to identify your warehouse")
     route_ids = fields.Many2many(
         'stock.location.route', 'stock_route_warehouse', 'warehouse_id', 'route_id',
-        'Routes', domain="[('warehouse_selectable', '=', True)]",
-        help='Defaults routes through the warehouse')
+        'Routes',
+        domain="[('warehouse_selectable', '=', True), '|', ('company_id', '=', False), ('company_id', '=', company_id)]",
+        help='Defaults routes through the warehouse', check_company=True)
     reception_steps = fields.Selection([
         ('one_step', 'Receive goods directly (1 step)'),
         ('two_steps', 'Receive goods in input and then stock (2 steps)'),
@@ -48,16 +56,16 @@ class Warehouse(models.Model):
         ('pick_pack_ship', 'Pack goods, send goods in output and then deliver (3 steps)')],
         'Outgoing Shipments', default='ship_only', required=True,
         help="Default outgoing route to follow")
-    wh_input_stock_loc_id = fields.Many2one('stock.location', 'Input Location')
-    wh_qc_stock_loc_id = fields.Many2one('stock.location', 'Quality Control Location')
-    wh_output_stock_loc_id = fields.Many2one('stock.location', 'Output Location')
-    wh_pack_stock_loc_id = fields.Many2one('stock.location', 'Packing Location')
+    wh_input_stock_loc_id = fields.Many2one('stock.location', 'Input Location', check_company=True)
+    wh_qc_stock_loc_id = fields.Many2one('stock.location', 'Quality Control Location', check_company=True)
+    wh_output_stock_loc_id = fields.Many2one('stock.location', 'Output Location', check_company=True)
+    wh_pack_stock_loc_id = fields.Many2one('stock.location', 'Packing Location', check_company=True)
     mto_pull_id = fields.Many2one('stock.rule', 'MTO rule')
-    pick_type_id = fields.Many2one('stock.picking.type', 'Pick Type')
-    pack_type_id = fields.Many2one('stock.picking.type', 'Pack Type')
-    out_type_id = fields.Many2one('stock.picking.type', 'Out Type')
-    in_type_id = fields.Many2one('stock.picking.type', 'In Type')
-    int_type_id = fields.Many2one('stock.picking.type', 'Internal Type')
+    pick_type_id = fields.Many2one('stock.picking.type', 'Pick Type', check_company=True)
+    pack_type_id = fields.Many2one('stock.picking.type', 'Pack Type', check_company=True)
+    out_type_id = fields.Many2one('stock.picking.type', 'Out Type', check_company=True)
+    in_type_id = fields.Many2one('stock.picking.type', 'In Type', check_company=True)
+    int_type_id = fields.Many2one('stock.picking.type', 'Internal Type', check_company=True)
     crossdock_route_id = fields.Many2one('stock.location.route', 'Crossdock Route', ondelete='restrict')
     reception_route_id = fields.Many2one('stock.location.route', 'Receipt Route', ondelete='restrict')
     delivery_route_id = fields.Many2one('stock.location.route', 'Delivery Route', ondelete='restrict')
@@ -122,6 +130,11 @@ class Warehouse(models.Model):
         return warehouse
 
     def write(self, vals):
+        if 'company_id' in vals:
+            for warehouse in self:
+                if warehouse.company_id.id != vals['company_id']:
+                    raise UserError(_("Changing the company of this record is forbidden at this point, you should rather archive it and create a new one."))
+
         Route = self.env['stock.location.route']
         warehouses = self.with_context(active_test=False)
 
@@ -825,6 +838,7 @@ class Warehouse(models.Model):
                 'barcode': self.code.replace(" ", "").upper() + "-RECEIPTS",
                 'show_reserved': False,
                 'sequence_code': 'IN',
+                'company_id': self.company_id.id,
             }, 'out_type_id': {
                 'name': _('Delivery Orders'),
                 'code': 'outgoing',
@@ -834,6 +848,7 @@ class Warehouse(models.Model):
                 'sequence': max_sequence + 5,
                 'barcode': self.code.replace(" ", "").upper() + "-DELIVERY",
                 'sequence_code': 'OUT',
+                'company_id': self.company_id.id,
             }, 'pack_type_id': {
                 'name': _('Pack'),
                 'code': 'internal',
@@ -844,6 +859,7 @@ class Warehouse(models.Model):
                 'sequence': max_sequence + 4,
                 'barcode': self.code.replace(" ", "").upper() + "-PACK",
                 'sequence_code': 'PACK',
+                'company_id': self.company_id.id,
             }, 'pick_type_id': {
                 'name': _('Pick'),
                 'code': 'internal',
@@ -853,6 +869,7 @@ class Warehouse(models.Model):
                 'sequence': max_sequence + 3,
                 'barcode': self.code.replace(" ", "").upper() + "-PICK",
                 'sequence_code': 'PICK',
+                'company_id': self.company_id.id,
             }, 'int_type_id': {
                 'name': _('Internal Transfers'),
                 'code': 'internal',
@@ -864,6 +881,7 @@ class Warehouse(models.Model):
                 'sequence': max_sequence + 2,
                 'barcode': self.code.replace(" ", "").upper() + "-INTERNAL",
                 'sequence_code': 'INT',
+                'company_id': self.company_id.id,
             },
         }, max_sequence + 6
 
@@ -937,6 +955,7 @@ class Orderpoint(models.Model):
     """ Defines Minimum stock rules. """
     _name = "stock.warehouse.orderpoint"
     _description = "Minimum Inventory Rule"
+    _check_company_auto = True
 
     @api.model
     def default_get(self, fields):
@@ -957,13 +976,13 @@ class Orderpoint(models.Model):
         help="If the active field is set to False, it will allow you to hide the orderpoint without removing it.")
     warehouse_id = fields.Many2one(
         'stock.warehouse', 'Warehouse',
-        ondelete="cascade", required=True)
+        check_company=True, ondelete="cascade", required=True)
     location_id = fields.Many2one(
         'stock.location', 'Location',
-        ondelete="cascade", required=True)
+        ondelete="cascade", required=True, check_company=True)
     product_id = fields.Many2one(
         'product.product', 'Product',
-        domain=[('type', '=', 'product')], ondelete='cascade', required=True)
+        domain="[('type', '=', 'product'), '|', ('company_id', '=', False), ('company_id', '=', company_id)]", ondelete='cascade', required=True, check_company=True)
     product_uom = fields.Many2one(
         'uom.uom', 'Unit of Measure', related='product_id.uom_id',
         readonly=True, required=True,
@@ -985,7 +1004,7 @@ class Orderpoint(models.Model):
         'procurement.group', 'Procurement Group', copy=False,
         help="Moves created through this orderpoint will be put in this procurement group. If none is given, the moves generated by stock rules will be grouped into one big picking.")
     company_id = fields.Many2one(
-        'res.company', 'Company', required=True,
+        'res.company', 'Company', required=True, index=True,
         default=lambda self: self.env.company)
     lead_days = fields.Integer(
         'Lead Time', default=1,
@@ -1005,10 +1024,12 @@ class Orderpoint(models.Model):
         # We want to keep only the locations
         #  - strictly belonging to our warehouse
         #  - not belonging to any warehouses
-        other_warehouses = self.env['stock.warehouse'].search([('id', '!=', self.warehouse_id.id)])
-        for view_location_id in other_warehouses.mapped('view_location_id'):
-            loc_domain = expression.AND([loc_domain, ['!', ('id', 'child_of', view_location_id.id)]])
-        self.allowed_location_ids = self.env['stock.location'].search(loc_domain)
+        for orderpoint in self:
+            other_warehouses = self.env['stock.warehouse'].search([('id', '!=', orderpoint.warehouse_id.id)])
+            for view_location_id in other_warehouses.mapped('view_location_id'):
+                loc_domain = expression.AND([loc_domain, ['!', ('id', 'child_of', view_location_id.id)]])
+                loc_domain = expression.AND([loc_domain, ['|', ('company_id', '=', False), ('company_id', '=', orderpoint.company_id.id)]])
+            orderpoint.allowed_location_ids = self.env['stock.location'].search(loc_domain)
 
     def _quantity_in_progress(self):
         """Return Quantities that are not yet in virtual stock but should be deduced from orderpoint rule
@@ -1028,12 +1049,26 @@ class Orderpoint(models.Model):
             self.location_id = self.warehouse_id.lot_stock_id.id
 
     @api.onchange('product_id')
-    def onchange_product_id(self):
+    def _onchange_product_id(self):
         if self.product_id:
             self.product_uom = self.product_id.uom_id.id
             return {'domain':  {'product_uom': [('category_id', '=', self.product_id.uom_id.category_id.id)]}}
         return {'domain': {'product_uom': []}}
 
+    @api.onchange('company_id')
+    def _onchange_company_id(self):
+        if self.company_id:
+            self.warehouse_id = self.env['stock.warehouse'].search([
+                ('company_id', '=', self.company_id.id)
+            ], limit=1)
+
+    def write(self, vals):
+        if 'company_id' in vals:
+            for orderpoint in self:
+                if orderpoint.company_id.id != vals['company_id']:
+                    raise UserError(_("Changing the company of this record is forbidden at this point, you should rather archive it and create a new one."))
+        return super(Orderpoint, self).write(vals)
+
     def _get_date_planned(self, product_qty, start_date):
         days = self.lead_days or 0.0
         if self.lead_type == 'supplier':
@@ -1056,3 +1091,4 @@ class Orderpoint(models.Model):
             'orderpoint_id': self,
             'group_id': group or self.group_id,
         }
+
