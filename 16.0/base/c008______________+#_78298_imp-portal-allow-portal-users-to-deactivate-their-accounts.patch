PR: https://github.com/odoo/odoo/pull/78298

From: 66f5bc4dbf840824614ef81183d207e2bdb90d68
From: std-odoo
Date: 2022-06-30 10:10:56

Structural Changes: 3
Total Changes: 197

[IMP] portal: allow portal users to deactivate their accounts

Purpose
=======
Allow portal users to deactivate their accounts from the portal view.

After the deactivation, they are redirected to the login page, so
they can verify that they can not longer login with their credentials.

We first archived the record and remove sensitive information (password,
login, so he can not log in again with the same credentials).

After the deactivation, we blacklist the email and the phone of the
user, so we are sure that we never send him again email / SMS.

Then, we create a <res.users.deletion> to delete the user and the
partner in a CRON because this operation can be heavy (write_uid,
create_uid field on all models).

Task-2629544

Part-of: odoo/odoo#78298

================================= pseudo patch: =================================

--- a/odoo/addons/base/models/__init__.py
+++ b/odoo/addons/base/models/__init__.py
@@ -44,5 +44,6 @@ from . import res_config
 from . import res_currency
 from . import res_company
 from . import res_users
+from . import res_users_deletion
 
 from . import decimal_precision

--- a/odoo/addons/base/models/res_users.py
+++ b/odoo/addons/base/models/res_users.py
@@ -816,6 +816,61 @@ class Users(models.Model):
         # use self.env.user here, because it has uid=SUPERUSER_ID
         return self.env.user.write({'password': new_passwd})
 
+    def _deactivate_portal_user(self, **post):
+        """Try to remove the current portal user.
+
+        This is used to give the opportunity to portal users to de-activate their accounts.
+        Indeed, as the portal users can easily create accounts, they will sometimes wish
+        it removed because they don't use this Odoo portal anymore.
+
+        Before this feature, they would have to contact the website or the support to get
+        their account removed, which could be tedious.
+        """
+        non_portal_users = self.filtered(lambda user: not user.share)
+        if non_portal_users:
+            raise AccessDenied(_(
+                'Only the portal users can delete their accounts. '
+                'The user(s) %s can not be deleted.',
+                ', '.join(non_portal_users.mapped('name')),
+            ))
+
+        ip = request.httprequest.environ['REMOTE_ADDR'] if request else 'n/a'
+
+        res_users_deletion_values = []
+
+        for user in self:
+            _logger.info(
+                'Account deletion asked for "%s" (#%i) from %s. '
+                'Archive the user and remove login information.',
+                user.login, user.id, ip,
+            )
+
+            user.write({
+                'login': f'__deleted_user_{user.id}_{time.time()}',
+                'password': '',
+                'api_key_ids': Command.clear(),
+            })
+
+            res_users_deletion_values.append({
+                'user_id': user.id,
+                'state': 'todo',
+            })
+
+        # Here we try to archive the user / partner, and then add the user in a deletion
+        # queue, to remove it from the database. As the deletion might fail (if the
+        # partner is related to an invoice e.g.) it's important to archive it here.
+        try:
+            # A user can not self-deactivate
+            self.with_user(SUPERUSER_ID).action_archive()
+        except Exception:
+            pass
+        try:
+            self.partner_id.action_archive()
+        except Exception:
+            pass
+        # Add users in the deletion queue
+        self.env['res.users.deletion'].create(res_users_deletion_values)
+
     def preference_save(self):
         return {
             'type': 'ir.actions.client',

--- a/None
+++ b/odoo/addons/base/models/res_users_deletion.py
@@ -0,0 +1,66 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+import logging
+
+
+from odoo import api, fields, models
+
+_logger = logging.getLogger(__name__)
+
+
+class ResUsersDeletion(models.Model):
+    """User deletion requests.
+
+    Those requests are logged in a different model to keep a trace of this action and the
+    deletion is done in a CRON. Indeed, removing a user can be a heavy operation on
+    large database (because of create_uid, write_uid on each model, which are not always
+    indexed). This model just remove the users added in the deletion queue, remaining code
+    must deal with other consideration (archiving, blacklist email...).
+    """
+
+    _name = 'res.users.deletion'
+    _description = 'Users Deletion Request'
+    _rec_name = 'user_id'
+
+    # Integer field because the related user might be deleted from the database
+    user_id = fields.Many2one('res.users', string='User', ondelete='set null')
+    user_id_int = fields.Integer('User Id', compute='_compute_user_id_int', store=True)
+    state = fields.Selection([('todo', 'To Do'), ('done', 'Done'), ('fail', 'Failed')],
+                             string='State', required=True, default='todo')
+
+    @api.depends('user_id')
+    def _compute_user_id_int(self):
+        for user_deletion in self:
+            if user_deletion.user_id:
+                user_deletion.user_id_int = user_deletion.user_id.id
+
+    @api.autovacuum
+    def _gc_portal_users(self):
+        """Remove the portal users that asked to deactivate their account.
+
+        (see <res.users>::_deactivate_portal_user)
+
+        Removing a user can be an heavy operation on large database (because of
+        create_uid, write_uid on each models, which are not always indexed). Because of
+        that, this operation is done in a CRON.
+        """
+        delete_requests = self.search([('state', '=', 'todo')])
+
+        # filter the requests related to a deleted user
+        done_requests = delete_requests.filtered(lambda request: not request.user_id)
+        done_requests.state = 'done'
+
+        for delete_request in (delete_requests - done_requests):
+            user = delete_request.user_id
+            user_name = user.name
+            try:
+                with self.env.cr.savepoint():
+                    partner = user.partner_id
+                    user.unlink()
+                    partner.unlink()
+                    _logger.info('User #%i %r, deleted. Original request from %r.',
+                                 user.id, user_name, delete_request.create_uid.name)
+                    delete_request.state = 'done'
+            except Exception:
+                delete_request.state = 'fail'

--- a/odoo/addons/base/security/ir.model.access.csv
+++ b/odoo/addons/base/security/ir.model.access.csv
@@ -70,6 +70,8 @@
 "access_res_partner_title_group_partner_manager","res_partner_title group_user","model_res_partner_title",,1,0,0,0
 "access_res_users_all","res_users all","model_res_users",,1,0,0,0
 "access_res_users_group_erp_manager","res_users group_erp_manager","model_res_users","group_erp_manager",1,1,1,1
+"access_res_users_deletion_all","res_users_deletion all","model_res_users_deletion",,0,0,0,0
+"access_res_users_deletion_group_erp_manager","res_users_deletion group_erp_manager","model_res_users_deletion","group_erp_manager",1,1,1,1
 "access_res_users_log_all","res_users_log_all","model_res_users_log",,1,0,1,0
 "access_res_users_identitycheck_employee","id check employees","model_res_users_identitycheck","group_user",1,1,1,0
 "access_res_users_identitycheck_portal","id check portal","model_res_users_identitycheck","group_portal",1,1,1,0

--- a/odoo/addons/base/tests/test_res_users.py
+++ b/odoo/addons/base/tests/test_res_users.py
@@ -2,7 +2,9 @@
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
 from odoo.addons.base.models.res_users import is_selection_groups, get_selection_groups
+from odoo.exceptions import UserError
 from odoo.tests.common import TransactionCase, Form, tagged
+from odoo.tools import mute_logger
 
 
 class TestUsers(TransactionCase):
@@ -116,6 +118,77 @@ class TestUsers(TransactionCase):
             "the company_id of the partner_id shall be updated"
         )
 
+    @mute_logger('odoo.sql_db')
+    def test_deactivate_portal_users_access(self):
+        """Test that only a portal users can deactivate his account."""
+        user_internal = self.env['res.users'].create({
+            'name': 'Internal',
+            'login': 'user_internal',
+            'password': 'password',
+            'groups_id': [self.env.ref('base.group_user').id],
+        })
+
+        with self.assertRaises(UserError, msg='Internal users should not be able to deactivate their account'):
+            user_internal._deactivate_portal_user()
+
+    @mute_logger('odoo.sql_db')
+    def test_deactivate_portal_users_archive_and_remove(self):
+        """Test that if the account can not be removed, it's archived instead
+        and sensitive information are removed.
+
+        In this test, the deletion of "portal_user" will succeed,
+        but the deletion of "portal_user_2" will fail.
+        """
+        User = self.env['res.users']
+        portal_user = User.create({
+            'name': 'Portal',
+            'login': 'portal_user',
+            'password': 'password',
+            'groups_id': [self.env.ref('base.group_portal').id],
+        })
+        portal_partner = portal_user.partner_id
+
+        portal_user_2 = User.create({
+            'name': 'Portal',
+            'login': 'portal_user_2',
+            'password': 'password',
+            'groups_id': [self.env.ref('base.group_portal').id],
+        })
+        portal_partner_2 = portal_user_2.partner_id
+
+        (portal_user | portal_user_2)._deactivate_portal_user()
+
+        self.assertTrue(portal_user.exists() and not portal_user.active, 'Should have archived the user 1')
+
+        self.assertEqual(portal_user.name, 'Portal', 'Should have kept the user name')
+        self.assertEqual(portal_user.partner_id.name, 'Portal', 'Should have kept the partner name')
+        self.assertNotEqual(portal_user.login, 'portal_user', 'Should have removed the user login')
+
+        asked_deletion_1 = self.env['res.users.deletion'].search([('user_id', '=', portal_user.id)])
+        asked_deletion_2 = self.env['res.users.deletion'].search([('user_id', '=', portal_user_2.id)])
+
+        self.assertTrue(asked_deletion_1, 'Should have added the user 1 in the deletion queue')
+        self.assertTrue(asked_deletion_2, 'Should have added the user 2 in the deletion queue')
+
+        # The deletion will fail for "portal_user_2",
+        # because of the absence of "ondelete=cascade"
+        self.cron = self.env['ir.cron'].create({
+            'name': 'Test Cron',
+            'user_id': portal_user_2.id,
+            'model_id': self.env.ref('base.model_res_partner').id,
+        })
+
+        self.env['res.users.deletion']._gc_portal_users()
+
+        self.assertFalse(portal_user.exists(), 'Should have removed the user')
+        self.assertFalse(portal_partner.exists(), 'Should have removed the partner')
+        self.assertEqual(asked_deletion_1.state, 'done', 'Should have marked the deletion as done')
+
+        self.assertTrue(portal_user_2.exists(), 'Should have kept the user')
+        self.assertTrue(portal_partner_2.exists(), 'Should have kept the partner')
+        self.assertEqual(asked_deletion_2.state, 'fail', 'Should have marked the deletion as failed')
+
+
 @tagged('post_install', '-at_install')
 class TestUsers2(TransactionCase):
     def test_reified_groups(self):
