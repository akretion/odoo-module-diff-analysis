PR: https://github.com/odoo/odoo/pull/47212

From: 172722c4d229063ba964095df5bcfadc25ba65c9
From: Xavier Morel
Date: 2020-04-08 06:03:28

Structural Changes: 3
Total Changes: 104

[IMP] base: remove redundant base64 back and forth in attachments

* add a `raw` computed field, though only update some of base to use
  it (addons for which that makes sense can be migrated progressively)
* avoid working with base64 data when it's possible to work with the
  actual data
* improve datas (base64 encoded content): should depend on bin_size

closes odoo/odoo#47212

Signed-off-by: Raphael Collet (rco) <rco@openerp.com>

================================= pseudo patch: =================================

--- a/odoo/addons/base/models/assetsbundle.py
+++ b/odoo/addons/base/models/assetsbundle.py
@@ -284,7 +284,7 @@ class AssetsBundle(object):
             'res_id': False,
             'type': 'binary',
             'public': True,
-            'datas': base64.b64encode(content.encode('utf8')),
+            'raw': content.encode('utf8'),
         }
         attachment = ira.with_user(SUPERUSER_ID).create(values)
 
@@ -425,7 +425,7 @@ class AssetsBundle(object):
                         outdated = True
                         break
                     if asset._content is None:
-                        asset._content = attachment.datas and base64.b64decode(attachment.datas).decode('utf8') or ''
+                        asset._content = (attachment.raw or b'').decode('utf8')
                         if not asset._content and attachment.file_size > 0:
                             asset._content = None # file missing, force recompile
 
@@ -478,7 +478,7 @@ class AssetsBundle(object):
                         url = asset.html_url
                         with self.env.cr.savepoint():
                             self.env['ir.attachment'].sudo().create(dict(
-                                datas=base64.b64encode(asset.content.encode('utf8')),
+                                raw=asset.content.encode('utf8'),
                                 mimetype='text/css',
                                 type='binary',
                                 name=fname,

--- a/odoo/addons/base/models/ir_actions_report.py
+++ b/odoo/addons/base/models/ir_actions_report.py
@@ -211,7 +211,7 @@ class IrActionsReport(models.Model):
             return None
         attachment_vals = {
             'name': attachment_name,
-            'datas': base64.encodebytes(buffer.getvalue()),
+            'raw': buffer.getvalue(),
             'res_model': self.model,
             'res_id': record.id,
             'type': 'binary',

--- a/odoo/addons/base/models/ir_attachment.py
+++ b/odoo/addons/base/models/ir_attachment.py
@@ -65,8 +65,7 @@ class IrAttachment(models.Model):
         }[self._storage()]
 
         for attach in self.search(domain):
-            # pass mimetype, to avoid recomputation
-            attach.write({'datas': attach.datas, 'mimetype': attach.mimetype})
+            attach.write({'raw': attach.raw, 'mimetype': attach.mimetype})
         return True
 
     @api.model
@@ -97,22 +96,17 @@ class IrAttachment(models.Model):
         return fname, full_path
 
     @api.model
-    def _file_read(self, fname, bin_size=False):
+    def _file_read(self, fname):
         full_path = self._full_path(fname)
-        r = ''
         try:
-            if bin_size:
-                r = human_size(os.path.getsize(full_path))
-            else:
-                with open(full_path,'rb') as fd:
-                    r = base64.b64encode(fd.read())
+            with open(full_path, 'rb') as f:
+                return f.read()
         except (IOError, OSError):
             _logger.info("_read_file reading %s", full_path, exc_info=True)
-        return r
+        return b''
 
     @api.model
-    def _file_write(self, value, checksum):
-        bin_value = base64.b64decode(value)
+    def _file_write(self, bin_value, checksum):
         fname, full_path = self._get_path(bin_value, checksum)
         if not os.path.exists(full_path):
             try:
@@ -192,18 +186,37 @@ class IrAttachment(models.Model):
         cr.commit()
         _logger.info("filestore gc %d checked, %d removed", len(checklist), removed)
 
-    @api.depends('store_fname', 'db_datas')
+    @api.depends('store_fname', 'db_datas', 'file_size')
+    @api.depends_context('bin_size')
     def _compute_datas(self):
-        bin_size = self._context.get('bin_size')
+        if self._context.get('bin_size'):
+            for attach in self:
+                attach.datas = human_size(attach.file_size)
+            return
+
+        for attach in self:
+            attach.datas = base64.b64encode(attach.raw or b'')
+
+    @api.depends('store_fname', 'db_datas')
+    def _compute_raw(self):
         for attach in self:
             if attach.store_fname:
-                attach.datas = self._file_read(attach.store_fname, bin_size)
+                attach.raw = self._file_read(attach.store_fname)
             else:
-                attach.datas = attach.db_datas
+                attach.raw = attach.db_datas
+
+    def _inverse_raw(self):
+        self._set_attachment_data(lambda a: a.raw or b'')
 
     def _inverse_datas(self):
+        self._set_attachment_data(lambda attach: base64.b64decode(attach.datas or b''))
+
+    def _set_attachment_data(self, asbytes):
         for attach in self:
-            vals = self._get_datas_related_values(attach.datas, attach.mimetype)
+            # compute the fields that depend on datas
+            bin_data = asbytes(attach)
+            vals = self._get_datas_related_values(bin_data, attach.mimetype)
+
             # take current location in filestore to possibly garbage-collect it
             fname = attach.store_fname
             # write as superuser, as user probably does not have write access
@@ -212,12 +225,10 @@ class IrAttachment(models.Model):
                 self._file_delete(fname)
 
     def _get_datas_related_values(self, data, mimetype):
-        # compute the fields that depend on datas
-        bin_data = base64.b64decode(data) if data else b''
         values = {
-            'file_size': len(bin_data),
-            'checksum': self._compute_checksum(bin_data),
-            'index_content': self._index(bin_data, mimetype),
+            'file_size': len(data),
+            'checksum': self._compute_checksum(data),
+            'index_content': self._index(data, mimetype),
             'store_fname': False,
             'db_datas': data,
         }
@@ -259,8 +270,14 @@ class IrAttachment(models.Model):
             mimetype = mimetypes.guess_type(values['name'])[0]
         if not mimetype and values.get('url'):
             mimetype = mimetypes.guess_type(values['url'])[0]
-        if values.get('datas') and (not mimetype or mimetype == 'application/octet-stream'):
-            mimetype = guess_mimetype(base64.b64decode(values['datas']))
+        if not mimetype or mimetype == 'application/octet-stream':
+            raw = None
+            if values.get('raw'):
+                raw = values['raw']
+            elif values.get('datas'):
+                raw = base64.b64decode(values['datas'])
+            if raw:
+                mimetype = guess_mimetype(raw)
         return mimetype or 'application/octet-stream'
 
     def _check_contents(self, values):
@@ -316,7 +333,8 @@ class IrAttachment(models.Model):
     access_token = fields.Char('Access Token', groups="base.group_user")
 
     # the field 'datas' is computed and may use the other fields below
-    datas = fields.Binary(string='File Content', compute='_compute_datas', inverse='_inverse_datas')
+    raw = fields.Binary(string="File Content (raw)", compute='_compute_raw', inverse='_inverse_raw', context_dependent=False)
+    datas = fields.Binary(string='File Content (base64)', compute='_compute_datas', inverse='_inverse_datas')
     db_datas = fields.Binary('Database Data', attachment=False)
     store_fname = fields.Char('Stored Filename')
     file_size = fields.Integer('File Size', readonly=True)
@@ -521,7 +539,8 @@ class IrAttachment(models.Model):
                 values.pop(field, False)
             values = self._check_contents(values)
             if 'datas' in values:
-                values.update(self._get_datas_related_values(values.pop('datas'), values['mimetype']))
+                data = values.pop('datas')
+                values.update(self._get_datas_related_values(base64.b64decode(data or b''), values['mimetype']))
             # 'check()' only uses res_model and res_id from values, and make an exists.
             # We can group the values by model, res_id to make only one query when 
             # creating multiple attachments on a single record.

--- a/odoo/addons/base/tests/test_ir_attachment.py
+++ b/odoo/addons/base/tests/test_ir_attachment.py
@@ -24,32 +24,30 @@ class TestIrAttachment(TransactionCase):
 
         # Blob2
         self.blob2 = b'blob2'
-        self.blob2_b64 = base64.b64encode(self.blob2)
 
     def test_01_store_in_db(self):
         # force storing in database
         self.env['ir.config_parameter'].set_param('ir_attachment.location', 'db')
 
         # 'ir_attachment.location' is undefined test database storage
-        a1 = self.Attachment.create({'name': 'a1', 'datas': self.blob1_b64})
+        a1 = self.Attachment.create({'name': 'a1', 'raw': self.blob1})
         self.assertEqual(a1.datas, self.blob1_b64)
 
-        a1_db_datas = a1.db_datas
-        self.assertEqual(a1_db_datas, self.blob1_b64)
+        self.assertEqual(a1.db_datas, self.blob1)
 
     def test_02_store_on_disk(self):
-        a2 = self.Attachment.create({'name': 'a2', 'datas': self.blob1_b64})
+        a2 = self.Attachment.create({'name': 'a2', 'raw': self.blob1})
         self.assertEqual(a2.store_fname, self.blob1_fname)
         self.assertTrue(os.path.isfile(os.path.join(self.filestore, a2.store_fname)))
 
     def test_03_no_duplication(self):
-        a2 = self.Attachment.create({'name': 'a2', 'datas': self.blob1_b64})
-        a3 = self.Attachment.create({'name': 'a3', 'datas': self.blob1_b64})
+        a2 = self.Attachment.create({'name': 'a2', 'raw': self.blob1})
+        a3 = self.Attachment.create({'name': 'a3', 'raw': self.blob1})
         self.assertEqual(a3.store_fname, a2.store_fname)
 
     def test_04_keep_file(self):
-        a2 = self.Attachment.create({'name': 'a2', 'datas': self.blob1_b64})
-        a3 = self.Attachment.create({'name': 'a3', 'datas': self.blob1_b64})
+        a2 = self.Attachment.create({'name': 'a2', 'raw': self.blob1})
+        a3 = self.Attachment.create({'name': 'a3', 'raw': self.blob1})
 
         a2_fn = os.path.join(self.filestore, a2.store_fname)
 
@@ -57,13 +55,13 @@ class TestIrAttachment(TransactionCase):
         self.assertTrue(os.path.isfile(a2_fn))
 
     def test_05_change_data_change_file(self):
-        a2 = self.Attachment.create({'name': 'a2', 'datas': self.blob1_b64})
+        a2 = self.Attachment.create({'name': 'a2', 'raw': self.blob1})
         a2_store_fname1 = a2.store_fname
         a2_fn = os.path.join(self.filestore, a2_store_fname1)
 
         self.assertTrue(os.path.isfile(a2_fn))
 
-        a2.write({'datas': self.blob2_b64})
+        a2.write({'raw': self.blob2})
 
         a2_store_fname2 = a2.store_fname
         self.assertNotEqual(a2_store_fname1, a2_store_fname2)
@@ -72,7 +70,6 @@ class TestIrAttachment(TransactionCase):
         self.assertTrue(os.path.isfile(a2_fn))
 
     def test_06_linked_record_permission(self):
-        model_ir_attachment = self.env.ref('base.model_ir_attachment')
         Attachment = self.Attachment.with_user(self.env.ref('base.user_demo').id)
         a1 = self.Attachment.create({'name': 'a1'})
         vals = {'name': 'attach', 'res_id': a1.id, 'res_model': 'ir.attachment'}
@@ -97,12 +94,12 @@ class TestIrAttachment(TransactionCase):
         with self.assertRaises(AccessError):
             a3 = Attachment.create(vals)
         with self.assertRaises(AccessError):
-            a2.write({'datas': self.blob2_b64})
+            a2.write({'raw': self.blob2})
         with self.assertRaises(AccessError):
             a2.unlink()
 
         # write permission on linked record
         rule.perm_write = False
         a4 = Attachment.create(vals)
-        a4.write({'datas': self.blob2_b64})
+        a4.write({'raw': self.blob2})
         a4.unlink()
