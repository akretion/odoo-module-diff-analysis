PR: https://github.com/odoo/odoo/pull/152233

From: 6ed853270567b3faeb6797f8c42bf6aa483095dc
From: miad-odoo
Date: 2024-04-05 17:42:33

Structural Changes: 3
Total Changes: 171

[IMP] event_crm: allow generating all leads for an event

This commit allows event managers to re-generate all leads for a specific event
based on existing event.lead.rules.

A technical model was created to allow properly batching the process as it can
be relatively heavy depending on the registrations count for that event.
The batching method uses a CRON calling itself through CRON triggers.

We took this opportunity to slightly rework the "leads" stat button on the
event form to make it match the style of other stat buttons.

Task-3461434

closes odoo/odoo#152233

Signed-off-by: Thibault Delavallee (tde) <tde@openerp.com>
Co-authored-by: Aur√©lien Warnon <awa@odoo.com>

================================= pseudo patch: =================================

--- a/addons/event_crm/models/__init__.py
+++ b/addons/event_crm/models/__init__.py
@@ -1,7 +1,8 @@
 # -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
-from . import event_lead_rule
-from . import event_registration
 from . import crm_lead
 from . import event_event
+from . import event_lead_request
+from . import event_lead_rule
+from . import event_registration

--- a/addons/event_crm/models/event_event.py
+++ b/addons/event_crm/models/event_event.py
@@ -1,8 +1,8 @@
 # -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
-from odoo import fields, models, api
-
+from odoo import _, api, fields, models
+from odoo.exceptions import UserError
 
 class EventEvent(models.Model):
     _name = "event.event"
@@ -13,6 +13,19 @@ class EventEvent(models.Model):
         help="Leads generated from this event")
     lead_count = fields.Integer(
         string="# Leads", compute='_compute_lead_count', groups='sales_team.group_sale_salesman')
+    has_lead_request = fields.Boolean(
+        "Ongoing Generation Request", compute="_compute_has_lead_request", compute_sudo=True,
+        help="Set to True when a Lead Generation Request is currently running.")
+
+    @api.depends('registration_ids')
+    def _compute_has_lead_request(self):
+        lead_requests_data = self.env['event.lead.request']._read_group(
+            [('event_id', 'in', self.ids)],
+            ['event_id'], ['__count'],
+        )
+        mapped_data = {event.id: count for event, count in lead_requests_data}
+        for event in self:
+            event.has_lead_request = mapped_data.get(event.id, 0) != 0
 
     @api.depends('lead_ids')
     def _compute_lead_count(self):
@@ -23,3 +36,42 @@ class EventEvent(models.Model):
         mapped_data = {event.id: count for event, count in lead_data}
         for event in self:
             event.lead_count = mapped_data.get(event.id, 0)
+
+    def action_generate_leads(self):
+        """ Re-generate leads based on event.lead.rules.
+        The method is ran synchronously if there is a low amount of registrations, otherwise it
+        goes through a CRON job that runs in batches. """
+
+        if not self.env.user.has_group('event.group_event_manager'):
+            raise UserError(_("Only Event Managers are allowed to re-generate all leads."))
+
+        self.ensure_one()
+        registrations_count = self.env['event.registration'].search_count([
+            ('event_id', '=', self.id),
+            ('state', 'not in', ['draft', 'cancel']),
+        ])
+
+        if registrations_count <= self.env['event.lead.request']._REGISTRATIONS_BATCH_SIZE:
+            leads = self.env['event.registration'].search([
+                ('event_id', '=', self.id),
+                ('state', 'not in', ['draft', 'cancel']),
+            ])._apply_lead_generation_rules()
+            if leads:
+                notification = _("Yee-ha, %(leads_count)s Leads have been created!", leads_count=len(leads))
+            else:
+                notification = _("Aww! No Leads created, check your Lead Generation Rules and try again.")
+        else:
+            self.env['event.lead.request'].sudo().create({'event_id': self.id})
+            self.env.ref('event_crm.ir_cron_generate_leads')._trigger()
+            notification = _("Got it! We've noted your request. Your leads will be created soon!")
+
+        return {
+            'type': 'ir.actions.client',
+            'tag': 'display_notification',
+            'params': {
+                'type': 'info',
+                'sticky': False,
+                'message': notification,
+                'next': {'type': 'ir.actions.act_window_close'},  # force a form reload
+            }
+        }

--- a/None
+++ b/addons/event_crm/models/event_lead_request.py
@@ -0,0 +1,79 @@
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+import threading
+
+from odoo import api, fields, models
+
+
+class EventLeadRequest(models.Model):
+    """ Technical model created when a user requests 'leads generation' on an event based on all
+    existing event.lead.rules (see event#action_generate_leads).
+
+    As an event can hold a lot of registrations, we use a batch approach with a separate model that
+    contains the batching logic method and the field to retain progress.
+
+    To benefit from a background processing, we use a CRON that calls itself with a CRON trigger
+    until the batch is completed, which unlinks this technical generation record. """
+
+    _name = "event.lead.request"
+    _description = "Event Lead Request"
+    _log_access = False
+    _rec_name = "event_id"
+    _order = "id asc"
+
+    _REGISTRATIONS_BATCH_SIZE = 200
+
+    event_id = fields.Many2one('event.event', required=True, string="Event", ondelete="cascade")
+    processed_registration_id = fields.Integer("Processed Registration",
+        help="The ID of the last processed event.registration, used to know where to resume.")
+
+    _sql_constraints = [
+        ('uniq_event', 'unique(event_id)', 'You can only have one generation request per event at a time.'),
+    ]
+
+    @api.model
+    def _cron_generate_leads(self, job_limit=100, registrations_batch_size=None):
+        """ See class docstring for details.
+
+        :param job_limit: The maximum amount of 'event.lead.request' to process
+          Defaults to 100.
+        :param registrations_batch_size: The amount of attendees processed at once.
+          Defaults to event.lead.request._REGISTRATIONS_BATCH_SIZE """
+
+        # auto-commit except in testing mode
+        auto_commit = not getattr(threading.current_thread(), 'testing', False)
+
+        registrations_batch_size = registrations_batch_size or self._REGISTRATIONS_BATCH_SIZE
+        generate_requests = self.env['event.lead.request'].search([], limit=job_limit)
+        fulfilled_requests = self.env['event.lead.request']
+        for generate_request in generate_requests:
+            registrations_to_process = self.env['event.registration'].search([
+                ('event_id', '=', generate_request.event_id.id),
+                ('state', 'not in', ['draft', 'cancel']),
+                ('id', '>', generate_request.processed_registration_id)],
+                limit=registrations_batch_size,
+                order='id asc'
+            )
+
+            registrations_to_process._apply_lead_generation_rules()
+
+            if len(registrations_to_process) < registrations_batch_size:
+                # done processing
+                fulfilled_requests += generate_request
+            else:
+                # not complete yet, update last processed registration
+                generate_request.processed_registration_id = registrations_to_process[-1].id
+
+            if auto_commit:
+                # commit after each completed batch/completed request
+                # avoids to re-process everything if an issue with one of the requests
+                # important as the lead creation process can typically send emails
+                # that should not be duped
+                self.env.cr.commit()
+
+        if generate_requests - fulfilled_requests:
+            # we still have unfinished requests: run the CRON again
+            self.env.ref('event_crm.ir_cron_generate_leads')._trigger()
+
+        if fulfilled_requests:
+            fulfilled_requests.unlink()

--- a/addons/event_crm/models/event_lead_rule.py
+++ b/addons/event_crm/models/event_lead_rule.py
@@ -142,8 +142,8 @@ class EventLeadRule(models.Model):
         # order by ID, ensure first created wins
         registrations = registrations.sorted('id')
 
-        # first: ensure no duplicate by searching existing registrations / rule
-        existing_leads = self.env['crm.lead'].search([
+        # first: ensure no duplicate by searching existing registrations / rule (include lost leads)
+        existing_leads = self.env['crm.lead'].with_context(active_test=False).search([
             ('registration_ids', 'in', registrations.ids),
             ('event_lead_rule_id', 'in', self.ids)
         ])

--- a/addons/event_crm/models/event_registration.py
+++ b/addons/event_crm/models/event_registration.py
@@ -32,14 +32,7 @@ class EventRegistration(models.Model):
         # as registrations can be automatically confirmed, or even created directly
         # with a state given in values
         if not self.env.context.get('event_lead_rule_skip'):
-            self.env['event.lead.rule'].search([('lead_creation_trigger', '=', 'create')]).sudo()._run_on_registrations(registrations)
-            open_registrations = registrations.filtered(lambda reg: reg.state == 'open')
-            if open_registrations:
-                self.env['event.lead.rule'].search([('lead_creation_trigger', '=', 'confirm')]).sudo()._run_on_registrations(open_registrations)
-            done_registrations = registrations.filtered(lambda reg: reg.state == 'done')
-            if done_registrations:
-                self.env['event.lead.rule'].search([('lead_creation_trigger', '=', 'done')]).sudo()._run_on_registrations(done_registrations)
-
+            registrations._apply_lead_generation_rules()
         return registrations
 
     def write(self, vals):
@@ -86,6 +79,24 @@ class EventRegistration(models.Model):
         buy tickets, not when bootstrapping a database. """
         return super(EventRegistration, self.with_context(event_lead_rule_skip=True))._load_records_write(values)
 
+    def _apply_lead_generation_rules(self):
+        leads = self.env['crm.lead']
+        open_registrations = self.filtered(lambda reg: reg.state == 'open')
+        done_registrations = self.filtered(lambda reg: reg.state == 'done')
+
+        leads += self.env['event.lead.rule'].search(
+            [('lead_creation_trigger', '=', 'create')]
+        ).sudo()._run_on_registrations(self)
+        if open_registrations:
+            leads += self.env['event.lead.rule'].search(
+                [('lead_creation_trigger', '=', 'confirm')]
+            ).sudo()._run_on_registrations(open_registrations)
+        if done_registrations:
+            leads += self.env['event.lead.rule'].search(
+                [('lead_creation_trigger', '=', 'done')]
+            ).sudo()._run_on_registrations(done_registrations)
+        return leads
+
     def _update_leads(self, new_vals, lead_tracked_vals):
         """ Update leads linked to some registrations. Update is based depending
         on updated fields, see ``_get_lead_contact_fields()`` and ``_get_lead_
