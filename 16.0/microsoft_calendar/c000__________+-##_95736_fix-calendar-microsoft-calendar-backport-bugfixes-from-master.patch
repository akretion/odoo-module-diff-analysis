PR: https://github.com/odoo/odoo/pull/95736

From: 2fbfbf0dce6819b719bdfa674f29772fbed3b167
From: RÃ©my Baranx (bar)
Date: 2022-07-12 11:21:27

Structural Changes: 3
Total Changes: 713

[FIX] calendar, microsoft_calendar: backport bugfixes from master

As several customers complained about lot of bugs in microsoft_calendar in 14.0,
It has been decided to backport bug fixes of the model layer from master to 14.0,
without the need of an upgrade script (no new field, ...).

In master, we use 2 ids (organizer event id + universal id) instead of only one,
to handle Odoo <-> Outlook sync correctly when several attendees sync their Outlook
calendar with their Odoo calendar. For that, we have added a new field.
To report this bug fix in 14.0, the existing field which stores the organizer event id,
is now a string storing both ids separated by a ':' as follow: 'organizer_event_id:universal_id'.

2 new compute fields have been added to be able to use these 2 ids more easily.

(all commits from the original PR have been squashed to ease forward-port)

closes odoo/odoo#95736

X-original-commit: 5e83318a7240585371efd31e407829793f3e732f
Signed-off-by: Arnaud Joset <arj@odoo.com>
Signed-off-by: Yannick Tivisse (yti) <yti@odoo.com>

================================= pseudo patch: =================================

--- a/addons/microsoft_calendar/models/calendar.py
+++ b/addons/microsoft_calendar/models/calendar.py
@@ -1,14 +1,17 @@
 # -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
+import logging
 import pytz
 import re
+from datetime import datetime
 from dateutil.parser import parse
 from dateutil.relativedelta import relativedelta
 
 from odoo import api, fields, models, _
 from odoo.exceptions import UserError, ValidationError
-from odoo.tools import is_html_empty
+from odoo.tools import is_html_empty, email_normalize
+from odoo.addons.microsoft_calendar.utils.event_id_storage import combine_ids
 
 ATTENDEE_CONVERTER_O2M = {
     'needsAction': 'notresponded',
@@ -29,13 +32,19 @@ VIDEOCALL_URL_PATTERNS = (
 )
 MAX_RECURRENT_EVENT = 720
 
+_logger = logging.getLogger(__name__)
+
 class Meeting(models.Model):
     _name = 'calendar.event'
     _inherit = ['calendar.event', 'microsoft.calendar.sync']
 
+    # contains organizer event id and universal event id separated by a ':'
     microsoft_id = fields.Char('Microsoft Calendar Event Id')
     microsoft_recurrence_master_id = fields.Char('Microsoft Recurrence Master Id')
 
+    def _get_organizer(self):
+        return self.user_id
+
     @api.model
     def _get_microsoft_synced_fields(self):
         return {'name', 'description', 'allday', 'start', 'date_end', 'stop',
@@ -51,25 +60,68 @@ class Meeting(models.Model):
     @api.model_create_multi
     def create(self, vals_list):
         notify_context = self.env.context.get('dont_notify', False)
+
+        # for a recurrent event, we do not create events separately but we directly
+        # create the recurrency from the corresponding calendar.recurrence.
+        # That's why, events from a recurrency have their `need_sync_m` attribute set to False.
         return super(Meeting, self.with_context(dont_notify=notify_context)).create([
             dict(vals, need_sync_m=False) if vals.get('recurrence_id') or vals.get('recurrency') else vals
             for vals in vals_list
         ])
 
+    def _check_recurrence_overlapping(self, new_start):
+        """
+        Outlook does not allow to modify time fields of an event if this event crosses
+        or overlaps the recurrence. In this case a 400 error with the Outlook code "ErrorOccurrenceCrossingBoundary"
+        is returned. That means that the update violates the following Outlook restriction on recurrence exceptions:
+        an occurrence cannot be moved to or before the day of the previous occurrence, and cannot be moved to or after
+        the day of the following occurrence.
+        For example: E1 E2 E3 E4 cannot becomes E1 E3 E2 E4
+        """
+        before_count = len(self.recurrence_id.calendar_event_ids.filtered(
+            lambda e: e.start.date() < self.start.date() and e != self
+        ))
+        after_count = len(self.recurrence_id.calendar_event_ids.filtered(
+            lambda e: e.start.date() < parse(new_start).date() and e != self
+        ))
+        if before_count != after_count:
+            raise UserError(_(
+                "Outlook limitation: in a recurrence, an event cannot be moved to or before the day of the "
+                "previous event, and cannot be moved to or after the day of the following event."
+            ))
+
+    def _is_matching_timeslot(self, start, stop, allday):
+        """
+        Check if an event matches with the provided timeslot
+        """
+        self.ensure_one()
+
+        event_start, event_stop = self._range()
+        if allday:
+            event_start = datetime(event_start.year, event_start.month, event_start.day, 0, 0)
+            event_stop = datetime(event_stop.year, event_stop.month, event_stop.day, 0, 0)
+
+        return (event_start, event_stop) == (start, stop)
+
     def write(self, values):
         recurrence_update_setting = values.get('recurrence_update')
-        if recurrence_update_setting in ('all_events', 'future_events') and len(self) == 1:
-            values = dict(values, need_sync_m=False)
-        elif recurrence_update_setting == 'self_only' and 'start' in values:
-            previous_event_before_write = self.recurrence_id.calendar_event_ids.filtered(lambda e: e.start.date() < self.start.date() and e != self)
-            new_start = parse(values['start']).date()
-            previous_event_after_write = self.recurrence_id.calendar_event_ids.filtered(lambda e: e.start.date() < new_start and e != self)
-            if previous_event_before_write != previous_event_after_write:
-                # Outlook returns a 400 error if you try to synchronize an occurrence of this type.
-                raise UserError(_("Modified occurrence is crossing or overlapping adjacent occurrence."))
+
+        # check a Outlook limitation in overlapping the actual recurrence
+        if recurrence_update_setting == 'self_only' and 'start' in values:
+            self._check_recurrence_overlapping(values['start'])
+
+        # if a single event becomes the base event of a recurrency, it should be first
+        # removed from the Outlook calendar.
+        if 'recurrency' in values and values['recurrency']:
+            for e in self.filtered(lambda e: not e.recurrency and not e.recurrence_id):
+                e._microsoft_delete(e._get_organizer(), e.ms_organizer_event_id, timeout=3)
+                e.microsoft_id = False
+
         notify_context = self.env.context.get('dont_notify', False)
         res = super(Meeting, self.with_context(dont_notify=notify_context)).write(values)
-        if recurrence_update_setting in ('all_events',) and len(self) == 1 and values.keys() & self._get_microsoft_synced_fields():
+
+        if recurrence_update_setting in ('all_events',) and len(self) == 1 \
+           and values.keys() & self._get_microsoft_synced_fields():
             self.recurrence_id.need_sync_m = True
         return res
 
@@ -89,7 +141,7 @@ class Meeting(models.Model):
 
 
     @api.model
-    def _microsoft_to_odoo_values(self, microsoft_event, default_reminders=(), default_values={}):
+    def _microsoft_to_odoo_values(self, microsoft_event, default_reminders=(), default_values=None, with_ids=False):
         if microsoft_event.is_cancelled():
             return {'active': False}
 
@@ -107,12 +159,12 @@ class Meeting(models.Model):
             stop = parse(microsoft_event.end.get('dateTime')).astimezone(timeZone_stop).replace(tzinfo=None) - relativedelta(days=1)
         else:
             stop = parse(microsoft_event.end.get('dateTime')).astimezone(timeZone_stop).replace(tzinfo=None)
-        values = {
-            **default_values,
+        values = default_values or {}
+        values.update({
             'name': microsoft_event.subject or _("(No title)"),
             'description': microsoft_event.body and microsoft_event.body['content'],
             'location': microsoft_event.location and microsoft_event.location.get('displayName') or False,
-            'user_id': microsoft_event.owner(self.env).id,
+            'user_id': microsoft_event.owner_id(self.env),
             'privacy': sensitivity_o2m.get(microsoft_event.sensitivity, self.default_get(['privacy'])['privacy']),
             'attendee_ids': commands_attendee,
             'allday': microsoft_event.isAllDay,
@@ -120,14 +172,14 @@ class Meeting(models.Model):
             'stop': stop,
             'show_as': 'free' if microsoft_event.showAs == 'free' else 'busy',
             'recurrency': microsoft_event.is_recurrent()
-        }
+        })
         if commands_partner:
             # Add partner_commands only if set from Microsoft. The write method on calendar_events will
             # override attendee commands if the partner_ids command is set but empty.
             values['partner_ids'] = commands_partner
 
         if microsoft_event.is_recurrent() and not microsoft_event.is_recurrence():
-            # Propagate the follow_recurrence according to the google result
+            # Propagate the follow_recurrence according to the Outlook result
             values['follow_recurrence'] = not microsoft_event.is_recurrence_outlier()
 
         # if a videocall URL is provided with the Outlook event, use it
@@ -140,7 +192,9 @@ class Meeting(models.Model):
                 values['videocall_location'] = values['location']
                 values['location'] = False
 
-        values['microsoft_id'] = microsoft_event.id
+        if with_ids:
+            values['microsoft_id'] = combine_ids(microsoft_event.id, microsoft_event.iCalUId)
+
         if microsoft_event.is_recurrent():
             values['microsoft_recurrence_master_id'] = microsoft_event.seriesMasterId
 
@@ -151,7 +205,7 @@ class Meeting(models.Model):
         return values
 
     @api.model
-    def _microsoft_to_odoo_recurrence_values(self, microsoft_event, default_reminders=(), values={}):
+    def _microsoft_to_odoo_recurrence_values(self, microsoft_event, default_values=None):
         timeZone_start = pytz.timezone(microsoft_event.start.get('timeZone'))
         timeZone_stop = pytz.timezone(microsoft_event.end.get('timeZone'))
         start = parse(microsoft_event.start.get('dateTime')).astimezone(timeZone_start).replace(tzinfo=None)
@@ -159,10 +213,13 @@ class Meeting(models.Model):
             stop = parse(microsoft_event.end.get('dateTime')).astimezone(timeZone_stop).replace(tzinfo=None) - relativedelta(days=1)
         else:
             stop = parse(microsoft_event.end.get('dateTime')).astimezone(timeZone_stop).replace(tzinfo=None)
-        values['microsoft_id'] = microsoft_event.id
-        values['microsoft_recurrence_master_id'] = microsoft_event.seriesMasterId
-        values['start'] = start
-        values['stop'] = stop
+        values = default_values or {}
+        values.update({
+            'microsoft_id': combine_ids(microsoft_event.id, microsoft_event.iCalUId),
+            'microsoft_recurrence_master_id': microsoft_event.seriesMasterId,
+            'start': start,
+            'stop': stop,
+        })
         return values
 
     @api.model
@@ -171,9 +228,13 @@ class Meeting(models.Model):
         commands_partner = []
 
         microsoft_attendees = microsoft_event.attendees or []
-        emails = [a.get('emailAddress').get('address') for a in microsoft_attendees]
+        emails = [
+            a.get('emailAddress').get('address')
+            for a in microsoft_attendees
+            if email_normalize(a.get('emailAddress').get('address'))
+        ]
         existing_attendees = self.env['calendar.attendee']
-        if microsoft_event.exists(self.env):
+        if microsoft_event.match_with_odoo_events(self.env):
             existing_attendees = self.env['calendar.attendee'].search([
                 ('event_id', '=', microsoft_event.odoo_id(self.env)),
                 ('email', 'in', emails)])
@@ -182,20 +243,18 @@ class Meeting(models.Model):
             commands_partner += [(4, self.env.user.partner_id.id)]
         partners = self.env['mail.thread']._mail_find_partner_from_emails(emails, records=self, force_create=True)
         attendees_by_emails = {a.email: a for a in existing_attendees}
-        for attendee in zip(emails, partners, microsoft_attendees):
-            email = attendee[0]
-            state = ATTENDEE_CONVERTER_M2O.get(attendee[2].get('status').get('response'))
+        for email, partner, attendee_info in zip(emails, partners, microsoft_attendees):
+            state = ATTENDEE_CONVERTER_M2O.get(attendee_info.get('status').get('response'), 'needsAction')
 
             if email in attendees_by_emails:
                 # Update existing attendees
                 commands_attendee += [(1, attendees_by_emails[email].id, {'state': state})]
-            elif attendee[1]:
+            elif partner:
                 # Create new attendees
-                partner = attendee[1]
                 commands_attendee += [(0, 0, {'state': state, 'partner_id': partner.id})]
                 commands_partner += [(4, partner.id)]
-                if attendee[2].get('emailAddress').get('name') and not partner.name:
-                    partner.name = attendee[2].get('emailAddress').get('name')
+                if attendee_info.get('emailAddress').get('name') and not partner.name:
+                    partner.name = attendee_info.get('emailAddress').get('name')
         for odoo_attendee in attendees_by_emails.values():
             # Remove old attendees
             if odoo_attendee.email not in emails:
@@ -269,15 +328,7 @@ class Meeting(models.Model):
         if not fields_to_sync:
             return values
 
-        values['id'] = self.microsoft_id
         microsoft_guid = self.env['ir.config_parameter'].sudo().get_param('microsoft_calendar.microsoft_guid', False)
-        values['singleValueExtendedProperties'] = [{
-            'id': 'String {%s} Name odoo_id' % microsoft_guid,
-            'value': str(self.id),
-        }, {
-            'id': 'String {%s} Name owner_odoo_id' % microsoft_guid,
-            'value': str(self.user_id.id),
-        }]
 
         if self.microsoft_recurrence_master_id and 'type' not in values:
             values['seriesMasterId'] = self.microsoft_recurrence_master_id
@@ -417,17 +468,7 @@ class Meeting(models.Model):
                                     "\n%s", details, invalid_events))
 
     def _microsoft_values_occurence(self, initial_values={}):
-        values = dict(initial_values)
-        values['id'] = self.microsoft_id
-        microsoft_guid = self.env['ir.config_parameter'].sudo().get_param('microsoft_calendar.microsoft_guid', False)
-        values['singleValueExtendedProperties'] = [{
-            'id': 'String {%s} Name odoo_id' % microsoft_guid,
-            'value': str(self.id),
-        }, {
-            'id': 'String {%s} Name owner_odoo_id' % microsoft_guid,
-            'value': str(self.user_id.id),
-        }]
-
+        values = initial_values
         values['type'] = 'occurrence'
 
         if self.allday:

--- a/addons/microsoft_calendar/models/calendar_attendee.py
+++ b/addons/microsoft_calendar/models/calendar_attendee.py
@@ -40,8 +40,12 @@ class Attendee(models.Model):
         return res
 
     def _microsoft_sync_event(self, answer):
-        microsoft_service = MicrosoftCalendarService(self.env['microsoft.service'])
         params = {"comment": "", "sendResponse": True}
         # Microsoft prevent user to answer the meeting when they are the organizer
-        for event in self.event_id.filtered(lambda e: e.microsoft_id and e.user_id != self.env.user):
-            event._microsoft_attendee_answer(microsoft_service, event.microsoft_id, answer, params)
+        linked_events = self.event_id._get_synced_events()
+        for event in linked_events.filtered(lambda e: e.user_id != self.env.user):
+            event._microsoft_patch(
+                event._get_organizer(),
+                event.ms_organizer_event_id,
+                event._microsoft_values(["attendee_ids"]),
+            )

--- a/addons/microsoft_calendar/models/calendar_recurrence_rule.py
+++ b/addons/microsoft_calendar/models/calendar_recurrence_rule.py
@@ -3,8 +3,6 @@
 
 from odoo import api, fields, models
 
-from odoo.addons.microsoft_calendar.utils.microsoft_calendar import MicrosoftCalendarService
-
 
 class RecurrenceRule(models.Model):
     _name = 'calendar.recurrence'
@@ -36,17 +34,11 @@ class RecurrenceRule(models.Model):
         events = self.filtered('need_sync_m').calendar_event_ids
         detached_events = super()._apply_recurrence(specific_values_creation, no_send_edit, generic_values_creation)
 
-        microsoft_service = MicrosoftCalendarService(self.env['microsoft.service'])
-
         # If a synced event becomes a recurrence, the event needs to be deleted from
         # Microsoft since it's now the recurrence which is synced.
-        # Those events are kept in the database and their microsoft_id is updated
-        # according to the recurrence microsoft_id, therefore we need to keep an inactive copy
-        # of those events with the original microsoft_id. The next sync will then correctly
-        # delete those events from Microsoft.
         vals = []
-        for event in events.filtered('microsoft_id'):
-            if event.active and event.microsoft_id and not event.recurrence_id.microsoft_id:
+        for event in events._get_synced_events():
+            if event.active and event.ms_universal_event_id and not event.recurrence_id.ms_universal_event_id:
                 vals += [{
                     'name': event.name,
                     'microsoft_id': event.microsoft_id,
@@ -55,8 +47,8 @@ class RecurrenceRule(models.Model):
                     'active': False,
                     'need_sync_m': True,
                 }]
-                event._microsoft_delete(microsoft_service, event.microsoft_id)
-                event.microsoft_id = False
+                event._microsoft_delete(event.user_id, event.ms_organizer_event_id)
+                event.ms_universal_event_id = False
         self.env['calendar.event'].create(vals)
         self.calendar_event_ids.need_sync_m = False
         return detached_events
@@ -64,9 +56,12 @@ class RecurrenceRule(models.Model):
     def _write_events(self, values, dtstart=None):
         # If only some events are updated, sync those events.
         # If all events are updated, sync the recurrence instead.
-        values['need_sync_m'] = bool(dtstart)
+        values['need_sync_m'] = bool(dtstart) or values.get("need_sync_m", True)
         return super()._write_events(values, dtstart=dtstart)
 
+    def _get_organizer(self):
+        return self.base_event_id.user_id
+
     def _get_rrule(self, dtstart=None):
         if not dtstart and self.dtstart:
             dtstart = self.dtstart
@@ -81,22 +76,40 @@ class RecurrenceRule(models.Model):
             'need_sync_m': True,
         })
 
+    def _has_base_event_time_fields_changed(self, new):
+        """
+        Indicates if at least one time field of the base event has changed, based
+        on provided `new` values.
+        Note: for all day event comparison, hours/minutes are ignored.
+        """
+        def _convert(value, to_convert):
+            return value.date() if to_convert else value
+
+        old = self.base_event_id and self.base_event_id.read(['start', 'stop', 'allday'])[0]
+        return old and (
+            old['allday'] != new['allday']
+            or any(
+                _convert(new[f], new['allday']) != _convert(old[f], old['allday'])
+                for f in ('start', 'stop')
+            )
+        )
+
     def _write_from_microsoft(self, microsoft_event, vals):
         current_rrule = self.rrule
         # event_tz is written on event in Microsoft but on recurrence in Odoo
         vals['event_tz'] = microsoft_event.start.get('timeZone')
         super()._write_from_microsoft(microsoft_event, vals)
-        base_event_time_fields = ['start', 'stop', 'allday']
         new_event_values = self.env["calendar.event"]._microsoft_to_odoo_values(microsoft_event)
-        old_event_values = self.base_event_id and self.base_event_id.read(base_event_time_fields)[0]
-        if old_event_values and any(new_event_values[key] != old_event_values[key] for key in base_event_time_fields):
+        if self._has_base_event_time_fields_changed(new_event_values):
             # we need to recreate the recurrence, time_fields were modified.
             base_event_id = self.base_event_id
             # We archive the old events to recompute the recurrence. These events are already deleted on Microsoft side.
             # We can't call _cancel because events without user_id would not be deleted
             (self.calendar_event_ids - base_event_id).microsoft_id = False
             (self.calendar_event_ids - base_event_id).unlink()
-            base_event_id.with_context(dont_notify=True).write(dict(new_event_values, microsoft_id=False, need_sync_m=False))
+            base_event_id.with_context(dont_notify=True).write(dict(
+                new_event_values, microsoft_id=False, need_sync_m=False
+            ))
             if self.rrule == current_rrule:
                 # if the rrule has changed, it will be recalculated below
                 # There is no detached event now
@@ -113,7 +126,7 @@ class RecurrenceRule(models.Model):
                 if field not in time_fields
                 }, need_sync_m=False)
             )
-        # We apply the rrule check after the time_field check because the microsoft_id are generated according
+        # We apply the rrule check after the time_field check because the microsoft ids are generated according
         # to base_event start datetime.
         if self.rrule != current_rrule:
             detached_events = self._apply_recurrence()
@@ -127,37 +140,45 @@ class RecurrenceRule(models.Model):
         # We also prevent sync of other user recurrent events.
         return [('calendar_event_ids.user_id', '=', self.env.user.id), ('rrule', '!=', False)]
 
-
     def _cancel_microsoft(self):
         self.calendar_event_ids._cancel_microsoft()
         super()._cancel_microsoft()
 
     @api.model
-    def _microsoft_to_odoo_values(self, microsoft_recurrence, default_reminders=(), default_values={}):
+    def _microsoft_to_odoo_values(self, microsoft_recurrence, default_reminders=(), default_values=None, with_ids=False):
         recurrence = microsoft_recurrence.get_recurrence()
 
-        return {
-            **recurrence,
-            'microsoft_id': microsoft_recurrence.id,
-        }
+        if with_ids:
+            recurrence = {
+                **recurrence,
+                'ms_organizer_event_id': microsoft_recurrence.id,
+                'ms_universal_event_id': microsoft_recurrence.iCalUId,
+            }
+
+        return recurrence
 
     def _microsoft_values(self, fields_to_sync):
-        events_outliers = self.calendar_event_ids.filtered(lambda e: not e.follow_recurrence)
-        events = self.calendar_event_ids.sorted('start')
-        normal_event = (events - events_outliers)[:1] or events[:1]
-        if not normal_event:
-            return {}
-        values = normal_event._microsoft_values(fields_to_sync, initial_values={'type': 'seriesMaster'})
-
-        if self.microsoft_id:
-            values['id'] = self.microsoft_id
-            if events_outliers:
-                # We send the data as a list. If we directly send a list of values, we have issues...
-                values = [values]
-                for event in events_outliers:
-                    event_value = event._microsoft_values(fields_to_sync)
-                    values += [event_value]
-        return values
+        """
+        Get values to update the whole Outlook event recurrence.
+        (done through the first event of the Outlook recurrence).
+        """
+        return self.base_event_id._microsoft_values(fields_to_sync, initial_values={'type': 'seriesMaster'})
 
     def _ensure_attendees_have_email(self):
         self.calendar_event_ids.filtered(lambda e: e.active)._ensure_attendees_have_email()
+
+    def _split_from(self, event, recurrence_values=None):
+        """
+        When a recurrence is splitted, the base event of the new recurrence already
+        exist and may be already synced with Outlook.
+        In this case, we need to be removed this event on Outlook side to avoid duplicates while posting
+        the new recurrence.
+        """
+        new_recurrence = super()._split_from(event, recurrence_values)
+        if new_recurrence and new_recurrence.base_event_id.microsoft_id:
+            new_recurrence.base_event_id._microsoft_delete(
+                new_recurrence.base_event_id._get_organizer(),
+                new_recurrence.base_event_id.ms_organizer_event_id
+            )
+
+        return new_recurrence

--- a/addons/microsoft_calendar/models/microsoft_sync.py
+++ b/addons/microsoft_calendar/models/microsoft_sync.py
@@ -4,24 +4,23 @@
 import logging
 from contextlib import contextmanager
 from functools import wraps
-import requests
 import pytz
 from dateutil.parser import parse
 
-from odoo import api, fields, models, registry, _
+from odoo import api, fields, models, registry
 from odoo.tools import ormcache_context
 from odoo.exceptions import UserError
 from odoo.osv import expression
 
 from odoo.addons.microsoft_calendar.utils.microsoft_event import MicrosoftEvent
 from odoo.addons.microsoft_calendar.utils.microsoft_calendar import MicrosoftCalendarService
+from odoo.addons.microsoft_calendar.utils.event_id_storage import IDS_SEPARATOR, combine_ids, split_ids
 from odoo.addons.microsoft_account.models.microsoft_service import TIMEOUT
 
 _logger = logging.getLogger(__name__)
 
 MAX_RECURRENT_EVENT = 720
 
-
 # API requests are sent to Microsoft Calendar after the current transaction ends.
 # This ensures changes are sent to Microsoft only if they really happened in the Odoo database.
 # It is particularly important for event creation , otherwise the event might be created
@@ -53,22 +52,38 @@ def after_commit(func):
 def microsoft_calendar_token(user):
     yield user._get_microsoft_calendar_token()
 
-
 class MicrosoftSync(models.AbstractModel):
     _name = 'microsoft.calendar.sync'
     _description = "Synchronize a record with Microsoft Calendar"
 
     microsoft_id = fields.Char('Microsoft Calendar Id', copy=False)
-    # This field helps to known when a microsoft event need to be resynced
+
+    ms_organizer_event_id = fields.Char(
+        'Organizer event Id',
+        compute='_compute_organizer_event_id',
+        inverse='_set_event_id',
+        search='_search_organizer_event_id',
+    )
+    ms_universal_event_id = fields.Char(
+        'Universal event Id',
+        compute='_compute_universal_event_id',
+        inverse='_set_event_id',
+        search='_search_universal_event_id',
+    )
+
+    # This field helps to know when a microsoft event need to be resynced
     need_sync_m = fields.Boolean(default=True, copy=False)
     active = fields.Boolean(default=True)
 
     def write(self, vals):
-        microsoft_service = MicrosoftCalendarService(self.env['microsoft.service'])
-        if 'microsoft_id' in vals:
-            self._from_microsoft_ids.clear_cache(self)
+        if 'ms_universal_event_id' in vals:
+            self._from_uids.clear_cache(self)
         synced_fields = self._get_microsoft_synced_fields()
-        if 'need_sync_m' not in vals and vals.keys() & synced_fields and not self.env.user.microsoft_synchronization_stopped:
+        if (
+            'need_sync_m' not in vals and vals.keys() & synced_fields
+            and self.ms_organizer_event_id
+            and not self.env.user.microsoft_synchronization_stopped
+        ):
             fields_to_sync = [x for x in vals.keys() if x in synced_fields]
             if fields_to_sync:
                 vals['need_sync_m'] = True
@@ -78,36 +93,80 @@ class MicrosoftSync(models.AbstractModel):
         result = super().write(vals)
         need_delete = 'active' in vals.keys() and not vals.get('active')
         for record in self.filtered('need_sync_m'):
-            if need_delete and record.microsoft_id:
-                # We need to delete the event. Cancel is not sufficant. Errors may occurs
-                record._microsoft_delete(microsoft_service, record.microsoft_id, timeout=3)
-            elif record.microsoft_id and fields_to_sync:
-                values = record._microsoft_values(fields_to_sync)
-                if not values:
-                    continue
-                record._microsoft_patch(microsoft_service, record.microsoft_id, values, timeout=3)
+            if record.ms_universal_event_id:
+                if need_delete:
+                    # We need to delete the event. Cancel is not sufficant. Errors may occurs
+                    record._microsoft_delete(record._get_organizer(), record.ms_organizer_event_id, timeout=3)
+                elif fields_to_sync:
+                    values = record._microsoft_values(fields_to_sync)
+                    if not values:
+                        continue
+                    record._microsoft_patch(record._get_organizer(), record.ms_organizer_event_id, values, timeout=3)
+
         return result
 
     @api.model_create_multi
     def create(self, vals_list):
-        if any(vals.get('microsoft_id') for vals in vals_list):
-            self._from_microsoft_ids.clear_cache(self)
         if self.env.user.microsoft_synchronization_stopped:
             for vals in vals_list:
                 vals.update({'need_sync_m': False})
         records = super().create(vals_list)
 
-        microsoft_service = MicrosoftCalendarService(self.env['microsoft.service'])
         records_to_sync = records.filtered(lambda r: r.need_sync_m and r.active)
         for record in records_to_sync:
-            record._microsoft_insert(microsoft_service, record._microsoft_values(self._get_microsoft_synced_fields()), timeout=3)
+            record._microsoft_insert(record._microsoft_values(self._get_microsoft_synced_fields()), timeout=3)
         return records
 
+    @api.depends('microsoft_id')
+    def _compute_organizer_event_id(self):
+        for event in self:
+            event.ms_organizer_event_id = split_ids(event.microsoft_id)[0] if event.microsoft_id else False
+
+    @api.depends('microsoft_id')
+    def _compute_universal_event_id(self):
+        for event in self:
+            event.ms_universal_event_id = split_ids(event.microsoft_id)[1] if event.microsoft_id else False
+
+    def _set_event_id(self):
+        for event in self:
+            event.microsoft_id = combine_ids(event.ms_organizer_event_id, event.ms_universal_event_id)
+
+    def _search_event_id(self, operator, value, with_uid):
+        def _domain(v):
+            return ('microsoft_id', '=like', f'%{IDS_SEPARATOR}{v}' if with_uid else f'{v}%')
+
+        if operator == '=' and not value:
+            return (
+                ['|', ('microsoft_id', '=', False), ('microsoft_id', '=ilike', f'%{IDS_SEPARATOR}')]
+                if with_uid
+                else [('microsoft_id', '=', False)]
+            )
+        return (
+            ['|'] * (len(value) - 1) + [_domain(v) for v in value]
+            if operator.lower() == 'in'
+            else [_domain(value)]
+        )
+
+    def _search_organizer_event_id(self, operator, value):
+        return self._search_event_id(operator, value, with_uid=False)
+
+    def _search_universal_event_id(self, operator, value):
+        return self._search_event_id(operator, value, with_uid=True)
+
+    @api.model
+    def _get_microsoft_service(self):
+        return MicrosoftCalendarService(self.env['microsoft.service'])
+
+    def _get_synced_events(self):
+        """
+        Get events already synced with Microsoft Outlook.
+        """
+        return self.filtered(lambda e: e.ms_universal_event_id)
+
     def unlink(self):
-        synced = self.filtered('microsoft_id')
-        microsoft_service = MicrosoftCalendarService(self.env['microsoft.service'])
+        synced = self._get_synced_events()
         for ev in synced:
-            ev._microsoft_delete(microsoft_service, ev.microsoft_id)
+            ev._microsoft_delete(ev._get_organizer(), ev.ms_organizer_event_id)
         return super().unlink()
 
     def _write_from_microsoft(self, microsoft_event, vals):
@@ -118,13 +177,13 @@ class MicrosoftSync(models.AbstractModel):
         return self.create(vals_list)
 
     @api.model
-    @ormcache_context('microsoft_ids', keys=('active_test',))
-    def _from_microsoft_ids(self, microsoft_ids):
-        if not microsoft_ids:
+    @ormcache_context('uids', keys=('active_test',))
+    def _from_uids(self, uids):
+        if not uids:
             return self.browse()
-        return self.search([('microsoft_id', 'in', microsoft_ids)])
+        return self.search([('ms_universal_event_id', 'in', uids)])
 
-    def _sync_odoo2microsoft(self, microsoft_service: MicrosoftCalendarService):
+    def _sync_odoo2microsoft(self):
         if not self:
             return
         if self._active_name:
@@ -134,47 +193,58 @@ class MicrosoftSync(models.AbstractModel):
         cancelled_records = self - records_to_sync
 
         records_to_sync._ensure_attendees_have_email()
-        updated_records = records_to_sync.filtered('microsoft_id')
+        updated_records = records_to_sync._get_synced_events()
         new_records = records_to_sync - updated_records
-        for record in cancelled_records.filtered('microsoft_id'):
-            record._microsoft_delete(microsoft_service, record.microsoft_id)
+
+        for record in cancelled_records._get_synced_events():
+            record._microsoft_delete(record._get_organizer(), record.ms_organizer_event_id)
         for record in new_records:
             values = record._microsoft_values(self._get_microsoft_synced_fields())
             if isinstance(values, dict):
-                record._microsoft_insert(microsoft_service, values)
+                record._microsoft_insert(values)
             else:
                 for value in values:
-                    record._microsoft_insert(microsoft_service, value)
+                    record._microsoft_insert(value)
         for record in updated_records.filtered('need_sync_m'):
             values = record._microsoft_values(self._get_microsoft_synced_fields())
             if not values:
                 continue
-            record._microsoft_patch(microsoft_service, record.microsoft_id, values)
+            record._microsoft_patch(record._get_organizer(), record.ms_organizer_event_id, values)
 
     def _cancel_microsoft(self):
         self.microsoft_id = False
         self.unlink()
 
-    def _sync_recurrence_microsoft2odoo(self, microsoft_events: MicrosoftEvent):
-        recurrent_masters = microsoft_events.filter(lambda e: e.is_recurrence())
-        recurrents = microsoft_events.filter(lambda e: e.is_recurrent_not_master())
+    def _sync_recurrence_microsoft2odoo(self, microsoft_events, new_events=None):
+        recurrent_masters = new_events.filter(lambda e: e.is_recurrence()) if new_events else []
+        recurrents = new_events.filter(lambda e: e.is_recurrent_not_master()) if new_events else []
         default_values = {'need_sync_m': False}
 
         new_recurrence = self.env['calendar.recurrence']
+        updated_events = self.env['calendar.event']
 
+        # --- create new recurrences and associated events ---
         for recurrent_master in recurrent_masters:
-            new_calendar_recurrence = dict(self.env['calendar.recurrence']._microsoft_to_odoo_values(recurrent_master, (), default_values), need_sync_m=False)
-            to_create = recurrents.filter(lambda e: e.seriesMasterId == new_calendar_recurrence['microsoft_id'])
+            new_calendar_recurrence = dict(
+                self.env['calendar.recurrence']._microsoft_to_odoo_values(recurrent_master, default_values, with_ids=True),
+                need_sync_m=False
+            )
+            to_create = recurrents.filter(
+                lambda e: e.seriesMasterId == new_calendar_recurrence['ms_organizer_event_id']
+            )
             recurrents -= to_create
-            base_values = dict(self.env['calendar.event']._microsoft_to_odoo_values(recurrent_master, (), default_values), need_sync_m=False)
+            base_values = dict(
+                self.env['calendar.event']._microsoft_to_odoo_values(recurrent_master, default_values, with_ids=True),
+                need_sync_m=False
+            )
             to_create_values = []
             if new_calendar_recurrence.get('end_type', False) in ['count', 'forever']:
                 to_create = list(to_create)[:MAX_RECURRENT_EVENT]
             for recurrent_event in to_create:
                 if recurrent_event.type == 'occurrence':
-                    value = self.env['calendar.event']._microsoft_to_odoo_recurrence_values(recurrent_event, (), base_values)
+                    value = self.env['calendar.event']._microsoft_to_odoo_recurrence_values(recurrent_event, base_values)
                 else:
-                    value = self.env['calendar.event']._microsoft_to_odoo_values(recurrent_event, (), default_values)
+                    value = self.env['calendar.event']._microsoft_to_odoo_values(recurrent_event, default_values)
 
                 to_create_values += [dict(value, need_sync_m=False)]
 
@@ -183,161 +253,219 @@ class MicrosoftSync(models.AbstractModel):
             new_recurrence_odoo.base_event_id = new_recurrence_odoo.calendar_event_ids[0] if new_recurrence_odoo.calendar_event_ids else False
             new_recurrence |= new_recurrence_odoo
 
-        microsoft_ids = [x.seriesMasterId for x in recurrents]
-        recurrences = self.env['calendar.recurrence'].search([('microsoft_id', 'in', microsoft_ids)])
-        for recurrent_master_id in set([x.seriesMasterId for x in recurrents]):
-            recurrence_id = recurrences.filtered(lambda ev: ev.microsoft_id == recurrent_master_id)
+        # --- update events in existing recurrences ---
+        # Important note:
+        # To map existing recurrences with events to update, we must use the universal id
+        # (also known as ICalUId in the Microsoft API), as 'seriesMasterId' attribute of events
+        # is specific to the Microsoft user calendar.
+        ms_recurrence_ids = list({x.seriesMasterId for x in recurrents})
+        ms_recurrence_uids = {r.id: r.iCalUId for r in microsoft_events if r.id in ms_recurrence_ids}
+
+        recurrences = self.env['calendar.recurrence'].search([
+            ('ms_universal_event_id', 'in', ms_recurrence_uids.values())
+        ])
+        for recurrent_master_id in ms_recurrence_ids:
+            recurrence_id = recurrences.filtered(
+                lambda ev: ev.ms_universal_event_id == ms_recurrence_uids[recurrent_master_id]
+            )
             to_update = recurrents.filter(lambda e: e.seriesMasterId == recurrent_master_id)
             for recurrent_event in to_update:
                 if recurrent_event.type == 'occurrence':
-                    value = self.env['calendar.event']._microsoft_to_odoo_recurrence_values(recurrent_event, (), {'need_sync_m': False})
+                    value = self.env['calendar.event']._microsoft_to_odoo_recurrence_values(
+                        recurrent_event, {'need_sync_m': False}
+                    )
                 else:
-                    value = self.env['calendar.event']._microsoft_to_odoo_values(recurrent_event, (), default_values)
-                existing_event = recurrence_id.calendar_event_ids.filtered(lambda e: e._range() == (value['start'], value['stop']))
+                    value = self.env['calendar.event']._microsoft_to_odoo_values(recurrent_event, default_values)
+                existing_event = recurrence_id.calendar_event_ids.filtered(
+                    lambda e: e._is_matching_timeslot(value['start'], value['stop'], recurrent_event.isAllDay)
+                )
                 if not existing_event:
                     continue
                 value.pop('start')
                 value.pop('stop')
                 existing_event._write_from_microsoft(recurrent_event, value)
+                updated_events |= existing_event
             new_recurrence |= recurrence_id
-        return new_recurrence
-
-    def _update_microsoft_recurrence(self, recurrence_event, events):
-        vals = dict(self.base_event_id._microsoft_to_odoo_values(recurrence_event, ()), need_sync_m=False)
-        vals['microsoft_recurrence_master_id'] = vals.pop('microsoft_id')
-        self.base_event_id.write(vals)
-        values = {}
-        default_values = {}
+        return new_recurrence, updated_events
 
-        normal_events = []
-        events_to_update = events.filter(lambda e: e.seriesMasterId == self.microsoft_id)
+    def _update_microsoft_recurrence(self, recurrence, events):
+        """
+        Update Odoo events from Outlook recurrence and events.
+        """
+        # get the list of events to update ...
+        events_to_update = events.filter(lambda e: e.seriesMasterId == self.ms_organizer_event_id)
         if self.end_type in ['count', 'forever']:
             events_to_update = list(events_to_update)[:MAX_RECURRENT_EVENT]
 
-        for recurrent_event in events_to_update:
-            if recurrent_event.type == 'occurrence':
-                value = self.env['calendar.event']._microsoft_to_odoo_recurrence_values(recurrent_event, (), default_values)
-                normal_events += [recurrent_event.odoo_id(self.env)]
+        # ... and update them
+        rec_values = {}
+        update_events = self.env['calendar.event']
+        for e in events_to_update:
+            if e.type == "exception":
+                event_values = self.env['calendar.event']._microsoft_to_odoo_values(e)
+            elif e.type == "occurrence":
+                event_values = self.env['calendar.event']._microsoft_to_odoo_recurrence_values(e)
             else:
-                value = self.env['calendar.event']._microsoft_to_odoo_values(recurrent_event, (), default_values)
-                event = self.env['calendar.event'].browse(recurrent_event.odoo_id(self.env)).exists()
-                if event:
-                    event.with_context(no_mail_to_attendees=True, mail_create_nolog=True).write(dict(value, need_sync_m=False))
-            if value.get('start') and value.get('stop'):
-                values[(self.id, value.get('start'), value.get('stop'))] = dict(value, need_sync_m=False)
-
-        if (self.id, vals.get('start'), vals.get('stop')) in values:
-            base_event_vals = dict(vals)
-            base_event_vals.update(values[(self.id, vals.get('start'), vals.get('stop'))])
-            self.base_event_id.write(base_event_vals)
-
-        old_record = self._apply_recurrence(specific_values_creation=values, no_send_edit=True)
-
-        vals.pop('microsoft_id', None)
-        vals.pop('start', None)
-        vals.pop('stop', None)
-        normal_events = [e for e in normal_events if e in self.calendar_event_ids.ids]
-        normal_event_ids = self.env['calendar.event'].browse(normal_events) - old_record
-        if normal_event_ids:
-            vals['follow_recurrence'] = True
-            (self.env['calendar.event'].browse(normal_events) - old_record).write(vals)
-
-        old_record._cancel_microsoft()
-        if not self.base_event_id:
-            self.base_event_id = self._get_first_event(include_outliers=False)
+                event_values = None
 
-    @api.model
-    def _sync_microsoft2odoo(self, microsoft_events: MicrosoftEvent, default_reminders=()):
-        """Synchronize Microsoft recurrences in Odoo. Creates new recurrences, updates
-        existing ones.
+            if event_values:
+                # keep event values to update the recurrence later
+                if any(f for f in ('start', 'stop') if f in event_values):
+                    rec_values[(self.id, event_values.get('start'), event_values.get('stop'))] = dict(
+                        event_values, need_sync_m=False
+                    )
+
+                odoo_event = self.env['calendar.event'].browse(e.odoo_id(self.env)).exists().with_context(
+                    no_mail_to_attendees=True, mail_create_nolog=True
+                )
+                odoo_event.write(dict(event_values, need_sync_m=False))
+                update_events |= odoo_event
 
+        # update the recurrence
+        detached_events = self._apply_recurrence(rec_values)
+        detached_events._cancel_microsoft()
+
+        return update_events
+
+    @api.model
+    def _sync_microsoft2odoo(self, microsoft_events: MicrosoftEvent):
+        """
+        Synchronize Microsoft recurrences in Odoo.
+        Creates new recurrences, updates existing ones.
         :return: synchronized odoo
         """
-        existing = microsoft_events.exists(self.env)
-        new = microsoft_events - existing - microsoft_events.cancelled()
-        new_recurrent = new.filter(lambda e: e.is_recurrent())
-
-        default_values = {}
+        existing = microsoft_events.match_with_odoo_events(self.env)
+        cancelled = microsoft_events.cancelled()
+        new = microsoft_events - existing - cancelled
+        new_recurrence = new.filter(lambda e: e.is_recurrent())
 
+        # create new events and reccurrences
         odoo_values = [
-            dict(self._microsoft_to_odoo_values(e, default_reminders, default_values), need_sync_m=False)
-            for e in (new - new_recurrent)
+            dict(self._microsoft_to_odoo_values(e, with_ids=True), need_sync_m=False)
+            for e in (new - new_recurrence)
         ]
-        new_odoo = self.with_context(dont_notify=True)._create_from_microsoft(new, odoo_values)
-
-        synced_recurrent_records = self._sync_recurrence_microsoft2odoo(new_recurrent)
-
-        cancelled = existing.cancelled()
-        cancelled_odoo = self.browse(cancelled.odoo_ids(self.env))
-        cancelled_odoo._cancel_microsoft()
-
-        recurrent_cancelled = self.env['calendar.recurrence'].search([
-            ('microsoft_id', 'in', (microsoft_events.cancelled() - cancelled).microsoft_ids())])
-        recurrent_cancelled._cancel_microsoft()
-
-        synced_records = new_odoo + cancelled_odoo + synced_recurrent_records.calendar_event_ids
-
-        for mevent in (existing - cancelled).filter(lambda e: e.lastModifiedDateTime and not e.seriesMasterId):
+        synced_events = self.with_context(dont_notify=True)._create_from_microsoft(new, odoo_values)
+        synced_recurrences, updated_events = self._sync_recurrence_microsoft2odoo(existing, new_recurrence)
+        synced_events |= updated_events
+
+        # remove cancelled events and recurrences
+        cancelled_recurrences = self.env['calendar.recurrence'].search([
+            '|',
+            ('ms_universal_event_id', 'in', cancelled.uids),
+            ('ms_organizer_event_id', 'in', cancelled.ids),
+        ])
+        cancelled_events = self.browse([
+            e.odoo_id(self.env)
+            for e in cancelled
+            if e.id not in [r.ms_organizer_event_id for r in cancelled_recurrences]
+        ])
+        cancelled_recurrences._cancel_microsoft()
+        cancelled_events = cancelled_events.exists()
+        cancelled_events._cancel_microsoft()
+
+        synced_recurrences |= cancelled_recurrences
+        synced_events |= cancelled_events | cancelled_recurrences.calendar_event_ids
+
+        # update other events
+        for mevent in (existing - cancelled).filter(lambda e: e.lastModifiedDateTime):
             # Last updated wins.
             # This could be dangerous if microsoft server time and odoo server time are different
             if mevent.is_recurrence():
-                odoo_record = self.env['calendar.recurrence'].browse(mevent.odoo_id(self.env))
+                odoo_event = self.env['calendar.recurrence'].browse(mevent.odoo_id(self.env)).exists()
             else:
-                odoo_record = self.browse(mevent.odoo_id(self.env))
-            odoo_record_updated = pytz.utc.localize(odoo_record.write_date)
-            updated = parse(mevent.lastModifiedDateTime or str(odoo_record_updated))
-            if updated >= odoo_record_updated:
-                vals = dict(odoo_record._microsoft_to_odoo_values(mevent, default_reminders), need_sync_m=False)
-                odoo_record._write_from_microsoft(mevent, vals)
-                if odoo_record._name == 'calendar.recurrence':
-                    odoo_record._update_microsoft_recurrence(mevent, microsoft_events)
-                    synced_recurrent_records |= odoo_record
-                else:
-                    synced_records |= odoo_record
+                odoo_event = self.browse(mevent.odoo_id(self.env)).exists()
+
+            if odoo_event:
+                odoo_event_updated_time = pytz.utc.localize(odoo_event.write_date)
+                ms_event_updated_time = parse(mevent.lastModifiedDateTime)
+
+                if ms_event_updated_time >= odoo_event_updated_time:
+                    vals = dict(odoo_event._microsoft_to_odoo_values(mevent), need_sync_m=False)
+                    odoo_event._write_from_microsoft(mevent, vals)
 
-        return synced_records, synced_recurrent_records
+                    if odoo_event._name == 'calendar.recurrence':
+                        update_events = odoo_event._update_microsoft_recurrence(mevent, microsoft_events)
+                        synced_recurrences |= odoo_event
+                        synced_events |= update_events
+                    else:
+                        synced_events |= odoo_event
+
+        return synced_events, synced_recurrences
+
+    def _impersonate_user(self, user_id):
+        """ Impersonate a user (mainly the event organizer) to be able to call the Outlook API with its token """
+        return user_id.with_user(user_id)
 
     @after_commit
-    def _microsoft_delete(self, microsoft_service: MicrosoftCalendarService, microsoft_id, timeout=TIMEOUT):
-        with microsoft_calendar_token(self.env.user.sudo()) as token:
+    def _microsoft_delete(self, user_id, event_id, timeout=TIMEOUT):
+        """
+        Once the event has been really removed from the Odoo database, remove it from the Outlook calendar.
+
+        Note that all self attributes to use in this method must be provided as method parameters because
+        'self' won't exist when this method will be really called due to @after_commit decorator.
+        """
+        microsoft_service = self._get_microsoft_service()
+        with microsoft_calendar_token(self._impersonate_user(user_id).sudo()) as token:
             if token:
-                microsoft_service.delete(microsoft_id, token=token, timeout=timeout)
+                microsoft_service.delete(event_id, token=token, timeout=timeout)
 
     @after_commit
-    def _microsoft_patch(self, microsoft_service: MicrosoftCalendarService, microsoft_id, values, timeout=TIMEOUT):
-        with microsoft_calendar_token(self.env.user.sudo()) as token:
+    def _microsoft_patch(self, user_id, event_id, values, timeout=TIMEOUT):
+        """
+        Once the event has been really modified in the Odoo database, modify it in the Outlook calendar.
+
+        Note that all self attributes to use in this method must be provided as method parameters because
+        'self' may have been modified between the call of '_microsoft_patch' and its execution,
+        due to @after_commit decorator.
+        """
+        microsoft_service = self._get_microsoft_service()
+        with microsoft_calendar_token(self._impersonate_user(user_id).sudo()) as token:
             if token:
                 self._ensure_attendees_have_email()
-                microsoft_service.patch(microsoft_id, values, token=token, timeout=timeout)
-                self.need_sync_m = False
+                res = microsoft_service.patch(event_id, values, token=token, timeout=timeout)
+                self.write({
+                    'need_sync_m': not res,
+                })
 
     @after_commit
-    def _microsoft_insert(self, microsoft_service: MicrosoftCalendarService, values, timeout=TIMEOUT):
+    def _microsoft_insert(self, values, timeout=TIMEOUT):
+        """
+        Once the event has been really added in the Odoo database, add it in the Outlook calendar.
+
+        Note that all self attributes to use in this method must be provided as method parameters because
+        'self' may have been modified between the call of '_microsoft_insert' and its execution,
+        due to @after_commit decorator.
+        """
         if not values:
             return
+        microsoft_service = self._get_microsoft_service()
         with microsoft_calendar_token(self.env.user.sudo()) as token:
             if token:
                 self._ensure_attendees_have_email()
-                microsoft_id = microsoft_service.insert(values, token=token, timeout=timeout)
+                event_id, uid = microsoft_service.insert(values, token=token, timeout=timeout)
                 self.write({
-                    'microsoft_id': microsoft_id,
+                    'microsoft_id': combine_ids(event_id, uid),
                     'need_sync_m': False,
                 })
 
-    def _microsoft_attendee_answer(self, microsoft_service: MicrosoftCalendarService, microsoft_id, answer, params, timeout=TIMEOUT):
+    def _microsoft_attendee_answer(self, answer, params, timeout=TIMEOUT):
         if not answer:
             return
+        microsoft_service = self._get_microsoft_service()
         with microsoft_calendar_token(self.env.user.sudo()) as token:
             if token:
                 self._ensure_attendees_have_email()
-                microsoft_service.answer(microsoft_id, answer, params, token=token, timeout=timeout)
+                microsoft_service.answer(
+                    self.ms_organizer_event_id,
+                    answer, params, token=token, timeout=timeout
+                )
                 self.write({
                     'need_sync_m': False,
                 })
 
     def _get_microsoft_records_to_sync(self, full_sync=False):
-        """Return records that should be synced from Odoo to Microsoft
-
+        """
+        Return records that should be synced from Odoo to Microsoft
         :param full_sync: If True, all events attended by the user are returned
         :return: events
         """
@@ -346,21 +474,25 @@ class MicrosoftSync(models.AbstractModel):
             is_active_clause = (self._active_name, '=', True) if self._active_name else expression.TRUE_LEAF
             domain = expression.AND([domain, [
                 '|',
-                    '&', ('microsoft_id', '=', False), is_active_clause,
-                    ('need_sync_m', '=', True),
+                '&', ('ms_universal_event_id', '=', False), is_active_clause,
+                ('need_sync_m', '=', True),
             ]])
         return self.with_context(active_test=False).search(domain)
 
     @api.model
-    def _microsoft_to_odoo_values(self, microsoft_event: MicrosoftEvent, default_reminders=()):
-        """Implements this method to return a dict of Odoo values corresponding
+    def _microsoft_to_odoo_values(
+        self, microsoft_event: MicrosoftEvent, default_reminders=(), default_values=None, with_ids=False
+    ):
+        """
+        Implements this method to return a dict of Odoo values corresponding
         to the Microsoft event given as parameter
         :return: dict of Odoo formatted values
         """
         raise NotImplementedError()
 
     def _microsoft_values(self, fields_to_sync):
-        """Implements this method to return a dict with values formatted
+        """
+        Implements this method to return a dict with values formatted
         according to the Microsoft Calendar API
         :return: dict of Microsoft formatted values
         """
@@ -370,13 +502,15 @@ class MicrosoftSync(models.AbstractModel):
         raise NotImplementedError()
 
     def _get_microsoft_sync_domain(self):
-        """Return a domain used to search records to synchronize.
+        """
+        Return a domain used to search records to synchronize.
         e.g. return a domain to synchronize records owned by the current user.
         """
         raise NotImplementedError()
 
     def _get_microsoft_synced_fields(self):
-        """Return a set of field names. Changing one of these fields
+        """
+        Return a set of field names. Changing one of these fields
         marks the record to be re-synchronized.
         """
         raise NotImplementedError()

--- a/addons/microsoft_calendar/models/res_users.py
+++ b/addons/microsoft_calendar/models/res_users.py
@@ -9,7 +9,8 @@ from datetime import timedelta
 from odoo import api, fields, models, _
 from odoo.exceptions import UserError
 from odoo.loglevels import exception_to_unicode
-from odoo.addons.microsoft_calendar.utils.microsoft_calendar import MicrosoftCalendarService, InvalidSyncToken
+from odoo.addons.microsoft_account.models.microsoft_service import DEFAULT_MICROSOFT_TOKEN_ENDPOINT
+from odoo.addons.microsoft_calendar.utils.microsoft_calendar import InvalidSyncToken
 
 _logger = logging.getLogger(__name__)
 
@@ -58,8 +59,9 @@ class User(models.Model):
         }
 
         try:
-            endpoint = self.env['microsoft.service']._get_token_endpoint()
-            dummy, response, dummy = self.env['microsoft.service']._do_request(endpoint, params=data, headers=headers, method='POST', preuri='')
+            dummy, response, dummy = self.env['microsoft.service']._do_request(
+                DEFAULT_MICROSOFT_TOKEN_ENDPOINT, params=data, headers=headers, method='POST', preuri=''
+            )
             ttl = response.get('expires_in')
             self.write({
                 'microsoft_calendar_token': response.get('access_token'),
@@ -83,31 +85,31 @@ class User(models.Model):
                 error_key)
             raise UserError(error_msg)
 
-    def _sync_microsoft_calendar(self, calendar_service: MicrosoftCalendarService):
+    def _sync_microsoft_calendar(self):
         self.ensure_one()
         if self.microsoft_synchronization_stopped:
             return False
+        calendar_service = self.env["calendar.event"]._get_microsoft_service()
         full_sync = not bool(self.microsoft_calendar_sync_token)
         with microsoft_calendar_token(self) as token:
             try:
-                events, next_sync_token, default_reminders = calendar_service.get_events(self.microsoft_calendar_sync_token, token=token)
+                events, next_sync_token = calendar_service.get_events(self.microsoft_calendar_sync_token, token=token)
             except InvalidSyncToken:
-                events, next_sync_token, default_reminders = calendar_service.get_events(token=token)
+                events, next_sync_token = calendar_service.get_events(token=token)
                 full_sync = True
         self.microsoft_calendar_sync_token = next_sync_token
 
         # Microsoft -> Odoo
-        recurrences = events.filter(lambda e: e.is_recurrent())
-        synced_events, synced_recurrences = self.env['calendar.event']._sync_microsoft2odoo(events, default_reminders=default_reminders) if events else (self.env['calendar.event'], self.env['calendar.recurrence'])
+        synced_events, synced_recurrences = self.env['calendar.event']._sync_microsoft2odoo(events) if events else (self.env['calendar.event'], self.env['calendar.recurrence'])
 
         # Odoo -> Microsoft
         recurrences = self.env['calendar.recurrence']._get_microsoft_records_to_sync(full_sync=full_sync)
         recurrences -= synced_recurrences
-        recurrences._sync_odoo2microsoft(calendar_service)
+        recurrences._sync_odoo2microsoft()
         synced_events |= recurrences.calendar_event_ids
 
         events = self.env['calendar.event']._get_microsoft_records_to_sync(full_sync=full_sync)
-        (events - synced_events)._sync_odoo2microsoft(calendar_service)
+        (events - synced_events)._sync_odoo2microsoft()
 
         return bool(events | synced_events) or bool(recurrences | synced_recurrences)
 
@@ -115,11 +117,10 @@ class User(models.Model):
     def _sync_all_microsoft_calendar(self):
         """ Cron job """
         users = self.env['res.users'].search([('microsoft_calendar_rtoken', '!=', False), ('microsoft_synchronization_stopped', '=', False)])
-        microsoft = MicrosoftCalendarService(self.env['microsoft.service'])
         for user in users:
             _logger.info("Calendar Synchro - Starting synchronization for %s", user)
             try:
-                user.with_user(user).sudo()._sync_microsoft_calendar(microsoft)
+                user.with_user(user).sudo()._sync_microsoft_calendar()
                 self.env.cr.commit()
             except Exception as e:
                 _logger.exception("[%s] Calendar Synchro - Exception : %s !", user, exception_to_unicode(e))
