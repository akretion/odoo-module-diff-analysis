PR: https://github.com/odoo/odoo/pull/115871

From: 17bece3e797913bcba8dd7e07fc8541c0a45e3f7
From: Victor Feyens
Date: 2023-06-22 13:40:51

Structural Changes: 1
Total Changes: 161

[REF] sale,*: remove locked (done) SO state

It's not a specific state, it should be considered separately,
as a boolean.

This allows to reduce code complexity (flows should not rely (much) on
the locked logic) and to have a clearer flow.

Task-3163931

Part-of: odoo/odoo#115871

================================= pseudo patch: =================================

--- a/addons/sale/models/account_move.py
+++ b/addons/sale/models/account_move.py
@@ -63,17 +63,16 @@ class AccountMove(models.Model):
         res = super(AccountMove, self).action_post()
         down_payment_lines = self.line_ids.filtered('is_downpayment')
         for line in down_payment_lines:
+            if any(order.locked for order in line.sale_line_ids.order_id):
+                # We cannot change lines content on locked SO, changes on invoices are not
+                # forwarded to the SO if the SO is locked.
+                continue
 
             if not line.sale_line_ids.display_type:
                 line.sale_line_ids._compute_name()
 
-            try:
-                line.sale_line_ids.tax_id = line.tax_ids
-                line.sale_line_ids.price_unit = line.price_unit
-            except UserError:
-                # a UserError here means the SO was locked, which prevents changing the taxes
-                # just ignore the error - this is a nice to have feature and should not be blocking
-                pass
+            line.sale_line_ids.tax_id = line.tax_ids
+            line.sale_line_ids.price_unit = line.price_unit
         return res
 
     def button_draft(self):

--- a/addons/sale/models/account_move_line.py
+++ b/addons/sale/models/account_move_line.py
@@ -76,15 +76,28 @@ class AccountMoveLine(models.Model):
                 continue
 
             # raise if the sale order is not currently open
-            if sale_order.state != 'sale':
-                message_unconfirmed = _('The Sales Order %s linked to the Analytic Account %s must be validated before registering expenses.')
-                messages = {
-                    'draft': message_unconfirmed,
-                    'sent': message_unconfirmed,
-                    'done': _('The Sales Order %s linked to the Analytic Account %s is currently locked. You cannot register an expense on a locked Sales Order. Please create a new SO linked to this Analytic Account.'),
-                    'cancel': _('The Sales Order %s linked to the Analytic Account %s is cancelled. You cannot register an expense on a cancelled Sales Order.'),
-                }
-                raise UserError(messages[sale_order.state] % (sale_order.name, sale_order.analytic_account_id.name))
+            if sale_order.state in ('draft', 'sent'):
+                raise UserError(_(
+                    "The Sales Order %(order)s linked to the Analytic Account %(account)s must be"
+                    " validated before registering expenses.",
+                    order=sale_order.name,
+                    account=sale_order.analytic_account_id.name,
+                ))
+            elif sale_order.state == 'cancel':
+                raise UserError(_(
+                    "The Sales Order %(order)s linked to the Analytic Account %(account)s is cancelled."
+                    " You cannot register an expense on a cancelled Sales Order.",
+                    order=sale_order.name,
+                    account=sale_order.analytic_account_id.name,
+                ))
+            elif sale_order.locked:
+                raise UserError(_(
+                    "The Sales Order %(order)s linked to the Analytic Account %(account)s is currently locked."
+                    " You cannot register an expense on a locked Sales Order."
+                    " Please create a new SO linked to this Analytic Account.",
+                    order=sale_order.name,
+                    account=sale_order.analytic_account_id.name,
+                ))
 
             price = move_line._sale_get_invoice_price(sale_order)
 

--- a/addons/sale/models/crm_team.py
+++ b/addons/sale/models/crm_team.py
@@ -130,7 +130,7 @@ class CrmTeam(models.Model):
 
     def _extra_sql_conditions(self):
         if self._in_sale_scope():
-            return "AND state in ('sale', 'done')"
+            return "AND state = 'sale'"
         return super()._extra_sql_conditions()
 
     def _graph_title_and_key(self):

--- a/addons/sale/models/payment_transaction.py
+++ b/addons/sale/models/payment_transaction.py
@@ -151,7 +151,7 @@ class PaymentTransaction(models.Model):
                 ('is_move_sent', '=', False),
                 ('state', '=', 'posted'),
             ])),
-            ('sale_order_ids.state', 'in', ('sale', 'done')),
+            ('sale_order_ids.state', '=', 'sale'),
             ('last_state_change', '>=', retry_limit_date),
         ])._send_invoice()
 
@@ -159,7 +159,7 @@ class PaymentTransaction(models.Model):
         for tx in self.filtered(lambda tx: tx.sale_order_ids):
             # Create invoices
             tx = tx.with_company(tx.company_id).with_context(company_id=tx.company_id.id)
-            confirmed_orders = tx.sale_order_ids.filtered(lambda so: so.state in ('sale', 'done'))
+            confirmed_orders = tx.sale_order_ids.filtered(lambda so: so.state == 'sale')
             if confirmed_orders:
                 confirmed_orders._force_lines_to_invoice_policy_order()
                 invoices = confirmed_orders.with_context(

--- a/addons/sale/models/res_partner.py
+++ b/addons/sale/models/res_partner.py
@@ -44,7 +44,7 @@ class ResPartner(models.Model):
         SaleOrder = self.env['sale.order']
         has_so = SaleOrder.search([
             ('partner_id', 'child_of', self.commercial_partner_id.id),
-            ('state', 'in', ['sent', 'sale', 'done'])
+            ('state', 'in', ['sent', 'sale'])
         ], limit=1)
         return can_edit_vat and not bool(has_so)
 
@@ -56,7 +56,7 @@ class ResPartner(models.Model):
 
     def _credit_debit_get(self):
         super()._credit_debit_get()
-        domain = [('partner_id', 'in', self.ids), ('state', 'in', ['sale', 'done'])]
+        domain = [('partner_id', 'in', self.ids), ('state', '=', 'sale')]
         group = self.env['sale.order']._read_group(domain, ['partner_id'], ['amount_to_invoice:sum'])
         for partner, amount_to_invoice_sum in group:
             partner.credit += amount_to_invoice_sum

--- a/addons/sale/models/sale_order.py
+++ b/addons/sale/models/sale_order.py
@@ -1,4 +1,3 @@
-# -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
 from datetime import timedelta
@@ -8,7 +7,6 @@ from markupsafe import escape
 from odoo import api, fields, models, SUPERUSER_ID, _
 from odoo.exceptions import AccessError, UserError, ValidationError
 from odoo.fields import Command
-from odoo.osv import expression
 from odoo.tools import float_is_zero, format_amount, format_date, html_keep_url, is_html_empty
 from odoo.tools.sql import create_index
 
@@ -16,12 +14,7 @@ from odoo.addons.payment import utils as payment_utils
 
 READONLY_FIELD_STATES = {
     state: [('readonly', True)]
-    for state in {'sale', 'done', 'cancel'}
-}
-
-LOCKED_FIELD_STATES = {
-    state: [('readonly', True)]
-    for state in {'done', 'cancel'}
+    for state in {'sale', 'cancel'}
 }
 
 INVOICE_STATUS = [
@@ -31,6 +24,13 @@ INVOICE_STATUS = [
     ('no', 'Nothing to Invoice')
 ]
 
+SALE_ORDER_STATE = [
+    ('draft', "Quotation"),
+    ('sent', "Quotation Sent"),
+    ('sale', "Sales Order"),
+    ('cancel', "Cancelled"),
+]
+
 
 class SaleOrder(models.Model):
     _name = 'sale.order'
@@ -41,7 +41,7 @@ class SaleOrder(models.Model):
 
     _sql_constraints = [
         ('date_order_conditional_required',
-         "CHECK((state IN ('sale', 'done') AND date_order IS NOT NULL) OR state NOT IN ('sale', 'done'))",
+         "CHECK((state = 'sale' AND date_order IS NOT NULL) OR state != 'sale')",
          "A confirmed sales order requires a confirmation date."),
     ]
 
@@ -72,24 +72,18 @@ class SaleOrder(models.Model):
         states=READONLY_FIELD_STATES,
         domain="[('type', '!=', 'private'), ('company_id', 'in', (False, company_id))]")
     state = fields.Selection(
-        selection=[
-            ('draft', "Quotation"),
-            ('sent', "Quotation Sent"),
-            ('sale', "Sales Order"),
-            ('done', "Locked"),
-            ('cancel', "Cancelled"),
-        ],
+        selection=SALE_ORDER_STATE,
         string="Status",
         readonly=True, copy=False, index=True,
         tracking=3,
         default='draft')
+    locked = fields.Boolean(default=False, copy=False, help="Locked orders cannot be modified.")
 
     client_order_ref = fields.Char(string="Customer Reference", copy=False)
     create_date = fields.Datetime(  # Override of default create_date field from ORM
         string="Creation Date", index=True, readonly=True)
     commitment_date = fields.Datetime(
         string="Delivery Date", copy=False,
-        states=LOCKED_FIELD_STATES,
         help="This is the delivery date promised to the customer. "
              "If set, the delivery order will be scheduled based on "
              "this date rather than product lead times.")
@@ -144,14 +138,12 @@ class SaleOrder(models.Model):
         string="Invoice Address",
         compute='_compute_partner_invoice_id',
         store=True, readonly=False, required=True, precompute=True,
-        states=LOCKED_FIELD_STATES,
         domain="['|', ('company_id', '=', False), ('company_id', '=', company_id)]")
     partner_shipping_id = fields.Many2one(
         comodel_name='res.partner',
         string="Delivery Address",
         compute='_compute_partner_shipping_id',
         store=True, readonly=False, required=True, precompute=True,
-        states=LOCKED_FIELD_STATES,
         domain="['|', ('company_id', '=', False), ('company_id', '=', company_id)]",)
 
     fiscal_position_id = fields.Many2one(
@@ -212,7 +204,6 @@ class SaleOrder(models.Model):
         comodel_name='sale.order.line',
         inverse_name='order_id',
         string="Order Lines",
-        states=LOCKED_FIELD_STATES,
         copy=True, auto_join=True)
 
     amount_untaxed = fields.Monetary(string="Untaxed Amount", store=True, compute='_compute_amounts', tracking=5)
@@ -525,9 +516,8 @@ class SaleOrder(models.Model):
         - invoiced: if all SO lines are invoiced, the SO is invoiced.
         - upselling: if all SO lines are invoiced or upselling, the status is upselling.
         """
-        unconfirmed_orders = self.filtered(lambda so: so.state not in ['sale', 'done'])
-        unconfirmed_orders.invoice_status = 'no'
-        confirmed_orders = self - unconfirmed_orders
+        confirmed_orders = self.filtered(lambda so: so.state == 'sale')
+        (self - confirmed_orders).invoice_status = 'no'
         if not confirmed_orders:
             return
         line_invoice_status_all = [
@@ -540,7 +530,7 @@ class SaleOrder(models.Model):
                 ['order_id', 'invoice_status'])]
         for order in confirmed_orders:
             line_invoice_status = [d[1] for d in line_invoice_status_all if d[0] == order.id]
-            if order.state not in ('sale', 'done'):
+            if order.state != 'sale':
                 order.invoice_status = 'no'
             elif any(invoice_status == 'to invoice' for invoice_status in line_invoice_status):
                 order.invoice_status = 'to invoice'
@@ -819,7 +809,7 @@ class SaleOrder(models.Model):
         :rtype: record of `mail.template` or `None` if not found
         """
         self.ensure_one()
-        if self.env.context.get('proforma') or self.state not in ('sale', 'done'):
+        if self.env.context.get('proforma') or self.state != 'sale':
             return self.env.ref('sale.email_template_edi_sale', raise_if_not_found=False)
         else:
             return self._get_confirmation_template()
@@ -845,7 +835,7 @@ class SaleOrder(models.Model):
 
         :raise: UserError if any given SO is not in draft state.
         """
-        if self.filtered(lambda so: so.state != 'draft'):
+        if any(order.state != 'draft' for order in self):
             raise UserError(_("Only draft orders can be marked as sent directly."))
 
         for order in self:
@@ -860,12 +850,12 @@ class SaleOrder(models.Model):
 
         :return: True
         :rtype: bool
-        :raise: UserError if trying to confirm locked or cancelled SO's
+        :raise: UserError if trying to confirm cancelled SO's
         """
-        if self._get_forbidden_state_confirm() & set(self.mapped('state')):
+        if not all(order._can_be_confirmed() for order in self):
             raise UserError(_(
-                "It is not allowed to confirm an order in the following states: %s",
-                ", ".join(self._get_forbidden_state_confirm()),
+                "The following orders are not in a state requiring confirmation: %s",
+                ", ".join(self.mapped('display_name')),
             ))
 
         self.order_line._validate_analytic_distribution()
@@ -885,12 +875,13 @@ class SaleOrder(models.Model):
 
         self.with_context(context)._action_confirm()
         if self.env.user.has_group('sale.group_auto_done_setting'):
-            self.action_done()
+            self.action_lock()
 
         return True
 
-    def _get_forbidden_state_confirm(self):
-        return {'done', 'cancel'}
+    def _can_be_confirmed(self):
+        self.ensure_one()
+        return self.state in {'draft', 'sent'}
 
     def _prepare_confirmation_values(self):
         """ Prepare the sales order confirmation values.
@@ -959,16 +950,16 @@ class SaleOrder(models.Model):
             subtype_xmlid='mail.mt_comment',
         )
 
-    def action_done(self):
+    def action_lock(self):
         for order in self:
             tx = order.sudo().transaction_ids._get_last()
             if tx and tx.state == 'pending' and tx.provider_id.code == 'custom':
                 tx._set_done()
                 tx.write({'is_post_processed': True})
-        self.write({'state': 'done'})
+        self.locked = True
 
     def action_unlock(self):
-        self.write({'state': 'sale'})
+        self.locked = False
 
     def action_cancel(self):
         """ Cancel SO after showing the cancel wizard when needed. (cfr :meth:`_show_cancel_wizard`)
@@ -977,6 +968,8 @@ class SaleOrder(models.Model):
 
         note: self.ensure_one() if the wizard is shown.
         """
+        if any(order.locked for order in self):
+            raise UserError(_("You cannot cancel a locked order. Please unlock it first."))
         cancel_warning = self._show_cancel_wizard()
         if cancel_warning:
             self.ensure_one()
@@ -1424,11 +1417,16 @@ class SaleOrder(models.Model):
     # PAYMENT #
 
     def _force_lines_to_invoice_policy_order(self):
+        """Force the qty_to_invoice to be computed as if the invoice_policy
+        was set to "Ordered quantities", independently of the product configuration.
+
+        This is needed for the automatic invoice logic, as we want to automatically
+        invoice the full SO when it's paid.
+        """
         for line in self.order_line:
-            if self.state in ['sale', 'done']:
+            if line.state == 'sale':
+                # No need to set 0 as it is already the standard logic in the compute method.
                 line.qty_to_invoice = line.product_uom_qty - line.qty_invoiced
-            else:
-                line.qty_to_invoice = 0
 
     def payment_action_capture(self):
         """ Capture all transactions linked to this sale order. """
@@ -1534,7 +1532,7 @@ class SaleOrder(models.Model):
 
     def _get_report_base_filename(self):
         self.ensure_one()
-        return '%s %s' % (self.type_name, self.name)
+        return f'{self.type_name} {self.name}'
 
     #=== CORE METHODS OVERRIDES ===#
 
@@ -1564,7 +1562,7 @@ class SaleOrder(models.Model):
             for order in self:
                 name = order.name
                 if order.partner_id.name:
-                    name = '%s - %s' % (name, order.partner_id.name)
+                    name = f'{name} - {order.partner_id.name}'
                 res.append((order.id, name))
             return res
         return super().name_get()

--- a/addons/sale/models/sale_order_line.py
+++ b/addons/sale/models/sale_order_line.py
@@ -764,7 +764,7 @@ class SaleOrderLine(models.Model):
         calculated from the ordered quantity. Otherwise, the quantity delivered is used.
         """
         for line in self:
-            if line.state in ['sale', 'done'] and not line.display_type:
+            if line.state == 'sale' and not line.display_type:
                 if line.product_id.invoice_policy == 'order':
                     line.qty_to_invoice = line.product_uom_qty - line.qty_invoiced
                 else:
@@ -776,20 +776,19 @@ class SaleOrderLine(models.Model):
     def _compute_invoice_status(self):
         """
         Compute the invoice status of a SO line. Possible statuses:
-        - no: if the SO is not in status 'sale' or 'done', we consider that there is nothing to
+        - no: if the SO is not in status 'sale', we consider that there is nothing to
           invoice. This is also the default value if the conditions of no other status is met.
         - to invoice: we refer to the quantity to invoice of the line. Refer to method
           `_compute_qty_to_invoice()` for more information on how this quantity is calculated.
         - upselling: this is possible only for a product invoiced on ordered quantities for which
           we delivered more than expected. The could arise if, for example, a project took more
           time than expected but we decided not to invoice the extra cost to the client. This
-          occurs only in state 'sale', so that when a SO is set to done, the upselling opportunity
-          is removed from the list.
+          occurs only in state 'sale', the upselling opportunity is removed from the list.
         - invoiced: the quantity invoiced is larger or equal to the quantity ordered.
         """
         precision = self.env['decimal.precision'].precision_get('Product Unit of Measure')
         for line in self:
-            if line.state not in ('sale', 'done'):
+            if line.state != 'sale':
                 line.invoice_status = 'no'
             elif line.is_downpayment and line.untaxed_amount_to_invoice == 0:
                 line.invoice_status = 'invoiced'
@@ -835,7 +834,7 @@ class SaleOrderLine(models.Model):
         """
         for line in self:
             amount_to_invoice = 0.0
-            if line.state in ['sale', 'done']:
+            if line.state == 'sale':
                 # Note: do not use price_subtotal field as it returns zero when the ordered quantity is
                 # zero. It causes problem for expense line (e.i.: ordered qty = 0, deli qty = 4,
                 # price_unit = 20 ; subtotal is zero), but when you can invoice the line, you see an
@@ -888,7 +887,13 @@ class SaleOrderLine(models.Model):
     @api.depends('product_id', 'state', 'qty_invoiced', 'qty_delivered')
     def _compute_product_updatable(self):
         for line in self:
-            if line.state in ['done', 'cancel'] or (line.state == 'sale' and (line.qty_invoiced > 0 or line.qty_delivered > 0)):
+            if line.state == 'cancel':
+                line.product_updatable = False
+            elif line.state == 'sale' and (
+                line.order_id.locked
+                or line.qty_invoiced > 0
+                or line.qty_delivered > 0
+            ):
                 line.product_updatable = False
             else:
                 line.product_updatable = True
@@ -897,7 +902,7 @@ class SaleOrderLine(models.Model):
     def _compute_product_uom_readonly(self):
         for line in self:
             # line.ids checks whether it's a new record not yet saved
-            line.product_uom_readonly = line.ids and line.state in ['sale', 'done', 'cancel']
+            line.product_uom_readonly = line.ids and line.state in ['sale', 'cancel']
 
     #=== CONSTRAINT METHODS ===#
 
@@ -967,7 +972,7 @@ class SaleOrderLine(models.Model):
 
         # Prevent writing on a locked SO.
         protected_fields = self._get_protected_fields()
-        if 'done' in self.mapped('state') and any(f in values.keys() for f in protected_fields):
+        if any(self.order_id.mapped('locked')) and any(f in values.keys() for f in protected_fields):
             protected_fields_modified = list(set(protected_fields) & set(values.keys()))
 
             if 'name' in protected_fields_modified and all(self.mapped('is_downpayment')):
@@ -1031,7 +1036,7 @@ class SaleOrderLine(models.Model):
         """
         return self.filtered(
             lambda line:
-                line.state in ('sale', 'done')
+                line.state == 'sale'
                 and (line.invoice_lines or not line.is_downpayment)
                 and not line.display_type
         )
@@ -1071,7 +1076,7 @@ class SaleOrderLine(models.Model):
 
     def _expected_date(self):
         self.ensure_one()
-        if self.state in ['sale', 'done'] and self.order_id.date_order:
+        if self.state == 'sale' and self.order_id.date_order:
             order_date = self.order_id.date_order
         else:
             order_date = fields.Datetime.now()
