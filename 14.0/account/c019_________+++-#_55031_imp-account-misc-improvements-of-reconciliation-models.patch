PR: https://github.com/odoo/odoo/pull/55031

From: 98b64be59f42f9d1e75470971dc5973172b87ee7
From: william
Date: 2020-08-13 13:10:33

Structural Changes: 10
Total Changes: 204

[IMP] account: misc improvements of reconciliation models

Task 2292368
Bundle
https://runbot.odoo.com/runbot/bundle/master-reconcile-model-boost-wan-60105

* Search in Notes and References, not only in the statement's
communication.
* Activate the partner mapping for Suggest Counterpart models
* Always show the Amount Matching field
* Do not block the deletion of models with a partner mapping
* Allow to archive models
* Add a button to get back to Processing state from Validated state on
bank statements.

closes odoo/odoo#55031

Related: odoo/upgrade#1619
Signed-off-by: Cedric Snauwaert (csn) <csn@openerp.com>

================================= pseudo patch: =================================

--- a/addons/account/models/account_bank_statement.py
+++ b/addons/account/models/account_bank_statement.py
@@ -434,6 +434,13 @@ class AccountBankStatement(models.Model):
         self.line_ids.move_id.button_draft()
         self.line_ids.button_undo_reconciliation()
 
+    def button_reprocess(self):
+        """Move the bank statements back to the 'posted' state."""
+        if any(statement.state != 'confirm' for statement in self):
+            raise UserError(_("Only Validated statements can be reset to new."))
+
+        self.write({'state': 'posted', 'date_done': False})
+
     def button_journal_entries(self):
         return {
             'name': _('Journal Entries'),

--- a/addons/account/models/account_reconcile_model.py
+++ b/addons/account/models/account_reconcile_model.py
@@ -13,8 +13,8 @@ class AccountReconcileModelPartnerMapping(models.Model):
     _name = 'account.reconcile.model.partner.mapping'
     _description = 'Partner mapping for reconciliation models'
 
-    model_id = fields.Many2one(comodel_name='account.reconcile.model', readonly=True, required=True)
-    partner_id = fields.Many2one(comodel_name='res.partner', string="Partner", required=True)
+    model_id = fields.Many2one(comodel_name='account.reconcile.model', readonly=True, required=True, ondelete='cascade')
+    partner_id = fields.Many2one(comodel_name='res.partner', string="Partner", required=True, ondelete='cascade')
     payment_ref_regex = fields.Char(string="Find Text in Label")
     narration_regex = fields.Char(string="Find Text in Notes")
 
@@ -110,6 +110,7 @@ class AccountReconcileModel(models.Model):
     _check_company_auto = True
 
     # Base fields.
+    active = fields.Boolean(default=True)
     name = fields.Char(string='Name', required=True)
     sequence = fields.Integer(required=True, default=10)
     company_id = fields.Many2one(
@@ -125,8 +126,28 @@ class AccountReconcileModel(models.Model):
     auto_reconcile = fields.Boolean(string='Auto-validate',
         help='Validate the statement line automatically (reconciliation based on your rule).')
     to_check = fields.Boolean(string='To Check', default=False, help='This matching rule is used when the user is not certain of all the informations of the counterpart.')
+    matching_order = fields.Selection(
+        selection=[
+            ('old_first', 'Oldest first'),
+            ('new_first', 'Newest first'),
+        ],
+        required=True,
+        default='old_first',
+    )
 
     # ===== Conditions =====
+    match_text_location_label = fields.Boolean(
+        default=True,
+        help="Search in the Statement's Label to find the Invoice/Payment's reference",
+    )
+    match_text_location_note = fields.Boolean(
+        default=False,
+        help="Search in the Statement's Note to find the Invoice/Payment's reference",
+    )
+    match_text_location_reference = fields.Boolean(
+        default=False,
+        help="Search in the Statement's Reference to find the Invoice/Payment's reference",
+    )
     match_journal_ids = fields.Many2many('account.journal', string='Journals',
         domain="[('type', 'in', ('bank', 'cash')), ('company_id', '=', company_id)]",
         check_company=True,
@@ -525,22 +546,16 @@ class AccountReconcileModel(models.Model):
         # (higher priority) from invoice matching using the partner (lower priority).
         query = r'''
         SELECT
-            %(sequence)s                        AS sequence,
-            %(model_id)s                        AS model_id,
             st_line.id                          AS id,
             aml.id                              AS aml_id,
             aml.currency_id                     AS aml_currency_id,
             aml.date_maturity                   AS aml_date_maturity,
             aml.amount_residual                 AS aml_amount_residual,
             aml.amount_residual_currency        AS aml_amount_residual_currency,
-            aml.balance                         AS aml_balance,
-            aml.amount_currency                 AS aml_amount_currency,
-            account.internal_type               AS account_internal_type,
-
-            ''' + self._get_select_communication_flag() + r''', ''' + self._get_select_payment_reference_flag() + r'''
+            ''' + self._get_select_communication_flag() + r''' AS communication_flag,
+            ''' + self._get_select_payment_reference_flag() + r''' AS payment_reference_flag
         FROM account_bank_statement_line st_line
         JOIN account_move st_line_move          ON st_line_move.id = st_line.move_id
-        JOIN account_journal journal            ON journal.id = st_line_move.journal_id
         JOIN res_company company                ON company.id = st_line_move.company_id
         , account_move_line aml
         LEFT JOIN account_move move             ON move.id = aml.move_id AND move.state = 'posted'
@@ -571,35 +586,12 @@ class AccountReconcileModel(models.Model):
                 st_line_subquery += r"""
                     AND
                     (
-                        substring(REGEXP_REPLACE(st_line.payment_ref, '[^0-9|^\s]', '', 'g'), '\S(?:.*\S)*') != ''
+                        substring(REGEXP_REPLACE(st_line.payment_ref, '[^0-9\s]', '', 'g'), '\S(?:.*\S)*') != ''
                         AND
                         (
-                            (
-                                aml.name IS NOT NULL
-                                AND
-                                substring(REGEXP_REPLACE(aml.name, '[^0-9|^\s]', '', 'g'), '\S(?:.*\S)*') != ''
-                                AND
-                                    regexp_split_to_array(substring(REGEXP_REPLACE(aml.name, '[^0-9|^\s]', '', 'g'), '\S(?:.*\S)*'),'\s+')
-                                    && regexp_split_to_array(substring(REGEXP_REPLACE(st_line.payment_ref, '[^0-9|^\s]', '', 'g'), '\S(?:.*\S)*'), '\s+')
-                            )
-                            OR
-                                regexp_split_to_array(substring(REGEXP_REPLACE(move.name, '[^0-9|^\s]', '', 'g'), '\S(?:.*\S)*'),'\s+')
-                                && regexp_split_to_array(substring(REGEXP_REPLACE(st_line.payment_ref, '[^0-9|^\s]', '', 'g'), '\S(?:.*\S)*'), '\s+')
-                            OR
-                            (
-                                move.ref IS NOT NULL
-                                AND
-                                substring(REGEXP_REPLACE(move.ref, '[^0-9|^\s]', '', 'g'), '\S(?:.*\S)*') != ''
-                                AND
-                                    regexp_split_to_array(substring(REGEXP_REPLACE(move.ref, '[^0-9|^\s]', '', 'g'), '\S(?:.*\S)*'),'\s+')
-                                    && regexp_split_to_array(substring(REGEXP_REPLACE(st_line.payment_ref, '[^0-9|^\s]', '', 'g'), '\S(?:.*\S)*'), '\s+')
-                            )
+                            (""" + self._get_select_communication_flag() + """)
                             OR
-                            (
-                                move.payment_reference IS NOT NULL
-                                AND
-                                regexp_replace(move.payment_reference, '\s+', '', 'g') = regexp_replace(st_line.payment_ref, '\s+', '', 'g')
-                            )
+                            (""" + self._get_select_payment_reference_flag() + """)
                         )
                     )
                     OR
@@ -617,10 +609,7 @@ class AccountReconcileModel(models.Model):
 
         query += r" AND (%s) " % " OR ".join(st_lines_queries)
 
-        params = {
-            'sequence': self.sequence,
-            'model_id': self.id,
-        }
+        params = {}
 
         # If this reconciliation model defines a past_months_limit, we add a condition
         # to the query to only search on move lines that are younger than this limit.
@@ -634,56 +623,79 @@ class AccountReconcileModel(models.Model):
             query += 'AND aml.id NOT IN %(excluded_aml_ids)s'
             params['excluded_aml_ids'] = tuple(excluded_ids)
 
-        # Oldest due dates come first.
-        query += ' ORDER BY aml_date_maturity, aml_id'
+        if self.matching_order == 'new_first':
+            query += ' ORDER BY aml_date_maturity DESC, aml_id DESC'
+        else:
+            query += ' ORDER BY aml_date_maturity ASC, aml_id ASC'
 
         return query, params
 
     def _get_select_communication_flag(self):
-        return r'''
-            -- Determine a matching or not with the statement line communication using the aml.name, move.name or move.ref.
-            (
-                aml.name IS NOT NULL
-                AND
-                substring(REGEXP_REPLACE(aml.name, '[^0-9|^\s]', '', 'g'), '\S(?:.*\S)*') != ''
-                AND
-                    regexp_split_to_array(substring(REGEXP_REPLACE(aml.name, '[^0-9|^\s]', '', 'g'), '\S(?:.*\S)*'),'\s+')
-                    && regexp_split_to_array(substring(REGEXP_REPLACE(st_line.payment_ref, '[^0-9|^\s]', '', 'g'), '\S(?:.*\S)*'), '\s+')
-            )
-            OR
-                regexp_split_to_array(substring(REGEXP_REPLACE(move.name, '[^0-9|^\s]', '', 'g'), '\S(?:.*\S)*'),'\s+')
-                && regexp_split_to_array(substring(REGEXP_REPLACE(st_line.payment_ref, '[^0-9|^\s]', '', 'g'), '\S(?:.*\S)*'), '\s+')
-            OR
-            (
-                move.ref IS NOT NULL
-                AND
-                substring(REGEXP_REPLACE(move.ref, '[^0-9|^\s]', '', 'g'), '\S(?:.*\S)*') != ''
-                AND
-                    regexp_split_to_array(substring(REGEXP_REPLACE(move.ref, '[^0-9|^\s]', '', 'g'), '\S(?:.*\S)*'),'\s+')
-                    && regexp_split_to_array(substring(REGEXP_REPLACE(st_line.payment_ref, '[^0-9|^\s]', '', 'g'), '\S(?:.*\S)*'), '\s+')
-            )                                   AS communication_flag
-        '''
+        self.ensure_one()
+        # Determine a matching or not with the statement line communication using the aml.name, move.name or move.ref.
+        st_ref_list = []
+        if self.match_text_location_label:
+            st_ref_list += ['st_line.payment_ref']
+        if self.match_text_location_note:
+            st_ref_list += ['st_line_move.narration']
+        if self.match_text_location_reference:
+            st_ref_list += ['st_line_move.ref']
+
+        st_ref = " || ' ' || ".join(
+            "COALESCE(%s, '')" % st_ref_name
+            for st_ref_name in st_ref_list
+        )
+        if not st_ref:
+            return "FALSE"
+
+        statement_compare = r"""(
+                {move_field} IS NOT NULL AND substring(REGEXP_REPLACE({move_field}, '[^0-9\s]', '', 'g'), '\S(?:.*\S)*') != ''
+                AND (
+                    regexp_split_to_array(substring(REGEXP_REPLACE({move_field}, '[^0-9\s]', '', 'g'), '\S(?:.*\S)*'),'\s+')
+                    && regexp_split_to_array(substring(REGEXP_REPLACE({st_ref}, '[^0-9\s]', '', 'g'), '\S(?:.*\S)*'), '\s+')
+                )
+            )"""
+        return " OR ".join(
+            statement_compare.format(move_field=field, st_ref=st_ref)
+            for field in ['aml.name', 'move.name', 'move.ref']
+        )
 
     def _get_select_payment_reference_flag(self):
-        return r'''
-            -- Determine a matching or not with the statement line communication using the move.payment_reference.
-            (
-                move.payment_reference IS NOT NULL
-                AND
-                regexp_replace(move.payment_reference, '\s+', '', 'g') = regexp_replace(st_line.payment_ref, '\s+', '', 'g')
-            )                                   AS payment_reference_flag
-        '''
+        # Determine a matching or not with the statement line communication using the move.payment_reference.
+        st_ref_list = []
+        if self.match_text_location_label:
+            st_ref_list += ['st_line.payment_ref']
+        if self.match_text_location_note:
+            st_ref_list += ['st_line_move.narration']
+        if self.match_text_location_reference:
+            st_ref_list += ['st_line_move.ref']
+        if not st_ref_list:
+            return "FALSE"
+        return r'''(move.payment_reference IS NOT NULL AND ({}))'''.format(
+            ' OR '.join(
+                rf"regexp_replace(move.payment_reference, '\s+', '', 'g') = regexp_replace({st_ref}, '\s+', '', 'g')"
+                for st_ref in st_ref_list
+            )
+        )
 
     def _get_partner_from_mapping(self, st_line):
-        """ For invoice matching rules, matches the statement line against
-        each regex defined in partner mapping, and returns the partner corresponding to
-        the first one matching.
+        """Find partner with mapping defined on model.
+
+        For invoice matching rules, matches the statement line against each
+        regex defined in partner mapping, and returns the partner corresponding
+        to the first one matching.
+
+        :param st_line (Model<account.bank.statement.line>):
+            The statement line that needs a partner to be found
+        :return Model<res.partner>:
+            The partner found from the mapping. Can be empty an empty recordset
+            if there was nothing found from the mapping or if the function is
+            not applicable.
         """
         self.ensure_one()
 
-        if self.rule_type != 'invoice_matching':
-            # Only invoice_matching rules support this option
-            return None
+        if self.rule_type not in ('invoice_matching', 'writeoff_suggestion'):
+            return self.env['res.partner']
 
         for partner_mapping in self.partner_mapping_line_ids:
             match_payment_ref = re.match(partner_mapping.payment_ref_regex, st_line.payment_ref) if partner_mapping.payment_ref_regex else True
@@ -691,7 +703,7 @@ class AccountReconcileModel(models.Model):
 
             if match_payment_ref and match_narration:
                 return partner_mapping.partner_id
-        return None
+        return self.env['res.partner']
 
     def _get_writeoff_suggestion_query(self, st_lines_with_partner, excluded_ids=None):
         ''' Returns the query applying the current writeoff_suggestion reconciliation
@@ -710,18 +722,11 @@ class AccountReconcileModel(models.Model):
 
         query = '''
             SELECT
-                %(sequence)s                        AS sequence,
-                %(model_id)s                        AS model_id,
                 st_line.id                          AS id
             FROM account_bank_statement_line st_line
-            JOIN account_move st_line_move          ON st_line_move.id = st_line.move_id
-            LEFT JOIN account_journal journal       ON journal.id = st_line_move.journal_id
-            LEFT JOIN res_company company           ON company.id = st_line_move.company_id
             WHERE st_line.id IN %(st_line_ids)s
         '''
         params = {
-            'sequence': self.sequence,
-            'model_id': self.id,
             'st_line_ids': tuple(st_line.id for (st_line, partner) in st_lines_with_partner),
         }
 

--- a/addons/account/models/chart_template.py
+++ b/addons/account/models/chart_template.py
@@ -1116,8 +1116,26 @@ class AccountReconcileModelTemplate(models.Model):
     auto_reconcile = fields.Boolean(string='Auto-validate',
         help='Validate the statement line automatically (reconciliation based on your rule).')
     to_check = fields.Boolean(string='To Check', default=False, help='This matching rule is used when the user is not certain of all the informations of the counterpart.')
+    matching_order = fields.Selection(
+        selection=[
+            ('old_first', 'Oldest first'),
+            ('new_first', 'Newest first'),
+        ]
+    )
 
     # ===== Conditions =====
+    match_text_location_label = fields.Boolean(
+        default=True,
+        help="Search in the Statement's Label to find the Invoice/Payment's reference",
+    )
+    match_text_location_note = fields.Boolean(
+        default=False,
+        help="Search in the Statement's Note to find the Invoice/Payment's reference",
+    )
+    match_text_location_reference = fields.Boolean(
+        default=False,
+        help="Search in the Statement's Reference to find the Invoice/Payment's reference",
+    )
     match_journal_ids = fields.Many2many('account.journal', string='Journals',
         domain="[('type', 'in', ('bank', 'cash'))]",
         help='The reconciliation model will only be available from the selected journals.')
