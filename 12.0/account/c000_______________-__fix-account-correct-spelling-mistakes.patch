PR: https://github.com/odoo/odoo/pull/

From: 7fd8c7f7f71b419b8d55fe87933237d68b6dc265
From: Andrew Latham
Date: 2017-11-03 08:19:33

Structural Changes: 2
Total Changes: 92

[FIX] account: correct spelling mistakes

Closes #20652

Partially backported at 5aebc227223

================================= pseudo patch: =================================

--- a/addons/account/models/account.py
+++ b/addons/account/models/account.py
@@ -52,7 +52,7 @@ class AccountAccount(models.Model):
     def _check_reconcile(self):
         for account in self:
             if account.internal_type in ('receivable', 'payable') and account.reconcile == False:
-                raise ValidationError(_('You cannot have a receivable/payable account that is not reconciliable. (account code: %s)') % account.code)
+                raise ValidationError(_('You cannot have a receivable/payable account that is not reconcilable. (account code: %s)') % account.code)
 
     name = fields.Char(required=True, index=True)
     currency_id = fields.Many2one('res.currency', string='Account Currency',
@@ -107,7 +107,7 @@ class AccountAccount(models.Model):
     def _set_opening_debit_credit(self, amount, field):
         """ Generic function called by both opening_debit and opening_credit's
         inverse function. 'Amount' parameter is the value to be set, and field
-        either 'debit' or 'credit', depending on wich one of these two fields
+        either 'debit' or 'credit', depending on which one of these two fields
         got assigned.
         """
         opening_move = self.company_id.account_opening_move_id
@@ -215,7 +215,7 @@ class AccountAccount(models.Model):
     def load(self, fields, data):
         """ Overridden for better performances when importing a list of account
         with opening debit/credit. In that case, the auto-balance is postpone
-        untill the whole file has been imported.
+        until the whole file has been imported.
         """
         rslt = super(AccountAccount, self).load(fields, data)
 
@@ -227,7 +227,7 @@ class AccountAccount(models.Model):
 
     @api.multi
     def write(self, vals):
-        # Dont allow changing the company_id when account_move_line already exist
+        # Do not allow changing the company_id when account_move_line already exist
         if vals.get('company_id', False):
             move_lines = self.env['account.move.line'].search([('account_id', 'in', self.ids)], limit=1)
             for account in self:
@@ -364,7 +364,7 @@ class AccountJournal(models.Model):
         domain=[('payment_type', '=', 'inbound')], string='Debit Methods', default=lambda self: self._default_inbound_payment_methods(),
         help="Manual: Get paid by cash, check or any other method outside of Odoo.\n"\
              "Electronic: Get paid automatically through a payment acquirer by requesting a transaction on a card saved by the customer when buying or subscribing online (payment token).\n"\
-             "Batch Deposit: Encash several customer checks at once by generating a batch deposit to submit to your bank. When encoding the bank statement in Odoo,you are suggested to reconcile the transaction with the batch deposit. Enable this option from the settings.")
+             "Batch Deposit: Encase several customer checks at once by generating a batch deposit to submit to your bank. When encoding the bank statement in Odoo,you are suggested to reconcile the transaction with the batch deposit. Enable this option from the settings.")
     outbound_payment_method_ids = fields.Many2many('account.payment.method', 'account_journal_outbound_payment_method_rel', 'journal_id', 'outbound_payment_method',
         domain=[('payment_type', '=', 'outbound')], string='Payment Methods', default=lambda self: self._default_outbound_payment_methods(),
         help="Manual:Pay bill by cash or any other method outside of Odoo.\n"\
@@ -558,7 +558,7 @@ class AccountJournal(models.Model):
 
         :param name: name of the bank account
         :param company: company for which the wizard is running
-        :param currency_id: ID of the currency in wich is the bank account
+        :param currency_id: ID of the currency in which is the bank account
         :param type: either 'cash' or 'bank'
         :return: mapping of field names and values
         :rtype: dict
@@ -796,7 +796,7 @@ class AccountTax(models.Model):
 
     @api.model
     def name_search(self, name, args=None, operator='ilike', limit=80):
-        """ Returns a list of tupples containing id, name, as internally it is called {def name_get}
+        """ Returns a list of tuples containing id, name, as internally it is called {def name_get}
             result format: {[(id, name), (id, name), ...]}
         """
         args = args or []
@@ -882,7 +882,7 @@ class AccountTax(models.Model):
 
     @api.multi
     def compute_all(self, price_unit, currency=None, quantity=1.0, product=None, partner=None):
-        """ Returns all information required to apply taxes (in self + their children in case of a tax goup).
+        """ Returns all information required to apply taxes (in self + their children in case of a tax group).
             We consider the sequence of the parent for group of taxes.
                 Eg. considering letters as taxes and alphabetic order as sequence :
                 [G, B([A, D, F]), E, C] will be computed as [A, D, F, C, E, G]

--- a/addons/account/models/account_bank_statement.py
+++ b/addons/account/models/account_bank_statement.py
@@ -454,7 +454,7 @@ class AccountBankStatementLine(models.Model):
             else:
                 unreconciled += stl
 
-        # Collect various informations for the reconciliation widget
+        # Collect various information for the reconciliation widget
         notifications = []
         num_auto_reconciled = len(automatic_reconciliation_entries)
         if num_auto_reconciled > 0:
@@ -733,7 +733,7 @@ class AccountBankStatementLine(models.Model):
         except UserError:
             # A configuration / business logic error that makes it impossible to auto-reconcile should not be raised
             # since automatic reconciliation is just an amenity and the user will get the same exception when manually
-            # reconciling. Other types of exception are (hopefully) programmation errors and should cause a stacktrace.
+            # reconciling. Other types of exception are (hopefully) programming errors and should cause a stacktrace.
             self.invalidate_cache()
             self.env['account.move'].invalidate_cache()
             self.env['account.move.line'].invalidate_cache()
@@ -769,7 +769,7 @@ class AccountBankStatementLine(models.Model):
         st_line_currency = self.currency_id or statement_currency
         amount_currency = False
         st_line_currency_rate = self.currency_id and (self.amount_currency / self.amount) or False
-        # We have several use case here to compure the currency and amount currency of counterpart line to balance the move:
+        # We have several use case here to compare the currency and amount currency of counterpart line to balance the move:
         if st_line_currency != company_currency and st_line_currency == statement_currency:
             # company in currency A, statement in currency B and transaction in currency B
             # counterpart line must have currency B and correct amount is inverse of already existing lines

--- a/addons/account/models/account_cash_rounding.py
+++ b/addons/account/models/account_cash_rounding.py
@@ -7,7 +7,7 @@ from odoo.tools import float_round
 class AccountCashRounding(models.Model):
     """
     In some countries, we need to be able to make appear on an invoice a rounding line, appearing there only because the
-    smallest coinage has been removed from the circulation. For example, in Switerzland invoices have to be rounded to
+    smallest coinage has been removed from the circulation. For example, in Switzerland invoices have to be rounded to
     0.05 CHF because coins of 0.01 CHF and 0.02 CHF aren't used anymore.
     see https://en.wikipedia.org/wiki/Cash_rounding for more details.
     """

--- a/addons/account/models/account_journal_dashboard.py
+++ b/addons/account/models/account_journal_dashboard.py
@@ -219,7 +219,7 @@ class account_journal(models.Model):
 
     def _get_open_bills_to_pay_query(self):
         """
-        Returns a tuple contaning the SQL query used to gather the open bills
+        Returns a tuple containing the SQL query used to gather the open bills
         data as its first element, and the arguments dictionary to use to run
         it as its second.
         """

--- a/addons/account/models/account_move.py
+++ b/addons/account/models/account_move.py
@@ -812,10 +812,10 @@ class AccountMoveLine(models.Model):
             # 3)    33      0           25             YEN
             # 
             # If we ask to see the information in the reconciliation widget in company currency, we want to see
-            # The following informations
+            # The following information
             # 1) 25 USD (no currency information)
             # 2) 17 USD [25 EUR] (show 25 euro in currency information, in the little bill)
-            # 3) 33 USD [25 YEN] (show 25 yen in currencu information)
+            # 3) 33 USD [25 YEN] (show 25 yen in currency information)
             # 
             # If we ask to see the information in another currency than the company let's say EUR
             # 1) 35 EUR [25 USD]
@@ -863,7 +863,7 @@ class AccountMoveLine(models.Model):
             :param data: list of dicts containing:
                 - 'type': either 'partner' or 'account'
                 - 'id': id of the affected res.partner or account.account
-                - 'mv_line_ids': ids of exisiting account.move.line to reconcile
+                - 'mv_line_ids': ids of existing account.move.line to reconcile
                 - 'new_mv_line_dicts': list of dicts containing values suitable for account_move_line.create()
         """
         for datum in data:
@@ -881,7 +881,7 @@ class AccountMoveLine(models.Model):
     def process_reconciliation(self, new_mv_line_dicts):
         """ Create new move lines from new_mv_line_dicts (if not empty) then call reconcile_partial on self and new move lines
 
-            :param new_mv_line_dicts: list of dicts containing values suitable fot account_move_line.create()
+            :param new_mv_line_dicts: list of dicts containing values suitable for account_move_line.create()
         """
         if len(self) < 1 or len(self) + len(new_mv_line_dicts) < 2:
             raise UserError(_('A reconciliation must involve at least 2 move lines.'))
@@ -1028,7 +1028,7 @@ class AccountMoveLine(models.Model):
             if not all_aml_share_same_currency:
                 writeoff_vals['amount_currency'] = False
             writeoff_to_reconcile = remaining_moves._create_writeoff(writeoff_vals)
-            #add writeoff line to reconcile algo and finish the reconciliation
+            #add writeoff line to reconcile algorithm and finish the reconciliation
             remaining_moves = (remaining_moves + writeoff_to_reconcile).auto_reconcile_lines()
             return writeoff_to_reconcile
         return True
@@ -1037,7 +1037,7 @@ class AccountMoveLine(models.Model):
         """ Create a writeoff move for the account.move.lines in self. If debit/credit is not specified in vals,
             the writeoff amount will be computed as the sum of amount_residual of the given recordset.
 
-            :param vals: dict containing values suitable fot account_move_line.create(). The data in vals will
+            :param vals: dict containing values suitable for account_move_line.create(). The data in vals will
                 be processed to create bot writeoff acount.move.line and their enclosing account.move.
         """
         # Check and complete vals
@@ -1141,7 +1141,7 @@ class AccountMoveLine(models.Model):
             #eventually create journal entries to book the difference due to foreign currency's exchange rate that fluctuates
             aml_recs, partial_recs = self.env['account.partial.reconcile'].create_exchange_rate_entry(aml_to_balance, 0.0, total_amount_currency, currency, exchange_move)
 
-            #add the ecxhange rate line and the exchange rate partial reconciliation in the et of the full reconcile
+            #add the exchange rate line and the exchange rate partial reconciliation in the et of the full reconcile
             self |= aml_recs
             partial_rec_set |= partial_recs
 
@@ -1372,7 +1372,7 @@ class AccountMoveLine(models.Model):
 
     def _get_matched_percentage(self):
         """ This function returns a dictionary giving for each move_id of self, the percentage to consider as cash basis factor.
-        This is actuallty computing the same as the matched_percentage field of account.move, except in case of multi-currencies
+        This is actually computing the same as the matched_percentage field of account.move, except in case of multi-currencies
         where we recompute the matched percentage based on the amount_currency fields.
         Note that this function is used only by the tax cash basis module since we want to consider the matched_percentage only
         based on the company currency amounts in reports.
@@ -1565,7 +1565,7 @@ class AccountPartialReconcile(models.Model):
     def create_exchange_rate_entry(self, aml_to_fix, amount_diff, diff_in_currency, currency, move):
         """
         Automatically create a journal items to book the exchange rate
-        differences that can occure in multi-currencies environment. That
+        differences that can occur in multi-currencies environment. That
         new journal item will be made into the given `move` in the company
         `currency_exchange_journal_id`, and one of its journal items is
         matched with the other lines to balance the full reconciliation.
@@ -1642,7 +1642,7 @@ class AccountPartialReconcile(models.Model):
             if move_date < move.date:
                 move_date = move.date
             for line in move.line_ids:
-                #TOCHECK: normal and cash basis taxes shoudn't be mixed together (on the same invoice line for example) as it will
+                #TOCHECK: normal and cash basis taxes shouldn't be mixed together (on the same invoice line for example) as it will
                 # create reporting issues. Not sure of the behavior to implement in that case, though.
                 if not line.tax_exigible:
                     percentage_before = percentage_before_rec[move.id]
@@ -1852,7 +1852,7 @@ class AccountFullReconcile(models.Model):
     def unlink(self):
         """ When removing a full reconciliation, we need to revert the eventual journal entries we created to book the
             fluctuation of the foreign currency's exchange rate.
-            We need also to reconcile together the origin currency difference line and its reversal in order to completly
+            We need also to reconcile together the origin currency difference line and its reversal in order to completely
             cancel the currency difference entry on the partner account (otherwise it will still appear on the aged balance
             for example).
         """

--- a/addons/account/models/account_payment.py
+++ b/addons/account/models/account_payment.py
@@ -35,7 +35,7 @@ class account_abstract_payment(models.AbstractModel):
         help="Manual: Get paid by cash, check or any other method outside of Odoo.\n"\
         "Electronic: Get paid automatically through a payment acquirer by requesting a transaction on a card saved by the customer when buying or subscribing online (payment token).\n"\
         "Check: Pay bill by check and print it from Odoo.\n"\
-        "Batch Deposit: Encash several customer checks at once by generating a batch deposit to submit to your bank. When encoding the bank statement in Odoo, you are suggested to reconcile the transaction with the batch deposit.To enable batch deposit,module account_batch_deposit must be installed.\n"\
+        "Batch Deposit: Encase several customer checks at once by generating a batch deposit to submit to your bank. When encoding the bank statement in Odoo, you are suggested to reconcile the transaction with the batch deposit.To enable batch deposit,module account_batch_deposit must be installed.\n"\
         "SEPA Credit Transfer: Pay bill from a SEPA Credit Transfer file you submit to your bank. To enable sepa credit transfer, module account_sepa must be installed ")
     payment_method_code = fields.Char(related='payment_method_id.code',
         help="Technical field used to adapt the interface to the payment type selected.", readonly=True)
@@ -132,7 +132,7 @@ class account_register_payments(models.TransientModel):
 
         # Check for selected invoices ids
         if not active_ids:
-            raise UserError(_("Programmation error: wizard action executed without active_ids in context."))
+            raise UserError(_("Programming error: wizard action executed without active_ids in context."))
 
         invoices = self.env['account.invoice'].browse(active_ids)
 
@@ -459,8 +459,8 @@ class account_payment(models.Model):
     def post(self):
         """ Create the journal items for the payment and update the payment's state to 'posted'.
             A journal entry is created containing an item in the source liquidity account (selected journal's default_debit or default_credit)
-            and another in the destination reconciliable account (see _compute_destination_account_id).
-            If invoice_ids is not empty, there will be one reconciliable move line per invoice to reconcile with.
+            and another in the destination reconcilable account (see _compute_destination_account_id).
+            If invoice_ids is not empty, there will be one reconcilable move line per invoice to reconcile with.
             If the payment is a transfer, a second journal entry is created in the destination journal to receive money from the transfer account.
         """
         for rec in self:
@@ -524,7 +524,7 @@ class account_payment(models.Model):
         aml_obj = self.env['account.move.line'].with_context(check_move_validity=False)
         invoice_currency = False
         if self.invoice_ids and all([x.currency_id == self.invoice_ids[0].currency_id for x in self.invoice_ids]):
-            #if all the invoices selected share the same currency, record the paiement in that currency too
+            #if all the invoices selected share the same currency, record the payment in that currency too
             invoice_currency = self.invoice_ids[0].currency_id
         debit, credit, amount_currency, currency_id = aml_obj.with_context(date=self.payment_date).compute_amount_fields(amount, self.currency_id, self.company_id.currency_id, invoice_currency)
 
@@ -589,7 +589,7 @@ class account_payment(models.Model):
         return move
 
     def _create_transfer_entry(self, amount):
-        """ Create the journal entry corresponding to the 'incoming money' part of an internal transfer, return the reconciliable move line
+        """ Create the journal entry corresponding to the 'incoming money' part of an internal transfer, return the reconcilable move line
         """
         aml_obj = self.env['account.move.line'].with_context(check_move_validity=False)
         debit, credit, amount_currency, dummy = aml_obj.with_context(date=self.payment_date).compute_amount_fields(amount, self.currency_id, self.company_id.currency_id)

--- a/addons/account/models/chart_template.py
+++ b/addons/account/models/chart_template.py
@@ -22,7 +22,7 @@ def migrate_set_tags_and_taxes_updatable(cr, registry, module):
         cr.execute("update ir_model_data set noupdate = 'f' where id in %s", (tuple(xml_record_ids),))
 
 def migrate_tags_on_taxes(cr, registry):
-    ''' This is a utiliy function to help migrate the tags of taxes when the localization has been modified on stable version. If
+    ''' This is a utility function to help migrate the tags of taxes when the localization has been modified on stable version. If
     called accordingly in a post_init_hooked function, it will reset the tags set on taxes as per their equivalent template.
 
     Note: This unusual decision has been made in order to help the improvement of VAT reports on version 9.0, to have them more flexible
@@ -366,7 +366,7 @@ class AccountChartTemplate(models.Model):
         return ir_model_data._update(model, template_xmlid.module, vals, xml_id=new_xml_id, store=True, noupdate=True, mode='init', res_id=False)
 
     def _get_account_vals(self, company, account_template, code_acc, tax_template_ref):
-        """ This method generates a dictionnary of all the values for the account that will be created.
+        """ This method generates a dictionary of all the values for the account that will be created.
         """
         self.ensure_one()
         tax_ids = []
@@ -391,7 +391,7 @@ class AccountChartTemplate(models.Model):
         """ This method for generating accounts from templates.
 
             :param tax_template_ref: Taxes templates reference for write taxes_id in account_account.
-            :param acc_template_ref: dictionary with the mappping between the account templates and the real accounts.
+            :param acc_template_ref: dictionary with the mapping between the account templates and the real accounts.
             :param code_digits: number of digits got from wizard.multi.charts.accounts, this is use for account code.
             :param company_id: company_id selected from wizard.multi.charts.accounts.
             :returns: return acc_template_ref for reference purpose.
@@ -411,7 +411,7 @@ class AccountChartTemplate(models.Model):
         return acc_template_ref
 
     def _prepare_reconcile_model_vals(self, company, account_reconcile_model, acc_template_ref, tax_template_ref):
-        """ This method generates a dictionnary of all the values for the account.reconcile.model that will be created.
+        """ This method generates a dictionary of all the values for the account.reconcile.model that will be created.
         """
         self.ensure_one()
         return {
@@ -436,7 +436,7 @@ class AccountChartTemplate(models.Model):
         """ This method for generating accounts from templates.
 
             :param tax_template_ref: Taxes templates reference for write taxes_id in account_account.
-            :param acc_template_ref: dictionary with the mappping between the account templates and the real accounts.
+            :param acc_template_ref: dictionary with the mapping between the account templates and the real accounts.
             :param company_id: company_id selected from wizard.multi.charts.accounts.
             :returns: return new_account_reconcile_model for reference purpose.
             :rtype: dict
@@ -538,7 +538,7 @@ class AccountTaxTemplate(models.Model):
         'account.account.template',
         string='Tax Received Account',
         domain=[('deprecated', '=', False)],
-        help='Account used as counterpart for the journal entry, for taxes exigible based on payments.')
+        help='Account used as counterpart for the journal entry, for taxes eligible based on payments.')
 
     _sql_constraints = [
         ('name_company_uniq', 'unique(name, company_id, type_tax_use, chart_template_id)', 'Tax names must be unique !'),
@@ -554,7 +554,7 @@ class AccountTaxTemplate(models.Model):
         return res
 
     def _get_tax_vals(self, company, tax_template_to_tax):
-        """ This method generates a dictionnary of all the values for the tax that will be created.
+        """ This method generates a dictionary of all the values for the tax that will be created.
         """
         # Compute children tax ids
         children_ids = []
@@ -609,7 +609,7 @@ class AccountTaxTemplate(models.Model):
 
         if any([tax.tax_exigibility == 'on_payment' for tax in self]):
             # When a CoA is being installed automatically and if it is creating account tax(es) whose field `Use Cash Basis`(tax_exigibility) is set to True by default
-            # (exapmple of such CoA's are l10n_fr and l10n_mx) then in the `Accounting Settings` the option `Cash Basis` should be checked by default.
+            # (example of such CoA's are l10n_fr and l10n_mx) then in the `Accounting Settings` the option `Cash Basis` should be checked by default.
             company.tax_exigibility = True
 
         return {
@@ -634,7 +634,7 @@ class AccountFiscalPositionTemplate(models.Model):
     country_id = fields.Many2one('res.country', string='Country',
         help="Apply only if delivery or invoicing country match.")
     country_group_id = fields.Many2one('res.country.group', string='Country Group',
-        help="Apply only if delivery or invocing country match the group.")
+        help="Apply only if delivery or invoicing country match the group.")
     state_ids = fields.Many2many('res.country.state', string='Federal States')
     zip_from = fields.Integer(string='Zip Range From', default=0)
     zip_to = fields.Integer(string='Zip Range To', default=0)
@@ -728,7 +728,7 @@ class WizardMultiChartsAccounts(models.TransientModel):
             self.complete_tax_set = self.chart_template_id.complete_tax_set
             self.currency_id = currency_id
             if self.chart_template_id.complete_tax_set:
-            # default tax is given by the lowest sequence. For same sequence we will take the latest created as it will be the case for tax created while isntalling the generic chart of account
+            # default tax is given by the lowest sequence. For same sequence we will take the latest created as it will be the case for tax created while installing the generic chart of account
                 chart_ids = self._get_chart_parent_ids(self.chart_template_id)
                 base_tax_domain = [('chart_template_id', 'parent_of', chart_ids)]
                 sale_tax_domain = base_tax_domain + [('type_tax_use', '=', 'sale')]
@@ -827,7 +827,7 @@ class WizardMultiChartsAccounts(models.TransientModel):
         it's not the case, it creates the templates for account.tax object accordingly to the provided sale/purchase rates.
         Then it saves the new tax templates as default taxes to use for this chart template.
 
-        :param company_id: id of the company for wich the wizard is running
+        :param company_id: id of the company for which the wizard is running
         :return: True
         '''
         obj_tax_temp = self.env['account.tax.template']

--- a/addons/account/models/company.py
+++ b/addons/account/models/company.py
@@ -271,7 +271,7 @@ Best Regards,''')
             default_journal = self.env['account.journal'].search([('type', '=', 'general'), ('company_id', '=', self.id)], limit=1)
 
             if not default_journal:
-                raise UserError(_("No miscellanous journal could be found. Please create one before proceeding."))
+                raise UserError(_("No miscellaneous journal could be found. Please create one before proceeding."))
 
             self.account_opening_move_id = self.env['account.move'].create({
                 'name': _('Opening Journal Entry'),

--- a/addons/account/models/partner.py
+++ b/addons/account/models/partner.py
@@ -27,7 +27,7 @@ class AccountFiscalPosition(models.Model):
     country_id = fields.Many2one('res.country', string='Country',
         help="Apply only if delivery or invoicing country match.")
     country_group_id = fields.Many2one('res.country.group', string='Country Group',
-        help="Apply only if delivery or invocing country match the group.")
+        help="Apply only if delivery or invoicing country match the group.")
     state_ids = fields.Many2many('res.country.state', string='Federal States')
     zip_from = fields.Integer(string='Zip Range From', default=0)
     zip_to = fields.Integer(string='Zip Range To', default=0)
@@ -137,7 +137,7 @@ class AccountFiscalPosition(models.Model):
     def get_fiscal_position(self, partner_id, delivery_id=None):
         if not partner_id:
             return False
-        # This can be easily overriden to apply more complex fiscal rules
+        # This can be easily overridden to apply more complex fiscal rules
         PartnerObj = self.env['res.partner']
         partner = PartnerObj.browse(partner_id)
 
@@ -271,7 +271,7 @@ class ResPartner(models.Model):
             all_partners_and_children[partner] = self.with_context(active_test=False).search([('id', 'child_of', partner.id)]).ids
             all_partner_ids += all_partners_and_children[partner]
 
-        # searching account.invoice.report via the orm is comparatively expensive
+        # searching account.invoice.report via the ORM is comparatively expensive
         # (generates queries "id in []" forcing to build the full table).
         # In simple cases where all invoices are in the same currency than the user's company
         # access directly these elements

--- a/addons/account/models/res_config_settings.py
+++ b/addons/account/models/res_config_settings.py
@@ -139,7 +139,7 @@ class ResConfigSettings(models.TransientModel):
         # Optimisation purpose, saving a res_config even without changing any values will trigger the write of all
         # related values, including the currency_id field on res_company. This in turn will trigger the recomputation
         # of account_move_line related field company_currency_id which can be slow depending on the number of entries
-        # in the database. Thus, if we do not explicitely change the currency_id, we should not write it on the company
+        # in the database. Thus, if we do not explicitly change the currency_id, we should not write it on the company
         # Same for the field `code_digits` which will trigger a write on all the account.account to complete the
         # code the missing characters to complete the desired number of digit, leading to a sql_constraint.
         if ('company_id' in values and 'currency_id' in values):
