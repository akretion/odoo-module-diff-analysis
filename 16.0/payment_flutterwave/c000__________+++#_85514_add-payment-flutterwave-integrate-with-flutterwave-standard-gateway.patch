PR: https://github.com/odoo/odoo/pull/85514

From: 94bddadf4e2339e9c5ba997d36a6c78af4aa44f9
From: Antoine Vandevenne (anv)
Date: 2022-05-31 14:02:08

Structural Changes: 9
Total Changes: 344

[ADD] payment_flutterwave: integrate with "Flutterwave standard" gateway

See README for technical details.

task-2759117

Part-of: odoo/odoo#85514

================================= pseudo patch: =================================

--- a/None
+++ b/addons/payment_flutterwave/models/__init__.py
@@ -0,0 +1,6 @@
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from . import account_payment_method
+from . import payment_acquirer
+from . import payment_token
+from . import payment_transaction

--- a/None
+++ b/addons/payment_flutterwave/models/account_payment_method.py
@@ -0,0 +1,13 @@
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from odoo import api, models
+
+
+class AccountPaymentMethod(models.Model):
+    _inherit = 'account.payment.method'
+
+    @api.model
+    def _get_payment_method_information(self):
+        res = super()._get_payment_method_information()
+        res['flutterwave'] = {'mode': 'unique', 'domain': [('type', '=', 'bank')]}
+        return res

--- a/None
+++ b/addons/payment_flutterwave/models/payment_acquirer.py
@@ -0,0 +1,115 @@
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+import logging
+import pprint
+
+import requests
+from werkzeug.urls import url_join
+
+from odoo import _, api, fields, models
+from odoo.exceptions import ValidationError
+
+from odoo.addons.payment_flutterwave.const import SUPPORTED_CURRENCIES
+
+
+_logger = logging.getLogger(__name__)
+
+
+class PaymentAcquirer(models.Model):
+    _inherit = 'payment.acquirer'
+
+    provider = fields.Selection(
+        selection_add=[('flutterwave', "Flutterwave")], ondelete={'flutterwave': 'set default'}
+    )
+    flutterwave_public_key = fields.Char(
+        string="Flutterwave Public Key",
+        help="The key solely used to identify the account with Flutterwave.",
+        required_if_provider='flutterwave',
+    )
+    flutterwave_secret_key = fields.Char(
+        string="Flutterwave Secret Key",
+        required_if_provider='flutterwave',
+        groups='base.group_system',
+    )
+    flutterwave_webhook_secret = fields.Char(
+        string="Flutterwave Webhook Secret",
+        required_if_provider='flutterwave',
+        groups='base.group_system',
+    )
+
+    #=== COMPUTE METHODS ===#
+
+    def _compute_feature_support_fields(self):
+        """ Override of `payment` to enable additional features. """
+        super()._compute_feature_support_fields()
+        self.filtered(lambda acq: acq.provider == 'flutterwave').update({
+            'support_tokenization': True,
+        })
+
+    # === BUSINESS METHODS ===#
+
+    @api.model
+    def _get_compatible_acquirers(self, *args, currency_id=None, is_validation=False, **kwargs):
+        """ Override of payment to filter out Flutterwave acquirers for unsupported currencies or
+        for validation operations. """
+        acquirers = super()._get_compatible_acquirers(
+            *args, currency_id=currency_id, is_validation=is_validation, **kwargs
+        )
+
+        currency = self.env['res.currency'].browse(currency_id).exists()
+        if (currency and currency.name not in SUPPORTED_CURRENCIES) or is_validation:
+            acquirers = acquirers.filtered(lambda a: a.provider != 'flutterwave')
+
+        return acquirers
+
+    def _flutterwave_make_request(self, endpoint, payload=None, method='POST'):
+        """ Make a request to Flutterwave API at the specified endpoint.
+
+        Note: self.ensure_one()
+
+        :param str endpoint: The endpoint to be reached by the request.
+        :param dict payload: The payload of the request.
+        :param str method: The HTTP method of the request.
+        :return The JSON-formatted content of the response.
+        :rtype: dict
+        :raise ValidationError: If an HTTP error occurs.
+        """
+        self.ensure_one()
+
+        url = url_join('https://api.flutterwave.com/v3/', endpoint)
+        headers = {'Authorization': f'Bearer {self.flutterwave_secret_key}'}
+        try:
+            if method == 'GET':
+                response = requests.get(url, params=payload, headers=headers, timeout=10)
+            else:
+                response = requests.post(url, json=payload, headers=headers, timeout=10)
+            try:
+                response.raise_for_status()
+            except requests.exceptions.HTTPError:
+                _logger.exception(
+                    "Invalid API request at %s with data:\n%s", url, pprint.pformat(payload),
+                )
+                raise ValidationError("Flutterwave: " + _(
+                    "The communication with the API failed. Flutterwave gave us the following "
+                    "information: '%s'", response.json().get('message', '')
+                ))
+        except (requests.exceptions.ConnectionError, requests.exceptions.Timeout):
+            _logger.exception("Unable to reach endpoint at %s", url)
+            raise ValidationError(
+                "Flutterwave: " + _("Could not establish the connection to the API.")
+            )
+        return response.json()
+
+    def _get_default_payment_method_id(self):
+        self.ensure_one()
+        if self.provider != 'flutterwave':
+            return super()._get_default_payment_method_id()
+        return self.env.ref('payment_flutterwave.payment_method_flutterwave').id
+
+    def _neutralize(self):
+        super()._neutralize()
+        self._neutralize_fields('flutterwave', [
+            'flutterwave_public_key',
+            'flutterwave_secret_key',
+            'flutterwave_webhook_secret',
+        ])

--- a/None
+++ b/addons/payment_flutterwave/models/payment_token.py
@@ -0,0 +1,11 @@
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from odoo import fields, models
+
+
+class PaymentToken(models.Model):
+    _inherit = 'payment.token'
+
+    flutterwave_customer_email = fields.Char(
+        help="The email of the customer at the time the token was created.", readonly=True
+    )

--- a/None
+++ b/addons/payment_flutterwave/models/payment_transaction.py
@@ -0,0 +1,199 @@
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+import logging
+import pprint
+
+from werkzeug import urls
+
+from odoo import _, models
+from odoo.exceptions import UserError, ValidationError
+
+from odoo.addons.payment import utils as payment_utils
+from odoo.addons.payment_flutterwave.const import PAYMENT_STATUS_MAPPING
+from odoo.addons.payment_flutterwave.controllers.main import FlutterwaveController
+
+
+_logger = logging.getLogger(__name__)
+
+
+class PaymentTransaction(models.Model):
+    _inherit = 'payment.transaction'
+
+    def _get_specific_rendering_values(self, processing_values):
+        """ Override of payment to return Flutterwave-specific rendering values.
+
+        Note: self.ensure_one() from `_get_processing_values`
+
+        :param dict processing_values: The generic and specific processing values of the transaction
+        :return: The dict of acquirer-specific processing values.
+        :rtype: dict
+        """
+        res = super()._get_specific_rendering_values(processing_values)
+        if self.provider != 'flutterwave':
+            return res
+
+        # Initiate the payment and retrieve the payment link data.
+        base_url = self.acquirer_id.get_base_url()
+        payload = {
+            'tx_ref': self.reference,
+            'amount': self.amount,
+            'currency': self.currency_id.name,
+            'redirect_url': urls.url_join(base_url, FlutterwaveController._return_url),
+            'customer': {
+                'email': self.partner_email,
+                'name': self.partner_name,
+                'phonenumber': self.partner_phone,
+            },
+            'customizations': {
+                'title': self.company_id.name,
+                'logo': urls.url_join(base_url, f'web/image/res.company/{self.company_id.id}/logo'),
+            },
+        }
+        payment_link_data = self.acquirer_id._flutterwave_make_request('payments', payload=payload)
+
+        # Extract the payment link URL and embed it in the redirect form.
+        rendering_values = {
+            'api_url': payment_link_data['data']['link'],
+        }
+        return rendering_values
+
+    def _send_payment_request(self):
+        """ Override of payment to send a payment request to Flutterwave.
+
+        Note: self.ensure_one()
+
+        :return: None
+        :raise UserError: If the transaction is not linked to a token.
+        """
+        super()._send_payment_request()
+        if self.provider != 'flutterwave':
+            return
+
+        # Prepare the payment request to Flutterwave.
+        if not self.token_id:
+            raise UserError("Flutterwave: " + _("The transaction is not linked to a token."))
+
+        first_name, last_name = payment_utils.split_partner_name(self.partner_name)
+        data = {
+            'token': self.token_id.acquirer_ref,
+            'email': self.token_id.flutterwave_customer_email,
+            'amount': self.amount,
+            'currency': self.currency_id.name,
+            'country': self.company_id.country_id.code,
+            'tx_ref': self.reference,
+            'first_name': first_name,
+            'last_name': last_name,
+            'ip': payment_utils.get_customer_ip_address(),
+        }
+
+        # Make the payment request to Flutterwave.
+        response_content = self.acquirer_id._flutterwave_make_request(
+            'tokenized-charges', payload=data
+        )
+
+        # Handle the payment request response.
+        _logger.info(
+            "payment request response for transaction with reference %s:\n%s",
+            self.reference, pprint.pformat(response_content)
+        )
+        self._handle_notification_data('flutterwave', response_content['data'])
+
+    def _get_tx_from_notification_data(self, provider, notification_data):
+        """ Override of payment to find the transaction based on Flutterwave data.
+
+        :param str provider: The provider of the acquirer that handled the transaction.
+        :param dict notification_data: The notification data sent by the provider.
+        :return: The transaction if found.
+        :rtype: recordset of `payment.transaction`
+        :raise ValidationError: If inconsistent data were received.
+        :raise ValidationError: If the data match no transaction.
+        """
+        tx = super()._get_tx_from_notification_data(provider, notification_data)
+        if provider != 'flutterwave' or len(tx) == 1:
+            return tx
+
+        reference = notification_data.get('tx_ref')
+        if not reference:
+            raise ValidationError("Flutterwave: " + _("Received data with missing reference."))
+
+        tx = self.search([('reference', '=', reference), ('provider', '=', 'flutterwave')])
+        if not tx:
+            raise ValidationError(
+                "Flutterwave: " + _("No transaction found matching reference %s.", reference)
+            )
+        return tx
+
+    def _process_notification_data(self, notification_data):
+        """ Override of payment to process the transaction based on Flutterwave data.
+
+        Note: self.ensure_one()
+
+        :param dict notification_data: The notification data sent by the provider.
+        :return: None
+        :raise ValidationError: If inconsistent data were received.
+        """
+        super()._process_notification_data(notification_data)
+        if self.provider != 'flutterwave':
+            return
+
+        # Verify the notification data.
+        verification_response_content = self.acquirer_id._flutterwave_make_request(
+            'transactions/verify_by_reference', payload={'tx_ref': self.reference}, method='GET'
+        )
+        verified_data = verification_response_content['data']
+
+        # Process the verified notification data.
+        self.acquirer_reference = verified_data['id']
+        payment_status = verified_data['status'].lower()
+        if payment_status in PAYMENT_STATUS_MAPPING['pending']:
+            self._set_pending()
+        elif payment_status in PAYMENT_STATUS_MAPPING['done']:
+            self._set_done()
+            has_token_data = 'token' in verified_data.get('card', {})
+            if self.tokenize and has_token_data:
+                self._flutterwave_tokenize_from_notification_data(verified_data)
+        elif payment_status in PAYMENT_STATUS_MAPPING['cancel']:
+            self._set_canceled()
+        elif payment_status in PAYMENT_STATUS_MAPPING['error']:
+            self._set_error(_(
+                "An error occurred during the processing of your payment (status %s). Please try "
+                "again.", payment_status
+            ))
+        else:
+            _logger.warning(
+                "Received data with invalid payment status (%s) for transaction with reference %s.",
+                payment_status, self.reference
+            )
+            self._set_error("Flutterwave: " + _("Unknown payment status: %s", payment_status))
+
+    def _flutterwave_tokenize_from_notification_data(self, notification_data):
+        """ Create a new token based on the notification data.
+
+        Note: self.ensure_one()
+
+        :param dict notification_data: The notification data sent by the provider.
+        :return: None
+        """
+        self.ensure_one()
+
+        token = self.env['payment.token'].create({
+            'acquirer_id': self.acquirer_id.id,
+            'name': payment_utils.build_token_name(notification_data['card']['last_4digits']),
+            'partner_id': self.partner_id.id,
+            'acquirer_ref': notification_data['card']['token'],
+            'flutterwave_customer_email': notification_data['customer']['email'],
+            'verified': True,  # The payment is confirmed, so the payment method is valid.
+        })
+        self.write({
+            'token_id': token,
+            'tokenize': False,
+        })
+        _logger.info(
+            "created token with id %(token_id)s for partner with id %(partner_id)s from "
+            "transaction with reference %(ref)s",
+            {
+                'token_id': token.id,
+                'partner_id': self.partner_id.id,
+                'ref': self.reference,
+            },
+        )
