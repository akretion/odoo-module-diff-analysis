PR: https://github.com/odoo/odoo/pull/93712

From: 1f4fb64a197729b709bba8524b6bc59892a2f099
From: Ahmed Khalaf (ahkh)
Date: 2023-01-13 15:26:57

Structural Changes: 2
Total Changes: 64

[IMP] mrp: MO component qty changes reflected in pickings

When changing quantities of raw moves after MO confirm,
procurement is run to fulfill updated need.

Since procurement creates new moves, some fixes were also done to allow
moves to be merged with older ones, including:
1) `date_planned_start` of merged MO included microsecond which
blocked merging new moves created by procurement with orig moves.
Removed microseconds.

2) `_set_date_deadline` did not allow a simple date update to moves with
orig or dest moves. Added context to hard set all moves in self to specific
deadline.

3) `_update_candidate_moves_list` when merging moves, did not return candidates
from pickings that were merged to same MO. Usually just mattered when decreasing
quantity. Added explicit check for sibling pickings in MO

closes odoo/odoo#93712

Task: 2859547
Signed-off-by: William Henrotin (whe) <whe@odoo.com>

================================= pseudo patch: =================================

--- a/addons/mrp/models/mrp_production.py
+++ b/addons/mrp/models/mrp_production.py
@@ -32,7 +32,7 @@ class MrpProduction(models.Model):
     def _get_default_date_planned_start(self):
         if self.env.context.get('default_date_deadline'):
             return fields.Datetime.to_datetime(self.env.context.get('default_date_deadline'))
-        return datetime.datetime.now()
+        return fields.Datetime.now()
 
     @api.model
     def _get_default_is_locked(self):
@@ -1074,27 +1074,13 @@ class MrpProduction(models.Model):
     def _update_raw_moves(self, factor):
         self.ensure_one()
         update_info = []
-        moves_to_assign = self.env['stock.move']
-        procurements = []
         for move in self.move_raw_ids.filtered(lambda m: m.state not in ('done', 'cancel')):
             old_qty = move.product_uom_qty
             new_qty = float_round(old_qty * factor, precision_rounding=move.product_uom.rounding, rounding_method='UP')
             if new_qty > 0:
+                # procurement and assigning is now run in write
                 move.write({'product_uom_qty': new_qty})
-                if move._should_bypass_reservation() \
-                        or move.picking_type_id.reservation_method == 'at_confirm' \
-                        or (move.reservation_date and move.reservation_date <= fields.Date.today()):
-                    moves_to_assign |= move
-                if move.procure_method == 'make_to_order':
-                    procurement_qty = new_qty - old_qty
-                    values = move._prepare_procurement_values()
-                    procurements.append(self.env['procurement.group'].Procurement(
-                        move.product_id, procurement_qty, move.product_uom,
-                        move.location_id, move.name, move.origin, move.company_id, values))
                 update_info.append((move, old_qty, new_qty))
-        moves_to_assign._action_assign()
-        if procurements:
-            self.env['procurement.group'].run(procurements)
         return update_info
 
     @api.ondelete(at_uninstall=False)
@@ -1614,7 +1600,7 @@ class MrpProduction(models.Model):
                 move_to_backorder_moves[move] = self.env['stock.move']
                 unit_factor = move.product_uom_qty / initial_qty_by_production[production]
                 initial_move_vals = move.copy_data(move._get_backorder_move_vals())[0]
-                move.with_context(do_not_unreserve=True).product_uom_qty = production.product_qty * unit_factor
+                move.with_context(do_not_unreserve=True, no_procurement=True).product_uom_qty = production.product_qty * unit_factor
 
                 for backorder in production_to_backorders[production]:
                     move_vals = dict(
@@ -2055,6 +2041,7 @@ class MrpProduction(models.Model):
         for move in production.move_raw_ids:
             for field, vals in origs[move.bom_line_id.id].items():
                 move[field] = vals
+
         for move in production.move_finished_ids:
             move.move_dest_ids = [Command.set(dests[move.byproduct_id.id])]
 
@@ -2069,6 +2056,8 @@ class MrpProduction(models.Model):
             production.state = 'confirmed'
 
         self.with_context(skip_activity=True)._action_cancel()
+        # set the new deadline of origin moves (stock to pre prod)
+        production.move_raw_ids.move_orig_ids.with_context(date_deadline_propagate_ids=set(production.move_raw_ids.ids)).write({'date_deadline': production.date_planned_start})
         for p in self:
             p._message_log(body=_('This production has been merge in %s', production.display_name))
 

--- a/addons/mrp/models/mrp_workorder.py
+++ b/addons/mrp/models/mrp_workorder.py
@@ -619,7 +619,7 @@ class MrpWorkorder(models.Model):
             })
         if self.state == 'progress':
             return True
-        start_date = datetime.now()
+        start_date = fields.Datetime.now()
         vals = {
             'state': 'progress',
             'date_start': start_date,

--- a/addons/mrp/models/stock_move.py
+++ b/addons/mrp/models/stock_move.py
@@ -304,8 +304,35 @@ class StockMove(models.Model):
             # so possibly unlink lines
             move_line_vals = vals.pop('move_line_ids')
             super().write({'move_line_ids': move_line_vals})
+        if 'product_uom_qty' in vals and self.raw_material_production_id.state == 'confirmed' and not self.env.context.get('no_procurement', False):
+            # when updating consumed qty need to update related pickings
+            # context no_procurement means we don't want the qty update to modify stock i.e create new pickings
+            # ex. when spliting MO to backorders we don't want to move qty from pre prod to stock in 2/3 step config
+            self._run_procurement(vals['product_uom_qty'], self.product_uom_qty)
         return super().write(vals)
 
+    def _run_procurement(self, new_qty, old_qty):
+        procurements = []
+        to_assign = self.env['stock.move']
+        self._adjust_procure_method()
+        for move in self:
+            if new_qty > 0:
+                if move._should_bypass_reservation() \
+                        or move.picking_type_id.reservation_method == 'at_confirm' \
+                        or (move.reservation_date and move.reservation_date <= fields.Date.today()):
+                    to_assign |= move
+
+            if move.procure_method == 'make_to_order':
+                procurement_qty = new_qty - old_qty
+                values = move._prepare_procurement_values()
+                procurements.append(self.env['procurement.group'].Procurement(
+                    move.product_id, procurement_qty, move.product_uom,
+                    move.location_id, move.name, move.origin, move.company_id, values))
+
+        to_assign._action_assign()
+        if procurements:
+            self.env['procurement.group'].run(procurements)
+
     def _action_assign(self, force_qty=False):
         res = super(StockMove, self)._action_assign(force_qty=force_qty)
         for move in self.filtered(lambda x: x.production_id or x.raw_material_production_id):
@@ -531,12 +558,16 @@ class StockMove(models.Model):
         else:
             self.quantity_done = new_qty
 
-    def _update_candidate_moves_list(self, candidate_moves_list):
-        super()._update_candidate_moves_list(candidate_moves_list)
+    def _update_candidate_moves_list(self, candidate_moves_set):
+        super()._update_candidate_moves_list(candidate_moves_set)
         for production in self.mapped('raw_material_production_id'):
-            candidate_moves_list.append(production.move_raw_ids)
+            candidate_moves_set.add(production.move_raw_ids)
         for production in self.mapped('production_id'):
-            candidate_moves_list.append(production.move_finished_ids)
+            candidate_moves_set.add(production.move_finished_ids)
+        # this will include sibling pickings as a result of merging MOs
+        for picking in self.move_dest_ids.raw_material_production_id.picking_ids:
+            candidate_moves_set.add(picking.move_ids)
+
 
     def _multi_line_quantity_done_set(self, quantity_done):
         if self.raw_material_production_id:
