PR: https://github.com/odoo/odoo/pull/

From: 58b5d09890107fa9396d2243be513675b4854427
From: Ravi Gohil
Date: 2016-06-30 12:41:22

Structural Changes: 83
Total Changes: 1036

[MIG] project: migration to new api of project.py

Also:
- removed onchange_partner_id() from 'project.project' model as
  'pricelist_id' field does not exist in project nor in any inherit(s)
  since its removal in 2008 by 07b1f0b9daac1d53aa25dcf26e7a3f7cce469520
- removed 'type' field from _defaults dictionary of 'project.project'
  model as it does not exists anymore, it used to be defined on
  account.analytic.account
- removed on_change_template() from 'account.analytic.account' model as
  it doesn't seem to be useful and/or called from any view
- overridden _default_get() for 'project.project' model to set default
  value for 'use_tasks' field of inherits account.analytic.account

================================= pseudo patch: =================================

--- a/addons/project/models/project.py
+++ b/addons/project/models/project.py
@@ -3,16 +3,12 @@
 
 from lxml import etree
 
-from openerp import api
-from openerp import SUPERUSER_ID
-from openerp import tools
-from openerp.osv import fields, osv
+from odoo import api, fields, models, tools, SUPERUSER_ID, _
 from openerp.tools.safe_eval import safe_eval as eval
-from openerp.tools.translate import _
-from openerp.exceptions import UserError
+from openerp.exceptions import UserError, ValidationError
 
 
-class project_task_type(osv.osv):
+class ProjectTaskType(models.Model):
     _name = 'project.task.type'
     _description = 'Task Stage'
     _order = 'sequence'
@@ -20,112 +16,95 @@ class project_task_type(osv.osv):
     def _get_mail_template_id_domain(self):
         return [('model', '=', 'project.task')]
 
-    _columns = {
-        'name': fields.char('Stage Name', required=True, translate=True),
-        'description': fields.text('Description', translate=True),
-        'sequence': fields.integer('Sequence'),
-        'project_ids': fields.many2many('project.project', 'project_task_type_rel', 'type_id', 'project_id', 'Projects'),
-        'legend_priority': fields.char(
-            'Priority Management Explanation', translate=True,
-            help='Explanation text to help users using the star and priority mechanism on stages or issues that are in this stage.'),
-        'legend_blocked': fields.char(
-            'Kanban Blocked Explanation', translate=True,
-            help='Override the default value displayed for the blocked state for kanban selection, when the task or issue is in that stage.'),
-        'legend_done': fields.char(
-            'Kanban Valid Explanation', translate=True,
-            help='Override the default value displayed for the done state for kanban selection, when the task or issue is in that stage.'),
-        'legend_normal': fields.char(
-            'Kanban Ongoing Explanation', translate=True,
-            help='Override the default value displayed for the normal state for kanban selection, when the task or issue is in that stage.'),
-        'mail_template_id': fields.many2one(
-            'mail.template',
-            string='Email Template',
-            domain=lambda self: self._get_mail_template_id_domain(),
-            help="If set an email will be sent to the customer when the task or issue reaches this step."),
-        'fold': fields.boolean('Folded in Tasks Pipeline',
-                               help='This stage is folded in the kanban view when '
-                               'there are no records in that stage to display.'),
-    }
-
-    def _get_default_project_ids(self, cr, uid, ctx=None):
-        if ctx is None:
-            ctx = {}
-        default_project_id = ctx.get('default_project_id')
+    def _get_default_project_ids(self):
+        default_project_id = self.env.context.get('default_project_id')
         return [default_project_id] if default_project_id else None
 
-    _defaults = {
-        'sequence': 1,
-        'project_ids': _get_default_project_ids,
-    }
-
-
-class project(osv.osv):
+    name = fields.Char(string='Stage Name', required=True, translate=True)
+    description = fields.Text(translate=True)
+    sequence = fields.Integer(default=1)
+    project_ids = fields.Many2many('project.project', 'project_task_type_rel', 'type_id', 'project_id', string='Projects',
+        default=_get_default_project_ids)
+    legend_priority = fields.Char(
+        string='Priority Management Explanation', translate=True,
+        help='Explanation text to help users using the star and priority mechanism on stages or issues that are in this stage.')
+    legend_blocked = fields.Char(
+        string='Kanban Blocked Explanation', translate=True,
+        help='Override the default value displayed for the blocked state for kanban selection, when the task or issue is in that stage.')
+    legend_done = fields.Char(
+        string='Kanban Valid Explanation', translate=True,
+        help='Override the default value displayed for the done state for kanban selection, when the task or issue is in that stage.')
+    legend_normal = fields.Char(
+        string='Kanban Ongoing Explanation', translate=True,
+        help='Override the default value displayed for the normal state for kanban selection, when the task or issue is in that stage.')
+    mail_template_id = fields.Many2one(
+        'mail.template',
+        string='Email Template',
+        domain=lambda self: self._get_mail_template_id_domain(),
+        help="If set an email will be sent to the customer when the task or issue reaches this step.")
+    fold = fields.Boolean(string='Folded in Tasks Pipeline',
+        help='This stage is folded in the kanban view when there are no records in that stage to display.')
+
+
+class Project(models.Model):
     _name = "project.project"
     _description = "Project"
     _inherit = ['mail.alias.mixin', 'mail.thread', 'ir.needaction_mixin']
     _inherits = {'account.analytic.account': "analytic_account_id"}
+    _order = "sequence, name, id"
     _period_number = 5
 
     def get_alias_model_name(self, vals):
         return vals.get('alias_model', 'project.task')
 
     def get_alias_values(self):
-        values = super(project, self).get_alias_values()
+        values = super(Project, self).get_alias_values()
         values['alias_defaults'] = {'project_id': self.id}
         return values
 
-    def onchange_partner_id(self, cr, uid, ids, part=False, context=None):
-        partner_obj = self.pool.get('res.partner')
-        val = {}
-        if not part:
-            return {'value': val}
-        if 'pricelist_id' in self.fields_get(cr, uid, context=context):
-            pricelist = partner_obj.read(cr, uid, part, ['property_product_pricelist'], context=context)
-            pricelist_id = pricelist.get('property_product_pricelist', False) and pricelist.get('property_product_pricelist')[0] or False
-            val['pricelist_id'] = pricelist_id
-        return {'value': val}
-
-    def unlink(self, cr, uid, ids, context=None):
-        analytic_account_to_delete = set()
-        for proj in self.browse(cr, uid, ids, context=context):
-            if proj.tasks:
+    @api.multi
+    def unlink(self):
+        analytic_accounts_to_delete = self.env['account.analytic.account']
+        for project in self:
+            if project.tasks:
                 raise UserError(_('You cannot delete a project containing tasks. You can either delete all the project\'s tasks and then delete the project or simply deactivate the project.'))
-            if proj.analytic_account_id and not proj.analytic_account_id.line_ids:
-                analytic_account_to_delete.add(proj.analytic_account_id.id)
-        res = super(project, self).unlink(cr, uid, ids, context=context)
-        self.pool['account.analytic.account'].unlink(cr, uid, list(analytic_account_to_delete), context=context)
-        return res
-
-    def _get_attached_docs(self, cr, uid, ids, field_name, arg, context):
-        res = {}
-        attachment = self.pool.get('ir.attachment')
-        task = self.pool.get('project.task')
-        for id in ids:
-            project_attachments = attachment.search(cr, uid, [('res_model', '=', 'project.project'), ('res_id', '=', id)], context=context, count=True)
-            task_ids = task.search(cr, uid, [('project_id', '=', id)], context=context)
-            task_attachments = attachment.search(cr, uid, [('res_model', '=', 'project.task'), ('res_id', 'in', task_ids)], context=context, count=True)
-            res[id] = (project_attachments or 0) + (task_attachments or 0)
-        return res
-    def _task_count(self, cr, uid, ids, field_name, arg, context=None):
-        if context is None:
-            context = {}
-        res={}
-        for project in self.browse(cr, uid, ids, context=context):
-            res[project.id] = len(project.task_ids)
-        return res
-
-    def _task_needaction_count(self, cr, uid, ids, field_name, arg, context=None):
-        Task = self.pool['project.task']
-        res = dict.fromkeys(ids, 0)
-        projects = Task.read_group(cr, uid, [('project_id', 'in', ids), ('message_needaction', '=', True)], ['project_id'], ['project_id'], context=context)
-        res.update({project['project_id'][0]: int(project['project_id_count']) for project in projects})
+            if project.analytic_account_id and not project.analytic_account_id.line_ids:
+                analytic_accounts_to_delete |= project.analytic_account_id
+        res = super(Project, self).unlink()
+        analytic_accounts_to_delete.unlink()
         return res
 
-    def _get_alias_models(self, cr, uid, context=None):
+    def _compute_attached_docs_count(self):
+        Attachment = self.env['ir.attachment']
+        for project in self:
+            project.doc_count = Attachment.search_count([
+                '|',
+                '&',
+                ('res_model', '=', 'project.project'), ('res_id', '=', project.id),
+                '&',
+                ('res_model', '=', 'project.task'), ('res_id', 'in', project.task_ids.ids)
+            ])
+
+    def _compute_task_count(self):
+        for project in self:
+            project.task_count = len(project.task_ids)
+
+    def _compute_task_needaction_count(self):
+        projects_data = self.env['project.task'].read_group([
+            ('project_id', 'in', self.ids),
+            ('message_needaction', '=', True)
+        ], ['project_id'], ['project_id'])
+        mapped_data = {project_data['project_id'][0]: int(project_data['project_id_count'])
+                       for project_data in projects_data}
+        for project in self:
+            project.task_needaction_count = mapped_data.get(project.id, 0)
+
+    @api.model
+    def _get_alias_models(self):
         """ Overriden in project_issue to offer more options """
         return [('project.task', "Tasks")]
 
-    def _get_visibility_selection(self, cr, uid, context=None):
+    def _get_visibility_selection(self):
         """ Overriden in portal_project to offer more options """
         return [
             ('employees', _('Visible by all employees')),
@@ -133,13 +112,13 @@ class project(osv.osv):
             ('portal', _('Shared with a customer'))
         ]
 
-    def attachment_tree_view(self, cr, uid, ids, context):
-        task_ids = self.pool.get('project.task').search(cr, uid, [('project_id', 'in', ids)])
+    @api.multi
+    def attachment_tree_view(self):
+        self.ensure_one()
         domain = [
-             '|',
-             '&', ('res_model', '=', 'project.project'), ('res_id', 'in', ids),
-             '&', ('res_model', '=', 'project.task'), ('res_id', 'in', task_ids)]
-        res_id = ids and ids[0] or False
+            '|',
+            '&', ('res_model', '=', 'project.project'), ('res_id', 'in', self.ids),
+            '&', ('res_model', '=', 'project.task'), ('res_id', 'in', self.task_ids.ids)]
         return {
             'name': _('Attachments'),
             'domain': domain,
@@ -154,338 +133,306 @@ class project(osv.osv):
                         documents to your project.
                     </p>'''),
             'limit': 80,
-            'context': "{'default_res_model': '%s','default_res_id': %d}" % (self._name, res_id)
+            'context': "{'default_res_model': '%s','default_res_id': %d}" % (self._name, self.id)
         }
 
-    def activate_sample_project(self, cr, uid, context=None):
+    @api.model
+    def activate_sample_project(self):
         """ Unarchives the sample project 'project.project_project_data' and
             reloads the project dashboard """
         # Unarchive sample project
-        data_obj = self.pool.get('ir.model.data')
-        proj_id = data_obj.xmlid_to_res_id(cr, uid, 'project.project_project_data')
-        if proj_id:
-            self.browse(cr, uid, proj_id, context=context).write({'active': True})
+        project = self.env.ref('project.project_project_data', False)
+        if project:
+            project.write({'active': True})
 
         # Change the help message on the action (no more activate project)
-        act_id = data_obj.xmlid_to_res_id(cr, uid, 'project.open_view_project_all')
-        action = None
-        if act_id:
-            act_window_obj =  self.pool.get('ir.actions.act_window')
-            act_window_obj.write(cr, SUPERUSER_ID, [act_id], {
+        action = self.env.ref('project.open_view_project_all', False)
+        action_data = None
+        if action:
+            action.sudo().write({
                 "help": _('''<p class="oe_view_nocontent_create">Click to create a new project.</p>''')
-            }, context=context)
-            action = act_window_obj.read(cr, uid, [act_id])[0]
+            })
+            action_data = action.read()[0]
         # Reload the dashboard
-        return action
+        return action_data
 
-    def _get_favorite(self, cr, uid, ids, name, args, context=None):
-        return dict((project.id, uid in project.favorite_user_ids.ids) for project in self.browse(cr, uid, ids, context=context))
+    def _compute_is_favorite(self):
+        for project in self:
+            project.is_favorite = self.env.user in project.favorite_user_ids
 
-    def _get_default_favorite_user_ids(self, cr, uid, context=None):
-        return [(6, 0, [uid])]
+    def _get_default_favorite_user_ids(self):
+        return [(6, 0, [self.env.uid])]
 
-    # Lambda indirection method to avoid passing a copy of the overridable method when declaring the field
-    _alias_models = lambda self, *args, **kwargs: self._get_alias_models(*args, **kwargs)
-    _visibility_selection = lambda self, *args, **kwargs: self._get_visibility_selection(*args, **kwargs)
-
-    _columns = {
-        'active': fields.boolean('Active', help="If the active field is set to False, it will allow you to hide the project without removing it."),
-        'sequence': fields.integer('Sequence', help="Gives the sequence order when displaying a list of Projects."),
-        'analytic_account_id': fields.many2one(
-            'account.analytic.account', 'Contract/Analytic',
-            help="Link this project to an analytic account if you need financial management on projects. "
-                 "It enables you to connect projects with budgets, planning, cost and revenue analysis, timesheets on projects, etc.",
-            ondelete="cascade", required=True, auto_join=True),
-        'favorite_user_ids': fields.many2many(
-            'res.users', 'project_favorite_user_rel', 'project_id', 'user_id',
-            string='Members'),
-        'is_favorite': fields.function(_get_favorite, type="boolean", string='Show Project on dashboard',
-            help="Whether this project should be displayed on the dashboard or not"),
-        'label_tasks': fields.char('Use Tasks as', help="Gives label to tasks on project's kanban view."),
-        'tasks': fields.one2many('project.task', 'project_id', "Task Activities"),
-        'resource_calendar_id': fields.many2one('resource.calendar', 'Working Time', help="Timetable working hours to adjust the gantt diagram report"),
-        'type_ids': fields.many2many('project.task.type', 'project_task_type_rel', 'project_id', 'type_id', 'Tasks Stages'),
-        'task_count': fields.function(_task_count, type='integer', string="Tasks",),
-        'task_needaction_count': fields.function(_task_needaction_count, type='integer', string="Tasks",),
-        'task_ids': fields.one2many('project.task', 'project_id', string='Tasks',
-                                    domain=['|', ('stage_id.fold', '=', False), ('stage_id', '=', False)]),
-        'color': fields.integer('Color Index'),
-        'user_id': fields.many2one('res.users', 'Project Manager'),
-        'alias_id': fields.many2one('mail.alias', 'Alias', ondelete="restrict", required=True,
-                                    help="Internal email associated with this project. Incoming emails are automatically synchronized "
-                                         "with Tasks (or optionally Issues if the Issue Tracker module is installed)."),
-        'alias_model': fields.selection(_alias_models, "Alias Model", select=True, required=True,
-                                        help="The kind of document created when an email is received on this project's email alias"),
-        'privacy_visibility': fields.selection(_visibility_selection, 'Privacy', required=True,
-            help="Holds visibility of the tasks or issues that belong to the current project:\n"
-                    "- Portal : employees see everything;\n"
-                    "   if portal is activated, portal users see the tasks or issues followed by\n"
-                    "   them or by someone of their company\n"
-                    "- Employees Only: employees see all tasks or issues\n"
-                    "- Followers Only: employees see only the followed tasks or issues; if portal\n"
-                    "   is activated, portal users see the followed tasks or issues."),
-        'doc_count': fields.function(
-            _get_attached_docs, string="Number of documents attached", type='integer'
-        ),
-        'date_start': fields.date('Start Date'),
-        'date': fields.date('Expiration Date', select=True, track_visibility='onchange'),
-     }
+    @api.model
+    def default_get(self, flds):
+        result = super(Project, self).default_get(flds)
+        result['use_tasks'] = True
+        return result
 
-    _order = "sequence, name, id"
-    _defaults = {
-        'active': True,
-        'favorite_user_ids': _get_default_favorite_user_ids,
-        'type': 'contract',
-        'label_tasks': 'Tasks',
-        'sequence': 10,
-        'user_id': lambda self,cr,uid,ctx: uid,
-        'alias_model': 'project.task',
-        'privacy_visibility': 'employees',
-    }
+    # Lambda indirection method to avoid passing a copy of the overridable method when declaring the field
+    _alias_models = lambda self: self._get_alias_models()
+    _visibility_selection = lambda self: self._get_visibility_selection()
+
+    active = fields.Boolean(default=True,
+        help="If the active field is set to False, it will allow you to hide the project without removing it.")
+    sequence = fields.Integer(default=10, help="Gives the sequence order when displaying a list of Projects.")
+    analytic_account_id = fields.Many2one(
+        'account.analytic.account', string='Contract/Analytic',
+        help="Link this project to an analytic account if you need financial management on projects. "
+             "It enables you to connect projects with budgets, planning, cost and revenue analysis, timesheets on projects, etc.",
+        ondelete="cascade", required=True, auto_join=True)
+    favorite_user_ids = fields.Many2many(
+        'res.users', 'project_favorite_user_rel', 'project_id', 'user_id',
+        default=_get_default_favorite_user_ids,
+        string='Members')
+    is_favorite = fields.Boolean(compute='_compute_is_favorite', string='Show Project on dashboard',
+        help="Whether this project should be displayed on the dashboard or not")
+    label_tasks = fields.Char(string='Use Tasks as', default='Tasks', help="Gives label to tasks on project's kanban view.")
+    tasks = fields.One2many('project.task', 'project_id', string="Task Activities")
+    resource_calendar_id = fields.Many2one('resource.calendar', string='Working Time',
+        help="Timetable working hours to adjust the gantt diagram report")
+    type_ids = fields.Many2many('project.task.type', 'project_task_type_rel', 'project_id', 'type_id', string='Tasks Stages')
+    task_count = fields.Integer(compute='_compute_task_count', string="Tasks")
+    task_needaction_count = fields.Integer(compute='_compute_task_needaction_count', string="Tasks")
+    task_ids = fields.One2many('project.task', 'project_id', string='Tasks',
+                               domain=['|', ('stage_id.fold', '=', False), ('stage_id', '=', False)])
+    color = fields.Integer(string='Color Index')
+    user_id = fields.Many2one('res.users', string='Project Manager', default=lambda self: self.env.user)
+    alias_id = fields.Many2one('mail.alias', string='Alias', ondelete="restrict", required=True,
+        help="Internal email associated with this project. Incoming emails are automatically synchronized "
+             "with Tasks (or optionally Issues if the Issue Tracker module is installed).")
+    alias_model = fields.Selection(_alias_models, string="Alias Model", index=True, required=True, default='project.task',
+        help="The kind of document created when an email is received on this project's email alias")
+    privacy_visibility = fields.Selection(_visibility_selection, string='Privacy', required=True,
+        default='employees',
+        help="Holds visibility of the tasks or issues that belong to the current project:\n"
+                "- Portal : employees see everything;\n"
+                "   if portal is activated, portal users see the tasks or issues followed by\n"
+                "   them or by someone of their company\n"
+                "- Employees Only: employees see all tasks or issues\n"
+                "- Followers Only: employees see only the followed tasks or issues; if portal\n"
+                "   is activated, portal users see the followed tasks or issues.")
+    doc_count = fields.Integer(compute='_compute_attached_docs_count', string="Number of documents attached")
+    date_start = fields.Date(string='Start Date')
+    date = fields.Date(string='Expiration Date', index=True, track_visibility='onchange')
 
     # TODO: Why not using a SQL contraints ?
-    def _check_dates(self, cr, uid, ids, context=None):
-        for leave in self.read(cr, uid, ids, ['date_start', 'date'], context=context):
-            if leave['date_start'] and leave['date']:
-                if leave['date_start'] > leave['date']:
-                    return False
-        return True
+    @api.constrains('date_start', 'date')
+    def _check_dates(self):
+        if any(self.filtered(lambda project: project.date_start and project.date and project.date_start > project.date)):
+            raise ValidationError(_('Error! project start-date must be lower than project end-date.'))
 
-    _constraints = [
-        (_check_dates, 'Error! project start-date must be lower than project end-date.', ['date_start', 'date'])
-    ]
-
-    def map_tasks(self, cr, uid, old_project_id, new_project_id, context=None):
+    @api.multi
+    def map_tasks(self, new_project_id):
         """ copy and map tasks from old to new project """
-        if context is None:
-            context = {}
-        map_task_id = {}
-        task_obj = self.pool.get('project.task')
-        proj = self.browse(cr, uid, old_project_id, context=context)
-        for task in proj.tasks:
+        tasks = self.env['project.task']
+        for task in self.tasks:
             # preserve task name and stage, normally altered during copy
             defaults = {'stage_id': task.stage_id.id,
                         'name': task.name}
-            map_task_id[task.id] =  task_obj.copy(cr, uid, task.id, defaults, context=context)
-        self.write(cr, uid, [new_project_id], {'tasks':[(6,0, map_task_id.values())]})
-        return True
+            tasks += task.copy(defaults)
+        return self.browse(new_project_id).write({'tasks': [(6, 0, tasks.ids)]})
 
-    def copy(self, cr, uid, id, default=None, context=None):
+    @api.multi
+    def copy(self, default=None):
         if default is None:
             default = {}
-        context = dict(context or {})
-        context['active_test'] = False
-        proj = self.browse(cr, uid, id, context=context)
+        self = self.with_context(active_test=False)
         if not default.get('name'):
-            default.update(name=_("%s (copy)") % (proj.name))
-        res = super(project, self).copy(cr, uid, id, default, context)
-        for follower in proj.message_follower_ids:
-            self.message_subscribe(cr, uid, res, partner_ids=[follower.partner_id.id], subtype_ids=[subtype.id for subtype in follower.subtype_ids])
-        self.map_tasks(cr, uid, id, res, context=context)
-        return res
-
-    def create(self, cr, uid, vals, context=None):
-        ir_values = self.pool.get('ir.values').get_default(cr, uid, 'project.config.settings', 'generate_project_alias')
+            default['name'] = _("%s (copy)") % (self.name)
+        project = super(Project, self).copy(default)
+        for follower in self.message_follower_ids:
+            project.message_subscribe(partner_ids=follower.partner_id.ids, subtype_ids=follower.subtype_ids.ids)
+        self.map_tasks(project.id)
+        return project
+
+    @api.model
+    def create(self, vals):
+        ir_values = self.env['ir.values'].get_default('project.config.settings', 'generate_project_alias')
         if ir_values:
             vals['alias_name'] = vals.get('alias_name') or vals.get('name')
         # Prevent double project creation when 'use_tasks' is checked
-        create_context = dict(context or {},
-                              project_creation_in_progress=True,
-                              mail_create_nosubscribe=True)
-        return super(project, self).create(cr, uid, vals, context=create_context)
+        self = self.with_context(project_creation_in_progress=True, mail_create_nosubscribe=True)
+        return super(Project, self).create(vals)
 
-    def write(self, cr, uid, ids, vals, context=None):
+    @api.multi
+    def write(self, vals):
         # if alias_model has been changed, update alias_model_id accordingly
         if vals.get('alias_model'):
-            model_ids = self.pool.get('ir.model').search(cr, uid, [('model', '=', vals.get('alias_model', 'project.task'))])
-            vals.update(alias_model_id=model_ids[0])
-        res = super(project, self).write(cr, uid, ids, vals, context=context)
+            vals['alias_model_id'] = self.env['ir.model'].search([
+                ('model', '=', vals.get('alias_model', 'project.task'))
+            ], limit=1).id
+        res = super(Project, self).write(vals)
         if 'active' in vals:
             # archiving/unarchiving a project does it on its tasks, too
-            projects = self.browse(cr, uid, ids, context)
-            tasks = projects.with_context(active_test=False).mapped('tasks')
-            tasks.write({'active': vals['active']})
+            self.with_context(active_test=False).mapped('tasks').write({'active': vals['active']})
         return res
 
-    def toggle_favorite(self, cr, uid, ids, context=None):
-        favorite_project_ids = []
-        not_fav_project_ids = []
-        for project in self.browse(cr, uid, ids, context=context):
-            if uid in project.favorite_user_ids.ids:
-                favorite_project_ids.append(project.id)
+    @api.multi
+    def toggle_favorite(self):
+        favorite_projects = not_fav_projects = self.env['project.project'].sudo()
+        for project in self:
+            if self.env.user in project.favorite_user_ids:
+                favorite_projects |= project
             else:
-                not_fav_project_ids.append(project.id)
+                not_fav_projects |= project
 
         # Project User has no write access for project.
-        self.write(cr, SUPERUSER_ID, not_fav_project_ids, {'favorite_user_ids': [(4, uid)]}, context=context)
-        self.write(cr, SUPERUSER_ID, favorite_project_ids, {'favorite_user_ids': [(3, uid)]}, context=context)
+        not_fav_projects.write({'favorite_user_ids': [(4, self.env.uid)]})
+        favorite_projects.write({'favorite_user_ids': [(3, self.env.uid)]})
 
     @api.multi
     def close_dialog(self):
         return {'type': 'ir.actions.act_window_close'}
 
-class task(osv.osv):
+
+class Task(models.Model):
     _name = "project.task"
     _description = "Task"
     _date_name = "date_start"
     _inherit = ['mail.thread', 'ir.needaction_mixin']
     _mail_post_access = 'read'
+    _order = "priority desc, sequence, date_start, name, id"
 
-    def _get_default_partner(self, cr, uid, context=None):
-        if context is None:
-            context = {}
-        if 'default_project_id' in context:
-            project = self.pool.get('project.project').browse(cr, uid, context['default_project_id'], context=context)
-            if project and project.partner_id:
-                return project.partner_id.id
-        return False
+    def _get_default_partner(self):
+        if 'default_project_id' in self.env.context:
+            default_project_id = self.env['project.project'].browse(self.env.context['default_project_id'])
+            return default_project_id.exists().partner_id
 
-    def _get_default_stage_id(self, cr, uid, context=None):
+    def _get_default_stage_id(self):
         """ Gives default stage_id """
-        if context is None:
-            context = {}
-        return self.stage_find(cr, uid, [], context.get('default_project_id'), [('fold', '=', False)], context=context)
-
-    def _read_group_stage_ids(self, cr, uid, ids, domain, read_group_order=None, access_rights_uid=None, context=None):
-        if context is None:
-            context = {}
-        stage_obj = self.pool.get('project.task.type')
-        order = stage_obj._order
-        access_rights_uid = access_rights_uid or uid
+        return self.stage_find(self.env.context.get('default_project_id'), [('fold', '=', False)])
+
+    @api.multi
+    def _read_group_stage_ids(self, domain, read_group_order=None, access_rights_uid=None):
+        TaskType = self.env['project.task.type']
+        order = TaskType._order
+        access_rights_uid = access_rights_uid or self.env.uid
         if read_group_order == 'stage_id desc':
             order = '%s desc' % order
-        if 'default_project_id' in context:
-            search_domain = ['|', ('project_ids', '=', context['default_project_id']), ('id', 'in', ids)]
+        if 'default_project_id' in self.env.context:
+            search_domain = ['|', ('project_ids', '=', self.env.context['default_project_id']), ('id', 'in', self.ids)]
         else:
-            search_domain = [('id', 'in', ids)]
-        stage_ids = stage_obj._search(cr, uid, search_domain, order=order, access_rights_uid=access_rights_uid, context=context)
-        result = stage_obj.name_get(cr, access_rights_uid, stage_ids, context=context)
+            search_domain = [('id', 'in', self.ids)]
+        stage_ids = TaskType._search(search_domain, order=order, access_rights_uid=access_rights_uid)
+        stages = TaskType.sudo(access_rights_uid).browse(stage_ids)
+        result = stages.name_get()
         # restore order of the search
         result.sort(lambda x, y: cmp(stage_ids.index(x[0]), stage_ids.index(y[0])))
 
-        fold = {}
-        for stage in stage_obj.browse(cr, access_rights_uid, stage_ids, context=context):
-            fold[stage.id] = stage.fold or False
-        return result, fold
+        return result, {stage.id: stage.fold for stage in stages}
 
     _group_by_full = {
         'stage_id': _read_group_stage_ids,
     }
 
-    def onchange_project(self, cr, uid, id, project_id, context=None):
-        if project_id:
-            project = self.pool.get('project.project').browse(cr, uid, project_id, context=context)
-            if project and project.partner_id:
-                return {'value': {'partner_id': project.partner_id.id}}
-        return {}
+    active = fields.Boolean(default=True)
+    name = fields.Char(string='Task Title', track_visibility='onchange', required=True, index=True)
+    description = fields.Html(string='Description')
+    priority = fields.Selection([
+            ('0','Normal'),
+            ('1','High')
+        ], default='0', index=True)
+    sequence = fields.Integer(string='Sequence', index=True, default=10,
+        help="Gives the sequence order when displaying a list of tasks.")
+    stage_id = fields.Many2one('project.task.type', string='Stage', track_visibility='onchange', index=True,
+        default=_get_default_stage_id,
+        domain="[('project_ids', '=', project_id)]", copy=False)
+    tag_ids = fields.Many2many('project.tags', string='Tags', oldname='categ_ids')
+    kanban_state = fields.Selection([
+            ('normal', 'In Progress'),
+            ('done', 'Ready for next stage'),
+            ('blocked', 'Blocked')
+        ], string='Kanban State',
+        default='normal',
+        track_visibility='onchange',
+        required=True, copy=False,
+        help="A task's kanban state indicates special situations affecting it:\n"
+             " * Normal is the default situation\n"
+             " * Blocked indicates something is preventing the progress of this task\n"
+             " * Ready for next stage indicates the task is ready to be pulled to the next stage")
+    create_date = fields.Datetime(index=True)
+    write_date = fields.Datetime(index=True)  #not displayed in the view but it might be useful with base_action_rule module (and it needs to be defined first for that)
+    date_start = fields.Datetime(string='Starting Date',
+    default=fields.Datetime.now,
+    index=True, copy=False)
+    date_end = fields.Datetime(string='Ending Date', index=True, copy=False)
+    date_assign = fields.Datetime(string='Assigning Date', index=True, copy=False, readonly=True)
+    date_deadline = fields.Date(string='Deadline', index=True, copy=False)
+    date_last_stage_update = fields.Datetime(string='Last Stage Update',
+        default=fields.Datetime.now,
+        index=True,
+        copy=False,
+        readonly=True)
+    project_id = fields.Many2one('project.project',
+        string='Project',
+        default=lambda self: self.env.context.get('default_project_id'),
+        index=True,
+        track_visibility='onchange',
+        change_default=True)
+    notes = fields.Text(string='Notes')
+    planned_hours = fields.Float(string='Initially Planned Hours', help='Estimated time to do the task, usually set by the project manager when the task is in draft state.')
+    remaining_hours = fields.Float(string='Remaining Hours', digits=(16,2), help="Total remaining time, can be re-estimated periodically by the assignee of the task.")
+    user_id = fields.Many2one('res.users',
+        string='Assigned to',
+        default=lambda self: self.env.uid,
+        index=True, track_visibility='onchange')
+    partner_id = fields.Many2one('res.partner',
+        string='Customer',
+        default=_get_default_partner)
+    manager_id = fields.Many2one('res.users', string='Project Manager', related='project_id.user_id')
+    company_id = fields.Many2one('res.company',
+        string='Company',
+        default=lambda self: self.env['res.company']._company_default_get())
+    color = fields.Integer(string='Color Index')
+    user_email = fields.Char(related='user_id.email', string='User Email', readonly=True)
+    attachment_ids = fields.One2many('ir.attachment', 'res_id', domain=lambda self: [('res_model', '=', self._name)], auto_join=True, string='Attachments')
+    # In the domain of displayed_image_id, we couln't use attachment_ids because a one2many is represented as a list of commands so we used res_model & res_id
+    displayed_image_id = fields.Many2one('ir.attachment', domain="[('res_model', '=', 'project.task'), ('res_id', '=', id), ('mimetype', 'ilike', 'image')]", string='Displayed Image')
+    legend_blocked = fields.Char(related='stage_id.legend_blocked', string='Kanban Blocked Explanation')
+    legend_done = fields.Char(related='stage_id.legend_done', string='Kanban Valid Explanation')
+    legend_normal = fields.Char(related='stage_id.legend_normal', string='Kanban Ongoing Explanation')
+
+    @api.onchange('project_id')
+    def _onchange_project(self):
+        if self.project_id:
+            self.partner_id = self.project_id.partner_id
+
+    @api.onchange('user_id')
+    def _onchange_user(self):
+        if self.user_id:
+            self.date_start = fields.Datetime.now()
 
-    def onchange_user_id(self, cr, uid, ids, user_id, context=None):
-        vals = {}
-        if user_id:
-            vals['date_start'] = fields.datetime.now()
-        return {'value': vals}
-
-    def copy_data(self, cr, uid, id, default=None, context=None):
+    @api.multi
+    def copy(self, default=None):
         if default is None:
             default = {}
-        current = self.browse(cr, uid, id, context=context)
         if not default.get('name'):
-            default['name'] = _("%s (copy)") % current.name
+            default['name'] = _("%s (copy)") % self.name
         if 'remaining_hours' not in default:
-            default['remaining_hours'] = current.planned_hours
-
-        return super(task, self).copy_data(cr, uid, id, default, context)
-
-    _columns = {
-        'active': fields.boolean('Active'),
-        'name': fields.char('Task Title', track_visibility='onchange', size=128, required=True, select=True),
-        'description': fields.html('Description'),
-        'priority': fields.selection([('0','Normal'), ('1','High')], 'Priority', select=True),
-        'sequence': fields.integer('Sequence', select=True, help="Gives the sequence order when displaying a list of tasks."),
-        'stage_id': fields.many2one('project.task.type', 'Stage', track_visibility='onchange', select=True,
-                        domain="[('project_ids', '=', project_id)]", copy=False),
-        'tag_ids': fields.many2many('project.tags', string='Tags', oldname='categ_ids'),
-        'kanban_state': fields.selection([('normal', 'In Progress'),('done', 'Ready for next stage'),('blocked', 'Blocked')], 'Kanban State',
-                                         track_visibility='onchange',
-                                         help="A task's kanban state indicates special situations affecting it:\n"
-                                              " * Normal is the default situation\n"
-                                              " * Blocked indicates something is preventing the progress of this task\n"
-                                              " * Ready for next stage indicates the task is ready to be pulled to the next stage",
-                                         required=True, copy=False),
-        'create_date': fields.datetime('Create Date', readonly=True, select=True),
-        'write_date': fields.datetime('Last Modification Date', readonly=True, select=True), #not displayed in the view but it might be useful with base_action_rule module (and it needs to be defined first for that)
-        'date_start': fields.datetime('Starting Date', select=True, copy=False),
-        'date_end': fields.datetime('Ending Date', select=True, copy=False),
-        'date_assign': fields.datetime('Assigning Date', select=True, copy=False, readonly=True),
-        'date_deadline': fields.date('Deadline', select=True, copy=False),
-        'date_last_stage_update': fields.datetime('Last Stage Update', select=True, copy=False, readonly=True),
-        'project_id': fields.many2one('project.project', 'Project', ondelete='set null', select=True, track_visibility='onchange', change_default=True),
-        'notes': fields.text('Notes'),
-        'planned_hours': fields.float('Initially Planned Hours', help='Estimated time to do the task, usually set by the project manager when the task is in draft state.'),
-        'remaining_hours': fields.float('Remaining Hours', digits=(16,2), help="Total remaining time, can be re-estimated periodically by the assignee of the task."),
-        'user_id': fields.many2one('res.users', 'Assigned to', select=True, track_visibility='onchange'),
-        'partner_id': fields.many2one('res.partner', 'Customer'),
-        'manager_id': fields.related('project_id', 'user_id', type='many2one', relation='res.users', string='Project Manager'),
-        'company_id': fields.many2one('res.company', 'Company'),
-        'id': fields.integer('ID', readonly=True),
-        'color': fields.integer('Color Index'),
-        'user_email': fields.related('user_id', 'email', type='char', string='User Email', readonly=True),
-        'attachment_ids': fields.one2many('ir.attachment', 'res_id', domain=lambda self: [('res_model', '=', self._name)], auto_join=True, string='Attachments'),
-        # In the domain of displayed_image_id, we couln't use attachment_ids because a one2many is represented as a list of commands so we used res_model & res_id
-        'displayed_image_id': fields.many2one('ir.attachment', domain="[('res_model', '=', 'project.task'), ('res_id', '=', id), ('mimetype', 'ilike', 'image')]", string='Displayed Image'),
-        'legend_blocked': fields.related("stage_id", "legend_blocked", type="char", string='Kanban Blocked Explanation'),
-        'legend_done': fields.related("stage_id", "legend_done", type="char", string='Kanban Valid Explanation'),
-        'legend_normal': fields.related("stage_id", "legend_normal", type="char", string='Kanban Ongoing Explanation'),
-        }
-    _defaults = {
-        'stage_id': _get_default_stage_id,
-        'project_id': lambda self, cr, uid, ctx=None: ctx.get('default_project_id') if ctx is not None else False,
-        'date_last_stage_update': fields.datetime.now,
-        'kanban_state': 'normal',
-        'priority': '0',
-        'sequence': 10,
-        'active': True,
-        'user_id': lambda obj, cr, uid, ctx=None: uid,
-        'company_id': lambda self, cr, uid, ctx=None: self.pool.get('res.company')._company_default_get(cr, uid, 'project.task', context=ctx),
-        'partner_id': lambda self, cr, uid, ctx=None: self._get_default_partner(cr, uid, context=ctx),
-        'date_start': fields.datetime.now,
-    }
-    _order = "priority desc, sequence, date_start, name, id"
+            default['remaining_hours'] = self.planned_hours
+        return super(Task, self).copy(default)
 
-    def _check_dates(self, cr, uid, ids, context=None):
-        if context == None:
-            context = {}
-        obj_task = self.browse(cr, uid, ids[0], context=context)
-        start = obj_task.date_start or False
-        end = obj_task.date_end or False
-        if start and end :
-            if start > end:
-                return False
-        return True
-
-    _constraints = [
-        (_check_dates, 'Error ! Task starting date must be lower than its ending date.', ['date_start','date_end'])
-    ]
+    @api.constrains('date_start', 'date_end')
+    def _check_dates(self):
+        if any(self.filtered(lambda task: task.date_start and task.date_end and task.date_start > task.date_end)):
+            return ValidationError(_('Error ! Task starting date must be lower than its ending date.'))
 
     # Override view according to the company definition
-    def fields_view_get(self, cr, uid, view_id=None, view_type='form', context=None, toolbar=False, submenu=False):
-        users_obj = self.pool.get('res.users')
-        if context is None: context = {}
+    @api.model
+    def fields_view_get(self, view_id=None, view_type='form', toolbar=False, submenu=False):
         # read uom as admin to avoid access rights issues, e.g. for portal/share users,
         # this should be safe (no context passed to avoid side-effects)
-        obj_tm = users_obj.browse(cr, SUPERUSER_ID, uid, context=context).company_id.project_time_mode_id
+        obj_tm = self.env.user.company_id.project_time_mode_id
         tm = obj_tm and obj_tm.name or 'Hours'
 
-        res = super(task, self).fields_view_get(cr, uid, view_id=view_id, view_type=view_type, context=context, toolbar=toolbar, submenu=submenu)
+        res = super(Task, self).fields_view_get(view_id=view_id, view_type=view_type, toolbar=toolbar, submenu=submenu)
 
         # read uom as admin to avoid access rights issues, e.g. for portal/share users,
         # this should be safe (no context passed to avoid side-effects)
-        obj_tm = users_obj.browse(cr, SUPERUSER_ID, uid, context=context).company_id.project_time_mode_id
-        try:
-            # using get_object to get translation value
-            uom_hour = self.pool['ir.model.data'].get_object(cr, uid, 'product', 'product_uom_hour', context=context)
-        except ValueError:
-            uom_hour = False
+        obj_tm = self.env.user.company_id.project_time_mode_id
+        # using get_object to get translation value
+        uom_hour = self.env.ref('product.product_uom_hour', False)
         if not obj_tm or not uom_hour or obj_tm.id == uom_hour.id:
             return res
 
@@ -493,8 +440,8 @@ class task(osv.osv):
 
         # if the project_time_mode_id is not in hours (so in days), display it as a float field
         def _check_rec(eview):
-            if eview.attrib.get('widget','') == 'float_time':
-                eview.set('widget','float')
+            if eview.attrib.get('widget', '') == 'float_time':
+                eview.set('widget', 'float')
             for child in eview:
                 _check_rec(child)
             return True
@@ -512,33 +459,31 @@ class task(osv.osv):
                 res['fields'][f]['string'] = res['fields'][f]['string'].replace('Hours', obj_tm.name)
         return res
 
-    def get_empty_list_help(self, cr, uid, help, context=None):
-        context = dict(context or {})
-        context['empty_list_help_id'] = context.get('default_project_id')
-        context['empty_list_help_model'] = 'project.project'
-        context['empty_list_help_document_name'] = _("tasks")
-        return super(task, self).get_empty_list_help(cr, uid, help, context=context)
+    @api.model
+    def get_empty_list_help(self, help):
+        self = self.with_context(
+            empty_list_help_id=self.env.context.get('default_project_id'),
+            empty_list_help_model='project.project',
+            empty_list_help_document_name=_("tasks")
+        )
+        return super(Task, self).get_empty_list_help(help)
 
     # ----------------------------------------
     # Case management
     # ----------------------------------------
 
-    def stage_find(self, cr, uid, cases, section_id, domain=[], order='sequence', context=None):
+    def stage_find(self, section_id, domain=[], order='sequence'):
         """ Override of the base.stage method
             Parameter of the stage search taken from the lead:
             - section_id: if set, stages must belong to this section or
               be a default stage; if not set, stages must be default
               stages
         """
-        if isinstance(cases, (int, long)):
-            cases = self.browse(cr, uid, cases, context=context)
         # collect all section_ids
         section_ids = []
         if section_id:
             section_ids.append(section_id)
-        for task in cases:
-            if task.project_id:
-                section_ids.append(task.project_id.id)
+        section_ids.extend(self.mapped('project_id').ids)
         search_domain = []
         if section_ids:
             search_domain = [('|')] * (len(section_ids) - 1)
@@ -546,14 +491,11 @@ class task(osv.osv):
                 search_domain.append(('project_ids', '=', section_id))
         search_domain += list(domain)
         # perform search, return the first found
-        stage_ids = self.pool.get('project.task.type').search(cr, uid, search_domain, order=order, context=context)
-        if stage_ids:
-            return stage_ids[0]
-        return False
+        return self.env['project.task.type'].search(search_domain, order=order, limit=1).id
 
-    def _store_history(self, cr, uid, ids, context=None):
-        for task in self.browse(cr, uid, ids, context=context):
-            self.pool.get('project.task.history').create(cr, uid, {
+    def _store_history(self):
+        for task in self:
+            self.env['project.task.history'].create({
                 'task_id': task.id,
                 'remaining_hours': task.remaining_hours,
                 'planned_hours': task.planned_hours,
@@ -561,47 +503,45 @@ class task(osv.osv):
                 'type_id': task.stage_id.id,
                 'user_id': task.user_id.id
 
-            }, context=context)
+            })
         return True
 
     # ------------------------------------------------
     # CRUD overrides
     # ------------------------------------------------
 
-    def create(self, cr, uid, vals, context=None):
-        context = dict(context or {})
+    @api.model
+    def create(self, vals):
+        # context: no_log, because subtype already handle this
+        context = dict(self.env.context, mail_create_nolog=True)
 
         # for default stage
         if vals.get('project_id') and not context.get('default_project_id'):
             context['default_project_id'] = vals.get('project_id')
         # user_id change: update date_assign
         if vals.get('user_id'):
-            vals['date_assign'] = fields.datetime.now()
-        # context: no_log, because subtype already handle this
-        create_context = dict(context, mail_create_nolog=True)
-        task_id = super(task, self).create(cr, uid, vals, context=create_context)
-        self._store_history(cr, uid, [task_id], context=context)
-        return task_id
-
-    def write(self, cr, uid, ids, vals, context=None):
-        if isinstance(ids, (int, long)):
-            ids = [ids]
+            vals['date_assign'] = fields.Datetime.now()
+        task = super(Task, self.with_context(context)).create(vals)
+        task._store_history()
+        return task
 
+    @api.multi
+    def write(self, vals):
+        now = fields.Datetime.now()
         # stage change: update date_last_stage_update
         if 'stage_id' in vals:
-            vals['date_last_stage_update'] = fields.datetime.now()
-        # user_id change: update date_assign
-        if vals.get('user_id'):
-            vals['date_assign'] = fields.datetime.now()
-        # reset kanban state when changing stage
-        if 'stage_id' in vals:
+            vals['date_last_stage_update'] = now
+            # reset kanban state when changing stage
             if 'kanban_state' not in vals:
                 vals['kanban_state'] = 'normal'
+        # user_id change: update date_assign
+        if vals.get('user_id'):
+            vals['date_assign'] = now
 
-        result = super(task, self).write(cr, uid, ids, vals, context=context)
+        result = super(Task, self).write(vals)
 
         if any(item in vals for item in ['stage_id', 'remaining_hours', 'user_id', 'kanban_state']):
-            self._store_history(cr, uid, ids, context=context)
+            self._store_history()
         return result
 
     # ---------------------------------------------------
@@ -610,50 +550,51 @@ class task(osv.osv):
 
     @api.multi
     def _track_template(self, tracking):
-        res = super(task, self)._track_template(tracking)
+        res = super(Task, self)._track_template(tracking)
         test_task = self[0]
         changes, tracking_value_ids = tracking[test_task.id]
         if 'stage_id' in changes and test_task.stage_id.mail_template_id:
             res['stage_id'] = (test_task.stage_id.mail_template_id, {'composition_mode': 'mass_mail'})
         return res
 
-    def _track_subtype(self, cr, uid, ids, init_values, context=None):
-        record = self.browse(cr, uid, ids[0], context=context)
-        if 'kanban_state' in init_values and record.kanban_state == 'blocked':
+    @api.multi
+    def _track_subtype(self, init_values):
+        self.ensure_one()
+        if 'kanban_state' in init_values and self.kanban_state == 'blocked':
             return 'project.mt_task_blocked'
-        elif 'kanban_state' in init_values and record.kanban_state == 'done':
+        elif 'kanban_state' in init_values and self.kanban_state == 'done':
             return 'project.mt_task_ready'
-        elif 'user_id' in init_values and record.user_id:  # assigned -> new
+        elif 'user_id' in init_values and self.user_id:  # assigned -> new
             return 'project.mt_task_new'
-        elif 'stage_id' in init_values and record.stage_id and record.stage_id.sequence <= 1:  # start stage -> new
+        elif 'stage_id' in init_values and self.stage_id and self.stage_id.sequence <= 1:  # start stage -> new
             return 'project.mt_task_new'
         elif 'stage_id' in init_values:
             return 'project.mt_task_stage'
-        return super(task, self)._track_subtype(cr, uid, ids, init_values, context=context)
+        return super(Task, self)._track_subtype(init_values)
 
-    def _notification_group_recipients(self, cr, uid, ids, message, recipients, done_ids, group_data, context=None):
+    @api.multi
+    def _notification_group_recipients(self, message, recipients, done_ids, group_data):
         """ Override the mail.thread method to handle project users and officers
         recipients. Indeed those will have specific action in their notification
         emails: creating tasks, assigning it. """
-        group_project_user = self.pool['ir.model.data'].xmlid_to_res_id(cr, uid, 'project.group_project_user')
-        for recipient in recipients:
-            if recipient.id in done_ids:
-                continue
-            if recipient.user_ids and group_project_user in recipient.user_ids[0].groups_id.ids:
+        group_project_user = self.env.ref('project.group_project_user')
+        for recipient in recipients.filtered(lambda recipient: recipient.id not in done_ids):
+            if recipient.user_ids and group_project_user in recipient.user_ids[0].groups_id:
                 group_data['group_project_user'] |= recipient
                 done_ids.add(recipient.id)
-        return super(task, self)._notification_group_recipients(cr, uid, ids, message, recipients, done_ids, group_data, context=context)
+        return super(Task, self)._notification_group_recipients(message, recipients, done_ids, group_data)
 
-    def _notification_get_recipient_groups(self, cr, uid, ids, message, recipients, context=None):
-        res = super(task, self)._notification_get_recipient_groups(cr, uid, ids, message, recipients, context=context)
+    @api.multi
+    def _notification_get_recipient_groups(self, message, recipients):
+        self.ensure_one()
+        res = super(Task, self)._notification_get_recipient_groups(message, recipients)
 
-        take_action = self._notification_link_helper(cr, uid, ids, 'assign', context=context)
-        new_action_id = self.pool['ir.model.data'].xmlid_to_res_id(cr, uid, 'project.action_view_task')
-        new_action = self._notification_link_helper(cr, uid, ids, 'new', context=context, action_id=new_action_id)
+        take_action = self._notification_link_helper('assign')
+        new_action_id = self.env.ref('project.action_view_task').id
+        new_action = self._notification_link_helper('new', action_id=new_action_id)
 
-        task_record = self.browse(cr, uid, ids[0], context=context)
         actions = []
-        if not task_record.user_id:
+        if not self.user_id:
             actions.append({'url': take_action, 'title': _('I take it')})
         else:
             actions.append({'url': new_action, 'title': _('New Task')})
@@ -663,39 +604,42 @@ class task(osv.osv):
         }
         return res
 
-    @api.cr_uid_context
-    def message_get_reply_to(self, cr, uid, ids, default=None, context=None):
+    @api.model
+    def message_get_reply_to(self, res_ids, default=None):
         """ Override to get the reply_to of the parent project. """
-        tasks = self.browse(cr, SUPERUSER_ID, ids, context=context)
-        project_ids = set([task.project_id.id for task in tasks if task.project_id])
-        aliases = self.pool['project.project'].message_get_reply_to(cr, uid, list(project_ids), default=default, context=context)
-        return dict((task.id, aliases.get(task.project_id and task.project_id.id or 0, False)) for task in tasks)
+        tasks = self.sudo().browse(res_ids)
+        project_ids = tasks.mapped('project_id').ids
+        aliases = self.env['project.project'].message_get_reply_to(project_ids, default=default)
+        return {task.id: aliases.get(task.project_id.id, False) for task in tasks}
 
-    def email_split(self, cr, uid, ids, msg, context=None):
+    @api.multi
+    def email_split(self, msg):
         email_list = tools.email_split((msg.get('to') or '') + ',' + (msg.get('cc') or ''))
         # check left-part is not already an alias
-        task_ids = self.browse(cr, uid, ids, context=context)
-        aliases = [task.project_id.alias_name for task in task_ids if task.project_id]
+        aliases = self.mapped('project_id.alias_name')
         return filter(lambda x: x.split('@')[0] not in aliases, email_list)
 
-    def message_new(self, cr, uid, msg, custom_values=None, context=None):
+    @api.model
+    def message_new(self, msg, custom_values=None):
         """ Override to updates the document according to the email. """
         if custom_values is None:
             custom_values = {}
         defaults = {
             'name': msg.get('subject'),
             'planned_hours': 0.0,
-            'partner_id': msg.get('author_id', False)
+            'partner_id': msg.get('author_id')
         }
         defaults.update(custom_values)
 
-        res = super(task, self).message_new(cr, uid, msg, custom_values=defaults, context=context)
-        email_list = self.email_split(cr, uid, [res], msg, context=context)
-        partner_ids = filter(None, self._find_partner_from_emails(cr, uid, [res], email_list, force_create=False, context=context))
-        self.message_subscribe(cr, uid, [res], partner_ids, context=context)
+        res = super(Task, self).message_new(msg, custom_values=defaults)
+        task = self.browse(res)
+        email_list = task.email_split(msg)
+        partner_ids = filter(None, task._find_partner_from_emails(email_list, force_create=False))
+        task.message_subscribe(partner_ids)
         return res
 
-    def message_update(self, cr, uid, ids, msg, update_vals=None, context=None):
+    @api.multi
+    def message_update(self, msg, update_vals=None):
         """ Override to update the task according to the email. """
         if update_vals is None:
             update_vals = {}
@@ -714,147 +658,127 @@ class task(osv.osv):
                     except (ValueError, TypeError):
                         pass
 
-        email_list = self.email_split(cr, uid, ids, msg, context=context)
-        partner_ids = filter(None, self._find_partner_from_emails(cr, uid, ids, email_list, force_create=False, context=context))
-        self.message_subscribe(cr, uid, ids, partner_ids, context=context)
-        return super(task, self).message_update(cr, uid, ids, msg, update_vals=update_vals, context=context)
-
-    def message_get_suggested_recipients(self, cr, uid, ids, context=None):
-        recipients = super(task, self).message_get_suggested_recipients(cr, uid, ids, context=context)
-        for data in self.browse(cr, uid, ids, context=context):
-            if data.partner_id:
-                reason = _('Customer Email') if data.partner_id.email else _('Customer')
-                data._message_add_suggested_recipient(recipients, partner=data.partner_id, reason=reason)
+        email_list = self.email_split(msg)
+        partner_ids = filter(None, self._find_partner_from_emails(email_list, force_create=False))
+        self.message_subscribe(partner_ids)
+        return super(Task, self).message_update(msg, update_vals=update_vals)
+
+    @api.multi
+    def message_get_suggested_recipients(self):
+        recipients = super(Task, self).message_get_suggested_recipients()
+        for task in self.filtered('partner_id'):
+            reason = _('Customer Email') if task.partner_id.email else _('Customer')
+            task._message_add_suggested_recipient(recipients, partner=task.partner_id, reason=reason)
         return recipients
 
-    def message_get_email_values(self, cr, uid, ids, notif_mail=None, context=None):
-        res = super(task, self).message_get_email_values(cr, uid, ids, notif_mail=notif_mail, context=context)
-        current_task = self.browse(cr, uid, ids[0], context=context)
+    @api.multi
+    def message_get_email_values(self, notif_mail=None):
+        res = super(Task, self).message_get_email_values(notif_mail=notif_mail)
         headers = {}
         if res.get('headers'):
             try:
                 headers.update(eval(res['headers']))
             except Exception:
                 pass
-        if current_task.project_id:
+        if self.project_id:
             current_objects = filter(None, headers.get('X-Odoo-Objects', '').split(','))
-            current_objects.insert(0, 'project.project-%s, ' % current_task.project_id.id)
+            current_objects.insert(0, 'project.project-%s, ' % self.project_id.id)
             headers['X-Odoo-Objects'] = ','.join(current_objects)
-        if current_task.tag_ids:
-            headers['X-Odoo-Tags'] = ','.join([tag.name for tag in current_task.tag_ids])
+        if self.tag_ids:
+            headers['X-Odoo-Tags'] = ','.join(self.tag_ids.mapped('name'))
         res['headers'] = repr(headers)
         return res
 
 
-class account_analytic_account(osv.osv):
+class AccountAnalyticAccount(models.Model):
     _inherit = 'account.analytic.account'
     _description = 'Analytic Account'
 
-    def _compute_project_count(self, cr, uid, ids, fieldnames, args, context=None):
-        result = dict.fromkeys(ids, 0)
-        for account in self.browse(cr, uid, ids, context=context):
-            result[account.id] = len(account.project_ids)
-        return result
+    use_tasks = fields.Boolean(string='Use Tasks', help="Check this box to manage internal activities through this project")
+    company_uom_id = fields.Many2one('product.uom', related='company_id.project_time_mode_id', string="Company UOM")
+    project_ids = fields.One2many('project.project', 'analytic_account_id', string='Projects')
+    project_count = fields.Integer(compute='_compute_project_count', string='Project Count')
 
-    _columns = {
-        'use_tasks': fields.boolean(string='Use Tasks', help="Check this box to manage internal activities through this project"),
-        'company_uom_id': fields.related('company_id', 'project_time_mode_id', string="Company UOM", type='many2one', relation='product.uom'),
-        'project_ids': fields.one2many('project.project', 'analytic_account_id', 'Projects'),
-        'project_count': fields.function(_compute_project_count, string='Project Count', type='integer')
-    }
-
-    def on_change_template(self, cr, uid, ids, template_id, date_start=False, context=None):
-        res = super(account_analytic_account, self).on_change_template(cr, uid, ids, template_id, date_start=date_start, context=context)
-        if template_id and 'value' in res:
-            template = self.browse(cr, uid, template_id, context=context)
-            res['value']['use_tasks'] = template.use_tasks
-        return res
+    def _compute_project_count(self):
+        for account in self:
+            account.project_count = len(account.project_ids)
 
-    def _trigger_project_creation(self, cr, uid, vals, context=None):
+    @api.model
+    def _trigger_project_creation(self, vals):
         '''
         This function is used to decide if a project needs to be automatically created or not when an analytic account is created. It returns True if it needs to be so, False otherwise.
         '''
-        if context is None: context = {}
-        return vals.get('use_tasks') and not 'project_creation_in_progress' in context
+        return vals.get('use_tasks') and 'project_creation_in_progress' not in self.env.context
 
-    @api.cr_uid_id_context
-    def project_create(self, cr, uid, analytic_account_id, vals, context=None):
+    @api.multi
+    def project_create(self, vals):
         '''
         This function is called at the time of analytic account creation and is used to create a project automatically linked to it if the conditions are meet.
         '''
-        project_pool = self.pool.get('project.project')
-        project_id = project_pool.search(cr, uid, [('analytic_account_id','=', analytic_account_id)])
-        if not project_id and self._trigger_project_creation(cr, uid, vals, context=context):
+        self.ensure_one()
+        Project = self.env['project.project']
+        project = Project.search([('analytic_account_id', '=', self.id)])
+        if not project and self._trigger_project_creation(vals):
             project_values = {
                 'name': vals.get('name'),
-                'analytic_account_id': analytic_account_id,
+                'analytic_account_id': self.id,
                 'use_tasks': True,
             }
-            return project_pool.create(cr, uid, project_values, context=context)
+            return Project.create(project_values).id
         return False
 
-    def create(self, cr, uid, vals, context=None):
-        if context is None:
-            context = {}
-        analytic_account_id = super(account_analytic_account, self).create(cr, uid, vals, context=context)
-        self.project_create(cr, uid, analytic_account_id, vals, context=context)
-        return analytic_account_id
+    @api.model
+    def create(self, vals):
+        analytic_account = super(AccountAnalyticAccount, self).create(vals)
+        analytic_account.project_create(vals)
+        return analytic_account
 
-    def write(self, cr, uid, ids, vals, context=None):
-        if isinstance(ids, (int, long)):
-            ids = [ids]
+    @api.multi
+    def write(self, vals):
         vals_for_project = vals.copy()
-        for account in self.browse(cr, uid, ids, context=context):
+        for account in self:
             if not vals.get('name'):
                 vals_for_project['name'] = account.name
-            self.project_create(cr, uid, account.id, vals_for_project, context=context)
-        return super(account_analytic_account, self).write(cr, uid, ids, vals, context=context)
+            account.project_create(vals_for_project)
+        return super(AccountAnalyticAccount, self).write(vals)
 
-    def unlink(self, cr, uid, ids, context=None):
-        proj_ids = self.pool['project.project'].search(cr, uid, [('analytic_account_id', 'in', ids)])
-        has_tasks = self.pool['project.task'].search(cr, uid, [('project_id', 'in', proj_ids)], count=True, context=context)
+    @api.multi
+    def unlink(self):
+        projects = self.env['project.project'].search([('analytic_account_id', 'in', self.ids)])
+        has_tasks = self.env['project.task'].search_count([('project_id', 'in', projects.ids)])
         if has_tasks:
             raise UserError(_('Please remove existing tasks in the project linked to the accounts you want to delete.'))
-        return super(account_analytic_account, self).unlink(cr, uid, ids, context=context)
+        return super(AccountAnalyticAccount, self).unlink()
 
-    def name_search(self, cr, uid, name, args=None, operator='ilike', context=None, limit=100):
+    @api.model
+    def name_search(self, name, args=None, operator='ilike', limit=100):
         if args is None:
             args = []
-        if context is None:
-            context={}
-        if context.get('current_model') == 'project.project':
-            project_ids = self.search(cr, uid, args + [('name', operator, name)], limit=limit, context=context)
-            return self.name_get(cr, uid, project_ids, context=context)
+        if self.env.context.get('current_model') == 'project.project':
+            return self.search(args + [('name', operator, name)], limit=limit).name_get()
 
-        return super(account_analytic_account, self).name_search(cr, uid, name, args=args, operator=operator, context=context, limit=limit)
+        return super(AccountAnalyticAccount, self).name_search(name, args=args, operator=operator, limit=limit)
 
-    def projects_action(self, cr, uid, ids, context=None):
-        accounts = self.browse(cr, uid, ids, context=context)
-        project_ids = sum([account.project_ids.ids for account in accounts], [])
+    @api.multi
+    def projects_action(self):
+        projects = self.mapped('project_ids')
         result = {
             "type": "ir.actions.act_window",
             "res_model": "project.project",
             "views": [[False, "tree"], [False, "form"]],
-            "domain": [["id", "in", project_ids]],
+            "domain": [["id", "in", projects.ids]],
             "context": {"create": False},
             "name": "Projects",
         }
-        if len(project_ids) == 1:
+        if len(projects) == 1:
             result['views'] = [(False, "form")]
-            result['res_id'] = project_ids[0]
+            result['res_id'] = projects.id
         else:
             result = {'type': 'ir.actions.act_window_close'}
         return result
 
 
-
-class project_project(osv.osv):
-    _inherit = 'project.project'
-    _defaults = {
-        'use_tasks': True
-    }
-
-class project_task_history(osv.osv):
+class ProjectTaskHistory(models.Model):
     """
     Tasks History, used for cumulative flow charts (Lean/Agile)
     """
@@ -863,13 +787,13 @@ class project_task_history(osv.osv):
     _rec_name = 'task_id'
     _log_access = False
 
-    def _get_date(self, cr, uid, ids, name, arg, context=None):
-        result = {}
-        for history in self.browse(cr, uid, ids, context=context):
+    @api.depends('date', 'task_id', 'type_id', 'type_id.fold')
+    def _compute_end_date(self):
+        for history in self:
             if history.type_id and history.type_id.fold:
-                result[history.id] = history.date
+                history.end_date = history.date
                 continue
-            cr.execute('''select
+            self.env.cr.execute('''select
                     date
                 from
                     project_task_history
@@ -877,51 +801,31 @@ class project_task_history(osv.osv):
                     task_id=%s and
                     id>%s
                 order by id limit 1''', (history.task_id.id, history.id))
-            res = cr.fetchone()
-            result[history.id] = res and res[0] or False
-        return result
-
-    def _get_related_date(self, cr, uid, ids, context=None):
-        result = []
-        for history in self.browse(cr, uid, ids, context=context):
-            cr.execute('''select
-                    id
-                from
-                    project_task_history
-                where
-                    task_id=%s and
-                    id<%s
-                order by id desc limit 1''', (history.task_id.id, history.id))
-            res = cr.fetchone()
-            if res:
-                result.append(res[0])
-        return result
-
-    _columns = {
-        'task_id': fields.many2one('project.task', 'Task', ondelete='cascade', required=True, select=True),
-        'type_id': fields.many2one('project.task.type', 'Stage'),
-        'kanban_state': fields.selection([('normal', 'Normal'), ('blocked', 'Blocked'), ('done', 'Ready for next stage')], 'Kanban State', required=False),
-        'date': fields.date('Date', select=True),
-        'end_date': fields.function(_get_date, string='End Date', type="date", store={
-            'project.task.history': (_get_related_date, None, 20)
-        }),
-        'remaining_hours': fields.float('Remaining Time', digits=(16, 2)),
-        'planned_hours': fields.float('Planned Time', digits=(16, 2)),
-        'user_id': fields.many2one('res.users', 'Responsible'),
-    }
-    _defaults = {
-        'date': fields.date.context_today,
-    }
-
-
-class project_tags(osv.Model):
+            res = self.env.cr.fetchone()
+            history.end_date = res and res[0] or False
+
+    task_id = fields.Many2one('project.task', string='Task', ondelete='cascade', required=True, index=True)
+    type_id = fields.Many2one('project.task.type', string='Stage')
+    kanban_state = fields.Selection([
+            ('normal', 'Normal'),
+            ('blocked', 'Blocked'),
+            ('done', 'Ready for next stage')
+        ], string='Kanban State')
+    date = fields.Date(string='Date', index=True, default=fields.Date.context_today)
+    end_date = fields.Date(string='End Date', compute='_compute_end_date', store=True)
+    remaining_hours = fields.Float(string='Remaining Time', digits=(16, 2))
+    planned_hours = fields.Float(string='Planned Time', digits=(16, 2))
+    user_id = fields.Many2one('res.users', string='Responsible')
+
+
+class ProjectTags(models.Model):
     """ Tags of project's tasks (or issues) """
     _name = "project.tags"
     _description = "Tags of project's tasks, issues..."
-    _columns = {
-        'name': fields.char('Name', required=True),
-        'color': fields.integer('Color Index'),
-    }
+
+    name = fields.Char(required=True)
+    color = fields.Integer(string='Color Index')
+
     _sql_constraints = [
-            ('name_uniq', 'unique (name)', "Tag name already exists !"),
+        ('name_uniq', 'unique (name)', "Tag name already exists !"),
     ]
