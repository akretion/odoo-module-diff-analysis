PR: https://github.com/odoo/odoo/pull/99023

From: 6927dcda9f99db2a4d2f06b32f8d377c17fe2794
From: eres-odoo
Date: 2022-09-02 18:10:59

Structural Changes: 14
Total Changes: 277

[IMP] loyalty*: misc loyalty improvements

This commit improves some messages and usability for loyalty and its
submodules:
 - Coupons should not be restricted to the partner assigned to them
   anymore
 - Merged "I have a promo code" and "Use a gift card" into a single
   toggle
 - Boolean fields have been added to each app to disable them where we
   don't want them.
 - Reduced the size of coupon codes
   This means that we increase the risk of collision which should be
   handled by the model as well now.
   Creating a coupon with an existing code will retry the creation (up
   to 10 times) until the coupon is indeed created.
 - Make it clearer in the coupon generation wizard that an email will be
   sent to the customer.
 - Reintroduce coupon/gift card details on sale order lines in eCommerce
   which was wrongfully removed.
 - Remove the "on product with taxes: " message on order lines when
   the amount is not split between taxes or if the tax message would be
   empty.
 - Make it possible for some error messages to be displayed as warning
   instead of errors
 - Split program types in two menuitems, one for promotions discount
   loyalty etc and one for gift cards and ewallet, the latter has
   simplified views.
 - Views overall have been reviewed to make it easier to understand how
   to programs work. New program types have also been added.

TaskId-2951413

Part-of: odoo/odoo#99023
Co-authored-by: William Braeckman <wbr@odoo.com>

================================= pseudo patch: =================================

--- a/addons/loyalty/models/loyalty_card.py
+++ b/addons/loyalty/models/loyalty_card.py
@@ -17,18 +17,19 @@ class LoyaltyCard(models.Model):
         """
         Barcode identifiable codes.
         """
-        return '044' + str(uuid4())[4:-8][3:]
+        return '044' + str(uuid4())[7:-18]
 
     def name_get(self):
         return [(card.id, f'{card.program_id.name}: {card.code}') for card in self]
 
-    program_id = fields.Many2one('loyalty.program', ondelete='restrict')
+    program_id = fields.Many2one('loyalty.program', ondelete='restrict', default=lambda self: self.env.context.get('active_id', None))
     company_id = fields.Many2one(related='program_id.company_id', store=True)
     currency_id = fields.Many2one(related='program_id.currency_id')
     # Reserved for this partner if non-empty
     partner_id = fields.Many2one('res.partner', index=True)
     points = fields.Float(tracking=True)
     point_name = fields.Char(related='program_id.portal_point_name', readonly=True)
+    points_display = fields.Char(compute='_compute_points_display')
 
     code = fields.Char(default=lambda self: self._generate_code(), required=True, readonly=True, index=True)
     expiration_date = fields.Date()
@@ -45,6 +46,11 @@ class LoyaltyCard(models.Model):
         if self.env['loyalty.rule'].search_count([('mode', '=', 'with_code'), ('code', 'in', self.mapped('code'))]):
             raise ValidationError(_('A trigger with the same code as one of your coupon already exists.'))
 
+    @api.depends('points', 'point_name')
+    def _compute_points_display(self):
+        for card in self:
+            card.points_display = "%.2f %s" % (card.points or 0, card.point_name or '')
+
     # Meant to be overriden
     def _compute_use_count(self):
         self.use_count = 0

--- a/addons/loyalty/models/loyalty_program.py
+++ b/addons/loyalty/models/loyalty_program.py
@@ -24,21 +24,31 @@ class LoyaltyProgram(models.Model):
 
     total_order_count = fields.Integer("Total Order Count", compute="_compute_total_order_count")
 
-    rule_ids = fields.One2many('loyalty.rule', 'program_id', 'Triggers', copy=True,
+    rule_ids = fields.One2many('loyalty.rule', 'program_id', 'Conditional rules', copy=True,
          compute='_compute_from_program_type', readonly=False, store=True)
     reward_ids = fields.One2many('loyalty.reward', 'program_id', 'Rewards', copy=True,
          compute='_compute_from_program_type', readonly=False, store=True)
     communication_plan_ids = fields.One2many('loyalty.mail', 'program_id', copy=True,
          compute='_compute_from_program_type', readonly=False, store=True)
+
+    # These fields are used for the simplified view of gift_card and ewallet
+    mail_template_id = fields.Many2one('mail.template', compute='_compute_mail_template_id', inverse='_inverse_mail_template_id', string="Email template", readonly=False)
+    trigger_product_ids = fields.Many2many(related='rule_ids.product_ids', readonly=False)
+
     coupon_ids = fields.One2many('loyalty.card', 'program_id')
     coupon_count = fields.Integer(compute='_compute_coupon_count')
+    coupon_count_display = fields.Char(compute='_compute_coupon_count_display', string="Items")
 
     program_type = fields.Selection([
         ('coupons', 'Coupons'),
         ('gift_card', 'Gift Card'),
         ('loyalty', 'Loyalty Cards'),
         ('promotion', 'Promotions'),
-        ('ewallet', 'eWallet')], default='promotion', required=True,
+        ('ewallet', 'eWallet'),
+        ('promo_code', 'Discount Code'),
+        ('buy_x_get_y', 'Buy X Get Y'),
+        ('next_order_coupons', 'Next Order Coupons')],
+        default='promotion', required=True,
     )
     date_to = fields.Date(string='Validity')
     limit_usage = fields.Boolean(string='Limit Usage')
@@ -67,9 +77,16 @@ class LoyaltyProgram(models.Model):
         Show in web portal, PoS customer ticket, eCommerce checkout, the number of points available and used by reward.
         """)
     portal_point_name = fields.Char(default='Points', translate=True,
-         compute='_compute_from_program_type', readonly=False, store=True)
+         compute='_compute_portal_point_name', readonly=False, store=True)
     is_nominative = fields.Boolean(compute='_compute_is_nominative')
 
+    # Technical field used for a label
+    available_on = fields.Boolean("Available On", store=False,
+        help="""
+        Manage where your program should be available for use.
+        """
+    )
+
     _sql_constraints = [
         ('check_max_usage', 'CHECK (limit_usage = False OR max_usage > 0)',
             'Max usage must be strictly positive if a limit is used.'),
@@ -77,12 +94,43 @@ class LoyaltyProgram(models.Model):
 
     @api.constrains('reward_ids')
     def _constrains_reward_ids(self):
+        if self.env.context.get('loyalty_skip_reward_check'):
+            return
         if any(not program.reward_ids for program in self):
             raise ValidationError(_('A program must have at least one reward.'))
 
     def _compute_total_order_count(self):
         self.total_order_count = 0
 
+    @api.depends('coupon_count', 'program_type')
+    def _compute_coupon_count_display(self):
+        program_items_name = self._program_items_name()
+        for program in self:
+            program.coupon_count_display = "%i %s" % (program.coupon_count or 0, program_items_name[program.program_type] or '')
+
+    @api.depends("communication_plan_ids.mail_template_id")
+    def _compute_mail_template_id(self):
+        for program in self:
+            program.mail_template_id = program.communication_plan_ids.mail_template_id[:1]
+
+    def _inverse_mail_template_id(self):
+        for program in self:
+            if program.program_type not in ("gift_card", "ewallet"):
+                continue
+            if not program.mail_template_id:
+                program.communication_plan_ids = [(5, 0, 0)]
+            elif not program.communication_plan_ids:
+                program.communication_plan_ids = self.env['loyalty.mail'].create({
+                    'program_id': program.id,
+                    'trigger': 'create',
+                    'mail_template_id': program.mail_template_id.id,
+                })
+            else:
+                program.communication_plan_ids.write({
+                    'trigger': 'create',
+                    'mail_template_id': program.mail_template_id.id,
+                })
+
     @api.depends('company_id')
     def _compute_currency_id(self):
         for program in self:
@@ -101,17 +149,30 @@ class LoyaltyProgram(models.Model):
             program.is_nominative = program.applies_on == 'both' or\
                 (program.program_type == 'ewallet' and program.applies_on == 'future')
 
+    @api.model
+    def _program_items_name(self):
+        return {
+            'coupons': _('Coupons'),
+            'promotion': _('Promos'),
+            'gift_card': _('Gift Cards'),
+            'loyalty': _('Loyalty Cards'),
+            'ewallet': _('eWallets'),
+            'promo_code': _('Discounts'),
+            'buy_x_get_y': _('Promos'),
+            'next_order_coupons': _('Coupons'),
+        }
+
     @api.model
     def _program_type_default_values(self):
         # All values to change when program_type changes
         # NOTE: any field used in `rule_ids`, `reward_ids` and `communication_plan_ids` MUST be present in the kanban view for it to work properly.
+        first_sale_product = self.env['product.product'].search([('sale_ok', '=', True)], limit=1)
         return {
             'coupons': {
                 'applies_on': 'current',
                 'trigger': 'with_code',
                 'portal_visible': False,
-                'portal_point_name': _('Points'),
-                # Coupons don't use rules by default
+                'portal_point_name': _('Coupon point(s)'),
                 'rule_ids': [(5, 0, 0)],
                 'reward_ids': [(5, 0, 0), (0, 0, {
                     'required_points': 1,
@@ -126,7 +187,7 @@ class LoyaltyProgram(models.Model):
                 'applies_on': 'current',
                 'trigger': 'auto',
                 'portal_visible': False,
-                'portal_point_name': _('Points'),
+                'portal_point_name': _('Promo point(s)'),
                 'rule_ids': [(5, 0, 0), (0, 0, {
                     'reward_point_amount': 1,
                     'reward_point_mode': 'order',
@@ -155,7 +216,7 @@ class LoyaltyProgram(models.Model):
                     'discount': 1,
                     'discount_applicability': 'order',
                     'required_points': 1,
-                    'description': _('Pay With Gift Card'),
+                    'description': _('Gift Card'),
                 })],
                 'communication_plan_ids': [(5, 0, 0), (0, 0, {
                     'trigger': 'create',
@@ -166,7 +227,7 @@ class LoyaltyProgram(models.Model):
                 'applies_on': 'both',
                 'trigger': 'auto',
                 'portal_visible': True,
-                'portal_point_name': _('Loyalty Points'),
+                'portal_point_name': _('Loyalty point(s)'),
                 'rule_ids': [(5, 0, 0), (0, 0, {
                     'reward_point_mode': 'money',
                 })],
@@ -177,8 +238,8 @@ class LoyaltyProgram(models.Model):
                 'communication_plan_ids': [(5, 0, 0)],
             },
             'ewallet': {
-                'applies_on': 'future',
                 'trigger': 'auto',
+                'applies_on': 'future',
                 'portal_visible': True,
                 'portal_point_name': self.env.company.currency_id.symbol,
                 'rule_ids': [(5, 0, 0), (0, 0, {
@@ -192,9 +253,62 @@ class LoyaltyProgram(models.Model):
                     'discount': 1,
                     'discount_applicability': 'order',
                     'required_points': 1,
+                    'description': _('eWallet'),
+                })],
+                'communication_plan_ids': [(5, 0, 0)],
+            },
+            'promo_code': {
+                'applies_on': 'current',
+                'trigger': 'with_code',
+                'portal_visible': False,
+                'portal_point_name': _('Discount point(s)'),
+                'rule_ids': [(5, 0, 0), (0, 0, {
+                    'mode': 'with_code',
+                    'code': 'PROMO_CODE_' + str(uuid4())[:4], # We should try not to trigger any unicity constraint
+                })],
+                'reward_ids': [(5, 0, 0), (0, 0, {
+                    'discount_applicability': 'specific',
+                    'discount_product_ids': first_sale_product,
+                    'discount_mode': 'percent',
+                    'discount': 10,
                 })],
                 'communication_plan_ids': [(5, 0, 0)],
             },
+            'buy_x_get_y': {
+                'applies_on': 'current',
+                'trigger': 'auto',
+                'portal_visible': False,
+                'portal_point_name': _('Credit(s)'),
+                'rule_ids': [(5, 0, 0), (0, 0, {
+                    'reward_point_mode': 'unit',
+                    'product_ids': first_sale_product,
+                })],
+                'reward_ids': [(5, 0, 0), (0, 0, {
+                    'reward_type': 'product',
+                    'reward_product_id': first_sale_product.id,
+                    'required_points': 2,
+                })],
+                'communication_plan_ids': [(5, 0, 0)],
+            },
+            'next_order_coupons': {
+                'applies_on': 'future',
+                'trigger': 'auto',
+                'portal_visible': True,
+                'portal_point_name': _('Coupon point(s)'),
+                'rule_ids': [(5, 0, 0), (0, 0, {
+                    'minimum_amount': 100,
+                })],
+                'reward_ids': [(5, 0, 0), (0, 0, {
+                    'reward_type': 'discount',
+                    'discount_mode': 'percent',
+                    'discount': 15,
+                    'discount_applicability': 'order',
+                })],
+                'communication_plan_ids': [(5, 0, 0), (0, 0, {
+                    'trigger': 'create',
+                    'mail_template_id': (self.env.ref('loyalty.mail_template_gift_card', raise_if_not_found=False) or self.env['mail.template']).id,
+                })],
+            },
         }
 
     @api.depends('program_type')
@@ -207,6 +321,13 @@ class LoyaltyProgram(models.Model):
             if program_type in program_type_defaults:
                 programs.write(program_type_defaults[program_type])
 
+    @api.depends("currency_id", "program_type")
+    def _compute_portal_point_name(self):
+        for program in self:
+            if program.program_type not in ('ewallet', 'gift_card'):
+                continue
+            program.portal_point_name = program.currency_id.symbol or ''
+
     def _get_valid_products(self, products):
         '''
         Returns a dict containing the products that match per rule of the program
@@ -220,6 +341,13 @@ class LoyaltyProgram(models.Model):
                 rule_products[rule] = products
         return rule_products
 
+    def action_open_loyalty_cards(self):
+        self.ensure_one()
+        action = self.env['ir.actions.act_window']._for_xml_id("loyalty.loyalty_card_action")
+        action['name'] = self._program_items_name()[self.program_type]
+        action['display_name'] = action['name']
+        return action
+
     @api.ondelete(at_uninstall=False)
     def _unlink_except_active(self):
         if any(program.active for program in self):
@@ -234,22 +362,39 @@ class LoyaltyProgram(models.Model):
             program.communication_plan_ids.active = program.active
             program.reward_ids.discount_line_product_id.active = program.active
 
+    def write(self, vals):
+        # There is an issue when we change the program type, since we clear the rewards and create new ones.
+        # The orm actually does it in this order upon writing, triggering the constraint before creating the new rewards.
+        # However we can check that the result of reward_ids would actually be empty or not, and if not, skip the constraint.
+        if 'reward_ids' in vals and self._fields['reward_ids'].convert_to_cache(vals['reward_ids'], self):
+            self = self.with_context(loyalty_skip_reward_check=True)
+        return super().write(vals)
+
     @api.model
     def get_program_templates(self):
         '''
         Returns the templates to be used for promotional programs.
         '''
+        ctx_menu_type = self.env.context.get('menu_type')
+        if ctx_menu_type == 'gift_ewallet':
+            return {
+                'gift_card': {
+                    'title': _('Gift Card'),
+                    'description': _('Sell Gift Cards, that can be used to purchase products'),
+                    'icon': 'gift_card',
+                },
+                'ewallet': {
+                    'title': _('eWallet'),
+                    'description': _('Fill in your eWallet, and use it to pay future orders'),
+                    'icon': 'ewallet',
+                },
+            }
         return {
             'promo_code': {
                 'title': _('Promo Code'),
                 'description': _('Get a code to receive 10% discount on specific products'),
                 'icon': 'promo_code',
             },
-            'gift_card': {
-                'title': _('Gift Card'),
-                'description': _('Sell Gift Cards, that can be used to purchase products'),
-                'icon': 'gift_card',
-            },
             'loyalty': {
                 'title': _('Loyalty Cards'),
                 'description': _('Win points with each purchases, and use points to get gifts'),
@@ -270,15 +415,15 @@ class LoyaltyProgram(models.Model):
                 'description': _('Send unique coupons that give access to rewards'),
                 'icon': 'coupons',
             },
-            'buy_two_get_one': {
+            'buy_x_get_y': {
                 'title': _('2+1 Free'),
                 'description': _('Buy 2 products and get a third one for free'),
                 'icon': '2_plus_1',
             },
-            'ewallet': {
-                'title': _('eWallet'),
-                'description': _('Fill in your eWallet, and use it to pay future orders'),
-                'icon': 'ewallet',
+            'next_order_coupons': {
+                'title': _('Next Order Coupons'),
+                'description': _('Send unique, single-use coupon code for the next purchase'),
+                'icon': 'coupons',
             },
         }
 
@@ -293,7 +438,11 @@ class LoyaltyProgram(models.Model):
         if template_id not in template_values:
             return False
         program = self.create(template_values[template_id])
-        action = self.env['ir.actions.act_window']._for_xml_id('loyalty.loyalty_program_action')
+        action = {}
+        if self.env.context.get('menu_type') == 'gift_ewallet':
+            action = self.env['ir.actions.act_window']._for_xml_id('loyalty.loyalty_program_discount_loyalty_action')
+        else:
+            action = self.env['ir.actions.act_window']._for_xml_id('loyalty.loyalty_program_gift_ewallet_action')
         action['views'] = [[False, 'form']]
         action['view_mode'] = 'form'
         action['res_id'] = program.id
@@ -334,20 +483,19 @@ class LoyaltyProgram(models.Model):
                 **program_type_defaults['promotion'],
             },
             'promo_code': {
-                'name': _('Promo Code'),
-                'program_type': 'promotion',
-                'applies_on': 'current',
-                'trigger': 'with_code',
-                'rule_ids': [(0, 0, {
-                    'mode': 'with_code',
-                    'code': '10PERCENT_' + str(uuid4())[:4], # Require a random code in case a user creates multiple program using this template
-                })],
-                'reward_ids': [(0, 0, {
-                    'discount_applicability': 'specific',
-                    'discount_product_ids': product,
-                    'discount_mode': 'percent',
-                    'discount': 10,
-                })]
+                'name': _('Discount code'),
+                'program_type': 'promo_code',
+                **program_type_defaults['promo_code'],
+            },
+            'buy_x_get_y': {
+                'name': _('2+1 Free'),
+                'program_type': 'buy_x_get_y',
+                **program_type_defaults['buy_x_get_y'],
+            },
+            'next_order_coupons': {
+                'name': _('Next Order Coupons'),
+                'program_type': 'next_order_coupons',
+                **program_type_defaults['next_order_coupons'],
             },
             'fidelity': {
                 'name': _('Fidelity Cards'),
@@ -366,19 +514,4 @@ class LoyaltyProgram(models.Model):
                     'discount': 10,
                 })]
             },
-            'buy_two_get_one': {
-                'name': _('2+1 Free'),
-                'program_type': 'promotion',
-                'applies_on': 'current',
-                'trigger': 'auto',
-                'rule_ids': [(0, 0, {
-                    'reward_point_mode': 'unit',
-                    'product_ids': product,
-                })],
-                'reward_ids': [(0, 0, {
-                    'reward_type': 'product',
-                    'reward_product_id': product and product.id or False,
-                    'required_points': 2,
-                })]
-            },
         }

--- a/addons/loyalty/models/loyalty_reward.py
+++ b/addons/loyalty/models/loyalty_reward.py
@@ -27,6 +27,7 @@ class LoyaltyReward(models.Model):
 
     active = fields.Boolean(default=True)
     program_id = fields.Many2one('loyalty.program', required=True, ondelete='cascade')
+    program_type = fields.Selection(related="program_id.program_type")
     # Stored for security rules
     company_id = fields.Many2one(related='program_id.company_id', store=True)
     currency_id = fields.Many2one(related='program_id.currency_id')
@@ -38,6 +39,7 @@ class LoyaltyReward(models.Model):
         ('discount', 'Discount')],
         default='discount', required=True,
     )
+    user_has_debug = fields.Boolean(compute='_compute_user_has_debug')
 
     # Discount rewards
     discount = fields.Float('Discount', default=10)
@@ -116,9 +118,15 @@ class LoyaltyReward(models.Model):
     def _compute_description(self):
         for reward in self:
             reward_string = ""
-            if reward.reward_type == 'product':
+            if reward.program_type == 'gift_card':
+                reward_string = _("Gift Card")
+            elif reward.program_type == 'ewallet':
+                reward_string = _("eWallet")
+            elif reward.reward_type == 'product':
                 products = reward.reward_product_ids
-                if len(products) == 1:
+                if len(products) == 0:
+                    reward_string = _('Free Product')
+                elif len(products) == 1:
                     reward_string = _('Free Product - %s', reward.reward_product_id.name)
                 else:
                     reward_string = _('Free Product - [%s]', ', '.join(products.mapped('name')))
@@ -157,6 +165,11 @@ class LoyaltyReward(models.Model):
                                         reward.discount_applicability == 'order' and\
                                         reward.discount_mode == 'percent'
 
+    @api.depends_context('uid')
+    @api.depends("reward_type")
+    def _compute_user_has_debug(self):
+        self.user_has_debug = self.user_has_groups('base.group_no_one')
+
     def _create_missing_discount_line_products(self):
         # Make sure we create the product that will be used for our discounts
         rewards = self.filtered(lambda r: not r.discount_line_product_id)

--- a/addons/loyalty/models/loyalty_rule.py
+++ b/addons/loyalty/models/loyalty_rule.py
@@ -23,11 +23,13 @@ class LoyaltyRule(models.Model):
 
     active = fields.Boolean(default=True)
     program_id = fields.Many2one('loyalty.program', required=True, ondelete='cascade')
+    program_type = fields.Selection(related="program_id.program_type")
     # Stored for security rules
     company_id = fields.Many2one(related='program_id.company_id', store=True)
     currency_id = fields.Many2one(related='program_id.currency_id')
 
     # Only for dev mode
+    user_has_debug = fields.Boolean(compute='_compute_user_has_debug')
     product_domain = fields.Char(default="[]")
 
     product_ids = fields.Many2many('product.product', string='Products')
@@ -51,8 +53,8 @@ class LoyaltyRule(models.Model):
     mode = fields.Selection([
         ('auto', 'Automatic'),
         ('with_code', 'With a promotion code'),
-    ], string="Application", default="auto")
-    code = fields.Char(string='Promotion Code', compute='_compute_code', store=True, readonly=False)
+    ], string="Application", compute='_compute_mode', store=True, readonly=False)
+    code = fields.Char(string='Discount code', compute='_compute_code', store=True, readonly=False)
 
     _sql_constraints = [
         ('reward_point_amount_positive', 'CHECK (reward_point_amount > 0)', 'Rule points reward must be strictly positive.'),
@@ -84,6 +86,19 @@ class LoyaltyRule(models.Model):
             if rule.mode == 'auto':
                 rule.code = False
 
+    @api.depends('code')
+    def _compute_mode(self):
+        for rule in self:
+            if rule.code:
+                rule.mode = 'with_code'
+            else:
+                rule.mode = 'auto'
+
+    @api.depends_context('uid')
+    @api.depends("mode")
+    def _compute_user_has_debug(self):
+        self.user_has_debug = self.user_has_groups('base.group_no_one')
+
     def _get_valid_product_domain(self):
         self.ensure_one()
         domain = []
