PR: https://github.com/odoo/odoo/pull/

From: 64caa930b384a2aaa3ee6a689f29b830a55f9029
From: RÃ©my Voet (ryv)
Date: 2021-03-30 09:27:05

Structural Changes: 3
Total Changes: 33

[REF] stock: cache the `get_warehouse` of `stock.location`

To avoid multiple search of the get_warehouse for the same location
and extra SQL request (it happens a lot for complicate flow, e.g.
mrp_mps, replenishment report).
Translate it into a standard compute to use the cache of
the ORM for no-store compute field (`warehouse_id`) and put
some depends to be always correct (even if `warehouse_id` shouldn't
change in the same request).

task-2439019

================================= pseudo patch: =================================

--- a/addons/stock/models/product.py
+++ b/addons/stock/models/product.py
@@ -574,7 +574,7 @@ class Product(models.Model):
             seen_rules = self.env['stock.rule']
         rule = self.env['procurement.group']._get_rule(self, location, {
             'route_ids': route_ids,
-            'warehouse_id': location.get_warehouse()
+            'warehouse_id': location.warehouse_id
         })
         if not rule:
             return seen_rules

--- a/addons/stock/models/stock_location.py
+++ b/addons/stock/models/stock_location.py
@@ -6,6 +6,7 @@ from datetime import timedelta
 from odoo import _, api, fields, models
 from odoo.exceptions import UserError
 from odoo.osv import expression
+from collections import OrderedDict
 
 
 class Location(models.Model):
@@ -65,6 +66,8 @@ class Location(models.Model):
     cyclic_inventory_frequency = fields.Integer("Inventory Frequency (Days)", default=0, help=" When different than 0, inventory adjustments for products stored at this location will be created automatically at the defined frequency.")
     last_inventory_date = fields.Datetime("Last Effective Inventory", readonly=True, help="Date of the last inventory at this location.")
     next_inventory_date = fields.Date("Next Expected Inventory", compute="_compute_next_inventory_date", store=True, help="Date for next planned inventory based on cyclic schedule.")
+    warehouse_view_ids = fields.One2many('stock.warehouse', 'view_location_id', readonly=True)
+    warehouse_id = fields.Many2one('stock.warehouse', compute='_compute_warehouse_id')
 
     _sql_constraints = [('barcode_company_uniq', 'unique (barcode,company_id)', 'The barcode for a location must be unique per company !'),
                         ('inventory_freq_nonneg', 'check(cyclic_inventory_frequency >= 0)', 'The inventory frequency (days) for a location must be non-negative')]
@@ -95,6 +98,18 @@ class Location(models.Model):
             else:
                 location.next_inventory_date = False
 
+    @api.depends('location_id.warehouse_id', 'warehouse_view_ids')
+    def _compute_warehouse_id(self):
+        warehouses = self.env['stock.warehouse'].search([('view_location_id', 'parent_of', self.ids)])
+        view_by_wh = OrderedDict((wh.view_location_id.id, wh.id) for wh in warehouses)
+        self.warehouse_id = False
+        for loc in self:
+            path = set(int(loc_id) for loc_id in loc.parent_path.split('/')[:-1])
+            for view_location_id in view_by_wh:
+                if view_location_id in path:
+                    loc.warehouse_id = view_by_wh[view_location_id]
+                    break
+
     @api.onchange('usage')
     def _onchange_usage(self):
         if self.usage not in ('internal', 'inventory'):
@@ -177,12 +192,6 @@ class Location(models.Model):
             current_location = current_location.location_id
         return putaway_location
 
-    @api.returns('stock.warehouse', lambda value: value.id)
-    def get_warehouse(self):
-        """ Returns warehouse id of warehouse that contains location """
-        domain = [('view_location_id', 'parent_of', self.ids)]
-        return self.env['stock.warehouse'].search(domain, limit=1)
-
     def should_bypass_reservation(self):
         self.ensure_one()
         return self.usage in ('supplier', 'customer', 'inventory', 'production') or self.scrap_location or (self.usage == 'transit' and not self.company_id)

--- a/addons/stock/models/stock_move.py
+++ b/addons/stock/models/stock_move.py
@@ -409,7 +409,7 @@ class StockMove(models.Model):
             move.forecast_availability = move.product_qty
 
         product_moves = (self - not_product_moves)
-        warehouse_by_location = {loc: loc.get_warehouse() for loc in product_moves.location_id}
+        warehouse_by_location = {loc: loc.warehouse_id for loc in product_moves.location_id}
 
         outgoing_unreserved_moves_per_warehouse = defaultdict(lambda: self.env['stock.move'])
         for move in product_moves:
@@ -670,9 +670,9 @@ class StockMove(models.Model):
             'move_to_match_ids': self.ids,
         }
         if self.picking_type_id.code == 'outgoing':
-            warehouse = self.location_id.get_warehouse()
+            warehouse = self.location_id.warehouse_id
         else:
-            warehouse = self.location_dest_id.get_warehouse()
+            warehouse = self.location_dest_id.warehouse_id
 
         if warehouse:
             action['context']['warehouse'] = warehouse.id
@@ -883,7 +883,7 @@ class StockMove(models.Model):
 
     def _get_forecast_availability_incoming(self):
         self.ensure_one()
-        warehouse = self.location_dest_id.get_warehouse()
+        warehouse = self.location_dest_id.warehouse_id
         self.forecast_availability = self.product_id.with_context(warehouse=warehouse.id, to_date=self.date).virtual_available
         if self.state == 'draft':
             self.forecast_availability += self.product_uom_qty

--- a/addons/stock/models/stock_orderpoint.py
+++ b/addons/stock/models/stock_orderpoint.py
@@ -176,7 +176,7 @@ class StockWarehouseOrderpoint(models.Model):
 
     @api.onchange('location_id')
     def _onchange_location_id(self):
-        warehouse = self.location_id.get_warehouse().id
+        warehouse = self.location_id.warehouse_id.id
         if warehouse:
             self.warehouse_id = warehouse
 
