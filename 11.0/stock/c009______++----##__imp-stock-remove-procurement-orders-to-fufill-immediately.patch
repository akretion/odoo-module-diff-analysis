PR: https://github.com/odoo/odoo/pull/

From: 0e4f3bb95991261c04c08e72b28430acfabdecd1
From: Fabien Pinckaers
Date: 2017-09-08 15:08:05

Structural Changes: 26.9
Total Changes: 456

[IMP] stock: remove procurement orders to fufill immediately

This removes the procurement.order model. To fufill their needs SO, PO, MO and
stock moves now call the _run method of the relevant procurement.group.

This mecanism is now only used for stockable product, tasks now uses their own
independent mecanism.

The _run method will check all the applicable rules and create directly the
needed model to fufill the need.

The modules stock, purchase, mrp, extends the _run method to implement their
specific strategy relevant for the rule type they define.

If an exception happens the message will be logged as a mail messsage on the
source model, for example, if a sales order cannot be fufilled the salesperson
will now see directly the reason.

OLD commit messages:
[WIP] procurement: removing procurement.order in stock, sale, purchase, sale_stock. WIP
fixup! [WIP] procurement: removing procurement.order in stock, sale, purchase, sale_stock. WIP
[IMP] Basic tests
[FIX] test not necessary anymore
[FIX] remove unnecessary print statement
[FIX] unnecessary test + why passing warehouse worked before?
[IMP] purchase: one move by purchase order line
[FIX] purchase: correct inventory tests and pass move_dest_ids among procurements
[FIX] because of bad cherry-pick merge
[IMP] make mrp pass by adding move_dest_ids there too
[IMP] tests of sale_mrp, no need for cancelpropagation then
[IMP] better to consistently use recordsets also for one2many
[FIX] purchase_requisition
[FIX] Exceptions should trigger errors, which should be caught in the tests
[FIX] sale_mrp: remove usage of procurement.order and use sale order name instead of sol
[FIX] stock_dropshipping: add sale_line_id on purchase_line_id
[FIX] Remove pdb
[IMP] add stock_dropshipping files
[IMP] stock: search carrier through sale line instead of procurement group
[IMP] add procrule test and preision needed when updating sol
[FIX] sale_order_dates + [IMP] procurement exceptions by scheduler
[FIX] No need to return task
[IMP] move file as name changes and add corrections
[FIX] Continue Run Schedulers wizard fix
[FIX] name issues of takss
[FIX] updating sale order line, but there is still a problem with the recompute

================================= pseudo patch: =================================

--- a/addons/stock/models/__init__.py
+++ b/addons/stock/models/__init__.py
@@ -2,7 +2,6 @@
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
 from . import barcode
-from . import product
 from . import procurement
 from . import product_strategy
 from . import res_company
@@ -20,3 +19,4 @@ from . import stock_traceability
 from . import stock_warehouse
 from . import stock_scrap
 from . import web_planner
+from . import product

--- a/addons/stock/models/procurement.py
+++ b/addons/stock/models/procurement.py
@@ -11,20 +11,34 @@ from odoo import api, fields, models, registry, _
 from odoo.osv import expression
 from odoo.tools import DEFAULT_SERVER_DATETIME_FORMAT, float_compare, float_round
 
-import logging
+from odoo.exceptions import UserError
 
+import logging
 _logger = logging.getLogger(__name__)
 
-class ProcurementGroup(models.Model):
-    _inherit = 'procurement.group'
-
-    partner_id = fields.Many2one('res.partner', 'Partner')
-
 
 class ProcurementRule(models.Model):
-    """ Pull rules """
-    _inherit = 'procurement.rule'
-
+    """ A rule describe what a procurement should do; produce, buy, move, ... """
+    _name = 'procurement.rule'
+    _description = "Procurement Rule"
+    _order = "sequence, name"
+
+    name = fields.Char(
+        'Name', required=True, translate=True,
+        help="This field will fill the packing origin and the name of its moves")
+    active = fields.Boolean(
+        'Active', default=True,
+        help="If unchecked, it will allow you to hide the rule without removing it.")
+    group_propagation_option = fields.Selection([
+        ('none', 'Leave Empty'),
+        ('propagate', 'Propagate'),
+        ('fixed', 'Fixed')], string="Propagation of Procurement Group", default='propagate')
+    group_id = fields.Many2one('procurement.group', 'Fixed Procurement Group')
+    action = fields.Selection(
+        selection=[('move', 'Move From Another Location')], string='Action',
+        required=True)
+    sequence = fields.Integer('Sequence', default=20)
+    company_id = fields.Many2one('res.company', 'Company')
     location_id = fields.Many2one('stock.location', 'Procurement Location')
     location_src_id = fields.Many2one('stock.location', 'Source Location', help="Source location is action=move")
     route_id = fields.Many2one('stock.location.route', 'Route', required=True, ondelete='cascade')
@@ -48,188 +62,190 @@ class ProcurementRule(models.Model):
         'stock.warehouse', 'Warehouse to Propagate',
         help="The warehouse to propagate on the created move/procurement, which can be different of the warehouse this rule is for (e.g for resupplying rules from another warehouse)")
 
-    @api.model
-    def _get_action(self):
-        result = super(ProcurementRule, self)._get_action()
-        return result + [('move', _('Move From Another Location'))]
-
-
-class ProcurementOrder(models.Model):
-    _inherit = "procurement.order"
-
-    location_id = fields.Many2one('stock.location', 'Procurement Location')  # not required because task may create procurements that aren't linked to a location with sale_service
-    partner_dest_id = fields.Many2one('res.partner', 'Customer Address', help="In case of dropshipping, we need to know the destination address more precisely")
-    move_ids = fields.One2many('stock.move', 'procurement_id', 'Moves', help="Moves created by the procurement")
-    move_dest_id = fields.Many2one('stock.move', 'Destination Move', help="Move which caused (created) the procurement")
-    route_ids = fields.Many2many(
-        'stock.location.route', 'stock_location_route_procurement', 'procurement_id', 'route_id', 'Preferred Routes',
-        help="Preferred route to be followed by the procurement order. Usually copied from the generating document (SO) but could be set up manually.")
-    warehouse_id = fields.Many2one('stock.warehouse', 'Warehouse', help="Warehouse to consider for the route selection")
-    orderpoint_id = fields.Many2one('stock.warehouse.orderpoint', 'Minimum Stock Rule')
-
-    @api.onchange('warehouse_id')
-    def onchange_warehouse_id(self):
-        if self.warehouse_id:
-            self.location_id = self.warehouse_id.lot_stock_id.id
-
-    @api.multi
-    def propagate_cancels(self):
-        # set the context for the propagation of the procurement cancellation
-        # TDE FIXME: was in cancel, moved here for consistency
-        cancel_moves = self.filtered(lambda order: order.rule_id.action == 'move').mapped('move_ids').filtered(lambda m: m.state not in ('cancel', 'done'))
-        if cancel_moves:
-            cancel_moves.action_cancel()
-        return self.search([('move_dest_id', 'in', cancel_moves.filtered(lambda move: move.propagate).ids)])
+class ProcurementGroup(models.Model):
+    """
+    The procurement group class is used to group products together
+    when computing procurements. (tasks, physical products, ...)
+
+    The goal is that when you have one sales order of several products
+    and the products are pulled from the same or several location(s), to keep
+    having the moves grouped into pickings that represent the sales order.
+
+    Used in: sales order (to group delivery order lines like the so), pull/push
+    rules (to pack like the delivery order), on orderpoints (e.g. for wave picking
+    all the similar products together).
+
+    Grouping is made only if the source and the destination is the same.
+    Suppose you have 4 lines on a picking from Output where 2 lines will need
+    to come from Input (crossdock) and 2 lines coming from Stock -> Output As
+    the four will have the same group ids from the SO, the move from input will
+    have a stock.picking with 2 grouped lines and the move from stock will have
+    2 grouped lines also.
+
+    The name is usually the name of the original document (sales order) or a
+    sequence computed if created manually.
+    """
+    _name = 'procurement.group'
+    _description = 'Procurement Requisition'
+    _order = "id desc"
 
-    @api.multi
-    def cancel(self):
-        propagated_procurements = self.filtered(lambda order: order.state != 'done').propagate_cancels()
-        if propagated_procurements:
-            propagated_procurements.cancel()
-        return super(ProcurementOrder, self).cancel()
+    partner_id = fields.Many2one('res.partner', 'Partner')
+    name = fields.Char(
+        'Reference',
+        default=lambda self: self.env['ir.sequence'].next_by_code('procurement.group') or '',
+        required=True)
+    move_type = fields.Selection([
+        ('direct', 'Partial'),
+        ('one', 'All at once')], string='Delivery Type', default='direct',
+        required=True)
+
+    def _make_po_get_domain(self, values, partner):
+        return ()
+
+    def _log_next_activity(self, product_id, note):
+        existing_activity = self.env['mail.activity'].search([('res_id', '=',  product_id.product_tmpl_id.id), ('res_model_id', '=', self.env.ref('product.model_product_template').id),
+                                                              ('note', '=', note)])
+        if not existing_activity:
+            self.env['mail.activity'].create({
+                'activity_type_id': self.env.ref('mail.mail_activity_data_todo').id,
+                'note': note,
+                'user_id': product_id.responsible_id.id,
+                'res_id': product_id.product_tmpl_id.id,
+                'res_model_id': self.env.ref('product.model_product_template').id,
+            })
 
-    @api.multi
-    def do_view_pickings(self):
-        """ Return an action to display the pickings belonging to the same
-        procurement group of given ids. """
-        action = self.env.ref('stock.do_view_pickings').read()[0]
-        action['domain'] = [('group_id', 'in', self.mapped('group_id').ids)]
-        return action
+    @api.model
+    def run(self, values, doraise=True):
+        for key in ('product_id', 'product_uom', 'product_qty', 'location_id', 'name', 'origin'):
+            assert key in values
+        values.setdefault('company_id', self.env['res.company']._company_default_get('procurement.group'))
+        values.setdefault('priority', '1')
+        values.setdefault('date_planned', fields.Datetime.now())
+        rule = self._get_rule(values)
 
-    @api.multi
-    @api.returns('procurement.rule', lambda value: value.id if value else False)
-    def _find_suitable_rule(self):
-        rule = super(ProcurementOrder, self)._find_suitable_rule()
         if not rule:
-            # a rule defined on 'Stock' is suitable for a procurement in 'Stock\Bin A'
-            all_parent_location_ids = self._find_parent_locations()
-            rule = self._search_suitable_rule([('location_id', 'in', all_parent_location_ids.ids)])
-        return rule
-
-    def _find_parent_locations(self):
-        parent_locations = self.env['stock.location']
-        location = self.location_id
-        while location:
-            parent_locations |= location
-            location = location.location_id
-        return parent_locations
+            if doraise:
+                raise UserError(_('No procurement rule found.'))
+            else:
+                msg = _('No procurement rule found. Update the inventory tab of the product form.')
+                if values.get('orderpoint_id', False):
+                    msg = _('No procurement rule found for orderpoint %s. Update the inventory tab of the product form.') % (values['orderpoint_id'].name,)
+                self._log_next_activity(values['product_id'], msg)
+                return False
+        self._run(values, rule, doraise)
+        return True
 
-    def _search_suitable_rule(self, domain):
-        """ First find a rule among the ones defined on the procurement order
+    @api.model
+    def _search_rule(self, values, domain):
+        """ First find a rule among the ones defined on the procurement
         group; then try on the routes defined for the product; finally fallback
         on the default behavior """
-        if self.warehouse_id:
-            domain = expression.AND([['|', ('warehouse_id', '=', self.warehouse_id.id), ('warehouse_id', '=', False)], domain])
+        if values.get('warehouse_id', False):
+            domain = expression.AND([['|', ('warehouse_id', '=', values['warehouse_id'].id), ('warehouse_id', '=', False)], domain])
         Pull = self.env['procurement.rule']
         res = self.env['procurement.rule']
-        if self.route_ids:
-            res = Pull.search(expression.AND([[('route_id', 'in', self.route_ids.ids)], domain]), order='route_sequence, sequence', limit=1)
+        if values.get('route_ids', False):
+            res = Pull.search(expression.AND([[('route_id', 'in', values['route_ids'].ids)], domain]), order='route_sequence, sequence', limit=1)
         if not res:
-            product_routes = self.product_id.route_ids | self.product_id.categ_id.total_route_ids
+            product_routes = values['product_id'].route_ids | values['product_id'].categ_id.total_route_ids
             if product_routes:
                 res = Pull.search(expression.AND([[('route_id', 'in', product_routes.ids)], domain]), order='route_sequence, sequence', limit=1)
         if not res:
-            warehouse_routes = self.warehouse_id.route_ids
+            warehouse_routes = values['warehouse_id'].route_ids
             if warehouse_routes:
                 res = Pull.search(expression.AND([[('route_id', 'in', warehouse_routes.ids)], domain]), order='route_sequence, sequence', limit=1)
         return res
 
-    def _get_stock_move_values(self):
+    @api.model
+    def _get_rule(self, values):
+        result = False
+        location = values['location_id']
+        while (not result) and location:
+            result = self._search_rule(values, [('location_id', '=', location.id)])
+            location = location.location_id
+        return result
+
+    def _get_stock_move_values(self, values, rule, group_id):
         ''' Returns a dictionary of values that will be used to create a stock move from a procurement.
         This function assumes that the given procurement has a rule (action == 'move') set on it.
 
         :param procurement: browse record
         :rtype: dictionary
         '''
-        group_id = False
-        if self.rule_id.group_propagation_option == 'propagate':
-            group_id = self.group_id.id
-        elif self.rule_id.group_propagation_option == 'fixed':
-            group_id = self.rule_id.group_id.id
-        date_expected = (datetime.strptime(self.date_planned, DEFAULT_SERVER_DATETIME_FORMAT) - relativedelta(days=self.rule_id.delay or 0)).strftime(DEFAULT_SERVER_DATETIME_FORMAT)
+        date_expected = (datetime.strptime(values['date_planned'], DEFAULT_SERVER_DATETIME_FORMAT) - relativedelta(days=rule.delay or 0)).strftime(DEFAULT_SERVER_DATETIME_FORMAT)
         # it is possible that we've already got some move done, so check for the done qty and create
         # a new move with the correct qty
-        qty_done = sum(self.move_ids.filtered(lambda move: move.state == 'done').mapped('product_uom_qty'))
-        qty_left = max(self.product_qty - qty_done, 0)
+        qty_left = values['product_qty']
         return {
-            'name': self.name[:2000],
-            'company_id': self.rule_id.company_id.id or self.rule_id.location_src_id.company_id.id or self.rule_id.location_id.company_id.id or self.company_id.id,
-            'product_id': self.product_id.id,
-            'product_uom': self.product_uom.id,
+            'name': values['name'][:2000],
+            'company_id': rule.company_id.id or rule.location_src_id.company_id.id or rule.location_id.company_id.id or values['company_id'].id,
+            'product_id': values['product_id'].id,
+            'product_uom': values['product_uom'].id,
             'product_uom_qty': qty_left,
-            'partner_id': self.rule_id.partner_address_id.id or (self.group_id and self.group_id.partner_id.id) or False,
-            'location_id': self.rule_id.location_src_id.id,
-            'location_dest_id': self.location_id.id,
-            'move_dest_ids': self.move_dest_id and [(4, self.move_dest_id.id)] or False,
-            'procurement_id': self.id,
-            'rule_id': self.rule_id.id,
-            'procure_method': self.rule_id.procure_method,
-            'origin': self.origin,
-            'picking_type_id': self.rule_id.picking_type_id.id,
+            'partner_id': rule.partner_address_id.id or (values['group_id'] and values['group_id'].partner_id.id) or False,
+            'location_id': rule.location_src_id.id,
+            'location_dest_id': values['location_id'].id,
+            'move_dest_ids': values.get('move_dest_ids', False) and [(4, x.id) for x in values['move_dest_ids']] or [],
+            'rule_id': rule.id,
+            'procure_method': rule.procure_method,
+            'origin': values['origin'],
+            'picking_type_id': rule.picking_type_id.id,
             'group_id': group_id,
-            'route_ids': [(4, route.id) for route in self.route_ids],
-            'warehouse_id': self.rule_id.propagate_warehouse_id.id or self.rule_id.warehouse_id.id,
+            'route_ids': [(4, route.id) for route in values.get('route_ids', [])],
+            'warehouse_id': rule.propagate_warehouse_id.id or rule.warehouse_id.id,
             'date': date_expected,
             'date_expected': date_expected,
-            'propagate': self.rule_id.propagate,
-            'priority': self.priority,
+            'propagate': rule.propagate,
+            'priority': values.get('priority', "1"),
         }
 
+    def _merge_domain(self, values, rule, group_id):
+        return [
+            ('group_id', '=', group_id), #extra logic?
+            ('location_id', '=', rule.location_src_id.id),
+            ('location_dest_id', '=', values['location_id'].id),
+            ('picking_type_id', '=', rule.picking_type_id.id),
+            ('picking_id.printed', '=', False),
+            ('picking_id.state', 'in', ['draft', 'confirmed', 'waiting', 'partially_available', 'assigned']),
+            ('picking_id.backorder_id', '=', False),
+            ('product_id', '=', values['product_id'].id)]
+
     @api.multi
-    def _run(self):
-        if self.rule_id.action == 'move':
-            if not self.rule_id.location_src_id:
-                self.message_post(body=_('No source location defined!'))
-                return False
+    def _run(self, values, rule, doraise=True):
+        if rule.action == 'move':
+            if not rule.location_src_id:
+                msg = _('No source location defined on procurement rule: %s!') % (rule.name, )
+                if doraise:
+                    raise UserError(msg)
+                else:
+                    self._log_next_activity(values['product_id'], msg)
+                    return False
+
             # create the move as SUPERUSER because the current user may not have the rights to do it (mto product launched by a sale for example)
-            self.env['stock.move'].sudo().create(self._get_stock_move_values())
+            # Search if picking with move for it exists already:
+            group_id = False
+            if rule.group_propagation_option == 'propagate':
+                group_id = values.get('group_id', False) and values['group_id'].id
+            elif rule.group_propagation_option == 'fixed':
+                group_id = rule.group_id.id
+
+            data = self._get_stock_move_values(values, rule, group_id)
+            # Since action_confirm launch following procurement_group we should activate it.
+            move = self.env['stock.move'].sudo().create(data)
+            move.assign_picking()
+            move.picking_id.action_confirm()
             return True
-        return super(ProcurementOrder, self)._run()
+        return False
 
-    @api.multi
-    def run(self, autocommit=False):
-        # TDE CLEANME: unused context key procurement_auto_defer remove
-        new_self = self.filtered(lambda order: order.state not in ['running', 'done', 'cancel'])
-        res = super(ProcurementOrder, new_self).run(autocommit=autocommit)
-
-        # after all the procurements are run, check if some created a draft stock move that needs to be confirmed
-        # (we do that in batch because it fasts the picking assignation and the picking state computation)
-        new_self.filtered(lambda order: order.state == 'running' and order.rule_id.action == 'move').mapped('move_ids').filtered(lambda move: move.state == 'draft').action_confirm()
-
-        # TDE FIXME: action_confirm in stock_move already call run() ... necessary ??
-        # If procurements created other procurements, run the created in batch
-        new_procurements = self.search([('move_dest_id.procurement_id', 'in', new_self.ids)], order='id')
-        if new_procurements:
-            res = new_procurements.run(autocommit=autocommit)
-        return res
-
-    @api.multi
-    def _check(self):
-        """ Checking rules of type 'move': satisfied only if all related moves
-        are done/cancel and if the requested quantity is moved. """
-        if self.rule_id.action == 'move':
-            # In case Phantom BoM splits only into procurements
-            if not self.move_ids:
-                return True
-            move_all_done_or_cancel = all(move.state in ['done', 'cancel'] for move in self.move_ids)
-            move_all_cancel = all(move.state == 'cancel' for move in self.move_ids)
-            if not move_all_done_or_cancel:
-                return False
-            elif move_all_done_or_cancel and not move_all_cancel:
-                return True
-            else:
-                self.message_post(body=_('All stock moves have been cancelled for this procurement.'))
-                # TDE FIXME: strange that a check method actually modified the procurement...
-                self.write({'state': 'cancel'})
-                return False
-        return super(ProcurementOrder, self)._check()
+    @api.model
+    def _get_exceptions_domain(self):
+        return [('procure_method', '=', 'make_to_order'), ('move_orig_ids', '=', False)]
 
     @api.model
     def run_scheduler(self, use_new_cursor=False, company_id=False):
-        ''' Call the scheduler in order to check the running procurements (super method), to check the minimum stock rules
+        """ Call the scheduler in order to check the running procurements (super method), to check the minimum stock rules
         and the availability of moves. This function is intended to be run for all the companies at the same time, so
-        we run functions as SUPERUSER to avoid intercompanies and access rights issues. '''
-        super(ProcurementOrder, self).run_scheduler(use_new_cursor=use_new_cursor, company_id=company_id)
+        we run functions as SUPERUSER to avoid intercompanies and access rights issues. """
         try:
             if use_new_cursor:
                 cr = registry(self._cr.dbname).cursor()
@@ -241,10 +257,13 @@ class ProcurementOrder(models.Model):
             # Search all confirmed stock_moves and try to assign them
             confirmed_moves = self.env['stock.move'].search([('state', '=', 'confirmed')], limit=None, order='priority desc, date_expected asc')
             for moves_chunk in split_every(100, confirmed_moves.ids):
-                # TDE CLEANME: muf muf
                 self.env['stock.move'].browse(moves_chunk).action_assign()
                 if use_new_cursor:
                     self._cr.commit()
+                    
+            exception_moves = self.env['stock.move'].search(self._get_exceptions_domain())
+            for move in exception_moves:
+                self.env['procurement.group'].run(move._prepare_procurement_from_move(), doraise=False)
             if use_new_cursor:
                 self._cr.commit()
         finally:
@@ -295,9 +314,6 @@ class ProcurementOrder(models.Model):
                 cr = registry(self._cr.dbname).cursor()
                 self = self.with_env(self.env(cr=cr))
             OrderPoint = self.env['stock.warehouse.orderpoint']
-            Procurement = self.env['procurement.order']
-            ProcurementAutorundefer = Procurement.with_context(procurement_autorun_defer=True)
-            procurement_list = []
 
             orderpoints = OrderPoint.browse(orderpoints_noprefetch[:1000])
             orderpoints_noprefetch = orderpoints_noprefetch[1000:]
@@ -313,7 +329,7 @@ class ProcurementOrder(models.Model):
             for location_id, location_data in location_data.items():
                 location_orderpoints = location_data['orderpoints']
                 product_context = dict(self._context, location=location_orderpoints[0].location_id.id)
-                substract_quantity = location_orderpoints.subtract_procurements_from_orderpoints()
+                substract_quantity = location_orderpoints._quantity_in_progress()
 
                 for group in location_data['groups']:
                     if group.get('from_date'):
@@ -339,12 +355,8 @@ class ProcurementOrder(models.Model):
                                 qty -= substract_quantity[orderpoint.id]
                                 qty_rounded = float_round(qty, precision_rounding=orderpoint.product_uom.rounding)
                                 if qty_rounded > 0:
-                                    new_procurement = ProcurementAutorundefer.create(
-                                        orderpoint._prepare_procurement_values(qty_rounded, **group['procurement_values']))
-                                    procurement_list.append(new_procurement)
-                                    new_procurement.message_post_with_view('mail.message_origin_link',
-                                        values={'self': new_procurement, 'origin': orderpoint},
-                                        subtype_id=self.env.ref('mail.mt_note').id)
+                                    self.env['procurement.group'].run(
+                                        orderpoint._prepare_procurement_values(qty_rounded, **group['procurement_values']), doraise=False)
                                     self._procurement_from_orderpoint_post_process([orderpoint.id])
                                 if use_new_cursor:
                                     cr.commit()
@@ -358,12 +370,6 @@ class ProcurementOrder(models.Model):
                                 raise
 
             try:
-                # TDE CLEANME: use record set ?
-                procurement_list.reverse()
-                procurements = self.env['procurement.order']
-                for p in procurement_list:
-                    procurements += p
-                procurements.run()
                 if use_new_cursor:
                     cr.commit()
             except OperationalError:
@@ -378,3 +384,4 @@ class ProcurementOrder(models.Model):
                 cr.close()
 
         return {}
+

--- a/addons/stock/models/product.py
+++ b/addons/stock/models/product.py
@@ -70,8 +70,7 @@ class Product(models.Model):
              "any of its children.\n"
              "Otherwise, this includes goods leaving any Stock "
              "Location with 'internal' type.")
-    # TDE CLEANME: unused except in one test
-    orderpoint_ids = fields.One2many('stock.warehouse.orderpoint', 'product_id', 'Minimum Stock Rules')
+
     nbr_reordering_rules = fields.Integer('Reordering Rules', compute='_compute_nbr_reordering_rules')
     reordering_min_qty = fields.Float(compute='_compute_nbr_reordering_rules')
     reordering_max_qty = fields.Float(compute='_compute_nbr_reordering_rules')
@@ -370,11 +369,8 @@ class Product(models.Model):
 class ProductTemplate(models.Model):
     _inherit = 'product.template'
 
+    responsible_id = fields.Many2one('res.users', string='Responsible', default=lambda self: self.env.uid, required=True)
     type = fields.Selection(selection_add=[('product', 'Stockable Product')])
-    property_stock_procurement = fields.Many2one(
-        'stock.location', "Procurement Location",
-        company_dependent=True, domain=[('usage', 'like', 'procurement')],
-        help="This stock location will be used, instead of the default one, as the source location for stock moves generated by procurements.")
     property_stock_production = fields.Many2one(
         'stock.location', "Production Location",
         company_dependent=True, domain=[('usage', 'like', 'production')],

--- a/addons/stock/models/stock_inventory.py
+++ b/addons/stock/models/stock_inventory.py
@@ -176,12 +176,10 @@ class Inventory(models.Model):
     def action_check(self):
         """ Checks the inventory and computes the stock move to do """
         # tde todo: clean after _generate_moves
-        for inventory in self:
+        for inventory in self.filtered(lambda x: x.state not in ('done','cancel')):
             # first remove the existing stock moves linked to this inventory
             inventory.mapped('move_ids').unlink()
-            for line in inventory.line_ids:
-                # compare the checked quantities on inventory lines to the theorical one
-                stock_move = line._generate_moves()
+            inventory.line_ids._generate_moves()
 
     @api.multi
     def action_cancel_draft(self):
@@ -447,8 +445,8 @@ class InventoryLine(models.Model):
                 continue
             diff = line.theoretical_qty - line.product_qty
             if diff < 0:  # found more than expected
-                vals = self._get_move_values(abs(diff), line.product_id.property_stock_inventory.id, line.location_id.id, False)
+                vals = line._get_move_values(abs(diff), line.product_id.property_stock_inventory.id, line.location_id.id, False)
             else:
-                vals = self._get_move_values(abs(diff), line.location_id.id, line.product_id.property_stock_inventory.id, True)
+                vals = line._get_move_values(abs(diff), line.location_id.id, line.product_id.property_stock_inventory.id, True)
             moves |= self.env['stock.move'].create(vals)
         return moves

--- a/addons/stock/models/stock_location.py
+++ b/addons/stock/models/stock_location.py
@@ -189,7 +189,7 @@ class PushedFlow(models.Model):
     name = fields.Char('Operation Name', required=True)
     company_id = fields.Many2one(
         'res.company', 'Company',
-        default=lambda self: self.env['res.company']._company_default_get('procurement.order'), index=True)
+        default=lambda self: self.env['res.company']._company_default_get('stock.location.path'), index=True)
     route_id = fields.Many2one('stock.location.route', 'Route', required=True, ondelete='cascade')
     location_from_id = fields.Many2one(
         'stock.location', 'Source Location', index=True, ondelete='cascade', required=True,
@@ -243,7 +243,6 @@ class PushedFlow(models.Model):
                 'propagate': self.propagate,
                 'push_rule_id': self.id,
                 'warehouse_id': self.warehouse_id.id,
-                'procurement_id': False,
             }
 
         return new_move_vals

--- a/addons/stock/models/stock_move.py
+++ b/addons/stock/models/stock_move.py
@@ -8,11 +8,11 @@ from operator import itemgetter
 
 from odoo import api, fields, models, _
 from odoo.addons import decimal_precision as dp
-from odoo.addons.procurement.models import procurement
 from odoo.exceptions import UserError
 from odoo.tools import DEFAULT_SERVER_DATETIME_FORMAT
 from odoo.tools.float_utils import float_compare, float_round, float_is_zero
 
+PROCUREMENT_PRIORITIES = [('0', 'Not urgent'), ('1', 'Normal'), ('2', 'Urgent'), ('3', 'Very Urgent')]
 
 class StockMove(models.Model):
     _name = "stock.move"
@@ -26,7 +26,7 @@ class StockMove(models.Model):
 
     name = fields.Char('Description', index=True, required=True)
     sequence = fields.Integer('Sequence', default=10)
-    priority = fields.Selection(procurement.PROCUREMENT_PRIORITIES, 'Priority', default='1')
+    priority = fields.Selection(PROCUREMENT_PRIORITIES, 'Priority', default='1')
     create_date = fields.Datetime('Creation Date', index=True, readonly=True)
     date = fields.Datetime(
         'Date', default=fields.Datetime.now, index=True, required=True,
@@ -122,7 +122,6 @@ class StockMove(models.Model):
              "this second option should be chosen.")
     scrapped = fields.Boolean('Scrapped', related='location_dest_id.scrap_location', readonly=True, store=True)
     scrap_ids = fields.One2many('stock.scrap', 'move_id')
-    procurement_id = fields.Many2one('procurement.order', 'Procurement')
     group_id = fields.Many2one('procurement.group', 'Procurement Group', default=_default_group_id)
     rule_id = fields.Many2one('procurement.rule', 'Procurement Rule', ondelete='restrict', help='The procurement rule that created this stock move')
     push_rule_id = fields.Many2one('stock.location.path', 'Push Rule', ondelete='restrict', help='The push rule that created this stock move')
@@ -146,7 +145,7 @@ class StockMove(models.Model):
         'Availability', compute='_compute_string_qty_information',
         readonly=True, help='Show various information on stock availability for this move')
     restrict_partner_id = fields.Many2one('res.partner', 'Owner ', help="Technical field used to depict a restriction on the ownership of quants to consider when marking this move as 'done'")
-    route_ids = fields.Many2many('stock.location.route', 'stock_location_route_move', 'move_id', 'route_id', 'Destination route', help="Preferred route to be followed by the procurement order")
+    route_ids = fields.Many2many('stock.location.route', 'stock_location_route_move', 'move_id', 'route_id', 'Destination route', help="Preferred route")
     warehouse_id = fields.Many2one('stock.warehouse', 'Warehouse', help="Technical field depicting the warehouse to consider for the route selection on the next procurement (if any).")
     has_tracking = fields.Selection(related='product_id.tracking', string='Product with Tracking')
     quantity_done = fields.Float('Quantity Done', compute='_quantity_done_compute', digits=dp.get_precision('Product Unit of Measure'), inverse='_quantity_done_set',
@@ -589,11 +588,8 @@ class StockMove(models.Model):
                 to_assign[key] |= move
 
         # create procurements for make to order moves
-        procurements = self.env['procurement.order']
         for move in move_create_proc:
-            procurements |= procurements.create(move._prepare_procurement_from_move())
-        if procurements:
-            procurements.run()
+            self.env['procurement.group'].run(move._prepare_procurement_from_move())
 
         move_to_confirm.write({'state': 'confirmed'})
         (move_waiting | move_create_proc).write({'state': 'waiting'})
@@ -607,25 +603,25 @@ class StockMove(models.Model):
     def _prepare_procurement_from_move(self):
         self.ensure_one()
         origin = (self.group_id and (self.group_id.name + ":") or "") + (self.rule_id and self.rule_id.name or self.origin or self.picking_id.name or "/")
-        group_id = self.group_id and self.group_id.id or False
+        group_id = self.group_id or False
         if self.rule_id:
             if self.rule_id.group_propagation_option == 'fixed' and self.rule_id.group_id:
-                group_id = self.rule_id.group_id.id
+                group_id = self.rule_id.group_id
             elif self.rule_id.group_propagation_option == 'none':
                 group_id = False
         return {
             'name': self.rule_id and self.rule_id.name or "/",
             'origin': origin,
-            'company_id': self.company_id.id,
+            'company_id': self.company_id,
             'date_planned': self.date,
-            'product_id': self.product_id.id,
+            'product_id': self.product_id,
             'product_qty': self.product_uom_qty,
-            'product_uom': self.product_uom.id,
-            'location_id': self.location_id.id,
-            'move_dest_id': self.id,
+            'product_uom': self.product_uom,
+            'location_id': self.location_id,
+            'move_dest_ids': self,
             'group_id': group_id,
-            'route_ids': [(4, x.id) for x in self.route_ids],
-            'warehouse_id': self.warehouse_id.id or (self.picking_type_id and self.picking_type_id.warehouse_id.id or False),
+            'route_ids': self.route_ids,
+            'warehouse_id': self.warehouse_id or self.picking_id.picking_type_id.warehouse_id or self.picking_type_id.warehouse_id,
             'priority': self.priority,
         }
 
@@ -813,7 +809,6 @@ class StockMove(models.Model):
                     move.move_dest_ids.write({'procure_method': 'make_to_stock'})
                     move.move_dest_ids.write({'move_orig_ids': [(3, move.id, 0)]})
         self.write({'state': 'cancel', 'move_orig_ids': [(5, 0, 0)]})
-        self.mapped('procurement_id').check()
         return True
 
     def _prepare_extra_move_vals(self, qty):
@@ -832,7 +827,6 @@ class StockMove(models.Model):
         The rationale for the creation of an extra move is the application of a potential push
         rule that will handle the extra quantities.
         """
-        self.ensure_one()
         extra_move = self.env['stock.move']
         rounding = self.product_uom.rounding
         # moves created after the picking is assigned do not have `product_uom_qty`, but we shouldn't create extra moves for them
@@ -933,7 +927,6 @@ class StockMove(models.Model):
         vals = {
             'product_uom_qty': uom_qty,
             'procure_method': 'make_to_stock',
-            'procurement_id': self.procurement_id.id,
             'move_dest_ids': [(4, x.id) for x in self.move_dest_ids if x.state not in ('done', 'cancel')],
             'move_orig_ids': [(4, x.id) for x in self.move_orig_ids],
             'origin_returned_move_id': self.origin_returned_move_id.id,
@@ -960,6 +953,7 @@ class StockMove(models.Model):
         # HALF-UP rounding as only rounding errors will be because of propagation of error from default UoM
         uom_qty = self.product_id.uom_id._compute_quantity(qty, self.product_uom, rounding_method='HALF-UP')
         defaults = self._prepare_move_split_vals(uom_qty)
+
         if restrict_partner_id:
             defaults['restrict_partner_id'] = restrict_partner_id
 

--- a/addons/stock/models/stock_picking.py
+++ b/addons/stock/models/stock_picking.py
@@ -9,8 +9,8 @@ from itertools import groupby
 from odoo import api, fields, models, _
 from odoo.tools import DEFAULT_SERVER_DATETIME_FORMAT
 from odoo.tools.float_utils import float_compare, float_round
-from odoo.addons.procurement.models import procurement
 from odoo.exceptions import UserError
+from odoo.addons.stock.models.stock_move import PROCUREMENT_PRIORITIES
 from operator import itemgetter
 
 
@@ -213,7 +213,7 @@ class Picking(models.Model):
         readonly=True, related='move_lines.group_id', store=True)
 
     priority = fields.Selection(
-        procurement.PROCUREMENT_PRIORITIES, string='Priority',
+        PROCUREMENT_PRIORITIES, string='Priority',
         compute='_compute_priority', inverse='_set_priority', store=True,
         # default='1', required=True,  # TDE: required, depending on moves ? strange
         index=True, track_visibility='onchange',
@@ -709,7 +709,6 @@ class Picking(models.Model):
             'location_id': picking.location_id.id,
             'location_dest_id': picking.location_dest_id.id,
             'product_id': product.id,
-            'procurement_id': proc_id,
             'product_uom': uom_id,
             'product_uom_qty': qty,
             'name': _('Extra Move: ') + name,

--- a/addons/stock/models/stock_warehouse.py
+++ b/addons/stock/models/stock_warehouse.py
@@ -8,7 +8,7 @@ from dateutil import relativedelta
 from odoo import api, fields, models, _
 from odoo.addons import decimal_precision as dp
 from odoo.exceptions import UserError, ValidationError
-from odoo.tools import DEFAULT_SERVER_DATE_FORMAT
+from odoo.tools import DEFAULT_SERVER_DATETIME_FORMAT
 
 import logging
 
@@ -769,7 +769,6 @@ class Orderpoint(models.Model):
         'Qty Multiple', digits=dp.get_precision('Product Unit of Measure'),
         default=1, required=True,
         help="The procurement quantity will be rounded up to this multiple.  If it is 0, the exact quantity will be used.")
-    procurement_ids = fields.One2many('procurement.order', 'orderpoint_id', 'Created Procurements')
     group_id = fields.Many2one(
         'procurement.group', 'Procurement Group', copy=False,
         help="Moves created through this orderpoint will be put in this procurement group. If none is given, the moves generated by procurement rules will be grouped into one big picking.")
@@ -787,6 +786,12 @@ class Orderpoint(models.Model):
         ('qty_multiple_check', 'CHECK( qty_multiple >= 0 )', 'Qty Multiple must be greater than or equal to zero.'),
     ]
 
+    @api.multi
+    def _quantity_in_progress(self):
+        """Return Quantities that are not yet in virtual stock but should be deduced from orderpoint rule
+        (example: purchases created from orderpoints)"""
+        return dict(self.mapped(lambda x: (x.id, 0.0)))
+
     @api.constrains('product_id')
     def _check_product_uom(self):
         ''' Check if the UoM has the same category as the product standard UoM '''
@@ -806,32 +811,6 @@ class Orderpoint(models.Model):
             return {'domain':  {'product_uom': [('category_id', '=', self.product_id.uom_id.category_id.id)]}}
         return {'domain': {'product_uom': []}}
 
-    @api.multi
-    def subtract_procurements_from_orderpoints(self):
-        '''This function returns quantity of product that needs to be deducted from the orderpoint computed quantity because there's already a procurement created with aim to fulfill it.
-        '''
-        self._cr.execute("""SELECT orderpoint.id, procurement.id, procurement.product_uom, procurement.product_qty, template.uom_id, move.product_qty
-            FROM stock_warehouse_orderpoint orderpoint
-            JOIN procurement_order AS procurement ON procurement.orderpoint_id = orderpoint.id
-            JOIN product_product AS product ON product.id = procurement.product_id
-            JOIN product_template AS template ON template.id = product.product_tmpl_id
-            LEFT JOIN stock_move AS move ON move.procurement_id = procurement.id
-            WHERE procurement.state not in ('done', 'cancel')
-                AND (move.state IS NULL OR move.state != 'draft')
-                AND orderpoint.id IN %s
-            ORDER BY orderpoint.id, procurement.id
-        """, (tuple(self.ids),))
-        UoM = self.env["product.uom"]
-        procurements_done = set()
-        res = dict.fromkeys(self.ids, 0.0)
-        for orderpoint_id, procurement_id, product_uom_id, procurement_qty, template_uom_id, move_qty in self._cr.fetchall():
-            if procurement_id not in procurements_done:  # count procurement once, if multiple move in this orderpoint/procurement combo
-                procurements_done.add(procurement_id)
-                res[orderpoint_id] += UoM.browse(product_uom_id)._compute_quantity(procurement_qty, UoM.browse(template_uom_id), round=False)
-            if move_qty:
-                res[orderpoint_id] -= move_qty
-        return res
-
     def _get_date_planned(self, product_qty, start_date):
         days = self.lead_days or 0.0
         if self.lead_type == 'supplier':
@@ -841,20 +820,20 @@ class Orderpoint(models.Model):
                 date=fields.Date.to_string(start_date),
                 uom_id=self.product_uom).delay or 0.0
         date_planned = start_date + relativedelta.relativedelta(days=days)
-        return date_planned.strftime(DEFAULT_SERVER_DATE_FORMAT)
+        return date_planned.strftime(DEFAULT_SERVER_DATETIME_FORMAT)
 
     @api.multi
     def _prepare_procurement_values(self, product_qty, date=False, group=False):
         return {
             'name': self.name,
             'date_planned': date or self._get_date_planned(product_qty, datetime.today()),
-            'product_id': self.product_id.id,
+            'product_id': self.product_id,
             'product_qty': product_qty,
-            'company_id': self.company_id.id,
-            'product_uom': self.product_uom.id,
-            'location_id': self.location_id.id,
+            'company_id': self.company_id,
+            'product_uom': self.product_uom,
+            'location_id': self.location_id,
             'origin': self.name,
-            'warehouse_id': self.warehouse_id.id,
-            'orderpoint_id': self.id,
-            'group_id': group or self.group_id.id,
+            'warehouse_id': self.warehouse_id,
+            'orderpoint_id': self,
+            'group_id': group or self.group_id,
         }
