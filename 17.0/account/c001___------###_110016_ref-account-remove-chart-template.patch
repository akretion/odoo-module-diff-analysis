PR: https://github.com/odoo/odoo/pull/110016

From: 512574861691f425ec6a17f20fe4b586bb88a299
From: wan
Date: 2023-02-17 18:30:40

Breaking data model changes scores: del:126.8 + add:0, change matches:
-    code_prefix_start = fields.Char()
-    code_prefix_end = fields.Char()
+    code_prefix_start = fields.Char(compute='_compute_code_prefix_start', readonly=False, store=True, precompute=True)
+    code_prefix_end = fields.Char(compute='_compute_code_prefix_end', readonly=False, store=True, precompute=True)
-    chart_template_id = fields.Many2one(string="Chart of Accounts", comodel_name='account.chart.template')
-    property_tax_payable_account_id = fields.Many2one(
-    property_tax_receivable_account_id = fields.Many2one(
-    property_advance_tax_payment_account_id = fields.Many2one(
-    parent_id = fields.Many2one('account.group.template', ondelete='cascade')
-    code_prefix_start = fields.Char()
-    code_prefix_end = fields.Char()
-    chart_template_id = fields.Many2one('account.chart.template', string='Chart Template', required=True)
-    _inherit = ['mail.thread']
-    name = fields.Char(required=True)
-    currency_id = fields.Many2one('res.currency', string='Account Currency', help="Forces all moves for this account to have this secondary currency.")
-    code = fields.Char(size=64, required=True)
-    account_type = fields.Selection(
-    reconcile = fields.Boolean(string='Allow Invoices & payments Matching', default=False,
-    note = fields.Text()
-    tax_ids = fields.Many2many('account.tax.template', 'account_account_template_tax_rel', 'account_id', 'tax_id', string='Default Taxes')
-    nocreate = fields.Boolean(string='Optional Create', default=False,
-    chart_template_id = fields.Many2one('account.chart.template', string='Chart Template',
-    tag_ids = fields.Many2many('account.account.tag', 'account_account_template_account_tag', string='Account tag', help="Optional tags you may want to assign for custom reporting")
-    chart_template_id = fields.Many2one('account.chart.template', string='Chart Template', required=True)
-    name = fields.Char(string='Tax Name', required=True)
-    type_tax_use = fields.Selection(TYPE_TAX_USE, string='Tax Type', required=True, default="sale",
-    tax_scope = fields.Selection([('service', 'Service'), ('consu', 'Consumable')], help="Restrict the use of taxes to a type of product.")
-    amount_type = fields.Selection(default='percent', string="Tax Computation", required=True,
-    active = fields.Boolean(default=True, help="Set active to false to hide the tax without removing it.")
-    children_tax_ids = fields.Many2many('account.tax.template', 'account_tax_template_filiation_rel', 'parent_tax', 'child_tax', string='Children Taxes')
-    sequence = fields.Integer(required=True, default=1,
-    amount = fields.Float(required=True, digits=(16, 4), default=0)
-    description = fields.Char(string='Display on Invoices')
-    price_include = fields.Boolean(string='Included in Price', default=False,
-    include_base_amount = fields.Boolean(string='Affect Subsequent Taxes', default=False,
-    is_base_affected = fields.Boolean(
-    analytic = fields.Boolean(string="Analytic Cost", help="If set, the amount computed by this tax will be assigned to the same analytic account as the invoice line (if any)")
-    invoice_repartition_line_ids = fields.One2many(string="Repartition for Invoices", comodel_name="account.tax.repartition.line.template", inverse_name="invoice_tax_id", copy=True, help="Repartition when the tax is used on an invoice")
-    refund_repartition_line_ids = fields.One2many(string="Repartition for Refund Invoices", comodel_name="account.tax.repartition.line.template", inverse_name="refund_tax_id", copy=True, help="Repartition when the tax is used on a refund")
-    tax_group_id = fields.Many2one('account.tax.group', string="Tax Group")
-    tax_exigibility = fields.Selection(
-    cash_basis_transition_account_id = fields.Many2one(
-    factor_percent = fields.Float(
-    repartition_type = fields.Selection(string="Based On", selection=[('base', 'Base'), ('tax', 'of tax')], required=True, default='tax', help="Base on which the factor will be applied.")
-    account_id = fields.Many2one(string="Account", comodel_name='account.account.template', help="Account on which to post the tax amount")
-    invoice_tax_id = fields.Many2one(comodel_name='account.tax.template', help="The tax set to apply this distribution on invoices. Mutually exclusive with refund_tax_id")
-    refund_tax_id = fields.Many2one(comodel_name='account.tax.template', help="The tax set to apply this distribution on refund invoices. Mutually exclusive with invoice_tax_id")
-    tag_ids = fields.Many2many(string="Financial Tags", relation='account_tax_repartition_financial_tags', comodel_name='account.account.tag', copy=True, help="Additional tags that will be assigned by this repartition line for use in domains")
-    use_in_tax_closing = fields.Boolean(string="Tax Closing Entry")
-    plus_report_expression_ids = fields.Many2many(string="Plus Tax Report Expressions", relation='account_tax_rep_template_plus', comodel_name='account.report.expression', copy=True, help="Tax report expressions whose '+' tag will be assigned to move lines by this repartition line")
-    minus_report_expression_ids = fields.Many2many(string="Minus Report Expressions", relation='account_tax_rep_template_minus', comodel_name='account.report.expression', copy=True, help="Tax report expressions whose '-' tag will be assigned to move lines by this repartition line")
-    sequence = fields.Integer()
-    name = fields.Char(string='Fiscal Position Template', required=True)
-    chart_template_id = fields.Many2one('account.chart.template', string='Chart Template', required=True)
-    account_ids = fields.One2many('account.fiscal.position.account.template', 'position_id', string='Account Mapping')
-    tax_ids = fields.One2many('account.fiscal.position.tax.template', 'position_id', string='Tax Mapping')
-    note = fields.Text(string='Notes')
-    auto_apply = fields.Boolean(string='Detect Automatically', help="Apply tax & account mappings on invoices automatically if the matching criterias (VAT/Country) are met.")
-    vat_required = fields.Boolean(string='VAT required', help="Apply only if partner has a VAT number.")
-    country_id = fields.Many2one('res.country', string='Country',
-    country_group_id = fields.Many2one('res.country.group', string='Country Group',
-    state_ids = fields.Many2many('res.country.state', string='Federal States')
-    zip_from = fields.Char(string='Zip Range From')
-    zip_to = fields.Char(string='Zip Range To')
-    position_id = fields.Many2one('account.fiscal.position.template', string='Fiscal Position', required=True, ondelete='cascade')
-    tax_src_id = fields.Many2one('account.tax.template', string='Tax Source', required=True)
-    tax_dest_id = fields.Many2one('account.tax.template', string='Replacement Tax')
-    position_id = fields.Many2one('account.fiscal.position.template', string='Fiscal Mapping', required=True, ondelete='cascade')
-    account_src_id = fields.Many2one('account.account.template', string='Account Source', required=True)
-    account_dest_id = fields.Many2one('account.account.template', string='Account Destination', required=True)
-    chart_template_id = fields.Many2one('account.chart.template', string='Chart Template', required=True)
-    name = fields.Char(string='Button Label', required=True)
-    sequence = fields.Integer(required=True, default=10)
-    rule_type = fields.Selection(selection=[
-    auto_reconcile = fields.Boolean(string='Auto-validate',
-    to_check = fields.Boolean(string='To Check', default=False, help='This matching rule is used when the user is not certain of all the information of the counterpart.')
-    matching_order = fields.Selection(
-    match_text_location_label = fields.Boolean(
-    match_text_location_note = fields.Boolean(
-    match_text_location_reference = fields.Boolean(
-    match_journal_ids = fields.Many2many('account.journal', string='Journals Availability',
-    match_nature = fields.Selection(selection=[
-    match_amount = fields.Selection(selection=[
-    match_amount_min = fields.Float(string='Amount Min Parameter')
-    match_amount_max = fields.Float(string='Amount Max Parameter')
-    match_label = fields.Selection(selection=[
-    match_label_param = fields.Char(string='Label Parameter')
-    match_note = fields.Selection(selection=[
-    match_note_param = fields.Char(string='Note Parameter')
-    match_transaction_type = fields.Selection(selection=[
-    match_transaction_type_param = fields.Char(string='Transaction Type Parameter')
-    match_same_currency = fields.Boolean(string='Same Currency', default=True,
-    allow_payment_tolerance = fields.Boolean(
-    payment_tolerance_param = fields.Float(
-    payment_tolerance_type = fields.Selection(
-    match_partner = fields.Boolean(string='Partner Is Set',
-    match_partner_ids = fields.Many2many('res.partner', string='Restrict Partners to',
-    match_partner_category_ids = fields.Many2many('res.partner.category', string='Restrict Partner Categories to',
-    line_ids = fields.One2many('account.reconcile.model.line.template', 'model_id')
-    decimal_separator = fields.Char(help="Every character that is nor a digit nor this separator will be removed from the matching string")
-    model_id = fields.Many2one('account.reconcile.model.template')
-    sequence = fields.Integer(required=True, default=10)
-    account_id = fields.Many2one('account.account.template', string='Account', ondelete='cascade', domain=[('deprecated', '=', False)])
-    label = fields.Char(string='Journal Item Label')
-    amount_type = fields.Selection([
-    amount_string = fields.Char(string="Amount")
-    force_tax_included = fields.Boolean(string='Tax Included in Price', help='Force the tax to be managed as a price included tax.')
-    tax_ids = fields.Many2many('account.tax.template', string='Taxes', ondelete='restrict')
-    chart_template_id = fields.Many2one('account.chart.template', help='The chart template for the company (if any)')
-    property_stock_account_input_categ_id = fields.Many2one('account.account', string="Input Account for Stock Valuation")
-    property_stock_account_output_categ_id = fields.Many2one('account.account', string="Output Account for Stock Valuation")
-    property_stock_valuation_account_id = fields.Many2one('account.account', string="Account Template for Stock Valuation")
-    name = fields.Char(string='Fiscal Position', required=True)
-    chart_template_id = fields.Many2one('account.chart.template', string='Template', default=lambda self: self.env.company.chart_template_id,

Total Changes: 2759

[REF] account: remove chart template

Rewrite the whole chart template mechanism, removing the templates
stored in the database. The new format will mainly use CSV.

Speed up install time
*--------------------

* About half of the time of installing a localization for the first time is
  taken by creating the template records. This new in code format gets
  completely rid of this.
* Creating the template records could often not be done in batch because
  of parent/children relations.
* The instanciation of the accounts on the company has been entirely
  reworked too, by
  - optimizing the order of creation of records to avoid UPDATE queries
  - using precomputed fields to avoid UPDATE queries
  - updating the translation in batch
  - deactivating logging in the chatter
  - avoiding access rights checks by checking the rights at the start

Overall, when installing a chart template for the first time, it is 4
times faster because half of the time spent on saving the template in
the database is not done at all anymore, and the instanciation on the
company is more than twice as fast.

Reduce technical debt
*--------------------

There is no need to synchronize the templates with the real records
anymore. No need to use hooks to copy the data from one to the other.

It is easier to change a template in a stable version, which can often
be necessary due to legal reasons (i.e. a change of tax rates, reporting
tags,...)

Two modules have been removed:
* `l10n_generic_coa`: since there is nothing left datawise in this
  module, it can be integrated in `account` for free. It is just code
  and CSV.
* `l10n_multilang`: the fields that this module modified to be
  translatable are now always translatable:
  - there was an issue when updating modules that deleted all the
    translations because the fields were not translatable at some point
    during the loading of the registry, then they because translatable
    again but lost all translations because of the column type change.
  - most devs are not able to understand all the languages needed for
    all the localization available. Therefore, english has been added in
    the sources in most localization to understand better issues while
    debugging.
  - no need to call post init hooks anymore, doing the sync with the
    templates.
  - more: see "Translations" section

Because most of the data is now in CSV, it is also easier for product
owners to edit, audit, modify files themselves, removing one layer
during trivial development processes when only data should be changed.

More flexibility for declaration
*-------------------------------

The data declaration can now be done easily in python or CSV.
A nice feature is that you can declare everything at once, even for some
more complex chart of accounts:
* if you have to set default taxes on accounts, would need to
  - declare the accounts because accounts are required on the taxes
  - declare the taxes
  - declare the taxes to put on the accounts
  This would lead to scatter information in multiple files. Now,
  everything can be declared in the same place and the loading of the
  chart of accounts will do the 3 steps automatically.
* if you have a relation of child/parent, you would first need to
  declare the parents then the children, and the loading would not be
  efficient because done one by one. Now, everything is done in batch
  automatically without having to think about it.

It is also easier to update fields on records where there was no field
for that on the templates, like
* setting a restriction for journals on accounts
* setting specific values on the company
* modifying journals and linking them easily by using the xml_id instead
  of having to compute it manually

Translations
*-----------

Some countries have multiple languages (i.e. Belgium uses officially
French, Dutch and German, and the CoA also has an official English
version) and we must support the languages in all these countries.
All these translations are known, and hard coded without using out
translation platform (Transifex). We also like to have the English
version (even if an official one doesn't exist) so that support can be
done more easily in databases using chart templates in other languages
(especially using a non roman alphabet).

Because the translations were not on Transifex for these records, it was
really hard to maintain: the translation templates (`.pot` files) were
not easy to extract as the automatic export would give values mixing
both the CoA and the menuitmes, the fields' strings,... But we don't
want to translate the CoA as we already know the value.
Managing the translations in the `.po` files was also annoying:
* it is easy to forget that the translations need an update too
* it requires a special editor, special terminal commands that everyone
  is not familiar with
* it is easy to make mistakes in the source string

The new format is the following: `field@en_US` where `field` is the
translatable field (usually `name`) and `en_US` is the locale code.
This allows to have the whole declaration on one line, everything in one
file. It also makes the process easier when debugging: instead of
searching for the translation in the `.po` files, it directly appears
next to the configuration of the account/tax/... .

Update of the code
*-----------------

The code can be updated using this script
https://github.com/william-andre/transform_coa
Forward ports can be managed too by stashing/resetting/checkout the new
modules or the changes in the modules updated in the same PR.

task-2687567

Part-of: odoo/odoo#110016

================================= pseudo patch: =================================

--- a/addons/account/models/__init__.py
+++ b/addons/account/models/__init__.py
@@ -32,5 +32,7 @@ from . import account_incoterms
 from . import digest
 from . import res_users
 from . import ir_actions_report
+from . import ir_module
 from . import res_currency
 from . import account_report
+from . import template_generic_coa

--- a/addons/account/models/account_account.py
+++ b/addons/account/models/account_account.py
@@ -34,7 +34,7 @@ class AccountAccount(models.Model):
                 account_unaffected_earnings = self.browse(res['ids'])
                 raise ValidationError(_('You cannot have more than one account with "Current Year Earnings" as type. (accounts: %s)', [a.code for a in account_unaffected_earnings]))
 
-    name = fields.Char(string="Account Name", required=True, index='trigram', tracking=True)
+    name = fields.Char(string="Account Name", required=True, index='trigram', tracking=True, translate=True)
     currency_id = fields.Many2one('res.currency', string='Account Currency', tracking=True,
         help="Forces all journal items in this account to have a specific currency (i.e. bank journals). If no currency is set, entries can use any currency.")
     code = fields.Char(size=64, required=True, tracking=True)
@@ -68,8 +68,8 @@ class AccountAccount(models.Model):
     )
     include_initial_balance = fields.Boolean(string="Bring Accounts Balance Forward",
         help="Used in reports to know if we should consider journal items from the beginning of time instead of from the fiscal year only. Account types that should be reset to zero at each new fiscal year (like expenses, revenue..) should not have this option set.",
-        compute="_compute_include_initial_balance",
-        store=True)
+        compute="_compute_include_initial_balance", store=True, precompute=True,
+    )
     internal_group = fields.Selection(
         selection=[
             ('equity', 'Equity'),
@@ -79,12 +79,13 @@ class AccountAccount(models.Model):
             ('expense', 'Expense'),
             ('off_balance', 'Off Balance'),
         ],
-        string="Internal Group", readonly=True, compute="_compute_internal_group", store=True
+        string="Internal Group",
+        compute="_compute_internal_group", store=True, precompute=True,
     )
     #has_unreconciled_entries = fields.Boolean(compute='_compute_has_unreconciled_entries',
     #    help="The account has at least one unreconciled debit and credit since last time the invoices & payments matching was performed.")
     reconcile = fields.Boolean(string='Allow Reconciliation', tracking=True,
-        compute='_compute_reconcile', store=True, readonly=False,
+        compute='_compute_reconcile', store=True, readonly=False, precompute=True,
         help="Check this box if this account allows invoices & payments matching of journal items.")
     tax_ids = fields.Many2many('account.tax', 'account_account_tax_default_rel',
         'account_id', 'tax_id', string='Default Taxes',
@@ -96,7 +97,7 @@ class AccountAccount(models.Model):
     tag_ids = fields.Many2many('account.account.tag', 'account_account_account_tag', string='Tags', help="Optional tags you may want to assign for custom reporting")
     group_id = fields.Many2one('account.group', compute='_compute_account_group', store=True, readonly=True,
                                help="Account prefixes can determine account groups.")
-    root_id = fields.Many2one('account.root', compute='_compute_account_root', store=True)
+    root_id = fields.Many2one('account.root', compute='_compute_account_root', store=True, precompute=True)
     allowed_journal_ids = fields.Many2many('account.journal', string="Allowed Journals", help="Define in which journals this account can be used. If empty, can be used in all journals.")
     opening_debit = fields.Monetary(string="Opening Debit", compute='_compute_opening_debit_credit', inverse='_set_opening_debit')
     opening_credit = fields.Monetary(string="Opening Credit", compute='_compute_opening_debit_credit', inverse='_set_opening_credit')
@@ -253,7 +254,6 @@ class AccountAccount(models.Model):
         if not accounts:
             return
 
-        self.flush_recordset(['reconcile'])
         self.env['account.journal'].flush_model(['company_id', 'default_account_id'])
         self.env['res.company'].flush_model(['account_journal_payment_credit_account_id', 'account_journal_payment_debit_account_id'])
         self.env['account.payment.method.line'].flush_model(['journal_id', 'payment_account_id'])
@@ -342,9 +342,11 @@ class AccountAccount(models.Model):
             record.used = record.id in ids
 
     @api.model
-    def _search_new_account_code(self, company, digits, prefix):
+    def _search_new_account_code(self, company, digits, prefix, cache=None):
         for num in range(1, 10000):
             new_code = str(prefix.ljust(digits - 1, '0')) + str(num)
+            if new_code in (cache or []):
+                continue
             rec = self.search([('code', '=', new_code), ('company_id', '=', company.id)], limit=1)
             if not rec:
                 return new_code
@@ -615,6 +617,15 @@ class AccountAccount(models.Model):
             default['name'] = self.name
         return super(AccountAccount, self).copy(default)
 
+    def copy_translations(self, new, excluded=()):
+        super().copy_translations(new, excluded=tuple(excluded)+('name',))
+        if new.name == _('%s (copy)', self.name):
+            name_field = self._fields['name']
+            self.env.cache.update_raw(new, name_field, [{
+                lang: _('%s (copy)', tr)
+                for lang, tr in name_field._get_stored_translations(self).items()
+            }], dirty=True)
+
     @api.model
     def load(self, fields, data):
         """ Overridden for better performances when importing a list of account
@@ -689,6 +700,17 @@ class AccountAccount(models.Model):
             return self.create({'code': code, 'name': name}).name_get()[0]
         raise UserError(_("Please create new accounts from the Chart of Accounts menu."))
 
+    @api.model_create_multi
+    def create(self, vals_list):
+        cache_map = defaultdict(list)
+        for vals in vals_list:
+            if 'prefix' in vals:
+                company = self.env['res.company'].browse(vals.get('company_id')) or self.env.company
+                cache = cache_map[company.id]
+                vals['code'] = self._search_new_account_code(company, vals.pop('code_digits'), vals.pop('prefix'), cache)
+                cache.append(vals['code'])
+        return super().create(vals_list)
+
     def write(self, vals):
         # Do not allow changing the company_id when account_move_line already exist
         if vals.get('company_id', False):
@@ -777,9 +799,9 @@ class AccountGroup(models.Model):
 
     parent_id = fields.Many2one('account.group', index=True, ondelete='cascade', readonly=True)
     parent_path = fields.Char(index=True, unaccent=False)
-    name = fields.Char(required=True)
-    code_prefix_start = fields.Char()
-    code_prefix_end = fields.Char()
+    name = fields.Char(required=True, translate=True)
+    code_prefix_start = fields.Char(compute='_compute_code_prefix_start', readonly=False, store=True, precompute=True)
+    code_prefix_end = fields.Char(compute='_compute_code_prefix_end', readonly=False, store=True, precompute=True)
     company_id = fields.Many2one('res.company', required=True, readonly=True, default=lambda self: self.env.company)
 
     _sql_constraints = [
@@ -790,15 +812,17 @@ class AccountGroup(models.Model):
         ),
     ]
 
-    @api.onchange('code_prefix_start')
-    def _onchange_code_prefix_start(self):
-        if not self.code_prefix_end or self.code_prefix_end < self.code_prefix_start:
-            self.code_prefix_end = self.code_prefix_start
+    @api.depends('code_prefix_start')
+    def _compute_code_prefix_end(self):
+        for group in self:
+            if not group.code_prefix_end or group.code_prefix_end < group.code_prefix_start:
+                group.code_prefix_end = group.code_prefix_start
 
-    @api.onchange('code_prefix_end')
-    def _onchange_code_prefix_end(self):
-        if not self.code_prefix_start or self.code_prefix_start > self.code_prefix_end:
-            self.code_prefix_start = self.code_prefix_end
+    @api.depends('code_prefix_end')
+    def _compute_code_prefix_start(self):
+        for group in self:
+            if not group.code_prefix_start or group.code_prefix_start > group.code_prefix_end:
+                group.code_prefix_start = group.code_prefix_end
 
     def name_get(self):
         result = []
@@ -841,18 +865,22 @@ class AccountGroup(models.Model):
         if res:
             raise ValidationError(_('Account Groups with the same granularity can\'t overlap'))
 
+    def _sanitize_vals(self, vals):
+        if vals.get('code_prefix_start') and 'code_prefix_end' in vals and not vals['code_prefix_end']:
+            del vals['code_prefix_end']
+        if vals.get('code_prefix_end') and 'code_prefix_start' in vals and not vals['code_prefix_start']:
+            del vals['code_prefix_start']
+        return vals
+
     @api.model_create_multi
     def create(self, vals_list):
-        for vals in vals_list:
-            if 'code_prefix_start' in vals and not vals.get('code_prefix_end'):
-                vals['code_prefix_end'] = vals['code_prefix_start']
-        res_ids = super(AccountGroup, self).create(vals_list)
+        res_ids = super(AccountGroup, self).create([self._sanitize_vals(vals) for vals in vals_list])
         res_ids._adapt_accounts_for_account_groups()
         res_ids._adapt_parent_account_group()
         return res_ids
 
     def write(self, vals):
-        res = super(AccountGroup, self).write(vals)
+        res = super(AccountGroup, self).write(self._sanitize_vals(vals))
         if 'code_prefix_start' in vals or 'code_prefix_end' in vals:
             self._adapt_accounts_for_account_groups()
             self._adapt_parent_account_group()
@@ -874,12 +902,14 @@ class AccountGroup(models.Model):
         The most specific is the one with the longest prefixes and with the starting
         prefix being smaller than the account code and the ending prefix being greater.
         """
+        if self.env.context.get('delay_account_group_sync'):
+            return
         company_ids = account_ids.company_id.ids if account_ids else self.company_id.ids
         account_ids = account_ids.ids if account_ids else []
-        if not company_ids and not account_ids:
+        if not company_ids and account_ids is None:
             return
         self.flush_model()
-        self.env['account.account'].flush_model()
+        self.env['account.account'].flush_model(['code'])
 
         account_where_clause = ''
         where_params = [tuple(company_ids)]
@@ -887,25 +917,25 @@ class AccountGroup(models.Model):
             account_where_clause = 'AND account.id IN %s'
             where_params.append(tuple(account_ids))
 
-        self._cr.execute(f'''
-            WITH candidates_account_groups AS (
-                SELECT
-                    account.id AS account_id,
-                    ARRAY_AGG(agroup.id ORDER BY char_length(agroup.code_prefix_start) DESC, agroup.id) AS group_ids
-                FROM account_account account
-                LEFT JOIN account_group agroup
-                    ON agroup.code_prefix_start <= LEFT(account.code, char_length(agroup.code_prefix_start))
+        self._cr.execute(f"""
+            WITH relation AS (
+                 SELECT DISTINCT ON (account.id)
+                        account.id AS account_id,
+                        agroup.id AS group_id
+                   FROM account_account account
+              LEFT JOIN account_group agroup
+                     ON agroup.code_prefix_start <= LEFT(account.code, char_length(agroup.code_prefix_start))
                     AND agroup.code_prefix_end >= LEFT(account.code, char_length(agroup.code_prefix_end))
                     AND agroup.company_id = account.company_id
-                WHERE account.company_id IN %s {account_where_clause}
-                GROUP BY account.id
+                  WHERE account.company_id IN %s {account_where_clause}
+               ORDER BY account.id, char_length(agroup.code_prefix_start) DESC, agroup.id
             )
             UPDATE account_account
-            SET group_id = rel.group_ids[1]
-            FROM candidates_account_groups rel
-            WHERE account_account.id = rel.account_id
-        ''', where_params)
-        self.env['account.account'].invalidate_model(['group_id'])
+               SET group_id = rel.group_id
+              FROM relation rel
+             WHERE account_account.id = rel.account_id
+        """, where_params)
+        self.env['account.account'].invalidate_model(['group_id'], flush=False)
 
     def _adapt_parent_account_group(self):
         """Ensure consistency of the hierarchy of account groups.
@@ -914,13 +944,16 @@ class AccountGroup(models.Model):
         The most specific is the one with the longest prefixes and with the starting
         prefix being smaller than the child prefixes and the ending prefix being greater.
         """
+        if self.env.context.get('delay_account_group_sync'):
+            return
         if not self:
             return
         self.flush_model()
         query = """
             WITH relation AS (
-       SELECT DISTINCT FIRST_VALUE(parent.id) OVER (PARTITION BY child.id ORDER BY child.id, char_length(parent.code_prefix_start) DESC) AS parent_id,
-                       child.id AS child_id
+                SELECT DISTINCT ON (child.id)
+                       child.id AS child_id,
+                       parent.id AS parent_id
                   FROM account_group parent
                   JOIN account_group child
                     ON char_length(parent.code_prefix_start) < char_length(child.code_prefix_start)
@@ -929,6 +962,7 @@ class AccountGroup(models.Model):
                    AND parent.id != child.id
                    AND parent.company_id = child.company_id
                  WHERE child.company_id IN %(company_ids)s
+              ORDER BY child.id, char_length(parent.code_prefix_start) DESC
             )
             UPDATE account_group child
                SET parent_id = relation.parent_id

--- a/addons/account/models/account_account_tag.py
+++ b/addons/account/models/account_account_tag.py
@@ -8,7 +8,7 @@ class AccountAccountTag(models.Model):
     _name = 'account.account.tag'
     _description = 'Account Tag'
 
-    name = fields.Char('Tag Name', required=True)
+    name = fields.Char('Tag Name', required=True, translate=True)
     applicability = fields.Selection([('accounts', 'Accounts'), ('taxes', 'Taxes'), ('products', 'Products')], required=True, default='accounts')
     color = fields.Integer('Color Index')
     active = fields.Boolean(default=True, help="Set active to false to hide the Account Tag without removing it.")

--- a/addons/account/models/account_journal.py
+++ b/addons/account/models/account_journal.py
@@ -4,6 +4,7 @@ from odoo.osv import expression
 from odoo.exceptions import UserError, ValidationError
 from odoo.addons.base.models.res_bank import sanitize_account_number
 from odoo.tools import remove_accents
+from collections import defaultdict
 import logging
 import re
 
@@ -62,8 +63,15 @@ class AccountJournal(models.Model):
                     return model
         return 'odoo'
 
-    name = fields.Char(string='Journal Name', required=True)
-    code = fields.Char(string='Short Code', size=5, required=True, help="Shorter name used for display. The journal entries of this journal will also be named using this prefix by default.")
+    name = fields.Char(string='Journal Name', required=True, translate=True)
+    code = fields.Char(
+        string='Short Code',
+        size=5,
+        compute='_compute_code', readonly=False, store=True,
+        required=True, precompute=True,
+        help="Shorter name used for display. "
+             "The journal entries of this journal will also be named using this prefix by default."
+    )
     active = fields.Boolean(default=True, help="Set active to false to hide the Journal without removing it.")
     type = fields.Selection([
             ('sale', 'Sales'),
@@ -203,6 +211,18 @@ class AccountJournal(models.Model):
         ('code_company_uniq', 'unique (company_id, code)', 'Journal codes must be unique per company.'),
     ]
 
+    @api.depends('type', 'company_id')
+    def _compute_code(self):
+        cache = defaultdict(list)
+        for record in self:
+            if not record.code and record.type in ('bank', 'cash'):
+                record.code = self.get_next_bank_cash_default_code(
+                    record.type,
+                    record.company_id,
+                    cache.get(record.company_id)
+                )
+                cache[record.company_id].append(record.code)
+
     @api.depends('outbound_payment_method_line_ids', 'inbound_payment_method_line_ids')
     def _compute_available_payment_method_ids(self):
         """
@@ -572,13 +592,16 @@ class AccountJournal(models.Model):
         return result
 
     @api.model
-    def get_next_bank_cash_default_code(self, journal_type, company):
+    def get_next_bank_cash_default_code(self, journal_type, company, cache=None):
         journal_code_base = (journal_type == 'cash' and 'CSH' or 'BNK')
-        journals = self.env['account.journal'].search([('code', 'like', journal_code_base + '%'), ('company_id', '=', company.id)])
+        existing_codes = set(self.env['account.journal'].search([
+            ('code', 'like', journal_code_base + '%'),
+            ('company_id', '=', company.id),
+        ]).mapped('code') + (cache or []))
         for num in range(1, 100):
             # journal_code has a maximal size of 5, hence we can enforce the boundary num < 100
             journal_code = journal_code_base + str(num)
-            if journal_code not in journals.mapped('code'):
+            if journal_code not in existing_codes:
                 return journal_code
 
     @api.model
@@ -607,7 +630,7 @@ class AccountJournal(models.Model):
         company = self.env['res.company'].browse(vals['company_id']) if vals.get('company_id') else self.env.company
         vals['company_id'] = company.id
 
-        # Don't get the digits on 'chart_template_id' since the chart template could be a custom one.
+        # Don't get the digits on 'chart_template' since the chart template could be a custom one.
         random_account = self.env['account.account'].search([('company_id', '=', company.id)], limit=1)
         digits = len(random_account.code) if random_account else 6
 
@@ -624,12 +647,6 @@ class AccountJournal(models.Model):
             # === Fill missing name ===
             vals['name'] = vals.get('name') or vals.get('bank_acc_number')
 
-            # === Fill missing code ===
-            if 'code' not in vals:
-                vals['code'] = self.get_next_bank_cash_default_code(journal_type, company)
-                if not vals['code']:
-                    raise UserError(_("Cannot generate an unused journal code. Please fill the 'Shortcode' field."))
-
             # === Fill missing accounts ===
             if not has_liquidity_accounts:
                 default_account_code = self.env['account.account']._search_new_account_code(company, digits, liquidity_account_prefix)

--- a/addons/account/models/account_report.py
+++ b/addons/account/models/account_report.py
@@ -31,7 +31,7 @@ class AccountReport(models.Model):
     column_ids = fields.One2many(string="Columns", comodel_name='account.report.column', inverse_name='report_id')
     root_report_id = fields.Many2one(string="Root Report", comodel_name='account.report', help="The report this report is a variant of.")
     variant_report_ids = fields.One2many(string="Variants", comodel_name='account.report', inverse_name='root_report_id')
-    chart_template_id = fields.Many2one(string="Chart of Accounts", comodel_name='account.chart.template')
+    chart_template = fields.Selection(string="Chart of Accounts", selection=lambda self: self.env['account.chart.template']._select_chart_template())
     country_id = fields.Many2one(string="Country", comodel_name='res.country')
     only_tax_exigible = fields.Boolean(
         string="Only Tax Exigible Lines",

--- a/addons/account/models/account_tax.py
+++ b/addons/account/models/account_tax.py
@@ -25,22 +25,28 @@ class AccountTaxGroup(models.Model):
 
     name = fields.Char(required=True, translate=True)
     sequence = fields.Integer(default=10)
-    property_tax_payable_account_id = fields.Many2one(
+    company_id = fields.Many2one('res.company', required=True, default=lambda self: self.env.company)
+    tax_payable_account_id = fields.Many2one(
         comodel_name='account.account',
-        company_dependent=True,
+        check_company=True,
         string='Tax Payable Account',
         help="Tax current account used as a counterpart to the Tax Closing Entry when in favor of the authorities.")
-    property_tax_receivable_account_id = fields.Many2one(
+    tax_receivable_account_id = fields.Many2one(
         comodel_name='account.account',
-        company_dependent=True,
+        check_company=True,
         string='Tax Receivable Account',
         help="Tax current account used as a counterpart to the Tax Closing Entry when in favor of the company.")
-    property_advance_tax_payment_account_id = fields.Many2one(
+    advance_tax_payment_account_id = fields.Many2one(
         comodel_name='account.account',
-        company_dependent=True,
+        check_company=True,
         string='Tax Advance Account',
         help="Downpayments posted on this account will be considered by the Tax Closing Entry.")
-    country_id = fields.Many2one(string="Country", comodel_name='res.country', help="The country for which this tax group is applicable.")
+    country_id = fields.Many2one(
+        string="Country",
+        comodel_name='res.country',
+        compute='_compute_country_id', store=True, readonly=False, precompute=True,
+        help="The country for which this tax group is applicable.",
+    )
     country_code = fields.Char(related="country_id.code")
     preceding_subtotal = fields.Char(
         string="Preceding Subtotal",
@@ -48,6 +54,11 @@ class AccountTaxGroup(models.Model):
              "If not set, the tax group will be displayed after the 'Untaxed amount' subtotal.",
     )
 
+    @api.depends('company_id.account_fiscal_country_id')
+    def _compute_country_id(self):
+        for group in self:
+            group.country_id = group.company_id.account_fiscal_country_id or group.company_id.country_id
+
     @api.model
     def _check_misconfigured_tax_groups(self, company, countries):
         """ Searches the tax groups used on the taxes from company in countries that don't have
@@ -56,21 +67,12 @@ class AccountTaxGroup(models.Model):
         :return: A boolean telling whether or not there are misconfigured groups for any
                  of these countries, in this company
         """
-
-        # This cannot be refactored to check for misconfigured groups instead
-        # because of an ORM limitation with search on property fields:
-        # searching on property = False also returns the properties using the default value,
-        # even if it's non-empty.
-        # (introduced here https://github.com/odoo/odoo/pull/6044)
-        all_configured_groups_ids = self.with_company(company)._search([
-            ('property_tax_payable_account_id', '!=', False),
-            ('property_tax_receivable_account_id', '!=', False),
-        ])
-
         return bool(self.env['account.tax'].search([
             ('company_id', '=', company.id),
-            ('tax_group_id', 'not in', all_configured_groups_ids),
             ('country_id', 'in', countries.ids),
+            '|',
+            ('tax_group_id.tax_payable_account_id', '=', False),
+            ('tax_group_id.tax_receivable_account_id', '=', False),
         ], limit=1))
 
 
@@ -81,11 +83,7 @@ class AccountTax(models.Model):
     _check_company_auto = True
     _rec_names_search = ['name', 'description']
 
-    @api.model
-    def _default_tax_group(self):
-        return self.env.ref('account.tax_group_taxes')
-
-    name = fields.Char(string='Tax Name', required=True)
+    name = fields.Char(string='Tax Name', required=True, translate=True)
     name_searchable = fields.Char(store=False, search='_search_name',
           help="This dummy field lets us use another search method on the field 'name'."
                "This allows more freedom on how to search the 'name' compared to 'filter_domain'."
@@ -124,8 +122,12 @@ class AccountTax(models.Model):
         default=True,
         help="If set, taxes with a lower sequence might affect this one, provided they try to do it.")
     analytic = fields.Boolean(string="Include in Analytic Cost", help="If set, the amount computed by this tax will be assigned to the same analytic account as the invoice line (if any)")
-    tax_group_id = fields.Many2one('account.tax.group', string="Tax Group", default=_default_tax_group, required=True,
-                                   domain="[('country_id', 'in', (country_id, False))]")
+    tax_group_id = fields.Many2one(
+        comodel_name='account.tax.group',
+        string="Tax Group",
+        compute='_compute_tax_group_id', readonly=False, store=True,
+        required=True, precompute=True,
+        domain="[('country_id', 'in', (country_id, False))]")
     # Technical field to make the 'tax_exigibility' field invisible if the same named field is set to false in 'res.company' model
     hide_tax_exigibility = fields.Boolean(string='Hide Use Cash Basis Option', related='company_id.tax_exigibility', readonly=True)
     tax_exigibility = fields.Selection(
@@ -160,7 +162,13 @@ class AccountTax(models.Model):
         copy=True,
         help="Distribution when the tax is used on a refund",
     )
-    country_id = fields.Many2one(string="Country", comodel_name='res.country', required=True, help="The country for which this tax is applicable.")
+    country_id = fields.Many2one(
+        string="Country",
+        comodel_name='res.country',
+        compute='_compute_country_id', readonly=False, store=True,
+        required=True, precompute=True,
+        help="The country for which this tax is applicable.",
+    )
     country_code = fields.Char(related='country_id.code', readonly=True)
 
     _sql_constraints = [
@@ -173,16 +181,36 @@ class AccountTax(models.Model):
             if record.tax_group_id.country_id and record.tax_group_id.country_id != record.country_id:
                 raise ValidationError(_("The tax group must have the same country_id as the tax using it."))
 
+    @api.depends('company_id.account_fiscal_country_id')
+    def _compute_country_id(self):
+        for tax in self:
+            tax.country_id = tax.company_id.account_fiscal_country_id or tax.company_id.country_id or tax.country_id
+
+    @api.depends('company_id', 'country_id')
+    def _compute_tax_group_id(self):
+        by_country_company = defaultdict(self.browse)
+        for tax in self:
+            if (
+                not tax.tax_group_id
+                or tax.tax_group_id.country_id != tax.country_id
+                or tax.tax_group_id.company_id != tax.company_id
+            ):
+                by_country_company[(tax.country_id, tax.company_id)] += tax
+        for (country, company), taxes in by_country_company.items():
+            taxes.tax_group_id = self.env['account.tax.group'].search([
+                ('company_id', '=', company.id),
+                ('country_id', '=', country.id),
+            ], limit=1) or self.env['account.tax.group'].search([
+                ('company_id', '=', company.id),
+                ('country_id', '=', False),
+            ], limit=1)
+
     @api.model
     def default_get(self, fields_list):
         # company_id is added so that we are sure to fetch a default value from it to use in repartition lines, below
         rslt = super(AccountTax, self).default_get(fields_list + ['company_id'])
 
         company_id = rslt.get('company_id')
-        company = self.env['res.company'].browse(company_id)
-
-        if 'country_id' in fields_list:
-            rslt['country_id'] = company.account_fiscal_country_id.id
 
         repartition = rslt.setdefault('repartition_line_ids', [])
         if 'repartition_line_ids' in fields_list and not repartition:
@@ -228,8 +256,8 @@ class AccountTax(models.Model):
     @api.constrains('invoice_repartition_line_ids', 'refund_repartition_line_ids')
     def _validate_repartition_lines(self):
         for record in self:
-            invoice_repartition_line_ids = record.invoice_repartition_line_ids.sorted()
-            refund_repartition_line_ids = record.refund_repartition_line_ids.sorted()
+            invoice_repartition_line_ids = record.invoice_repartition_line_ids.sorted(lambda l: (l.sequence, l.id))
+            refund_repartition_line_ids = record.refund_repartition_line_ids.sorted(lambda l: (l.sequence, l.id))
             record._check_repartition_lines(invoice_repartition_line_ids)
             record._check_repartition_lines(refund_repartition_line_ids)
 
@@ -282,19 +310,28 @@ class AccountTax(models.Model):
         if self._cr.fetchone():
             raise UserError(_("You can't change the company of your tax since there are some journal items linked to it."))
 
+    def _sanitize_vals(self, vals):
+        """Normalize the create/write values."""
+        sanitized = vals.copy()
+        # Allow to provide invoice_repartition_line_ids and refund_repartition_line_ids by dispatching them
+        # correctly in the repartition_line_ids
+        for doc_type in ('invoice', 'refund'):
+            fname = f"{doc_type}_repartition_line_ids"
+            if fname in sanitized:
+                repartition = sanitized.setdefault('repartition_line_ids', [])
+                repartition.extend([
+                    (command, id, {'document_type': doc_type, **v}) if command in (Command.CREATE, Command.UPDATE)
+                    else (command, id, v)
+                    for command, id, v in sanitized.pop(fname)
+                ])
+        return sanitized
+
     @api.model_create_multi
     def create(self, vals_list):
-        for vals in vals_list:
-            for doc_type in ('invoice', 'refund'):
-                fname = f"{doc_type}_repartition_line_ids"
-                if fname in vals:
-                    repartition = vals.setdefault('repartition_line_ids', [])
-                    repartition.extend([
-                        (command, id, {'document_type': doc_type, **v})
-                        for command, id, v in vals.pop(fname)
-                    ])
-        return super().create(vals_list)
+        return super().create([self._sanitize_vals(vals) for vals in vals_list])
 
+    def write(self, vals):
+        return super().write(self._sanitize_vals(vals))
 
     @api.returns('self', lambda value: value.id)
     def copy(self, default=None):

--- a/addons/account/models/chart_template.py
+++ b/addons/account/models/chart_template.py
@@ -1,30 +1,35 @@
 # -*- coding: utf-8 -*-
 
-from odoo.exceptions import AccessError
-from odoo import api, fields, models, Command, _, osv
-from odoo import SUPERUSER_ID
-from odoo.exceptions import UserError, ValidationError
-from odoo.http import request
-from odoo.addons.account.models.account_tax import TYPE_TAX_USE
-from odoo.addons.account.models.account_account import ACCOUNT_CODE_REGEX
-from odoo.tools import html_escape
-
+import ast
+from collections import defaultdict
+import csv
+from functools import wraps
+from inspect import getmembers
 import logging
 import re
 
+from psycopg2.extras import Json
+
+from odoo import Command, _, models, api
+from odoo.addons.base.models.ir_model import MODULE_UNINSTALL_FLAG
+from odoo.addons.account import SYSCOHADA_LIST
+from odoo.exceptions import AccessError
+from odoo.tools import file_open
+
 _logger = logging.getLogger(__name__)
 
-def migrate_set_tags_and_taxes_updatable(cr, registry, module):
-    ''' This is a utility function used to manually set the flag noupdate to False on tags and account tax templates on localization modules
-    that need migration (for example in case of VAT report improvements)
-    '''
-    env = api.Environment(cr, SUPERUSER_ID, {})
-    xml_record_ids = env['ir.model.data'].search([
-        ('model', 'in', ['account.tax.template', 'account.account.tag']),
-        ('module', 'like', module)
-    ]).ids
-    if xml_record_ids:
-        cr.execute("update ir_model_data set noupdate = 'f' where id in %s", (tuple(xml_record_ids),))
+TEMPLATE_MODELS = (
+    'account.group',
+    'account.account',
+    'account.tax.group',
+    'account.tax',
+    'account.journal',
+    'account.reconcile.model',
+    'account.fiscal.position',
+)
+
+TAX_TAG_DELIMITER = '||'
+
 
 def preserve_existing_tags_on_taxes(env, module):
     ''' This is a utility function used to preserve existing previous tags during upgrade of the module.'''
@@ -32,966 +37,652 @@ def preserve_existing_tags_on_taxes(env, module):
     if xml_records:
         env.cr.execute("update ir_model_data set noupdate = 't' where id in %s", [tuple(xml_records.ids)])
 
-def update_taxes_from_templates(cr, chart_template_xmlid):
-    def _create_tax_from_template(company, template, old_tax=None):
-        """
-        Create a new tax from template with template xmlid, if there was already an old tax with that xmlid we
-        remove the xmlid from it but don't modify anything else.
-        """
-        def _remove_xml_id(xml_id):
-            module, name = xml_id.split(".", 1)
-            env['ir.model.data'].search([('module', '=', module), ('name', '=', name)]).unlink()
-
-        def _avoid_name_conflict():
-            conflict_tax = env['account.tax'].search([('name', '=', template.name), ('company_id', '=', company.id),
-                                                      ('type_tax_use', '=', template.type_tax_use), ('tax_scope', '=', template.tax_scope)])
-            if conflict_tax:
-                conflict_tax.name = "[old] " + conflict_tax.name
-
-        template_vals = template._get_tax_vals_complete(company)
-        chart_template = env["account.chart.template"].with_context(default_company_id=company.id)
-        if old_tax:
-            xml_id = old_tax.get_external_id().get(old_tax.id)
-            if xml_id:
-                _remove_xml_id(xml_id)
-        _avoid_name_conflict()
-        chart_template.create_record_with_xmlid(company, template, "account.tax", template_vals)
-
-    def _update_tax_from_template(template, tax):
-        # -> update the tax : we only updates tax tags
-        tax_rep_lines = tax.invoice_repartition_line_ids + tax.refund_repartition_line_ids
-        template_rep_lines = template.invoice_repartition_line_ids + template.refund_repartition_line_ids
-        for tax_line, template_line in zip(tax_rep_lines, template_rep_lines):
-            tags_to_add = template_line._get_tags_to_add()
-            tags_to_unlink = tax_line.tag_ids
-            if tags_to_add != tags_to_unlink:
-                tax_line.write({"tag_ids": [(6, 0, tags_to_add.ids)]})
-                _cleanup_tags(tags_to_unlink)
-
-    def _get_template_to_real_xmlid_mapping(company, model):
-        """
-        This function uses ir_model_data to return a mapping between the templates and the data, using their xmlid
-        :returns: {
-            account.tax.template.id: account.tax.id
-            }
-        """
-        env['ir.model.data'].flush_model()
-        env.cr.execute(
-            """
-            SELECT template.res_id AS template_res_id,
-                   data.res_id AS data_res_id
-            FROM ir_model_data data
-            JOIN ir_model_data template
-            ON template.name = substr(data.name, strpos(data.name, '_') + 1)
-            WHERE data.model = %s
-            AND data.name LIKE %s
-            -- tax.name is of the form: {company_id}_{account.tax.template.name}
-            """,
-            [model, r"%s\_%%" % company.id],
-        )
-        tuples = env.cr.fetchall()
-        return dict(tuples)
 
-    def _is_tax_and_template_same(template, tax):
-        """
-        This function compares account.tax and account.tax.template repartition lines.
-        A tax is considered the same as the template if they have the same:
-            - amount_type
-            - amount
-            - repartition lines percentages in the same order
-        """
-        tax_rep_lines = tax.invoice_repartition_line_ids + tax.refund_repartition_line_ids
-        template_rep_lines = template.invoice_repartition_line_ids + template.refund_repartition_line_ids
-        return (
-                tax.amount_type == template.amount_type
-                and tax.amount == template.amount
-                and len(tax_rep_lines) == len(template_rep_lines)
-                and all(
-                    rep_line_tax.factor_percent == rep_line_template.factor_percent
-                    for rep_line_tax, rep_line_template in zip(tax_rep_lines, template_rep_lines)
-                )
-        )
+def template(template=None, model='template_data'):
+    def decorator(func):
+        @wraps(func)
+        def wrapper(*args, **kwargs):
+            if template is not None:
+                # remove the template code argument as we already know it from the decorator
+                args, kwargs = args[:1], {}
+            return func(*args, **kwargs)
+        return api.attrsetter('_l10n_template', (template, model))(wrapper)
+    return decorator
 
-    def _cleanup_tags(tags):
-        """
-        Checks if the tags are still used in taxes or move lines. If not we delete it.
-        """
-        for tag in tags:
-            tax_using_tag = env['account.tax.repartition.line'].sudo().search([('tag_ids', 'in', tag.id)], limit=1)
-            aml_using_tag = env['account.move.line'].sudo().search([('tax_tag_ids', 'in', tag.id)], limit=1)
-            report_expr_using_tag = tag._get_related_tax_report_expressions()
-            if not (aml_using_tag or tax_using_tag or report_expr_using_tag):
-                tag.unlink()
-
-    def _update_fiscal_positions_from_templates(company, chart_template_id, new_taxes_template):
-        chart_template = env["account.chart.template"].browse(chart_template_id)
-        positions = env['account.fiscal.position.template'].search([('chart_template_id', '=', chart_template_id)])
-        tax_template_ref = _get_template_to_real_xmlid_mapping(company, 'account.tax')
-        fp_template_ref = _get_template_to_real_xmlid_mapping(company, 'account.fiscal.position')
-
-        tax_template_vals = []
-        for position_template in positions:
-            fp = env["account.fiscal.position"].browse(fp_template_ref.get(position_template.id))
-            if not fp:
-                continue
-            for position_tax in position_template.tax_ids:
-                if position_tax.tax_src_id in new_taxes_template or position_tax.tax_dest_id in new_taxes_template:
-                    tax_template_vals.append((position_tax, {
-                        'tax_src_id': tax_template_ref[position_tax.tax_src_id.id],
-                        'tax_dest_id': position_tax.tax_dest_id and tax_template_ref[position_tax.tax_dest_id.id] or False,
-                        'position_id': fp.id,
-                    }))
-        chart_template._create_records_with_xmlid('account.fiscal.position.tax', tax_template_vals, company)
-
-    def _notify_accountant_managers(taxes_to_check):
-        accountant_manager_group = env.ref("account.group_account_manager")
-        partner_managers_ids = accountant_manager_group.users.mapped('partner_id')
-        odoobot = env.ref('base.partner_root')
-        message_body = _(
-            "Please check these taxes. They might be outdated. We did not update them. "
-            "Indeed, they do not exactly match the taxes of the original version of the localization module.<br/>"
-            "You might want to archive or adapt them.<br/><ul>"
-        )
-        for account_tax in taxes_to_check:
-            message_body += f"<li>{html_escape(account_tax.name)}</li>"
-        message_body += "</ul>"
-        env['mail.thread'].message_notify(
-            subject=_('Your taxes have been updated !'),
-            author_id=odoobot.id,
-            body=message_body,
-            partner_ids=[partner.id for partner in partner_managers_ids],
-        )
-
-    env = api.Environment(cr, SUPERUSER_ID, {})
-    chart_template_id = env.ref(chart_template_xmlid).id
-    companies = env['res.company'].search([('chart_template_id', 'child_of', chart_template_id)])
-    outdated_taxes = []
-    new_taxes_template = []
-    for company in companies:
-        template_to_tax = _get_template_to_real_xmlid_mapping(company, 'account.tax')
-        templates = env['account.tax.template'].with_context(active_test=False).search([("chart_template_id", "=", chart_template_id)])
-        for template in templates:
-            tax = env["account.tax"].browse(template_to_tax.get(template.id))
-            if not tax or not _is_tax_and_template_same(template, tax):
-                _create_tax_from_template(company, template, old_tax=tax)
-                if tax:
-                    outdated_taxes.append(tax)
-                else:
-                    new_taxes_template.append(template)
-            else:
-                _update_tax_from_template(template, tax)
-        _update_fiscal_positions_from_templates(company, chart_template_id, new_taxes_template)
-    if outdated_taxes:
-        _notify_accountant_managers(outdated_taxes)
-
-#  ---------------------------------------------------------------
-#   Account Templates: Account, Tax, Tax Code and chart. + Wizard
-#  ---------------------------------------------------------------
-
-
-class AccountGroupTemplate(models.Model):
-    _name = "account.group.template"
-    _description = 'Template for Account Groups'
-    _order = 'code_prefix_start'
-
-    parent_id = fields.Many2one('account.group.template', ondelete='cascade')
-    name = fields.Char(required=True)
-    code_prefix_start = fields.Char()
-    code_prefix_end = fields.Char()
-    chart_template_id = fields.Many2one('account.chart.template', string='Chart Template', required=True)
-
-
-class AccountAccountTemplate(models.Model):
-    _name = "account.account.template"
-    _inherit = ['mail.thread']
-    _description = 'Templates for Accounts'
-    _order = "code"
-
-    name = fields.Char(required=True)
-    currency_id = fields.Many2one('res.currency', string='Account Currency', help="Forces all moves for this account to have this secondary currency.")
-    code = fields.Char(size=64, required=True)
-    account_type = fields.Selection(
-        selection=[
-            ("asset_receivable", "Receivable"),
-            ("asset_cash", "Bank and Cash"),
-            ("asset_current", "Current Assets"),
-            ("asset_non_current", "Non-current Assets"),
-            ("asset_prepayments", "Prepayments"),
-            ("asset_fixed", "Fixed Assets"),
-            ("liability_payable", "Payable"),
-            ("liability_credit_card", "Credit Card"),
-            ("liability_current", "Current Liabilities"),
-            ("liability_non_current", "Non-current Liabilities"),
-            ("equity", "Equity"),
-            ("equity_unaffected", "Current Year Earnings"),
-            ("income", "Income"),
-            ("income_other", "Other Income"),
-            ("expense", "Expenses"),
-            ("expense_depreciation", "Depreciation"),
-            ("expense_direct_cost", "Cost of Revenue"),
-            ("off_balance", "Off-Balance Sheet"),
-        ],
-        string="Type",
-        help="These types are defined according to your country. The type contains more information "\
-        "about the account and its specificities."
-    )
-    reconcile = fields.Boolean(string='Allow Invoices & payments Matching', default=False,
-        help="Check this option if you want the user to reconcile entries in this account.")
-    note = fields.Text()
-    tax_ids = fields.Many2many('account.tax.template', 'account_account_template_tax_rel', 'account_id', 'tax_id', string='Default Taxes')
-    nocreate = fields.Boolean(string='Optional Create', default=False,
-        help="If checked, the new chart of accounts will not contain this by default.")
-    chart_template_id = fields.Many2one('account.chart.template', string='Chart Template',
-        help="This optional field allow you to link an account template to a specific chart template that may differ from the one its root parent belongs to. This allow you "
-            "to define chart templates that extend another and complete it with few new accounts (You don't need to define the whole structure that is common to both several times).")
-    tag_ids = fields.Many2many('account.account.tag', 'account_account_template_account_tag', string='Account tag', help="Optional tags you may want to assign for custom reporting")
-
-    @api.depends('name', 'code')
-    def name_get(self):
-        res = []
-        for record in self:
-            name = record.name
-            if record.code:
-                name = record.code + ' ' + name
-            res.append((record.id, name))
-        return res
-
-    @api.constrains('code')
-    def _check_account_code(self):
-        for account in self:
-            if not re.match(ACCOUNT_CODE_REGEX, account.code):
-                raise ValidationError(_(
-                    "The account code can only contain alphanumeric characters and dots."
-                ))
 
-
-class AccountChartTemplate(models.Model):
+class AccountChartTemplate(models.AbstractModel):
     _name = "account.chart.template"
     _description = "Account Chart Template"
 
-    name = fields.Char(required=True)
-    parent_id = fields.Many2one('account.chart.template', string='Parent Chart Template')
-    code_digits = fields.Integer(string='# of Digits', required=True, default=6, help="No. of Digits to use for account code")
-    visible = fields.Boolean(string='Can be Visible?', default=True,
-        help="Set this to False if you don't want this template to be used actively in the wizard that generate Chart of Accounts from "
-            "templates, this is useful when you want to generate accounts of this template only when loading its child template.")
-    currency_id = fields.Many2one('res.currency', string='Currency', required=True)
-    use_anglo_saxon = fields.Boolean(string="Use Anglo-Saxon accounting", default=False)
-    use_storno_accounting = fields.Boolean(string="Use Storno accounting", default=False)
-    account_ids = fields.One2many('account.account.template', 'chart_template_id', string='Associated Account Templates')
-    tax_template_ids = fields.One2many('account.tax.template', 'chart_template_id', string='Tax Template List',
-        help='List of all the taxes that have to be installed by the wizard')
-    bank_account_code_prefix = fields.Char(string='Prefix of the bank accounts', required=True)
-    cash_account_code_prefix = fields.Char(string='Prefix of the main cash accounts', required=True)
-    transfer_account_code_prefix = fields.Char(string='Prefix of the main transfer accounts', required=True)
-    income_currency_exchange_account_id = fields.Many2one('account.account.template',
-        string="Gain Exchange Rate Account", domain=[('account_type', 'not in', ('asset_receivable', 'liability_payable', 'asset_cash', 'liability_credit_card')), ('deprecated', '=', False)])
-    expense_currency_exchange_account_id = fields.Many2one('account.account.template',
-        string="Loss Exchange Rate Account", domain=[('account_type', 'not in', ('asset_receivable', 'liability_payable', 'asset_cash', 'liability_credit_card')), ('deprecated', '=', False)])
-    country_id = fields.Many2one(string="Country", comodel_name='res.country', help="The country this chart of accounts belongs to. None if it's generic.")
-
-    account_journal_suspense_account_id = fields.Many2one('account.account.template', string='Journal Suspense Account')
-    account_journal_payment_debit_account_id = fields.Many2one('account.account.template', string='Journal Outstanding Receipts Account')
-    account_journal_payment_credit_account_id = fields.Many2one('account.account.template', string='Journal Outstanding Payments Account')
-
-    default_cash_difference_income_account_id = fields.Many2one('account.account.template', string="Cash Difference Income Account")
-    default_cash_difference_expense_account_id = fields.Many2one('account.account.template', string="Cash Difference Expense Account")
-    default_pos_receivable_account_id = fields.Many2one('account.account.template', string="PoS receivable account")
-
-    account_journal_early_pay_discount_loss_account_id = fields.Many2one(comodel_name='account.account.template', string='Cash Discount Write-Off Loss Account', )
-    account_journal_early_pay_discount_gain_account_id = fields.Many2one(comodel_name='account.account.template', string='Cash Discount Write-Off Gain Account', )
-
-    property_account_receivable_id = fields.Many2one('account.account.template', string='Receivable Account')
-    property_account_payable_id = fields.Many2one('account.account.template', string='Payable Account')
-    property_account_expense_categ_id = fields.Many2one('account.account.template', string='Category of Expense Account')
-    property_account_income_categ_id = fields.Many2one('account.account.template', string='Category of Income Account')
-    property_account_expense_id = fields.Many2one('account.account.template', string='Expense Account on Product Template')
-    property_account_income_id = fields.Many2one('account.account.template', string='Income Account on Product Template')
-    property_stock_account_input_categ_id = fields.Many2one('account.account.template', string="Input Account for Stock Valuation")
-    property_stock_account_output_categ_id = fields.Many2one('account.account.template', string="Output Account for Stock Valuation")
-    property_stock_valuation_account_id = fields.Many2one('account.account.template', string="Account Template for Stock Valuation")
-    property_tax_payable_account_id = fields.Many2one('account.account.template', string="Tax current account (payable)")
-    property_tax_receivable_account_id = fields.Many2one('account.account.template', string="Tax current account (receivable)")
-    property_advance_tax_payment_account_id = fields.Many2one('account.account.template', string="Advance tax payment account")
-    property_cash_basis_base_account_id = fields.Many2one(
-        comodel_name='account.account.template',
-        domain=[('deprecated', '=', False)],
-        string="Base Tax Received Account",
-        help="Account that will be set on lines created in cash basis journal entry and used to keep track of the "
-             "tax base amount.")
-
-    @api.model
-    def _prepare_transfer_account_template(self, prefix=None):
-        ''' Prepare values to create the transfer account that is an intermediary account used when moving money
-        from a liquidity account to another.
-
-        :return:    A dictionary of values to create a new account.account.
-        '''
-        digits = self.code_digits
-        prefix = prefix or self.transfer_account_code_prefix or ''
-        # Flatten the hierarchy of chart templates.
-        chart_template = self
-        chart_templates = self
-        while chart_template.parent_id:
-            chart_templates += chart_template.parent_id
-            chart_template = chart_template.parent_id
-        new_code = ''
-        for num in range(1, 100):
-            new_code = str(prefix.ljust(digits - 1, '0')) + str(num)
-            rec = self.env['account.account.template'].search(
-                [('code', '=', new_code), ('chart_template_id', 'in', chart_templates.ids)], limit=1)
-            if not rec:
-                break
+    @property
+    def _template_register(self):
+        def is_template(func):
+            return callable(func) and hasattr(func, '_l10n_template')
+        template_register = defaultdict(lambda: defaultdict(list))
+        cls = type(self)
+        for _attr, func in getmembers(cls, is_template):
+            template, model = func._l10n_template
+            template_register[template][model].append(func)
+        cls._template_register = template_register
+        return template_register
+
+    def _setup_complete(self):
+        super()._setup_complete()
+        type(self)._template_register = AccountChartTemplate._template_register
+
+
+    # --------------------------------------------------------------------------------
+    # Template selection
+    # --------------------------------------------------------------------------------
+
+    def _get_chart_template_mapping(self, get_all=False):
+        """Get basic information about available CoA and their modules.
+
+        :return: a mapping between the template code and a dictionnary constaining the
+                 name, country id, country name, module dependencies and parent template
+        :rtype: dict[str, dict]
+        """
+        field = self.env['ir.module.module']._fields['account_templates']
+        if self.env.cache.contains_field(field):
+            modules = self.env.cache.get_records(self.env['ir.module.module'], field)
         else:
-            raise UserError(_('Cannot generate an unused account code.'))
-
+            modules = self.env['ir.module.module'].search([])
         return {
-            'name': _('Liquidity Transfer'),
-            'code': new_code,
-            'account_type': 'asset_current',
-            'reconcile': True,
-            'chart_template_id': self.id,
+            name: template
+            for mapping in modules.mapped('account_templates')
+            for name, template in mapping.items()
+            if get_all or template['visible']
         }
 
-    @api.model
-    def _create_liquidity_journal_suspense_account(self, company, code_digits):
-        return self.env['account.account'].create({
-            'name': _("Bank Suspense Account"),
-            'code': self.env['account.account']._search_new_account_code(company, code_digits, company.bank_account_code_prefix or ''),
-            'account_type': 'asset_current',
-            'company_id': company.id,
-        })
-
-    @api.model
-    def _create_cash_discount_loss_account(self, company, code_digits):
-        return self.env['account.account'].create({
-            'name': _("Cash Discount Loss"),
-            'code': 999998,
-            'account_type': 'expense',
-            'company_id': company.id,
-        })
-
-    @api.model
-    def _create_cash_discount_gain_account(self, company, code_digits):
-        return self.env['account.account'].create({
-            'name': _("Cash Discount Gain"),
-            'code': 999997,
-            'account_type': 'income_other',
-            'company_id': company.id,
-        })
-
-    def try_loading(self, company=False, install_demo=True):
-        """ Installs this chart of accounts for the current company if not chart
-        of accounts had been created for it yet.
-
-        :param company (Model<res.company>): the company we try to load the chart template on.
+    def _select_chart_template(self, country=None):
+        """Get the available templates in a format suited for Selection fields."""
+        country = country if country is not None else self.env.company.country_id
+        chart_template_mapping = self._get_chart_template_mapping()
+        return [
+            (template_code, template['name'])
+            for template_code, template in sorted(chart_template_mapping.items(), key=(lambda t: (
+                t[1]['name'] != 'generic_coa' if not country
+                else t[1]['name'] != 'syscohada' if country.code in SYSCOHADA_LIST
+                else t[1]['country_id'] != country.id
+            )))
+        ]
+
+    def _guess_chart_template(self, country):
+        """Guess the most appropriate template based on the country."""
+        return self._select_chart_template(country)[0][0]
+
+    # --------------------------------------------------------------------------------
+    # Loading
+    # --------------------------------------------------------------------------------
+
+    def try_loading(self, template_code, company, install_demo=True):
+        """Check if the chart template can be loaded then proceeds installing it.
+
+        :param template_code: code of the chart template to be loaded.
+        :type template_code: str
+        :param company: the company we try to load the chart template on.
             If not provided, it is retrieved from the context.
-        :param install_demo (bool): whether or not we should load demo data right after loading the
+        :type company: int, Model<res.company>
+        :param install_demo: whether or not we should load demo data right after loading the
             chart template.
+        :type install_demo: bool
         """
-        # do not use `request.env` here, it can cause deadlocks
         if not company:
-            if request and hasattr(request, 'allowed_company_ids'):
-                company = self.env['res.company'].browse(request.allowed_company_ids[0])
-            else:
-                company = self.env.company
-        # If we don't have any chart of account on this company, install this chart of account
-        if not company.chart_template_id and not self.existing_accounting(company):
-            for template in self:
-                template.with_context(default_company_id=company.id)._load(company)
-            # Install the demo data when the first localization is instanciated on the company
-            if install_demo and self.env.ref('base.module_account').demo:
-                self.with_context(
-                    default_company_id=company.id,
-                    allowed_company_ids=[company.id],
-                )._create_demo_data()
-
-    def _create_demo_data(self):
-        try:
-            with self.env.cr.savepoint():
-                demo_data = self._get_demo_data()
-                for model, data in demo_data:
-                    created = self.env[model]._load_records([{
-                        'xml_id': "account.%s" % xml_id if '.' not in xml_id else xml_id,
-                        'values': record,
-                        'noupdate': True,
-                    } for xml_id, record in data.items()])
-                    self._post_create_demo_data(created)
-        except Exception:
-            # Do not rollback installation of CoA if demo data failed
-            _logger.exception('Error while loading accounting demo data')
-
-    def _load(self, company):
-        """ Installs this chart of accounts on the current company, replacing
-        the existing one if it had already one defined. If some accounting entries
-        had already been made, this function fails instead, triggering a UserError.
-
-        Also, note that this function can only be run by someone with administration
-        rights.
+            company = self.env.company
+        if isinstance(company, int):
+            company = self.env['res.company'].browse([company])
+
+        template_code = template_code or company and self._guess_chart_template(company.country_id)
+
+        return self._load(template_code, company, install_demo)
+
+    def _load(self, template_code, company, install_demo):
+        """Install this chart of accounts for the current company.
+
+        :param template_code: code of the chart template to be loaded.
+        :param company: the company we try to load the chart template on.
+            If not provided, it is retrieved from the context.
+        :param install_demo: whether or not we should load demo data right after loading the
+            chart template.
         """
-        self.ensure_one()
-        # do not use `request.env` here, it can cause deadlocks
-        # Ensure everything is translated to the company's language, not the user's one.
-        self = self.with_context(lang=company.partner_id.lang).with_company(company)
-        if not self.env.is_admin():
-            raise AccessError(_("Only administrators can load a chart of accounts"))
-
-        existing_accounts = self.env['account.account'].search([('company_id', '=', company.id)])
-        if existing_accounts:
-            # we tolerate switching from accounting package (localization module) as long as there isn't yet any accounting
-            # entries created for the company.
-            if self.existing_accounting(company):
-                raise UserError(_('Could not install new chart of account as there are already accounting entries existing.'))
-
-            # delete accounting properties
-            prop_values = ['account.account,%s' % (account_id,) for account_id in existing_accounts.ids]
-            existing_journals = self.env['account.journal'].search([('company_id', '=', company.id)])
-            if existing_journals:
-                prop_values.extend(['account.journal,%s' % (journal_id,) for journal_id in existing_journals.ids])
-            self.env['ir.property'].sudo().search(
-                [('value_reference', 'in', prop_values)]
-            ).unlink()
-
-            # delete account, journal, tax, fiscal position and reconciliation model
-            models_to_delete = ['account.reconcile.model', 'account.fiscal.position', 'account.move.line', 'account.move', 'account.journal', 'account.tax', 'account.group']
-            for model in models_to_delete:
-                res = self.env[model].sudo().search([('company_id', '=', company.id)])
-                if len(res):
-                    res.with_context(force_delete=True).unlink()
-            existing_accounts.unlink()
-
-        company.write({'currency_id': self.currency_id.id,
-                       'anglo_saxon_accounting': self.use_anglo_saxon,
-                       'account_storno': self.use_storno_accounting,
-                       'bank_account_code_prefix': self.bank_account_code_prefix,
-                       'cash_account_code_prefix': self.cash_account_code_prefix,
-                       'transfer_account_code_prefix': self.transfer_account_code_prefix,
-                       'chart_template_id': self.id
-        })
-
-        #set the coa currency to active
-        self.currency_id.write({'active': True})
-
-        # When we install the CoA of first company, set the currency to price types and pricelists
-        if company.id == 1:
-            for reference in ['product.list_price', 'product.standard_price']:
-                try:
-                    tmp2 = self.env.ref(reference).write({'currency_id': self.currency_id.id})
-                except ValueError:
-                    pass
-
-        # Set the fiscal country before generating taxes in case the company does not have a country_id set yet
-        if self.country_id:
-            # If this CoA is made for only one country, set it as the fiscal country of the company.
-            company.account_fiscal_country_id = self.country_id
-        elif not company.account_fiscal_country_id:
-            company.account_fiscal_country_id = self.env.ref('base.us')
-
-        # Install all the templates objects and generate the real objects
-        acc_template_ref, taxes_ref = self._install_template(company, code_digits=self.code_digits)
-
-        # Set default cash discount write-off accounts
-        if not company.account_journal_early_pay_discount_loss_account_id:
-            company.account_journal_early_pay_discount_loss_account_id = self._create_cash_discount_loss_account(
-                company, self.code_digits)
-        if not company.account_journal_early_pay_discount_gain_account_id:
-            company.account_journal_early_pay_discount_gain_account_id = self._create_cash_discount_gain_account(
-                company, self.code_digits)
-
-        # Set default cash difference account on company
-        if not company.account_journal_suspense_account_id:
-            company.account_journal_suspense_account_id = self._create_liquidity_journal_suspense_account(company, self.code_digits)
-
-        if not company.account_journal_payment_debit_account_id:
-            company.account_journal_payment_debit_account_id = self.env['account.account'].create({
-                'name': _("Outstanding Receipts"),
-                'code': self.env['account.account']._search_new_account_code(company, self.code_digits, company.bank_account_code_prefix or ''),
-                'reconcile': True,
-                'account_type': 'asset_current',
-                'company_id': company.id,
-            })
+        # Ensure that the context is the correct one, even if not called by try_loading
+        if not self.env.is_system():
+            raise AccessError(_("Only administrators can install chart templates"))
+
+        module_name = self._get_chart_template_mapping()[template_code].get('module')
+        module = self.env['ir.module.module'].search([('name', '=', module_name), ('state', '=', 'uninstalled')])
+        if module:
+            module.button_immediate_install()
+            self.env.reset()  # clear the envs with an old registry
+            self = self.env()['account.chart.template']  # create a new env with the new registry
+
+        self = self.with_context(
+            default_company_id=company.id,
+            allowed_company_ids=[company.id],
+            tracking_disable=True,
+            delay_account_group_sync=True,
+        )
+        company = company.with_env(self.env)
+
+        reload_template = template_code == company.chart_template
+        company.chart_template = template_code
+
+        if not reload_template:
+            for model in ('account.move',) + TEMPLATE_MODELS[::-1]:
+                self.env[model].search([('company_id', '=', company.id)]).with_context({MODULE_UNINSTALL_FLAG: True}).unlink()
+
+        data = self._get_chart_template_data(template_code)
+        template_data = data.pop('template_data')
+
+        if reload_template:
+            self._pre_reload_data(company, template_data, data)
+            install_demo = False
+        data = self._pre_load_data(template_code, company, template_data, data)
+        self._load_data(data)
+        self._post_load_data(template_code, company, template_data)
+
+        # Manual sync because disable above (delay_account_group_sync)
+        AccountGroup = self.env['account.group'].with_context(delay_account_group_sync=False)
+        AccountGroup._adapt_accounts_for_account_groups(self.env['account.account'].search([]))
+        AccountGroup.search([])._adapt_parent_account_group()
+
+        # Install the demo data when the first localization is instanciated on the company
+        if install_demo and self.ref('base.module_account').demo and not reload_template:
+            try:
+                with self.env.cr.savepoint():
+                    self._load_data(self._get_demo_data(company))
+                    self._post_load_demo_data(company)
+            except Exception:
+                # Do not rollback installation of CoA if demo data failed
+                _logger.exception('Error while loading accounting demo data')
+
+    def _pre_reload_data(self, company, template_data, data):
+        """Pre-process the data in case of reloading the chart of accounts.
+
+        When we reload the chart of accounts, we only want to update fields that are main
+        configuration, like:
+        - tax tags
+        - fiscal position mappings linked to new records
+        """
+        for prop in list(template_data):
+            if prop.startswith('property_'):
+                template_data.pop(prop)
+        data.pop('account.reconcile.model', None)
+
+        for xmlid, journal_data in list(data.get('account.journal', {}).items()):
+            if self.ref(xmlid, raise_if_not_found=False):
+                del data['account.journal'][xmlid]
+            elif 'code' in journal_data:
+                journal = self.env['account.journal'].search([
+                    ('code', '=', journal_data['code']),
+                    ('company_id', '=', company.id),
+                ])
+                if journal:
+                    del data['account.journal'][xmlid]
+                    self.env['ir.model.data']._update_xmlids([{
+                        'xml_id': f"account.{company.id}_{xmlid}",
+                        'record': journal,
+                        'noupdate': True,
+                    }])
+
+        current_taxes = self.env['account.tax'].search([('company_id', '=', company.id)])
+        unique_tax_name_key = lambda t: (t.name, t.type_tax_use, t.tax_scope, t.company_id)
+        unique_tax_name_keys = set(current_taxes.mapped(unique_tax_name_key))
+        xmlid2tax = {
+            xml_id.split('.')[1].split('_', maxsplit=1)[1]: self.env['account.tax'].browse(record)
+            for record, xml_id in current_taxes.get_external_id().items()
+        }
+        def tax_template_changed(tax, template):
+            return (
+                tax.amount_type != template.get('amount_type', 'percent')
+                or tax.amount != template.get('amount', 0)
+            )
+
+        obsolete_xmlid = set()
+        for model_name, records in data.items():
+            _fields = self.env[model_name]._fields
+            for xmlid, values in records.items():
+                x2manyfields = [
+                    fname
+                    for fname in values
+                    if fname in _fields
+                    and _fields[fname].type in ('one2many', 'many2many')
+                    and isinstance(values[fname], (list, tuple))
+                ]
+                if x2manyfields:
+                    rec = self.ref(xmlid, raise_if_not_found=False)
+                    if rec:
+                        for fname in x2manyfields:
+                            for i, (line, vals) in enumerate(zip(rec[fname], values[fname])):
+                                values[fname][i] = Command.update(line.id, vals[2])
+
+                if model_name == 'account.fiscal.position':
+                    # Only add tax mappings containing new taxes
+                    values['tax_ids'] = [
+                        (command, id, vals)
+                        for command, id, vals in values.get('tax_ids', [])
+                        if (
+                            command not in (Command.UPDATE, Command.CREATE)
+                            or not self.ref(vals['tax_src_id'], raise_if_not_found=False)
+                            or not self.ref(vals['tax_dest_id'], raise_if_not_found=False)
+                        )
+                    ]
+                elif model_name == 'account.tax':
+                    # Only update the tags of existing taxes
+                    if xmlid not in xmlid2tax or tax_template_changed(xmlid2tax[xmlid], values):
+                        if xmlid in xmlid2tax:
+                            obsolete_xmlid.add(xmlid)
+                            oldtax = xmlid2tax[xmlid]
+                            if unique_tax_name_key(oldtax) in unique_tax_name_keys:
+                                oldtax.name = f"[old] {oldtax.name}"
+                    else:
+                        repartition_lines = values.get('repartition_line_ids')
+                        values.clear()
+                        if repartition_lines:
+                            values['repartition_line_ids'] = repartition_lines
+                            for _c, _id, repartition_line in values.get('repartition_line_ids', []):
+                                tags = repartition_line.get('tag_ids')
+                                repartition_line.clear()
+                                if tags:
+                                    repartition_line['tag_ids'] = tags
+
+        if obsolete_xmlid:
+            self.env['ir.model.data'].search([
+                ('name', 'in', [f"{company.id}_{xmlid}" for xmlid in obsolete_xmlid]),
+                ('module', '=', 'account'),
+            ]).unlink()
+
+    def _pre_load_data(self, template_code, company, template_data, data):
+        """Pre-process the data and preload some values.
+
+        Some of the data needs special pre_process before being fed to the database.
+        e.g. the account codes' width must be standardized to the code_digits applied.
+        The fiscal country code must be put in place before taxes are generated.
+        """
+        if 'account_fiscal_country_id' in data['res.company'][company.id]:
+            fiscal_country = self.ref(data['res.company'][company.id]['account_fiscal_country_id'])
+        else:
+            fiscal_country = company.account_fiscal_country_id
 
-        if not company.account_journal_payment_credit_account_id:
-            company.account_journal_payment_credit_account_id = self.env['account.account'].create({
-                'name': _("Outstanding Payments"),
-                'code': self.env['account.account']._search_new_account_code(company, self.code_digits, company.bank_account_code_prefix or ''),
-                'reconcile': True,
-                'account_type': 'asset_current',
-                'company_id': company.id,
-            })
+        # Apply template data to the company
+        filter_properties = lambda key: (
+            (not key.startswith("property_") or key.startswith("property_stock_") or key == "additional_properties")
+            and key != 'name'
+            and key in company._fields
+        )
 
-        if not company.default_cash_difference_expense_account_id:
-            company.default_cash_difference_expense_account_id = self.env['account.account'].create({
-                'name': _('Cash Difference Loss'),
-                'code': self.env['account.account']._search_new_account_code(company, self.code_digits, '999'),
-                'account_type': 'expense',
-                'tag_ids': [(6, 0, self.env.ref('account.account_tag_investing').ids)],
-                'company_id': company.id,
-            })
-
-        if not company.default_cash_difference_income_account_id:
-            company.default_cash_difference_income_account_id = self.env['account.account'].create({
-                'name': _('Cash Difference Gain'),
-                'code': self.env['account.account']._search_new_account_code(company, self.code_digits, '999'),
-                'account_type': 'income',
-                'tag_ids': [(6, 0, self.env.ref('account.account_tag_investing').ids)],
-                'company_id': company.id,
-            })
-
-        # Set the transfer account on the company
-        company.transfer_account_id = self.env['account.account'].search([
-            ('code', '=like', self.transfer_account_code_prefix + '%'), ('company_id', '=', company.id)], limit=1)
-
-        # Create Bank journals
-        self._create_bank_journals(company, acc_template_ref)
-
-        # Create the current year earning account if it wasn't present in the CoA
-        company.get_unaffected_earnings_account()
+        # Set the currency to the fiscal country's currency
+        vals = {key: val for key, val in template_data.items() if filter_properties(key)}
+        vals['currency_id'] = fiscal_country.currency_id.id
+        if not company.country_id:
+            vals['country_id'] = fiscal_country.id
 
-        # set the default taxes on the company
-        company.account_sale_tax_id = self.env['account.tax'].search([('type_tax_use', 'in', ('sale', 'all')), ('company_id', '=', company.id)], limit=1).id
-        company.account_purchase_tax_id = self.env['account.tax'].search([('type_tax_use', 'in', ('purchase', 'all')), ('company_id', '=', company.id)], limit=1).id
+        # This write method is important because it's overridden and has additional triggers
+        # e.g it activates the currency
+        company.write(vals)
 
-        return {}
+        # Normalize the code_digits of the accounts
+        code_digits = int(template_data.get('code_digits', 6))
+        for key, account_data in data.get('account.account', {}).items():
+            data['account.account'][key]['code'] = f'{account_data["code"]:<0{code_digits}}'
 
-    @api.model
-    def existing_accounting(self, company_id):
-        """ Returns True iff some accounting entries have already been made for
-        the provided company (meaning hence that its chart of accounts cannot
-        be changed anymore).
-        """
-        model_to_check = ['account.payment', 'account.bank.statement.line']
-        for model in model_to_check:
-            if self.env[model].sudo().search([('company_id', '=', company_id.id)], order="id DESC", limit=1):
-                return True
-        if self.env['account.move'].sudo().search([('company_id', '=', company_id.id), ('state', '!=', 'draft')], order="id DESC", limit=1):
-            return True
-        return False
-
-    def _get_chart_parent_ids(self):
-        """ Returns the IDs of all ancestor charts, including the chart itself.
-            (inverse of child_of operator)
-
-            :return: the IDS of all ancestor charts, including the chart itself.
-        """
-        chart_template = self
-        result = [chart_template.id]
-        while chart_template.parent_id:
-            chart_template = chart_template.parent_id
-            result.append(chart_template.id)
-        return result
-
-    def _create_bank_journals(self, company, acc_template_ref):
-        '''
-        This function creates bank journals and their account for each line
-        data returned by the function _get_default_bank_journals_data.
-
-        :param company: the company for which the wizard is running.
-        :param acc_template_ref: the dictionary containing the mapping between the ids of account templates and the ids
-            of the accounts that have been generated from them.
-        '''
-        self.ensure_one()
-        bank_journals = self.env['account.journal']
-        # Create the journals that will trigger the account.account creation
-        for acc in self._get_default_bank_journals_data():
-            bank_journals += self.env['account.journal'].create({
-                'name': acc['acc_name'],
-                'type': acc['account_type'],
-                'company_id': company.id,
-                'currency_id': acc.get('currency_id', self.env['res.currency']).id,
-                'sequence': 10,
-            })
-
-        return bank_journals
-
-    @api.model
-    def _get_default_bank_journals_data(self):
-        """ Returns the data needed to create the default bank journals when
-        installing this chart of accounts, in the form of a list of dictionaries.
-        The allowed keys in these dictionaries are:
-            - acc_name: string (mandatory)
-            - account_type: 'cash' or 'bank' (mandatory)
-            - currency_id (optional, only to be specified if != company.currency_id)
-        """
-        return [{'acc_name': _('Cash'), 'account_type': 'cash'}, {'acc_name': _('Bank'), 'account_type': 'bank'}]
+        for model in ('account.fiscal.position', 'account.reconcile.model'):
+            if model in data:
+                data[model] = data.pop(model)
 
-    @api.model
-    def generate_journals(self, acc_template_ref, company, journals_dict=None):
-        """
-        This method is used for creating journals.
+        return data
 
-        :param acc_template_ref: Account templates reference.
-        :param company_id: company to generate journals for.
-        :returns: True
-        """
-        JournalObj = self.env['account.journal']
-        for vals_journal in self._prepare_all_journals(acc_template_ref, company, journals_dict=journals_dict):
-            journal = JournalObj.create(vals_journal)
-            if vals_journal['type'] == 'general' and vals_journal['code'] == _('EXCH'):
-                company.write({'currency_exchange_journal_id': journal.id})
-            if vals_journal['type'] == 'general' and vals_journal['code'] == _('CABA'):
-                company.write({'tax_cash_basis_journal_id': journal.id})
-        return True
-
-    def _prepare_all_journals(self, acc_template_ref, company, journals_dict=None):
-        def _get_default_account(journal_vals, type='debit'):
-            # Get the default accounts
-            default_account = False
-            if journal['type'] == 'sale':
-                default_account = acc_template_ref.get(self.property_account_income_categ_id).id
-            elif journal['type'] == 'purchase':
-                default_account = acc_template_ref.get(self.property_account_expense_categ_id).id
-
-            return default_account
-
-        journals = [{'name': _('Customer Invoices'), 'type': 'sale', 'code': _('INV'), 'favorite': True, 'color': 11, 'sequence': 5},
-                    {'name': _('Vendor Bills'), 'type': 'purchase', 'code': _('BILL'), 'favorite': True, 'color': 11, 'sequence': 6},
-                    {'name': _('Miscellaneous Operations'), 'type': 'general', 'code': _('MISC'), 'favorite': True, 'sequence': 7},
-                    {'name': _('Exchange Difference'), 'type': 'general', 'code': _('EXCH'), 'favorite': False, 'sequence': 9},
-                    {'name': _('Cash Basis Taxes'), 'type': 'general', 'code': _('CABA'), 'favorite': False, 'sequence': 10}]
-        if journals_dict != None:
-            journals.extend(journals_dict)
-
-        self.ensure_one()
-        journal_data = []
-        for journal in journals:
-            vals = {
-                'type': journal['type'],
-                'name': journal['name'],
-                'code': journal['code'],
-                'company_id': company.id,
-                'default_account_id': _get_default_account(journal),
-                'show_on_dashboard': journal['favorite'],
-                'color': journal.get('color', False),
-                'sequence': journal['sequence']
-            }
-            journal_data.append(vals)
-        return journal_data
+    def _load_data(self, data):
+        """Load all the data linked to the template into the database.
 
-    def generate_properties(self, acc_template_ref, company):
-        """
-        This method used for creating properties.
+        The data can contain translation values (i.e. `name@fr_FR` to translate the name in French)
+        An xml_id tht doesn't contain a `.` will be treated as being linked to `account` and prefixed
+        with the company's id (i.e. `cash` is interpreted as `account.1_cash` if the company's id is 1)
 
-        :param acc_template_ref: Mapping between ids of account templates and real accounts created from them
-        :param company_id: company to generate properties for.
-        :returns: True
-        """
-        self.ensure_one()
-        PropertyObj = self.env['ir.property']
-        todo_list = [
-            ('property_account_receivable_id', 'res.partner'),
-            ('property_account_payable_id', 'res.partner'),
-            ('property_account_expense_categ_id', 'product.category'),
-            ('property_account_income_categ_id', 'product.category'),
-            ('property_account_expense_id', 'product.template'),
-            ('property_account_income_id', 'product.template'),
-            ('property_tax_payable_account_id', 'account.tax.group'),
-            ('property_tax_receivable_account_id', 'account.tax.group'),
-            ('property_advance_tax_payment_account_id', 'account.tax.group'),
-        ]
-        for field, model in todo_list:
-            account = self[field]
-            value = acc_template_ref[account].id if account else False
-            if value:
-                PropertyObj._set_default(field, model, value, company=company)
-
-        stock_properties = [
-            'property_stock_account_input_categ_id',
-            'property_stock_account_output_categ_id',
-            'property_stock_valuation_account_id',
-        ]
-        for stock_property in stock_properties:
-            account = getattr(self, stock_property)
-            value = account and acc_template_ref[account].id or False
-            if value:
-                company.write({stock_property: value})
-        return True
-
-    def _install_template(self, company, code_digits=None, obj_wizard=None, acc_ref=None, taxes_ref=None):
-        """ Recursively load the template objects and create the real objects from them.
-
-            :param company: company the wizard is running for
-            :param code_digits: number of digits the accounts code should have in the COA
-            :param obj_wizard: the current wizard for generating the COA from the templates
-            :param acc_ref: Mapping between ids of account templates and real accounts created from them
-            :param taxes_ref: Mapping between ids of tax templates and real taxes created from them
-            :returns: tuple with a dictionary containing
-                * the mapping between the account template ids and the ids of the real accounts that have been generated
-                  from them, as first item,
-                * a similar dictionary for mapping the tax templates and taxes, as second item,
-            :rtype: tuple(dict, dict, dict)
-        """
-        self.ensure_one()
-        if acc_ref is None:
-            acc_ref = {}
-        if taxes_ref is None:
-            taxes_ref = {}
-        if self.parent_id:
-            tmp1, tmp2 = self.parent_id._install_template(company, code_digits=code_digits, acc_ref=acc_ref, taxes_ref=taxes_ref)
-            acc_ref.update(tmp1)
-            taxes_ref.update(tmp2)
-        # Ensure, even if individually, that everything is translated according to the company's language.
-        tmp1, tmp2 = self.with_context(lang=company.partner_id.lang)._load_template(company, code_digits=code_digits, account_ref=acc_ref, taxes_ref=taxes_ref)
-        acc_ref.update(tmp1)
-        taxes_ref.update(tmp2)
-        return acc_ref, taxes_ref
-
-    def _load_template(self, company, code_digits=None, account_ref=None, taxes_ref=None):
-        """ Generate all the objects from the templates
-
-            :param company: company the wizard is running for
-            :param code_digits: number of digits the accounts code should have in the COA
-            :param acc_ref: Mapping between ids of account templates and real accounts created from them
-            :param taxes_ref: Mapping between ids of tax templates and real taxes created from them
-            :returns: tuple with a dictionary containing
-                * the mapping between the account template ids and the ids of the real accounts that have been generated
-                  from them, as first item,
-                * a similar dictionary for mapping the tax templates and taxes, as second item,
-            :rtype: tuple(dict, dict, dict)
+        :param data: Basically all the final data of records to create/update for the chart
+                     of accounts. It is a mapping {model: {xml_id: values}}.
+        :type data: dict[str, dict[(str, int), dict]]
         """
-        self.ensure_one()
-        if account_ref is None:
-            account_ref = {}
-        if taxes_ref is None:
-            taxes_ref = {}
-        if not code_digits:
-            code_digits = self.code_digits
-        AccountTaxObj = self.env['account.tax']
-
-        # Generate taxes from templates.
-        generated_tax_res = self.with_context(active_test=False).tax_template_ids._generate_tax(company)
-        taxes_ref.update(generated_tax_res['tax_template_to_tax'])
-
-        # Generating Accounts from templates.
-        account_template_ref = self.generate_account(taxes_ref, account_ref, code_digits, company)
-        account_ref.update(account_template_ref)
-
-        # Generate account groups, from template
-        self.generate_account_groups(company)
-
-        # writing account values after creation of accounts
-        for tax, value in generated_tax_res['account_dict']['account.tax'].items():
-            if value['cash_basis_transition_account_id']:
-                tax.cash_basis_transition_account_id = account_ref.get(value['cash_basis_transition_account_id'])
-
-        for repartition_line, value in generated_tax_res['account_dict']['account.tax.repartition.line'].items():
-            if value['account_id']:
-                repartition_line.account_id = account_ref.get(value['account_id'])
-
-        # Set the company accounts
-        self._load_company_accounts(account_ref, company)
-
-        # Create Journals - Only done for root chart template
-        if not self.parent_id:
-            self.generate_journals(account_ref, company)
-
-        # generate properties function
-        self.generate_properties(account_ref, company)
-
-        # Generate Fiscal Position , Fiscal Position Accounts and Fiscal Position Taxes from templates
-        self.generate_fiscal_position(taxes_ref, account_ref, company)
-
-        # Generate account operation template templates
-        self.generate_account_reconcile_model(taxes_ref, account_ref, company)
-
-        return account_ref, taxes_ref
-
-    def _load_company_accounts(self, account_ref, company):
-        # Set the default accounts on the company
-        accounts = {
-            'default_cash_difference_income_account_id': self.default_cash_difference_income_account_id,
-            'default_cash_difference_expense_account_id': self.default_cash_difference_expense_account_id,
-            'account_journal_early_pay_discount_loss_account_id': self.account_journal_early_pay_discount_loss_account_id,
-            'account_journal_early_pay_discount_gain_account_id': self.account_journal_early_pay_discount_gain_account_id,
-            'account_journal_suspense_account_id': self.account_journal_suspense_account_id,
-            'account_journal_payment_debit_account_id': self.account_journal_payment_debit_account_id,
-            'account_journal_payment_credit_account_id': self.account_journal_payment_credit_account_id,
-            'account_cash_basis_base_account_id': self.property_cash_basis_base_account_id,
-            'account_default_pos_receivable_account_id': self.default_pos_receivable_account_id,
-            'income_currency_exchange_account_id': self.income_currency_exchange_account_id,
-            'expense_currency_exchange_account_id': self.expense_currency_exchange_account_id,
+        def deref(values, model):
+            """Replace xml_id references by database ids.
+
+            This allows to define all the data before the records even exist in the database.
+            """
+            fields = ((model._fields[k], k, v) for k, v in values.items() if k in model._fields)
+            for field, fname, value in fields:
+                if not value:
+                    values[fname] = False
+                elif isinstance(value, str) and (
+                    field.type == 'many2one'
+                    or (field.type in ('integer', 'many2one_reference') and not value.isdigit())
+                ):
+                    values[fname] = self.ref(value).id if value not in ('', 'False', 'None') else False
+                elif field.type in ('one2many', 'many2many') and isinstance(value[0], (list, tuple)):
+                    for i, (command, _id, *last_part) in enumerate(value):
+                        if last_part:
+                            last_part = last_part[0]
+                        # (0, 0, {'test': 'account.ref_name'}) -> Command.Create({'test': 13})
+                        if command in (Command.CREATE, Command.UPDATE):
+                            deref(last_part, self.env[field.comodel_name])
+                        # (6, 0, ['account.ref_name']) -> Command.Set([13])
+                        elif command == Command.SET:
+                            for subvalue_idx, subvalue in enumerate(last_part):
+                                if isinstance(subvalue, str):
+                                    last_part[subvalue_idx] = self.ref(subvalue).id
+                        elif command == Command.LINK and isinstance(_id, str):
+                            value[i] = Command.link(self.ref(_id).id)
+                elif field.type in ('one2many', 'many2many') and isinstance(value, str):
+                    values[fname] = [Command.set([
+                        self.ref(v).id
+                        for v in value.split(',')
+                        if v
+                    ])]
+            return values
+
+        def defer(all_data):
+            """Defer writing some relations if the related records don't exist yet."""
+            created_models = set()
+            while all_data:
+                (model, data), *all_data = all_data
+                to_delay = defaultdict(dict)
+                for xml_id, vals in data.items():
+                    to_be_removed = []
+                    for field_name in vals:
+                        field = self.env[model]._fields.get(field_name, None)
+                        if (field and
+                            field.relational and
+                            field.comodel_name not in created_models and
+                            (field.comodel_name in dict(all_data) or field.comodel_name == model)
+                        ):
+                            to_be_removed.append(field_name)
+                            to_delay[xml_id][field_name] = vals.get(field_name)
+                    for field_name in to_be_removed:
+                        del vals[field_name]
+                if any(to_delay.values()):
+                    all_data.append((model, to_delay))
+                yield model, data
+                created_models.add(model)
+
+        created_vals = {}
+        for model, data in defer(list(data.items())):
+            translate_vals = []
+            create_vals = []
+
+            for xml_id, record in data.items():
+                # Extract the translations from the values
+                if any('@' in key for key in record):
+                    translate_vals.append({
+                        translate.split('@')[1]: value
+                        for translate, value in record.items()
+                        if '@' in translate and value
+                    })
+                    translate_vals[-1]['en_US'] = record['name']
+                else:
+                    translate_vals.append(None)
+                for key in list(record):
+                    if '@' in key:
+                        del record[key]
+
+                # Manage ids given as database id or xml_id
+                if isinstance(xml_id, int):
+                    record['id'] = xml_id
+                    xml_id = False
+                else:
+                    xml_id = f"{('account.' + str(self.env.company.id) + '_') if '.' not in xml_id else ''}{xml_id}"
+
+                create_vals.append({
+                    'xml_id': xml_id,
+                    'values': deref(record, self.env[model]),
+                    'noupdate': True,
+                })
+            created_vals[model] = created = self.env[model]._load_records(create_vals)
+
+            # Update the translations in batch for all languages
+            translate_vals = [(r.id, Json(t)) for t, r in zip(translate_vals, created) if t]
+            if translate_vals:
+                self.env.cr.execute(f"""
+                    UPDATE "{self.env[model]._table}" AS m
+                    SET "name" =  t.value
+                    FROM (
+                        VALUES {', '.join(['(%s, %s::jsonb)'] * (len(translate_vals)))}
+                    ) AS t(id, value)
+                    WHERE m.id = t.id
+                """, [v for vals in translate_vals for v in vals])
+        return created_vals
+
+    def _post_load_data(self, template_code, company, template_data):
+        company = (company or self.env.company)
+        additional_properties = template_data.pop('additional_properties', {})
+
+        self._setup_utility_bank_accounts(template_code, company, template_data)
+
+        # Unaffected earnings account on the company (if not present yet)
+        company.get_unaffected_earnings_account()
+
+        # Set newly created Cash difference and Suspense accounts to the Cash and Bank journals
+        for journal in [self.ref(kind, raise_if_not_found=False) for kind in ('bank', 'cash')]:
+            if journal:
+                journal.suspense_account_id = journal.suspense_account_id or company.account_journal_suspense_account_id
+                journal.profit_account_id = journal.profit_account_id or company.default_cash_difference_income_account_id
+                journal.loss_account_id = journal.loss_account_id or company.default_cash_difference_expense_account_id
+
+        # Set newly created journals as defaults for the company
+        if not company.tax_cash_basis_journal_id:
+            company.tax_cash_basis_journal_id = self.ref('caba')
+        if not company.currency_exchange_journal_id:
+            company.currency_exchange_journal_id = self.ref('exch')
+
+        # Setup default Income/Expense Accounts on Sale/Purchase journals
+        sale_journal = self.ref("sale", raise_if_not_found=False)
+        if sale_journal and template_data.get('property_account_income_categ_id'):
+            sale_journal.default_account_id = self.ref(template_data.get('property_account_income_categ_id'))
+        purchase_journal = self.ref("purchase", raise_if_not_found=False)
+        if purchase_journal and template_data.get('property_account_expense_categ_id'):
+            purchase_journal.default_account_id = self.ref(template_data.get('property_account_expense_categ_id'))
+
+        # Set default Purchase and Sale taxes on the company
+        if not company.account_sale_tax_id:
+            company.account_sale_tax_id = self.env['account.tax'].search([
+                ('type_tax_use', 'in', ('sale', 'all')), ('company_id', '=', company.id)], limit=1).id
+        if not company.account_purchase_tax_id:
+            company.account_purchase_tax_id = self.env['account.tax'].search([
+                ('type_tax_use', 'in', ('purchase', 'all')), ('company_id', '=', company.id)], limit=1).id
+        # Display caba fields if there are caba taxes
+        if self.env['account.tax'].search([('tax_exigibility', '=', 'on_payment')]):
+            company.tax_exigibility = True
+
+        for field, model in {
+            **additional_properties,
+            'property_account_receivable_id': 'res.partner',
+            'property_account_payable_id': 'res.partner',
+            'property_account_expense_categ_id': 'product.category',
+            'property_account_income_categ_id': 'product.category',
+            'property_account_expense_id': 'product.template',
+            'property_account_income_id': 'product.template',
+            'property_stock_journal': 'product.category',
+            'property_stock_account_input_categ_id': 'product.category',
+            'property_stock_account_output_categ_id': 'product.category',
+            'property_stock_valuation_account_id': 'product.category',
+        }.items():
+            value = template_data.get(field)
+            if value and field in self.env[model]._fields:
+                self.env['ir.property']._set_default(field, model, self.ref(value).id, company=company)
+
+    def _get_chart_template_data(self, template_code):
+        template_data = defaultdict(lambda: defaultdict(dict))
+        template_data['res.company']
+        for code in [None] + self._get_parent_template(template_code):
+            for model, funcs in sorted(
+                self._template_register[code].items(),
+                key=lambda i: TEMPLATE_MODELS.index(i[0]) if i[0] in TEMPLATE_MODELS else 1000
+            ):
+                for func in funcs:
+                    data = func(self, template_code)
+                    if data is not None:
+                        if model == 'template_data':
+                            template_data[model].update(data)
+                        else:
+                            for xmlid, record in data.items():
+                                template_data[model][xmlid].update(record)
+        return template_data
+
+    def _setup_utility_bank_accounts(self, template_code, company, template_data):
+        """Define basic bank accounts for the company.
+
+        - Suspense Account
+        - Outstanding Receipts/Payments Accounts
+        - Cash Difference Gain/Loss Accounts
+        - Liquidity Transfer Account
+        """
+        # Create utility bank_accounts
+        bank_prefix = company.bank_account_code_prefix
+        code_digits = int(template_data.get('code_digits', 6))
+        accounts_data = {
+            'account_journal_suspense_account_id': {
+                'name': _("Bank Suspense Account"),
+                'prefix': bank_prefix,
+                'code_digits': code_digits,
+                'account_type': 'asset_current',
+            },
+            'account_journal_payment_debit_account_id': {
+                'name': _("Outstanding Receipts"),
+                'prefix': bank_prefix,
+                'code_digits': code_digits,
+                'account_type': 'asset_current',
+                'reconcile': True,
+            },
+            'account_journal_payment_credit_account_id': {
+                'name': _("Outstanding Payments"),
+                'prefix': bank_prefix,
+                'code_digits': code_digits,
+                'account_type': 'asset_current',
+                'reconcile': True,
+            },
+            'account_journal_early_pay_discount_loss_account_id': {
+                'name': _("Cash Discount Loss"),
+                'code': '999998',
+                'account_type': 'expense',
+            },
+            'account_journal_early_pay_discount_gain_account_id': {
+                'name': _("Cash Discount Gain"),
+                'code': '999997',
+                'account_type': 'income_other',
+            },
+            'default_cash_difference_income_account_id': {
+                'name': _("Cash Difference Gain"),
+                'prefix': '999',
+                'code_digits': code_digits,
+                'account_type': 'expense',
+                'tag_ids': [(6, 0, self.ref('account.account_tag_investing').ids)],
+            },
+            'default_cash_difference_expense_account_id': {
+                'name': _("Cash Difference Loss"),
+                'prefix': '999',
+                'code_digits': code_digits,
+                'account_type': 'expense',
+                'tag_ids': [(6, 0, self.ref('account.account_tag_investing').ids)],
+            },
+            'transfer_account_id': {
+                'name': _("Liquidity Transfer"),
+                'prefix': company.transfer_account_code_prefix,
+                'code_digits': code_digits,
+                'account_type': 'asset_current',
+                'reconcile': True,
+            },
         }
 
-        values = {}
+        for fname in list(accounts_data):
+            if company[fname]:
+                del accounts_data[fname]
 
-        # The loop is to avoid writing when we have no values, thus avoiding erasing the account from the parent
-        for key, account in accounts.items():
-            if account_ref.get(account):
-                values[key] = account_ref.get(account)
+        accounts = self.env['account.account'].create(accounts_data.values())
+        for company_attr_name, account in zip(accounts_data.keys(), accounts):
+            company[company_attr_name] = account
 
-        company.write(values)
+    # --------------------------------------------------------------------------------
+    # Root template functions
+    # --------------------------------------------------------------------------------
 
-    def create_record_with_xmlid(self, company, template, model, vals):
-        return self._create_records_with_xmlid(model, [(template, vals)], company).id
+    @template(model='account.account')
+    def _get_account_account(self, template_code):
+        return self._parse_csv(template_code, 'account.account')
 
-    def _create_records_with_xmlid(self, model, template_vals, company):
-        """ Create records for the given model name with the given vals, and
-            create xml ids based on each record's template and company id.
-        """
-        if not template_vals:
-            return self.env[model]
-        template_model = template_vals[0][0]
-        template_ids = [template.id for template, vals in template_vals]
-        template_xmlids = template_model.browse(template_ids).get_external_id()
-        data_list = []
-        for template, vals in template_vals:
-            module, name = template_xmlids[template.id].split('.', 1)
-            xml_id = "%s.%s_%s" % (module, company.id, name)
-            data_list.append(dict(xml_id=xml_id, values=vals, noupdate=True))
-        return self.env[model]._load_records(data_list)
-
-    @api.model
-    def _load_records(self, data_list, update=False):
-        # When creating a chart template create, for the liquidity transfer account
-        #  - an account.account.template: this allow to define account.reconcile.model.template objects refering that liquidity transfer
-        #    account although it's not existing in any xml file
-        #  - an entry in ir_model_data: this allow to still use the method create_record_with_xmlid() and don't make any difference between
-        #    regular accounts created and that liquidity transfer account
-        records = super(AccountChartTemplate, self)._load_records(data_list, update)
-        account_data_list = []
-        for data, record in zip(data_list, records):
-            # Create the transfer account only for leaf chart template in the hierarchy.
-            if record.parent_id:
-                continue
-            if data.get('xml_id'):
-                account_xml_id = data['xml_id'] + '_liquidity_transfer'
-                if not self.env.ref(account_xml_id, raise_if_not_found=False):
-                    account_vals = record._prepare_transfer_account_template()
-                    account_data_list.append(dict(
-                        xml_id=account_xml_id,
-                        values=account_vals,
-                        noupdate=data.get('noupdate'),
-                    ))
-        self.env['account.account.template']._load_records(account_data_list, update)
-        return records
-
-    def _get_account_vals(self, company, account_template, code_acc, tax_template_ref):
-        """ This method generates a dictionary of all the values for the account that will be created.
-        """
-        self.ensure_one()
-        tax_ids = []
-        for tax in account_template.tax_ids:
-            tax_ids.append(tax_template_ref[tax].id)
-        val = {
-                'name': account_template.name,
-                'currency_id': account_template.currency_id and account_template.currency_id.id or False,
-                'code': code_acc,
-                'account_type': account_template.account_type or False,
-                'reconcile': account_template.reconcile,
-                'note': account_template.note,
-                'tax_ids': [(6, 0, tax_ids)],
-                'company_id': company.id,
-                'tag_ids': [(6, 0, [t.id for t in account_template.tag_ids])],
-            }
-        return val
+    @template(model='account.group')
+    def _get_account_group(self, template_code):
+        return self._parse_csv(template_code, 'account.group')
 
-    def generate_account(self, tax_template_ref, acc_template_ref, code_digits, company):
-        """ This method generates accounts from account templates.
+    @template(model='account.tax.group')
+    def _get_account_tax_group(self, template_code):
+        return self._parse_csv(template_code, 'account.tax.group')
 
-        :param tax_template_ref: Taxes templates reference for write taxes_id in account_account.
-        :param acc_template_ref: dictionary containing the mapping between the account templates and generated accounts (will be populated)
-        :param code_digits: number of digits to use for account code.
-        :param company_id: company to generate accounts for.
-        :returns: return acc_template_ref for reference purpose.
-        :rtype: dict
-        """
-        self.ensure_one()
-        account_tmpl_obj = self.env['account.account.template']
-        acc_template = account_tmpl_obj.search([('nocreate', '!=', True), ('chart_template_id', '=', self.id)], order='id')
-        template_vals = []
-        for account_template in acc_template:
-            code_main = account_template.code and len(account_template.code) or 0
-            code_acc = account_template.code or ''
-            if code_main > 0 and code_main <= code_digits:
-                code_acc = str(code_acc) + (str('0'*(code_digits-code_main)))
-            vals = self._get_account_vals(company, account_template, code_acc, tax_template_ref)
-            template_vals.append((account_template, vals))
-        accounts = self._create_records_with_xmlid('account.account', template_vals, company)
-        for template, account in zip(acc_template, accounts):
-            acc_template_ref[template] = account
-        return acc_template_ref
-
-    def generate_account_groups(self, company):
-        """ This method generates account groups from account groups templates.
-        :param company: company to generate the account groups for
-        """
-        self.ensure_one()
-        group_templates = self.env['account.group.template'].search([('chart_template_id', '=', self.id)])
-        template_vals = []
-        for group_template in group_templates:
-            vals = {
-                'name': group_template.name,
-                'code_prefix_start': group_template.code_prefix_start,
-                'code_prefix_end': group_template.code_prefix_end,
-                'company_id': company.id,
-            }
-            template_vals.append((group_template, vals))
-        groups = self._create_records_with_xmlid('account.group', template_vals, company)
+    @template(model='account.tax')
+    def _get_account_tax(self, template_code):
+        tax_data = self._parse_csv(template_code, 'account.tax')
+        self._deref_account_tags(template_code, tax_data)
+        return tax_data
 
-    def _prepare_reconcile_model_vals(self, company, account_reconcile_model, acc_template_ref, tax_template_ref):
-        """ This method generates a dictionary of all the values for the account.reconcile.model that will be created.
-        """
-        self.ensure_one()
-        account_reconcile_model_lines = self.env['account.reconcile.model.line.template'].search([
-            ('model_id', '=', account_reconcile_model.id)
-        ])
+    @template(model='account.fiscal.position')
+    def _get_account_fiscal_position(self, template_code):
+        return self._parse_csv(template_code, 'account.fiscal.position')
+
+    @template(model='account.journal')
+    def _get_account_journal(self, template_code):
         return {
-            'name': account_reconcile_model.name,
-            'sequence': account_reconcile_model.sequence,
-            'company_id': company.id,
-            'rule_type': account_reconcile_model.rule_type,
-            'auto_reconcile': account_reconcile_model.auto_reconcile,
-            'to_check': account_reconcile_model.to_check,
-            'match_journal_ids': [(6, None, account_reconcile_model.match_journal_ids.ids)],
-            'match_nature': account_reconcile_model.match_nature,
-            'match_amount': account_reconcile_model.match_amount,
-            'match_amount_min': account_reconcile_model.match_amount_min,
-            'match_amount_max': account_reconcile_model.match_amount_max,
-            'match_label': account_reconcile_model.match_label,
-            'match_label_param': account_reconcile_model.match_label_param,
-            'match_note': account_reconcile_model.match_note,
-            'match_note_param': account_reconcile_model.match_note_param,
-            'match_transaction_type': account_reconcile_model.match_transaction_type,
-            'match_transaction_type_param': account_reconcile_model.match_transaction_type_param,
-            'match_same_currency': account_reconcile_model.match_same_currency,
-            'allow_payment_tolerance': account_reconcile_model.allow_payment_tolerance,
-            'payment_tolerance_type': account_reconcile_model.payment_tolerance_type,
-            'payment_tolerance_param': account_reconcile_model.payment_tolerance_param,
-            'match_partner': account_reconcile_model.match_partner,
-            'match_partner_ids': [(6, None, account_reconcile_model.match_partner_ids.ids)],
-            'match_partner_category_ids': [(6, None, account_reconcile_model.match_partner_category_ids.ids)],
-            'line_ids': [(0, 0, {
-                'account_id': acc_template_ref[line.account_id].id,
-                'label': line.label,
-                'amount_type': line.amount_type,
-                'force_tax_included': line.force_tax_included,
-                'amount_string': line.amount_string,
-                'tax_ids': [[4, tax_template_ref[tax].id, 0] for tax in line.tax_ids],
-            }) for line in account_reconcile_model_lines],
+            "sale": {
+                'name': _('Customer Invoices'),
+                'type': 'sale',
+                'code': _('INV'),
+                'show_on_dashboard': True,
+                'color': 11,
+                'sequence': 5,
+            },
+            "purchase": {
+                'name': _('Vendor Bills'),
+                'type': 'purchase',
+                'code': _('BILL'),
+                'show_on_dashboard': True,
+                'color': 11,
+                'sequence': 6,
+            },
+            "general": {
+                'name': _('Miscellaneous Operations'),
+                'type': 'general',
+                'code': _('MISC'),
+                'show_on_dashboard': True,
+                'sequence': 7,
+            },
+            "exch": {
+                'name': _('Exchange Difference'),
+                'type': 'general',
+                'code': _('EXCH'),
+                'show_on_dashboard': False,
+                'sequence': 9,
+            },
+            "caba": {
+                'name': _('Cash Basis Taxes'),
+                'type': 'general',
+                'code': _('CABA'),
+                'show_on_dashboard': False,
+                'sequence': 10,
+            },
+            "bank": {
+                'name': _('Bank'),
+                'type': 'bank',
+                'show_on_dashboard': True,
+            },
+            "cash": {
+                'name': _('Cash'),
+                'type': 'cash',
+                'show_on_dashboard': True,
+            },
         }
 
-    def generate_account_reconcile_model(self, tax_template_ref, acc_template_ref, company):
-        """ This method creates account reconcile models
-
-        :param tax_template_ref: Taxes templates reference for write taxes_id in account_account.
-        :param acc_template_ref: dictionary with the mapping between the account templates and the real accounts.
-        :param company_id: company to create models for
-        :returns: return new_account_reconcile_model for reference purpose.
-        :rtype: dict
-        """
-        self.ensure_one()
-        account_reconcile_models = self.env['account.reconcile.model.template'].search([
-            ('chart_template_id', '=', self.id)
-        ])
-        for account_reconcile_model in account_reconcile_models:
-            vals = self._prepare_reconcile_model_vals(company, account_reconcile_model, acc_template_ref, tax_template_ref)
-            self.create_record_with_xmlid(company, account_reconcile_model, 'account.reconcile.model', vals)
-
-        # Create default rules for the reconciliation widget matching invoices automatically.
-        if not self.parent_id:
-            self.env['account.reconcile.model'].sudo().create({
+    @template(model='account.reconcile.model')
+    def _get_account_reconcile_model(self, template_code):
+        return {
+            "reconcile_perfect_match": {
                 "name": _('Invoices/Bills Perfect Match'),
-                "sequence": '1',
+                "sequence": 1,
                 "rule_type": 'invoice_matching',
                 "auto_reconcile": True,
                 "match_nature": 'both',
@@ -1000,661 +691,88 @@ class AccountChartTemplate(models.Model):
                 "payment_tolerance_type": 'percentage',
                 "payment_tolerance_param": 0,
                 "match_partner": True,
-                "company_id": company.id,
-            })
-
-            self.env['account.reconcile.model'].sudo().create({
+            },
+            "reconcile_partial_underpaid": {
                 "name": _('Invoices/Bills Partial Match if Underpaid'),
-                "sequence": '2',
+                "sequence": 2,
                 "rule_type": 'invoice_matching',
                 "auto_reconcile": False,
                 "match_nature": 'both',
                 "match_same_currency": True,
                 "allow_payment_tolerance": False,
                 "match_partner": True,
-                "company_id": company.id,
-            })
-
-        return True
-
-    def _get_fp_vals(self, company, position):
-        return {
-            'company_id': company.id,
-            'sequence': position.sequence,
-            'name': position.name,
-            'note': position.note,
-            'auto_apply': position.auto_apply,
-            'vat_required': position.vat_required,
-            'country_id': position.country_id.id,
-            'country_group_id': position.country_group_id.id,
-            'state_ids': position.state_ids and [(6,0, position.state_ids.ids)] or [],
-            'zip_from': position.zip_from,
-            'zip_to': position.zip_to,
-        }
-
-    def generate_fiscal_position(self, tax_template_ref, acc_template_ref, company):
-        """ This method generates Fiscal Position, Fiscal Position Accounts
-        and Fiscal Position Taxes from templates.
-
-        :param taxes_ids: Taxes templates reference for generating account.fiscal.position.tax.
-        :param acc_template_ref: Account templates reference for generating account.fiscal.position.account.
-        :param company_id: the company to generate fiscal position data for
-        :returns: True
-        """
-        self.ensure_one()
-        positions = self.env['account.fiscal.position.template'].search([('chart_template_id', '=', self.id)])
-
-        # first create fiscal positions in batch
-        template_vals = []
-        for position in positions:
-            fp_vals = self._get_fp_vals(company, position)
-            template_vals.append((position, fp_vals))
-        fps = self._create_records_with_xmlid('account.fiscal.position', template_vals, company)
-
-        # then create fiscal position taxes and accounts
-        tax_template_vals = []
-        account_template_vals = []
-        for position, fp in zip(positions, fps):
-            for tax in position.tax_ids:
-                tax_template_vals.append((tax, {
-                    'tax_src_id': tax_template_ref[tax.tax_src_id].id,
-                    'tax_dest_id': tax.tax_dest_id and tax_template_ref[tax.tax_dest_id].id or False,
-                    'position_id': fp.id,
-                }))
-            for acc in position.account_ids:
-                account_template_vals.append((acc, {
-                    'account_src_id': acc_template_ref[acc.account_src_id].id,
-                    'account_dest_id': acc_template_ref[acc.account_dest_id].id,
-                    'position_id': fp.id,
-                }))
-        self._create_records_with_xmlid('account.fiscal.position.tax', tax_template_vals, company)
-        self._create_records_with_xmlid('account.fiscal.position.account', account_template_vals, company)
-
-        return True
-
-
-class AccountTaxTemplate(models.Model):
-    _name = 'account.tax.template'
-    _description = 'Templates for Taxes'
-    _order = 'id'
-
-    chart_template_id = fields.Many2one('account.chart.template', string='Chart Template', required=True)
-
-    name = fields.Char(string='Tax Name', required=True)
-    type_tax_use = fields.Selection(TYPE_TAX_USE, string='Tax Type', required=True, default="sale",
-        help="Determines where the tax is selectable. Note : 'None' means a tax can't be used by itself, however it can still be used in a group.")
-    tax_scope = fields.Selection([('service', 'Service'), ('consu', 'Consumable')], help="Restrict the use of taxes to a type of product.")
-    amount_type = fields.Selection(default='percent', string="Tax Computation", required=True,
-        selection=[('group', 'Group of Taxes'), ('fixed', 'Fixed'), ('percent', 'Percentage of Price'), ('division', 'Percentage of Price Tax Included')])
-    active = fields.Boolean(default=True, help="Set active to false to hide the tax without removing it.")
-    children_tax_ids = fields.Many2many('account.tax.template', 'account_tax_template_filiation_rel', 'parent_tax', 'child_tax', string='Children Taxes')
-    sequence = fields.Integer(required=True, default=1,
-        help="The sequence field is used to define order in which the tax lines are applied.")
-    amount = fields.Float(required=True, digits=(16, 4), default=0)
-    description = fields.Char(string='Display on Invoices')
-    price_include = fields.Boolean(string='Included in Price', default=False,
-        help="Check this if the price you use on the product and invoices includes this tax.")
-    include_base_amount = fields.Boolean(string='Affect Subsequent Taxes', default=False,
-        help="If set, taxes with a higher sequence than this one will be affected by it, provided they accept it.")
-    is_base_affected = fields.Boolean(
-        string="Base Affected by Previous Taxes",
-        default=True,
-        help="If set, taxes with a lower sequence might affect this one, provided they try to do it.")
-    analytic = fields.Boolean(string="Analytic Cost", help="If set, the amount computed by this tax will be assigned to the same analytic account as the invoice line (if any)")
-    invoice_repartition_line_ids = fields.One2many(string="Repartition for Invoices", comodel_name="account.tax.repartition.line.template", inverse_name="invoice_tax_id", copy=True, help="Repartition when the tax is used on an invoice")
-    refund_repartition_line_ids = fields.One2many(string="Repartition for Refund Invoices", comodel_name="account.tax.repartition.line.template", inverse_name="refund_tax_id", copy=True, help="Repartition when the tax is used on a refund")
-    tax_group_id = fields.Many2one('account.tax.group', string="Tax Group")
-    tax_exigibility = fields.Selection(
-        [('on_invoice', 'Based on Invoice'),
-         ('on_payment', 'Based on Payment'),
-        ], string='Tax Due', default='on_invoice',
-        help="Based on Invoice: the tax is due as soon as the invoice is validated.\n"
-        "Based on Payment: the tax is due as soon as the payment of the invoice is received.")
-    cash_basis_transition_account_id = fields.Many2one(
-        comodel_name='account.account.template',
-        string="Cash Basis Transition Account",
-        domain=[('deprecated', '=', False)],
-        help="Account used to transition the tax amount for cash basis taxes. It will contain the tax amount as long as the original invoice has not been reconciled ; at reconciliation, this amount cancelled on this account and put on the regular tax account.")
-
-    _sql_constraints = [
-        ('name_company_uniq', 'unique(name, type_tax_use, tax_scope, chart_template_id)', 'Tax names must be unique !'),
-    ]
-
-    @api.depends('name', 'description')
-    def name_get(self):
-        res = []
-        for record in self:
-            name = record.description and record.description or record.name
-            res.append((record.id, name))
-        return res
-
-    @api.model
-    def _try_instantiating_foreign_taxes(self, country, company):
-        """ This function is called in multivat setup, when a company needs to submit a
-        tax report in a foreign country.
-
-        It searches for tax templates in the provided countries and instantiates the
-        ones it find in the provided company.
-
-        Tax accounts are not kept from the templates (this wouldn't make sense,
-        as they don't belong to the same CoA as the one installed on the company).
-        Instead, we search existing tax accounts for approximately equivalent accounts
-        and use their prefix to create new accounts. Doing this gives a roughly correct suggestion
-        that then needs to be reviewed by the user to ensure its consistency.
-        It is intended as a shortcut to avoid hours of encoding, not as an out-of-the-box, always
-        correct solution.
-        """
-        def create_foreign_tax_account(existing_account, additional_label):
-            new_code = self.env['account.account']._search_new_account_code(existing_account.company_id, len(existing_account.code), existing_account.code[:-2])
-            return self.env['account.account'].create({
-                'name': f"{existing_account.name} - {additional_label}",
-                'code': new_code,
-                'account_type': existing_account.account_type,
-                'company_id': existing_account.company_id.id,
-            })
-
-        def get_existing_tax_account(foreign_tax_rep_line, force_tax=None):
-            company = foreign_tax_rep_line.company_id
-            sign_comparator = '<' if foreign_tax_rep_line.factor_percent < 0 else '>'
-
-            search_domain = [
-                ('account_id', '!=', False),
-                ('factor_percent', sign_comparator, 0),
-                ('company_id', '=', company.id),
-                '|',
-                '&', ('invoice_tax_id.type_tax_use', '=', tax_rep_line.invoice_tax_id.type_tax_use),
-                     ('invoice_tax_id.country_id', '=', company.account_fiscal_country_id.id),
-                '&', ('refund_tax_id.type_tax_use', '=', tax_rep_line.refund_tax_id.type_tax_use),
-                     ('refund_tax_id.country_id', '=', company.account_fiscal_country_id.id),
-            ]
-
-            if force_tax:
-                search_domain += [
-                    '|', ('invoice_tax_id', 'in', force_tax.ids),
-                    ('refund_tax_id', 'in', force_tax.ids),
-                ]
-
-            return self.env['account.tax.repartition.line'].search(search_domain, limit=1).account_id
-
-
-        taxes_in_country = self.env['account.tax'].search([
-            ('country_id', '=', country.id),
-            ('company_id', '=', company.id)
-        ])
-
-        if taxes_in_country:
-            return
-
-        templates_to_instantiate = self.env['account.tax.template'].with_context(active_test=False).search([('chart_template_id.country_id', '=', country.id)])
-        default_company_taxes = company.account_sale_tax_id + company.account_purchase_tax_id
-        rep_lines_accounts = templates_to_instantiate._generate_tax(company)['account_dict']
-
-        new_accounts_map = {}
-
-        # Handle tax repartition line accounts
-        tax_rep_lines_accounts_dict = rep_lines_accounts['account.tax.repartition.line']
-        for tax_rep_line, account_dict in tax_rep_lines_accounts_dict.items():
-            account_template = account_dict['account_id']
-            rep_account = new_accounts_map.get(account_template)
-
-            if not rep_account:
-
-                existing_account = get_existing_tax_account(tax_rep_line, force_tax=default_company_taxes)
-
-                if not existing_account:
-                    # If the default taxes were not enough to provide the account
-                    # we need, search on all other taxes.
-                    existing_account = get_existing_tax_account(tax_rep_line)
-
-                if existing_account:
-                    rep_account = create_foreign_tax_account(existing_account, _("Foreign tax account (%s)", country.code))
-                    new_accounts_map[account_template] = rep_account
-
-            tax_rep_line.account_id = rep_account
-
-        # Handle cash basis taxes transtion account
-        caba_transition_dict = rep_lines_accounts['account.tax']
-        for tax, account_dict in caba_transition_dict.items():
-            transition_account_template = account_dict['cash_basis_transition_account_id']
-
-            if transition_account_template:
-                transition_account = new_accounts_map.get(transition_account_template)
-
-                if not transition_account:
-                    rep_lines = tax.invoice_repartition_line_ids + tax.refund_repartition_line_ids
-                    tax_accounts = rep_lines.account_id
-
-                    if tax_accounts:
-                        transition_account = create_foreign_tax_account(tax_accounts[0], _("Cash basis transition account"))
-
-                tax.cash_basis_transition_account_id = transition_account
-
-        # Setup tax closing accounts on foreign tax groups ; we don't want to use the domestic accounts
-        groups = self.env['account.tax.group'].search([('country_id', '=', country.id)])
-        group_property_fields = [
-            'property_tax_payable_account_id',
-            'property_tax_receivable_account_id',
-            'property_advance_tax_payment_account_id'
-        ]
-
-        property_company = self.env['ir.property'].with_company(company)
-        groups_company = groups.with_company(company)
-        for property_field in group_property_fields:
-            default_acc = property_company._get(property_field, 'account.tax.group')
-            if default_acc:
-                groups_company.write({
-                    property_field: create_foreign_tax_account(default_acc, _("Foreign account (%s)", country.code))
-                })
-
-    def _get_tax_vals(self, company, tax_template_to_tax):
-        """ This method generates a dictionary of all the values for the tax that will be created.
-        """
-        # Compute children tax ids
-        children_ids = []
-        for child_tax in self.children_tax_ids:
-            if tax_template_to_tax.get(child_tax):
-                children_ids.append(tax_template_to_tax[child_tax].id)
-        self.ensure_one()
-        val = {
-            'name': self.name,
-            'type_tax_use': self.type_tax_use,
-            'tax_scope': self.tax_scope,
-            'amount_type': self.amount_type,
-            'active': self.active,
-            'company_id': company.id,
-            'sequence': self.sequence,
-            'amount': self.amount,
-            'description': self.description,
-            'price_include': self.price_include,
-            'include_base_amount': self.include_base_amount,
-            'is_base_affected': self.is_base_affected,
-            'analytic': self.analytic,
-            'children_tax_ids': [(6, 0, children_ids)],
-            'tax_exigibility': self.tax_exigibility,
-        }
-
-        # We add repartition lines if there are some, so that if there are none,
-        # default_get is called and creates the default ones properly.
-        if self.invoice_repartition_line_ids:
-            val['invoice_repartition_line_ids'] = self.invoice_repartition_line_ids.get_repartition_line_create_vals(company)
-        if self.refund_repartition_line_ids:
-            val['refund_repartition_line_ids'] = self.refund_repartition_line_ids.get_repartition_line_create_vals(company)
-
-        if self.tax_group_id:
-            val['tax_group_id'] = self.tax_group_id.id
-        return val
-
-    def _get_tax_vals_complete(self, company):
-        """
-        Returns a dict of values to be used to create the tax corresponding to the template, assuming the
-        account.account objects were already created.
-        It differs from function _get_tax_vals because here, we replace the references to account.template by their
-        corresponding account.account ids ('cash_basis_transition_account_id' and 'account_id' in the invoice and
-        refund repartition lines)
-        (Used by upgrade/migrations/util/accounting)
-        """
-        vals = self._get_tax_vals(company, {})
-        vals.pop("children_tax_ids", None)
-
-        if self.cash_basis_transition_account_id.code:
-            cash_basis_account_id = self.env['account.account'].search([
-                ('code', '=like', self.cash_basis_transition_account_id.code + '%'),
-                ('company_id', '=', company.id)
-            ], limit=1)
-            if cash_basis_account_id:
-                vals.update({"cash_basis_transition_account_id": cash_basis_account_id.id})
-
-        vals.update({
-            "invoice_repartition_line_ids": self.invoice_repartition_line_ids._get_repartition_line_create_vals_complete(company),
-            "refund_repartition_line_ids": self.refund_repartition_line_ids._get_repartition_line_create_vals_complete(company),
-        })
-        return vals
-
-    def _generate_tax(self, company):
-        """ This method generate taxes from templates.
-
-            :param company: the company for which the taxes should be created from templates in self
-            :returns: {
-                'tax_template_to_tax': mapping between tax template and the newly generated taxes corresponding,
-                'account_dict': dictionary containing a to-do list with all the accounts to assign on new taxes
             }
-        """
-        # default_company_id is needed in context to allow creation of default
-        # repartition lines on taxes
-        ChartTemplate = self.env['account.chart.template'].with_context(default_company_id=company.id)
-        todo_dict = {'account.tax': {}, 'account.tax.repartition.line': {}}
-        tax_template_to_tax = {}
-
-        templates_todo = list(self)
-        while templates_todo:
-            templates = templates_todo
-            templates_todo = []
-
-            # create taxes in batch
-            tax_template_vals = []
-            for template in templates:
-                if all(child in tax_template_to_tax for child in template.children_tax_ids):
-                    vals = template._get_tax_vals(company, tax_template_to_tax)
-
-                    if self.chart_template_id.country_id:
-                        vals['country_id'] = self.chart_template_id.country_id.id
-                    elif company.account_fiscal_country_id:
-                        vals['country_id'] = company.account_fiscal_country_id.id
-                    else:
-                        # Will happen for generic CoAs such as syscohada (they are available for multiple countries, and don't have any country_id)
-                        raise UserError(_("Please first define a fiscal country for company %s.", company.name))
-
-                    tax_template_vals.append((template, vals))
-                else:
-                    # defer the creation of this tax to the next batch
-                    templates_todo.append(template)
-            taxes = ChartTemplate._create_records_with_xmlid('account.tax', tax_template_vals, company)
-
-            # fill in tax_template_to_tax and todo_dict
-            for tax, (template, vals) in zip(taxes, tax_template_vals):
-                tax_template_to_tax[template] = tax
-                # Since the accounts have not been created yet, we have to wait before filling these fields
-                todo_dict['account.tax'][tax] = {
-                    'cash_basis_transition_account_id': template.cash_basis_transition_account_id,
-                }
-
-                # We also have to delay the assignation of accounts to repartition lines
-                # The below code assigns the account_id to the repartition lines according
-                # to the corresponding repartition line in the template, based on the order.
-                # As we just created the repartition lines, tax.invoice_repartition_line_ids is not well sorted.
-                # But we can force the sort by calling sort()
-                all_tax_rep_lines = tax.invoice_repartition_line_ids.sorted() + tax.refund_repartition_line_ids.sorted()
-                all_template_rep_lines = template.invoice_repartition_line_ids + template.refund_repartition_line_ids
-                for i in range(0, len(all_template_rep_lines)):
-                    # We assume template and tax repartition lines are in the same order
-                    template_account = all_template_rep_lines[i].account_id
-                    if template_account:
-                        todo_dict['account.tax.repartition.line'][all_tax_rep_lines[i]] = {
-                            'account_id': template_account,
-                        }
-
-        if any(template.tax_exigibility == 'on_payment' for template in self):
-            # When a CoA is being installed automatically and if it is creating account tax(es) whose field `Use Cash Basis`(tax_exigibility) is set to True by default
-            # (example of such CoA's are l10n_fr and l10n_mx) then in the `Accounting Settings` the option `Cash Basis` should be checked by default.
-            company.tax_exigibility = True
-
-        return {
-            'tax_template_to_tax': tax_template_to_tax,
-            'account_dict': todo_dict
         }
 
-# Tax Repartition Line Template
-
-
-class AccountTaxRepartitionLineTemplate(models.Model):
-    _name = "account.tax.repartition.line.template"
-    _description = "Tax Repartition Line Template"
-
-    factor_percent = fields.Float(
-        string="%",
-        required=True,
-        default=100,
-        help="Factor to apply on the account move lines generated from this distribution line, in percents",
-    )
-    repartition_type = fields.Selection(string="Based On", selection=[('base', 'Base'), ('tax', 'of tax')], required=True, default='tax', help="Base on which the factor will be applied.")
-    account_id = fields.Many2one(string="Account", comodel_name='account.account.template', help="Account on which to post the tax amount")
-    invoice_tax_id = fields.Many2one(comodel_name='account.tax.template', help="The tax set to apply this distribution on invoices. Mutually exclusive with refund_tax_id")
-    refund_tax_id = fields.Many2one(comodel_name='account.tax.template', help="The tax set to apply this distribution on refund invoices. Mutually exclusive with invoice_tax_id")
-    tag_ids = fields.Many2many(string="Financial Tags", relation='account_tax_repartition_financial_tags', comodel_name='account.account.tag', copy=True, help="Additional tags that will be assigned by this repartition line for use in domains")
-    use_in_tax_closing = fields.Boolean(string="Tax Closing Entry")
-
-
-    # These last two fields are helpers used to ease the declaration of account.account.tag objects in XML.
-    # They are directly linked to account.tax.report.expression objects, which create corresponding + and - tags
-    # at creation. This way, we avoid declaring + and - separately every time.
-    plus_report_expression_ids = fields.Many2many(string="Plus Tax Report Expressions", relation='account_tax_rep_template_plus', comodel_name='account.report.expression', copy=True, help="Tax report expressions whose '+' tag will be assigned to move lines by this repartition line")
-    minus_report_expression_ids = fields.Many2many(string="Minus Report Expressions", relation='account_tax_rep_template_minus', comodel_name='account.report.expression', copy=True, help="Tax report expressions whose '-' tag will be assigned to move lines by this repartition line")
-
-    @api.model_create_multi
-    def create(self, vals_list):
-        for vals in vals_list:
-            if vals.get('use_in_tax_closing') is None:
-                vals['use_in_tax_closing'] = False
-                if vals.get('account_id'):
-                    account_type = self.env['account.account.template'].browse(vals.get('account_id')).account_type
-                    if account_type:
-                        vals['use_in_tax_closing'] = not (account_type.startswith('income') or account_type.startswith('expense'))
-
-        return super().create(vals_list)
-
-    @api.constrains('invoice_tax_id', 'refund_tax_id')
-    def validate_tax_template_link(self):
-        for record in self:
-            if record.invoice_tax_id and record.refund_tax_id:
-                raise ValidationError(_("Tax distribution line templates should apply to either invoices or refunds, not both at the same time. invoice_tax_id and refund_tax_id should not be set together."))
-
-    @api.constrains('plus_report_expression_ids', 'minus_report_expression_ids')
-    def _validate_report_expressions(self):
-        for record in self:
-            all_engines = set((record.plus_report_expression_ids + record.minus_report_expression_ids).mapped('engine'))
-            if all_engines and all_engines != {'tax_tags'}:
-                raise ValidationError(_("Only 'tax_tags' expressions can be linked to a tax repartition line template."))
-
-    def get_repartition_line_create_vals(self, company):
-        rslt = [Command.clear()]
-        for record in self:
-            rslt.append(Command.create({
-                'factor_percent': record.factor_percent,
-                'repartition_type': record.repartition_type,
-                'tag_ids': [Command.set(record._get_tags_to_add().ids)],
-                'company_id': company.id,
-                'use_in_tax_closing': record.use_in_tax_closing
-            }))
-        return rslt
-
-    def _get_repartition_line_create_vals_complete(self, company):
-        """
-        This function returns a list of values to create the repartition lines of a tax based on
-        one or several account.tax.repartition.line.template. It mimicks the function get_repartition_line_create_vals
-        but adds the missing field account_id (account.account)
-
-        Returns a list of (0,0, x) ORM commands to create the repartition lines starting with a (5,0,0)
-        command to clear the repartition.
-        """
-        rslt = self.get_repartition_line_create_vals(company)
-        for idx, template_line in zip(range(1, len(rslt)), self):  # ignore first ORM command ( (5, 0, 0) )
-            account_id = False
-            if template_line.account_id:
-                # take the first account.account which code begins with the correct code
-                account_id = self.env['account.account'].search([
-                    ('code', '=like', template_line.account_id.code + '%'),
-                    ('company_id', '=', company.id)
-                ], limit=1).id
-                if not account_id:
-                    _logger.warning("The account with code '%s' was not found but is supposed to be linked to a tax",
-                                    template_line.account_id.code)
-            rslt[idx][2].update({
-                "account_id": account_id,
-            })
-        return rslt
-
-    def _get_tags_to_add(self):
-        self.ensure_one()
-        tags_to_add = self.tag_ids
-
-        domains = []
-        for sign, report_expressions in (('+', self.plus_report_expression_ids), ('-', self.minus_report_expression_ids)):
-            for report_expression in report_expressions:
-                country = report_expression.report_line_id.report_id.country_id
-                domains.append(self.env['account.account.tag']._get_tax_tags_domain(report_expression.formula, country.id, sign=sign))
-
-        if domains:
-            tags_to_add |= self.env['account.account.tag'].with_context(active_test=False).search(osv.expression.OR(domains))
-
-        return tags_to_add
-
-class AccountFiscalPositionTemplate(models.Model):
-    _name = 'account.fiscal.position.template'
-    _description = 'Template for Fiscal Position'
-
-    sequence = fields.Integer()
-    name = fields.Char(string='Fiscal Position Template', required=True)
-    chart_template_id = fields.Many2one('account.chart.template', string='Chart Template', required=True)
-    account_ids = fields.One2many('account.fiscal.position.account.template', 'position_id', string='Account Mapping')
-    tax_ids = fields.One2many('account.fiscal.position.tax.template', 'position_id', string='Tax Mapping')
-    note = fields.Text(string='Notes')
-    auto_apply = fields.Boolean(string='Detect Automatically', help="Apply tax & account mappings on invoices automatically if the matching criterias (VAT/Country) are met.")
-    vat_required = fields.Boolean(string='VAT required', help="Apply only if partner has a VAT number.")
-    country_id = fields.Many2one('res.country', string='Country',
-        help="Apply only if delivery country matches.")
-    country_group_id = fields.Many2one('res.country.group', string='Country Group',
-        help="Apply only if delivery country matches the group.")
-    state_ids = fields.Many2many('res.country.state', string='Federal States')
-    zip_from = fields.Char(string='Zip Range From')
-    zip_to = fields.Char(string='Zip Range To')
-
-
-class AccountFiscalPositionTaxTemplate(models.Model):
-    _name = 'account.fiscal.position.tax.template'
-    _description = 'Tax Mapping Template of Fiscal Position'
-    _rec_name = 'position_id'
-
-    position_id = fields.Many2one('account.fiscal.position.template', string='Fiscal Position', required=True, ondelete='cascade')
-    tax_src_id = fields.Many2one('account.tax.template', string='Tax Source', required=True)
-    tax_dest_id = fields.Many2one('account.tax.template', string='Replacement Tax')
-
-
-class AccountFiscalPositionAccountTemplate(models.Model):
-    _name = 'account.fiscal.position.account.template'
-    _description = 'Accounts Mapping Template of Fiscal Position'
-    _rec_name = 'position_id'
-
-    position_id = fields.Many2one('account.fiscal.position.template', string='Fiscal Mapping', required=True, ondelete='cascade')
-    account_src_id = fields.Many2one('account.account.template', string='Account Source', required=True)
-    account_dest_id = fields.Many2one('account.account.template', string='Account Destination', required=True)
-
-
-class AccountReconcileModelTemplate(models.Model):
-    _name = "account.reconcile.model.template"
-    _description = 'Reconcile Model Template'
-
-    # Base fields.
-    chart_template_id = fields.Many2one('account.chart.template', string='Chart Template', required=True)
-    name = fields.Char(string='Button Label', required=True)
-    sequence = fields.Integer(required=True, default=10)
-
-    rule_type = fields.Selection(selection=[
-        ('writeoff_button', 'Button to generate counterpart entry'),
-        ('writeoff_suggestion', 'Rule to suggest counterpart entry'),
-        ('invoice_matching', 'Rule to match invoices/bills'),
-    ], string='Type', default='writeoff_button', required=True)
-    auto_reconcile = fields.Boolean(string='Auto-validate',
-        help='Validate the statement line automatically (reconciliation based on your rule).')
-    to_check = fields.Boolean(string='To Check', default=False, help='This matching rule is used when the user is not certain of all the information of the counterpart.')
-    matching_order = fields.Selection(
-        selection=[
-            ('old_first', 'Oldest first'),
-            ('new_first', 'Newest first'),
-        ]
-    )
-
-    # ===== Conditions =====
-    match_text_location_label = fields.Boolean(
-        default=True,
-        help="Search in the Statement's Label to find the Invoice/Payment's reference",
-    )
-    match_text_location_note = fields.Boolean(
-        default=False,
-        help="Search in the Statement's Note to find the Invoice/Payment's reference",
-    )
-    match_text_location_reference = fields.Boolean(
-        default=False,
-        help="Search in the Statement's Reference to find the Invoice/Payment's reference",
-    )
-    match_journal_ids = fields.Many2many('account.journal', string='Journals Availability',
-        domain="[('type', 'in', ('bank', 'cash'))]",
-        help='The reconciliation model will only be available from the selected journals.')
-    match_nature = fields.Selection(selection=[
-        ('amount_received', 'Amount Received'),
-        ('amount_paid', 'Amount Paid'),
-        ('both', 'Amount Paid/Received')
-    ], string='Amount Type', required=True, default='both',
-        help='''The reconciliation model will only be applied to the selected transaction type:
-        * Amount Received: Only applied when receiving an amount.
-        * Amount Paid: Only applied when paying an amount.
-        * Amount Paid/Received: Applied in both cases.''')
-    match_amount = fields.Selection(selection=[
-        ('lower', 'Is Lower Than'),
-        ('greater', 'Is Greater Than'),
-        ('between', 'Is Between'),
-    ], string='Amount Condition',
-        help='The reconciliation model will only be applied when the amount being lower than, greater than or between specified amount(s).')
-    match_amount_min = fields.Float(string='Amount Min Parameter')
-    match_amount_max = fields.Float(string='Amount Max Parameter')
-    match_label = fields.Selection(selection=[
-        ('contains', 'Contains'),
-        ('not_contains', 'Not Contains'),
-        ('match_regex', 'Match Regex'),
-    ], string='Label', help='''The reconciliation model will only be applied when the label:
-        * Contains: The proposition label must contains this string (case insensitive).
-        * Not Contains: Negation of "Contains".
-        * Match Regex: Define your own regular expression.''')
-    match_label_param = fields.Char(string='Label Parameter')
-    match_note = fields.Selection(selection=[
-        ('contains', 'Contains'),
-        ('not_contains', 'Not Contains'),
-        ('match_regex', 'Match Regex'),
-    ], string='Note', help='''The reconciliation model will only be applied when the note:
-        * Contains: The proposition note must contains this string (case insensitive).
-        * Not Contains: Negation of "Contains".
-        * Match Regex: Define your own regular expression.''')
-    match_note_param = fields.Char(string='Note Parameter')
-    match_transaction_type = fields.Selection(selection=[
-        ('contains', 'Contains'),
-        ('not_contains', 'Not Contains'),
-        ('match_regex', 'Match Regex'),
-    ], string='Transaction Type', help='''The reconciliation model will only be applied when the transaction type:
-        * Contains: The proposition transaction type must contains this string (case insensitive).
-        * Not Contains: Negation of "Contains".
-        * Match Regex: Define your own regular expression.''')
-    match_transaction_type_param = fields.Char(string='Transaction Type Parameter')
-    match_same_currency = fields.Boolean(string='Same Currency', default=True,
-        help='Restrict to propositions having the same currency as the statement line.')
-    allow_payment_tolerance = fields.Boolean(
-        string="Allow Payment Gap",
-        default=True,
-        help="Difference accepted in case of underpayment.",
-    )
-    payment_tolerance_param = fields.Float(
-        string="Gap",
-        default=0.0,
-        help="The sum of total residual amount propositions matches the statement line amount under this amount/percentage.",
-    )
-    payment_tolerance_type = fields.Selection(
-        selection=[('percentage', "in percentage"), ('fixed_amount', "in amount")],
-        required=True,
-        default='percentage',
-        help="The sum of total residual amount propositions and the statement line amount allowed gap type.",
-    )
-    match_partner = fields.Boolean(string='Partner Is Set',
-        help='The reconciliation model will only be applied when a customer/vendor is set.')
-    match_partner_ids = fields.Many2many('res.partner', string='Restrict Partners to',
-        help='The reconciliation model will only be applied to the selected customers/vendors.')
-    match_partner_category_ids = fields.Many2many('res.partner.category', string='Restrict Partner Categories to',
-        help='The reconciliation model will only be applied to the selected customer/vendor categories.')
-
-    line_ids = fields.One2many('account.reconcile.model.line.template', 'model_id')
-    decimal_separator = fields.Char(help="Every character that is nor a digit nor this separator will be removed from the matching string")
-
-
-class AccountReconcileModelLineTemplate(models.Model):
-    _name = "account.reconcile.model.line.template"
-    _description = 'Reconcile Model Line Template'
-
-    model_id = fields.Many2one('account.reconcile.model.template')
-    sequence = fields.Integer(required=True, default=10)
-    account_id = fields.Many2one('account.account.template', string='Account', ondelete='cascade', domain=[('deprecated', '=', False)])
-    label = fields.Char(string='Journal Item Label')
-    amount_type = fields.Selection([
-        ('fixed', 'Fixed'),
-        ('percentage', 'Percentage of balance'),
-        ('regex', 'From label'),
-    ], required=True, default='percentage')
-    amount_string = fields.Char(string="Amount")
-    force_tax_included = fields.Boolean(string='Tax Included in Price', help='Force the tax to be managed as a price included tax.')
-    tax_ids = fields.Many2many('account.tax.template', string='Taxes', ondelete='restrict')
+    # --------------------------------------------------------------------------------
+    # Tooling
+    # --------------------------------------------------------------------------------
+
+    def ref(self, xmlid, raise_if_not_found=True):
+        return self.env.ref(f"account.{self.env.company.id}_{xmlid}" if xmlid and '.' not in xmlid else xmlid, raise_if_not_found)
+
+    def _get_parent_template(self, code):
+        parents = []
+        template_mapping = self._get_chart_template_mapping(get_all=True)
+        while template_mapping.get(code):
+            parents.append(code)
+            code = template_mapping.get(code).get('parent')
+        return parents
+
+    def _get_tag_mapper(self, template_code):
+        tags = {x.name: x.id for x in self.env['account.account.tag'].search([
+            ('applicability', '=', 'taxes'),
+            ('country_id', '=', self._get_chart_template_mapping()[template_code]['country_id']),
+        ])}
+        return lambda *args: [tags[re.sub(r'\s+', ' ', x.strip())] for x in args]
+
+    def _deref_account_tags(self, template_code, tax_data):
+        mapper = self._get_tag_mapper(template_code)
+        for tax in tax_data.values():
+            for fname in ('invoice_repartition_line_ids', 'refund_repartition_line_ids', 'repartition_line_ids'):
+                if tax.get(fname):
+                    for _command, _id, repartition in tax[fname]:
+                        tags = repartition.get('tag_ids')
+                        if isinstance(tags, str) and not re.match(r"^(\w+\.\w+,)*\w+\.\w+$", tags):
+                            repartition['tag_ids'] = [Command.set(mapper(*tags.split(TAX_TAG_DELIMITER)))]
+
+    def _parse_csv(self, template_code, model, module=None):
+        Model = self.env[model]
+        model_fields = Model._fields
+
+        if module is None:
+            module = self._get_chart_template_mapping().get(template_code)['module']
+        assert re.fullmatch(r"[a-z0-9_]+", module)
+
+        res = {}
+        for template in self._get_parent_template(template_code)[::-1] or ['']:
+            try:
+                with file_open(f"{module}/data/template/{model}{f'-{template}' if template else ''}.csv", 'r') as csv_file:
+                    for row in csv.DictReader(csv_file):
+                        if row['id']:
+                            last_id = row['id']
+                            res[row['id']] = {
+                                key.split('/')[0]: (
+                                    value if '@' in key
+                                    else [] if '/' in key
+                                    else (value and ast.literal_eval(value) or False) if model_fields[key].type in ('boolean', 'int', 'float')
+                                    else value
+                                )
+                                for key, value in row.items()
+                                if key != 'id' and value != ""
+                            }
+                        create_added = set()
+                        for key, value in row.items():
+                            if '/' in key and value:
+                                sub = [Command.create(res[last_id])]
+                                path = key.split('/')
+                                for p in path[:-1]:
+                                    if p not in create_added:
+                                        create_added.add(p)
+                                        sub[-1][2].setdefault(p, [])
+                                        sub[-1][2][p].append(Command.create({}))
+                                    sub = sub[-1][2][p]
+                                sub[-1][2][path[-1]] = value
+            except FileNotFoundError:
+                _logger.debug("No file %s found for template '%s'", model, module)
+        return res

--- a/addons/account/models/company.py
+++ b/addons/account/models/company.py
@@ -57,7 +57,7 @@ class ResCompany(models.Model):
     transfer_account_id = fields.Many2one('account.account',
         domain="[('reconcile', '=', True), ('account_type', '=', 'asset_current'), ('deprecated', '=', False)]", string="Inter-Banks Transfer Account", help="Intermediary account used when moving money from a liqity account to another")
     expects_chart_of_accounts = fields.Boolean(string='Expects a Chart of Accounts', default=True)
-    chart_template_id = fields.Many2one('account.chart.template', help='The chart template for the company (if any)')
+    chart_template = fields.Selection(selection='_chart_template_selection')
     bank_account_code_prefix = fields.Char(string='Prefix of the bank accounts')
     cash_account_code_prefix = fields.Char(string='Prefix of the cash accounts')
     default_cash_difference_income_account_id = fields.Many2one('account.account', string="Cash Difference Income Account")
@@ -91,9 +91,6 @@ class ResCompany(models.Model):
         domain="[('deprecated', '=', False), ('company_id', '=', id), \
                 ('account_type', '=', 'expense')]")
     anglo_saxon_accounting = fields.Boolean(string="Use anglo-saxon accounting")
-    property_stock_account_input_categ_id = fields.Many2one('account.account', string="Input Account for Stock Valuation")
-    property_stock_account_output_categ_id = fields.Many2one('account.account', string="Output Account for Stock Valuation")
-    property_stock_valuation_account_id = fields.Many2one('account.account', string="Account Template for Stock Valuation")
     bank_journal_ids = fields.One2many('account.journal', 'company_id', domain=[('type', '=', 'bank')], string='Bank Journals')
     incoterm_id = fields.Many2one('account.incoterms', string='Default incoterm',
         help='International Commercial Terms are a series of predefined commercial terms used in international transactions.')
@@ -274,11 +271,15 @@ class ResCompany(models.Model):
         return new_prefix + current_code.replace(old_prefix, '', 1).lstrip('0').rjust(digits-len(new_prefix), '0')
 
     def reflect_code_prefix_change(self, old_code, new_code):
-        accounts = self.env['account.account'].search([('code', 'like', old_code), ('account_type', 'in', ('asset_cash', 'liability_credit_card')),
-            ('company_id', '=', self.id)], order='code asc')
+        if not old_code:
+            return
+        accounts = self.env['account.account'].search([
+            ('code', '=like', old_code + '%'),
+            ('account_type', 'in', ('asset_cash', 'liability_credit_card')),
+            ('company_id', '=', self.id)
+        ], order='code asc')
         for account in accounts:
-            if account.code.startswith(old_code):
-                account.write({'code': self.get_new_account_code(account.code, old_code, new_code)})
+            account.write({'code': self.get_new_account_code(account.code, old_code, new_code)})
 
     def _get_fiscalyear_lock_statement_lines_redirect_action(self, unreconciled_statement_lines):
         """ Get the action redirecting to the statement lines that are not already reconciled when setting a fiscal
@@ -581,6 +582,14 @@ class ResCompany(models.Model):
             raise RedirectWarning(msg, action.id, _("Go to the configuration panel"))
         return account
 
+    def _existing_accounting(self) -> bool:
+        """Return True iff some accounting entries have already been made for the current company."""
+        self.ensure_one()
+        return bool(self.env['account.move.line'].search([('company_id', '=', self.id)], order="id", limit=1))
+
+    def _chart_template_selection(self):
+        return self.env['account.chart.template']._select_chart_template(self.country_id)
+
     @api.model
     def _action_check_hash_integrity(self):
         return self.env.ref('account.action_report_account_hash_integrity').report_action(self.id)

--- a/None
+++ b/addons/account/models/ir_module.py
@@ -0,0 +1,66 @@
+from importlib import import_module
+from inspect import getmembers, ismodule, isclass, isfunction
+
+from odoo import models, fields
+
+
+def get_flag(country_code):
+    # get the sequence of 2 regional indicator emoji forming the flag linked to the country code
+    return "".join(chr(int(f"1f1{ord(c)+165:02x}", base=16)) for c in country_code)
+
+
+def templ(env, code, name=None, country='', **kwargs):
+    country_code = country or code.split('_')[0] if country is not None else None
+    country = country_code and env.ref(f"base.{country_code}", raise_if_not_found=False)
+    country_name = f"{get_flag(country.code)} {country.name}" if country else ''
+    return {
+        'name': country_name and (f"{country_name} - {name}" if name else country_name) or name,
+        'country_id': country and country.id,
+        'country_code': country and country.code,
+        **kwargs,
+    }
+
+template_module = lambda m: ismodule(m) and m.__name__.split('.')[-1].startswith('template_')
+template_class = isclass
+template_function = lambda f: isfunction(f) and hasattr(f, '_l10n_template') and f._l10n_template[1] == 'template_data'
+
+class IrModule(models.Model):
+    _inherit = "ir.module.module"
+
+    account_templates = fields.Binary(compute='_compute_account_templates', exportable=False)
+
+    def _compute_account_templates(self):
+        chart_category = self.env.ref('base.module_category_accounting_localizations_account_charts')
+        ChartTemplate = self.env['account.chart.template']
+        for module in self:
+            templates = {}
+            if module.category_id == chart_category or module.name == 'account':
+                python_module = import_module(f"odoo.addons.{module.name}.models")
+                templates = {
+                    fct._l10n_template[0]: {
+                        'name': fct(ChartTemplate).get('name'),
+                        'parent': fct(ChartTemplate).get('parent'),
+                        'country': fct(ChartTemplate).get('country', ''),
+                        'visible': fct(ChartTemplate).get('visible', True),
+                        'module': module.name,
+                    }
+                    for _name, mdl in getmembers(python_module, template_module)
+                    for _name, cls in getmembers(mdl, template_class)
+                    for _name, fct in getmembers(cls, template_function)
+                }
+
+            module.account_templates = {
+                code: templ(self.env, code, **vals)
+                for code, vals in templates.items()
+            }
+
+    def write(self, vals):
+        # Instanciate the first template of the module on the current company upon installing the module
+        was_installed = len(self) == 1 and self.state == 'installed'
+        super().write(vals)
+        is_installed = len(self) == 1 and self.state == 'installed'
+        if not was_installed and is_installed and not self.env.company.chart_template and self.account_templates:
+            self.env['account.chart.template'].try_loading(
+                next(iter(self.account_templates)),
+                self.env.company,
+            )

--- a/addons/account/models/partner.py
+++ b/addons/account/models/partner.py
@@ -20,7 +20,7 @@ class AccountFiscalPosition(models.Model):
     _order = 'sequence'
 
     sequence = fields.Integer()
-    name = fields.Char(string='Fiscal Position', required=True)
+    name = fields.Char(string='Fiscal Position', required=True, translate=True)
     active = fields.Boolean(default=True,
         help="By unchecking the active field, you may hide a fiscal position without deleting it.")
     company_id = fields.Many2one(
@@ -64,7 +64,7 @@ class AccountFiscalPosition(models.Model):
 
             if self.env['account.tax'].search([('country_id', '=', record.country_id.id)], limit=1):
                 record.foreign_vat_header_mode = None
-            elif self.env['account.tax.template'].search([('chart_template_id.country_id', '=', record.country_id.id)], limit=1):
+            elif self.env['account.chart.template']._guess_chart_template(record.country_id) != 'generic_coa':
                 record.foreign_vat_header_mode = 'templates_found'
             else:
                 record.foreign_vat_header_mode = 'no_template'

--- a/addons/account/models/res_config_settings.py
+++ b/addons/account/models/res_config_settings.py
@@ -31,8 +31,7 @@ class ResConfigSettings(models.TransientModel):
         domain="[('deprecated', '=', False), ('company_id', '=', company_id),\
                 ('account_type', '=', 'expense')]")
     has_chart_of_accounts = fields.Boolean(compute='_compute_has_chart_of_accounts', string='Company has a chart of accounts')
-    chart_template_id = fields.Many2one('account.chart.template', string='Template', default=lambda self: self.env.company.chart_template_id,
-        domain="[('visible','=', True)]")
+    chart_template = fields.Selection(selection=lambda self: self.env.company._chart_template_selection(), default=lambda self: self.env.company.chart_template)
     sale_tax_id = fields.Many2one('account.tax', string="Default Sale Tax", related='company_id.account_sale_tax_id', readonly=False)
     purchase_tax_id = fields.Many2one('account.tax', string="Default Purchase Tax", related='company_id.account_purchase_tax_id', readonly=False)
     tax_calculation_rounding_method = fields.Selection(
@@ -184,10 +183,12 @@ class ResConfigSettings(models.TransientModel):
     def set_values(self):
         super().set_values()
         # install a chart of accounts for the given company (if required)
-        if self.env.company == self.company_id \
-                and self.chart_template_id \
-                and self.chart_template_id != self.company_id.chart_template_id:
-            self.chart_template_id._load(self.env.company)
+        if self.env.company == self.company_id and self.chart_template \
+        and self.chart_template != self.company_id.chart_template:
+            self.env['account.chart.template'].try_loading(self.chart_template, company=self.company_id)
+
+    def reload_template(self):
+        self.env['account.chart.template'].try_loading(self.company_id.chart_template, company=self.company_id)
 
     @api.depends('company_id')
     def _compute_account_default_credit_limit(self):
@@ -205,8 +206,8 @@ class ResConfigSettings(models.TransientModel):
 
     @api.depends('company_id')
     def _compute_has_chart_of_accounts(self):
-        self.has_chart_of_accounts = bool(self.company_id.chart_template_id)
-        self.has_accounting_entries = self.env['account.chart.template'].existing_accounting(self.company_id)
+        self.has_chart_of_accounts = bool(self.company_id.chart_template)
+        self.has_accounting_entries = self.company_id._existing_accounting()
 
     @api.depends('show_line_subtotals_tax_selection')
     def _compute_group_show_line_subtotals(self):

--- a/None
+++ b/addons/account/models/template_generic_coa.py
@@ -0,0 +1,59 @@
+from odoo import models
+from odoo.addons.account.models.chart_template import template
+
+
+
+class AccountChartTemplate(models.AbstractModel):
+    _inherit = "account.chart.template"
+
+    @template('generic_coa')
+    def _get_generic_coa_template_data(self):
+        """Return the data necessary for the chart template.
+
+        :return: all the values that are not stored but are used to instancieate
+                 the chart of accounts. Common keys are:
+                 * anglo_saxon_accounting
+                 * transfer_account_code_prefix
+                 * property_*
+                 * code_digits
+        :rtype: dict
+        """
+        return {
+            'name': "Generic Chart Template",
+            'country': None,
+            'anglo_saxon_accounting': True,
+            'transfer_account_code_prefix': '1017',
+            'default_pos_receivable_account_id': 'pos_receivable',
+            'property_account_receivable_id': 'receivable',
+            'property_account_payable_id': 'payable',
+            'property_account_expense_id': 'expense',
+            'property_account_income_id': 'income',
+            'property_account_expense_categ_id': 'expense',
+            'property_account_income_categ_id': 'income',
+            'property_stock_account_input_categ_id': 'stock_in',
+            'property_stock_account_output_categ_id': 'stock_out',
+            'property_stock_valuation_account_id': 'stock_valuation',
+        }
+
+    @template('generic_coa', 'res.company')
+    def _get_generic_coa_res_company(self):
+        """Return the data to be written on the company.
+
+        The data is a mapping the XMLID to the create/write values of a record.
+
+        :rtype: dict[(str, int), dict]
+        """
+        return {
+            self.env.company.id: {
+                'account_fiscal_country_id': 'base.us',
+                'bank_account_code_prefix': '1014',
+                'cash_account_code_prefix': '1015',
+                'account_default_pos_receivable_account_id': 'pos_receivable',
+                'income_currency_exchange_account_id': 'income_currency_exchange',
+                'expense_currency_exchange_account_id': 'expense_currency_exchange',
+                'default_cash_difference_income_account_id': 'cash_diff_income',
+                'default_cash_difference_expense_account_id': 'cash_diff_expense',
+                'account_journal_early_pay_discount_loss_account_id': 'cash_discount_loss',
+                'account_journal_early_pay_discount_gain_account_id': 'cash_discount_gain',
+            }
+        }
