PR: https://github.com/odoo/odoo/pull/189274

From: 66856ad6a4dae3289593b55451e6c668a221fb8e
From: Einar Andersen (eian)
Date: 2025-02-17 11:58:20

Breaking data model changes scores: del:35.199999999999996 + add:2, change matches:
-    candidate_id = fields.Many2one(
-    candidate_id = fields.Many2one('hr.candidate', required=True, index=True)
-    partner_name = fields.Char(compute="_compute_partner_name", search="_search_partner_name", inverse="_inverse_name", compute_sudo=True)
+    partner_name = fields.Char("Applicant's Name")
-    categ_ids = fields.Many2many('hr.applicant.category', string="Tags", compute='_compute_categ_ids', store=True, readonly=False)
+    categ_ids = fields.Many2many('hr.applicant.category', string="Tags")
-    other_applications_count = fields.Integer(compute='_compute_other_applications_count', compute_sudo=True)
+    talent_pool_ids = fields.Many2many(comodel_name="hr.talent.pool", string="Talent Pools", groups="base.group_user")
-    _inherit = ['mail.thread.cc',
-    application_count = fields.Integer(compute="_compute_application_count")
-    partner_id = fields.Many2one('res.partner', "Contact", copy=False, index='btree_not_null')
-    partner_name = fields.Char("Candidates's Name")
-    email_from = fields.Char(
-    email_normalized = fields.Char(index='trigram')
-    partner_phone = fields.Char(
-    partner_phone_sanitized = fields.Char(
-    linkedin_profile = fields.Char('LinkedIn Profile')
-    type_id = fields.Many2one('hr.recruitment.degree', "Degree")
-    availability = fields.Date("Availability", help="The date at which the applicant will be available to start working", tracking=True)
-    categ_ids = fields.Many2many('hr.applicant.category', string="Tags")
-    priority = fields.Selection(AVAILABLE_PRIORITIES, string="Evaluation", compute="_compute_priority", store=True)
-    user_id = fields.Many2one(
-    employee_id = fields.Many2one('hr.employee', string="Employee", help="Employee linked to the candidate.", copy=False)
-    emp_is_active = fields.Boolean(string="Employee Active", related='employee_id.active')
-    employee_name = fields.Char(related='employee_id.name', string="Employee Name", readonly=False, tracking=False)
-    similar_candidates_count = fields.Integer(
-    applications_count = fields.Integer(string="# Offers", compute='_compute_applications_count')
-    refused_applications_count = fields.Integer(string="# Refused Offers", compute='_compute_applications_count')
-    accepted_applications_count = fields.Integer(string="# Accepted Offers", compute='_compute_applications_count')
-    meeting_ids = fields.One2many('calendar.event', 'candidate_id', 'Meetings')
-    meeting_display_text = fields.Char(compute='_compute_meeting_display')
-    meeting_display_date = fields.Date(compute='_compute_meeting_display')
-    attachment_count = fields.Integer(
-    candidate_properties = fields.Properties('Properties', definition='company_id.candidate_properties_definition', copy=True)
-    attachment_ids = fields.One2many('ir.attachment', 'res_id', domain=[('res_model', '=', 'hr.candidate')], string='Attachments')
-    candidate_id = fields.One2many('hr.candidate', 'employee_id', 'Candidate', groups="hr.group_hr_user")
+    talent_ids = fields.Many2many(comodel_name="hr.applicant", string="Talent", groups="base.group_user")
+    categ_ids = fields.Many2many(
-    candidate_properties_definition = fields.PropertiesDefinition('Candidate Properties')

Total Changes: 1096

[IMP] hr_recruitment: Bye Candidate, Hi Talent Pool

The goal of this PR can be split into three sections:

1. Remove the hr.candidate model
   The removal of the hr.candidate model required migrating information previously
   attached to the candidate over to the applicant. This change aims to simplify
   the flow of the recruitment app, as most SMEs don't need extensive complex
   recruitment workflows for hiring a few people occasionally.

2. Introduce the hr.talent.pool model
   While removing hr.candidate means losing features useful for industries like
   headhunting, the new talent pool system aims to re-introduce these features.
   It enables creating application templates (talents) from existing applications
   and using these talents to generate applications for other jobs.

3. Other minor UI/UX/DX tweaks
   - Improved job position form view for better user experience
   - Improved applicant form view to integrate with talent pool system
   - Renamed appraisal_goal_date/timeless_date to 'timeless_datetime' and moved
     it to 'hr' so it can be used in both appraisal and recruitment

These changes make the recruitment app more versatile. Smaller companies with
simple recruitment processes can use basic applications and recruitment flows
(similar to 17.4), while companies with complex needs can leverage talent pools
to manage applications as they did with the candidate model.

Task-4307229

closes odoo/odoo#189274

Related: odoo/enterprise#77118
Related: odoo/upgrade#7116
Signed-off-by: Yannick Tivisse (yti) <yti@odoo.com>

================================= pseudo patch: =================================

--- a/addons/hr_recruitment/models/__init__.py
+++ b/addons/hr_recruitment/models/__init__.py
@@ -4,12 +4,12 @@ from . import hr_department
 from . import hr_applicant
 from . import hr_applicant_category
 from . import hr_applicant_refuse_reason
-from . import hr_candidate
 from . import hr_recruitment_degree
 from . import hr_recruitment_source
 from . import hr_recruitment_stage
 from . import hr_employee
 from . import hr_job
+from . import hr_talent_pool
 from . import res_config_settings
 from . import calendar
 from . import digest

--- a/addons/hr_recruitment/models/calendar.py
+++ b/addons/hr_recruitment/models/calendar.py
@@ -18,14 +18,6 @@ class CalendarEvent(models.Model):
                 default_partner_ids=self.env.context.get('default_partner_ids'),
                 default_name=self.env.context.get('default_name')
             )
-        elif self.env.context.get('default_candidate_id'):
-            self_ctx = self.with_context(
-                default_res_model='hr.candidate',  # res_model seems to be lost without this
-                default_res_model_id=self.env.ref('hr_recruitment.model_hr_candidate').id,
-                default_res_id=self.env.context.get('default_candidate_id'),
-                default_partner_ids=self.env.context.get('default_partner_ids'),
-                default_name=self.env.context.get('default_name')
-            )
 
         defaults = super(CalendarEvent, self_ctx).default_get(fields)
 
@@ -39,14 +31,6 @@ class CalendarEvent(models.Model):
         return defaults
 
     applicant_id = fields.Many2one('hr.applicant', string="Applicant", index='btree_not_null', ondelete='set null')
-    candidate_id = fields.Many2one(
-        'hr.candidate',
-        string="Candidate",
-        compute="_compute_candidate_id",
-        store=True,
-        readonly=False,
-        index='btree_not_null',
-        ondelete='set null')
 
     @api.model_create_multi
     def create(self, vals_list):
@@ -57,8 +41,7 @@ class CalendarEvent(models.Model):
         attachments = False
         if "default_applicant_id" in self.env.context:
             attachments = self.env['hr.applicant'].browse(self.env.context['default_applicant_id']).attachment_ids
-        elif "default_candidate_id" in self.env.context:
-            attachments = self.env['hr.candidate'].browse(self.env.context['default_candidate_id']).attachment_ids
+
         if attachments:
             self.env['ir.attachment'].create([{
                 'name': att.name,
@@ -76,10 +59,3 @@ class CalendarEvent(models.Model):
             for event in self:
                 if event.applicant_id.id == applicant_id:
                     event.is_highlighted = True
-
-    @api.depends('applicant_id')
-    def _compute_candidate_id(self):
-        for event in self:
-            if not event.applicant_id:
-                continue
-            event.candidate_id = event.applicant_id.candidate_id

--- a/addons/hr_recruitment/models/hr_applicant.py
+++ b/addons/hr_recruitment/models/hr_applicant.py
@@ -2,12 +2,15 @@
 import re
 
 from markupsafe import Markup
+from collections import defaultdict
 from dateutil.relativedelta import relativedelta
 from datetime import datetime
 
 from odoo import api, fields, models, tools
 from odoo.exceptions import UserError, ValidationError
+from odoo.fields import Domain
 from odoo.osv import expression
+from odoo.tools import SQL
 from odoo.tools.translate import _
 
 
@@ -25,6 +28,8 @@ class HrApplicant(models.Model):
     _order = "priority desc, id desc"
     _inherit = ['mail.thread.cc',
                'mail.thread.main.attachment',
+               'mail.thread.blacklist',
+               'mail.thread.phone',
                'mail.activity.mixin',
                'utm.mixin',
                'mail.tracking.duration.mixin',
@@ -36,20 +41,37 @@ class HrApplicant(models.Model):
 
     active = fields.Boolean("Active", default=True, help="If the active field is set to false, it will allow you to hide the case without removing it.", index=True)
 
-    candidate_id = fields.Many2one('hr.candidate', required=True, index=True)
-    partner_id = fields.Many2one(related="candidate_id.partner_id")
-    partner_name = fields.Char(compute="_compute_partner_name", search="_search_partner_name", inverse="_inverse_name", compute_sudo=True)
-    email_from = fields.Char(related="candidate_id.email_from", readonly=False)
-    email_normalized = fields.Char(related="candidate_id.email_normalized")
-    partner_phone = fields.Char(related="candidate_id.partner_phone", readonly=False)
-    partner_phone_sanitized = fields.Char(related="candidate_id.partner_phone_sanitized")
-    linkedin_profile = fields.Char(related="candidate_id.linkedin_profile", readonly=False)
-    type_id = fields.Many2one(related="candidate_id.type_id", readonly=False)
-    availability = fields.Date(related="candidate_id.availability", readonly=False)
-    color = fields.Integer(related="candidate_id.color")
-    employee_id = fields.Many2one(related="candidate_id.employee_id", readonly=False)
-    emp_is_active = fields.Boolean(related="candidate_id.emp_is_active")
-    employee_name = fields.Char(related="candidate_id.employee_name")
+    partner_id = fields.Many2one('res.partner', "Contact", copy=False, index='btree_not_null')
+    partner_name = fields.Char("Applicant's Name")
+    email_from = fields.Char(
+        string="Email",
+        size=128,
+        compute='_compute_partner_phone_email',
+        inverse='_inverse_partner_email',
+        copy=True,
+        store=True,
+        index='trigram',
+    )
+    email_normalized = fields.Char(index='trigram')  # inherited via mail.thread.blacklist
+    partner_phone = fields.Char(
+        string="Phone",
+        size=32,
+        compute='_compute_partner_phone_email',
+        inverse='_inverse_partner_email',
+        copy=True,
+        store=True,
+        index='btree_not_null',
+    )
+    partner_phone_sanitized = fields.Char(
+        string="Sanitized Phone Number", compute='_compute_partner_phone_sanitized', store=True, index='btree_not_null'
+    )
+    linkedin_profile = fields.Char('LinkedIn Profile')
+    type_id = fields.Many2one('hr.recruitment.degree', "Degree")
+    availability = fields.Date("Availability", help="The date at which the applicant will be available to start working", tracking=True)
+    color = fields.Integer("Color Index", default=0)
+    employee_id = fields.Many2one('hr.employee', string="Employee", help="Employee linked to the applicant.", copy=False)
+    emp_is_active = fields.Boolean(string="Employee Active", related='employee_id.active')
+    employee_name = fields.Char(related='employee_id.name', string="Employee Name", readonly=False, tracking=False)
 
     probability = fields.Float("Probability")
     create_date = fields.Datetime("Applied on", readonly=True)
@@ -60,7 +82,7 @@ class HrApplicant(models.Model):
                                group_expand='_read_group_stage_ids')
     last_stage_id = fields.Many2one('hr.recruitment.stage', "Last Stage",
                                     help="Stage of the applicant before being in the current stage. Used for lost cases analysis.")
-    categ_ids = fields.Many2many('hr.applicant.category', string="Tags", compute='_compute_categ_ids', store=True, readonly=False)
+    categ_ids = fields.Many2many('hr.applicant.category', string="Tags")
     company_id = fields.Many2one('res.company', "Company", compute='_compute_company', store=True, readonly=False, tracking=True)
     user_id = fields.Many2one(
         'res.users', "Recruiter", compute='_compute_user', domain="[('share', '=', False), ('company_ids', 'in', company_id)]",
@@ -108,39 +130,326 @@ class HrApplicant(models.Model):
         ('refused', 'Refused'),
         ('archived', 'Archived'),
     ], compute="_compute_application_status", search="_search_application_status")
-    other_applications_count = fields.Integer(compute='_compute_other_applications_count', compute_sudo=True)
+    application_count = fields.Integer(compute='_compute_application_count', help='Applications with the same email or phone or mobile')
     applicant_properties = fields.Properties('Properties', definition='job_id.applicant_properties_definition', copy=True)
     applicant_notes = fields.Html()
     refuse_date = fields.Datetime('Refuse Date')
+    talent_pool_ids = fields.Many2many(comodel_name="hr.talent.pool", string="Talent Pools", groups="base.group_user")
+    pool_applicant_id = fields.Many2one("hr.applicant")
+    is_pool_applicant = fields.Boolean(compute="_compute_is_pool")
+    is_applicant_in_pool = fields.Boolean(
+        compute="_compute_is_applicant_in_pool", search="_search_is_applicant_in_pool"
+    )
+    talent_pool_count = fields.Integer(compute="_compute_talent_pool_count")
 
     _job_id_stage_id_idx = models.Index("(job_id, stage_id) WHERE active IS TRUE")
 
-    @api.depends("candidate_id.partner_name")
-    def _compute_partner_name(self):
+    @api.depends("email_normalized", "partner_phone_sanitized", "linkedin_profile", "pool_applicant_id.talent_pool_ids")
+    def _compute_talent_pool_count(self):
+        """
+        This method will find the amount of talent pools the current application is associated with.
+        An application can either be associated directly with a talent pool through talent_pool_ids
+        and/or pool_applicant_id.talent_pool_ids or indirectly by having the same email, phone
+        number or linkedin as a directly linked application.
+        """
+        pool_applicants = self.filtered("is_applicant_in_pool")
+        (self - pool_applicants).talent_pool_count = 0
+
+        if not pool_applicants:
+            return
+
+        directly_linked = pool_applicants.filtered("pool_applicant_id")
+        for applicant in directly_linked:
+            # All talents(applications with talent_pool_ids set) have a pool_applicant_id set to
+            # themselves which is the reason we only look for that instead of searching for all
+            # applications with talent_pool_ids and all applications with pool_applicant_id seperately
+            applicant.talent_pool_count = len(applicant.pool_applicant_id.talent_pool_ids)
+
+        indirectly_linked = pool_applicants - directly_linked
+        if not indirectly_linked:
+            return
+
+        all_emails = {a.email_normalized for a in indirectly_linked if a.email_normalized}
+        all_phones = {a.partner_phone_sanitized for a in indirectly_linked if a.partner_phone_sanitized}
+        all_linkedins = {a.linkedin_profile for a in indirectly_linked if a.linkedin_profile}
+
+        epl_domain = Domain.FALSE
+        if all_emails:
+            epl_domain |= Domain("email_normalized", "in", list(all_emails))
+        if all_phones:
+            epl_domain |= Domain("partner_phone_sanitized", "in", list(all_phones))
+        if all_linkedins:
+            epl_domain |= Domain("linkedin_profile", "in", list(all_linkedins))
+
+        pool_domain = Domain(["|", ("talent_pool_ids", "!=", False), ("pool_applicant_id", "!=", False)])
+        domain = pool_domain & epl_domain
+        in_pool_applicants = self.env["hr.applicant"].with_context(active_test=True).search(domain)
+
+        in_pool_emails = defaultdict(int)
+        in_pool_phones = defaultdict(int)
+        in_pool_linkedins = defaultdict(int)
+
+        for applicant in in_pool_applicants:
+            talent_pool_count = len(applicant.pool_applicant_id.talent_pool_ids)
+            if applicant.email_normalized:
+                in_pool_emails[applicant.email_normalized] = talent_pool_count
+            if applicant.partner_phone_sanitized:
+                in_pool_phones[applicant.partner_phone_sanitized] = talent_pool_count
+            if applicant.linkedin_profile:
+                in_pool_linkedins[applicant.linkedin_profile] = talent_pool_count
+
+        for applicant in indirectly_linked:
+            if applicant.email_from and in_pool_emails[applicant.email_normalized]:
+                applicant.talent_pool_count = in_pool_emails[applicant.email_normalized]
+            elif applicant.partner_phone_sanitized and in_pool_phones[applicant.partner_phone_sanitized]:
+                applicant.talent_pool_count = in_pool_phones[applicant.partner_phone_sanitized]
+            elif applicant.linkedin_profile and in_pool_linkedins[applicant.linkedin_profile]:
+                applicant.talent_pool_count = in_pool_linkedins[applicant.linkedin_profile]
+            else:
+                applicant.talent_pool_count = 0
+
+    @api.depends("partner_phone")
+    def _compute_partner_phone_sanitized(self):
         for applicant in self:
-            applicant.partner_name = applicant.candidate_id.partner_name
+            applicant.partner_phone_sanitized = (
+                applicant._phone_format(fname="partner_phone") or applicant.partner_phone
+            )
 
-    def _search_partner_name(self, operator, value):
-        return [('candidate_id.partner_name', operator, value)]
+    @api.depends("partner_id")
+    def _compute_partner_phone_email(self):
+        for applicant in self:
+            if not applicant.partner_id:
+                continue
+            applicant.email_from = applicant.partner_id.email
+            if not applicant.partner_phone:
+                applicant.partner_phone = applicant.partner_id.phone
 
-    def _inverse_name(self):
+    def _inverse_partner_email(self):
         for applicant in self:
-            if applicant.partner_name and not applicant.candidate_id:
-                applicant.candidate_id = self.env['hr.candidate'].create({'partner_name': applicant.partner_name})
-            else:
-                applicant.candidate_id.partner_name = applicant.partner_name
+            if not applicant.email_from:
+                continue
+            if not applicant.partner_id:
+                if not applicant.partner_name:
+                    raise UserError(_("You must define a Contact Name for this applicant."))
+                applicant.partner_id = (
+                    self.env["res.partner"]
+                    .with_context(default_lang=self.env.lang)
+                    .find_or_create(applicant.email_from)
+                )
+            if applicant.partner_name and not applicant.partner_id.name:
+                applicant.partner_id.name = applicant.partner_name
+            if tools.email_normalize(applicant.email_from) != tools.email_normalize(applicant.partner_id.email):
+                # change email on a partner will trigger other heavy code, so avoid to change the email when
+                # it is the same. E.g. "email@example.com" vs "My Email" <email@example.com>""
+                applicant.partner_id.email = applicant.email_from
+            if applicant.partner_phone:
+                applicant.partner_id.phone = applicant.partner_phone
+
+    @api.depends("email_normalized", "partner_phone_sanitized", "linkedin_profile")
+    def _compute_application_count(self):
+        """
+        This method will find all applications that have either the same email,
+        phone number og linkedin profile as the current(self) application(s) excluding
+        applications that are in a talent pool(talents). If self has email,
+        phonenumber or linkedin set this method will include self in the returned count
+        """
+        all_emails = {a.email_normalized for a in self if a.email_normalized}
+        all_phones = {a.partner_phone_sanitized for a in self if a.partner_phone_sanitized}
+        all_linkedins = {a.linkedin_profile for a in self if a.linkedin_profile}
+
+        domain = Domain.FALSE
+        if all_emails:
+            domain |= Domain("email_normalized", "in", list(all_emails))
+        if all_phones:
+            domain |= Domain("partner_phone_sanitized", "in", list(all_phones))
+        if all_linkedins:
+            domain |= Domain("linkedin_profile", "in", list(all_linkedins))
+
+        domain &= Domain("talent_pool_ids", "=", False)
+        matching_applicants = self.env["hr.applicant"].with_context(active_test=False).search(domain)
+
+        email_map = defaultdict(set)
+        phone_map = defaultdict(set)
+        linkedin_map = defaultdict(set)
+        for app in matching_applicants:
+            if app.email_normalized:
+                email_map[app.email_normalized].add(app.id)
+            if app.partner_phone_sanitized:
+                phone_map[app.partner_phone_sanitized].add(app.id)
+            if app.linkedin_profile:
+                linkedin_map[app.linkedin_profile].add(app.id)
 
-    @api.depends('candidate_id')
-    def _compute_other_applications_count(self):
         for applicant in self:
-            same_candidate_applications = max(len(applicant.with_context(active_test=False).candidate_id.applicant_ids) - 1, 0)
-            if applicant.candidate_id:
-                domain = applicant.candidate_id._get_similar_candidates_domain()
-                similar_candidates = self.env['hr.candidate'].with_context(active_test=False).search(domain) - applicant.candidate_id
-                similar_candidate_applications = sum(len(candidate.applicant_ids) for candidate in similar_candidates)
-                applicant.other_applications_count = similar_candidate_applications + same_candidate_applications
-            else:
-                applicant.other_applications_count = same_candidate_applications
+            related_ids = set()
+            if applicant.email_normalized:
+                related_ids.update(email_map.get(applicant.email_normalized, set()))
+            if applicant.partner_phone_sanitized:
+                related_ids.update(phone_map.get(applicant.partner_phone_sanitized, set()))
+            if applicant.linkedin_profile:
+                related_ids.update(linkedin_map.get(applicant.linkedin_profile, set()))
+
+            count = len(related_ids)
+
+            applicant.application_count = max(0, count)
+
+    @api.depends("talent_pool_ids")
+    def _compute_is_pool(self):
+        for applicant in self:
+            applicant.is_pool_applicant = applicant.talent_pool_ids
+
+    def _get_similar_applicants_domain(self, ignore_talent=False, only_talent=False):
+        """
+        This method returns a domain for the applicants whitch match with the
+        current applicant according to email_from, partner_phone or linkedin_profile.
+        Thus, search on the domain will return the current applicant as well
+        if any of the following fields are filled.
+
+        Args:
+            ignore_talent: if you want the domain to only include applicants not belonging to a talent pool
+            only_talent: if you want the domain to only include applicants belonging to a talent pool
+
+        Returns:
+            Domain()
+        """
+        self.ensure_one()
+        domain = Domain("id", "=", self.id)
+        if self.email_normalized:
+            domain |= Domain("email_normalized", "=", self.email_normalized)
+        if self.partner_phone_sanitized:
+            domain |= Domain("partner_phone_sanitized", "=", self.partner_phone_sanitized)
+        if self.linkedin_profile:
+            domain |= Domain("linkedin_profile", "=", self.linkedin_profile)
+        if ignore_talent:
+            domain &= Domain("talent_pool_ids", "=", False)
+        if only_talent:
+            domain &= Domain("talent_pool_ids", "!=", False)
+        return domain
+
+    @api.depends(
+        "talent_pool_ids", "pool_applicant_id", "email_normalized", "partner_phone_sanitized", "linkedin_profile"
+    )
+    def _compute_is_applicant_in_pool(self):
+        """
+        Computes if an application is linked to a talent pool or not.
+        An application can either be directly or indirectly linked to a talent pool.
+        Direct link:
+            - 1. Application has talent_pool_ids set, meaning this application
+                is a talent pool application, or talent for short.
+            - 2. Application has pool_applicant_id set, meaning this application
+            is a copy or directly linked to a talent (scenario 1)
+
+        Indirect link:
+            - 3. Application shares a phone number, email, or linkedin with a
+                direclty linked application.
+
+        Note: While possible, linking an application to a pool through linking
+        it to an indirect link is currently excluded from the implementation
+        for technical reasons.
+        """
+        direct = self.filtered(lambda a: a.talent_pool_ids or a.pool_applicant_id)
+        direct.is_applicant_in_pool = True
+        indirect = self - direct
+
+        if not indirect:
+            return
+
+        all_emails = {a.email_normalized for a in indirect if a.email_normalized}
+        all_phones = {a.partner_phone_sanitized for a in indirect if a.partner_phone_sanitized}
+        all_linkedins = {a.linkedin_profile for a in indirect if a.linkedin_profile}
+
+        epl_domain = Domain.FALSE
+        if all_emails:
+            epl_domain |= Domain("email_normalized", "in", list(all_emails))
+        if all_phones:
+            epl_domain |= Domain("partner_phone_sanitized", "in", list(all_phones))
+        if all_linkedins:
+            epl_domain |= Domain("linkedin_profile", "in", list(all_linkedins))
+
+        pool_domain = Domain(["|", ("talent_pool_ids", "!=", False), ("pool_applicant_id", "!=", False)])
+        domain = pool_domain & epl_domain
+        in_pool_applicants = self.env["hr.applicant"].with_context(active_test=True).search(domain)
+        in_pool_data = {"emails": set(), "phones": set(), "linkedins": set()}
+
+        for applicant in in_pool_applicants:
+            if applicant.email_normalized:
+                in_pool_data["emails"].add(applicant.email_normalized)
+            if applicant.partner_phone_sanitized:
+                in_pool_data["phones"].add(applicant.partner_phone_sanitized)
+            if applicant.linkedin_profile:
+                in_pool_data["linkedins"].add(applicant.linkedin_profile)
+
+        for applicant in indirect:
+            applicant.is_applicant_in_pool = (
+                applicant.email_normalized in in_pool_data["emails"]
+                or applicant.partner_phone_sanitized in in_pool_data["phones"]
+                or applicant.linkedin_profile in in_pool_data["linkedins"]
+            )
+
+    def _search_is_applicant_in_pool(self, operator, value):
+        """
+        This function is needed to hide duplicates when adding applicants/talents to a talent pool.
+        All applications that have either talent_pool_ids or pool_applicant_id set are considered
+        directly in a pool. Furthermore, any application with the same phone number, email or linkedin
+        as the first applications, that are directly in the pool, are also considered to belong to
+        the same talent pool.
+
+        Returns:
+            returns a domain with ids of applications that are either directly or indirectly linked to a pool
+        """
+        if operator not in ["=", "!="] or not isinstance(value, bool):
+            raise NotImplementedError(_("Operation not supported"))
+
+        query = SQL("""
+                WITH talent_pool_applicants AS (
+                    SELECT
+                           a.id as id,
+                           email_normalized,
+                           partner_phone_sanitized,
+                           linkedin_profile
+                      FROM hr_applicant a
+                 LEFT JOIN hr_applicant_hr_talent_pool_rel rel
+                        ON a.id = rel.hr_applicant_id
+                     WHERE pool_applicant_id IS NOT NULL
+                        OR hr_talent_pool_id IS NOT NULL
+                )
+                SELECT a.id
+                FROM hr_applicant a
+                WHERE
+                    -- Check if directly linked to a pool
+                    (a.id IN (
+                        SELECT DISTINCT id
+                        from talent_pool_applicants
+                    ))
+                    OR
+                    -- Check if email matches any talent pool applicant
+                    (a.email_normalized IN (
+                        SELECT DISTINCT email_normalized
+                        FROM talent_pool_applicants
+                        WHERE email_normalized IS NOT NULL
+                    ))
+                    OR
+                    -- Check if phone matches any talent pool applicant
+                    (a.partner_phone_sanitized IN (
+                        SELECT DISTINCT partner_phone_sanitized
+                        FROM talent_pool_applicants
+                        WHERE partner_phone_sanitized IS NOT NULL
+                    ))
+                    OR
+                    -- Check if LinkedIn profile matches any talent pool applicant
+                    (a.linkedin_profile IN (
+                        SELECT DISTINCT linkedin_profile
+                        FROM talent_pool_applicants
+                        WHERE linkedin_profile IS NOT NULL
+                    ))
+        """)
+        domain_operator = "in" if (operator == "=" and value) or (operator == "!=" and not value) else "not in"
+        return [
+            (
+                "id",
+                domain_operator,
+                query,
+            )
+        ]
 
     @api.depends('date_open', 'date_closed')
     def _compute_day(self):
@@ -190,11 +499,6 @@ class HrApplicant(models.Model):
             else:
                 applicant.meeting_display_text = _('Last Meeting')
 
-    @api.depends('candidate_id')
-    def _compute_categ_ids(self):
-        for applicant in self:
-            applicant.categ_ids = applicant.candidate_id.categ_ids.ids + applicant.categ_ids.ids
-
     @api.depends('refuse_reason_id', 'date_closed')
     def _compute_application_status(self):
         for applicant in self:
@@ -337,21 +641,6 @@ class HrApplicant(models.Model):
                     record_name=applicant.display_name,
                     model_description="Applicant",
                 )
-        # Copy CV from candidate to applicant at record creation
-        attachments_by_candidate = dict(self.env['ir.attachment']._read_group([
-            ('res_id', 'in', applicants.candidate_id.ids),
-            ('res_model', '=', "hr.candidate")
-        ], groupby=['res_id'], aggregates=['id:recordset']))
-        for applicant in applicants:
-            if applicant.candidate_id.company_id and applicant.company_id != applicant.candidate_id.company_id:
-                raise ValidationError(_("You cannot create an applicant in a different company than the candidate"))
-            candidate_id = applicant.candidate_id.id
-            if candidate_id not in attachments_by_candidate:
-                continue
-            attachments_by_candidate[candidate_id].copy({
-                'res_id': applicant.id,
-                'res_model': 'hr.applicant'
-            })
         return applicants
 
     def write(self, vals):
@@ -374,6 +663,17 @@ class HrApplicant(models.Model):
                     applicant.job_id.no_of_recruitment += 1
         res = super().write(vals)
 
+        if self.pool_applicant_id and (not self.is_pool_applicant):
+            for applicant in self:
+                if 'email_from' in vals:
+                    applicant.pool_applicant_id.email_from = vals['email_from']
+                if 'partner_phone' in vals:
+                    applicant.pool_applicant_id.partner_phone = vals['partner_phone']
+                if 'linkedin_profile' in vals:
+                    applicant.pool_applicant_id.linkedin_profile = vals['linkedin_profile']
+                if 'type_id' in vals:
+                    applicant.pool_applicant_id.type_id = vals['type_id']
+
         if 'interviewer_ids' in vals:
             interviewers_to_clean = old_interviewers - self.interviewer_ids
             interviewers_to_clean._remove_recruitment_interviewers()
@@ -399,11 +699,7 @@ class HrApplicant(models.Model):
         if vals.get('date_closed'):
             for applicant in self:
                 if applicant.job_id.date_to:
-                    applicant.candidate_id.availability = applicant.job_id.date_to + relativedelta(days=1)
-
-        if vals.get("company_id") and not self.env.context.get('do_not_propagate_company', False):
-            self.candidate_id.with_context(do_not_propagate_company=True).write({"company_id": vals["company_id"]})
-            self.candidate_id.applicant_ids.with_context(do_not_propagate_company=True).write({"company_id": vals["company_id"]})
+                    applicant.availability = applicant.job_id.date_to + relativedelta(days=1)
 
         return res
 
@@ -415,17 +711,14 @@ class HrApplicant(models.Model):
         else:
             hr_job = self.env['hr.job']
 
-        nocontent_body = Markup("""
-<p class="o_view_nocontent_smiling_face">%(help_title)s</p>
-""") % {
+        nocontent_body = Markup("""<p class="o_view_nocontent_smiling_face">%(help_title)s</p>""") % {
             'help_title': _("No application found. Let's create one !"),
         }
 
         if hr_job:
             pattern = r'(.*)<a>(.*?)<\/a>(.*)'
             match = re.fullmatch(pattern, _('Have you tried to <a>add skills to your job position</a> and search into the Reserve ?'))
-            nocontent_body += Markup("""
-<p>%(para_1)s<a href="%(link)s">%(para_2)s</a>%(para_3)s</p>""") % {
+            nocontent_body += Markup("""<p>%(para_1)s<a href="%(link)s">%(para_2)s</a>%(para_3)s</p>""") % {
             'para_1': match[1],
             'para_2': match[2],
             'para_3': match[3],
@@ -475,7 +768,6 @@ class HrApplicant(models.Model):
         res['context'] = {
             'create': True,
             'default_applicant_id': self.id,
-            'default_candidate_id': self.candidate_id.id,
             'default_partner_ids': partners.ids,
             'default_user_id': self.env.uid,
             'default_name': self.partner_name,
@@ -504,25 +796,85 @@ class HrApplicant(models.Model):
 
     def action_open_employee(self):
         self.ensure_one()
-        return self.candidate_id.action_open_employee()
+        return {
+            'name': _('Employee'),
+            'type': 'ir.actions.act_window',
+            'res_model': 'hr.employee',
+            'view_mode': 'form',
+            'res_id': self.employee_id.id,
+        }
 
-    def action_open_other_applications(self):
+    def action_open_applications(self):
         self.ensure_one()
-        similar_candidates = (
-            self.env["hr.candidate"]
+        similar_applicants = (
+            self.env["hr.applicant"]
             .with_context(active_test=False)
-            .search(self.candidate_id._get_similar_candidates_domain())
-            - self.candidate_id
+            .search(
+                self._get_similar_applicants_domain(ignore_talent=True),
+            )
         )
         return {
-            'name': _('Other Applications'),
-            'type': 'ir.actions.act_window',
-            'res_model': 'hr.applicant',
-            'view_mode': 'list,kanban,form,pivot,graph,calendar,activity',
-            'domain': [('id', 'in', (self.candidate_id.applicant_ids + similar_candidates.applicant_ids).ids)],
-            'context': {
-                'active_test': False,
-                'search_default_stage': 1,
+            "name": _("Applications"),
+            "type": "ir.actions.act_window",
+            "res_model": "hr.applicant",
+            "view_mode": "list,form",
+            "domain": [("id", "in", similar_applicants.ids)],
+            "context": {
+                "active_test": False,
+                "search_default_stage": 1,
+                "default_applicant_ids": self.ids,
+                "no_create_application_button": True,
+            },
+        }
+
+    def action_talent_pool_stat_button(self):
+        self.ensure_one()
+        # If the applicant has other applications linked to pool but for some
+        # reason this applicant is not linked to that account then link it
+        if not self.pool_applicant_id:
+            self.link_applicant_to_talent()
+        return {
+            "type": "ir.actions.act_window",
+            "res_model": "hr.applicant",
+            "view_mode": "form",
+            "target": "current",
+            "res_id": self.pool_applicant_id.id,
+        }
+
+    def link_applicant_to_talent(self):
+        talent = self.env["hr.applicant"].search(domain=self._get_similar_applicants_domain(only_talent=True))
+        self.pool_applicant_id = talent
+
+    def action_talent_pool_add_applicants(self):
+        return {
+            "name": _("Add applicants to the pool"),
+            "type": "ir.actions.act_window",
+            "res_model": "talent.pool.add.applicants",
+            "target": "new",
+            "views": [[False, "form"]],
+            "context": {
+                "is_modal": True,
+                "dialog_size": "medium",
+                "default_talent_pool_ids": self.env.context.get(
+                    "default_talent_pool_ids"
+                )
+                or [],
+                "default_applicant_ids": self.ids,
+            },
+        }
+
+    def action_job_add_applicants(self):
+        return {
+            "name": _("Create Applications"),
+            "type": "ir.actions.act_window",
+            "res_model": "job.add.applicants",
+            "target": "new",
+            "views": [[False, "form"]],
+            "context": {
+                "is_modal": True,
+                "dialog_size": "medium",
+                "default_applicant_ids": self.ids
+                or self.env.context.get("default_applicant_ids"),
             },
         }
 
@@ -580,7 +932,7 @@ class HrApplicant(models.Model):
         if not self.env.context.get('show_partner_name'):
             return super()._compute_display_name()
         for applicant in self:
-            applicant.display_name = applicant.partner_name or applicant.name
+            applicant.display_name = applicant.partner_name
 
     @api.model
     def message_new(self, msg, custom_values=None):
@@ -590,36 +942,24 @@ class HrApplicant(models.Model):
         # found.
         self = self.with_context(default_user_id=False)
         stage = False
-        candidate_defaults = {}
-        partner_name, email_from_normalized = tools.parse_contact_from_email(msg.get('from'))
-        candidate_domain = [
-            ("email_from", "=", email_from_normalized),
-        ]
         if custom_values and 'job_id' in custom_values:
             job = self.env['hr.job'].browse(custom_values['job_id'])
             stage = job._get_first_stage()
-            candidate_defaults['company_id'] = job.company_id.id
-            candidate_domain = expression.AND([candidate_domain, [("company_id", "in", [job.company_id.id, False])]])
 
-        candidate = self.env["hr.candidate"].search(candidate_domain, limit=1)\
-            or self.env["hr.candidate"].create({
-                "partner_name": partner_name or email_from_normalized,
-                **candidate_defaults,
-            })
+        partner_name, email_from_normalized = tools.parse_contact_from_email(msg.get('from'))
 
         defaults = {
-            'candidate_id': candidate.id,
             'partner_name': partner_name,
         }
         job_platform = self.env['hr.job.platform'].search([('email', '=', email_from_normalized)], limit=1)
+
         if msg.get('from') and not job_platform:
-            candidate.email_from = msg.get('from')
-            candidate.partner_id = msg.get('author_id', False)
+            defaults['email_from'] = msg.get('from')
+            defaults['partner_id'] = msg.get('author_id', False)
         if msg.get('email_from') and job_platform:
             subject_pattern = re.compile(job_platform.regex or '')
             regex_results = re.findall(subject_pattern, msg.get('subject')) + re.findall(subject_pattern, msg.get('body'))
-            candidate.partner_name = regex_results[0] if regex_results else partner_name
-            defaults["partner_name"] = candidate.partner_name
+            defaults['partner_name'] = regex_results[0] if regex_results else partner_name
             del msg['email_from']
         if msg.get('priority'):
             defaults['priority'] = msg.get('priority')
@@ -628,7 +968,7 @@ class HrApplicant(models.Model):
         if custom_values:
             defaults.update(custom_values)
         res = super().message_new(msg, custom_values=defaults)
-        candidate._compute_partner_phone_email()
+        res._compute_partner_phone_email()
         return res
 
     def _message_post_after_hook(self, message, msg_vals):
@@ -655,9 +995,22 @@ class HrApplicant(models.Model):
         return super()._message_post_after_hook(message, msg_vals)
 
     def create_employee_from_applicant(self):
+        """ Create an employee from applicant """
         self.ensure_one()
-        action = self.candidate_id.create_employee_from_candidate()
-        employee = self.env['hr.employee'].browse(action['res_id'])
+        self._check_interviewer_access()
+
+        if not self.partner_id:
+            if not self.partner_name:
+                raise UserError(_('Please provide an applicant name.'))
+            self.partner_id = self.env['res.partner'].create({
+                'is_company': False,
+                'name': self.partner_name,
+                'email': self.email_from,
+            })
+
+        action = self.env['ir.actions.act_window']._for_xml_id('hr.open_view_employee_list')
+        employee = self.env['hr.employee'].create(self._get_employee_create_vals())
+        action['res_id'] = employee.id
         employee_attachments = self.env['ir.attachment'].search([('res_model', '=','hr.employee'), ('res_id', '=', employee.id)])
         unique_attachments = self.attachment_ids.filtered(
             lambda attachment: attachment.datas not in employee_attachments.mapped('datas')
@@ -672,6 +1025,36 @@ class HrApplicant(models.Model):
         })
         return action
 
+    def _get_employee_create_vals(self):
+        self.ensure_one()
+        address_id = self.partner_id.address_get(['contact'])['contact']
+        address_sudo = self.env['res.partner'].sudo().browse(address_id)
+        return {
+            'name': self.partner_name or self.partner_id.display_name,
+            'work_contact_id': self.partner_id.id,
+            'job_id': self.job_id.id,
+            'job_title': self.job_id.name,
+            'private_street': address_sudo.street,
+            'private_street2': address_sudo.street2,
+            'private_city': address_sudo.city,
+            'private_state_id': address_sudo.state_id.id,
+            'private_zip': address_sudo.zip,
+            'private_country_id': address_sudo.country_id.id,
+            'private_phone': address_sudo.phone,
+            'private_email': address_sudo.email,
+            'lang': address_sudo.lang,
+            'department_id': self.department_id.id,
+            'address_id': self.company_id.partner_id.id,
+            'work_email': self.department_id.company_id.email or self.email_from,  # To have a valid email address by default
+            'work_phone': self.department_id.company_id.phone,
+            'applicant_ids': self.ids,
+            'phone': self.partner_phone
+        }
+
+    def _check_interviewer_access(self):
+        if self.env.user.has_group('hr_recruitment.group_hr_recruitment_interviewer') and not self.env.user.has_group('hr_recruitment.group_hr_recruitment_user'):
+            raise UserError(_('You are not allowed to perform this action.'))
+
     def archive_applicant(self):
         return {
             'type': 'ir.actions.act_window',

--- a/addons/hr_recruitment/models/hr_candidate.py
+++ b/None
@@ -1,400 +0,0 @@
-# Part of Odoo. See LICENSE file for full copyright and licensing details.
-
-from collections import defaultdict
-
-from odoo.addons.hr_recruitment.models.hr_applicant import AVAILABLE_PRIORITIES
-
-from odoo import api, models, fields, SUPERUSER_ID, tools, _
-from odoo.exceptions import UserError
-from odoo.osv import expression
-
-
-class HrCandidate(models.Model):
-    _name = 'hr.candidate'
-    _description = "Candidate"
-    _inherit = ['mail.thread.cc',
-               'mail.thread.main.attachment',
-               'mail.thread.blacklist',
-               'mail.thread.phone',
-               'mail.activity.mixin',
-    ]
-    _order = "priority desc, availability asc, id desc"
-    _mailing_enabled = True
-    _primary_email = 'email_from'
-    _rec_name = 'partner_name'
-
-    active = fields.Boolean("Active", default=True, index=True)
-    company_id = fields.Many2one('res.company', "Company", default=lambda self: self.env.company)
-    applicant_ids = fields.One2many('hr.applicant', 'candidate_id')
-    application_count = fields.Integer(compute="_compute_application_count")
-    partner_id = fields.Many2one('res.partner', "Contact", copy=False, index='btree_not_null')
-    partner_name = fields.Char("Candidates's Name")
-    email_from = fields.Char(
-        string="Email",
-        size=128,
-        compute='_compute_partner_phone_email',
-        inverse='_inverse_partner_email',
-        store=True,
-        index='trigram')
-    email_normalized = fields.Char(index='trigram')  # inherited via mail.thread.blacklist
-    partner_phone = fields.Char(
-        string="Phone",
-        size=32,
-        compute='_compute_partner_phone_email',
-        inverse='_inverse_partner_email',
-        store=True,
-        index='btree_not_null')
-    partner_phone_sanitized = fields.Char(
-        string='Sanitized Phone Number',
-        compute='_compute_partner_phone_sanitized',
-        store=True,
-        index='btree_not_null')
-    linkedin_profile = fields.Char('LinkedIn Profile')
-    type_id = fields.Many2one('hr.recruitment.degree', "Degree")
-    availability = fields.Date("Availability", help="The date at which the applicant will be available to start working", tracking=True)
-    categ_ids = fields.Many2many('hr.applicant.category', string="Tags")
-    color = fields.Integer("Color Index", default=0)
-    priority = fields.Selection(AVAILABLE_PRIORITIES, string="Evaluation", compute="_compute_priority", store=True)
-    user_id = fields.Many2one(
-        'res.users',
-        string="Candidate Manager",
-        default=lambda self: self.env.user if self.env.user.id != SUPERUSER_ID else False,
-        domain="[('share', '=', False), ('company_ids', 'in', company_id)]",
-        tracking=True)
-    employee_id = fields.Many2one('hr.employee', string="Employee", help="Employee linked to the candidate.", copy=False)
-    emp_is_active = fields.Boolean(string="Employee Active", related='employee_id.active')
-    employee_name = fields.Char(related='employee_id.name', string="Employee Name", readonly=False, tracking=False)
-
-    similar_candidates_count = fields.Integer(
-        compute='_compute_similar_candidates_count',
-        help='Candidates with the same email or phone or mobile')
-    applications_count = fields.Integer(string="# Offers", compute='_compute_applications_count')
-    refused_applications_count = fields.Integer(string="# Refused Offers", compute='_compute_applications_count')
-    accepted_applications_count = fields.Integer(string="# Accepted Offers", compute='_compute_applications_count')
-
-    meeting_ids = fields.One2many('calendar.event', 'candidate_id', 'Meetings')
-    meeting_display_text = fields.Char(compute='_compute_meeting_display')
-    meeting_display_date = fields.Date(compute='_compute_meeting_display')
-    attachment_count = fields.Integer(
-        string="Number of Attachments",
-        compute='_compute_attachment_count')
-    candidate_properties = fields.Properties('Properties', definition='company_id.candidate_properties_definition', copy=True)
-    attachment_ids = fields.One2many('ir.attachment', 'res_id', domain=[('res_model', '=', 'hr.candidate')], string='Attachments')
-
-    _email_partner_phone_mobile = models.Index("(email_normalized, partner_phone_sanitized)")
-
-    def _phone_get_number_fields(self):
-        return super()._phone_get_number_fields() + ['partner_phone']
-
-    @api.depends('partner_name')
-    def _compute_display_name(self):
-        for candidate in self:
-            candidate.display_name = candidate.partner_name or candidate.partner_id.name
-
-    @api.depends('partner_phone')
-    def _compute_partner_phone_sanitized(self):
-        for candidate in self:
-            candidate.partner_phone_sanitized = candidate._phone_format(fname='partner_phone') or candidate.partner_phone
-
-    @api.depends('partner_id')
-    def _compute_partner_phone_email(self):
-        for candidate in self:
-            if not candidate.partner_id:
-                continue
-            candidate.email_from = candidate.partner_id.email
-            if not candidate.partner_phone:
-                candidate.partner_phone = candidate.partner_id.phone
-
-    def _inverse_partner_email(self):
-        for candidate in self:
-            if not candidate.email_from:
-                continue
-            if not candidate.partner_id:
-                if not candidate.partner_name:
-                    raise UserError(_('You must define a Contact Name for this candidate.'))
-                candidate.partner_id = self.env['res.partner'].with_context(default_lang=self.env.lang).find_or_create(candidate.email_from)
-            if candidate.partner_name and (not candidate.partner_id.name or candidate.partner_id.name == candidate.email_from):
-                candidate.partner_id.name = candidate.partner_name
-            if tools.email_normalize(candidate.email_from) != tools.email_normalize(candidate.partner_id.email):
-                # change email on a partner will trigger other heavy code, so avoid to change the email when
-                # it is the same. E.g. "email@example.com" vs "My Email" <email@example.com>""
-                candidate.partner_id.email = candidate.email_from
-            if candidate.partner_phone:
-                candidate.partner_id.phone = candidate.partner_phone
-
-    @api.depends('email_from', 'partner_phone_sanitized')
-    def _compute_similar_candidates_count(self):
-        """
-            The field similar_candidates_count is only used on the form view.
-            Thus, using ORM rather then querying, should not make much
-            difference in terms of performance, while being more readable and secure.
-        """
-        if not any(self._ids):
-            for candidate in self:
-                domain = candidate._get_similar_candidates_domain()
-                if domain:
-                    candidate.similar_candidates_count = max(0, self.env["hr.candidate"].with_context(active_test=False).search_count(domain) - 1)
-                else:
-                    candidate.similar_candidates_count = 0
-            return
-        self.flush_recordset(['email_normalized', 'partner_phone_sanitized'])
-        self.env.cr.execute("""
-            SELECT
-                id,
-                (
-                    SELECT COUNT(*)
-                    FROM hr_candidate AS sub
-                    WHERE c.id != sub.id
-                     AND ((coalesce(c.email_normalized, '') <> '' AND sub.email_normalized = c.email_normalized)
-                       OR (coalesce(c.partner_phone_sanitized, '') <> '' AND c.partner_phone_sanitized = sub.partner_phone_sanitized))
-                      AND c.company_id = sub.company_id
-                ) AS similar_candidates
-            FROM hr_candidate AS c
-            WHERE id IN %(ids)s
-        """, {'ids': tuple(self._origin.ids)})
-        query_results = self.env.cr.dictfetchall()
-        mapped_data = {result['id']: result['similar_candidates'] for result in query_results}
-        for candidate in self:
-            candidate.similar_candidates_count = mapped_data.get(candidate.id, 0)
-
-    def _get_similar_candidates_domain(self):
-        """
-            This method returns a domain for the applicants whitch match with the
-            current candidate according to email_from, partner_phone.
-            Thus, search on the domain will return the current candidate as well if any of
-            the following fields are filled.
-        """
-        self.ensure_one()
-        if not self:
-            return []
-        domain = [('id', 'in', self.ids)]
-        if self.email_normalized:
-            domain = expression.OR([domain, [('email_normalized', '=', self.email_normalized)]])
-        if self.partner_phone_sanitized:
-            domain = expression.OR([domain, [('partner_phone_sanitized', '=', self.partner_phone_sanitized)]])
-        domain = expression.AND([domain, [('company_id', '=', self.company_id.id)]])
-        return domain
-
-    def _compute_attachment_count(self):
-        read_group_res = self.env['ir.attachment']._read_group(
-            [('res_model', '=', 'hr.candidate'), ('res_id', 'in', self.ids)],
-            ['res_id'], ['__count'])
-        attach_data = dict(read_group_res)
-        for candidate in self:
-            candidate.attachment_count = attach_data.get(candidate.id, 0)
-
-    def _compute_application_count(self):
-        read_group_res = self.env['hr.applicant']._read_group(
-            [('candidate_id', 'in', self.ids)],
-            ['candidate_id'], ['__count'])
-        application_data = dict(read_group_res)
-        for candidate in self:
-            candidate.application_count = application_data.get(candidate, 0)
-
-    @api.depends('applicant_ids.priority')
-    def _compute_priority(self):
-        for candidate in self:
-            if not candidate.applicant_ids:
-                candidate.priority = "0"
-            else:
-                candidate.priority = str(round(sum(int(a.priority) for a in candidate.applicant_ids) / len(candidate.applicant_ids)))
-
-    def _compute_applications_count(self):
-        result = defaultdict(lambda: {"total": 0, "refused": 0, "accepted": 0})
-        for applicant in self.with_context(active_test=False).applicant_ids:
-            result[applicant.candidate_id.id]["total"] += 1
-            if applicant.application_status == "refused":
-                result[applicant.candidate_id.id]["refused"] += 1
-            elif applicant.application_status == "hired":
-                result[applicant.candidate_id.id]["accepted"] += 1
-        for candidate in self:
-            candidate.applications_count = result[candidate.id]['total']
-            candidate.refused_applications_count = result[candidate.id]['refused']
-            candidate.accepted_applications_count = result[candidate.id]['accepted']
-
-    @api.depends_context('lang')
-    @api.depends('meeting_ids', 'meeting_ids.start')
-    def _compute_meeting_display(self):
-        candidate_with_meetings = self.filtered('meeting_ids')
-        (self - candidate_with_meetings).update({
-            'meeting_display_text': _('No Meeting'),
-            'meeting_display_date': ''
-        })
-        today = fields.Date.today()
-        for candidate in candidate_with_meetings:
-            count = len(candidate.meeting_ids)
-            dates = candidate.meeting_ids.mapped('start')
-            min_date, max_date = min(dates).date(), max(dates).date()
-            if min_date >= today:
-                candidate.meeting_display_date = min_date
-            else:
-                candidate.meeting_display_date = max_date
-            if count == 1:
-                candidate.meeting_display_text = _('1 Meeting')
-            elif candidate.meeting_display_date >= today:
-                candidate.meeting_display_text = _('Next Meeting')
-            else:
-                candidate.meeting_display_text = _('Last Meeting')
-
-    def write(self, vals):
-        res = super().write(vals)
-
-        if vals.get("company_id") and not self.env.context.get('do_not_propagate_company', False):
-            self.applicant_ids.with_context(do_not_propagate_company=True).write({"company_id": vals["company_id"]})
-        return res
-
-    def action_open_similar_candidates(self):
-        self.ensure_one()
-        domain = self._get_similar_candidates_domain()
-        similar_candidates = self.env['hr.candidate'].with_context(active_test=False).search(domain)
-        return {
-            'type': 'ir.actions.act_window',
-            'name': _('Similar Candidates'),
-            'res_model': self._name,
-            'view_mode': 'list,kanban,form,activity',
-            'domain': [('id', 'in', similar_candidates.ids)],
-            'context': {
-                'active_test': False,
-            },
-        }
-
-    def action_open_applications(self):
-        self.ensure_one()
-        return {
-            'name': _('Applications'),
-            'type': 'ir.actions.act_window',
-            'res_model': 'hr.applicant',
-            'view_mode': 'list,kanban,form,pivot,graph,calendar,activity',
-            'domain': [('id', 'in', self.applicant_ids.ids)],
-            'context': {
-                'active_test': False,
-                'search_default_stage': 1,
-            },
-        }
-
-    def action_open_employee(self):
-        self.ensure_one()
-        return {
-            'name': _('Employee'),
-            'type': 'ir.actions.act_window',
-            'res_model': 'hr.employee',
-            'view_mode': 'form',
-            'res_id': self.employee_id.id,
-        }
-
-    def action_create_meeting(self):
-        """ This opens Meeting's calendar view to schedule meeting on current candidate
-            @return: Dictionary value for created Meeting view
-        """
-        self.ensure_one()
-        if not self.partner_id:
-            if not self.partner_name:
-                raise UserError(_('You must define a Contact Name for this candidate.'))
-            self.partner_id = self.env['res.partner'].create({
-                'is_company': False,
-                'name': self.partner_name,
-                'email': self.email_from,
-            })
-
-        partners = self.partner_id
-        if self.env.user.has_group('hr_recruitment.group_hr_recruitment_interviewer') and not self.env.user.has_group('hr_recruitment.group_hr_recruitment_user'):
-            partners |= self.env.user.partner_id
-        else:
-            partners |= self.user_id.partner_id
-
-        res = self.env['ir.actions.act_window']._for_xml_id('calendar.action_calendar_event')
-        # As we are redirected from the hr.candidate, calendar checks rules on "hr.applicant",
-        # in order to decide whether to allow creation of a meeting.
-        # As interviewer does not have create right on the hr.applicant, in order to allow them
-        # to create a meeting for an applicant, we pass 'create': True to the context.
-        res['context'] = {
-            'create': True,
-            'default_candidate_id': self.id,
-            'default_partner_ids': partners.ids,
-            'default_user_id': self.env.uid,
-            'default_name': self.partner_name,
-            'attachment_ids': self.attachment_ids.ids
-        }
-        return res
-
-    @api.ondelete(at_uninstall=False)
-    def _unlink_except_linked_employee(self):
-        if self.employee_id:
-            raise UserError(_("The candidate is linked to an employee, to avoid losing information, archive it instead."))
-
-    def create_employee_from_candidate(self):
-        self.ensure_one()
-        self._check_interviewer_access()
-
-        if not self.partner_id:
-            if not self.partner_name:
-                raise UserError(_('Please provide an candidate name.'))
-            self.partner_id = self.env['res.partner'].create({
-                'is_company': False,
-                'name': self.partner_name,
-                'email': self.email_from,
-            })
-
-        action = self.env['ir.actions.act_window']._for_xml_id('hr.open_view_employee_list')
-        employee = self.env['hr.employee'].create(self._get_employee_create_vals())
-        attachments = self.env['ir.attachment'].search([('res_model', '=', self._name), ('res_id', '=', self.id)])
-        if attachments:
-            attachments.copy({'res_model': 'hr.employee', 'res_id': employee.id})
-        action['res_id'] = employee.id
-        return action
-
-    def _get_employee_create_vals(self):
-        self.ensure_one()
-        address_id = self.partner_id.address_get(['contact'])['contact']
-        address_sudo = self.env['res.partner'].sudo().browse(address_id)
-        return {
-            'name': self.partner_name or self.partner_id.display_name,
-            'work_contact_id': self.partner_id.id,
-            'private_street': address_sudo.street,
-            'private_street2': address_sudo.street2,
-            'private_city': address_sudo.city,
-            'private_state_id': address_sudo.state_id.id,
-            'private_zip': address_sudo.zip,
-            'private_country_id': address_sudo.country_id.id,
-            'private_phone': address_sudo.phone,
-            'private_email': address_sudo.email,
-            'lang': address_sudo.lang,
-            'address_id': self.company_id.partner_id.id,
-            'candidate_id': self.ids,
-            'phone': self.partner_phone
-        }
-
-    def _check_interviewer_access(self):
-        if self.env.user.has_group('hr_recruitment.group_hr_recruitment_interviewer') and not self.env.user.has_group('hr_recruitment.group_hr_recruitment_user'):
-            raise UserError(_('You are not allowed to perform this action.'))
-
-    def action_open_attachments(self):
-        return {
-            'type': 'ir.actions.act_window',
-            'res_model': 'ir.attachment',
-            'name': _('Documents'),
-            'context': {
-                'default_res_model': 'hr.candidate',
-                'default_res_id': self.ids[0],
-                'show_partner_name': 1,
-            },
-            'view_mode': 'list,form',
-            'views': [
-                (self.env.ref('hr_recruitment.ir_attachment_hr_recruitment_list_view').id, 'list'),
-                (False, 'form'),
-            ],
-            'search_view_id': self.env.ref('hr_recruitment.ir_attachment_view_search_inherit_hr_recruitment').ids,
-            'domain': [('res_model', '=', 'hr.candidate'), ('res_id', 'in', self.ids)],
-        }
-
-    def action_send_email(self):
-        return {
-            'name': _('Send Email'),
-            'type': 'ir.actions.act_window',
-            'target': 'new',
-            'view_mode': 'form',
-            'res_model': 'candidate.send.mail',
-            'context': {
-                'default_candidate_ids': self.ids,
-            }
-        }

--- a/addons/hr_recruitment/models/hr_employee.py
+++ b/addons/hr_recruitment/models/hr_employee.py
@@ -6,23 +6,22 @@ from odoo import api, fields, models
 class HrEmployee(models.Model):
     _inherit = "hr.employee"
 
-    # YTI Rename into candidate_ids
-    candidate_id = fields.One2many('hr.candidate', 'employee_id', 'Candidate', groups="hr.group_hr_user")
+    applicant_ids = fields.One2many('hr.applicant', 'employee_id', 'Applicant', groups="hr.group_hr_user")
 
     def _get_partner_count_depends(self):
-        return super()._get_partner_count_depends() + ['candidate_id']
+        return super()._get_partner_count_depends() + ['applicant_ids']
 
     def _get_related_partners(self):
         partners = super()._get_related_partners()
-        return partners | self.sudo().candidate_id.partner_id
+        return partners | self.sudo().applicant_ids.partner_id
 
     @api.model_create_multi
     def create(self, vals_list):
         employees = super().create(vals_list)
         for employee in employees:
-            if employee.candidate_id:
-                employee.candidate_id._message_log_with_view(
-                    'hr_recruitment.candidate_hired_template',
-                    render_values={'candidate': employee.candidate_id}
+            if employee.applicant_ids:
+                employee.applicant_ids._message_log_with_view(
+                    'hr_recruitment.applicant_hired_template',
+                    render_values={'applicant': employee.applicant_ids}
                 )
         return employees

--- a/addons/hr_recruitment/models/hr_job.py
+++ b/addons/hr_recruitment/models/hr_job.py
@@ -59,8 +59,10 @@ class HrJob(models.Model):
     interviewer_ids = fields.Many2many('res.users', string='Interviewers', domain="[('share', '=', False), ('company_ids', 'in', company_id)]", tracking=True, help="The Interviewers set on the job position can see all Applicants in it. They have access to the information, the attachments, the meeting management and they can refuse him. You don't need to have Recruitment rights to be set as an interviewer.")
     extended_interviewer_ids = fields.Many2many('res.users', 'hr_job_extended_interviewer_res_users', compute='_compute_extended_interviewer_ids', store=True)
     industry_id = fields.Many2one('res.partner.industry', 'Industry', tracking=True)
-    date_from = fields.Date(help="Is set, update candidates availability once hired for that specific mission.")
+    date_from = fields.Date(help="Is set, update applicants availability once hired for that specific mission.")
     date_to = fields.Date()
+    currency_id = fields.Many2one("res.currency", related="company_id.currency_id", readonly=True)
+    compensation = fields.Monetary(currency_field="currency_id")
 
     activities_overdue = fields.Integer(compute='_compute_activities')
     activities_today = fields.Integer(compute='_compute_activities')
@@ -315,12 +317,12 @@ class HrJob(models.Model):
                     application_ids.message_unsubscribe(to_unsubscribe)
                     application_ids.user_id = job.user_id
 
-        # Update the availability on all hired candidates if the mission end date is changed
+        # Update the availability on all hired applicants if the mission end date is changed
         if "date_to" in vals:
             for job in self:
-                hired_candidates = job.application_ids.filtered(lambda a: a.application_status == 'hired')
-                for candidate in hired_candidates:
-                    candidate.availability = job.date_to + relativedelta(days=1)
+                hired_applicants = job.application_ids.filtered(lambda a: a.application_status == 'hired')
+                for applicant in hired_applicants:
+                    applicant.availability = job.date_to + relativedelta(days=1)
 
         # Since the alias is created upon record creation, the default values do not reflect the current values unless
         # specifically rewritten

--- a/None
+++ b/addons/hr_recruitment/models/hr_talent_pool.py
@@ -0,0 +1,53 @@
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+from random import randint
+
+from odoo import fields, models
+
+
+class HrTalentPool(models.Model):
+    _name = "hr.talent.pool"
+    _description = "Talent Pool"
+    _inherit = ["mail.thread"]
+
+    def _get_default_color(self):
+        return randint(1, 11)
+
+    active = fields.Boolean(default=True)
+    name = fields.Char(string="Title", required=True, translate=True)
+    company_id = fields.Many2one(
+        "res.company",
+        string="Company",
+        default=lambda self: self.env.company,
+        tracking=True,
+    )
+    pool_manager = fields.Many2one(
+        "res.users",
+        "Pool Manager",
+        default=lambda self: self.env.user,
+        domain="[('share', '=', False), ('company_ids', 'in', company_id)]",
+        tracking=True,
+        store=True,
+        readonly=False,
+    )
+    talent_ids = fields.Many2many(comodel_name="hr.applicant", string="Talent", groups="base.group_user")
+    no_of_talents = fields.Integer(
+        compute="_compute_talent_count",
+        string="# Talents",
+        help="The number of talents in this talent pool.",
+    )
+    description = fields.Html(string="Talent Pool Description")
+    color = fields.Integer(string="Color", default=_get_default_color)
+    categ_ids = fields.Many2many(
+        comodel_name="hr.applicant.category",
+        string="Tags",
+        store=True,
+        readonly=False,
+    )
+
+    def _compute_talent_count(self):
+        talents = self.env["hr.applicant"]._read_group(
+            domain=[("talent_pool_ids", "in", self.ids)], groupby=["talent_pool_ids"], aggregates=["__count"]
+        )
+        talent_data = {talent_pool.id: count for talent_pool, count in talents}
+        for pool in self:
+            pool.no_of_talents = talent_data.get(pool.id, 0)

--- a/addons/hr_recruitment/models/res_company.py
+++ b/addons/hr_recruitment/models/res_company.py
@@ -6,5 +6,4 @@ from odoo import fields, models
 class ResCompany(models.Model):
     _inherit = "res.company"
 
-    candidate_properties_definition = fields.PropertiesDefinition('Candidate Properties')
     job_properties_definition = fields.PropertiesDefinition("Job Properties")
