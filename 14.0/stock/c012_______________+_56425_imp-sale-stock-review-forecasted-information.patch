PR: https://github.com/odoo/odoo/pull/56425

From: 5e5de2b2b64fd8cb259e72fc1a97dc754da871ad
From: RÃ©my Voet (ryv)
Date: 2020-09-11 09:18:09

Structural Changes: 3
Total Changes: 82

[IMP] (sale_)stock: review forecasted information

Remove the json_forecast of the sale order line,
it was a duplicate of information with the qty_at_date_widget.
But improve this one:
- Use the forecasted move information in case of confirmed SO.
- Change the icon (i) to chart.
- Link to the forcasted change to target new forcasted report
(Unfortunately we loose the feature to see components product forcasted
of a kit)
- Change information print in the popover in case of confirmed SO.

Also refactor the json_forcasted of `stock.move` into multiple fields
to avoid to dump/loads for other model who needed the forcasted data.

task-2324039

closes odoo/odoo#56425

Related: odoo/enterprise#13063
Signed-off-by: Arnold Moyaux <amoyaux@users.noreply.github.com>

================================= pseudo patch: =================================

--- a/addons/stock/models/stock_move.py
+++ b/addons/stock/models/stock_move.py
@@ -176,7 +176,10 @@ class StockMove(models.Model):
     next_serial = fields.Char('First SN')
     next_serial_count = fields.Integer('Number of SN')
     orderpoint_id = fields.Many2one('stock.warehouse.orderpoint', 'Original Reordering Rule', check_company=True)
+    # TODO : remove `json_forecast` in master, use forcast_ fields instead
     json_forecast = fields.Char('JSON data for the forecast widget', compute='_compute_json_forecast')
+    forecast_availability = fields.Float('Forcast Availability', compute='_compute_json_forecast', digits='Product Unit of Measure')
+    forecast_expected_date = fields.Datetime('Forcasted Expected date', compute='_compute_json_forecast')
     lot_ids = fields.Many2many('stock.production.lot', compute='_compute_lot_ids', inverse='_set_lot_ids', string='Serial Numbers', readonly=False)
 
     @api.onchange('product_id', 'picking_type_id')
@@ -405,30 +408,24 @@ class StockMove(models.Model):
                 total_availability = self.env['stock.quant']._get_available_quantity(move.product_id, move.location_id) if move.product_id else 0.0
                 move.availability = min(move.product_qty, total_availability)
 
-    @api.depends('product_id', 'picking_type_id', 'picking_id', 'reserved_availability', 'priority')
+    @api.depends('product_id', 'picking_type_id', 'picking_id', 'reserved_availability', 'priority', 'state', 'product_uom_qty')
     def _compute_json_forecast(self):
+        """ Compute forecasted information of the related product by warehouse."""
         self.json_forecast = False
-        if not any(self._ids):
-            # onchange
-            return
-        # compute
-        precision = self.env['decimal.precision'].precision_get('Product Unit of Measure')
-        not_product_moves = self.filtered(lambda move: move.product_id.type == 'product')
+        self.forecast_availability = False
+        self.forecast_expected_date = False
+
+        not_product_moves = self.filtered(lambda move: move.product_id.type != 'product')
         for move in not_product_moves:
-            reserved_availability = float_repr(move.reserved_availability, precision)
-            move.json_forecast = json.dumps({'reservedAvailability': reserved_availability})
+            move.forecast_availability = move.product_qty
         outgoing_unreserved_moves_per_warehouse = defaultdict(lambda: self.env['stock.move'])
         for move in (self - not_product_moves):
             picking_type = move.picking_type_id or move.picking_id.picking_type_id
-            is_unreserved = float_is_zero(move.reserved_availability, precision_rounding=move.product_uom.rounding)
-            if picking_type.code in self._consuming_picking_types():
-                if is_unreserved:
-                    outgoing_unreserved_moves_per_warehouse[picking_type.warehouse_id] |= move
-                else:
-                    reserved_availability = float_repr(move.reserved_availability, precision)
-                    move.json_forecast = json.dumps({'reservedAvailability': reserved_availability})
-        if not outgoing_unreserved_moves_per_warehouse:
-            return
+            is_unreserved = move.state in ('waiting', 'confirmed', 'partially_available')
+            if picking_type.code in self._consuming_picking_types() and is_unreserved:
+                outgoing_unreserved_moves_per_warehouse[picking_type.warehouse_id] |= move
+            elif picking_type.code in self._consuming_picking_types():
+                move.forecast_availability = move.reserved_availability
 
         for warehouse, moves in outgoing_unreserved_moves_per_warehouse.items():
             product_variant_ids = moves.product_id.ids
@@ -439,25 +436,13 @@ class StockMove(models.Model):
             forecast_lines = self.env['report.stock.report_product_product_replenishment']\
                 ._get_report_lines(None, product_variant_ids, wh_location_ids)
             for move in moves:
-                found = [l for l in forecast_lines if l["move_out"] == move and l["replenishment_filled"] is True]
-                if found:
-                    move_ins = list(filter(lambda report_line: report_line['move_in'], found))
-                    # If the move is linked to multiple ingoing moves, take only the last one to have the worst expected date.
-                    if len(move_ins):
-                        found = [move_ins[-1]]
-                    # The move is replenished but there's no expected date -> take from stock
-                    if found[0]["receipt_date_short"] is False:
-                        reserved_availability = float_repr(move.reserved_availability, precision)
-                        move.json_forecast = json.dumps({'reservedAvailability': reserved_availability})
-                    else:
-                        move.json_forecast = json.dumps({
-                            'sortingDate': format_date(self.env, found[0]['move_in'].date, date_format='yyyy-MM-dd'),
-                            'expectedDate': found[0]["receipt_date_short"],
-                            'isLate': found[0]["is_late"],
-                            'replenishmentFilled': found[0]["replenishment_filled"]
-                        })
-                else:
-                    move.json_forecast = json.dumps({'expectedDate': None})
+                lines = [l for l in forecast_lines if l["move_out"] == move._origin and l["replenishment_filled"] is True]
+                if lines:
+                    move.forecast_availability = sum(m['quantity'] for m in lines)
+                    move_ins_lines = list(filter(lambda report_line: report_line['move_in'], lines))
+                    if move_ins_lines:
+                        expected_date = max(m['move_in'].date for m in move_ins_lines)
+                        move.forecast_expected_date = expected_date
 
     def _set_date_deadline(self, new_deadline):
         # Handle the propagation of `date_deadline` fields (up and down stream - only update by up/downstream documents)

--- a/addons/stock/models/stock_picking.py
+++ b/addons/stock/models/stock_picking.py
@@ -15,6 +15,7 @@ from odoo.exceptions import UserError
 from odoo.osv import expression
 from odoo.tools import DEFAULT_SERVER_DATETIME_FORMAT, format_datetime
 from odoo.tools.float_utils import float_compare, float_is_zero, float_round
+from odoo.tools.misc import format_date
 
 
 class PickingType(models.Model):
@@ -400,24 +401,20 @@ class Picking(models.Model):
         for picking in self:
             picking.delay_alert_date = delay_alert_date_data.get(picking.id, False)
 
-    @api.depends('move_lines', 'state')
+    @api.depends('move_lines', 'state', 'picking_type_code', 'move_lines.forecast_availability', 'move_lines.forecast_expected_date')
     def _compute_products_availability(self):
         self.products_availability = False
         self.products_availability_state = 'available'
         pickings = self.filtered(lambda picking: picking.state not in ['cancel', 'draft', 'done'] and picking.picking_type_code == 'outgoing')
+        pickings.products_availability = _('Available')
         for picking in pickings:
-            forecast_data = []
-            for move in picking.move_lines:
-                if move.json_forecast:
-                    forecast_data.append(json.loads(move.json_forecast))
-            picking.products_availability = 'Available'
-            forecast_data.sort(key=lambda line: line.get('sortingDate', ''), reverse=True)
-            if len(forecast_data) > 0 and forecast_data[0].get('sortingDate', False):
-                picking.products_availability = _('Exp %s', forecast_data[0]['expectedDate'])
-                picking.products_availability_state = 'late' if forecast_data[0]['isLate'] else 'expected'
-            elif any(not data.get('reservedAvailability', False) for data in forecast_data):
-                picking.products_availability = 'Not Available'
-                picking.products_availability_state = 'late'
+            forecast_date = max(picking.move_lines.filtered('forecast_expected_date').mapped('forecast_expected_date'), default=False)
+            if any(float_compare(move.forecast_availability, move.product_qty, move.product_id.uom_id.rounding) == -1 for move in picking.move_lines):
+                picking.components_availability = _('Not Available')
+                picking.components_availability_state = 'late'
+            elif forecast_date:
+                picking.components_availability = _('Exp %s', format_date(self.env, forecast_date))
+                picking.components_availability_state = 'late' if picking.date_deadline < forecast_date else 'expected'
 
     @api.depends('picking_type_id.show_operations')
     def _compute_show_operations(self):
