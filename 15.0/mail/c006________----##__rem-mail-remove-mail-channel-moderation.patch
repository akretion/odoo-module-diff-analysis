PR: https://github.com/odoo/odoo/pull/

From: 59d6bb23d75cd8ddf8e62dad8aa8ad13d0cf4a0a
From: std-odoo
Date: 2021-07-09 11:16:38

Structural Changes: 21
Total Changes: 559

[REM] mail: remove mail channel moderation

Rationale
=========

Currently, mail channels have 2 modes
- They can be used like Discuss channel (chat, livechat, group)
- They can be used like a Mailing List (with the "email_send" field)

The mix of both feature in the same model causes some code complexity.
Several fields are not used in both cases (moderation related field)
and the future "Discord like" Discuss will even push the mail channel
further than the usage of the mailing list.

Because of all those reasons, we want to split the 2 mains features of
the mail channels into 2 different modules and models.

Purpose
=======

This commit remove the moderation feature of the mail channel
(email_send=True). This will be re-implemented in a separate module
in the next commit.

Do not be able to check messages in Discuss anymore because this
feature is only used to moderate the message and this feature will be
spitted in a new module "mail_group".

Links
=====

Task-2510267
See odoo/odoo/pull/71599
See odoo/enterprise/pull/19296
See odoo/upgrade/pull/2600

================================= pseudo patch: =================================

--- a/addons/mail/models/__init__.py
+++ b/addons/mail/models/__init__.py
@@ -17,7 +17,6 @@ from . import mail_thread
 from . import mail_thread_blacklist
 from . import mail_thread_cc
 from . import mail_blacklist
-from . import mail_moderation
 from . import mail_channel_partner
 from . import mail_channel
 from . import mail_template

--- a/addons/mail/models/mail_channel.py
+++ b/addons/mail/models/mail_channel.py
@@ -11,7 +11,6 @@ from odoo.exceptions import UserError, ValidationError
 from odoo.osv import expression
 from odoo.tools import ormcache, formataddr
 
-MODERATION_FIELDS = ['moderation', 'moderator_ids', 'moderation_ids', 'moderation_notify', 'moderation_notify_msg', 'moderation_guidelines', 'moderation_guidelines_msg']
 _logger = logging.getLogger(__name__)
 
 
@@ -48,7 +47,6 @@ class Channel(models.Model):
     description = fields.Text('Description')
     email_send = fields.Boolean('Send messages by email', default=False)
     image_128 = fields.Image("Image", max_width=128, max_height=128, default=_get_default_image)
-    # members (depends=['...'] is for `test_mail/tests/common.py`, class Moderation, `setUpClass`)
     channel_partner_ids = fields.Many2many(
         'res.partner', string='Members',
         compute='_compute_channel_partner_ids', inverse='_inverse_channel_partner_ids',
@@ -73,21 +71,6 @@ class Channel(models.Model):
         help='This group is visible by non members. Invisible groups can add members through the invite button.')
     group_public_id = fields.Many2one('res.groups', string='Authorized Group',
                                       default=lambda self: self.env.ref('base.group_user'))
-    # moderation
-    moderation = fields.Boolean(string='Moderate this channel')
-    moderator_ids = fields.Many2many('res.users', 'mail_channel_moderator_rel', string='Moderators')
-    is_moderator = fields.Boolean(help="Current user is a moderator of the channel", string='Moderator', compute="_compute_is_moderator")
-    moderation_ids = fields.One2many(
-        'mail.moderation', 'channel_id', string='Moderated Emails',
-        groups="base.group_user")
-    moderation_count = fields.Integer(
-        string='Moderated emails count', compute='_compute_moderation_count',
-        groups="base.group_user")
-    moderation_notify = fields.Boolean(string="Automatic notification", help="People receive an automatic notification about their message being waiting for moderation.")
-    moderation_notify_msg = fields.Text(string="Notification message")
-    moderation_guidelines = fields.Boolean(string="Send guidelines to new subscribers", help="Newcomers on this moderated channel will automatically receive the guidelines.")
-    moderation_guidelines_msg = fields.Text(string="Guidelines")
-
     # COMPUTE / INVERSE
 
     @api.depends('channel_type')
@@ -133,46 +116,6 @@ class Channel(models.Model):
         for channel in self:
             channel.is_member = self.env.user.partner_id in channel.channel_partner_ids
 
-    @api.depends('moderator_ids')
-    @api.depends_context('uid')
-    def _compute_is_moderator(self):
-        for channel in self:
-            channel.is_moderator = self.env.user in channel.moderator_ids
-
-    @api.depends('moderation_ids')
-    def _compute_moderation_count(self):
-        read_group_res = self.env['mail.moderation'].read_group([('channel_id', 'in', self.ids)], ['channel_id'], 'channel_id')
-        data = dict((res['channel_id'][0], res['channel_id_count']) for res in read_group_res)
-        for channel in self:
-            channel.moderation_count = data.get(channel.id, 0)
-
-    # CONSTRAINTS
-
-    @api.constrains('moderator_ids')
-    def _check_moderator_email(self):
-        if any(not moderator.email for channel in self for moderator in channel.moderator_ids):
-            raise ValidationError(_("Moderators must have an email address."))
-
-    @api.constrains('moderator_ids', 'channel_partner_ids')
-    def _check_moderator_is_member(self):
-        for channel in self:
-            if channel.moderator_ids.partner_id > channel.channel_partner_ids:
-                missing = channel.mapped('moderator_ids.partner_id') - channel.channel_partner_ids
-                raise ValidationError(
-                    _("Moderators should be members of the channel they moderate (missing %(user_names)s).",
-                      user_names=', '.join(missing.mapped('name')))
-                )
-
-    @api.constrains('moderation', 'email_send')
-    def _check_moderation_parameters(self):
-        if any(not channel.email_send and channel.moderation for channel in self):
-            raise ValidationError(_('Only mailing lists can be moderated.'))
-
-    @api.constrains('moderator_ids')
-    def _check_moderator_existence(self):
-        if any(not channel.moderator_ids for channel in self if channel.moderation):
-            raise ValidationError(_('Moderated channels must have moderators.'))
-
     # ONCHANGE
 
     @api.onchange('public')
@@ -180,29 +123,6 @@ class Channel(models.Model):
         if self.public != 'public' and self.alias_contact == 'everyone':
             self.alias_contact = 'followers'
 
-    @api.onchange('moderator_ids')
-    def _onchange_moderator_ids(self):
-        missing_partner_ids = set(self.mapped('moderator_ids.partner_id').ids) - set(self.mapped('channel_last_seen_partner_ids.partner_id').ids)
-        if missing_partner_ids:
-            self.channel_last_seen_partner_ids = [
-                Command.create({'partner_id': partner_id})
-                for partner_id in missing_partner_ids
-            ]
-
-    @api.onchange('email_send')
-    def _onchange_email_send(self):
-        if not self.email_send:
-            self.moderation = False
-
-    @api.onchange('moderation')
-    def _onchange_moderation(self):
-        if not self.moderation:
-            self.moderation_notify = False
-            self.moderation_guidelines = False
-            self.moderator_ids = False
-        else:
-            self.moderator_ids |= self.env.user
-
     # ------------------------------------------------------------
     # CRUD
     # ------------------------------------------------------------
@@ -271,27 +191,11 @@ class Channel(models.Model):
             raise UserError(_('You cannot delete those groups, as the Whole Company group is required by other modules.'))
 
     def write(self, vals):
-        # First checks if user tries to modify moderation fields and has not the right to do it.
-        if any(key for key in MODERATION_FIELDS if vals.get(key)) and not self.env.user.has_group('base.group_system'):
-            not_moderator = self.filtered(lambda channel: channel.moderation and self.env.user not in channel.moderator_ids)
-            if not_moderator:
-                raise UserError(_("You do not have rights to modify moderation configuration on %(channel_names)s",
-                                   channel_names=', '.join(not_moderator.mapped('name'))
-                               ))
-
         result = super(Channel, self).write(vals)
 
         if vals.get('group_ids'):
             self._subscribe_users_automatically()
 
-        # avoid keeping messages to moderate and accept them
-        if vals.get('moderation') is False:
-            self.env['mail.message'].search([
-                ('moderation_status', '=', 'pending_moderation'),
-                ('model', '=', 'mail.channel'),
-                ('res_id', 'in', self.ids)
-            ])._moderate_accept()
-
         return result
 
     def init(self):
@@ -568,19 +472,12 @@ class Channel(models.Model):
         return super(Channel, self)._notify_email_recipient_values(whitelist.ids)
 
     def _notify_thread(self, message, msg_vals=False, **kwargs):
-        # When posting a message on a mail channel, manage moderation and postpone notify users
-        if not msg_vals or msg_vals.get('moderation_status') != 'pending_moderation':
-            # link message to channel
-            rdata = super(Channel, self)._notify_thread(message, msg_vals=msg_vals, **kwargs)
-
-            message_format_values = message.message_format()[0]
-            bus_notifications = self._channel_message_notifications(message, message_format_values)
-            self.env['bus.bus'].sudo().sendmany(bus_notifications)
-
-        else:
-            message._notify_pending_by_chat()
-            rdata = False
+        # link message to channel
+        rdata = super(Channel, self)._notify_thread(message, msg_vals=msg_vals, **kwargs)
 
+        message_format_values = message.message_format()[0]
+        bus_notifications = self._channel_message_notifications(message, message_format_values)
+        self.env['bus.bus'].sudo().sendmany(bus_notifications)
         return rdata
 
     def _message_receive_bounce(self, email, partner):
@@ -592,10 +489,6 @@ class Channel(models.Model):
 
     @api.returns('mail.message', lambda value: value.id)
     def message_post(self, *, message_type='notification', **kwargs):
-        moderation_status, email = self._extract_moderation_values(message_type, **kwargs)
-        if moderation_status == 'rejected':
-            return self.env['mail.message']
-
         self.filtered(lambda channel: channel.is_chat).mapped('channel_last_seen_partner_ids').sudo().write({'is_pinned': True})
 
         # mail_post_autofollow=False is necessary to prevent adding followers
@@ -605,21 +498,7 @@ class Channel(models.Model):
         # The current client code might be setting the key to True on sending
         # message but it is only useful when targeting customers in chatter.
         # This value should simply be set to False in channels no matter what.
-        message = super(Channel, self.with_context(mail_create_nosubscribe=True, mail_post_autofollow=False)).message_post(message_type=message_type, moderation_status=moderation_status, **kwargs)
-
-        # Notifies the message author when his message is pending moderation if required on channel.
-        # The fields "email_from" and "reply_to" are filled in automatically by method create in model mail.message.
-        if self.moderation_notify and self.moderation_notify_msg and message_type in ['email','comment'] and moderation_status == 'pending_moderation':
-            self.env['mail.mail'].sudo().create({
-                'author_id': self.env.user.partner_id.id,
-                'email_from': self.env.user.company_id.catchall_formatted or self.env.user.company_id.email_formatted,
-                'body_html': self.moderation_notify_msg,
-                'subject': 'Re: %s' % (kwargs.get('subject', '')),
-                'email_to': email,
-                'auto_delete': True,
-                'state': 'outgoing'
-            })
-        return message
+        return super(Channel, self.with_context(mail_create_nosubscribe=True, mail_post_autofollow=False)).message_post(message_type=message_type, **kwargs)
 
     def _message_post_after_hook(self, message, msg_vals):
         """
@@ -628,92 +507,11 @@ class Channel(models.Model):
         self._set_last_seen_message(message)
         return super()._message_post_after_hook(message=message, msg_vals=msg_vals)
 
-    def _extract_moderation_values(self, message_type, **kwargs):
-        """ This method is used to compute moderation status before the creation
-        of a message.  For this operation the message's author email address is required.
-        This address is returned with status for other computations. """
-        moderation_status = 'accepted'
-        email = ''
-        if self.moderation and message_type in ['email', 'comment']:
-            author_id = kwargs.get('author_id')
-            if author_id and isinstance(author_id, int):
-                email = self.env['res.partner'].browse([author_id]).email
-            elif author_id:
-                email = author_id.email
-            elif kwargs.get('email_from'):
-                email = tools.email_split(kwargs['email_from'])[0]
-            else:
-                email = self.env.user.email
-            if email in self.mapped('moderator_ids.email'):
-                return moderation_status, email
-            status = self.env['mail.moderation'].sudo().search([('email', '=', email), ('channel_id', 'in', self.ids)]).mapped('status')
-            if status and status[0] == 'allow':
-                moderation_status = 'accepted'
-            elif status and status[0] == 'ban':
-                moderation_status = 'rejected'
-            else:
-                moderation_status = 'pending_moderation'
-        return moderation_status, email
-
     def _message_subscribe(self, partner_ids=None, subtype_ids=None, customer_ids=None):
         """ Do not allow follower subscription on channels. Only members are
         considered. """
         raise UserError(_('Adding followers on channels is not possible. Consider adding members instead.'))
 
-    # ------------------------------------------------------------
-    # MODERATION
-    # ------------------------------------------------------------
-
-    def send_guidelines(self):
-        """ Send guidelines to all channel members. """
-        if self.env.user in self.moderator_ids or self.env.user.has_group('base.group_system'):
-            success = self._send_guidelines(self.channel_partner_ids)
-            if not success:
-                raise UserError(_('View "mail.mail_channel_send_guidelines" was not found. No email has been sent. Please contact an administrator to fix this issue.'))
-        else:
-            raise UserError(_("Only an administrator or a moderator can send guidelines to channel members!"))
-
-    def _send_guidelines(self, partners):
-        """ Send guidelines of a given channel. Returns False if template used for guidelines
-        not found. Caller may have to handle this return value. """
-        self.ensure_one()
-        view = self.env.ref('mail.mail_channel_send_guidelines', raise_if_not_found=False)
-        if not view:
-            _logger.warning('View "mail.mail_channel_send_guidelines" was not found.')
-            return False
-        banned_emails = self.env['mail.moderation'].sudo().search([
-            ('status', '=', 'ban'),
-            ('channel_id', 'in', self.ids)
-        ]).mapped('email')
-        for partner in partners.filtered(lambda p: p.email and not (p.email in banned_emails)):
-            company = partner.company_id or self.env.company
-            create_values = {
-                'email_from': company.catchall_formatted or company.email_formatted,
-                'author_id': self.env.user.partner_id.id,
-                'body_html': view._render({'channel': self, 'partner': partner}, engine='ir.qweb', minimal_qcontext=True),
-                'subject': _("Guidelines of channel %s", self.name),
-                'recipient_ids': [Command.link(partner.id)]
-            }
-            mail = self.env['mail.mail'].sudo().create(create_values)
-        return True
-
-    def _update_moderation_email(self, emails, status):
-        """ This method adds emails into either white or black of the channel list of emails
-            according to status. If an email in emails is already moderated, the method updates the email status.
-            :param emails: list of email addresses to put in white or black list of channel.
-            :param status: value is 'allow' or 'ban'. Emails are put in white list if 'allow', in black list if 'ban'.
-        """
-        self.ensure_one()
-        splitted_emails = [tools.email_split(email)[0] for email in emails if tools.email_split(email)]
-        moderated = self.env['mail.moderation'].sudo().search([
-            ('email', 'in', splitted_emails),
-            ('channel_id', 'in', self.ids)
-        ])
-        cmds = [Command.update(record.id, {'status': status}) for record in moderated]
-        not_moderated = [email for email in splitted_emails if email not in moderated.mapped('email')]
-        cmds += [Command.create({'email': email, 'status': status}) for email in not_moderated]
-        return self.write({'moderation_ids': cmds})
-
     # ------------------------------------------------------------
     # BROADCAST
     # ------------------------------------------------------------
@@ -813,8 +611,6 @@ class Channel(models.Model):
                 'channel_type': channel.channel_type,
                 'public': channel.public,
                 'mass_mailing': channel.email_send,
-                'moderation': channel.moderation,
-                'is_moderator': self.env.uid in channel.moderator_ids.ids,
                 'group_based_subscription': bool(channel.group_ids),
                 'create_uid': channel.create_uid.id,
             }
@@ -1126,9 +922,6 @@ class Channel(models.Model):
             notification = _('<div class="o_mail_notification">joined <a href="#" class="o_channel_redirect" data-oe-id="%s">#%s</a></div>', self.id, self.name)
             self.message_post(body=notification, message_type="notification", subtype_xmlid="mail.mt_comment")
 
-        if added and self.moderation_guidelines:
-            self._send_guidelines(self.env.user.partner_id)
-
         channel_info = self.channel_info('join')[0]
         self.env['bus.bus'].sendone((self._cr.dbname, 'res.partner', self.env.user.partner_id.id), channel_info)
         return channel_info

--- a/addons/mail/models/mail_message.py
+++ b/addons/mail/models/mail_message.py
@@ -162,13 +162,6 @@ class Message(models.Model):
     message_id = fields.Char('Message-Id', help='Message unique identifier', index=True, readonly=1, copy=False)
     reply_to = fields.Char('Reply-To', help='Reply email address. Setting the reply_to bypasses the automatic thread creation.')
     mail_server_id = fields.Many2one('ir.mail_server', 'Outgoing mail server')
-    # moderation
-    moderation_status = fields.Selection([
-        ('pending_moderation', 'Pending Moderation'),
-        ('accepted', 'Accepted'),
-        ('rejected', 'Rejected')], string="Moderation Status", index=True)
-    moderator_id = fields.Many2one('res.users', string="Moderated By", index=True)
-    need_moderation = fields.Boolean('Need moderation', compute='_compute_need_moderation', search='_search_need_moderation')
     # keep notification layout informations to be able to generate mail again
     email_layout_xmlid = fields.Char('Layout', copy=False)  # xml id of layout
     add_sign = fields.Boolean(default=True)
@@ -232,21 +225,6 @@ class Message(models.Model):
             return [('starred_partner_ids', 'in', [self.env.user.partner_id.id])]
         return [('starred_partner_ids', 'not in', [self.env.user.partner_id.id])]
 
-    def _compute_need_moderation(self):
-        for message in self:
-            message.need_moderation = False
-
-    @api.model
-    def _search_need_moderation(self, operator, operand):
-        if operator == '=' and operand is True:
-            return ['&', '&',
-                    ('moderation_status', '=', 'pending_moderation'),
-                    ('model', '=', 'mail.channel'),
-                    ('res_id', 'in', self.env.user.moderation_channel_ids.ids)]
-
-        # no support for other operators
-        raise UserError(_('Unsupported search filter on moderation status'))
-
     # ------------------------------------------------------
     # CRUD / ORM
     # ------------------------------------------------------
@@ -360,12 +338,10 @@ class Message(models.Model):
             - write: if
                 - author_id == pid, uid is the author, OR
                 - uid is in the recipients (partner_ids) OR
-                - uid is moderator of the channel and moderation_status is pending_moderation OR
-                - uid has write or create access on the related document if model, res_id and moderation_status is not pending_moderation
+                - uid has write or create access on the related document if model, res_id
                 - otherwise: raise
             - unlink: if
-                - uid is moderator of the channel and moderation_status is pending_moderation OR
-                - uid has write or create access on the related document if model, res_id and moderation_status is not pending_moderation
+                - uid has write or create access on the related document
                 - otherwise: raise
 
         Specific case: non employee users see only messages with subtype (aka do
@@ -402,16 +378,13 @@ class Message(models.Model):
         # Read mail_message.ids to have their values
         message_values = dict((message_id, {}) for message_id in self.ids)
 
-        self.flush(['model', 'res_id', 'author_id', 'parent_id', 'moderation_status', 'message_type', 'partner_ids'])
+        self.flush(['model', 'res_id', 'author_id', 'parent_id', 'message_type', 'partner_ids'])
         self.env['mail.notification'].flush(['mail_message_id', 'res_partner_id'])
-        self.env['mail.channel'].flush(['moderator_ids'])
-        self.env['res.users'].flush(['moderation_channel_ids'])
 
         if operation == 'read':
             self._cr.execute("""
                 SELECT DISTINCT m.id, m.model, m.res_id, m.author_id, m.parent_id,
                                 COALESCE(partner_rel.res_partner_id, needaction_rel.res_partner_id),
-                                m.moderation_status,
                                 m.message_type as message_type
                 FROM "%s" m
                 LEFT JOIN "mail_message_res_partner_rel" partner_rel
@@ -419,74 +392,47 @@ class Message(models.Model):
                 LEFT JOIN "mail_notification" needaction_rel
                 ON needaction_rel.mail_message_id = m.id AND needaction_rel.res_partner_id = %%(pid)s
                 WHERE m.id = ANY (%%(ids)s)""" % self._table, dict(pid=self.env.user.partner_id.id, ids=self.ids))
-            for mid, rmod, rid, author_id, parent_id, partner_id, moderation_status, message_type in self._cr.fetchall():
+            for mid, rmod, rid, author_id, parent_id, partner_id, message_type in self._cr.fetchall():
                 message_values[mid] = {
                     'model': rmod,
                     'res_id': rid,
                     'author_id': author_id,
                     'parent_id': parent_id,
-                    'moderation_status': moderation_status,
-                    'moderator_id': False,
                     'notified': any((message_values[mid].get('notified'), partner_id)),
                     'message_type': message_type,
                 }
         elif operation == 'write':
             self._cr.execute("""
-                SELECT DISTINCT m.id, m.model, m.res_id, m.author_id, m.parent_id, m.moderation_status,
+                SELECT DISTINCT m.id, m.model, m.res_id, m.author_id, m.parent_id,
                                 COALESCE(partner_rel.res_partner_id, needaction_rel.res_partner_id),
-                                channel_moderator_rel.res_users_id as moderator_id,
                                 m.message_type as message_type
                 FROM "%s" m
                 LEFT JOIN "mail_message_res_partner_rel" partner_rel
                 ON partner_rel.mail_message_id = m.id AND partner_rel.res_partner_id = %%(pid)s
                 LEFT JOIN "mail_notification" needaction_rel
                 ON needaction_rel.mail_message_id = m.id AND needaction_rel.res_partner_id = %%(pid)s
-                LEFT JOIN "mail_channel" moderated_channel
-                ON m.moderation_status = 'pending_moderation' AND m.res_id = moderated_channel.id
-                LEFT JOIN "mail_channel_moderator_rel" channel_moderator_rel
-                ON channel_moderator_rel.mail_channel_id = moderated_channel.id AND channel_moderator_rel.res_users_id = %%(uid)s
                 WHERE m.id = ANY (%%(ids)s)""" % self._table, dict(pid=self.env.user.partner_id.id, uid=self.env.user.id, ids=self.ids))
-            for mid, rmod, rid, author_id, parent_id, moderation_status, partner_id, moderator_id, message_type in self._cr.fetchall():
+            for mid, rmod, rid, author_id, parent_id, partner_id, message_type in self._cr.fetchall():
                 message_values[mid] = {
                     'model': rmod,
                     'res_id': rid,
                     'author_id': author_id,
                     'parent_id': parent_id,
-                    'moderation_status': moderation_status,
-                    'moderator_id': moderator_id,
                     'notified': any((message_values[mid].get('notified'), partner_id)),
                     'message_type': message_type,
                 }
-        elif operation == 'create':
-            self._cr.execute("""SELECT DISTINCT id, model, res_id, author_id, parent_id, moderation_status, message_type FROM "%s" WHERE id = ANY (%%s)""" % self._table, (self.ids,))
-            for mid, rmod, rid, author_id, parent_id, moderation_status, message_type in self._cr.fetchall():
-                message_values[mid] = {
-                    'model': rmod,
-                    'res_id': rid,
-                    'author_id': author_id,
-                    'parent_id': parent_id,
-                    'moderation_status': moderation_status,
-                    'moderator_id': False,
-                    'message_type': message_type,
-                }
-        else:  # unlink
-            self._cr.execute("""SELECT DISTINCT m.id, m.model, m.res_id, m.author_id, m.parent_id, m.moderation_status, channel_moderator_rel.res_users_id as moderator_id, m.message_type as message_type
-                FROM "%s" m
-                LEFT JOIN "mail_channel" moderated_channel
-                ON m.moderation_status = 'pending_moderation' AND m.res_id = moderated_channel.id
-                LEFT JOIN "mail_channel_moderator_rel" channel_moderator_rel
-                ON channel_moderator_rel.mail_channel_id = moderated_channel.id AND channel_moderator_rel.res_users_id = (%%s)
-                WHERE m.id = ANY (%%s)""" % self._table, (self.env.user.id, self.ids,))
-            for mid, rmod, rid, author_id, parent_id, moderation_status, moderator_id, message_type in self._cr.fetchall():
+        elif operation in ('create', 'unlink'):
+            self._cr.execute("""SELECT DISTINCT id, model, res_id, author_id, parent_id, message_type FROM "%s" WHERE id = ANY (%%s)""" % self._table, (self.ids,))
+            for mid, rmod, rid, author_id, parent_id, message_type in self._cr.fetchall():
                 message_values[mid] = {
                     'model': rmod,
                     'res_id': rid,
                     'author_id': author_id,
                     'parent_id': parent_id,
-                    'moderation_status': moderation_status,
-                    'moderator_id': moderator_id,
                     'message_type': message_type,
                 }
+        else:
+            raise ValueError(_('Wrong operation name (%s)', operation))
 
         # Author condition (READ, WRITE, CREATE (private))
         author_ids = []
@@ -494,18 +440,13 @@ class Message(models.Model):
             author_ids = [mid for mid, message in message_values.items()
                           if message.get('author_id') and message.get('author_id') == self.env.user.partner_id.id]
         elif operation == 'write':
-            author_ids = [mid for mid, message in message_values.items()
-                          if message.get('moderation_status') != 'pending_moderation' and message.get('author_id') == self.env.user.partner_id.id]
+            author_ids = [mid for mid, message in message_values.items() if message.get('author_id') == self.env.user.partner_id.id]
         elif operation == 'create':
             author_ids = [mid for mid, message in message_values.items()
                           if not self.is_thread_message(message)]
 
-        # Moderator condition: allow to WRITE, UNLINK if moderator of a pending message
-        moderator_ids = []
-        if operation in ['write', 'unlink']:
-            moderator_ids = [mid for mid, message in message_values.items() if message.get('moderator_id')]
         messages_to_check = self.ids
-        messages_to_check = set(messages_to_check).difference(set(author_ids), set(moderator_ids))
+        messages_to_check = set(messages_to_check).difference(set(author_ids))
         if not messages_to_check:
             return
 
@@ -522,10 +463,11 @@ class Message(models.Model):
 
         # CRUD: Access rights related to the document
         document_related_ids = []
-        document_related_candidate_ids = [mid for mid, message in message_values.items()
-                if (message.get('model') and message.get('res_id') and
-                    message.get('message_type') != 'user_notification' and
-                    (message.get('moderation_status') != 'pending_moderation' or operation not in ['write', 'unlink']))]
+        document_related_candidate_ids = [
+            mid for mid, message in message_values.items()
+            if (message.get('model') and message.get('res_id') and
+                message.get('message_type') != 'user_notification')
+        ]
         model_record_ids = _generate_model_record_ids(message_values, document_related_candidate_ids)
         for model, doc_ids in model_record_ids.items():
             DocumentModel = self.env[model]
@@ -538,11 +480,12 @@ class Message(models.Model):
             mids = records.browse(doc_ids)._filter_access_rules(check_operation)
             document_related_ids += [
                 mid for mid, message in message_values.items()
-                if (message.get('model') == model and
+                if (
+                    message.get('model') == model and
                     message.get('res_id') in mids.ids and
-                    message.get('message_type') != 'user_notification' and
-                    (message.get('moderation_status') != 'pending_moderation' or
-                    operation not in ['write', 'unlink']))]
+                    message.get('message_type') != 'user_notification'
+                )
+            ]
 
         messages_to_check = messages_to_check.difference(set(document_related_ids))
 
@@ -794,163 +737,6 @@ class Message(models.Model):
         notification = {'type': 'toggle_star', 'message_ids': [self.id], 'starred': starred}
         self.env['bus.bus'].sendone((self._cr.dbname, 'res.partner', self.env.user.partner_id.id), notification)
 
-    # --------------------------------------------------
-    # MODERATION API
-    # --------------------------------------------------
-
-    def moderate(self, decision, **kwargs):
-        """ Moderate messages. A check is done on moderation status of the
-        current user to ensure we only moderate valid messages. """
-        moderated_channels = self.env.user.moderation_channel_ids
-        to_moderate = [message.id for message in self
-                       if message.model == 'mail.channel' and
-                       message.res_id in moderated_channels.ids and
-                       message.moderation_status == 'pending_moderation']
-        if to_moderate:
-            self.browse(to_moderate)._moderate(decision, **kwargs)
-
-    def _moderate(self, decision, **kwargs):
-        """ :param decision
-                 * accept       - moderate message and broadcast that message to followers of relevant channels.
-                 * reject       - message will be deleted from the database without broadcast
-                                  an email sent to the author with an explanation that the moderators can edit.
-                 * discard      - message will be deleted from the database without broadcast.
-                 * allow        - add email address to white list people of specific channel,
-                                  so that next time if a message come from same email address on same channel,
-                                  it will be automatically broadcasted to relevant channels without any approval from moderator.
-                 * ban          - add email address to black list of emails for the specific channel.
-                                  From next time, a person sending a message using that email address will not need moderation.
-                                  message_post will not create messages with the corresponding expeditor.
-        """
-        if decision == 'accept':
-            self._moderate_accept()
-        elif decision == 'reject':
-            self._moderate_send_reject_email(kwargs.get('title'), kwargs.get('comment'))
-            self._moderate_discard()
-        elif decision == 'discard':
-            self._moderate_discard()
-        elif decision == 'allow':
-            channels = self.env['mail.channel'].browse(self.mapped('res_id'))
-            for channel in channels:
-                channel._update_moderation_email(
-                    list({message.email_from for message in self if message.res_id == channel.id}),
-                    'allow'
-                )
-            self._search_from_same_authors()._moderate_accept()
-        elif decision == 'ban':
-            channels = self.env['mail.channel'].browse(self.mapped('res_id'))
-            for channel in channels:
-                channel._update_moderation_email(
-                    list({message.email_from for message in self if message.res_id == channel.id}),
-                    'ban'
-                )
-            self._search_from_same_authors()._moderate_discard()
-
-    def _moderate_accept(self):
-        self.write({
-            'moderation_status': 'accepted',
-            'moderator_id': self.env.uid
-        })
-        # proceed with notification process to send notification emails and Inbox messages
-        for message in self:
-            if message.is_thread_message(): # note, since we will only intercept _notify_thread for message posted on channel,
-                # message will always be a thread_message. This check should always be true.
-                self.env[message.model].browse(message.res_id)._notify_thread(message)
-
-    def _moderate_send_reject_email(self, subject, comment):
-        for msg in self:
-            if not msg.email_from:
-                continue
-            body_html = tools.append_content_to_html('<div>%s</div>' % tools.ustr(comment), msg.body, plaintext=False)
-            vals = {
-                'subject': subject,
-                'body_html': body_html,
-                'author_id': self.env.user.partner_id.id,
-                'email_from': self.env.user.email_formatted or self.env.company.catchall_formatted,
-                'email_to': msg.email_from,
-                'auto_delete': True,
-                'state': 'outgoing'
-            }
-            self.env['mail.mail'].sudo().create(vals)
-
-    def _search_from_same_authors(self):
-        """ Returns all pending moderation messages that have same email_from and
-        same res_id as given recordset. """
-        messages = self.env['mail.message'].sudo()
-        for message in self:
-            messages |= messages.search([
-                ('moderation_status', '=', 'pending_moderation'),
-                ('email_from', '=', message.email_from),
-                ('model', '=', 'mail.channel'),
-                ('res_id', '=', message.res_id)
-            ])
-        return messages
-
-    def _moderate_discard(self):
-        """ Notify deletion of messages to their moderators and authors and then delete them.
-        """
-        channel_ids = self.mapped('res_id')
-        moderators = self.env['mail.channel'].browse(channel_ids).mapped('moderator_ids')
-        authors = self.mapped('author_id')
-        partner_to_pid = {}
-        for moderator in moderators:
-            partner_to_pid.setdefault(moderator.partner_id.id, set())
-            partner_to_pid[moderator.partner_id.id] |= set([message.id for message in self if message.res_id in moderator.moderation_channel_ids.ids])
-        for author in authors:
-            partner_to_pid.setdefault(author.id, set())
-            partner_to_pid[author.id] |= set([message.id for message in self if message.author_id == author])
-
-        notifications = []
-        for partner_id, message_ids in partner_to_pid.items():
-            notifications.append([
-                (self._cr.dbname, 'res.partner', partner_id),
-                {'type': 'deletion', 'message_ids': sorted(list(message_ids))}  # sorted to make deterministic for tests
-            ])
-        self.env['bus.bus'].sendmany(notifications)
-        self.unlink()
-
-    def _notify_pending_by_chat(self):
-        """ Generate the bus notifications for the given message and send them
-        to the appropriate moderators and the author (if the author has not been
-        elected moderator meanwhile). The author notification can be considered
-        as a feedback to the author.
-        """
-        self.ensure_one()
-        message = self.message_format()[0]
-        partners = self.env['mail.channel'].browse(self.res_id).mapped('moderator_ids.partner_id')
-        notifications = []
-        for partner in partners:
-            notifications.append([
-                (self._cr.dbname, 'res.partner', partner.id),
-                {'type': 'moderator', 'message': message}
-            ])
-        if self.author_id not in partners:
-            notifications.append([
-                (self._cr.dbname, 'res.partner', self.author_id.id),
-                {'type': 'author', 'message': message}
-            ])
-        self.env['bus.bus'].sendmany(notifications)
-
-    @api.model
-    def _notify_moderators(self):
-        """ Push a notification (Inbox/email) to moderators having messages
-        waiting for moderation. This method is called once a day by a cron.
-        """
-        channels = self.env['mail.channel'].browse(self.search([('moderation_status', '=', 'pending_moderation')]).mapped('res_id'))
-        moderators_to_notify = channels.mapped('moderator_ids')
-        template = self.env.ref('mail.mail_channel_notify_moderation', raise_if_not_found=False)
-        if not template:
-            _logger.warning('Template "mail.mail_channel_notify_moderation" was not found. Cannot send reminder notifications.')
-            return
-        MailThread = self.env['mail.thread'].with_context(mail_notify_author=True)
-        for moderator in moderators_to_notify:
-            MailThread.message_notify(
-                partner_ids=moderator.partner_id.ids,
-                subject=_('Message are pending moderation'),  # tocheck: target language
-                body=template._render({'record': moderator.partner_id}, engine='ir.qweb', minimal_qcontext=True),
-                email_from=moderator.company_id.catchall_formatted or moderator.company_id.email_formatted,
-            )
-
     # ------------------------------------------------------
     # MESSAGE READ / FETCH / FAILURE API
     # ------------------------------------------------------
@@ -1027,32 +813,13 @@ class Message(models.Model):
         return messages._message_notification_format()
 
     @api.model
-    def message_fetch(self, domain, limit=20, moderated_channel_ids=None):
+    def message_fetch(self, domain, limit=20):
         """ Get a limited amount of formatted messages with provided domain.
             :param domain: the domain to filter messages;
             :param limit: the maximum amount of messages to get;
-            :param list(int) moderated_channel_ids: if set, it contains the ID
-              of a moderated channel. Fetched messages should include pending
-              moderation messages for moderators. If the current user is not
-              moderator, it should still get self-authored messages that are
-              pending moderation;
             :returns list(dict).
         """
-        messages = self.search(domain, limit=limit)
-        if moderated_channel_ids:
-            # Split load moderated and regular messages, as the ORed domain can
-            # cause performance issues on large databases.
-            moderated_messages_dom = [
-                ('model', '=', 'mail.channel'),
-                ('res_id', 'in', moderated_channel_ids),
-                '|',
-                ('author_id', '=', self.env.user.partner_id.id),
-                ('moderation_status', '=', 'pending_moderation'),
-            ]
-            messages |= self.search(moderated_messages_dom, limit=limit)
-            # Truncate the results to `limit`
-            messages = messages.sorted(key='id', reverse=True)[:limit]
-        return messages.message_format()
+        return self.search(domain, limit=limit).message_format()
 
     def message_format(self):
         """ Get the message values in the format for web client. Since message values can be broadcasted,
@@ -1092,7 +859,6 @@ class Message(models.Model):
                     'is_note': True # only if the message is a note (subtype == note)
                     'is_discussion': False # only if the message is a discussion (subtype == discussion)
                     'is_notification': False # only if the message is a note but is a notification aka not linked to a document like assignation
-                    'moderation_status': 'pending_moderation'
                 }
         """
         vals_list = self._message_format(self._get_message_format_fields())
@@ -1122,7 +888,6 @@ class Message(models.Model):
             'model', 'res_id', 'record_name',  # document related
             'partner_ids',  # recipients
             'starred_partner_ids',  # list of partner ids for whom the message is starred
-            'moderation_status',
         ]
 
     def _message_notification_format(self):

--- a/addons/mail/models/mail_moderation.py
+++ b/None
@@ -1,20 +0,0 @@
-# -*- coding: utf-8 -*-
-# Part of Odoo. See LICENSE file for full copyright and licensing details.
-
-from odoo import fields, models
-
-
-class Moderation(models.Model):
-    _name = 'mail.moderation'
-    _description = 'Channel black/white list'
-
-    email = fields.Char(string="Email", index=True, required=True)
-    status = fields.Selection([
-        ('allow', 'Always Allow'),
-        ('ban', 'Permanent Ban')],
-        string="Status", required=True)
-    channel_id = fields.Many2one('mail.channel', string="Channel", index=True, required=True)
-
-    _sql_constraints = [
-        ('channel_email_uniq', 'unique (email,channel_id)', 'The email address must be unique per channel !')
-    ]

--- a/addons/mail/models/mail_thread.py
+++ b/addons/mail/models/mail_thread.py
@@ -2106,9 +2106,6 @@ class MailThread(models.AbstractModel):
          * performs the notification process by calling the various notification
            methods implemented;
 
-        This method cnn be overridden to intercept and postpone notification
-        mechanism like mail.channel moderation.
-
         :param message: mail.message record to notify;
         :param msg_vals: dictionary of values used to create the message. If given
           it is used instead of accessing ``self`` to lessen query count in some

--- a/addons/mail/models/res_users.py
+++ b/addons/mail/models/res_users.py
@@ -25,37 +25,6 @@ class Users(models.Model):
         help="Policy on how to handle Chatter notifications:\n"
              "- Handle by Emails: notifications are sent to your email address\n"
              "- Handle in Odoo: notifications appear in your Odoo Inbox")
-    # channel-specific: moderation
-    is_moderator = fields.Boolean(string='Is moderator', compute='_compute_is_moderator')
-    moderation_counter = fields.Integer(string='Moderation count', compute='_compute_moderation_counter')
-    moderation_channel_ids = fields.Many2many(
-        'mail.channel', 'mail_channel_moderator_rel',
-        string='Moderated channels')
-
-    @api.depends('moderation_channel_ids.moderation', 'moderation_channel_ids.moderator_ids')
-    def _compute_is_moderator(self):
-        moderated = self.env['mail.channel'].search([
-            ('id', 'in', self.mapped('moderation_channel_ids').ids),
-            ('moderation', '=', True),
-            ('moderator_ids', 'in', self.ids)
-        ])
-        user_ids = moderated.mapped('moderator_ids')
-        for user in self:
-            user.is_moderator = user in user_ids
-
-    def _compute_moderation_counter(self):
-        self._cr.execute("""
-SELECT channel_moderator.res_users_id, COUNT(msg.id)
-FROM "mail_channel_moderator_rel" AS channel_moderator
-JOIN "mail_message" AS msg
-ON channel_moderator.mail_channel_id = msg.res_id
-    AND channel_moderator.res_users_id IN %s
-    AND msg.model = 'mail.channel'
-    AND msg.moderation_status = 'pending_moderation'
-GROUP BY channel_moderator.res_users_id""", [tuple(self.ids)])
-        result = dict(self._cr.fetchall())
-        for user in self:
-            user.moderation_counter = result.get(user.id, 0)
 
     @property
     def SELF_READABLE_FIELDS(self):
