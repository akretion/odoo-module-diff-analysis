PR: https://github.com/odoo/odoo/pull/

From: 63e72649da67e544e807f7e454c3dc754c0b297a
From: qdp-odoo
Date: 2015-10-21 14:55:40

Structural Changes: 2
Total Changes: 43

Merge branch '9.0' into master up to revision 57d0903154c56201a4d59a3e7176f55dc46dc1ae

================================= pseudo patch: =================================

--- a/addons/mail/models/mail_channel.py
+++ b/addons/mail/models/mail_channel.py
@@ -481,8 +481,13 @@ class Channel(models.Model):
     @api.multi
     def channel_join_and_get_info(self):
         self.ensure_one()
+        notification = {"type": "user_join", "payload": {"channel_id": self.id, "name": self.env.user.partner_id.name}}
+        self.env['bus.bus'].sendmany([[(self._cr.dbname, 'mail.channel', self.id), notification]])
         self.action_follow()
-        return self.channel_info()[0]
+
+        channel_info = self.channel_info()[0]
+        self.env['bus.bus'].sendone((self._cr.dbname, 'res.partner', self.env.user.partner_id.id), channel_info)
+        return channel_info
 
     @api.model
     def channel_create(self, name, privacy='public'):
@@ -499,4 +504,6 @@ class Channel(models.Model):
             'email_send': False,
             'channel_partner_ids': [(4, self.env.user.partner_id.id)]
         })
-        return new_channel.channel_info()[0]
+        channel_info = new_channel.channel_info()[0]
+        self.env['bus.bus'].sendone((self._cr.dbname, 'res.partner', self.env.user.partner_id.id), channel_info)
+        return channel_info

--- a/addons/mail/models/mail_message.py
+++ b/addons/mail/models/mail_message.py
@@ -150,12 +150,18 @@ class Message(models.Model):
     def set_message_needaction(self, partner_ids=None):
         if not partner_ids:
             partner_ids = [self.env.user.partner_id.id]
+        if set(partner_ids) == set([self.env.user.partner_id.id]):
+            # a user should be able to mark a message as needaction for him
+            self = self.sudo()
         return self.write({'needaction_partner_ids': [(4, pid) for pid in partner_ids]})
 
     @api.multi
     def set_message_done(self, partner_ids=None):
         if not partner_ids:
             partner_ids = [self.env.user.partner_id.id]
+        if set(partner_ids) == set([self.env.user.partner_id.id]):
+            # a user should be able to mark a message as done for him
+            self = self.sudo()
         return self.write({'needaction_partner_ids': [(3, pid) for pid in partner_ids]})
 
     @api.multi
@@ -167,10 +173,12 @@ class Message(models.Model):
             :param bool create_missing: create notifications for missing entries
                 (i.e. when acting on displayed messages not notified)
         """
+        # a user should always be able to star a message he can read
+        self.check_access_rule('read')
         if starred:
-            self.write({'starred_partner_ids': [(4, self.env.user.partner_id.id)]})
+            self.sudo().write({'starred_partner_ids': [(4, self.env.user.partner_id.id)]})
         else:
-            self.write({'starred_partner_ids': [(3, self.env.user.partner_id.id)]})
+            self.sudo().write({'starred_partner_ids': [(3, self.env.user.partner_id.id)]})
         return starred
 
     #------------------------------------------------------

--- a/addons/mail/models/mail_thread.py
+++ b/addons/mail/models/mail_thread.py
@@ -63,7 +63,8 @@ class MailThread(models.AbstractModel):
     _mail_post_access = 'write'  # access required on the document to post on it
     _mail_mass_mailing = False  # enable mass mailing on this model
 
-    message_is_follower = fields.Boolean('Is Follower', compute='_compute_is_follower')
+    message_is_follower = fields.Boolean(
+        'Is Follower', compute='_compute_is_follower', search='_search_is_follower')
     message_follower_ids = fields.One2many(
         'mail.followers', 'res_id', string='Followers',
         domain=lambda self: [('res_model', '=', self._name)])
@@ -135,6 +136,18 @@ class MailThread(models.AbstractModel):
         for record in self:
             record.message_is_follower = record.id in following_ids
 
+    @api.model
+    def _search_is_follower(self, operator, operand):
+        followers = self.env['mail.followers'].sudo().search([
+            ('res_model', '=', self._name),
+            ('partner_id', '=', self.env.user.partner_id.id),
+            ])
+        # Cases ('message_is_follower', '=', True) or  ('message_is_follower', '!=', False)
+        if (operator == '=' and operand) or (operator == '!=' and not operand):
+            return [('id', 'in', followers.mapped('res_id'))]
+        else:
+            return [('id', 'not in', followers.mapped('res_id'))]
+
     @api.multi
     def _get_message_unread(self):
         res = dict((res_id, 0) for res_id in self.ids)
@@ -1654,7 +1667,10 @@ class MailThread(models.AbstractModel):
         new_message = MailMessage.create(values)
 
         # Post-process: subscribe author, update message_last_post
-        if model and model != 'mail.thread' and self.ids and subtype_id:
+        # Note: the message_last_post mechanism is no longer used.  This
+        # will be removed in a later version.
+        if (self._context.get('mail_save_message_last_post') and
+                model and model != 'mail.thread' and self.ids and subtype_id):
             subtype_rec = self.env['mail.message.subtype'].sudo().browse(subtype_id)
             if not subtype_rec.internal:
                 # done with SUPERUSER_ID, because on some models users can post only with read access, not necessarily write access
