PR: https://github.com/odoo/odoo/pull/

From: dfde326e7532e8ddbe34a3ddf698f6a556e3cfa5
From: Laurent Smet
Date: 2018-05-30 16:28:13

Structural Changes: 5
Total Changes: 133

[IMP] account: add account.fiscalyear model

In order to improve the fiscal year management, we allow the user to define custom fiscal years
    using the account.fiscalyear model.

Was task: https://www.odoo.com/web#id=39878&view_type=form&model=project.task&menu_id=
Was PR #20936

================================= pseudo patch: =================================

--- a/addons/account/models/__init__.py
+++ b/addons/account/models/__init__.py
@@ -10,6 +10,7 @@ from . import chart_template
 from . import account_analytic_line
 from . import account_journal_dashboard
 from . import product
+from . import account_fiscal_year
 from . import company
 from . import res_config_settings
 from . import account_cash_rounding

--- a/None
+++ b/addons/account/models/account_fiscal_year.py
@@ -0,0 +1,56 @@
+# -*- coding: utf-8 -*-
+
+from odoo.exceptions import ValidationError
+from odoo import api, fields, models, _
+from odoo.tools import DEFAULT_SERVER_DATE_FORMAT
+
+
+from datetime import datetime
+
+
+class AccountFiscalYear(models.Model):
+    _name = 'account.fiscal.year'
+    _description = 'Fiscal Year'
+
+    name = fields.Char(string='Name', required=True)
+    date_from = fields.Date(string='Start Date', required=True,
+        help='Start Date, included in the fiscal year.')
+    date_to = fields.Date(string='End Date', required=True,
+        help='Ending Date, included in the fiscal year.')
+    company_id = fields.Many2one('res.company', string='Company', required=True,
+        default=lambda self: self.env.user.company_id)
+
+    @api.constrains('date_from', 'date_to', 'company_id')
+    def _check_dates(self):
+        '''
+        Check interleaving between fiscal years.
+        There are 3 cases to consider:
+
+        s1   s2   e1   e2
+        (    [----)----]
+
+        s2   s1   e2   e1
+        [----(----]    )
+
+        s1   s2   e2   e1
+        (    [----]    )
+        '''
+        for fy in self:
+            # Starting date must be prior to the ending date
+            date_from = datetime.strptime(fy.date_from, DEFAULT_SERVER_DATE_FORMAT)
+            date_to = datetime.strptime(fy.date_to, DEFAULT_SERVER_DATE_FORMAT)
+            if date_to < date_from:
+                raise ValidationError(_('The ending date must not be prior to the starting date.'))
+
+
+            domain = [
+                ('id', '!=', fy.id),
+                ('company_id', '=', fy.company_id.id),
+                '|', '|',
+                '&', ('date_from', '<=', fy.date_from), ('date_to', '>=', fy.date_from),
+                '&', ('date_from', '<=', fy.date_to), ('date_to', '>=', fy.date_to),
+                '&', ('date_from', '<=', fy.date_from), ('date_to', '>=', fy.date_to),
+            ]
+
+            if self.search_count(domain) > 0:
+                raise ValidationError(_('You can not have an overlap between two fiscal years, please correct the start and/or end dates of your fiscal years.'))

--- a/addons/account/models/company.py
+++ b/addons/account/models/company.py
@@ -7,6 +7,7 @@ from odoo import fields, models, api, _
 from odoo.exceptions import ValidationError, UserError
 from odoo.exceptions import UserError
 from odoo.tools.float_utils import float_round, float_is_zero
+from odoo.tools import DEFAULT_SERVER_DATE_FORMAT, date_utils
 
 
 class ResCompany(models.Model):
@@ -74,27 +75,59 @@ Best Regards,'''))
         return last_day > last_day_of_month and last_day_of_month or last_day
 
     @api.multi
-    def compute_fiscalyear_dates(self, date):
-        """ Computes the start and end dates of the fiscalyear where the given 'date' belongs to
-            @param date: a datetime object
-            @returns: a dictionary with date_from and date_to
-        """
-        self = self[0]
-        last_month = self.fiscalyear_last_month
-        last_day = self.fiscalyear_last_day
-        if (date.month < last_month or (date.month == last_month and date.day <= last_day)):
-            date = date.replace(month=last_month, day=last_day)
-        else:
-            if last_month == 2 and last_day == 29 and (date.year + 1) % 4 != 0:
-                date = date.replace(month=last_month, day=28, year=date.year + 1)
-            else:
-                date = date.replace(month=last_month, day=last_day, year=date.year + 1)
-        date_to = date
-        date_from = date + timedelta(days=1)
-        if date_from.month == 2 and date_from.day == 29:
-            date_from = date_from.replace(day=28, year=date_from.year - 1)
-        else:
-            date_from = date_from.replace(year=date_from.year - 1)
+    def compute_fiscalyear_dates(self, current_date):
+        '''Computes the start and end dates of the fiscal year where the given 'date' belongs to.
+
+        :param current_date: A datetime.date/datetime.datetime object.
+        :return: A dictionary containing:
+            * date_from
+            * date_to
+            * [Optionally] record: The fiscal year record.
+        '''
+        self.ensure_one()
+        date_str = current_date.strftime(DEFAULT_SERVER_DATE_FORMAT)
+
+        # Search a fiscal year record containing the date.
+        # If a record is found, then no need further computation, we get the dates range directly.
+        fiscalyear = self.env['account.fiscal.year'].search([
+            ('company_id', '=', self.id),
+            ('date_from', '<=', date_str),
+            ('date_to', '>=', date_str),
+        ], limit=1)
+        if fiscalyear:
+            return {
+                'date_from': datetime.strptime(fiscalyear.date_from, DEFAULT_SERVER_DATE_FORMAT).date(),
+                'date_to': datetime.strptime(fiscalyear.date_to, DEFAULT_SERVER_DATE_FORMAT).date(),
+                'record': fiscalyear,
+            }
+
+        date_from, date_to = date_utils.get_fiscal_year(
+            current_date, day=self.fiscalyear_last_day, month=self.fiscalyear_last_month)
+
+        date_from_str = date_from.strftime(DEFAULT_SERVER_DATE_FORMAT)
+        date_to_str = date_to.strftime(DEFAULT_SERVER_DATE_FORMAT)
+
+        # Search for fiscal year records reducing the delta between the date_from/date_to.
+        # This case could happen if there is a gap between two fiscal year records.
+        # E.g. two fiscal year records: 2017-01-01 -> 2017-02-01 and 2017-03-01 -> 2017-12-31.
+        # => The period 2017-02-02 - 2017-02-30 is not covered by a fiscal year record.
+
+        fiscalyear_from = self.env['account.fiscal.year'].search([
+            ('company_id', '=', self.id),
+            ('date_from', '<=', date_from_str),
+            ('date_to', '>=', date_from_str),
+        ], limit=1)
+        if fiscalyear_from:
+            date_from = datetime.strptime(fiscalyear_from.date_to, DEFAULT_SERVER_DATE_FORMAT).date() + timedelta(days=1)
+
+        fiscalyear_to = self.env['account.fiscal.year'].search([
+            ('company_id', '=', self.id),
+            ('date_from', '<=', date_to_str),
+            ('date_to', '>=', date_to_str),
+        ], limit=1)
+        if fiscalyear_to:
+            date_to = datetime.strptime(fiscalyear_to.date_from, DEFAULT_SERVER_DATE_FORMAT).date() - timedelta(days=1)
+
         return {'date_from': date_from, 'date_to': date_to}
 
     def get_new_account_code(self, current_code, old_prefix, new_prefix):

--- a/addons/account/models/res_config_settings.py
+++ b/addons/account/models/res_config_settings.py
@@ -31,6 +31,7 @@ class ResConfigSettings(models.TransientModel):
     group_analytic_tags = fields.Boolean(string='Analytic Tags', implied_group='analytic.group_analytic_tags')
     group_warning_account = fields.Boolean(string="Warnings in Invoices", implied_group='account.group_warning_account')
     group_cash_rounding = fields.Boolean(string="Cash Rounding", implied_group='account.group_cash_rounding')
+    group_fiscal_year = fields.Boolean(string='Fiscal Years', implied_group='account.group_fiscal_year')
     module_account_asset = fields.Boolean(string='Assets Management')
     module_account_deferred_revenue = fields.Boolean(string="Revenue Recognition")
     module_account_budget = fields.Boolean(string='Budget Management')
