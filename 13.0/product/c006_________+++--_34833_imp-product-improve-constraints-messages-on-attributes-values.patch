PR: https://github.com/odoo/odoo/pull/34833

From: 054baf94a68ab1d080316469756bfba1e6a35777
From: Sébastien Theys
Date: 2019-08-09 12:49:31

Structural Changes: 15
Total Changes: 145

[IMP] product: improve constraints & messages on attributes & values

Usability improvements:

- Prevent the user from doing actions that will lead to exceptions.
- Improve error messages when exceptions do happen.

Also add more constraints to keep the database in a consistent state.

task-2035609

closes odoo/odoo#34833

Signed-off-by: Jérémy Kersten (jke) <jke@openerp.com>

================================= pseudo patch: =================================

--- a/addons/product/models/product_attribute.py
+++ b/addons/product/models/product_attribute.py
@@ -18,12 +18,28 @@ class ProductAttribute(models.Model):
     sequence = fields.Integer('Sequence', help="Determine the display order", index=True)
     attribute_line_ids = fields.One2many('product.template.attribute.line', 'attribute_id', 'Lines')
     create_variant = fields.Selection([
-        ('no_variant', 'Never'),
-        ('always', 'Always'),
-        ('dynamic', 'Only when the product is added to a sales order')],
+        ('always', 'Instantly'),
+        ('dynamic', 'Dynamically'),
+        ('no_variant', 'Never')],
         default='always',
-        string="Create Variants",
-        help="Check this if you want to create multiple variants for this attribute.", required=True)
+        string="Variants Creation Mode",
+        help="""- Instantly: All possible variants are created as soon as the attribute and its values are added to a product.
+        - Dynamically: Each variant is created only when its corresponding attributes and values are added to a sales order.
+        - Never: Variants are never created for the attribute.
+        Note: the variants creation mode cannot be changed once the attribute is used on at least one product.""",
+        required=True)
+    is_used_on_products = fields.Boolean('Used on Products', compute='_compute_is_used_on_products')
+    product_tmpl_ids = fields.Many2many('product.template', string="Related Products", compute='_compute_products', store=True)
+
+    @api.depends('product_tmpl_ids')
+    def _compute_is_used_on_products(self):
+        for pa in self:
+            pa.is_used_on_products = bool(pa.product_tmpl_ids)
+
+    @api.depends('attribute_line_ids.product_tmpl_id')
+    def _compute_products(self):
+        for pa in self:
+            pa.product_tmpl_ids = pa.attribute_line_ids.product_tmpl_id
 
     def _without_no_variant_attributes(self):
         return self.filtered(lambda pa: pa.create_variant != 'no_variant')
@@ -37,10 +53,12 @@ class ProductAttribute(models.Model):
         them might take too long and we don't want to change products without
         the user knowing about it."""
         if 'create_variant' in vals:
-            products = self._get_related_product_templates()
-            if products:
-                message = ', '.join(products.mapped('name'))
-                raise UserError(_('You are trying to change the type of an attribute value still referenced on at least one product template: %s') % message)
+            for pa in self:
+                if vals['create_variant'] != pa.create_variant and pa.is_used_on_products:
+                    raise UserError(
+                        _("You cannot change the Variants Creation Mode of the attribute <strong>%s</strong> because it is used on the following products:\n%s") %
+                        (pa.display_name, ", ".join(pa.product_tmpl_ids.mapped('display_name')))
+                    )
         invalidate_cache = 'sequence' in vals and any(record.sequence != vals['sequence'] for record in self)
         res = super(ProductAttribute, self).write(vals)
         if invalidate_cache:
@@ -49,10 +67,14 @@ class ProductAttribute(models.Model):
             self.invalidate_cache()
         return res
 
-    def _get_related_product_templates(self):
-        return self.env['product.template'].with_context(active_test=False).search([
-            ('attribute_line_ids.attribute_id', 'in', self.ids),
-        ])
+    def unlink(self):
+        for pa in self:
+            if pa.is_used_on_products:
+                raise UserError(
+                    _("You cannot delete the attribute <strong>%s</strong> because it is used on the following products:\n%s") %
+                    (pa.display_name, ", ".join(pa.product_tmpl_ids.mapped('display_name')))
+                )
+        return super(ProductAttribute, self).unlink()
 
 
 class ProductAttributeValue(models.Model):
@@ -64,12 +86,22 @@ class ProductAttributeValue(models.Model):
 
     name = fields.Char(string='Value', required=True, translate=True)
     sequence = fields.Integer(string='Sequence', help="Determine the display order", index=True)
-    attribute_id = fields.Many2one('product.attribute', string='Attribute', ondelete='cascade', required=True, index=True)
+    attribute_id = fields.Many2one('product.attribute', string="Attribute", ondelete='cascade', required=True, index=True,
+        help="The attribute cannot be changed once the value is used on at least one product.")
+
+    pav_attribute_line_ids = fields.Many2many('product.template.attribute.line', string="Lines",
+        relation='product_attribute_value_product_template_attribute_line_rel')
+    is_used_on_products = fields.Boolean('Used on Products', compute='_compute_is_used_on_products')
 
     _sql_constraints = [
-        ('value_company_uniq', 'unique (name, attribute_id)', 'This attribute value already exists !')
+        ('value_company_uniq', 'unique (name, attribute_id)', "You cannot create two values with the same name for the same attribute.")
     ]
 
+    @api.depends('pav_attribute_line_ids')
+    def _compute_is_used_on_products(self):
+        for pav in self:
+            pav.is_used_on_products = bool(pav.pav_attribute_line_ids)
+
     def name_get(self):
         """Override because in general the name of the value is confusing if it
         is displayed without the name of the corresponding attribute.
@@ -87,6 +119,14 @@ class ProductAttributeValue(models.Model):
         return ", ".join([v.name for v in self if v.attribute_id in variable_attributes])
 
     def write(self, values):
+        if 'attribute_id' in values:
+            for pav in self:
+                if pav.attribute_id.id != values['attribute_id'] and pav.is_used_on_products:
+                    raise UserError(
+                        _("You cannot change the attribute of the value <strong>%s</strong> because it is used on the following products:%s") %
+                        (pav.display_name, ", ".join(pav.pav_attribute_line_ids.product_tmpl_id.mapped('display_name')))
+                    )
+
         invalidate_cache = 'sequence' in values and any(record.sequence != values['sequence'] for record in self)
         res = super(ProductAttributeValue, self).write(values)
         if invalidate_cache:
@@ -96,19 +136,17 @@ class ProductAttributeValue(models.Model):
         return res
 
     def unlink(self):
-        linked_products = self._get_related_product_templates()
-        if linked_products:
-            raise UserError(_('The operation cannot be completed:\nYou are trying to delete an attribute value with a reference on a product variant.'))
+        for pav in self:
+            if pav.is_used_on_products:
+                raise UserError(
+                    _("You cannot delete the value <strong>%s</strong> because it is used on the following products:\n%s") %
+                    (pav.display_name, ", ".join(pav.pav_attribute_line_ids.product_tmpl_id.mapped('display_name')))
+                )
         return super(ProductAttributeValue, self).unlink()
 
     def _without_no_variant_attributes(self):
         return self.filtered(lambda pav: pav.attribute_id.create_variant != 'no_variant')
 
-    def _get_related_product_templates(self):
-        return self.env['product.template'].with_context(active_test=False).search([
-            ('attribute_line_ids.value_ids', 'in', self.ids),
-        ])
-
 
 class ProductTemplateAttributeLine(models.Model):
     """Attributes available on product.template with their selected values in a m2m.
@@ -119,19 +157,34 @@ class ProductTemplateAttributeLine(models.Model):
     _description = 'Product Template Attribute Line'
     _order = 'attribute_id, id'
 
-    product_tmpl_id = fields.Many2one('product.template', string='Product Template', ondelete='cascade', required=True, index=True)
-    attribute_id = fields.Many2one('product.attribute', string='Attribute', ondelete='restrict', required=True, index=True)
-    value_ids = fields.Many2many('product.attribute.value', string='Attribute Values')
+    product_tmpl_id = fields.Many2one('product.template', string="Product Template", ondelete='cascade', required=True, index=True)
+    attribute_id = fields.Many2one('product.attribute', string="Attribute", ondelete='restrict', required=True, index=True)
+    value_ids = fields.Many2many('product.attribute.value', string="Values", domain="[('attribute_id', '=', attribute_id)]",
+        relation='product_attribute_value_product_template_attribute_line_rel')
     product_template_value_ids = fields.Many2many(
         'product.template.attribute.value',
         string='Product Attribute Values',
         compute="_set_product_template_value_ids",
         store=False)
 
+    @api.onchange('attribute_id')
+    def _onchange_attribute_id(self):
+        self.value_ids = self.value_ids.filtered(lambda pav: pav.attribute_id == self.attribute_id)
+
     @api.constrains('value_ids', 'attribute_id')
-    def _check_valid_attribute(self):
-        if any(not line.value_ids or line.value_ids > line.attribute_id.value_ids for line in self):
-            raise ValidationError(_('You cannot use this attribute with the following value.'))
+    def _check_valid_values(self):
+        for ptal in self:
+            if not ptal.value_ids:
+                raise ValidationError(
+                    _("The attribute <strong>%s</strong> must have at least one value for the product %s.") %
+                    (ptal.attribute_id.display_name, ptal.product_tmpl_id.display_name)
+                )
+            for pav in ptal.value_ids:
+                if pav.attribute_id != ptal.attribute_id:
+                    raise ValidationError(
+                        _("On the product %s you cannot associate the value <strong>%s</strong> with the attribute <strong>%s</strong> because they do not match.") %
+                        (ptal.product_tmpl_id.display_name, pav.display_name, ptal.attribute_id.display_name)
+                    )
         return True
 
     @api.model_create_multi
@@ -141,6 +194,22 @@ class ProductTemplateAttributeLine(models.Model):
         return res
 
     def write(self, values):
+        if 'product_tmpl_id' in values:
+            for ptal in self:
+                if ptal.product_tmpl_id.id != values['product_tmpl_id']:
+                    raise UserError(
+                        _("You cannot move the attribute <strong>%s</strong> from the product %s to the product %s.") %
+                        (ptal.attribute_id.display_name, ptal.product_tmpl_id.display_name, values['product_tmpl_id'])
+                    )
+
+        if 'attribute_id' in values:
+            for ptal in self:
+                if ptal.attribute_id.id != values['attribute_id']:
+                    raise UserError(
+                        _("On the product %s you cannot transform the attribute <strong>%s</strong> into the attribute %s.") %
+                        (ptal.product_tmpl_id.display_name, ptal.attribute_id.display_name, values['attribute_id'])
+                    )
+
         res = super(ProductTemplateAttributeLine, self).write(values)
         self._update_product_template_attribute_values()
         return res
@@ -242,6 +311,24 @@ class ProductTemplateAttributeValue(models.Model):
         help="""Make this attribute value not compatible with
         other values of the product or some attribute values of optional and accessory products.""")
 
+    def write(self, values):
+        pav_in_values = 'product_attribute_value_id' in values
+        product_in_values = 'product_tmpl_id' in values
+        if pav_in_values or product_in_values:
+            for ptav in self:
+                if pav_in_values and ptav.product_attribute_value_id.id != values['product_attribute_value_id']:
+                    raise UserError(
+                        _("You cannot change the value of the value <strong>%s</strong> set on product %s.") %
+                        (ptav.display_name, ptav.product_tmpl_id.display_name)
+                    )
+                if product_in_values and ptav.product_tmpl_id.id != values['product_tmpl_id']:
+                    raise UserError(
+                        _("You cannot change the product of the value <strong>%s</strong> set on product %s.") %
+                        (ptav.display_name, ptav.product_tmpl_id.display_name)
+                    )
+
+        return super(ProductTemplateAttributeValue, self).write(values)
+
     def name_get(self):
         """Override because in general the name of the value is confusing if it
         is displayed without the name of the corresponding attribute.
