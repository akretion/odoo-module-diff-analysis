PR: https://github.com/odoo/odoo/pull/146306

From: 7cb48bb804b3de4218807889321de72e908d9358
From: Pierre-Yves Dufays
Date: 2024-03-11 08:39:35

Structural Changes: 7
Total Changes: 70

[IMP] survey: add scale question type

We add the scale question type to survey. That type is a numerical value that
can be chosen among a list of consecutive numbers defined by a custom min and
max value between 0 and 10. The choices are displayed horizontally to
represent a scale.

Details:
- The scale is graduated with step of 1: no configurable step, no decimal,
no negative values
- There are 3 optional labels: min, middle, max value label
- There are no correct answer for that type and then no scoring
- The question cannot be used as a trigger
- Comments are not supported
- Similarly to numerical question, we don't support result filtering on that
new type

We also update the tests to check the behavior of this new question type.

Technical note: we reuse the statistic "question_result_choice" template for
the new type to avoid code duplication. Indeed with minor changes, that
template is compatible and it is quite logical as the scale question type
allows the user to choose among predefined values as well. The main difference
is that scale questions have no "suggested_answer" (survey.question.answer) as
it is just a range of values. This is handy as it automatically disable
features not supported by this new type like filtering on result value (which
relies on suggested answer anyway).

Task-3603599

closes odoo/odoo#146306

Signed-off-by: Thibault Delavallee (tde) <tde@openerp.com>

================================= pseudo patch: =================================

--- a/addons/survey/models/survey_question.py
+++ b/addons/survey/models/survey_question.py
@@ -75,6 +75,7 @@ class SurveyQuestion(models.Model):
         ('text_box', 'Multiple Lines Text Box'),
         ('char_box', 'Single Line Text Box'),
         ('numerical_box', 'Numerical Value'),
+        ('scale', 'Scale'),
         ('date', 'Date'),
         ('datetime', 'Datetime'),
         ('matrix', 'Matrix')], string='Question Type',
@@ -108,6 +109,12 @@ class SurveyQuestion(models.Model):
     matrix_row_ids = fields.One2many(
         'survey.question.answer', 'matrix_question_id', string='Matrix Rows', copy=True,
         help='Labels used for proposed choices: rows of matrix')
+    # -- scale
+    scale_min = fields.Integer("Scale Minimum Value", default=0)
+    scale_max = fields.Integer("Scale Maximum Value", default=10)
+    scale_min_label = fields.Char("Scale Minimum Label", translate=True)
+    scale_mid_label = fields.Char("Scale Middle Label", translate=True)
+    scale_max_label = fields.Char("Scale Maximum Label", translate=True)
     # -- display & timing options
     is_time_limited = fields.Boolean("The question is limited in time",
         help="Currently only supported for live sessions.")
@@ -170,6 +177,8 @@ class SurveyQuestion(models.Model):
             'All "Is a scored question = True" and "Question Type: Datetime" questions need an answer'),
         ('scored_date_have_answers', "CHECK (is_scored_question != True OR question_type != 'date' OR answer_date is not null)",
             'All "Is a scored question = True" and "Question Type: Date" questions need an answer'),
+        ('scale', "CHECK (question_type != 'scale' OR (scale_min >= 0 AND scale_max <= 10 AND scale_min < scale_max))",
+            'The scale must be a growing non-empty range between 0 and 10 (inclusive)'),
     ]
 
     # -------------------------------------------------------------------------
@@ -426,6 +435,8 @@ class SurveyQuestion(models.Model):
                 return self._validate_choice(answer, comment)
             elif self.question_type == 'matrix':
                 return self._validate_matrix(answer)
+            elif self.question_type == 'scale':
+                return self._validate_scale(answer)
         return {}
 
     def _validate_char_box(self, answer):
@@ -494,6 +505,13 @@ class SurveyQuestion(models.Model):
             return {self.id: self.constr_error_msg or _('This question requires an answer.')}
         return {}
 
+    def _validate_scale(self, answer):
+        if not self.survey_id.users_can_go_back \
+                and self.constr_mandatory \
+                and not answer:
+            return {self.id: self.constr_error_msg or _('This question requires an answer.')}
+        return {}
+
     def _index(self):
         """We would normally just use the 'sequence' field of questions BUT, if the pages and questions are
         created without ever moving records around, the sequence field can be set to 0 for all the questions.
@@ -554,6 +572,9 @@ class SurveyQuestion(models.Model):
             return table_data, [{'key': self.title, 'values': graph_data}]
         elif self.question_type == 'matrix':
             return self._get_stats_graph_data_matrix(user_input_lines)
+        elif self.question_type == 'scale':
+            table_data, graph_data = self._get_stats_data_scale(user_input_lines)
+            return table_data, [{'key': self.title, 'values': graph_data}]
         return [line for line in user_input_lines], []
 
     def _get_stats_data_answers(self, user_input_lines):
@@ -613,14 +634,38 @@ class SurveyQuestion(models.Model):
 
         return table_data, graph_data
 
+    def _get_stats_data_scale(self, user_input_lines):
+        suggested_answers = range(self.scale_min, self.scale_max + 1)
+        # Scale doesn't support comment as answer, so no extra value added
+
+        count_data = dict.fromkeys(suggested_answers, 0)
+        for line in user_input_lines:
+            if not line.skipped and line.value_scale in count_data:
+                count_data[line.value_scale] += 1
+
+        table_data = []
+        graph_data = []
+        for sug_answer in suggested_answers:
+            table_data.append({'value': str(sug_answer),
+                               'suggested_answer': self.env['survey.question.answer'],
+                               'count': count_data[sug_answer],
+                               })
+            graph_data.append({'text': str(sug_answer),
+                               'count': count_data[sug_answer]
+                               })
+
+        return table_data, graph_data
+
     def _get_stats_summary_data(self, user_input_lines):
         stats = {}
         if self.question_type in ['simple_choice', 'multiple_choice']:
             stats.update(self._get_stats_summary_data_choice(user_input_lines))
         elif self.question_type == 'numerical_box':
             stats.update(self._get_stats_summary_data_numerical(user_input_lines))
+        elif self.question_type == 'scale':
+            stats.update(self._get_stats_summary_data_numerical(user_input_lines, 'value_scale'))
 
-        if self.question_type in ['numerical_box', 'date', 'datetime']:
+        if self.question_type in ['numerical_box', 'date', 'datetime', 'scale']:
             stats.update(self._get_stats_summary_data_scored(user_input_lines))
         return stats
 
@@ -642,8 +687,8 @@ class SurveyQuestion(models.Model):
             'partial_inputs_count': len(partial_inputs),
         }
 
-    def _get_stats_summary_data_numerical(self, user_input_lines):
-        all_values = user_input_lines.filtered(lambda line: not line.skipped).mapped('value_numerical_box')
+    def _get_stats_summary_data_numerical(self, user_input_lines, fname='value_numerical_box'):
+        all_values = user_input_lines.filtered(lambda line: not line.skipped).mapped(fname)
         lines_sum = sum(all_values)
         return {
             'numerical_max': max(all_values, default=0),

--- a/addons/survey/models/survey_user_input.py
+++ b/addons/survey/models/survey_user_input.py
@@ -286,7 +286,7 @@ class SurveyUserInput(models.Model):
         if old_answers and not overwrite_existing:
             raise UserError(_("This answer cannot be overwritten."))
 
-        if question.question_type in ['char_box', 'text_box', 'numerical_box', 'date', 'datetime']:
+        if question.question_type in ['char_box', 'text_box', 'scale', 'numerical_box', 'date', 'datetime']:
             self._save_line_simple_answer(question, old_answers, answer)
             if question.save_as_email and answer:
                 self.write({'email': answer})
@@ -367,6 +367,8 @@ class SurveyUserInput(models.Model):
             vals['suggested_answer_id'] = int(answer)
         elif answer_type == 'numerical_box':
             vals['value_numerical_box'] = float(answer)
+        elif answer_type == 'scale':
+            vals['value_scale'] = int(answer)
         else:
             vals['value_%s' % answer_type] = answer
         return vals
@@ -716,11 +718,13 @@ class SurveyUserInputLine(models.Model):
         ('text_box', 'Free Text'),
         ('char_box', 'Text'),
         ('numerical_box', 'Number'),
+        ('scale', 'Number'),
         ('date', 'Date'),
         ('datetime', 'Datetime'),
         ('suggestion', 'Suggestion')], string='Answer Type')
     value_char_box = fields.Char('Text answer')
     value_numerical_box = fields.Float('Numerical answer')
+    value_scale = fields.Integer('Scale value')
     value_date = fields.Date('Date answer')
     value_datetime = fields.Datetime('Datetime answer')
     value_text_box = fields.Text('Free Text answer')
@@ -747,6 +751,8 @@ class SurveyUserInputLine(models.Model):
                 line.display_name = fields.Date.to_string(line.value_date)
             elif line.answer_type == 'datetime':
                 line.display_name = fields.Datetime.to_string(line.value_datetime)
+            elif line.answer_type == 'scale':
+                line.display_name = line.value_scale
             elif line.answer_type == 'suggestion':
                 if line.matrix_row_id:
                     line.display_name = f'{line.suggested_answer_id.value}: {line.matrix_row_id.value}'
@@ -762,9 +768,12 @@ class SurveyUserInputLine(models.Model):
             if (line.skipped == bool(line.answer_type)):
                 raise ValidationError(_('A question can either be skipped or answered, not both.'))
 
-            # allow 0 for numerical box
+            # allow 0 for numerical box and scale
             if line.answer_type == 'numerical_box' and float_is_zero(line['value_numerical_box'], precision_digits=6):
                 continue
+            if line.answer_type == 'scale' and line['value_scale'] == 0:
+                continue
+
             if line.answer_type == 'suggestion':
                 field_name = 'suggested_answer_id'
             elif line.answer_type:
@@ -801,11 +810,12 @@ class SurveyUserInputLine(models.Model):
 
     def _get_answer_matching_domain(self):
         self.ensure_one()
-        if self.answer_type in ('char_box', 'text_box', 'numerical_box', 'date', 'datetime'):
+        if self.answer_type in ('char_box', 'text_box', 'numerical_box', 'scale', 'date', 'datetime'):
             value_field = {
                 'char_box': 'value_char_box',
                 'text_box': 'value_text_box',
                 'numerical_box': 'value_numerical_box',
+                'scale': 'value_scale',
                 'date': 'value_date',
                 'datetime': 'value_datetime',
             }
@@ -813,6 +823,7 @@ class SurveyUserInputLine(models.Model):
                 'char_box': 'ilike',
                 'text_box': 'ilike',
                 'numerical_box': '=',
+                'scale': '=',
                 'date': '=',
                 'datetime': '=',
             }
@@ -905,6 +916,8 @@ class SurveyUserInputLine(models.Model):
             return self.value_text_box
         elif self.answer_type == 'numerical_box':
             return self.value_numerical_box
+        elif self.answer_type == 'scale':
+            return self.value_scale
         elif self.answer_type == 'date':
             return self.value_date
         elif self.answer_type == 'datetime':
