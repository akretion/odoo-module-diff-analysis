PR: https://github.com/odoo/odoo/pull/169110

From: 26d960a38b8257297a1802715df216653464b0eb
From: Mathieu Duckerts-Antoine
Date: 2024-06-26 12:19:56

Structural Changes: 3
Total Changes: 59

[REF] mrp: gantt unavailabilities

We adapt the code of mrp to changes brought by https://github.com/odoo/enterprise/pull/64263.
Since the gantt view for mrp workorders always needs to have unavailabilities
for some workcenters in order to compute the aggregates displayed in the
row "Total", we have overridden get_gantt_data here to compute those unavailabilities.
This has allowed us to make the mrp_workorder_gantt view much simpler.

closes odoo/odoo#169110

Related: odoo/enterprise#64263
Signed-off-by: Aaron Bohy (aab) <aab@odoo.com>

================================= pseudo patch: =================================

--- a/addons/mrp/models/mrp_workorder.py
+++ b/addons/mrp/models/mrp_workorder.py
@@ -552,38 +552,35 @@ class MrpWorkorder(models.Model):
         return total
 
     @api.model
-    def gantt_unavailability(self, start_date, end_date, scale, group_bys=None, rows=None):
+    def get_gantt_data(self, domain, groupby, read_specification, limit=None, offset=0, unavailability_fields=[], start_date=None, stop_date=None, scale=None):
+        gantt_data = super().get_gantt_data(domain, groupby, read_specification, limit=limit, offset=offset, unavailability_fields=unavailability_fields, start_date=start_date, stop_date=stop_date, scale=scale)
+        if 'workcenter_id' not in gantt_data['unavailabilities']:
+            workcenter_ids = set()
+            if groupby and 'workcenter_id' in groupby:
+                for group in gantt_data['groups']:
+                    res_id = group['workcenter_id'][0] if group['workcenter_id'] else False
+                    workcenter_ids.add(res_id)
+            else:
+                for record in gantt_data['records']:
+                    res_id = record['workcenter_id']['id'] if record.get('workcenter_id') else False
+                    workcenter_ids.add(res_id)
+            start, stop = fields.Datetime.from_string(start_date), fields.Datetime.from_string(stop_date)
+            gantt_data['unavailabilities']['workcenter_id'] = self._gantt_unavailability('workcenter_id', workcenter_ids, start, stop, scale)
+        return gantt_data
+
+    @api.model
+    def _gantt_unavailability(self, field, res_ids, start, stop, scale):
         """Get unavailabilities data to display in the Gantt view."""
-        workcenter_ids = set()
-
-        def traverse_inplace(func, row, **kargs):
-            res = func(row, **kargs)
-            if res:
-                kargs.update(res)
-            for row in row.get('rows'):
-                traverse_inplace(func, row, **kargs)
-
-        def search_workcenter_ids(row):
-            if row.get('groupedBy') and row.get('groupedBy')[0] == 'workcenter_id' and row.get('resId'):
-                workcenter_ids.add(row.get('resId'))
-
-        for row in rows:
-            traverse_inplace(search_workcenter_ids, row)
-        start_datetime = fields.Datetime.to_datetime(start_date)
-        end_datetime = fields.Datetime.to_datetime(end_date)
-        workcenters = self.env['mrp.workcenter'].browse(workcenter_ids)
-        unavailability_mapping = workcenters._get_unavailability_intervals(start_datetime, end_datetime)
-
-        def add_unavailability(row, workcenter_id=None):
-            if row.get('groupedBy') and row.get('groupedBy')[0] == 'workcenter_id' and row.get('resId'):
-                workcenter_id = row.get('resId')
-            if workcenter_id:
-                row['unavailabilities'] = [{'start': interval[0], 'stop': interval[1]} for interval in unavailability_mapping[workcenter_id]]
-                return {'workcenter_id': workcenter_id}
-
-        for row in rows:
-            traverse_inplace(add_unavailability, row)
-        return rows
+        if field != 'workcenter_id':
+            return super()._gantt_unavailability(field, res_ids, start, stop, scale)
+
+        workcenters = self.env['mrp.workcenter'].browse(res_ids)
+        unavailability_mapping = workcenters._get_unavailability_intervals(start, stop)
+
+        result = {}
+        for workcenter in workcenters:
+            result[workcenter.id] = [{'start': interval[0], 'stop': interval[1]} for interval in unavailability_mapping[workcenter.id]]
+        return result
 
     def button_start(self):
         if any(wo.working_state == 'blocked' for wo in self):
