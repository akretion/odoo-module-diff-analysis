PR: https://github.com/odoo/odoo/pull/138330

From: 005b76462a33558d43e7ca1eaf6f73c4601edaff
From: Sébastien Theys
Date: 2023-10-24 12:38:21

Structural Changes: 5
Total Changes: 419

[IMP] mail, im_livechat, *: simplify channel ACL

* = bus, crm_livechat, hr, mail_bot, test_discuss_full, test_mail,
    website_livechat

Now that livechat uses guest, we can write proper ACL for channel and
channel member to check if the current user/guest is a member.

This allows removing most sudo in code and to simplify search domains.
Remaining sudo in discuss folder have been reviewed and commented.

task-3394829

closes odoo/odoo#138330

Related: odoo/upgrade#5295
Signed-off-by: Sébastien Theys (seb) <seb@odoo.com>

================================= pseudo patch: =================================

--- a/addons/mail/models/discuss/discuss_channel.py
+++ b/addons/mail/models/discuss/discuss_channel.py
@@ -7,7 +7,6 @@ from hashlib import sha512
 from markupsafe import Markup
 from secrets import choice
 from markupsafe import Markup
-from werkzeug.exceptions import NotFound
 
 from odoo import _, api, fields, models, tools, Command
 from odoo.addons.base.models.avatar_mixin import get_hsl_from_seed
@@ -29,8 +28,6 @@ group_avatar = '''<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 530.06 53
 
 
 class Channel(models.Model):
-    """ A discuss.channel is a discussion group that may behave like a listener
-    on documents. """
     _description = 'Discussion Channel'
     _name = 'discuss.channel'
     _mail_flat_thread = False
@@ -63,11 +60,8 @@ class Channel(models.Model):
     channel_partner_ids = fields.Many2many(
         'res.partner', string='Partners',
         compute='_compute_channel_partner_ids', inverse='_inverse_channel_partner_ids',
-        compute_sudo=True, search='_search_channel_partner_ids',
-        groups='base.group_user')
-    channel_member_ids = fields.One2many(
-        'discuss.channel.member', 'channel_id', string='Members',
-        groups='base.group_user')
+        search='_search_channel_partner_ids')
+    channel_member_ids = fields.One2many('discuss.channel.member', 'channel_id', string='Members')
     pinned_message_ids = fields.One2many('mail.message', 'res_id', domain=[('model', '=', 'discuss.channel'), ('pinned_at', '!=', False)], string='Pinned Messages')
     sfu_channel_uuid = fields.Char(groups="base.group_system")
     sfu_server_url = fields.Char(groups="base.group_system")
@@ -95,14 +89,16 @@ class Channel(models.Model):
 
     # CONSTRAINTS
 
-    @api.constrains('channel_member_ids', 'channel_partner_ids')
+    @api.constrains('channel_member_ids')
     def _constraint_partners_chat(self):
+        # sudo: discuss.channel - skipping ACL for constraint, more performant and no sensitive information is leaked
         for ch in self.sudo().filtered(lambda ch: ch.channel_type == 'chat'):
-            if len(ch.channel_member_ids) > 2 or len(ch.channel_partner_ids) > 2:
+            if len(ch.channel_member_ids) > 2:
                 raise ValidationError(_("A channel of type 'chat' cannot have more than two users."))
 
     @api.constrains('group_public_id', 'group_ids')
     def _constraint_group_id_channel(self):
+        # sudo: discuss.channel - skipping ACL for constraint, more performant and no sensitive information is leaked
         failing_channels = self.sudo().filtered(lambda channel: channel.channel_type != 'channel' and (channel.group_public_id or channel.group_ids))
         if failing_channels:
             raise ValidationError(_("For %(channels)s, channel_type should be 'channel' to have the group-based authorization or group auto-subscription.", channels=', '.join([ch.name for ch in failing_channels])))
@@ -118,9 +114,9 @@ class Channel(models.Model):
     def _compute_is_editable(self):
         for channel in self:
             if channel.channel_type == 'channel':
-                channel.is_editable = self.sudo(False).env.is_admin() or channel.create_uid.id == self.env.user.id
+                channel.is_editable = self.env.user._is_admin() or channel.create_uid.id == self.env.user.id
             elif channel.channel_type == 'group':
-                channel.is_editable = channel.is_member and not self.sudo(False).env.user._is_public()
+                channel.is_editable = channel.is_member and not self.env.user.share
             else:
                 channel.is_editable = False
 
@@ -155,53 +151,27 @@ class Channel(models.Model):
                 'partner_id': partner.id,
             } for partner in partners_new]
             outdated += current_members.filtered(lambda m: m.partner_id not in partners)
-
         if new_members:
             self.env['discuss.channel.member'].create(new_members)
         if outdated:
-            outdated.sudo().unlink()
+            outdated.unlink()
 
     def _search_channel_partner_ids(self, operator, operand):
-        return [(
-            'channel_member_ids',
-            'in',
-            self.env['discuss.channel.member'].sudo()._search([
-                ('partner_id', operator, operand)
-            ])
-        )]
+        return [('channel_member_ids', 'any', [('partner_id', operator, operand)])]
 
     @api.depends_context('uid', 'guest')
     @api.depends('channel_member_ids')
     def _compute_is_member(self):
         if not self:
             return
-        if self.env.user._is_public():
-            guest = self.env['mail.guest']._get_guest_from_context()
-            if not guest:
-                self.is_member = False
-                return
-            user_domain = [('guest_id', '=', guest.id)]
-        else:
-            user_domain = [('partner_id', '=', self.env.user.partner_id.id)]
-        members = self.env['discuss.channel.member'].sudo().search(expression.AND([[('channel_id', 'in', self.ids)], user_domain]))
-        is_member_channels = {member.channel_id for member in members}
+        members = self.env['discuss.channel.member'].search([('channel_id', 'in', self.ids), ('is_self', '=', True)])
+        is_member_channels = members.channel_id
         for channel in self:
             channel.is_member = channel in is_member_channels
 
     def _search_is_member(self, operator, operand):
         is_in = (operator == '=' and operand) or (operator == '!=' and not operand)
-        if self.env.user._is_public():
-            guest = self.env['mail.guest']._get_guest_from_context()
-            if not guest:
-                return expression.FALSE_DOMAIN if is_in else expression.TRUE_DOMAIN
-            user_domain = [('guest_id', '=', guest.id)]
-        else:
-            user_domain = [('partner_id', '=', self.env.user.partner_id.id)]
-        return [(
-            'channel_member_ids',
-            'in' if is_in else 'not in',
-            self.env['discuss.channel.member'].sudo()._search(user_domain)
-        )]
+        return [('channel_member_ids', "any" if is_in else "not any", [('is_self', '=', True)])]
 
     @api.depends('channel_member_ids')
     def _compute_member_count(self):
@@ -256,7 +226,8 @@ class Channel(models.Model):
 
         # Create channel and alias
         channels = super(Channel, self.with_context(mail_create_bypass_create_check=self.env['discuss.channel.member']._bypass_create_check, mail_create_nolog=True, mail_create_nosubscribe=True)).create(vals_list)
-
+        # pop the mail_create_bypass_create_check key to avoid leaking it outside of create)
+        channels = channels.with_context(mail_create_bypass_create_check=None)
         channels._subscribe_users_automatically()
 
         return channels
@@ -273,7 +244,7 @@ class Channel(models.Model):
 
     def write(self, vals):
         if 'channel_type' in vals:
-            failing_channels = self.sudo().filtered(lambda channel: channel.channel_type != vals.get('channel_type'))
+            failing_channels = self.filtered(lambda channel: channel.channel_type != vals.get('channel_type'))
             if failing_channels:
                 raise UserError(_('Cannot change the channel type of: %(channel_names)s', channel_names=', '.join(failing_channels.mapped('name'))))
         notifications = []
@@ -311,13 +282,6 @@ class Channel(models.Model):
         if not self._cr.fetchone():
             self._cr.execute('CREATE INDEX discuss_channel_member_seen_message_id_idx ON discuss_channel_member (channel_id,partner_id,seen_message_id)')
 
-    @api.model
-    def _get_from_context_or_raise(self, thread_id):
-        """Overridden because guests and (portal) users need sudo to post on channels. This ensures they are actually
-        members before granting them access, as well as properly setting up the guest context on the resulting thread
-        if applicable."""
-        return self.env["discuss.channel.member"]._get_as_sudo_from_context_or_raise(thread_id).channel_id
-
     # ------------------------------------------------------------
     # MEMBERS MANAGEMENT
     # ------------------------------------------------------------
@@ -330,6 +294,7 @@ class Channel(models.Model):
                 for channel_id in new_members
                 for partner_id in new_members[channel_id]
             ]
+            # sudo: discuss.channel.member - adding member of other users based on channel auto-subscribe
             self.env['discuss.channel.member'].sudo().create(to_create)
 
     def _subscribe_users_automatically_get_members(self):
@@ -344,22 +309,21 @@ class Channel(models.Model):
 
     def _action_unfollow(self, partner):
         self.message_unsubscribe(partner.ids)
-        if partner not in self.with_context(active_test=False).channel_partner_ids:
+        member = self.env['discuss.channel.member'].search([('channel_id', '=', self.id), ('partner_id', '=', partner.id)])
+        if not member:
             return True
         channel_info = self._channel_info()[0]  # must be computed before leaving the channel (access rights)
-        member = self.env['discuss.channel.member'].search([('channel_id', '=', self.id), ('partner_id', '=', partner.id)])
-        member_id = member.id
         member.unlink()
         # side effect of unsubscribe that wasn't taken into account because
         # channel_info is called before actually unpinning the channel
         channel_info['is_pinned'] = False
         self.env['bus.bus']._sendone(partner, 'discuss.channel/leave', channel_info)
         notification = Markup('<div class="o_mail_notification">%s</div>') % _('left the channel')
-        # post 'channel left' message as root since the partner just unsubscribed from the channel
+        # sudo: mail.message - post as sudo since the user just unsubscribed from the channel
         self.sudo().message_post(body=notification, subtype_xmlid="mail.mt_comment", author_id=partner.id)
         self.env['bus.bus']._sendone(self, 'mail.record/insert', {
             'Thread': {
-                'channelMembers': [('DELETE', {'id': member_id})],
+                'channelMembers': [('DELETE', {'id': member.id})],
                 'id': self.id,
                 'memberCount': self.member_count,
                 'model': "discuss.channel",
@@ -368,30 +332,12 @@ class Channel(models.Model):
 
     def add_members(self, partner_ids=None, guest_ids=None, invite_to_rtc_call=False, open_chat_window=False, post_joined_message=True):
         """ Adds the given partner_ids and guest_ids as member of self channels. """
-        self.check_access_rights('write')
-        self.check_access_rule('write')
         current_partner, current_guest = self.env["res.partner"]._get_current_persona()
         partners = self.env['res.partner'].browse(partner_ids or []).exists()
         guests = self.env['mail.guest'].browse(guest_ids or []).exists()
         notifications = []
         for channel in self:
             members_to_create = []
-            if channel.group_public_id:
-                invalid_partners = partners.filtered(lambda partner: channel.group_public_id not in partner.user_ids.groups_id)
-                if invalid_partners:
-                    raise UserError(_(
-                        'Channel "%(channel_name)s" only accepts members of group "%(group_name)s". Forbidden for: %(partner_names)s',
-                        channel_name=channel.name,
-                        group_name=channel.group_public_id.name,
-                        partner_names=', '.join(partner.name for partner in invalid_partners)
-                    ))
-                if guests:
-                    raise UserError(_(
-                        'Channel "%(channel_name)s" only accepts members of group "%(group_name)s". Forbidden for: %(guest_names)s',
-                        channel_name=channel.name,
-                        group_name=channel.group_public_id.name,
-                        guest_names=', '.join(guest.name for guest in guests)
-                    ))
             existing_members = self.env['discuss.channel.member'].search(expression.AND([
                 [('channel_id', '=', channel.id)],
                 expression.OR([
@@ -407,17 +353,16 @@ class Channel(models.Model):
                 'guest_id': guest.id,
                 'channel_id': channel.id,
             } for guest in guests - existing_members.guest_id]
-            new_members = self.env['discuss.channel.member'].sudo().create(members_to_create)
+            new_members = self.env['discuss.channel.member'].create(members_to_create)
             for member in new_members.filtered(lambda member: member.partner_id):
                 # notify invited members through the bus
                 user = member.partner_id.user_ids[0] if member.partner_id.user_ids else self.env['res.users']
                 if user:
                     notifications.append((member.partner_id, 'discuss.channel/joined', {
-                        'channel': member.channel_id.with_user(user).with_context(allowed_company_ids=user.company_ids.ids).sudo()._channel_info()[0],
+                        'channel': member.channel_id.with_user(user).with_context(allowed_company_ids=user.company_ids.ids)._channel_info()[0],
                         'invited_by_user_id': self.env.user.id,
                         'open_chat_window': open_chat_window,
                     }))
-
                 if post_joined_message:
                     # notify existing members with a new message in the channel
                     if member.partner_id == self.env.user.partner_id:
@@ -432,7 +377,7 @@ class Channel(models.Model):
                 guest = member.guest_id
                 if guest:
                     notifications.append((guest, 'discuss.channel/joined', {
-                        'channel': member.channel_id.sudo()._channel_info()[0],
+                        'channel': member.channel_id.with_context(guest=guest)._channel_info()[0],
                     }))
             notifications.append((channel, 'mail.record/insert', {
                 'Thread': {
@@ -442,7 +387,7 @@ class Channel(models.Model):
                     'model': "discuss.channel",
                 }
             }))
-            if existing_members:
+            if existing_members and (current_partner or current_guest):
                 # If the current user invited these members but they are already present, notify the current user about their existence as well.
                 # In particular this fixes issues where the current user is not aware of its own member in the following case:
                 # create channel from form view, and then join from discuss without refreshing the page.
@@ -456,31 +401,13 @@ class Channel(models.Model):
                 }))
         if invite_to_rtc_call:
             for channel in self:
-                current_channel_member = self.env['discuss.channel.member'].sudo().search([('channel_id', '=', channel.id), ('partner_id', '=', current_partner.id), ('guest_id', '=', current_guest.id)])
-                if current_channel_member and current_channel_member.rtc_session_ids:
-                    current_channel_member._rtc_invite_members(member_ids=new_members.ids)
+                current_channel_member = self.env['discuss.channel.member'].search([('channel_id', '=', channel.id), ('is_self', '=', 'True')])
+                # sudo: discuss.channel.rtc.session - reading rtc sessions of current user
+                if current_channel_member and current_channel_member.sudo().rtc_session_ids:
+                    # sudo: discuss.channel.rtc.session - current user can invite new members in call
+                    current_channel_member.sudo()._rtc_invite_members(member_ids=new_members.ids)
         self.env['bus.bus']._sendmany(notifications)
 
-    def _can_invite(self, partner_id):
-        """Return True if the current user can invite the partner to the channel.
-
-          * channel -- public channel: ok;
-          *         -- group restricted channel: both current user and target must in the group;
-          * chat/group: current user must be member;
-
-        :return boolean: whether inviting is ok"""
-        partner = self.env['res.partner'].browse(partner_id)
-
-        for channel in self.sudo():
-            if channel.channel_type != 'channel' and not channel.is_member:
-                return False
-            if channel.group_public_id:
-                if not partner.user_ids or channel.group_public_id not in partner.user_ids.groups_id:
-                    return False
-                if channel.group_public_id not in self.env.user.groups_id:
-                    return False
-        return True
-
     # ------------------------------------------------------------
     # RTC
     # ------------------------------------------------------------
@@ -538,9 +465,8 @@ class Channel(models.Model):
           and use;
         """
         # get values from msg_vals or from message if msg_vals doen't exists
-        msg_sudo = message.sudo()
-        message_type = msg_vals.get('message_type', 'email') if msg_vals else msg_sudo.message_type
-        pids = msg_vals.get('partner_ids', []) if msg_vals else msg_sudo.partner_ids.ids
+        message_type = msg_vals.get('message_type', 'email') if msg_vals else message.message_type
+        pids = msg_vals.get('partner_ids', []) if msg_vals else message.partner_ids.ids
 
         # notify only user input (comment or incoming emails)
         if message_type not in ('comment', 'email'):
@@ -549,8 +475,8 @@ class Channel(models.Model):
         if not pids:
             return []
 
-        email_from = tools.email_normalize(msg_vals.get('email_from') or msg_sudo.email_from)
-        author_id = msg_vals.get('author_id') or msg_sudo.author_id.id
+        email_from = tools.email_normalize(msg_vals.get('email_from') or message.email_from)
+        author_id = msg_vals.get('author_id') or message.author_id.id
 
         recipients_data = []
         if pids:
@@ -601,16 +527,15 @@ class Channel(models.Model):
 
         message_format_values = message.message_format()[0]
         bus_notifications = self._channel_message_notifications(message, message_format_values)
-        # Last interest and is_pinned are updated for a chat when posting a message.
+        # Last interest and is_pinned are updated for a channel when posting a message.
         # So a notification is needed to update UI, and it should come before the
         # notification of the message itself to ensure the channel automatically opens.
-        if self.is_chat or self.channel_type in ['channel', 'group']:
-            for member in self.channel_member_ids.filtered('partner_id'):
-                bus_notifications.insert(0, [member.partner_id, 'discuss.channel/last_interest_dt_changed', {
-                    'id': self.id,
-                    'isServerPinned': member.is_pinned,
-                    'last_interest_dt': member.last_interest_dt,
-                }])
+        bus_notifications.insert(0, [self, 'discuss.channel/last_interest_dt_changed', {
+            'id': self.id,
+            'isServerPinned': True,
+            'last_interest_dt': fields.Datetime.now(),
+        }])
+        # sudo: bus.bus - sending on safe channel (target channel or partner)
         self.env['bus.bus'].sudo()._sendmany(bus_notifications)
         if self.is_chat or self.channel_type == 'group':
             self._notify_thread_by_web_push(message, rdata, msg_vals, **kwargs)
@@ -639,11 +564,14 @@ class Channel(models.Model):
 
     @api.returns('mail.message', lambda value: value.id)
     def message_post(self, *, message_type='notification', **kwargs):
-        self.filtered(lambda channel: channel.is_chat or channel.channel_type in ['channel', 'group']).mapped('channel_member_ids').sudo().write({
+        if (not self.env.user or self.env.user._is_public()) and self.is_member:
+            # sudo: discuss.channel - guests don't have access for creating mail.message
+            self = self.sudo()
+        # sudo: discuss.channel.member - updating hard-coded fields/values for non-self members
+        self.sudo().channel_member_ids.write({
             'is_pinned': True,
             'last_interest_dt': fields.Datetime.now(),
         })
-
         # mail_post_autofollow=False is necessary to prevent adding followers
         # when using mentions in channels. Followers should not be added to
         # channels, and especially not automatically (because channel membership
@@ -772,30 +700,25 @@ class Channel(models.Model):
             }
             self.message_post(body=notification, message_type="notification", subtype_xmlid="mail.mt_comment")
 
-    def _find_or_create_persona_for_channel(self, guest_name, timezone, country_code, add_as_member=True, post_joined_message=True):
+    def _find_or_create_persona_for_channel(self, guest_name, timezone, country_code, post_joined_message=True):
         """
         :param channel: channel to add the persona to
         :param guest_name: name of the persona
-        :param add_as_member: whether to add the persona as a member of the channel
         :param post_joined_message: whether to post a message to the channel
             to notify that the persona joined
         :return tuple(partner, guest):
         """
         self.ensure_one()
         guest = None
-        member = self.env["discuss.channel.member"]._get_as_sudo_from_context(channel_id=self.id)
+        member = self.env["discuss.channel.member"].search([("channel_id", "=", self.id), ("is_self", "=", True)])
         if member:
             return member.partner_id, member.guest_id
-        if not self.env.user._is_public() and add_as_member:
-            try:
-                self.add_members([self.env.user.partner_id.id], post_joined_message=post_joined_message)
-            except UserError:
-                raise NotFound()
+        if not self.env.user._is_public():
+            self.add_members([self.env.user.partner_id.id], post_joined_message=post_joined_message)
         elif self.env.user._is_public():
-            is_guest_known = self.env["mail.guest"]._get_guest_from_context().exists()
-            country_id = self.env["res.country"].search([("code", "=", country_code)], limit=1).id
+            is_guest_known = self.env["mail.guest"]._get_guest_from_context()
+            country_id = self.env["res.country"].search([("code", "=", country_code)]).id
             guest = self.env["mail.guest"]._find_or_create_for_channel(
-                add_as_member=add_as_member,
                 channel=self,
                 country_id=country_id,
                 name=guest_name,
@@ -814,6 +737,7 @@ class Channel(models.Model):
         if not self:
             return []
         channel_infos = []
+        # sudo: discuss.channel.rtc.session - reading sessions of accessible channel is acceptable
         rtc_sessions_by_channel = self.sudo().rtc_session_ids._mail_rtc_session_format_by_channel()
         current_partner, current_guest = self.env["res.partner"]._get_current_persona()
         self.env['discuss.channel'].flush_model()
@@ -837,14 +761,14 @@ class Channel(models.Model):
                ORDER BY discuss_channel_member.id ASC
         """, {'channel_ids': tuple(self.ids), 'current_partner_id': current_partner.id or None, 'current_guest_id': current_guest.id or None})
         all_needed_members = self.env['discuss.channel.member'].browse([m['id'] for m in self.env.cr.dictfetchall()])
-        all_needed_members.partner_id.sudo().mail_partner_format()  # prefetch in batch
+        all_needed_members._discuss_channel_member_format()  # prefetch in batch
         members_by_channel = defaultdict(lambda: self.env['discuss.channel.member'])
         invited_members_by_channel = defaultdict(lambda: self.env['discuss.channel.member'])
         member_of_current_user_by_channel = defaultdict(lambda: self.env['discuss.channel.member'])
         for member in all_needed_members:
-            members_by_channel[member.channel_id] |= member
+            members_by_channel[member.channel_id] += member
             if member.rtc_inviting_session_id:
-                invited_members_by_channel[member.channel_id] |= member
+                invited_members_by_channel[member.channel_id] += member
             if (current_partner and member.partner_id == current_partner) or (current_guest and member.guest_id == current_guest):
                 member_of_current_user_by_channel[member.channel_id] = member
         for channel in self:
@@ -976,7 +900,6 @@ class Channel(models.Model):
         else:
             # create a new one
             channel = self.create({
-                'channel_partner_ids': [Command.link(partner_id) for partner_id in partners_to],
                 'channel_member_ids': [
                     Command.create({
                         'partner_id': partner_id,
@@ -985,7 +908,7 @@ class Channel(models.Model):
                     }) for partner_id in partners_to
                 ],
                 'channel_type': 'chat',
-                'name': ', '.join(self.env['res.partner'].sudo().browse(partners_to).mapped('name')),
+                'name': ', '.join(self.env['res.partner'].browse(partners_to).mapped('name')),
             })
             channel._broadcast(partners_to)
         return channel
@@ -1133,7 +1056,7 @@ class Channel(models.Model):
         self.write({'description': description})
 
     def channel_join(self):
-        """ Shortcut to add the current user as member of self channels.
+        """Shortcut to add the current user as member of self channels.
         Prefer calling add_members() directly when possible.
         """
         self.add_members(self.env.user.partner_id.ids)
@@ -1179,7 +1102,7 @@ class Channel(models.Model):
             'default_display_mode': default_display_mode,
             'name': name,
         })
-        channel._broadcast(partners_to)
+        channel._broadcast(channel.channel_member_ids.partner_id.ids)
         return channel
 
     @api.model

--- a/addons/mail/models/discuss/discuss_channel_member.py
+++ b/addons/mail/models/discuss/discuss_channel_member.py
@@ -1,12 +1,9 @@
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
-from werkzeug.exceptions import NotFound
-
 from odoo import api, fields, models, _
-from odoo.exceptions import AccessError, ValidationError
+from odoo.exceptions import AccessError, UserError, ValidationError
 from odoo.osv import expression
 
-
 class ChannelMember(models.Model):
     _name = "discuss.channel.member"
     _description = "Channel Member"
@@ -16,6 +13,7 @@ class ChannelMember(models.Model):
     # identity
     partner_id = fields.Many2one("res.partner", "Partner", ondelete="cascade", index=True)
     guest_id = fields.Many2one("mail.guest", "Guest", ondelete="cascade", readonly=True, index=True)
+    is_self = fields.Boolean(compute="_compute_is_self", search="_search_is_self")
     # channel
     channel_id = fields.Many2one("discuss.channel", "Channel", ondelete="cascade", readonly=True, required=True)
     # state
@@ -38,7 +36,34 @@ class ChannelMember(models.Model):
             if any(user._is_public() for user in member.partner_id.user_ids):
                 raise ValidationError(_("Channel members cannot include public users."))
 
-    @api.depends('channel_id.message_ids', 'seen_message_id')
+    @api.depends_context("uid", "guest")
+    def _compute_is_self(self):
+        if not self:
+            return
+        current_partner, current_guest = self.env["res.partner"]._get_current_persona()
+        self.is_self = False
+        for member in self:
+            if current_partner and member.partner_id == current_partner:
+                member.is_self = True
+            if current_guest and member.guest_id == current_guest:
+                member.is_self = True
+
+    def _search_is_self(self, operator, operand):
+        is_in = (operator == "=" and operand) or (operator == "!=" and not operand)
+        current_partner, current_guest = self.env["res.partner"]._get_current_persona()
+        if is_in:
+            return [
+                '|',
+                ("partner_id", "=", current_partner.id) if current_partner else expression.FALSE_LEAF,
+                ("guest_id", "=", current_guest.id) if current_guest else expression.FALSE_LEAF,
+            ]
+        else:
+            return [
+                ("partner_id", "!=", current_partner.id) if current_partner else expression.TRUE_LEAF,
+                ("guest_id", "!=", current_guest.id) if current_guest else expression.TRUE_LEAF,
+            ]
+
+    @api.depends("channel_id.message_ids", "seen_message_id")
     def _compute_message_unread(self):
         if self.ids:
             self.env['mail.message'].flush_model()
@@ -83,58 +108,35 @@ class ChannelMember(models.Model):
 
     @api.model_create_multi
     def create(self, vals_list):
-        """Similar access rule as the access rule of the mail channel.
-
-        It can not be implemented in XML, because when the record will be created, the
-        partner will be added in the channel and the security rule will always authorize
-        the creation.
-        """
-        if not self.env.is_admin() and not self.env.context.get('mail_create_bypass_create_check') is self._bypass_create_check:
-            for vals in vals_list:
-                if 'channel_id' in vals:
-                    channel_id = self.env['discuss.channel'].browse(vals['channel_id'])
-                    if not channel_id._can_invite(vals.get('partner_id')):
-                        raise AccessError(_('This user can not be added in this channel'))
+        if self.env.context.get("mail_create_bypass_create_check") is self._bypass_create_check:
+            self = self.sudo()
+        for vals in vals_list:
+            if "channel_id" not in vals:
+                raise UserError(
+                    _(
+                        "It appears you're trying to create a channel member, but it seems like you forgot to specify the related channel. "
+                        "To move forward, please make sure to provide the necessary channel information."
+                    )
+                )
+            channel = self.env["discuss.channel"].browse(vals["channel_id"])
+            if channel.channel_type == "chat" and len(channel.channel_member_ids) > 0:
+                raise UserError(
+                    _("Adding more members to this chat isn't possible; it's designed for just two people.")
+                )
         return super().create(vals_list)
 
     def write(self, vals):
         for channel_member in self:
-            for field_name in {'channel_id', 'partner_id', 'guest_id'}:
+            for field_name in ['channel_id', 'partner_id', 'guest_id']:
                 if field_name in vals and vals[field_name] != channel_member[field_name].id:
                     raise AccessError(_('You can not write on %(field_name)s.', field_name=field_name))
         return super().write(vals)
 
     def unlink(self):
-        self.sudo().rtc_session_ids.unlink()
+        # sudo: discuss.channel.rtc.session - cascade unlink of sessions for self member
+        self.sudo().rtc_session_ids.unlink()  # ensure unlink overrides are applied
         return super().unlink()
 
-    @api.model
-    def _get_as_sudo_from_context_or_raise(self, channel_id):
-        channel_member = self._get_as_sudo_from_context(channel_id=channel_id)
-        if not channel_member:
-            raise NotFound()
-        return channel_member
-
-    @api.model
-    def _get_as_sudo_from_context(self, channel_id):
-        """ Seeks a channel member matching the provided `channel_id` and the
-        current user or guest.
-
-        :param channel_id: The id of the channel of which the user/guest is
-            expected to be member.
-        :type channel_id: int
-        :return: A record set containing the channel member if found, or an
-            empty record set otherwise. In case of guest, the record is returned
-            with the 'guest' record in the context.
-        :rtype: discuss.channel.member
-        """
-        if self.env.uid and not self.env.user._is_public():
-            return self.env['discuss.channel.member'].sudo().search([('channel_id', '=', channel_id), ('partner_id', '=', self.env.user.partner_id.id)], limit=1)
-        guest = self.env['mail.guest']._get_guest_from_context()
-        if guest:
-            return guest.env['discuss.channel.member'].sudo().search([('channel_id', '=', channel_id), ('guest_id', '=', guest.id)], limit=1)
-        return self.env['discuss.channel.member'].sudo()
-
     def _notify_typing(self, is_typing):
         """ Broadcast the typing notification to channel members
             :param is_typing: (boolean) tells whether the members are typing or not
@@ -159,9 +161,11 @@ class ChannelMember(models.Model):
                 data['thread'] = member.channel_id._channel_format(fields=fields.get('channel')).get(member.channel_id)
             if 'persona' in fields:
                 if member.partner_id:
-                    persona = member._get_partner_data(fields=fields.get('persona', {}).get('partner'))
+                    # sudo: res.partner - reading _get_partner_data related to a member is considered acceptable
+                    persona = member.sudo()._get_partner_data(fields=fields.get('persona', {}).get('partner'))
                     persona['type'] = "partner"
                 if member.guest_id:
+                    # sudo: mail.guest - reading _guest_format related to a member is considered acceptable
                     persona = member.guest_id.sudo()._guest_format(fields=fields.get('persona', {}).get('guest')).get(member.guest_id)
                 data['persona'] = persona
             members_formatted_data[member] = data

--- a/addons/mail/models/discuss/ir_attachment.py
+++ b/addons/mail/models/discuss/ir_attachment.py
@@ -20,6 +20,7 @@ class IrAttachment(models.Model):
     def _attachment_format(self):
         attachment_format = super()._attachment_format()
         for a in attachment_format:
+        # sudo: discuss.voice.metadata - checking the existence of voice metadata for accessible attachments is fine
             a["voice"] = bool(self.browse(a["id"]).with_prefetch(self._prefetch_ids).sudo().voice_ids)
         return attachment_format
 

--- a/addons/mail/models/discuss/ir_websocket.py
+++ b/addons/mail/models/discuss/ir_websocket.py
@@ -1,3 +1,5 @@
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
 from odoo import models
 from odoo.addons.mail.models.discuss.mail_guest import add_guest_to_context
 
@@ -8,6 +10,7 @@ class IrWebsocket(models.AbstractModel):
     def _get_im_status(self, data):
         im_status = super()._get_im_status(data)
         if "mail.guest" in data:
+            # sudo: mail.guest - necessary to read im_status from other guests, information is not considered sensitive
             im_status["Persona"] += [{**g, 'type': "guest"} for g in (
                 self.env["mail.guest"]
                 .sudo()
@@ -19,26 +22,22 @@ class IrWebsocket(models.AbstractModel):
     @add_guest_to_context
     def _build_bus_channel_list(self, channels):
         channels = list(channels)  # do not alter original list
-        guest_sudo = self.env["mail.guest"]._get_guest_from_context().sudo()
-        discuss_channels = self.env["discuss.channel"]
-        if self.env.uid and not self.env.user._is_public():
-            discuss_channels = self.env.user.partner_id.channel_ids
-        elif guest_sudo:
-            discuss_channels = guest_sudo.channel_ids
-            channels.append(guest_sudo)
-        for discuss_channel in discuss_channels:
-            channels.append(discuss_channel)
+        guest = self.env["mail.guest"]._get_guest_from_context()
+        if guest:
+            channels.append(guest)
+        channels.extend(self.env["discuss.channel"].search([("is_member", "=", True)]))
         return super()._build_bus_channel_list(channels)
 
     @add_guest_to_context
     def _update_bus_presence(self, inactivity_period, im_status_ids_by_model):
         super()._update_bus_presence(inactivity_period, im_status_ids_by_model)
         if not self.env.user or self.env.user._is_public():
-            guest_sudo = self.env["mail.guest"]._get_guest_from_context().sudo()
-            if not guest_sudo:
+            guest = self.env["mail.guest"]._get_guest_from_context()
+            if not guest:
                 return
-            guest_sudo.env["bus.presence"].update_presence(
+            # sudo: bus.presence - guests currently need sudo to write their own presence
+            self.env["bus.presence"].sudo().update_presence(
                 inactivity_period,
                 identity_field="guest_id",
-                identity_value=guest_sudo.id,
+                identity_value=guest.id,
             )

--- a/addons/mail/models/discuss/mail_guest.py
+++ b/addons/mail/models/discuss/mail_guest.py
@@ -5,7 +5,6 @@ import uuid
 from datetime import datetime, timedelta
 from functools import wraps
 from inspect import Parameter, signature
-from werkzeug.exceptions import NotFound
 
 from odoo.tools import consteq, get_lang
 from odoo import _, api, fields, models
@@ -83,6 +82,7 @@ class MailGuest(models.Model):
         parts = token.split(self._cookie_separator)
         if len(parts) == 2:
             guest_id, guest_access_token = parts
+            # sudo: mail.guest: guests need sudo to read their access_token
             guest = self.browse(int(guest_id)).sudo().exists()
             if not guest or not guest.access_token or not consteq(guest.access_token, guest_access_token):
                 guest = self.env["mail.guest"]
@@ -92,7 +92,7 @@ class MailGuest(models.Model):
         """Returns the current guest record from the context, if applicable."""
         guest = self.env.context.get('guest')
         if isinstance(guest, self.pool['mail.guest']):
-            return guest.with_context(guest=guest)
+            return guest.sudo(False).with_context(guest=guest)
         return self.env['mail.guest']
 
     def _get_timezone_from_request(self, request):
@@ -129,20 +129,25 @@ class MailGuest(models.Model):
 
     def _init_messaging(self):
         self.ensure_one()
-        odoobot = self.env.ref('base.partner_root')
+        # sudo: res.partner - exposing OdooBot name and id
+        odoobot = self.env.ref('base.partner_root').sudo()
+        # sudo: mail.guest - guest reading their own id/name/channels
+        guest_sudo = self.sudo()
         return {
-            'channels': self.channel_ids._channel_info(),
+            'channels': guest_sudo.channel_ids.sudo(False)._channel_info(),
             'companyName': self.env.company.name,
             'currentGuest': {
-                'id': self.id,
-                'name': self.name,
+                'id': guest_sudo.id,
+                'name': guest_sudo.name,
                 'type': "guest",
             },
             'current_partner': False,
             'current_user_id': False,
             'current_user_settings': False,
+             # sudo: ir.config_parameter: safe to check for existence of tenor api key
             'hasGifPickerFeature': bool(self.env["ir.config_parameter"].sudo().get_param("discuss.tenor_api_key")),
             'hasLinkPreviewFeature': self.env['mail.link.preview']._is_link_preview_enabled(),
+             # sudo: bus.bus: reading non-sensitive last id
             'initBusId': self.env['bus.bus'].sudo()._bus_last_id(),
             'menu_id': False,
             'needaction_inbox_counter': False,
@@ -171,7 +176,7 @@ class MailGuest(models.Model):
             guests_formatted_data[guest] = data
         return guests_formatted_data
 
-    def _find_or_create_for_channel(self, channel, name, country_id, timezone, add_as_member=True, post_joined_message=False):
+    def _find_or_create_for_channel(self, channel, name, country_id, timezone, post_joined_message=False):
         """Get a guest for the given channel. If there is no guest yet,
         create one.
 
@@ -183,8 +188,6 @@ class MailGuest(models.Model):
         :param post_joined_message: whether to post a message to the channel
             to notify that the guest joined
         """
-        if channel.group_public_id:
-            raise NotFound()
         guest = self._get_guest_from_context()
         if not guest:
             guest = self.create(
@@ -194,19 +197,14 @@ class MailGuest(models.Model):
                     "name": name,
                     "timezone": timezone,
                 }
-            )
-        if add_as_member:
-            channel = channel.with_context(guest=guest)
-            try:
-                channel.add_members(guest_ids=[guest.id], post_joined_message=post_joined_message)
-            except UserError:
-                raise NotFound()
+            ).sudo(False)
+        channel.add_members(guest_ids=guest.ids, post_joined_message=post_joined_message)
         return guest
 
     def _set_auth_cookie(self):
         """Add a cookie to the response to identify the guest. Every route
         that expects a guest will make use of it to authenticate the guest
-        through `_get_as_sudo_from_context` or `_get_as_sudo_from_context_or_raise`.
+        through `add_guest_to_context`.
         """
         self.ensure_one()
         expiration_date = datetime.now() + timedelta(days=365)
@@ -216,6 +214,7 @@ class MailGuest(models.Model):
             httponly=True,
             expires=expiration_date,
         )
+        request.update_context(guest=self.sudo(False))
 
     def _format_auth_cookie(self):
         """Format the cookie value for the given guest.

--- a/addons/mail/models/discuss/mail_message.py
+++ b/addons/mail/models/discuss/mail_message.py
@@ -12,6 +12,7 @@ class MailMessage(models.Model):
         self.ensure_one()
         if self.env.user._is_public():
             guest = self.env["mail.guest"]._get_guest_from_context()
+            # sudo: mail.guest - current guest can read channels they are member of
             return guest and self.model == "discuss.channel" and self.res_id in guest.sudo().channel_ids.ids
         return super()._validate_access_for_current_persona(operation)
 

--- a/addons/mail/models/discuss/res_partner.py
+++ b/addons/mail/models/discuss/res_partner.py
@@ -16,37 +16,6 @@ class ResPartner(models.Model):
         copy=False,
     )
 
-    def _get_channels_as_member(self):
-        """Returns the channels of the partner."""
-        self.ensure_one()
-        channels = self.env["discuss.channel"]
-        # get the channels and groups
-        channels |= self.env["discuss.channel"].search(
-            [
-                ("channel_type", "in", ("channel", "group")),
-                ("channel_partner_ids", "in", [self.id]),
-            ]
-        )
-        # get the pinned direct messages (directly include whatsapp to avoid overrides)
-        channels |= self.env["discuss.channel"].search(
-            [
-                ("channel_type", "in", ["chat", "whatsapp"]),
-                (
-                    "channel_member_ids",
-                    "in",
-                    self.env["discuss.channel.member"]
-                    .sudo()
-                    ._search(
-                        [
-                            ("partner_id", "=", self.id),
-                            ("is_pinned", "=", True),
-                        ]
-                    ),
-                ),
-            ]
-        )
-        return channels
-
     @api.model
     def search_for_channel_invite(self, search_term, channel_id=None, limit=30):
         """Returns partners matching search_term that can be invited to a channel.

--- a/addons/mail/models/discuss/res_users.py
+++ b/addons/mail/models/discuss/res_users.py
@@ -38,11 +38,9 @@ class ResUsers(models.Model):
     def _unsubscribe_from_non_public_channels(self):
         """This method un-subscribes users from group restricted channels. Main purpose
         of this method is to prevent sending internal communication to archived / deleted users.
-        We do not un-subscribes users from public channels because in most common cases,
-        public channels are mailing list (e-mail based) and so users should always receive
-        updates from public channels until they manually un-subscribe themselves.
         """
         domain = [("partner_id", "in", self.partner_id.ids)]
+        # sudo: discuss.channel.member - removing member of other users based on channel restrictions
         current_cm = self.env["discuss.channel.member"].sudo().search(domain)
         current_cm.filtered(
             lambda cm: (cm.channel_id.channel_type == "channel" and cm.channel_id.group_public_id)
@@ -50,8 +48,18 @@ class ResUsers(models.Model):
 
     def _init_messaging(self):
         self.ensure_one()
+        # 2 different queries because the 2 sub-queries together with OR are less efficient
+        channels = self.env["discuss.channel"].with_user(self)
+        channels += channels.search([("channel_type", "in", ("channel", "group")), ("is_member", "=", True)])
+        channels += channels.search(
+            [
+                ("channel_type", "not in", ("channel", "group")),
+                ("channel_member_ids", "any", [("is_self", "=", True), ("is_pinned", "=", True)]),
+            ]
+        )
         return {
-            'channels': self.partner_id._get_channels_as_member()._channel_info(),
-            'hasGifPickerFeature': bool(self.env["ir.config_parameter"].sudo().get_param("discuss.tenor_api_key")),
+            "channels": channels._channel_info(),
+            # sudo: ir.config_parameter - reading hard-coded key to check its existence, safe to return if the feature is enabled
+            "hasGifPickerFeature": bool(self.env["ir.config_parameter"].sudo().get_param("discuss.tenor_api_key")),
             **super()._init_messaging(),
         }

--- a/addons/mail/models/ir_attachment.py
+++ b/addons/mail/models/ir_attachment.py
@@ -62,7 +62,8 @@ class IrAttachment(models.Model):
 
     def _delete_and_notify(self, message=None):
         if message:
-            message.write({})  # to make sure write_date on the message is updated
+            # sudo: mail.message - safe write just updating the date, because guests don't have the rights
+            message.sudo().write({})  # to make sure write_date on the message is updated
         self.env['bus.bus']._sendmany((attachment._bus_notification_target(), 'ir.attachment/delete', {
             'id': attachment.id, 'message': {'id': message.id, 'write_date': message.write_date} if message else None
         }) for attachment in self)

--- a/addons/mail/models/mail_thread.py
+++ b/addons/mail/models/mail_thread.py
@@ -22,7 +22,6 @@ from email.message import EmailMessage
 from email import message_from_string
 from lxml import etree
 from werkzeug import urls
-from werkzeug.exceptions import NotFound
 from xmlrpc import client as xmlrpclib
 from markupsafe import Markup, escape
 
@@ -479,13 +478,6 @@ class MailThread(models.AbstractModel):
         if any(message.message_type != 'comment' for message in messages):
             raise exceptions.UserError(_("Only messages type comment can have their content updated"))
 
-    @api.model
-    def _get_from_context_or_raise(self, thread_id):
-        thread = self.search([["id", "=", thread_id]])
-        if not thread:
-            raise NotFound()
-        return thread
-
     # ------------------------------------------------------
     # TRACKING / LOG
     # ------------------------------------------------------

--- a/addons/mail/models/res_partner.py
+++ b/addons/mail/models/res_partner.py
@@ -6,7 +6,6 @@ import re
 from odoo import _, api, fields, models, tools
 from odoo.osv import expression
 
-
 class Partner(models.Model):
     """ Update partner to add a field about notification preferences. Add a generic opt-out field that can be used
        to restrict usage of automatic email templates. """
@@ -319,7 +318,6 @@ class Partner(models.Model):
 
     @api.model
     def _get_current_persona(self):
-        guest = self.env["mail.guest"]._get_guest_from_context()
-        if self.env.user._is_public() and guest:
-            return (self.env["res.partner"], guest)
+        if not self.env.user or self.env.user._is_public():
+            return (self.env["res.partner"], self.env["mail.guest"]._get_guest_from_context())
         return (self.env.user.partner_id, self.env["mail.guest"])
