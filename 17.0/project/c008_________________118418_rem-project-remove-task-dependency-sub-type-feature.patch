PR: https://github.com/odoo/odoo/pull/118418

From: b4ac7f54fa5b83d1698169d6b89ff4ec93de7804
From: Kartik Chavda
Date: 2023-04-21 16:46:48

Structural Changes: 2
Total Changes: 58

[REM] project: remove task dependency sub-type feature

Before this commit there is a sub-type to notify parent
if child stage change but with new to-do state feature
we don't to unnecessory notification on parent which is
more problemation then informative.

This commit remove task dependency sub-type and it's related
code.

task-3252755

closes odoo/odoo#118418

Related: odoo/enterprise#39972
Related: odoo/upgrade#4542
Signed-off-by: Xavier Bol (xbo) <xbo@odoo.com>

================================= pseudo patch: =================================

--- a/addons/project/models/project_project.py
+++ b/addons/project/models/project_project.py
@@ -543,10 +543,8 @@ class Project(models.Model):
         if not self.rating_active:
             res -= self.env.ref('project.mt_project_task_rating')
         if len(self) == 1:
-            dependency_subtype = self.env.ref('project.mt_project_task_dependency_change')
             waiting_subtype = self.env.ref('project.mt_project_task_waiting')
-            if not self.allow_task_dependencies and dependency_subtype in res:
-                res -= dependency_subtype
+            if not self.allow_task_dependencies and waiting_subtype in res:
                 res -= waiting_subtype
         return res
 

--- a/addons/project/models/project_task.py
+++ b/addons/project/models/project_task.py
@@ -123,7 +123,7 @@ class Task(models.Model):
     stage_id = fields.Many2one('project.task.type', string='Stage', compute='_compute_stage_id',
         store=True, readonly=False, ondelete='restrict', tracking=True, index=True,
         default=_get_default_stage_id, group_expand='_read_group_stage_ids',
-        domain="[('project_ids', '=', project_id)]", task_dependency_tracking=True)
+        domain="[('project_ids', '=', project_id)]")
     tag_ids = fields.Many2many('project.tags', string='Tags')
 
     state = fields.Selection([
@@ -132,14 +132,14 @@ class Task(models.Model):
         ('03_approved', 'Approved'),
         *CLOSED_STATES.items(),
         ('04_waiting_normal', 'Waiting'),
-    ], string='Status', copy=False, default='01_in_progress', required=True, compute='_compute_state', inverse='_inverse_state', readonly=False, store=True, recursive=True, task_dependency_tracking=True, tracking=True)
+    ], string='Status', copy=False, default='01_in_progress', required=True, compute='_compute_state', inverse='_inverse_state', readonly=False, store=True, recursive=True, tracking=True)
 
     create_date = fields.Datetime("Created On", readonly=True)
     write_date = fields.Datetime("Last Updated On", readonly=True)
     date_end = fields.Datetime(string='Ending Date', index=True, copy=False)
     date_assign = fields.Datetime(string='Assigning Date', copy=False, readonly=True,
         help="Date on which this task was last assigned (or unassigned). Based on this, you can get statistics on the time it usually takes to assign tasks.")
-    date_deadline = fields.Date(string='Deadline', index=True, copy=False, tracking=True, task_dependency_tracking=True)
+    date_deadline = fields.Date(string='Deadline', index=True, copy=False, tracking=True)
 
     date_last_stage_update = fields.Datetime(string='Last Stage Update',
         index=True,
@@ -694,19 +694,6 @@ class Task(models.Model):
         )
         return super(Task, self).get_empty_list_help(help)
 
-    def _valid_field_parameter(self, field, name):
-        # If the field has `task_dependency_tracking` on we track the changes made in the dependent task on the parent task
-        return name == 'task_dependency_tracking' or super()._valid_field_parameter(field, name)
-
-    @tools.ormcache('self.env.uid', 'self.env.su')
-    def _get_depends_tracked_fields(self):
-        """ Returns the set of tracked field names for the current model.
-        Those fields are the ones tracked in the parent task when using task dependencies.
-
-        See :meth:`mail.models.MailThread._track_get_fields`"""
-        fields = {name for name, field in self._fields.items() if getattr(field, 'task_dependency_tracking', None)}
-        return fields and set(self.fields_get(fields))
-
     # ----------------------------------------
     # Case management
     # ----------------------------------------
@@ -1179,31 +1166,6 @@ class Task(models.Model):
                         'new_value_char': ', '.join(self[changed_field].mapped('name')),
                     }
                     tracking_value_ids.append(Command.create(vals))
-        # Track changes on depending tasks
-        depends_tracked_fields = self._get_depends_tracked_fields()
-        depends_changes = changes & depends_tracked_fields
-        if depends_changes and self.allow_task_dependencies and self.user_has_groups('project.group_project_task_dependencies'):
-            parent_ids = self.dependent_ids
-            if parent_ids:
-                fields_to_ids = self.env['ir.model.fields']._get_ids('project.task')
-                field_ids = [fields_to_ids.get(name) for name in depends_changes]
-                depends_tracking_value_ids = [
-                    tracking_values for tracking_values in tracking_value_ids
-                    if tracking_values[2]['field'] in field_ids
-                ]
-                subtype = self.env['ir.model.data']._xmlid_to_res_id('project.mt_task_dependency_change')
-                # We want to include the original subtype message coming from the child task
-                # for example when the stage changes the message in the chatter starts with 'Stage Changed'
-                child_subtype = self._track_subtype(dict((col_name, initial_values[col_name]) for col_name in changes))
-                child_subtype_info = child_subtype.description or child_subtype.name if child_subtype else False
-                # NOTE: the subtype does not have a description on purpose, otherwise the description would be put
-                #  at the end of the message instead of at the top, we use the name here
-                body = self.env['ir.qweb']._render('project.task_track_depending_tasks', {
-                    'child': self,
-                    'child_subtype': child_subtype_info,
-                })
-                for p in parent_ids:
-                    p.message_post(body=body, subtype_id=subtype, tracking_value_ids=depends_tracking_value_ids)
         return changes, tracking_value_ids
 
     def _track_template(self, changes):
@@ -1242,12 +1204,10 @@ class Task(models.Model):
         if not self.project_id.rating_active:
             res -= self.env.ref('project.mt_task_rating')
         if len(self) == 1:
-            dependency_subtype = self.env.ref('project.mt_task_dependency_change')
             waiting_subtype = self.env.ref('project.mt_task_waiting')
             if ((self.project_id and not self.project_id.allow_task_dependencies)\
                 or (not self.project_id and not self.user_has_groups('project.group_project_task_dependencies')))\
-                and dependency_subtype in res:
-                res -= dependency_subtype
+                and waiting_subtype in res:
                 res -= waiting_subtype
         return res
 

--- a/addons/project/models/res_config_settings.py
+++ b/addons/project/models/res_config_settings.py
@@ -49,14 +49,8 @@ class ResConfigSettings(models.TransientModel):
                 else:
                     projects[project_flag] = config_feature_enabled
 
-        # Hide the task dependency changes subtype when the dependency setting is disabled
-        task_dep_change_subtype_id = self.env.ref('project.mt_task_dependency_change')
-        project_task_dep_change_subtype_id = self.env.ref('project.mt_project_task_dependency_change')
         task_waiting_subtype_id = self.env.ref('project.mt_task_waiting')
         project_task_waiting_subtype_id = self.env.ref('project.mt_project_task_waiting')
-        if task_dep_change_subtype_id.hidden != (not self['group_project_task_dependencies']):
-            task_dep_change_subtype_id.hidden = not self['group_project_task_dependencies']
-            project_task_dep_change_subtype_id.hidden = not self['group_project_task_dependencies']
         if task_waiting_subtype_id.hidden != (not self['group_project_task_dependencies']):
             task_waiting_subtype_id.hidden = not self['group_project_task_dependencies']
             project_task_waiting_subtype_id.hidden = not self['group_project_task_dependencies']
