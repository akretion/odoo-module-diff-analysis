PR: https://github.com/odoo/odoo/pull/

From: bbca13541053a3ac35ac2ec340b843205117468a
From: Keyur Gajjar
Date: 2016-06-17 09:23:12

Structural Changes: 67.9
Total Changes: 1290

[MIG] mass_mailing: code migration to new api

NB: A controller in website_mass_mailing has been migrated too. It's not a real issue
as this module will also be migrated in the days to come

================================= pseudo patch: =================================

--- a/addons/mass_mailing/models/__init__.py
+++ b/addons/mass_mailing/models/__init__.py
@@ -1,4 +1,5 @@
 # -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
 
 import mass_mailing
 import mass_mailing_stats

--- a/addons/mass_mailing/models/link_tracker.py
+++ b/addons/mass_mailing/models/link_tracker.py
@@ -1,13 +1,15 @@
-from openerp import fields
-from openerp import models
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
 
-class link_tracker(models.Model):
+from odoo import fields, models
+
+class LinkTracker(models.Model):
     _inherit = "link.tracker"
 
     mass_mailing_id = fields.Many2one('mail.mass_mailing', string='Mass Mailing')
     mass_mailing_campaign_id = fields.Many2one('mail.mass_mailing.campaign', string='Mass Mailing Campaign')
 
-class link_tracker_click(models.Model):
+class LinkTrackerClick(models.Model):
     _inherit = "link.tracker.click"
 
     mail_stat_id = fields.Many2one('mail.mail.statistics', string='Mail Statistics')

--- a/addons/mass_mailing/models/mail_mail.py
+++ b/addons/mass_mailing/models/mail_mail.py
@@ -5,78 +5,71 @@ import re
 import urlparse
 import werkzeug.urls
 
-from openerp import tools
-from openerp import SUPERUSER_ID
-from openerp.osv import osv, fields
+from odoo import api, fields, models, tools
 
 
 URL_REGEX = r'(\bhref=[\'"]([^\'"]+)[\'"])'
 
 
-class MailMail(osv.Model):
+class MailMail(models.Model):
     """Add the mass mailing campaign data to mail"""
-    _name = 'mail.mail'
     _inherit = ['mail.mail']
 
-    _columns = {
-        'mailing_id': fields.many2one('mail.mass_mailing', 'Mass Mailing'),
-        'statistics_ids': fields.one2many(
-            'mail.mail.statistics', 'mail_mail_id',
-            string='Statistics',
-        ),
-    }
+    mailing_id = fields.Many2one('mail.mass_mailing', string='Mass Mailing')
+    statistics_ids = fields.One2many('mail.mail.statistics', 'mail_mail_id', string='Statistics')
 
-    def create(self, cr, uid, values, context=None):
+    @api.model
+    def create(self, values):
         """ Override mail_mail creation to create an entry in mail.mail.statistics """
         # TDE note: should be after 'all values computed', to have values (FIXME after merging other branch holding create refactoring)
-        mail_id = super(MailMail, self).create(cr, uid, values, context=context)
+        mail = super(MailMail, self).create(values)
         if values.get('statistics_ids'):
-            mail = self.browse(cr, SUPERUSER_ID, mail_id, context=context)
-            for stat in mail.statistics_ids:
-                self.pool['mail.mail.statistics'].write(cr, uid, [stat.id], {'message_id': mail.message_id, 'state': 'outgoing'}, context=context)
-        return mail_id
+            mail_sudo = mail.sudo()
+            mail_sudo.statistics_ids.write({'message_id': mail_sudo.message_id, 'state': 'outgoing'})
+        return mail
 
-    def _get_tracking_url(self, cr, uid, mail, partner=None, context=None):
-        base_url = self.pool.get('ir.config_parameter').get_param(cr, uid, 'web.base.url')
+    def _get_tracking_url(self, partner=None):
+        base_url = self.env['ir.config_parameter'].get_param('web.base.url')
         track_url = urlparse.urljoin(
             base_url, 'mail/track/%(mail_id)s/blank.gif?%(params)s' % {
-                'mail_id': mail.id,
-                'params': werkzeug.url_encode({'db': cr.dbname})
+                'mail_id': self.id,
+                'params': werkzeug.url_encode({'db': self.env.cr.dbname})
             }
         )
         return '<img src="%s" alt=""/>' % track_url
 
-    def _get_unsubscribe_url(self, cr, uid, mail, email_to, context=None):
-        base_url = self.pool.get('ir.config_parameter').get_param(cr, uid, 'web.base.url')
+    def _get_unsubscribe_url(self, email_to):
+        base_url = self.env['ir.config_parameter'].get_param('web.base.url')
         url = urlparse.urljoin(
             base_url, 'mail/mailing/%(mailing_id)s/unsubscribe?%(params)s' % {
-                'mailing_id': mail.mailing_id.id,
-                'params': werkzeug.url_encode({'db': cr.dbname, 'res_id': mail.res_id, 'email': email_to})
+                'mailing_id': self.mailing_id.id,
+                'params': werkzeug.url_encode({'db': self.env.cr.dbname, 'res_id': self.res_id, 'email': email_to})
             }
         )
         return url
 
-    def send_get_mail_body(self, cr, uid, ids, partner=None, context=None):
+    @api.multi
+    def send_get_mail_body(self, partner=None):
         """ Override to add the tracking URL to the body and to add
         Statistic_id in shorted urls """
         # TDE: temporary addition (mail was parameter) due to semi-new-API
-        body = super(MailMail, self).send_get_mail_body(cr, uid, ids, partner=partner, context=context)
-        mail = self.browse(cr, uid, ids[0], context=context)
+        self.ensure_one()
+        body = super(MailMail, self).send_get_mail_body(partner=partner)
 
         links_blacklist = ['/unsubscribe_from_list']
 
-        if mail.mailing_id and body and mail.statistics_ids:
-            for match in re.findall(URL_REGEX, mail.body_html):
+        if self.mailing_id and body and self.statistics_ids:
+            for match in re.findall(URL_REGEX, self.body_html):
 
                 href = match[0]
                 url = match[1]
 
                 if not [s for s in links_blacklist if s in href]:
-                    new_href = href.replace(url, url + '/m/' + str(mail.statistics_ids[0].id))
+                    new_href = href.replace(url, url + '/m/' + str(self.statistics_ids[0].id))
                     body = body.replace(href, new_href)
 
         # prepend <base> tag for images using absolute urls
-        domain = self.pool.get("ir.config_parameter").get_param(cr, uid, "web.base.url", context=context)
+        domain = self.env["ir.config_parameter"].get_param("web.base.url")
         base = "<base href='%s'>" % domain
         body = tools.append_content_to_html(base, body, plaintext=False, container_tag='div')
         # resolve relative image url to absolute for outlook.com
@@ -86,29 +79,31 @@ class MailMail(osv.Model):
         body = re.sub(r'(<[^>]+\bstyle="[^"]+\burl\(\'?)(/[^/\'][^\'")]+)', _sub_relative2absolute, body)
 
         # generate tracking URL
-        if mail.statistics_ids:
-            tracking_url = self._get_tracking_url(cr, uid, mail, partner, context=context)
+        if self.statistics_ids:
+            tracking_url = self._get_tracking_url(partner)
             if tracking_url:
                 body = tools.append_content_to_html(body, tracking_url, plaintext=False, container_tag='div')
         return body
 
-    def send_get_email_dict(self, cr, uid, ids, partner=None, context=None):
+    @api.multi
+    def send_get_email_dict(self, partner=None):
         # TDE: temporary addition (mail was parameter) due to semi-new-API
-        res = super(MailMail, self).send_get_email_dict(cr, uid, ids, partner, context=context)
-        mail = self.browse(cr, uid, ids[0], context=context)
-        base_url = self.pool.get('ir.config_parameter').get_param(cr, uid, 'web.base.url')
-        if mail.mailing_id and res.get('body') and res.get('email_to'):
+        res = super(MailMail, self).send_get_email_dict(partner)
+        base_url = self.env['ir.config_parameter'].get_param('web.base.url')
+        if self.mailing_id and res.get('body') and res.get('email_to'):
             emails = tools.email_split(res.get('email_to')[0])
             email_to = emails and emails[0] or False
-            unsubscribe_url= self._get_unsubscribe_url(cr, uid, mail, email_to, context=context)
-            link_to_replace =  base_url+'/unsubscribe_from_list'
+            unsubscribe_url = self._get_unsubscribe_url(email_to)
+            link_to_replace = base_url + '/unsubscribe_from_list'
             if link_to_replace in res['body']:
                 res['body'] = res['body'].replace(link_to_replace, unsubscribe_url if unsubscribe_url else '#')
         return res
 
-    def _postprocess_sent_message(self, cr, uid, mail, context=None, mail_sent=True):
-        if mail_sent is True and mail.statistics_ids:
-            self.pool['mail.mail.statistics'].write(cr, uid, [s.id for s in mail.statistics_ids], {'sent': fields.datetime.now(), 'exception': False}, context=context)
-        elif mail_sent is False and mail.statistics_ids:
-            self.pool['mail.mail.statistics'].write(cr, uid, [s.id for s in mail.statistics_ids], {'exception': fields.datetime.now()}, context=context)
-        return super(MailMail, self)._postprocess_sent_message(cr, uid, mail, context=context, mail_sent=mail_sent)
+    @api.multi
+    def _postprocess_sent_message_v9(self, mail_sent=True):
+        for mail in self:
+            if mail_sent is True and mail.statistics_ids:
+                mail.statistics_ids.write({'sent': fields.Datetime.now(), 'exception': False})
+            elif mail_sent is False and mail.statistics_ids:
+                mail.statistics_ids.write({'exception': fields.Datetime.now()})
+        return super(MailMail, self)._postprocess_sent_message_v9(mail_sent=mail_sent)

--- a/addons/mass_mailing/models/mail_thread.py
+++ b/addons/mass_mailing/models/mail_thread.py
@@ -4,24 +4,25 @@
 import logging
 import re
 
-from openerp.addons.mail.models.mail_message import decode
-from openerp.addons.mail.models.mail_thread import decode_header
-from openerp.osv import osv
+from odoo import api, models
+
+from odoo.addons.mail.models.mail_message import decode
+from odoo.addons.mail.models.mail_thread import decode_header
+
 
 _logger = logging.getLogger(__name__)
 
 
-class MailThread(osv.AbstractModel):
+class MailThread(models.AbstractModel):
     """ Update MailThread to add the feature of bounced emails and replied emails
     in message_process. """
-    _name = 'mail.thread'
-    _inherit = ['mail.thread']
+    _inherit = 'mail.thread'
 
-    def message_route_check_bounce(self, cr, uid, message, context=None):
+    def message_route_check_bounce(self, message):
         """ Override to verify that the email_to is the bounce alias. If it is the
         case, log the bounce, set the parent and related document as bounced and
         return False to end the routing process. """
-        bounce_alias = self.pool['ir.config_parameter'].get_param(cr, uid, "mail.bounce.alias", context=context)
+        bounce_alias = self.env['ir.config_parameter'].get_param("mail.bounce.alias")
         message_id = message.get('Message-Id')
         email_from = decode_header(message, 'From')
         email_to = decode_header(message, 'To')
@@ -36,38 +37,39 @@ class MailThread(osv.AbstractModel):
             if bounce_match:
                 bounced_model, bounced_thread_id = None, False
                 bounced_mail_id = bounce_match.group(1)
-                stat_ids = self.pool['mail.mail.statistics'].set_bounced(cr, uid, mail_mail_ids=[bounced_mail_id], context=context)
-                for stat in self.pool['mail.mail.statistics'].browse(cr, uid, stat_ids, context=context):
+                statistics = self.env['mail.mail.statistics'].set_bounced(mail_mail_ids=[bounced_mail_id])
+                for stat in statistics:
                     bounced_model = stat.model
                     bounced_thread_id = stat.res_id
                 _logger.info('Routing mail from %s to %s with Message-Id %s: bounced mail from mail %s, model: %s, thread_id: %s',
                              email_from, email_to, message_id, bounced_mail_id, bounced_model, bounced_thread_id)
-                if bounced_model and bounced_model in self.pool and hasattr(self.pool[bounced_model], 'message_receive_bounce') and bounced_thread_id:
-                    self.pool[bounced_model].message_receive_bounce(cr, uid, [bounced_thread_id], mail_id=bounced_mail_id, context=context)
+                if bounced_model and bounced_model in self.pool and hasattr(self.env[bounced_model], 'message_receive_bounce') and bounced_thread_id:
+                    self.env[bounced_model].browse(bounced_thread_id).message_receive_bounce(mail_id=bounced_mail_id)
                 return False
 
         return True
 
-    def message_route(self, cr, uid, message, message_dict, model=None, thread_id=None,
-                      custom_values=None, context=None):
-        if not self.message_route_check_bounce(cr, uid, message, context=context):
+    @api.model
+    def message_route(self, message, message_dict, model=None, thread_id=None, custom_values=None):
+        if not self.message_route_check_bounce(message):
             return []
-        return super(MailThread, self).message_route(cr, uid, message, message_dict, model, thread_id, custom_values, context)
+        return super(MailThread, self).message_route(message, message_dict, model, thread_id, custom_values)
 
-    def message_receive_bounce(self, cr, uid, ids, mail_id=None, context=None):
+    def message_receive_bounce(self, mail_id=None):
         """Called by ``message_process`` when a bounce email (such as Undelivered
         Mail Returned to Sender) is received for an existing thread. The default
         behavior is to check is an integer  ``message_bounce`` column exists.
         If it is the case, its content is incremented. """
         if 'message_bounce' in self._fields:
-            for obj in self.browse(cr, uid, ids, context=context):
-                self.write(cr, uid, [obj.id], {'message_bounce': obj.message_bounce + 1}, context=context)
+            for mail_thread in self:
+                mail_thread.message_bounce = mail_thread.message_bounce + 1
 
-    def message_route_process(self, cr, uid, message, message_dict, routes, context=None):
+    @api.model
+    def message_route_process(self, message, message_dict, routes):
         """ Override to update the parent mail statistics. The parent is found
         by using the References header of the incoming message and looking for
         matching message_id in mail.mail.statistics. """
         if message.get('References'):
             message_ids = [x.strip() for x in decode(message['References']).split()]
-            self.pool['mail.mail.statistics'].set_replied(cr, uid, mail_message_ids=message_ids, context=context)
-        return super(MailThread, self).message_route_process(cr, uid, message, message_dict, routes, context=context)
+            self.env['mail.mail.statistics'].set_replied(mail_message_ids=message_ids)
+        return super(MailThread, self).message_route_process(message, message_dict, routes)

--- a/addons/mass_mailing/models/mass_mailing.py
+++ b/addons/mass_mailing/models/mass_mailing.py
@@ -1,57 +1,35 @@
 # -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
 
 from datetime import datetime
 import random
 
-from openerp import _
-from openerp import tools
-from openerp import SUPERUSER_ID
-from openerp.exceptions import UserError
-from openerp.tools.misc import DEFAULT_SERVER_DATETIME_FORMAT
-from openerp.tools.safe_eval import safe_eval as eval
-from openerp.osv import osv, fields
+from odoo import api, fields, models, _
+from odoo.exceptions import UserError
+from odoo.tools.safe_eval import safe_eval as eval
 
 
-class MassMailingTag(osv.Model):
+class MassMailingTag(models.Model):
     """Model of categories of mass mailing, i.e. marketing, newsletter, ... """
     _name = 'mail.mass_mailing.tag'
     _description = 'Mass Mailing Tag'
     _order = 'name'
 
-    _columns = {
-        'name': fields.char('Name', required=True),
-        'color': fields.integer('Color Index'),
-    }
+    name = fields.Char(required=True)
+    color = fields.Integer(string='Color Index')
+
     _sql_constraints = [
             ('name_uniq', 'unique (name)', "Tag name already exists !"),
     ]
 
-class MassMailingList(osv.Model):
+
+class MassMailingList(models.Model):
     """Model of a contact list. """
     _name = 'mail.mass_mailing.list'
     _order = 'name'
     _description = 'Mailing List'
 
-    def _get_contact_nbr(self, cr, uid, ids, name, arg, context=None):
-        result = dict.fromkeys(ids, 0)
-        Contacts = self.pool.get('mail.mass_mailing.contact')
-        for group in Contacts.read_group(cr, uid, [('list_id', 'in', ids), ('opt_out', '!=', True)], ['list_id'], ['list_id'], context=context):
-            result[group['list_id'][0]] = group['list_id_count']
-        return result
-
-    _columns = {
-        'name': fields.char('Mailing List', required=True),
-        'active': fields.boolean('Active'),
-        'create_date': fields.datetime('Creation Date'),
-        'contact_nbr': fields.function(
-            _get_contact_nbr, type='integer',
-            string='Number of Contacts',
-        ),
-        'popup_content': fields.html("Website Popup Content", translate=True, sanitize=False),
-        'popup_redirect_url': fields.char("Website Popup Redirect URL"),
-    }
-
-    def _get_default_popup_content(self, cr, uid, context=None):
+    def _default_popup_content(self):
         return """<div class="modal-header text-center">
     <h3 class="modal-title mt8">Odoo Presents</h3>
 </div>
@@ -62,14 +40,20 @@ class MassMailingList(osv.Model):
 </div>
 <p class="o_message_paragraph">Join our Marketing newsletter and get <strong>this white paper instantly</strong></p>"""
 
-    _defaults = {
-        'active': True,
-        'popup_content': _get_default_popup_content,
-        'popup_redirect_url': '/',
-    }
+    name = fields.Char(string='Mailing List', required=True)
+    active = fields.Boolean(default=True)
+    create_date = fields.Datetime(string='Creation Date')
+    contact_nbr = fields.Integer(compute="_compute_contact_nbr", string='Number of Contacts')
+    popup_content = fields.Html(string="Website Popup Content", translate=True, sanitize=False, default=_default_popup_content)
+    popup_redirect_url = fields.Char(string="Website Popup Redirect URL", default='/')
 
+    def _compute_contact_nbr(self):
+        contacts_data = self.env['mail.mass_mailing.contact'].read_group([('list_id', 'in', self.ids), ('opt_out', '!=', True)], ['list_id'], ['list_id'])
+        mapped_data = dict([(c['list_id'][0], c['list_id_count']) for c in contacts_data])
+        for mailing_list in self:
+            mailing_list.contact_nbr = mapped_data.get(mailing_list.id, 0)
 
-class MassMailingContact(osv.Model):
+class MassMailingContact(models.Model):
     """Model of a contact. This model is different from the partner model
     because it holds only some basic information: name, email. The purpose is to
     be able to deal with large contact list to email without bloating the partner
@@ -80,102 +64,134 @@ class MassMailingContact(osv.Model):
     _order = 'email'
     _rec_name = 'email'
 
-    _columns = {
-        'name': fields.char('Name'),
-        'email': fields.char('Email', required=True),
-        'create_date': fields.datetime('Create Date'),
-        'list_id': fields.many2one(
-            'mail.mass_mailing.list', string='Mailing List',
-            ondelete='cascade', required=True,
-        ),
-        'opt_out': fields.boolean('Opt Out', help='The contact has chosen not to receive mails anymore from this list'),
-        'unsubscription_date': fields.datetime('Unsubscription Date'),
-        'message_bounce': fields.integer('Bounce', help='Counter of the number of bounced emails for this contact.'),
-    }
-
-    def _get_latest_list(self, cr, uid, context={}):
-        lid = self.pool.get('mail.mass_mailing.list').search(cr, uid, [], limit=1, order='id desc', context=context)
-        return lid and lid[0] or False
-
-    _defaults = {
-        'list_id': _get_latest_list
-    }
-
-    def on_change_opt_out(self, cr, uid, id, opt_out, context=None):
-        return {'value': {
-            'unsubscription_date': opt_out and fields.datetime.now() or False,
-        }}
-
-    def create(self, cr, uid, vals, context=None):
+    name = fields.Char()
+    email = fields.Char(required=True)
+    create_date = fields.Datetime(string='Create Date')
+    list_id = fields.Many2one(
+        'mail.mass_mailing.list', string='Mailing List',
+        ondelete='cascade', required=True, default=lambda self: self.env['mail.mass_mailing.list'].search([], limit=1, order='id desc'))
+    opt_out = fields.Boolean(string='Opt Out', help='The contact has chosen not to receive mails anymore from this list')
+    unsubscription_date = fields.Datetime(string='Unsubscription Date')
+    message_bounce = fields.Integer(string='Bounce', help='Counter of the number of bounced emails for this contact.')
+
+    @api.model
+    def create(self, vals):
         if 'opt_out' in vals:
-            vals['unsubscription_date'] = vals['opt_out'] and fields.datetime.now() or False
-        return super(MassMailingContact, self).create(cr, uid, vals, context=context)
+            vals['unsubscription_date'] = vals['opt_out'] and fields.Datetime.now()
+        return super(MassMailingContact, self).create(vals)
 
-    def write(self, cr, uid, ids, vals, context=None):
+    @api.multi
+    def write(self, vals):
         if 'opt_out' in vals:
-            vals['unsubscription_date'] = vals['opt_out'] and fields.datetime.now() or False
-        return super(MassMailingContact, self).write(cr, uid, ids, vals, context=context)
+            vals['unsubscription_date'] = vals['opt_out'] and fields.Datetime.now()
+        return super(MassMailingContact, self).write(vals)
 
-    def get_name_email(self, name, context):
-        name, email = self.pool['res.partner']._parse_partner_name(name, context=context)
+    def get_name_email(self, name):
+        name, email = self.env['res.partner']._parse_partner_name(name)
         if name and not email:
             email = name
         if email and not name:
             name = email
         return name, email
 
-    def name_create(self, cr, uid, name, context=None):
-        name, email = self.get_name_email(name, context=context)
-        rec_id = self.create(cr, uid, {'name': name, 'email': email}, context=context)
-        return self.name_get(cr, uid, [rec_id], context)[0]
+    @api.model
+    def name_create(self, name):
+        name, email = self.get_name_email(name)
+        contact = self.create({'name': name, 'email': email})
+        return contact.name_get()[0]
 
-    def add_to_list(self, cr, uid, name, list_id, context=None):
-        name, email = self.get_name_email(name, context=context)
-        rec_id = self.create(cr, uid, {'name': name, 'email': email, 'list_id': list_id}, context=context)
-        return self.name_get(cr, uid, [rec_id], context)[0]
+    @api.model
+    def add_to_list(self, name, list_id):
+        name, email = self.get_name_email(name)
+        contact = self.create({'name': name, 'email': email, 'list_id': list_id})
+        return contact.name_get()[0]
 
-    def message_get_default_recipients(self, cr, uid, ids, context=None):
-        res = {}
-        for record in self.browse(cr, uid, ids, context=context):
-            res[record.id] = {'partner_ids': [], 'email_to': record.email, 'email_cc': False}
-        return res
+    @api.multi
+    def message_get_default_recipients(self):
+        return dict((record.id, {'partner_ids': [], 'email_to': record.email, 'email_cc': False}) for record in self)
 
-    def message_receive_bounce(self, cr, uid, ids, mail_id=None, context=None):
+    def message_receive_bounce(self, mail_id=None):
         """Called by ``message_process`` when a bounce email (such as Undelivered
         Mail Returned to Sender) is received for an existing thread. As contacts
         do not inherit form mail.thread, we have to define this method to be able
         to track bounces (see mail.thread for more details). """
-        for obj in self.browse(cr, uid, ids, context=context):
-            self.write(cr, uid, [obj.id], {'message_bounce': obj.message_bounce + 1}, context=context)
+        for contact in self:
+            contact.message_bounce = contact.message_bounce + 1
+
 
+class MassMailingStage(models.Model):
 
-class MassMailingStage(osv.Model):
     """Stage for mass mailing campaigns. """
     _name = 'mail.mass_mailing.stage'
     _description = 'Mass Mailing Campaign Stage'
     _order = 'sequence'
 
-    _columns = {
-        'name': fields.char('Name', required=True, translate=True),
-        'sequence': fields.integer('Sequence'),
-    }
-
-    _defaults = {
-        'sequence': 0,
-    }
+    name = fields.Char(required=True, translate=True)
+    sequence = fields.Integer()
 
 
-class MassMailingCampaign(osv.Model):
+class MassMailingCampaign(models.Model):
     """Model of mass mailing campaigns. """
     _name = "mail.mass_mailing.campaign"
     _description = 'Mass Mailing Campaign'
     _rec_name = "campaign_id"
     _inherits = {'utm.campaign': 'campaign_id'}
 
-    def _get_statistics(self, cr, uid, ids, name, arg, context=None):
+    stage_id = fields.Many2one('mail.mass_mailing.stage', string='Stage', required=True, 
+        default=lambda self: self.env['mail.mass_mailing.stage'].search([], limit=1))
+    user_id = fields.Many2one(
+        'res.users', string='Responsible',
+        required=True, default=lambda self: self.env.uid)
+    campaign_id = fields.Many2one('utm.campaign', 'campaign_id',
+        required=True, ondelete='cascade',  help="This name helps you tracking your different campaign efforts, e.g. Fall_Drive, Christmas_Special")
+    source_id = fields.Many2one('utm.source', string='Source',
+            help="This is the link source, e.g. Search Engine, another domain,or name of email list", default=lambda self: self.env.ref('utm.utm_source_newsletter'))
+    medium_id = fields.Many2one('utm.medium', string='Medium',
+            help="This is the delivery method, e.g. Postcard, Email, or Banner Ad", default=lambda self: self.env.ref('utm.utm_medium_email'))
+    tag_ids = fields.Many2many(
+        'mail.mass_mailing.tag', 'mail_mass_mailing_tag_rel',
+        'tag_id', 'campaign_id', string='Tags')
+    mass_mailing_ids = fields.One2many(
+        'mail.mass_mailing', 'mass_mailing_campaign_id',
+        string='Mass Mailings')
+    unique_ab_testing = fields.Boolean(string='AB Testing',
+        help='If checked, recipients will be mailed only once, allowing to send '
+             'various mailings in a single campaign to test the effectiveness '
+             'of the mailings.')
+    color = fields.Integer(string='Color Index')
+    clicks_ratio = fields.Integer(compute="_compute_clicks_ratio", string="Number of clicks")
+    # stat fields
+    total = fields.Integer(compute="_compute_statistics")
+    scheduled = fields.Integer(compute="_compute_statistics")
+    failed = fields.Integer(compute="_compute_statistics")
+    sent = fields.Integer(compute="_compute_statistics", string="Sent Emails")
+    delivered = fields.Integer(compute="_compute_statistics")
+    opened = fields.Integer(compute="_compute_statistics")
+    replied = fields.Integer(compute="_compute_statistics")
+    bounced = fields.Integer(compute="_compute_statistics")
+    received_ratio = fields.Integer(compute="_compute_statistics", string='Received Ratio')
+    opened_ratio = fields.Integer(compute="_compute_statistics", string='Opened Ratio')
+    replied_ratio = fields.Integer(compute="_compute_statistics", string='Replied Ratio')
+    bounced_ratio = fields.Integer(compute="_compute_statistics", string='Bounced Ratio')
+    total_mailings = fields.Integer(compute="_compute_total_mailings", string='Mailings')
+
+    def _compute_clicks_ratio(self):
+        self.env.cr.execute("""
+            SELECT COUNT(DISTINCT(stats.id)) AS nb_mails, COUNT(DISTINCT(clicks.mail_stat_id)) AS nb_clicks, stats.mass_mailing_campaign_id AS id
+            FROM mail_mail_statistics AS stats
+            LEFT OUTER JOIN link_tracker_click AS clicks ON clicks.mail_stat_id = stats.id
+            WHERE stats.mass_mailing_campaign_id IN %s
+            GROUP BY stats.mass_mailing_campaign_id
+        """, (tuple(self.ids), ))
+
+        campaign_data = self.env.cr.dictfetchall()
+        mapped_data = dict([(c['id'], 100 * c['nb_clicks'] / c['nb_mails']) for c in campaign_data])
+        for campaign in self:
+            campaign.clicks_ratio = mapped_data.get(campaign.id, 0)
+
+    def _compute_statistics(self):
         """ Compute statistics of the mass mailing campaign """
-        results = {}
-        cr.execute("""
+        self.env.cr.execute("""
             SELECT
                 c.id as campaign_id,
                 COUNT(s.id) AS total,
@@ -195,160 +211,48 @@ class MassMailingCampaign(osv.Model):
                 c.id IN %s
             GROUP BY
                 c.id
-        """, (tuple(ids), ))
-        for row in cr.dictfetchall():
-            results[row.pop('campaign_id')] = row
+        """, (tuple(self.ids), ))
+
+        for row in self.env.cr.dictfetchall():
             total = row['total'] or 1
             row['delivered'] = row['sent'] - row['bounced']
             row['received_ratio'] = 100.0 * row['delivered'] / total
             row['opened_ratio'] = 100.0 * row['opened'] / total
             row['replied_ratio'] = 100.0 * row['replied'] / total
             row['bounced_ratio'] = 100.0 * row['bounced'] / total
-        return results
-
-    def _get_clicks_ratio(self, cr, uid, ids, name, arg, context=None):
-        res = dict.fromkeys(ids, 0)
-        cr.execute("""
-            SELECT COUNT(DISTINCT(stats.id)) AS nb_mails, COUNT(DISTINCT(clicks.mail_stat_id)) AS nb_clicks, stats.mass_mailing_campaign_id AS id 
-            FROM mail_mail_statistics AS stats
-            LEFT OUTER JOIN link_tracker_click AS clicks ON clicks.mail_stat_id = stats.id
-            WHERE stats.mass_mailing_campaign_id IN %s
-            GROUP BY stats.mass_mailing_campaign_id
-        """, (tuple(ids), ))
-
-        for record in cr.dictfetchall():
-            res[record['id']] = 100 * record['nb_clicks'] / record['nb_mails']
-
+            self.browse(row.pop('campaign_id')).update(row)
+
+    def _compute_total_mailings(self):
+        campaign_data = self.env['mail.mass_mailing'].read_group(
+            [('mass_mailing_campaign_id', 'in', self.ids)],
+            ['mass_mailing_campaign_id'], ['mass_mailing_campaign_id'])
+        mapped_data = dict([(c['mass_mailing_campaign_id'][0], c['mass_mailing_campaign_id_count']) for c in campaign_data])
+        for campaign in self:
+            campaign.total_mailings = mapped_data.get(campaign.id, 0)
+
+    @api.multi
+    def mass_mailing_statistics_action(self):
+        res = self.env.ref('mass_mailing.action_view_mass_mailing_statistics')
+        res['domain'] = [('mass_mailing_campaign_id', 'in', self.ids)]
         return res
 
-    def _get_total_mailings(self, cr, uid, ids, field_name, arg, context=None):
-        result = dict.fromkeys(ids, 0)
-        for mail in self.pool['mail.mass_mailing'].read_group(cr, uid, [('mass_mailing_campaign_id', 'in', ids)], ['mass_mailing_campaign_id'], ['mass_mailing_campaign_id'], context=context):
-            result[mail['mass_mailing_campaign_id'][0]] = mail['mass_mailing_campaign_id_count']
-        return result
-
-    _columns = {
-        'stage_id': fields.many2one('mail.mass_mailing.stage', 'Stage', required=True),
-        'user_id': fields.many2one(
-            'res.users', 'Responsible',
-            required=True,
-        ),
-        'campaign_id': fields.many2one('utm.campaign', 'campaign_id', 
-            required=True, ondelete='cascade',
-            help="This name helps you tracking your different campaign efforts, e.g. Fall_Drive, Christmas_Special"),
-        'source_id':fields.many2one('utm.source', 'Source',
-            help="This is the link source, e.g. Search Engine, another domain,or name of email list"),
-        'medium_id': fields.many2one('utm.medium', 'Medium',
-            help="This is the delivery method, e.g. Postcard, Email, or Banner Ad"),
-        'tag_ids': fields.many2many(
-            'mail.mass_mailing.tag', 'mail_mass_mailing_tag_rel',
-            'tag_id', 'campaign_id', string='Tags'),
-        'mass_mailing_ids': fields.one2many(
-            'mail.mass_mailing', 'mass_mailing_campaign_id',
-            'Mass Mailings',
-        ),
-        'unique_ab_testing': fields.boolean(
-            'AB Testing',
-            help='If checked, recipients will be mailed only once, allowing to send '
-                 'various mailings in a single campaign to test the effectiveness '
-                 'of the mailings.'),
-        'color': fields.integer('Color Index'),
-        'clicks_ratio': fields.function(
-            _get_clicks_ratio, string="Number of clicks",
-            type="integer",
-        ),
-        # stat fields
-        'total': fields.function(
-            _get_statistics, string='Total',
-            type='integer', multi='_get_statistics'
-        ),
-        'scheduled': fields.function(
-            _get_statistics, string='Scheduled',
-            type='integer', multi='_get_statistics'
-        ),
-        'failed': fields.function(
-            _get_statistics, string='Failed',
-            type='integer', multi='_get_statistics'
-        ),
-        'sent': fields.function(
-            _get_statistics, string='Sent Emails',
-            type='integer', multi='_get_statistics'
-        ),
-        'delivered': fields.function(
-            _get_statistics, string='Delivered',
-            type='integer', multi='_get_statistics',
-        ),
-        'opened': fields.function(
-            _get_statistics, string='Opened',
-            type='integer', multi='_get_statistics',
-        ),
-        'replied': fields.function(
-            _get_statistics, string='Replied',
-            type='integer', multi='_get_statistics'
-        ),
-        'bounced': fields.function(
-            _get_statistics, string='Bounced',
-            type='integer', multi='_get_statistics'
-        ),
-        'received_ratio': fields.function(
-            _get_statistics, string='Received Ratio',
-            type='integer', multi='_get_statistics',
-        ),
-        'opened_ratio': fields.function(
-            _get_statistics, string='Opened Ratio',
-            type='integer', multi='_get_statistics',
-        ),
-        'replied_ratio': fields.function(
-            _get_statistics, string='Replied Ratio',
-            type='integer', multi='_get_statistics',
-        ),
-        'total_mailings': fields.function(_get_total_mailings, string='Mailings', type='integer'),
-        'bounced_ratio': fields.function(
-            _get_statistics, string='Bounced Ratio',
-            type='integer', multi='_get_statistics',
-        ),
-    }
-
-    def _get_default_stage_id(self, cr, uid, context=None):
-        stage_ids = self.pool['mail.mass_mailing.stage'].search(cr, uid, [], limit=1, context=context)
-        return stage_ids and stage_ids[0] or False
-
-    def _get_source_id(self, cr, uid, context=None):
-        return self.pool['ir.model.data'].xmlid_to_res_id(cr, uid, 'utm.utm_source_newsletter')
-
-    def _get_medium_id(self, cr, uid, context=None):
-        return self.pool['ir.model.data'].xmlid_to_res_id(cr, uid, 'utm.utm_medium_email')
-
-    _defaults = {
-        'user_id': lambda self, cr, uid, ctx=None: uid,
-        'stage_id': lambda self, *args: self._get_default_stage_id(*args),
-        'source_id': lambda self, *args: self._get_source_id(*args),
-        'medium_id': lambda self,*args: self._get_medium_id(*args),
-    }
-
-    def mass_mailing_statistics_action(self, cr, uid, ids, context=None):
-        res = self.pool['ir.actions.act_window'].for_xml_id(cr, uid, 'mass_mailing', 'action_view_mass_mailing_statistics', context=context)
-        res['domain'] = [('mass_mailing_campaign_id', 'in', ids)]
-        return res
-
-    def get_recipients(self, cr, uid, ids, model=None, context=None):
+    def get_recipients(self, model=None):
         """Return the recipients of a mailing campaign. This is based on the statistics
         build for each mailing. """
-        Statistics = self.pool['mail.mail.statistics']
-        res = dict.fromkeys(ids, False)
-        for cid in ids:
-            domain = [('mass_mailing_campaign_id', '=', cid)]
+        res = dict.fromkeys(self.ids, {})
+        for campaign in self:
+            domain = [('mass_mailing_campaign_id', '=', campaign.id)]
             if model:
                 domain += [('model', '=', model)]
-            stat_ids = Statistics.search(cr, uid, domain, context=context)
-            res[cid] = set(stat.res_id for stat in Statistics.browse(cr, uid, stat_ids, context=context))
+            res[campaign.id] = set(self.env['mail.mail.statistics'].search(domain).mapped('res_id'))
         return res
 
-    def read_group(self, cr, uid, domain, fields, groupby, offset=0, limit=None, context=None, orderby=False, lazy=True):
+    @api.model
+    def read_group(self, domain, fields, groupby, offset=0, limit=None, orderby=False, lazy=True):
         """ Override read_group to always display all states. """
         if groupby and groupby[0] == "stage_id":
             # Default result structure
-            states_read = self.pool['mail.mass_mailing.stage'].search_read(cr, uid, [], ['name'], context=context)
+            states_read = self.env['mail.mass_mailing.stage'].search_read([], ['name'])
             states = [(state['id'], state['name']) for state in states_read]
             read_group_all_states = [{
                 '__context': {'group_by': groupby[1:]},
@@ -357,7 +261,7 @@ class MassMailingCampaign(osv.Model):
                 'state_count': 0,
             } for state_value, state_name in states]
             # Get standard results
-            read_group_res = super(MassMailingCampaign, self).read_group(cr, uid, domain, fields, groupby, offset=offset, limit=limit, context=context, orderby=orderby)
+            read_group_res = super(MassMailingCampaign, self).read_group(domain, fields, groupby, offset=offset, limit=limit, orderby=orderby)
             # Update standard results with default results
             result = []
             for state_value, state_name in states:
@@ -368,10 +272,10 @@ class MassMailingCampaign(osv.Model):
                 result.append(res[0])
             return result
         else:
-            return super(MassMailingCampaign, self).read_group(cr, uid, domain, fields, groupby, offset=offset, limit=limit, context=context, orderby=orderby)
+            return super(MassMailingCampaign, self).read_group(domain, fields, groupby, offset=offset, limit=limit, orderby=orderby)
 
 
-class MassMailing(osv.Model):
+class MassMailing(models.Model):
     """ MassMailing models a wave of emails for a mass mailign campaign.
     A mass mailing is an occurence of sending emails. """
 
@@ -380,14 +284,106 @@ class MassMailing(osv.Model):
     # number of periods for tracking mail_mail statistics
     _period_number = 6
     _order = 'sent_date DESC'
-    # _send_trigger = 5  # Number under which mails are send directly
     _inherits = {'utm.source': 'source_id'}
     _rec_name = "source_id"
 
-    def _get_statistics(self, cr, uid, ids, name, arg, context=None):
+    @api.model
+    def default_get(self, fields):
+        res = super(MassMailing, self).default_get(fields)
+        if 'reply_to_mode' in fields and not 'reply_to_mode' in res and res.get('mailing_model'):
+            if res['mailing_model'] in ['res.partner', 'mail.mass_mailing.contact']:
+                res['reply_to_mode'] = 'email'
+            else:
+                res['reply_to_mode'] = 'thread'
+        return res
+
+    def _get_mailing_model(self):
+        res = []
+        for model_name in self.env:
+            model = self.env[model_name]
+            if hasattr(model, '_mail_mass_mailing') and getattr(model, '_mail_mass_mailing'):
+                if getattr(model, 'message_mass_mailing_enabled'):
+                    res.append((model._name, model.message_mass_mailing_enabled()))
+                else:
+                    res.append((model._name, model._mail_mass_mailing))
+        res.append(('mail.mass_mailing.contact', _('Mailing List')))
+        return res
+
+    # indirections for inheritance
+    _mailing_model = lambda self: self._get_mailing_model()
+
+    active = fields.Boolean(default=True)
+    email_from = fields.Char(string='From', required=True,
+        default=lambda self: self.env['mail.message']._get_default_from())
+    create_date = fields.Datetime(string='Creation Date')
+    sent_date = fields.Datetime(string='Sent Date', oldname='date', copy=False)
+    schedule_date = fields.Datetime(string='Schedule in the Future')
+    body_html = fields.Html(string='Body', translate=True)
+    attachment_ids = fields.Many2many('ir.attachment', 'mass_mailing_ir_attachments_rel',
+        'mass_mailing_id', 'attachment_id', string='Attachments')
+    keep_archives = fields.Boolean(string='Keep Archives')
+    mass_mailing_campaign_id = fields.Many2one('mail.mass_mailing.campaign', string='Mass Mailing Campaign')
+    campaign_id = fields.Many2one('utm.campaign', string='Campaign',
+                                  help="This name helps you tracking your different campaign efforts, e.g. Fall_Drive, Christmas_Special")
+    source_id = fields.Many2one('utm.source', string='Subject', required=True, ondelete='cascade',
+                                help="This is the link source, e.g. Search Engine, another domain, or name of email list")
+    medium_id = fields.Many2one('utm.medium', string='Medium',
+                                help="This is the delivery method, e.g. Postcard, Email, or Banner Ad", default=lambda self: self.env.ref('utm.utm_medium_email'))
+    clicks_ratio = fields.Integer(compute="_compute_clicks_ratio", string="Number of Clicks")
+    state = fields.Selection([('draft', 'Draft'), ('in_queue', 'In Queue'), ('sending', 'Sending'), ('done', 'Sent')],
+        string='Status', required=True, copy=False, default='draft')
+    color = fields.Integer(related='mass_mailing_campaign_id.color', string='Color Index')
+    # mailing options
+    reply_to_mode = fields.Selection(
+        [('thread', 'Followers of leads/applicants'), ('email', 'Specified Email Address')],
+        string='Reply-To Mode', required=True)
+    reply_to = fields.Char(string='Reply To', help='Preferred Reply-To Address',
+        default=lambda self: self.env['mail.message']._get_default_from())
+    # recipients
+    mailing_model = fields.Selection(selection=_mailing_model, string='Recipients Model', required=True, default='mail.mass_mailing.contact')
+    mailing_domain = fields.Char(string='Domain', oldname='domain', default=[])
+    contact_list_ids = fields.Many2many('mail.mass_mailing.list', 'mail_mass_mailing_list_rel',
+        string='Mailing Lists')
+    contact_ab_pc = fields.Integer(string='A/B Testing percentage',
+        help='Percentage of the contacts that will be mailed. Recipients will be taken randomly.', default=100)
+    # statistics data
+    statistics_ids = fields.One2many('mail.mail.statistics', 'mass_mailing_id', string='Emails Statistics')
+    total = fields.Integer(compute="_compute_total")
+    scheduled = fields.Integer(compute="_compute_statistics")
+    failed = fields.Integer(compute="_compute_statistics")
+    sent = fields.Integer(compute="_compute_statistics")
+    delivered = fields.Integer(compute="_compute_statistics")
+    opened = fields.Integer(compute="_compute_statistics")
+    replied = fields.Integer(compute="_compute_statistics")
+    bounced = fields.Integer(compute="_compute_statistics")
+    failed = fields.Integer(compute="_compute_statistics")
+    received_ratio = fields.Integer(compute="_compute_statistics", string='Received Ratio')
+    opened_ratio = fields.Integer(compute="_compute_statistics", string='Opened Ratio')
+    replied_ratio = fields.Integer(compute="_compute_statistics", string='Replied Ratio')
+    bounced_ratio = fields.Integer(compute="_compute_statistics", String='Bounced Ratio')
+    next_departure = fields.Datetime(compute="_compute_next_departure", string='Next Departure')
+
+    def _compute_total(self):
+        for mass_mailing in self:
+            mass_mailing.total = len(mass_mailing.sudo().get_recipients())
+
+    def _compute_clicks_ratio(self):
+        self.env.cr.execute("""
+            SELECT COUNT(DISTINCT(stats.id)) AS nb_mails, COUNT(DISTINCT(clicks.mail_stat_id)) AS nb_clicks, stats.mass_mailing_id AS id
+            FROM mail_mail_statistics AS stats
+            LEFT OUTER JOIN link_tracker_click AS clicks ON clicks.mail_stat_id = stats.id
+            WHERE stats.mass_mailing_id IN %s
+            GROUP BY stats.mass_mailing_id
+        """, (tuple(self.ids), ))
+
+        mass_mailing_data = self.env.cr.dictfetchall()
+        mapped_data = dict([(m['id'], 100 * m['nb_clicks'] / m['nb_mails']) for m in mass_mailing_data])
+        for mass_mailing in self:
+            mass_mailing.clicks_ratio = mapped_data.get(mass_mailing.id, 0)
+
+    def _compute_statistics(self):
         """ Compute statistics of the mass mailing """
-        results = {}
-        cr.execute("""
+        self.env.cr.execute("""
             SELECT
                 m.id as mailing_id,
                 COUNT(s.id) AS total,
@@ -408,230 +404,68 @@ class MassMailing(osv.Model):
                 m.id IN %s
             GROUP BY
                 m.id
-        """, (tuple(ids), ))
-        for row in cr.dictfetchall():
-            results[row.pop('mailing_id')] = row
-            total = row['total'] or 1
+        """, (tuple(self.ids), ))
+        for row in self.env.cr.dictfetchall():
+            total = row.pop('total') or 1
             row['received_ratio'] = 100.0 * row['delivered'] / total
             row['opened_ratio'] = 100.0 * row['opened'] / total
             row['replied_ratio'] = 100.0 * row['replied'] / total
             row['bounced_ratio'] = 100.0 * row['bounced'] / total
-        return results
-
-    def _get_mailing_model(self, cr, uid, context=None):
-        res = []
-        for model_name in self.pool:
-            model = self.pool[model_name]
-            if hasattr(model, '_mail_mass_mailing') and getattr(model, '_mail_mass_mailing'):
-                if getattr(model, 'message_mass_mailing_enabled'):
-                    res.append((model._name, model.message_mass_mailing_enabled()))
-                else:
-                    res.append((model._name, model._mail_mass_mailing))
-        res.append(('mail.mass_mailing.contact', _('Mailing List')))
-        return res
+            self.browse(row.pop('mailing_id')).update(row)
 
-    def _get_clicks_ratio(self, cr, uid, ids, name, arg, context=None):
-        res = dict.fromkeys(ids, 0)
-        cr.execute("""
-            SELECT COUNT(DISTINCT(stats.id)) AS nb_mails, COUNT(DISTINCT(clicks.mail_stat_id)) AS nb_clicks, stats.mass_mailing_id AS id 
-            FROM mail_mail_statistics AS stats
-            LEFT OUTER JOIN link_tracker_click AS clicks ON clicks.mail_stat_id = stats.id
-            WHERE stats.mass_mailing_id IN %s
-            GROUP BY stats.mass_mailing_id
-        """, (tuple(ids), ))
-
-        for record in cr.dictfetchall():
-            res[record['id']] = 100 * record['nb_clicks'] / record['nb_mails']
-
-        return res
-    def _get_next_departure(self, cr, uid, ids, name, arg, context=None):
-        mass_mailings = self.browse(cr, uid, ids, context=context)
-        cron_next_call = self.pool.get('ir.model.data').xmlid_to_object(cr, SUPERUSER_ID, 'mass_mailing.ir_cron_mass_mailing_queue', context=context).nextcall
-
-        result = {}
-        for mass_mailing in mass_mailings:
+    def _compute_next_departure(self):
+        cron_next_call = self.env.ref('mass_mailing.ir_cron_mass_mailing_queue').sudo().nextcall
+        for mass_mailing in self:
             schedule_date = mass_mailing.schedule_date
             if schedule_date:
-                if datetime.now() > datetime.strptime(schedule_date, tools.DEFAULT_SERVER_DATETIME_FORMAT):
-                    result[mass_mailing.id] = cron_next_call
+                if datetime.now() > fields.Datetime.from_string(schedule_date):
+                    mass_mailing.next_departure = cron_next_call
                 else:
-                    result[mass_mailing.id] = schedule_date
+                    mass_mailing.next_departure = schedule_date
             else:
-                result[mass_mailing.id] = cron_next_call
-        return result
-
-    def _get_total(self, cr, uid, ids, name, arg, context=None):
-        mass_mailings = self.browse(cr, uid, ids, context=context)
+                mass_mailing.next_departure = cron_next_call
 
-        result = {}
-        for mass_mailing in mass_mailings:
-            mailing = self.browse(cr, uid, mass_mailing.id, context=context)
-            result[mass_mailing.id] = len(self.get_recipients(cr, SUPERUSER_ID, mailing, context=context))
-        return result
-
-    # indirections for inheritance
-    _mailing_model = lambda self, *args, **kwargs: self._get_mailing_model(*args, **kwargs)
-
-    _columns = {
-        'active': fields.boolean('Active'),
-        'email_from': fields.char('From', required=True),
-        'create_date': fields.datetime('Creation Date'),
-        'sent_date': fields.datetime('Sent Date', oldname='date', copy=False),
-        'schedule_date': fields.datetime('Schedule in the Future'),
-        'body_html': fields.html('Body', translate=True),
-        'attachment_ids': fields.many2many(
-            'ir.attachment', 'mass_mailing_ir_attachments_rel',
-            'mass_mailing_id', 'attachment_id', 'Attachments'
-        ),
-        'keep_archives': fields.boolean('Keep Archives'),
-        'mass_mailing_campaign_id': fields.many2one(
-            'mail.mass_mailing.campaign', 'Mass Mailing Campaign',
-            ondelete='set null',
-        ),
-        'campaign_id': fields.many2one('utm.campaign', 'Campaign', 
-            help="This name helps you tracking your different campaign efforts, e.g. Fall_Drive, Christmas_Special"),
-        'source_id':fields.many2one('utm.source', 'Subject', required=True, ondelete='cascade',
-            help="This is the link source, e.g. Search Engine, another domain, or name of email list"),
-        'medium_id': fields.many2one('utm.medium', 'Medium', 
-            help="This is the delivery method, e.g. Postcard, Email, or Banner Ad"),
-        'clicks_ratio': fields.function(
-            _get_clicks_ratio, string="Number of Clicks",
-            type="integer",
-        ),
-        'state': fields.selection(
-            [('draft', 'Draft'), ('in_queue', 'In Queue'), ('sending', 'Sending'), ('done', 'Sent')],
-            string='Status', required=True, copy=False
-        ),
-        'color': fields.related(
-            'mass_mailing_campaign_id', 'color',
-            type='integer', string='Color Index',
-        ),
-        # mailing options
-        'reply_to_mode': fields.selection(
-            [('thread', 'Followers of leads/applicants'), ('email', 'Specified Email Address')],
-            string='Reply-To Mode', required=True,
-        ),
-        'reply_to': fields.char('Reply To', help='Preferred Reply-To Address'),
-        # recipients
-        'mailing_model': fields.selection(_mailing_model, string='Recipients Model', required=True),
-        'mailing_domain': fields.char('Domain', oldname='domain'),
-        'contact_list_ids': fields.many2many(
-            'mail.mass_mailing.list', 'mail_mass_mailing_list_rel',
-            string='Mailing Lists',
-        ),
-        'contact_ab_pc': fields.integer(
-            'A/B Testing percentage',
-            help='Percentage of the contacts that will be mailed. Recipients will be taken randomly.'
-        ),
-        # statistics data
-        'statistics_ids': fields.one2many(
-            'mail.mail.statistics', 'mass_mailing_id',
-            'Emails Statistics',
-        ),
-        'total': fields.function(
-            _get_total, string='Total',
-            type='integer',
-        ),
-        'scheduled': fields.function(
-            _get_statistics, string='Scheduled',
-            type='integer', multi='_get_statistics',
-        ),
-        'failed': fields.function(
-            _get_statistics, string='Failed',
-            type='integer', multi='_get_statistics',
-        ),
-        'sent': fields.function(
-            _get_statistics, string='Sent',
-            type='integer', multi='_get_statistics',
-        ),
-        'delivered': fields.function(
-            _get_statistics, string='Delivered',
-            type='integer', multi='_get_statistics',
-        ),
-        'opened': fields.function(
-            _get_statistics, string='Opened',
-            type='integer', multi='_get_statistics',
-        ),
-        'replied': fields.function(
-            _get_statistics, string='Replied',
-            type='integer', multi='_get_statistics',
-        ),
-        'bounced': fields.function(
-            _get_statistics, string='Bounced',
-            type='integer', multi='_get_statistics',
-        ),
-        'failed': fields.function(
-            _get_statistics, string='Failed',
-            type='integer', multi='_get_statistics',
-        ),
-        'received_ratio': fields.function(
-            _get_statistics, string='Received Ratio',
-            type='integer', multi='_get_statistics',
-        ),
-        'opened_ratio': fields.function(
-            _get_statistics, string='Opened Ratio',
-            type='integer', multi='_get_statistics',
-        ),
-        'replied_ratio': fields.function(
-            _get_statistics, string='Replied Ratio',
-            type='integer', multi='_get_statistics',
-        ),
-        'bounced_ratio': fields.function(
-            _get_statistics, String='Bouncded Ratio',
-            type='integer', multi='_get_statistics',
-        ),
-        'next_departure': fields.function(
-            _get_next_departure, string='Next Departure',
-            type='datetime'
-        ),
-    }
-
-    def mass_mailing_statistics_action(self, cr, uid, ids, context=None):
-        res = self.pool['ir.actions.act_window'].for_xml_id(cr, uid, 'mass_mailing', 'action_view_mass_mailing_statistics', context=context)
-        link_click_ids = self.pool['link.tracker.click'].search(cr, uid, [('mass_mailing_id', 'in', ids)], context=context)
+    @api.multi
+    def mass_mailing_statistics_action(self):
+        res = self.env.ref('mass_mailing.action_view_mass_mailing_statistics')
+        link_clicks_ids = self.env['link.tracker.click'].search([('mass_mailing_id', 'in', self.ids)]).ids
         res['domain'] = [('id', 'in', link_click_ids)]
         return res
 
-    def default_get(self, cr, uid, fields, context=None):
-        res = super(MassMailing, self).default_get(cr, uid, fields, context=context)
-        if 'reply_to_mode' in fields and not 'reply_to_mode' in res and res.get('mailing_model'):
-            if res['mailing_model'] in ['res.partner', 'mail.mass_mailing.contact']:
-                res['reply_to_mode'] = 'email'
+    @api.onchange('mass_mailing_campaign_id')
+    def _onchange_mass_mailing_campaign_id(self):
+        if self.mass_mailing_campaign_id:
+            dic = {'campaign_id': self.mass_mailing_campaign_id.campaign_id,
+                   'source_id': self.mass_mailing_campaign_id.source_id,
+                   'medium_id': self.mass_mailing_campaign_id.medium_id}
+            self.update(dic)
+
+    @api.onchange('mailing_model', 'contact_list_ids')
+    def _onchange_model_and_list(self):
+        if self.mailing_model == 'mail.mass_mailing.contact':
+            if self.contact_list_ids:
+                self.mailing_domain = "[('list_id', 'in', %s), ('opt_out', '=', False)]" % self.contact_list_ids.ids
             else:
-                res['reply_to_mode'] = 'thread'
-        return res
-
-    _defaults = {
-        'active': True,
-        'state': 'draft',
-        'email_from': lambda self, cr, uid, ctx=None: self.pool['mail.message']._get_default_from(cr, uid, context=ctx),
-        'reply_to': lambda self, cr, uid, ctx=None: self.pool['mail.message']._get_default_from(cr, uid, context=ctx),
-        'mailing_model': 'mail.mass_mailing.contact',
-        'contact_ab_pc': 100,
-        'mailing_domain': [],
-        'medium_id': lambda self,cr,uid,ctx=None: self.pool['ir.model.data'].xmlid_to_res_id(cr, SUPERUSER_ID, 'utm.utm_medium_email'),
-    }
-
-    def onchange_mass_mailing_campaign_id(self, cr, uid, id, mass_mailing_campaign_ids, context=None):
-        if mass_mailing_campaign_ids:
-            mass_mailing_campaign = self.pool['mail.mass_mailing.campaign'].browse(cr, uid, mass_mailing_campaign_ids, context=context)
-
-            dic = {'campaign_id': mass_mailing_campaign[0].campaign_id.id, 
-                   'source_id': mass_mailing_campaign[0].source_id.id, 
-                   'medium_id': mass_mailing_campaign[0].medium_id.id}
-            return {'value': dic}
+                self.mailing_domain = "[('list_id', '=', False)]"
+        elif 'opt_out' in self.env[self.mailing_model]._fields:
+            self.mailing_domain = "[('opt_out', '=', False)]"
+        else:
+            self.mailing_domain = []
+        self.body_html = "on_change_model_and_list"
 
     #------------------------------------------------------
     # Technical stuff
     #------------------------------------------------------
 
-    def copy_data(self, cr, uid, id, default=None, context=None):
-        mailing = self.browse(cr, uid, id, context=context)
+    @api.multi
+    def copy(self, default=None):
+        self.ensure_one()
         default = dict(default or {},
-                       name=_('%s (copy)') % mailing.name)
-        return super(MassMailing, self).copy_data(cr, uid, id, default, context=context)
+                       name=_('%s (copy)') % self.name)
+        return super(MassMailing, self).copy(default=default)
 
-    def read_group(self, cr, uid, domain, fields, groupby, offset=0, limit=None, context=None, orderby=False, lazy=True):
+    @api.model
+    def read_group(self, domain, fields, groupby, offset=0, limit=None, orderby=False, lazy=True):
         """ Override read_group to always display all states. """
         if groupby and groupby[0] == "state":
             # Default result structure
@@ -644,7 +478,7 @@ class MassMailing(osv.Model):
                 'state_count': 0,
             } for state_value, state_name in states]
             # Get standard results
-            read_group_res = super(MassMailing, self).read_group(cr, uid, domain, fields, groupby, offset=offset, limit=limit, context=context, orderby=orderby)
+            read_group_res = super(MassMailing, self).read_group(domain, fields, groupby, offset=offset, limit=limit, orderby=orderby)
             # Update standard results with default results
             result = []
             for state_value, state_name in states:
@@ -655,62 +489,41 @@ class MassMailing(osv.Model):
                 result.append(res[0])
             return result
         else:
-            return super(MassMailing, self).read_group(cr, uid, domain, fields, groupby, offset=offset, limit=limit, context=context, orderby=orderby)
+            return super(MassMailing, self).read_group(domain, fields, groupby, offset=offset, limit=limit, orderby=orderby)
 
-    def update_opt_out(self, cr, uid, mailing_id, email, res_ids, value, context=None):
-        mailing = self.browse(cr, uid, mailing_id, context=context)
-        model = self.pool[mailing.mailing_model]
+    def update_opt_out(self, email, res_ids, value):
+        model = self.env[self.mailing_model]
         if 'opt_out' in model._fields:
             email_fname = 'email_from'
             if 'email' in model._fields:
                 email_fname = 'email'
-            record_ids = model.search(cr, uid, [('id', 'in', res_ids), (email_fname, 'ilike', email)], context=context)
-            model.write(cr, uid, record_ids, {'opt_out': value}, context=context)
+            records = model.search([('id', 'in', res_ids), (email_fname, 'ilike', email)])
+            records.write({'opt_out': value})
 
     #------------------------------------------------------
     # Views & Actions
     #------------------------------------------------------
 
-    def on_change_model_and_list(self, cr, uid, ids, mailing_model, list_ids, context=None):
-        value = {}
-        if mailing_model == 'mail.mass_mailing.contact':
-            mailing_list_ids = set()
-            for item in list_ids:
-                if isinstance(item, (int, long)):
-                    mailing_list_ids.add(item)
-                elif len(item) == 2 and item[0] == 4:  # 4, id
-                    mailing_list_ids.add(item[1])
-                elif len(item) == 3:  # 6, 0, ids
-                    mailing_list_ids |= set(item[2])
-            if mailing_list_ids:
-                value['mailing_domain'] = "[('list_id', 'in', %s), ('opt_out', '=', False)]" % list(mailing_list_ids)
-            else:
-                value['mailing_domain'] = "[('list_id', '=', False)]"
-        elif 'opt_out' in self.pool[mailing_model]._fields:
-            value['mailing_domain'] = "[('opt_out', '=', False)]"
-        else:
-            value['mailing_domain'] = []
-        value['body_html'] = "on_change_model_and_list"
-        return {'value': value}
-
-    def action_duplicate(self, cr, uid, ids, context=None):
-        copy_id = None
-        for mid in ids:
-            copy_id = self.copy(cr, uid, mid, context=context)
-        if copy_id:
+    @api.multi
+    def action_duplicate(self):
+        self.ensure_one()
+        mass_mailing_copy = self.copy()
+        if mass_mailing_copy:
             return {
                 'type': 'ir.actions.act_window',
                 'view_type': 'form',
                 'view_mode': 'form',
                 'res_model': 'mail.mass_mailing',
-                'res_id': copy_id,
-                'context': context,
+                'res_id': mass_mailing_copy.id,
+                'context': self.env.context,
                 'flags': {'initial_mode': 'edit'},
             }
         return False
 
-    def action_test_mailing(self, cr, uid, ids, context=None):
-        ctx = dict(context, default_mass_mailing_id=ids[0])
+    @api.multi
+    def action_test_mailing(self):
+        self.ensure_one()
+        ctx = dict(self.env.context, default_mass_mailing_id=self.id)
         return {
             'name': _('Test Mailing'),
             'type': 'ir.actions.act_window',
@@ -720,24 +533,39 @@ class MassMailing(osv.Model):
             'context': ctx,
         }
 
+    @api.multi
+    def put_in_queue(self):
+        self.write({'sent_date': fields.Datetime.now(), 'state': 'in_queue'})
+
+    @api.multi
+    def cancel_mass_mailing(self):
+        self.write({'state': 'draft'})
+
+    @api.multi
+    def retry_failed_mail(self):
+        failed_mails = self.env['mail.mail'].search([('mailing_id', 'in', self.ids), ('state', '=', 'exception')])
+        failed_mails.mapped('statistics_ids').unlink()
+        failed_mails.unlink()
+        self.write({'state': 'in_queue'})
+
     #------------------------------------------------------
     # Email Sending
     #------------------------------------------------------
 
-    def get_recipients(self, cr, uid, mailing, context=None):
-        if mailing.mailing_domain:
-            domain = eval(mailing.mailing_domain)
-            res_ids = self.pool[mailing.mailing_model].search(cr, uid, domain, context=context)
+    def get_recipients(self):
+        if self.mailing_domain:
+            domain = eval(self.mailing_domain)
+            res_ids = self.env[self.mailing_model].search(domain).ids
         else:
             res_ids = []
             domain = [('id', 'in', res_ids)]
 
         # randomly choose a fragment
-        if mailing.contact_ab_pc < 100:
-            contact_nbr = self.pool[mailing.mailing_model].search(cr, uid, domain, count=True, context=context)
-            topick = int(contact_nbr / 100.0 * mailing.contact_ab_pc)
-            if mailing.mass_mailing_campaign_id and mailing.mass_mailing_campaign_id.unique_ab_testing:
-                already_mailed = self.pool['mail.mass_mailing.campaign'].get_recipients(cr, uid, [mailing.mass_mailing_campaign_id.id], context=context)[mailing.mass_mailing_campaign_id.id]
+        if self.contact_ab_pc < 100:
+            contact_nbr = self.env[self.mailing_model].search_count(domain)
+            topick = int(contact_nbr / 100.0 * self.contact_ab_pc)
+            if self.mass_mailing_campaign_id and self.mass_mailing_campaign_id.unique_ab_testing:
+                already_mailed = self.mass_mailing_campaign_id.get_recipients()[self.mass_mailing_campaign_id.id]
             else:
                 already_mailed = set([])
             remaining = set(res_ids).difference(already_mailed)
@@ -746,34 +574,29 @@ class MassMailing(osv.Model):
             res_ids = random.sample(remaining, topick)
         return res_ids
 
-    def get_remaining_recipients(self, cr, uid, mailing, context=None):
-        res_ids = self.get_recipients(cr, uid, mailing, context=context)
-        already_mailed = self.pool['mail.mail.statistics'].search_read(cr, uid, [('model', '=', mailing.mailing_model),
-                                                                                 ('res_id', 'in', res_ids),
-                                                                                 ('mass_mailing_id', '=', mailing.id)], ['res_id'], context=context)
+    def get_remaining_recipients(self):
+        res_ids = self.get_recipients()
+        already_mailed = self.env['mail.mail.statistics'].search_read([('model', '=', self.mailing_model),
+                                                                     ('res_id', 'in', res_ids),
+                                                                     ('mass_mailing_id', '=', self.id)], ['res_id'])
         already_mailed_res_ids = [record['res_id'] for record in already_mailed]
         return list(set(res_ids) - set(already_mailed_res_ids))
 
-    def send_mail(self, cr, uid, ids, context=None):
-        author_id = self.pool['res.users'].browse(cr, uid, uid, context=context).partner_id.id
-        for mailing in self.browse(cr, uid, ids, context=context):
+    def send_mail(self):
+        author_id = self.env.user.partner_id.id
+        for mailing in self:
             # instantiate an email composer + send emails
-            res_ids = self.get_remaining_recipients(cr, uid, mailing, context=context)
+            res_ids = mailing.get_remaining_recipients()
             if not res_ids:
                 raise UserError(_('Please select recipients.'))
 
-            if context:
-                comp_ctx = dict(context, active_ids=res_ids)
-            else:
-                comp_ctx = {'active_ids': res_ids}
-
             # Convert links in absolute URLs before the application of the shortener
-            self.write(cr, uid, [mailing.id], {'body_html': self.pool['mail.template']._replace_local_links(cr, uid, mailing.body_html, context)}, context=context)
+            mailing.body_html = self.env['mail.template']._replace_local_links(mailing.body_html)
 
             composer_values = {
                 'author_id': author_id,
                 'attachment_ids': [(4, attachment.id) for attachment in mailing.attachment_ids],
-                'body': self.convert_links(cr, uid, [mailing.id], context=context)[mailing.id],
+                'body': mailing.convert_links()[mailing.id],
                 'subject': mailing.name,
                 'model': mailing.mailing_model,
                 'email_from': mailing.email_from,
@@ -786,14 +609,14 @@ class MassMailing(osv.Model):
             if mailing.reply_to_mode == 'email':
                 composer_values['reply_to'] = mailing.reply_to
 
-            composer_id = self.pool['mail.compose.message'].create(cr, uid, composer_values, context=comp_ctx)
-            self.pool['mail.compose.message'].send_mail(cr, uid, [composer_id], auto_commit=True, context=comp_ctx)
-            self.write(cr, uid, [mailing.id], {'state': 'done'}, context=context)
+            composer = self.env['mail.compose.message'].with_context(active_ids=res_ids).create(composer_values)
+            composer.with_context(active_ids=res_ids).send_mail(auto_commit=True)
+            mailing.state = 'done'
         return True
 
-    def convert_links(self, cr, uid, ids, context=None):
+    def convert_links(self):
         res = {}
-        for mass_mailing in self.browse(cr, uid, ids, context=context):
+        for mass_mailing in self:
             utm_mixin = mass_mailing.mass_mailing_campaign_id if mass_mailing.mass_mailing_campaign_id else mass_mailing
             html = mass_mailing.body_html if mass_mailing.body_html else ''
 
@@ -808,34 +631,16 @@ class MassMailing(osv.Model):
             if utm_mixin.medium_id:
                 vals['medium_id'] = utm_mixin.medium_id.id
 
-            res[mass_mailing.id] = self.pool['link.tracker'].convert_links(cr, uid, html, vals, blacklist=['/unsubscribe_from_list'], context=context)
+            res[mass_mailing.id] = self.env['link.tracker'].convert_links(html, vals, blacklist=['/unsubscribe_from_list'])
 
         return res
 
-    def put_in_queue(self, cr, uid, ids, context=None):
-        self.write(cr, uid, ids, {'sent_date': fields.datetime.now(), 'state': 'in_queue'}, context=context)
-
-    def cancel_mass_mailing(self, cr, uid, ids, context=None):
-        self.write(cr, uid, ids, {'state': 'draft'}, context=context)
-
-    def retry_failed_mail(self, cr, uid, mass_mailing_ids, context=None):
-        mail_mail_ids = self.pool.get('mail.mail').search(cr, uid, [('mailing_id', 'in', mass_mailing_ids), ('state', '=', 'exception')], context=context)
-        self.pool.get('mail.mail').unlink(cr, uid, mail_mail_ids, context=context)
-
-        mail_mail_statistics_ids = self.pool.get('mail.mail.statistics').search(cr, uid, [('mail_mail_id_int', 'in', mail_mail_ids)])
-        self.pool.get('mail.mail.statistics').unlink(cr, uid, mail_mail_statistics_ids, context=context)
-
-        self.write(cr, uid, mass_mailing_ids, {'state': 'in_queue'})
-
-    def _process_mass_mailing_queue(self, cr, uid, context=None):
-        now = datetime.now().strftime(DEFAULT_SERVER_DATETIME_FORMAT)
-        mass_mailing_ids = self.search(cr, uid, [('state', 'in', ('in_queue', 'sending')), '|', ('schedule_date', '<', now), ('schedule_date', '=', False)], context=context)
-
-        for mass_mailing_id in mass_mailing_ids:
-            mass_mailing_record = self.browse(cr, uid, mass_mailing_id, context=context)
-
-            if len(self.get_remaining_recipients(cr, uid, mass_mailing_record, context=context)) > 0:
-                self.write(cr, uid, [mass_mailing_id], {'state': 'sending'}, context=context)
-                self.send_mail(cr, uid, [mass_mailing_id], context=context)
+    @api.model
+    def _process_mass_mailing_queue(self):
+        mass_mailings = self.search([('state', 'in', ('in_queue', 'sending')), '|', ('schedule_date', '<', fields.Datetime.now()), ('schedule_date', '=', False)])
+        for mass_mailing in mass_mailings:
+            if len(mass_mailing.get_remaining_recipients()) > 0:
+                mass_mailing.state = 'sending'
+                mass_mailing.send_mail()
             else:
-                self.write(cr, uid, [mass_mailing_id], {'state': 'done'}, context=context)
+                mass_mailing.state = 'done'

--- a/addons/mass_mailing/models/mass_mailing_report.py
+++ b/addons/mass_mailing/models/mass_mailing_report.py
@@ -1,36 +1,33 @@
 # -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
 
-from openerp.osv import fields, osv
-from openerp import tools
+from odoo import api, fields, models, tools
 
 
-class MassMailingReport(osv.Model):
+class MassMailingReport(models.Model):
     _name = 'mail.statistics.report'
     _auto = False
     _description = 'Mass Mailing Statistics'
 
-    _columns = {
-        'scheduled_date': fields.datetime('Scheduled Date', readonly=True),
-        'name': fields.char('Mass Mail', readonly=True),
-        'campaign': fields.char('Mass Mail Campaign', readonly=True),
-        'sent': fields.integer('Sent', readonly=True),
-        'delivered': fields.integer('Delivered', readonly=True),
-        'opened': fields.integer('Opened', readonly=True),
-        'bounced': fields.integer('Bounced', readonly=True),
-        'replied': fields.integer('Replied', readonly=True),
-        'state': fields.selection(
-            [('draft', 'Draft'), ('test', 'Tested'), ('done', 'Sent')],
-            string='Status', readonly=True,
-        ),
-        'email_from': fields.char('From', readonly=True),
-    }
+    scheduled_date = fields.Datetime(stirng='Scheduled Date', readonly=True)
+    name = fields.Char(string='Mass Mail', readonly=True)
+    campaign = fields.Char(string='Mass Mail Campaign', readonly=True)
+    sent = fields.Integer(readonly=True)
+    delivered = fields.Integer(readonly=True)
+    opened = fields.Integer(readonly=True)
+    bounced = fields.Integer(readonly=True)
+    replied = fields.Integer(readonly=True)
+    state = fields.Selection([('draft', 'Draft'), ('test', 'Tested'), ('done', 'Sent')],
+        string='Status', readonly=True)
+    email_from = fields.Char('From', readonly=True)
 
-    def init(self, cr):
+    @api.model_cr
+    def init(self):
         """Mass Mail Statistical Report: based on mail.mail.statistics that models the various
         statistics collected for each mailing, and mail.mass_mailing model that models the
         various mailing performed. """
-        tools.drop_view_if_exists(cr, 'mail_statistics_report')
-        cr.execute("""
+        tools.drop_view_if_exists(self.env.cr, 'mail_statistics_report')
+        self.env.cr.execute("""
             CREATE OR REPLACE VIEW mail_statistics_report AS (
                 SELECT
                     min(ms.id) as id,

--- a/addons/mass_mailing/models/mass_mailing_stats.py
+++ b/addons/mass_mailing/models/mass_mailing_stats.py
@@ -1,10 +1,10 @@
 # -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
-from openerp.osv import fields, osv
+from odoo import api, fields, models
 
 
-class MailMailStats(osv.Model):
+class MailMailStats(models.Model):
     """ MailMailStats models the statistics collected about emails. Those statistics
     are stored in a separated model and table to avoid bloating the mail_mail table
     with statistics values. This also allows to delete emails send with mass mailing
@@ -15,29 +15,64 @@ class MailMailStats(osv.Model):
     _rec_name = 'message_id'
     _order = 'message_id'
 
-    def _compute_state(self, cr, uid, ids, field_names, arg, context=None):
-        res = dict((i, {'state': 'outgoing', 'state_update': fields.datetime.now()}) for i in ids)
-
-        for stat in self.browse(cr, uid, ids, context=context):
+    mail_mail_id = fields.Many2one('mail.mail', string='Mail', index=True)
+    mail_mail_id_int = fields.Integer(
+        string='Mail ID (tech)',
+        help='ID of the related mail_mail. This field is an integer field because '
+             'the related mail_mail can be deleted separately from its statistics. '
+             'However the ID is needed for several action and controllers.'
+    )
+    message_id = fields.Char(string='Message-ID')
+    model = fields.Char(string='Document model')
+    res_id = fields.Integer(string='Document ID')
+    # campaign / wave data
+    mass_mailing_id = fields.Many2one('mail.mass_mailing', string='Mass Mailing')
+    mass_mailing_campaign_id = fields.Many2one(
+        related='mass_mailing_id.mass_mailing_campaign_id',
+        string='Mass Mailing Campaign',
+        store=True, readonly=True)
+    # Bounce and tracking
+    scheduled = fields.Datetime(help='Date when the email has been created', default=fields.Datetime.now)
+    sent = fields.Datetime(help='Date when the email has been sent')
+    exception = fields.Datetime(help='Date of technical error leading to the email not being sent')
+    opened = fields.Datetime(help='Date when the email has been opened the first time')
+    replied = fields.Datetime(help='Date when this email has been replied for the first time.')
+    bounced = fields.Datetime(help='Date when this email has bounced.')
+    links_click_ids = fields.One2many('link.tracker.click', 'mail_stat_id', string='Links click')
+    state = fields.Selection(compute="_compute_state",
+                             selection=[('outgoing', 'Outgoing'),
+                                        ('exception', 'Exception'),
+                                        ('sent', 'Sent'),
+                                        ('opened', 'Opened'),
+                                        ('replied', 'Replied'),
+                                        ('bounced', 'Bounced')], store=True)
+    state_update = fields.Datetime(compute="_compute_state", string='State Update',
+                                    help='Last state update of the mail',
+                                    store=True)
+    recipient = fields.Char(compute="_compute_recipient")
+
+    @api.depends('sent', 'opened', 'replied', 'bounced', 'exception')
+    def _compute_state(self):
+        self.update({'state_update': fields.Datetime.now()})
+        for stat in self:
             if stat.exception:
-                res[stat.id]['state'] = 'exception'
-            if stat.sent:
-                res[stat.id]['state'] = 'sent'
-            if stat.opened:
-                res[stat.id]['state'] = 'opened'
-            if stat.replied:
-                res[stat.id]['state'] = 'replied'
-            if stat.bounced:
-                res[stat.id]['state'] = 'bounced'
-
-        return res
-
-    def _compute_recipient(self, cr, uid, ids, field_names, arg, context=None):
-        res = dict.fromkeys(ids, '')
-        for stat in self.browse(cr, uid, ids, context=context):
-            if not self.pool.get(stat.model):
+                stat.state = 'exception'
+            elif stat.sent:
+                stat.state = 'sent'
+            elif stat.opened:
+                stat.state = 'opened'
+            elif stat.replied:
+                stat.state = 'replied'
+            elif stat.bounced:
+                stat.state = 'bounced'
+            else:
+                stat.state = 'outgoing'
+
+    def _compute_recipient(self):
+        for stat in self:
+            if stat.model not in self.env:
                 continue
-            target = self.pool[stat.model].browse(cr, uid, stat.res_id, context=context)
+            target = self.env[stat.model].browse(stat.res_id)
             if not target or not target.exists():
                 continue
             email = ''
@@ -45,88 +80,37 @@ class MailMailStats(osv.Model):
                 if email_field in target and target[email_field]:
                     email = ' <%s>' % target[email_field]
                     break
-            res[stat.id] = '%s%s' % (target.display_name, email)
-        return res
-
-    __store = {_name: ((lambda s, c, u, i, t: i), ['exception', 'sent', 'opened', 'replied', 'bounced'], 10)}
+            stat.recipient = '%s%s' % (target.display_name, email)
 
-    _columns = {
-        'mail_mail_id': fields.many2one('mail.mail', 'Mail', ondelete='set null', select=True),
-        'mail_mail_id_int': fields.integer(
-            'Mail ID (tech)',
-            help='ID of the related mail_mail. This field is an integer field because '
-                 'the related mail_mail can be deleted separately from its statistics. '
-                 'However the ID is needed for several action and controllers.'
-        ),
-        'message_id': fields.char('Message-ID'),
-        'model': fields.char('Document model'),
-        'res_id': fields.integer('Document ID'),
-        # campaign / wave data
-        'mass_mailing_id': fields.many2one(
-            'mail.mass_mailing', 'Mass Mailing',
-            ondelete='set null',
-        ),
-        'mass_mailing_campaign_id': fields.related(
-            'mass_mailing_id', 'mass_mailing_campaign_id',
-            type='many2one', ondelete='set null',
-            relation='mail.mass_mailing.campaign',
-            string='Mass Mailing Campaign',
-            store=True, readonly=True,
-        ),
-        # Bounce and tracking
-        'scheduled': fields.datetime('Scheduled', help='Date when the email has been created'),
-        'sent': fields.datetime('Sent', help='Date when the email has been sent'),
-        'exception': fields.datetime('Exception', help='Date of technical error leading to the email not being sent'),
-        'opened': fields.datetime('Opened', help='Date when the email has been opened the first time'),
-        'replied': fields.datetime('Replied', help='Date when this email has been replied for the first time.'),
-        'bounced': fields.datetime('Bounced', help='Date when this email has bounced.'),
-        'links_click_ids': fields.one2many('link.tracker.click', 'mail_stat_id', 'Links click'),
-        'state': fields.function(_compute_state, string='State', type="selection", multi="state",
-                                 selection=[('outgoing', 'Outgoing'),
-                                            ('exception', 'Exception'),
-                                            ('sent', 'Sent'),
-                                            ('opened', 'Opened'),
-                                            ('replied', 'Replied'),
-                                            ('bounced', 'Bounced')],
-                                 store=__store),
-        'state_update': fields.function(_compute_state, string='State Update', type='datetime',
-                                        multi='state', help='Last state update of the mail',
-                                        store=__store),
-        'recipient': fields.function(_compute_recipient, string='Recipient', type='char'),
-    }
-
-    _defaults = {
-        'scheduled': fields.datetime.now,
-    }
-
-    def create(self, cr, uid, values, context=None):
+    @api.model
+    def create(self, values):
         if 'mail_mail_id' in values:
             values['mail_mail_id_int'] = values['mail_mail_id']
-        res = super(MailMailStats, self).create(cr, uid, values, context=context)
+        res = super(MailMailStats, self).create(values)
         return res
 
-    def _get_ids(self, cr, uid, ids=None, mail_mail_ids=None, mail_message_ids=None, domain=None, context=None):
-        if not ids and mail_mail_ids:
+    def _get_records(self, mail_mail_ids=None, mail_message_ids=None, domain=None):
+        if not self.ids and mail_mail_ids:
             base_domain = [('mail_mail_id_int', 'in', mail_mail_ids)]
-        elif not ids and mail_message_ids:
+        elif not self.ids and mail_message_ids:
             base_domain = [('message_id', 'in', mail_message_ids)]
         else:
-            base_domain = [('id', 'in', ids or [])]
+            base_domain = [('id', 'in', self.ids)]
         if domain:
             base_domain = ['&'] + domain + base_domain
-        return self.search(cr, uid, base_domain, context=context)
-
-    def set_opened(self, cr, uid, ids=None, mail_mail_ids=None, mail_message_ids=None, context=None):
-        stat_ids = self._get_ids(cr, uid, ids, mail_mail_ids, mail_message_ids, [('opened', '=', False)], context)
-        self.write(cr, uid, stat_ids, {'opened': fields.datetime.now()}, context=context)
-        return stat_ids
-
-    def set_replied(self, cr, uid, ids=None, mail_mail_ids=None, mail_message_ids=None, context=None):
-        stat_ids = self._get_ids(cr, uid, ids, mail_mail_ids, mail_message_ids, [('replied', '=', False)], context)
-        self.write(cr, uid, stat_ids, {'replied': fields.datetime.now()}, context=context)
-        return stat_ids
-
-    def set_bounced(self, cr, uid, ids=None, mail_mail_ids=None, mail_message_ids=None, context=None):
-        stat_ids = self._get_ids(cr, uid, ids, mail_mail_ids, mail_message_ids, [('bounced', '=', False)], context)
-        self.write(cr, uid, stat_ids, {'bounced': fields.datetime.now()}, context=context)
-        return stat_ids
+        return self.search(base_domain)
+
+    def set_opened(self, mail_mail_ids=None, mail_message_ids=None):
+        statistics = self._get_records(mail_mail_ids, mail_message_ids, [('opened', '=', False)])
+        statistics.write({'opened': fields.Datetime.now()})
+        return statistics
+
+    def set_replied(self, mail_mail_ids=None, mail_message_ids=None):
+        statistics = self._get_records(mail_mail_ids, mail_message_ids, [('replied', '=', False)])
+        statistics.write({'replied': fields.Datetime.now()})
+        return statistics
+
+    def set_bounced(self, mail_mail_ids=None, mail_message_ids=None):
+        statistics = self._get_records(mail_mail_ids, mail_message_ids, [('bounced', '=', False)])
+        statistics.write({'bounced': fields.Datetime.now()})
+        return statistics

--- a/addons/mass_mailing/models/res_config.py
+++ b/addons/mass_mailing/models/res_config.py
@@ -1,23 +1,21 @@
 # -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
 
-from openerp.osv import fields, osv
+from odoo import fields, models
 
 
-class MassMailingConfiguration(osv.TransientModel):
+class MassMailingConfiguration(models.TransientModel):
     _name = 'mass.mailing.config.settings'
     _inherit = 'res.config.settings'
 
-    _columns = {
-        'group_mass_mailing_campaign': fields.selection([
-            (0, "Do not organize and schedule mail campaigns (easy)"),
-            (1, "Allow using marketing campaigns (advanced)")
-            ], "Campaigns",
-            implied_group='mass_mailing.group_mass_mailing_campaign',
-            help="""Manage mass mailign using Campaigns"""),
-        'group_website_popup_on_exit': fields.selection([
-            (0, 'Do not add extra content on website pages to encourage visitors to sign up'),
-            (1, 'Allow the use of a pop-up snippet on website to encourage visitors to sign up on a mass mailing list')
-            ], string="Website Pop-up",
-            implied_group="mass_mailing.group_website_popup_on_exit"),
-        'module_mass_mailing_themes': fields.boolean("Mass mailing themes"),
-    }
+    group_mass_mailing_campaign = fields.Selection([
+        (0, "Do not organize and schedule mail campaigns (easy)"),
+        (1, "Allow using marketing campaigns (advanced)")], string="Campaigns",
+        implied_group='mass_mailing.group_mass_mailing_campaign',
+        help="""Manage mass mailign using Campaigns""")
+    group_website_popup_on_exit = fields.Selection([
+        (0, 'Do not add extra content on website pages to encourage visitors to sign up'),
+        (1, 'Allow the use of a pop-up snippet on website to encourage visitors to sign up on a mass mailing list')
+        ], string="Website Pop-up",
+        implied_group="mass_mailing.group_website_popup_on_exit")
+    module_mass_mailing_themes = fields.Boolean("Mass mailing themes")
