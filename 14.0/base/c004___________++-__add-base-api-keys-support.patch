PR: https://github.com/odoo/odoo/pull/

From: d0dbbe23f4b1f797a9ed8c7a4726146d6df902ad
From: Xavier Morel
Date: 2020-08-14 23:03:27

Structural Changes: 5
Total Changes: 176

[ADD] base: API keys support

* ability for a user to request / create keys associated to their user
* overrides can block RPC solely through API keys, by overriding
  `_rpc_api_keys_only()` (to require API auth even in
  situations where the user has not requested it themselves)
* hash keys just in case as we can do so and might as well, add a
  cleartext index (first 4 bytes of 20) to avoid blowing up the DB if
  a user decides to create millions of keys for some daft reason
* users can delete their own keys, admins can delete (invalidate)
  anyone's keys
* `scope` on API keys can be used to restrict usage to certain
  kind of applications, so API keys can be used for other things
  than global authentication. New keys manually created by users
  have no scope by default so they are valid everywhere (global
  keys). RPC auth (stateless XML-RPC/JSON-RPC) requires global keys

Co-authored-by: Florimond Husquinet <fhu@odoo.com>
Co-authored-by: Olivier Dony <odo@odoo.com>

================================= pseudo patch: =================================

--- a/odoo/addons/base/models/res_users.py
+++ b/odoo/addons/base/models/res_users.py
@@ -2,6 +2,7 @@
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
 import base64
+import binascii
 import contextlib
 import datetime
 import hmac
@@ -9,6 +10,7 @@ import ipaddress
 import itertools
 import json
 import logging
+import os
 import time
 from collections import defaultdict
 from hashlib import sha256
@@ -114,6 +116,7 @@ def check_identity(fn, self):
         'type': 'ir.actions.act_window',
         'res_model': 'res.users.identitycheck',
         'res_id': w.id,
+        'name': _("Security Control"),
         'target': 'new',
         'views': [(False, 'form')],
     }
@@ -771,6 +774,10 @@ class Users(models.Model):
 
         # alternatively: use identitycheck wizard?
         self._check_credentials(old_passwd, {'interactive': True})
+
+        ip = request.httprequest.environ['REMOTE_ADDR'] if request else 'n/a'
+        _logger.info("Password change for '%s' (#%s) from %s", self.env.user.login, self.env.uid, ip)
+
         # use self.env.user here, because it has uid=SUPERUSER_ID
         return self.env.user.write({'password': new_passwd})
 
@@ -1447,21 +1454,21 @@ class UsersView(models.Model):
         return res
 
 class CheckIdentity(models.TransientModel):
-    _name = 'res.users.identitycheck'
-    _description = """ Wizard used to re-check the user's credentials (password)
+    """ Wizard used to re-check the user's credentials (password)
 
-Might be useful before the more security-sensitive operations, users might be
-leaving their computer unlocked & unattended. Re-checking credentials mitigates
-some of the risk of a third party using such an unattended device to manipulate
-the account.
-"""
+    Might be useful before the more security-sensitive operations, users might be
+    leaving their computer unlocked & unattended. Re-checking credentials mitigates
+    some of the risk of a third party using such an unattended device to manipulate
+    the account.
+    """
+    _name = 'res.users.identitycheck'
+    _description = "Password Check Wizard"
 
-    request = fields.Char(readonly=True, groups='.')
-    password = fields.Char(required=True)
+    request = fields.Char(readonly=True, groups='.') # no access
+    password = fields.Char()
 
     def run_check(self):
-        if not request:
-            raise UserError(_("This method can only be accessed over HTTP"))
+        assert request, "This method can only be accessed over HTTP"
         self.create_uid._check_credentials(self.password, {'interactive': True})
         self.password = False
 
@@ -1512,3 +1519,150 @@ class ChangePasswordUser(models.TransientModel):
             line.user_id.write({'password': line.new_passwd})
         # don't keep temporary passwords in the database longer than necessary
         self.write({'new_passwd': False})
+
+# API keys support
+API_KEY_SIZE = 20 # in bytes
+INDEX_SIZE = 8 # in hex digits, so 4 bytes, or 20% of the key
+KEY_CRYPT_CONTEXT = passlib.context.CryptContext(
+    # default is 29000 rounds which is 25~50ms, which is probably unnecessary
+    # given in this case all the keys are completely random data: dictionary
+    # attacks on API keys isn't much of a concern
+    ['pbkdf2_sha512'], pbkdf2_sha512__rounds=6000,
+)
+hash_api_key = getattr(KEY_CRYPT_CONTEXT, 'hash', None) or KEY_CRYPT_CONTEXT.encrypt
+class APIKeysUser(models.Model):
+    _inherit = 'res.users'
+
+    api_key_ids = fields.One2many('res.users.apikeys', 'user_id', string="API Keys")
+
+    def __init__(self, pool, cr):
+        init_res = super().__init__(pool, cr)
+        # duplicate list to avoid modifying the original reference
+        type(self).SELF_WRITEABLE_FIELDS = self.SELF_WRITEABLE_FIELDS + ['api_key_ids']
+        type(self).SELF_READABLE_FIELDS = self.SELF_READABLE_FIELDS + ['api_key_ids']
+        return init_res
+
+    def _rpc_api_keys_only(self):
+        """ To be overridden if RPC access needs to be restricted to API keys, e.g. for 2FA """
+        return False
+
+    def _check_credentials(self, password, user_agent_env):
+        if user_agent_env['interactive']:
+            return super()._check_credentials(password, user_agent_env)
+
+        if not self.env.user._rpc_api_keys_only():
+            try:
+                return super()._check_credentials(password, user_agent_env)
+            except AccessDenied:
+                pass
+
+        # 'rpc' scope does not really exist, we basically require a global key (scope NULL)
+        if self.env['res.users.apikeys']._check_credentials(scope='rpc', key=password) == self.env.uid:
+            return
+
+        raise AccessDenied()
+
+    @check_identity
+    def api_key_wizard(self):
+        return {
+            'type': 'ir.actions.act_window',
+            'res_model': 'res.users.apikeys.description',
+            'name': 'New API Key',
+            'target': 'new',
+            'views': [(False, 'form')],
+        }
+
+class APIKeys(models.Model):
+    _name = _description = 'res.users.apikeys'
+    _auto = False # so we can have a secret column
+
+    name = fields.Char("Description", required=True, readonly=True)
+    user_id = fields.Many2one('res.users', index=True, required=True, readonly=True, ondelete="cascade")
+    scope = fields.Char("Scope", readonly=True)
+    create_date = fields.Datetime("Creation Date", readonly=True)
+
+    def init(self):
+        # pylint: disable=sql-injection
+        self.env.cr.execute("""
+        CREATE TABLE IF NOT EXISTS {table} (
+            id serial primary key,
+            name varchar not null,
+            user_id integer not null REFERENCES res_users(id),
+            scope varchar,
+            index varchar({index_size}) not null CHECK (char_length(index) = {index_size}),
+            key varchar not null,
+            create_date timestamp without time zone DEFAULT (now() at time zone 'utc')
+        );
+        CREATE INDEX ON {table} (user_id, index);
+        """.format(table=self._table, index_size=INDEX_SIZE))
+
+    @check_identity
+    def remove(self):
+        if self.env.is_system() or self.mapped('user_id') == self.env.user:
+            ip = request.httprequest.environ['REMOTE_ADDR'] if request else 'n/a'
+            _logger.info("API key(s) removed: scope: <%s> for '%s' (#%s) from %s",
+               self.mapped('scope'), self.env.user.login, self.env.uid, ip)
+            self.sudo().unlink()
+            return {'type': 'ir.actions.act_window_close'}
+        raise AccessError(_("You can not remove API keys unless they're yours or you are a system user"))
+
+    def _check_credentials(self, *, scope, key):
+        assert scope, "scope is required"
+        index = key[:INDEX_SIZE]
+        self.env.cr.execute('SELECT user_id, key FROM res_users_apikeys WHERE index = %s AND (scope IS NULL OR scope = %s)', [index, scope])
+        for user_id, current_key in self.env.cr.fetchall():
+            if KEY_CRYPT_CONTEXT.verify(key, current_key):
+                return user_id
+
+    def _generate(self, scope, name):
+        """Generates an api key.
+        :param str scope: the scope of the key. If None, the key will give access to any rpc.
+        :param str name: the name of the key, mainly intended to be displayed in the UI.
+        :return: str: the key.
+
+        """
+        # no need to clear the LRU when *adding* a key, only when removing
+        k = binascii.hexlify(os.urandom(API_KEY_SIZE)).decode()
+        self.env.cr.execute("""
+        INSERT INTO res_users_apikeys (name, user_id, scope, key, index)
+        VALUES (%s, %s, %s, %s, %s)
+        RETURNING id
+        """,
+        [name, self.env.user.id, scope, hash_api_key(k), k[:INDEX_SIZE]])
+
+        ip = request.httprequest.environ['REMOTE_ADDR'] if request else 'n/a'
+        _logger.info("API key generated: scope: <%s> for '%s' (#%s) from %s",
+            scope, self.env.user.login, self.env.uid, ip)
+
+        return k
+
+class APIKeyDescription(models.TransientModel):
+    _name = _description = 'res.users.apikeys.description'
+
+    name = fields.Char("Description", required=True)
+
+    @check_identity
+    def make_key(self):
+        # only create keys for users who can delete their keys
+        if not self.user_has_groups('base.group_user'):
+            raise AccessError(_("Only internal users can create API keys"))
+
+        description = self.sudo()
+        k = self.env['res.users.apikeys']._generate(None, self.sudo().name)
+        description.unlink()
+
+        return {
+            'type': 'ir.actions.act_window',
+            'res_model': 'res.users.apikeys.show',
+            'name': 'API Key Ready',
+            'views': [(False, 'form')],
+            'target': 'new',
+            'context': {
+                'default_key': k,
+            }
+        }
+
+class APIKeyShow(models.AbstractModel):
+    _name = _description = 'res.users.apikeys.show'
+
+    key = fields.Char(readonly=True)
