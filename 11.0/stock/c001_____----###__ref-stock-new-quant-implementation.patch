PR: https://github.com/odoo/odoo/pull/

From: b3180c841101510081ee8ef9c52d205497efdd4f
From: Simon Lejeune
Date: 2017-07-14 15:08:21

Breaking data model changes score: 21, change matches:
-    quant_ids = fields.Many2many('stock.quant', 'stock_quant_move_rel', 'move_id', 'quant_id', 'Moved Quants', copy=False)
-    reserved_quant_ids = fields.One2many('stock.quant', 'reservation_id', 'Reserved quants')
-    lot_ids = fields.Many2many('stock.production.lot', string='Lots/Serial Numbers', compute='_compute_lot_ids')
-    quant_reserved_exist = fields.Boolean(
-    name = fields.Char(string='Identifier', compute='_compute_name')
-    qty = fields.Float(
-    product_uom_id = fields.Many2one(
-    packaging_type_id = fields.Many2one(
-    reservation_id = fields.Many2one(
-    cost = fields.Float('Unit Cost', group_operator='avg')
-    create_date = fields.Datetime('Creation Date', readonly=True)
-    history_ids = fields.Many2many(
-    company_id = fields.Many2one(
-    inventory_value = fields.Float('Inventory Value', compute='_compute_inventory_value', readonly=True)
-    propagated_from_id = fields.Many2one(
-    negative_move_id = fields.Many2one(
-    negative_dest_location_id = fields.Many2one(

Total Changes: 979

[REF] stock: new quant implementation

The main idea of this new implementation is that stock.quant is now a
cache of the quantity per location/lot/pack/owner key. We removed every
identity per record, such as `history_ids` or `inventory_value` so that
we can now avoid the linear creation of stock.quant records and are able
to work with only one record per key.

The algorithms to retrieve the quantity per key are made to work with
multiple records, this way we can implement strategies to workaround
postgres locks if concurrent transactions try to work on the same quant
row.

Quants will not be linked to moves anymore, this is in order to be able
to edit stock moves more easily/freely. We removed the links with this
commit and wipe out the `action_assign` on stock move. This will be
implemented in a followup commit, once the relations between stock.move,
stock.pack.operation and stock.quant are clarified.

This commit seems to have unecessary diff, but it was done in order to
run tests on the new implementation.

We adapt the views by removing the fields not present anymore in the
model. This include the complete removal of the inventory valuation
view, as the implementation of stock valuation will be refactored and
moved on stock.move in a following revision.

We wipe out `action_cancel`, `recalculate_move_state`,
`move_quants_by_lot_v10` and `quants_unreserve`.

* `get_removal_strategy` moved from `stock.move` to `stock.quant`

Stock quant model:
  * qty renamed to quantity
  * history_ids: because the quants are not moved
  * inventory_value: implementation moved to stock.move
  * packaging_type_id: doesn't seem to be used (in filters?)
  * propagated_from_id: because we do not split forced quants
  * reservation_id: because the reservation are not linked to
    the stock.move.line

We remove the `lot_ids` computed field, as it depended on the link
between stock moves and quants and could be replaced by a related
to the move lines once the new relation between stock.move,
stock.pack.operation and stock.quant is clarified in a further commit.
Furthermore, the field was not displayed to the user.

================================= pseudo patch: =================================

--- a/addons/stock/models/product.py
+++ b/addons/stock/models/product.py
@@ -146,7 +146,7 @@ class Product(models.Model):
         domain_move_out_todo = [('state', 'not in', ('done', 'cancel', 'draft'))] + domain_move_out
         moves_in_res = dict((item['product_id'][0], item['product_qty']) for item in Move.read_group(domain_move_in_todo, ['product_id', 'product_qty'], ['product_id']))
         moves_out_res = dict((item['product_id'][0], item['product_qty']) for item in Move.read_group(domain_move_out_todo, ['product_id', 'product_qty'], ['product_id']))
-        quants_res = dict((item['product_id'][0], item['qty']) for item in Quant.read_group(domain_quant, ['product_id', 'qty'], ['product_id']))
+        quants_res = dict((item['product_id'][0], item['quantity']) for item in Quant.read_group(domain_quant, ['product_id', 'quantity'], ['product_id']))
         if dates_in_the_past:
             # Calculate the moves that were done before now to calculate back in time (as most questions will be recent ones)
             domain_move_in_done = [('state', '=', 'done'), ('date', '>', to_date)] + domain_move_in_done

--- a/addons/stock/models/stock_inventory.py
+++ b/addons/stock/models/stock_inventory.py
@@ -244,7 +244,7 @@ class Inventory(models.Model):
             args += (categ_products.ids,)
             products_to_filter |= categ_products
 
-        self.env.cr.execute("""SELECT product_id, sum(qty) as product_qty, location_id, lot_id as prod_lot_id, package_id, owner_id as partner_id
+        self.env.cr.execute("""SELECT product_id, sum(quantity) as product_qty, location_id, lot_id as prod_lot_id, package_id, owner_id as partner_id
             FROM stock_quant
             WHERE %s
             GROUP BY product_id, location_id, lot_id, package_id, partner_id """ % domain, args)
@@ -339,7 +339,7 @@ class InventoryLine(models.Model):
         if not self.product_id:
             self.theoretical_qty = 0
             return
-        theoretical_qty = sum([x.qty for x in self._get_quants()])
+        theoretical_qty = sum([x.quantity for x in self._get_quants()])
         if theoretical_qty and self.product_uom_id and self.product_id.uom_id != self.product_uom_id:
             theoretical_qty = self.product_id.uom_id._compute_quantity(theoretical_qty, self.product_uom_id)
         self.theoretical_qty = theoretical_qty

--- a/addons/stock/models/stock_move.py
+++ b/addons/stock/models/stock_move.py
@@ -3,7 +3,6 @@
 
 from datetime import datetime
 from dateutil import relativedelta
-import time
 
 from odoo import api, fields, models, _
 from odoo.addons import decimal_precision as dp
@@ -117,8 +116,6 @@ class StockMove(models.Model):
              "its current stock) to gather products. If we want to chain moves and have this one to wait for the previous,"
              "this second option should be chosen.")
     scrapped = fields.Boolean('Scrapped', related='location_dest_id.scrap_location', readonly=True, store=True)
-    quant_ids = fields.Many2many('stock.quant', 'stock_quant_move_rel', 'move_id', 'quant_id', 'Moved Quants', copy=False)
-    reserved_quant_ids = fields.One2many('stock.quant', 'reservation_id', 'Reserved quants')
     linked_move_operation_ids = fields.One2many(
         'stock.move.operation.link', 'move_id', 'Linked Operations', readonly=True,
         help='Operations that impact this move for the computation of the remaining quantities')
@@ -135,7 +132,6 @@ class StockMove(models.Model):
         help='If checked, when this move is cancelled, cancel the linked move too')
     picking_type_id = fields.Many2one('stock.picking.type', 'Operation Type')
     inventory_id = fields.Many2one('stock.inventory', 'Inventory')
-    lot_ids = fields.Many2many('stock.production.lot', string='Lots/Serial Numbers', compute='_compute_lot_ids')
     origin_returned_move_id = fields.Many2one('stock.move', 'Origin return move', copy=False, help='Move that created the return move')
     returned_move_ids = fields.One2many('stock.move', 'origin_returned_move_id', 'All returned moves', help='Optional: all returned moves created from this move')
     reserved_availability = fields.Float(
@@ -170,13 +166,6 @@ class StockMove(models.Model):
     def _get_remaining_qty(self):
         self.remaining_qty = float_round(self.product_qty - sum(self.mapped('linked_move_operation_ids').mapped('qty')), precision_rounding=self.product_id.uom_id.rounding)
 
-    @api.one
-    @api.depends('state', 'quant_ids.lot_id', 'reserved_quant_ids.lot_id')
-    def _compute_lot_ids(self):
-        if self.state == 'done':
-            self.lot_ids = self.mapped('quant_ids').mapped('lot_id').ids
-        else:
-            self.lot_ids = self.mapped('reserved_quant_ids').mapped('lot_id').ids
 
     @api.one
     @api.depends('reserved_quant_ids.qty')
@@ -308,17 +297,6 @@ class StockMove(models.Model):
         """ Returns the unit price to store on the quant """
         return self.price_unit or self.product_id.standard_price
 
-    def get_removal_strategy(self):
-        ''' Returns the removal strategy to consider for the given move/ops '''
-        if self.product_id.categ_id.removal_strategy_id:
-            return self.product_id.categ_id.removal_strategy_id.method
-        loc = self.location_id
-        while loc:
-            if loc.removal_strategy_id:
-                return loc.removal_strategy_id.method
-            loc = loc.location_id
-        return 'fifo'
-
     @api.returns('self')
     @api.multi  # TDE: DECORATOR to remove
     def get_ancestors(self):
@@ -345,13 +323,7 @@ class StockMove(models.Model):
 
     @api.multi
     def do_unreserve(self):
-        if any(move.state in ('done', 'cancel') for move in self):
-            raise UserError(_('Cannot unreserve a done move'))
-        self.quants_unreserve()
-        if not self.env.context.get('no_state_change'):
-            waiting = self.filtered(lambda move: move.procure_method == 'make_to_order' or move.get_ancestors())
-            waiting.write({'state': 'waiting'})
-            (self - waiting).write({'state': 'confirmed'})
+        pass
 
     def _push_apply(self):
         # TDE CLEANME: I am quite sure I already saw this code somewhere ... in routing ??
@@ -555,217 +527,11 @@ class StockMove(models.Model):
                 raise UserError(_('You need to provide a Lot/Serial Number for product %s') % move.product_id.name)
 
     @api.multi
-    def action_assign(self, no_prepare=False):
-        """ Checks the product type and accordingly writes the state. """
-        # TDE FIXME: remove decorator once everything is migrated
-        # TDE FIXME: clean me, please
-        main_domain = {}
-
-        Quant = self.env['stock.quant']
-        Uom = self.env['product.uom']
-        moves_to_assign = self.env['stock.move']
-        moves_to_do = self.env['stock.move']
-        operations = self.env['stock.pack.operation']
-        ancestors_list = {}
-
-        # work only on in progress moves
-        moves = self.filtered(lambda move: move.state in ['confirmed', 'waiting', 'assigned'])
-        moves.filtered(lambda move: move.reserved_quant_ids).do_unreserve()
-        for move in moves:
-            if move.location_id.usage in ('supplier', 'inventory', 'production'):
-                moves_to_assign |= move
-                # TDE FIXME: what ?
-                # in case the move is returned, we want to try to find quants before forcing the assignment
-                if not move.origin_returned_move_id:
-                    continue
-            # if the move is preceeded, restrict the choice of quants in the ones moved previously in original move
-            ancestors = move.find_move_ancestors()
-            if move.product_id.type == 'consu' and not ancestors:
-                moves_to_assign |= move
-                continue
-            else:
-                moves_to_do |= move
-
-                # we always search for yet unassigned quants
-                main_domain[move.id] = [('reservation_id', '=', False), ('qty', '>', 0)]
-
-                ancestors_list[move.id] = True if ancestors else False
-                if move.state == 'waiting' and not ancestors:
-                    # if the waiting move hasn't yet any ancestor (PO/MO not confirmed yet), don't find any quant available in stock
-                    main_domain[move.id] += [('id', '=', False)]
-                elif ancestors:
-                    main_domain[move.id] += [('history_ids', 'in', ancestors.ids)]
-
-                # if the move is returned from another, restrict the choice of quants to the ones that follow the returned move
-                if move.origin_returned_move_id:
-                    main_domain[move.id] += [('history_ids', 'in', move.origin_returned_move_id.id)]
-                for link in move.linked_move_operation_ids:
-                    operations |= link.operation_id
-
-        # Check all ops and sort them: we want to process first the packages, then operations with lot then the rest
-        operations = operations.sorted(key=lambda x: ((x.package_id and not x.product_id) and -4 or 0) + (x.package_id and -2 or 0) + (x.pack_lot_ids and -1 or 0))
-        for ops in operations:
-            # TDE FIXME: this code seems to be in action_done, isn't it ?
-            # first try to find quants based on specific domains given by linked operations for the case where we want to rereserve according to existing pack operations
-            if not (ops.product_id and ops.pack_lot_ids):
-                for record in ops.linked_move_operation_ids:
-                    move = record.move_id
-                    if move.id in main_domain:
-                        qty = record.qty
-                        domain = main_domain[move.id]
-                        if qty:
-                            quants = Quant.quants_get_preferred_domain(qty, move, ops=ops, domain=domain, preferred_domain_list=[])
-                            Quant.quants_reserve(quants, move, record)
-            else:
-                lot_qty = {}
-                rounding = ops.product_id.uom_id.rounding
-                for pack_lot in ops.pack_lot_ids:
-                    lot_qty[pack_lot.lot_id.id] = ops.product_uom_id._compute_quantity(pack_lot.qty, ops.product_id.uom_id)
-                for record in ops.linked_move_operation_ids:
-                    move_qty = record.qty
-                    move = record.move_id
-                    domain = main_domain[move.id]
-                    for lot in lot_qty:
-                        if float_compare(lot_qty[lot], 0, precision_rounding=rounding) > 0 and float_compare(move_qty, 0, precision_rounding=rounding) > 0:
-                            qty = min(lot_qty[lot], move_qty)
-                            quants = Quant.quants_get_preferred_domain(qty, move, ops=ops, lot_id=lot, domain=domain, preferred_domain_list=[])
-                            Quant.quants_reserve(quants, move, record)
-                            lot_qty[lot] -= qty
-                            move_qty -= qty
-
-        # Sort moves to reserve first the ones with ancestors, in case the same product is listed in
-        # different stock moves.
-        for move in sorted(moves_to_do, key=lambda x: -1 if ancestors_list.get(x.id) else 0):
-            # then if the move isn't totally assigned, try to find quants without any specific domain
-            if move.state != 'assigned' and not self.env.context.get('reserve_only_ops'):
-                qty_already_assigned = move.reserved_availability
-                qty = move.product_qty - qty_already_assigned
-
-                quants = Quant.quants_get_preferred_domain(qty, move, domain=main_domain[move.id], preferred_domain_list=[])
-                Quant.quants_reserve(quants, move)
-
-        # force assignation of consumable products and incoming from supplier/inventory/production
-        # Do not take force_assign as it would create pack operations
-        if moves_to_assign:
-            moves_to_assign.write({'state': 'assigned'})
-        if not no_prepare:
-            self.check_recompute_pack_op()
-
-    @api.multi
-    def action_cancel(self):
-        """ Cancels the moves and if all moves are cancelled it cancels the picking. """
-        # TDE DUMB: why is cancel_procuremetn in ctx we do quite nothing ?? like not updating the move ??
-        if any(move.state == 'done' for move in self):
-            raise UserError(_('You cannot cancel a stock move that has been set to \'Done\'.'))
-
-        procurements = self.env['procurement.order']
-        for move in self:
-            if move.reserved_quant_ids:
-                move.quants_unreserve()
-            if self.env.context.get('cancel_procurement'):
-                if move.propagate:
-                    pass
-                    # procurements.search([('move_dest_id', '=', move.id)]).cancel()
-            else:
-                if move.move_dest_id:
-                    if move.propagate:
-                        move.move_dest_id.action_cancel()
-                    elif move.move_dest_id.state == 'waiting':
-                        # If waiting, the chain will be broken and we are not sure if we can still wait for it (=> could take from stock instead)
-                        move.move_dest_id.write({'state': 'confirmed'})
-                if move.procurement_id:
-                    procurements |= move.procurement_id
-
-        self.write({'state': 'cancel', 'move_dest_id': False})
-        if procurements:
-            procurements.check()
+    def action_assign(self):
         return True
 
-    def recalculate_move_state(self):
-        '''Recompute the state of moves given because their reserved quants were used to fulfill another operation'''
-        # TDE FIXME: what is the real purpose of this ? probably clean me
-        for move in self:
-            vals = {}
-            reserved_quant_ids = move.reserved_quant_ids
-            if len(reserved_quant_ids) > 0 and not move.partially_available:
-                vals['partially_available'] = True
-            if len(reserved_quant_ids) == 0 and move.partially_available:
-                vals['partially_available'] = False
-            if move.state == 'assigned':
-                if move.procure_method == 'make_to_order' or move.find_move_ancestors():
-                    vals['state'] = 'waiting'
-                else:
-                    vals['state'] = 'confirmed'
-            if vals:
-                move.write(vals)
-
-    @api.model
-    def _move_quants_by_lot(self, ops, lot_qty, quants_taken, false_quants, lot_move_qty, quant_dest_package_id):
-        """
-        This function is used to process all the pack operation lots of a pack operation
-        For every move:
-            First, we check the quants with lot already reserved (and those are already subtracted from the lots to do)
-            Then go through all the lots to process:
-                Add reserved false lots lot by lot
-                Check if there are not reserved quants or reserved elsewhere with that lot or without lot (with the traditional method)
-        """
-        return self.browse(lot_move_qty)._move_quants_by_lot_v10(quants_taken, false_quants, ops, lot_qty, lot_move_qty, quant_dest_package_id)
-
     @api.multi
-    def _move_quants_by_lot_v10(self, quants_taken, false_quants, pack_operation, lot_quantities, lot_move_quantities, dest_package_id):
-        Quant = self.env['stock.quant']
-        rounding = pack_operation.product_id.uom_id.rounding
-        preferred_domain_list = [[('reservation_id', '=', False)], ['&', ('reservation_id', 'not in', self.ids), ('reservation_id', '!=', False)]]
-
-        for move_rec_updateme in self:
-            from collections import defaultdict
-            lot_to_quants = defaultdict(list)
-
-            # Assign quants already reserved with lot to the correct
-            for quant in quants_taken:
-                if quant[0] <= move_rec_updateme.reserved_quant_ids:
-                    lot_to_quants[quant[0].lot_id.id].append(quant)
-
-            false_quants_move = [x for x in false_quants if x[0].reservation_id.id == move_rec_updateme.id]
-            for lot_id in lot_quantities:
-                redo_false_quants = False
-
-                # Take remaining reserved quants with  no lot first
-                # (This will be used mainly when incoming had no lot and you do outgoing with)
-                while false_quants_move and float_compare(lot_quantities[lot_id], 0, precision_rounding=rounding) > 0 and float_compare(lot_move_quantities[move_rec_updateme.id], 0, precision_rounding=rounding) > 0:
-                    qty_min = min(lot_quantities[lot_id], lot_move_quantities[move_rec_updateme.id])
-                    if false_quants_move[0].qty > qty_min:
-                        lot_to_quants[lot_id] += [(false_quants_move[0], qty_min)]
-                        qty = qty_min
-                        redo_false_quants = True
-                    else:
-                        qty = false_quants_move[0].qty
-                        lot_to_quants[lot_id] += [(false_quants_move[0], qty)]
-                        false_quants_move.pop(0)
-                    lot_quantities[lot_id] -= qty
-                    lot_move_quantities[move_rec_updateme.id] -= qty
-
-                # Search other with first matching lots and then without lots
-                if float_compare(lot_move_quantities[move_rec_updateme.id], 0, precision_rounding=rounding) > 0 and float_compare(lot_quantities[lot_id], 0, precision_rounding=rounding) > 0:
-                    # Search if we can find quants with that lot
-                    qty = min(lot_quantities[lot_id], lot_move_quantities[move_rec_updateme.id])
-                    quants = Quant.quants_get_preferred_domain(
-                        qty, move_rec_updateme, ops=pack_operation, lot_id=lot_id, domain=[('qty', '>', 0)],
-                        preferred_domain_list=preferred_domain_list)
-                    lot_to_quants[lot_id] += quants
-                    lot_quantities[lot_id] -= qty
-                    lot_move_quantities[move_rec_updateme.id] -= qty
-
-                # Move all the quants related to that lot/move
-                if lot_to_quants[lot_id]:
-                    Quant.quants_move(
-                        lot_to_quants[lot_id], move_rec_updateme, pack_operation.location_dest_id,
-                        location_from=pack_operation.location_id, lot_id=lot_id,
-                        owner_id=pack_operation.owner_id.id, src_package_id=pack_operation.package_id.id,
-                        dest_package_id=dest_package_id)
-                    if redo_false_quants:
-                        false_quants_move = [x for x in move_rec_updateme.reserved_quant_ids if (not x.lot_id) and (x.owner_id.id == pack_operation.owner_id.id) and
-                                             (x.location_id.id == pack_operation.location_id.id) and (x.package_id.id == pack_operation.package_id.id)]
+    def action_cancel(self):
         return True
 
     @api.multi
@@ -977,9 +743,3 @@ class StockMove(models.Model):
             'res_id': self.id}
     show_picking = action_show_picking
 
-    # Quants management
-    # ----------------------------------------------------------------------
-
-    def quants_unreserve(self):
-        self.filtered(lambda x: x.partially_available).write({'partially_available': False})
-        self.mapped('reserved_quant_ids').sudo().write({'reservation_id': False})

--- a/addons/stock/models/stock_picking.py
+++ b/addons/stock/models/stock_picking.py
@@ -253,10 +253,6 @@ class Picking(models.Model):
     picking_type_entire_packs = fields.Boolean(related='picking_type_id.show_entire_packs',
         readonly=True)
 
-    quant_reserved_exist = fields.Boolean(
-        'Has quants already reserved', compute='_compute_quant_reserved_exist',
-        help='Check the existance of quants linked to this picking')
-
     partner_id = fields.Many2one(
         'res.partner', 'Partner',
         states={'done': [('readonly', True)], 'cancel': [('readonly', True)]})
@@ -358,11 +354,6 @@ class Picking(models.Model):
         # TDE FIXME: better implementation
         self.has_scrap_move = bool(self.env['stock.move'].search_count([('picking_id', '=', self.id), ('scrapped', '=', True)]))
 
-    @api.one
-    def _compute_quant_reserved_exist(self):
-        # TDE TODO: chould probably be cleaned with a search in quants
-        self.quant_reserved_exist = any(move.reserved_quant_ids for move in self.mapped('move_lines'))
-
     @api.one
     def _compute_pack_operation_exist(self):
         self.pack_operation_exist = bool(self.pack_operation_ids)
@@ -621,15 +612,7 @@ class Picking(models.Model):
 
     @api.multi
     def do_unreserve(self):
-        """
-          Will remove all quants for picking in picking_ids
-        """
-        moves_to_unreserve = self.mapped('move_lines').filtered(lambda move: move.state not in ('done', 'cancel'))
-        pack_line_to_unreserve = self.mapped('pack_operation_ids')
-        if moves_to_unreserve:
-            if pack_line_to_unreserve:
-                pack_line_to_unreserve.unlink()
-            moves_to_unreserve.do_unreserve()
+        return True
 
     def recompute_remaining_qty(self, done_qtys=False):
 

--- a/addons/stock/models/stock_production_lot.py
+++ b/addons/stock/models/stock_production_lot.py
@@ -38,9 +38,8 @@ class ProductionLot(models.Model):
         return super(ProductionLot, self).create(vals)
 
     @api.one
-    @api.depends('quant_ids.qty')
     def _product_qty(self):
-        self.product_qty = sum(self.quant_ids.mapped('qty'))
+        self.product_qty = sum(self.quant_ids.mapped('quantity'))
 
     @api.multi
     def action_traceability(self):

--- a/addons/stock/models/stock_quant.py
+++ b/addons/stock/models/stock_quant.py
@@ -1,561 +1,226 @@
-from datetime import datetime
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
 
-from odoo import api, fields, models
-from odoo.tools.float_utils import float_compare, float_round
-from odoo.tools.translate import _
-from odoo.tools import DEFAULT_SERVER_DATETIME_FORMAT, pycompat
-from odoo.exceptions import UserError
+from psycopg2 import OperationalError
 
-import logging
+from odoo import api, fields, models, _
+from odoo.exceptions import UserError, ValidationError
+from odoo.tools import pycompat
+from odoo.osv import expression
 
-_logger = logging.getLogger(__name__)
 
+class StockQuant(models.Model):
+    _name = 'stock.quant'
+    _description = 'Quants'
 
-class Quant(models.Model):
-    """ Quants are the smallest unit of stock physical instances """
-    _name = "stock.quant"
-    _description = "Quants"
-
-    name = fields.Char(string='Identifier', compute='_compute_name')
     product_id = fields.Many2one(
         'product.product', 'Product',
-        index=True, ondelete="restrict", readonly=True, required=True)
+        ondelete='restrict', readonly=True, required=True)
+    product_uom_id = fields.Many2one(
+        'product.uom', 'Unit of Measure',
+        readonly=True, related='product_id.uom_id')
+    company_id = fields.Many2one(
+        'res.company', 'Company',
+        default=lambda self: self.env['res.company']._company_default_get('stock.quant'),
+        help='The company to which the quants belong',
+        readonly=True, required=True)
     location_id = fields.Many2one(
         'stock.location', 'Location',
-        auto_join=True, index=True, ondelete="restrict", readonly=True, required=True)
-    qty = fields.Float(
-        'Quantity',
-        index=True, readonly=True, required=True,
-        help="Quantity of products in this quant, in the default unit of measure of the product")
-    product_uom_id = fields.Many2one(
-        'product.uom', string='Unit of Measure', related='product_id.uom_id',
-        readonly=True)
-    package_id = fields.Many2one(
-        'stock.quant.package', string='Package',
-        index=True, readonly=True,
-        help="The package containing this quant")
-    packaging_type_id = fields.Many2one(
-        'product.packaging', string='Type of packaging', related='package_id.packaging_id',
-        readonly=True, store=True)
-    reservation_id = fields.Many2one(
-        'stock.move', 'Reserved for Move',
-        index=True, readonly=True,
-        help="The move the quant is reserved for")
+        auto_join=True, ondelete='restrict', readonly=True, required=True)
     lot_id = fields.Many2one(
         'stock.production.lot', 'Lot/Serial Number',
-        index=True, ondelete="restrict", readonly=True)
-    cost = fields.Float('Unit Cost', group_operator='avg')
+        ondelete='restrict', readonly=True)
+    package_id = fields.Many2one(
+        'stock.quant.package', 'Package',
+        help='The package containing this quant', readonly=True)
     owner_id = fields.Many2one(
         'res.partner', 'Owner',
-        index=True, readonly=True,
-        help="This is the owner of the quant")
-    create_date = fields.Datetime('Creation Date', readonly=True)
-    in_date = fields.Datetime('Incoming Date', index=True, readonly=True)
-    history_ids = fields.Many2many(
-        'stock.move', 'stock_quant_move_rel', 'quant_id', 'move_id',
-        string='Moves', copy=False,
-        help='Moves that operate(d) on this quant')
-    company_id = fields.Many2one(
-        'res.company', 'Company',
-        index=True, readonly=True, required=True,
-        default=lambda self: self.env['res.company']._company_default_get('stock.quant'),
-        help="The company to which the quants belong")
-    inventory_value = fields.Float('Inventory Value', compute='_compute_inventory_value', readonly=True)
-    # Used for negative quants to reconcile after compensated by a new positive one
-    propagated_from_id = fields.Many2one(
-        'stock.quant', 'Linked Quant',
-        index=True, readonly=True,
-        help='The negative quant this is coming from')
-    negative_move_id = fields.Many2one(
-        'stock.move', 'Move Negative Quant',
-        readonly=True,
-        help='If this is a negative quant, this will be the move that caused this negative quant.')
-    negative_dest_location_id = fields.Many2one(
-        'stock.location', "Negative Destination Location", related='negative_move_id.location_dest_id',
-        readonly=True,
-        help="Technical field used to record the destination location of a move that created a negative quant")
+        help='This is the owner of the quant', readonly=True)
+    quantity = fields.Float(
+        'Quantity',
+        help='Quantity of products in this quant, in the default unit of measure of the product',
+        readonly=True, required=True, oldname='qty')
+    reserved_quantity = fields.Float(
+        'Reserved Quantity',
+        default=0.0,
+        help='Quantity of reserved products in this quant, in the default unit of measure of the product',
+        readonly=True, required=True)
+    in_date = fields.Datetime('Incoming Date', readonly=True)
 
-    @api.one
-    def _compute_name(self):
-        """ Forms complete name of location from parent location to child location. """
-        self.name = '%s: %s%s' % (self.lot_id.name or self.product_id.code or '', self.qty, self.product_id.uom_id.name)
+    @api.multi
+    @api.constrains('product_id')
+    def check_product_id(self):
+        if any(elem.product_id.type == 'consu' for elem in self):
+            raise ValidationError(_('Quants cannot be created for consumables.'))
 
     @api.multi
-    def _compute_inventory_value(self):
+    @api.constrains('quantity')
+    def check_quantity(self):
         for quant in self:
-            if quant.company_id != self.env.user.company_id:
-                # if the company of the quant is different than the current user company, force the company in the context
-                # then re-do a browse to read the property fields for the good company.
-                quant = quant.with_context(force_company=quant.company_id.id)
-            quant.inventory_value = quant.product_id.standard_price * quant.qty
-
-    @api.model_cr
-    def init(self):
-        self._cr.execute('SELECT indexname FROM pg_indexes WHERE indexname = %s', ('stock_quant_product_location_index',))
-        if not self._cr.fetchone():
-            self._cr.execute('CREATE INDEX stock_quant_product_location_index ON stock_quant (product_id, location_id, company_id, qty, in_date, reservation_id)')
+            if quant.quantity > 1 and quant.lot_id and quant.product_id.tracking == 'serial':
+                raise ValidationError(_('A serial number should only be linked to a single product.'))
 
-    @api.multi
-    def unlink(self):
-        # TDE FIXME: should probably limitate unlink to admin and sudo calls to unlink, because context is not safe
-        if not self.env.context.get('force_unlink'):
-            raise UserError(_('Under no circumstances should you delete or change quants yourselves!'))
-        return super(Quant, self).unlink()
+    @api.one
+    def _compute_name(self):
+        self.name = '%s: %s%s' % (self.lot_id.name or self.product_id.code or '', self.quantity, self.product_id.uom_id.name)
 
     @api.model
-    def read_group(self, domain, fields, groupby, offset=0, limit=None, orderby=False, lazy=True):
-        " Overwrite the read_group in order to sum the function field 'inventory_value' in group by "
-        # TDE NOTE: WHAAAAT ??? is this because inventory_value is not stored ?
-        # TDE FIXME: why not storing the inventory_value field ? company_id is required, stored, and should not create issues
-        res = super(Quant, self).read_group(domain, fields, groupby, offset=offset, limit=limit, orderby=orderby, lazy=lazy)
-        if 'inventory_value' in fields:
-            for line in res:
-                if '__domain' in line:
-                    lines = self.search(line['__domain'])
-                    inv_value = 0.0
-                    for line2 in lines:
-                        inv_value += line2.inventory_value
-                    line['inventory_value'] = inv_value
-        return res
+    def _get_removal_strategy(self, product_id, location_id):
+        if product_id.categ_id.removal_strategy_id:
+            return product_id.categ_id.removal_strategy_id.method
+        loc = location_id
+        while loc:
+            if loc.removal_strategy_id:
+                return loc.removal_strategy_id.method
+            loc = loc.location_id
+        return 'fifo'
 
-    @api.multi
-    def action_view_quant_history(self):
-        ''' Returns an action that display the history of the quant, which
-        mean all the stock moves that lead to this quant creation with this
-        quant quantity. '''
-        action = self.env.ref('stock', 'stock_move_action').read()[0]
-        action['domain'] = [('id', 'in', self.mapped('history_ids').ids)]
-        return action
+    @api.model
+    def _get_removal_strategy_order(self, removal_strategy):
+        if removal_strategy == 'fifo':
+            return 'in_date, id'
+        elif removal_strategy == 'lifo':
+            return 'in_date desc, id desc'
+        raise UserError(_('Removal strategy %s not implemented.') % (removal_strategy,))
+
+    def _gather(self, product_id, location_id, lot_id=None, package_id=None, owner_id=None, strict=False):
+        removal_strategy = self._get_removal_strategy(product_id, location_id)
+        removal_strategy_order = self._get_removal_strategy_order(removal_strategy)
+        domain = [
+            ('product_id', '=', product_id.id),
+            ('location_id', 'child_of', location_id.id),
+        ]
+        if not strict:
+            if lot_id:
+                domain = expression.AND([[('lot_id', '=', lot_id.id)], domain])
+            if package_id:
+                domain = expression.AND([[('package_id', '=', package_id.id)], domain])
+            if owner_id:
+                domain = expression.AND([[('owner_id', '=', owner_id.id)], domain])
+        else:
+            domain = expression.AND([[('lot_id', '=', lot_id and lot_id.id or False)], domain])
+            domain = expression.AND([[('package_id', '=', package_id and package_id.id or False)], domain])
+            domain = expression.AND([[('owner_id', '=', owner_id and owner_id.id or False)], domain])
+
+        return self.search(domain, order=removal_strategy_order)
 
     @api.model
-    def quants_reserve(self, quants, move, link=False):
-        ''' This function reserves quants for the given move and optionally
-        given link. If the total of quantity reserved is enough, the move state
-        is also set to 'assigned'
-
-        :param quants: list of tuple(quant browse record or None, qty to reserve). If None is given as first tuple element, the item will be ignored. Negative quants should not be received as argument
-        :param move: browse record
-        :param link: browse record (stock.move.operation.link)
-        '''
-        # TDE CLEANME: use ids + quantities dict
-        # TDE CLEANME: check use of sudo
-        quants_to_reserve_sudo = self.env['stock.quant'].sudo()
-        reserved_availability = move.reserved_availability
-        # split quants if needed
-        for quant, qty in quants:
-            if qty <= 0.0 or (quant and quant.qty <= 0.0):
-                raise UserError(_('You can not reserve a negative quantity or a negative quant.'))
-            if not quant:
-                continue
-            quant._quant_split(qty)
-            quants_to_reserve_sudo |= quant
-            reserved_availability += quant.qty
-        # reserve quants
-        if quants_to_reserve_sudo:
-            quants_to_reserve_sudo.write({'reservation_id': move.id})
-        # check if move state needs to be set as 'assigned'
-        # TDE CLEANME: should be moved as a move model method IMO
-        rounding = move.product_id.uom_id.rounding
-        if float_compare(reserved_availability, move.product_qty, precision_rounding=rounding) == 0 and move.state in ('confirmed', 'waiting'):
-            move.write({'state': 'assigned'})
-        elif float_compare(reserved_availability, 0, precision_rounding=rounding) > 0 and not move.partially_available:
-            move.write({'partially_available': True})
+    def _get_quantity(self, product_id, location_id, lot_id=None, package_id=None, owner_id=None, strict=False):
+        self = self.sudo()
+        quants = self._gather(product_id, location_id, lot_id=lot_id, package_id=package_id, owner_id=owner_id, strict=strict)
+        return sum(quants.mapped('quantity'))
 
     @api.model
-    def quants_move(self, quants, move, location_to, location_from=False, lot_id=False, owner_id=False, src_package_id=False, dest_package_id=False, entire_pack=False):
-        """Moves all given stock.quant in the given destination location.  Unreserve from current move.
-        :param quants: list of tuple(browse record(stock.quant) or None, quantity to move)
-        :param move: browse record (stock.move)
-        :param location_to: browse record (stock.location) depicting where the quants have to be moved
-        :param location_from: optional browse record (stock.location) explaining where the quant has to be taken
-                              (may differ from the move source location in case a removal strategy applied).
-                              This parameter is only used to pass to _quant_create_from_move if a negative quant must be created
-        :param lot_id: ID of the lot that must be set on the quants to move
-        :param owner_id: ID of the partner that must own the quants to move
-        :param src_package_id: ID of the package that contains the quants to move
-        :param dest_package_id: ID of the package that must be set on the moved quant
+    def _get_available_quantity(self, product_id, location_id, lot_id=None, package_id=None, owner_id=None, strict=False):
+        """ Return the available quantity, i.e. the sum of `quantity` minus the sum of
+        `reserved_quantity`, for the set of quants sharing the combination of `product_id,
+        location_id` if `strict` is set to False or sharing the *exact same characteristics*
+        otherwise.
+        This method is called in the following usecases:
+            - when a stock move checks its availability
+            - when a stock move actually assign
+            - when editing a move line, to check if the new value is forced or not
+            - when validating a move line with some forced values and have to potentially unlink an
+              equivalent move line in another picking
+        In the two first usecases, `strict` should be set to `False`, as we don't know what exact
+        quants we'll reserve, and the characteristics are meaningless in this context.
+        In the last ones, `strict` should be set to `True`, as we work on a specific set of
+        characteristics.
+
+        :return: available quantity as a float
         """
-        # TDE CLEANME: use ids + quantities dict
-        if location_to.usage == 'view':
-            raise UserError(_('You cannot move to a location of type view %s.') % (location_to.name))
-
-        quants_reconcile_sudo = self.env['stock.quant'].sudo()
-        quants_move_sudo = self.env['stock.quant'].sudo()
-        check_lot = False
-        for quant, qty in quants:
-            if not quant:
-                #If quant is None, we will create a quant to move (and potentially a negative counterpart too)
-                quant = self._quant_create_from_move(
-                    qty, move, lot_id=lot_id, owner_id=owner_id, src_package_id=src_package_id, dest_package_id=dest_package_id, force_location_from=location_from, force_location_to=location_to)
-                check_lot = True
-            else:
-                quant._quant_split(qty)
-                quants_move_sudo |= quant
-            quants_reconcile_sudo |= quant
-
-        if quants_move_sudo:
-            moves_recompute = quants_move_sudo.filtered(lambda self: self.reservation_id != move).mapped('reservation_id')
-            quants_move_sudo._quant_update_from_move(move, location_to, dest_package_id, lot_id=lot_id, entire_pack=entire_pack)
-            moves_recompute.recalculate_move_state()
-
-        if location_to.usage == 'internal':
-            # Do manual search for quant to avoid full table scan (order by id)
-            self._cr.execute("""
-                SELECT 0 FROM stock_quant, stock_location WHERE product_id = %s AND stock_location.id = stock_quant.location_id AND
-                ((stock_location.parent_left >= %s AND stock_location.parent_left < %s) OR stock_location.id = %s) AND qty < 0.0 LIMIT 1
-            """, (move.product_id.id, location_to.parent_left, location_to.parent_right, location_to.id))
-            if self._cr.fetchone():
-                quants_reconcile_sudo._quant_reconcile_negative(move)
-
-        # In case of serial tracking, check if the product does not exist somewhere internally already
-        # Checking that a positive quant already exists in an internal location is too restrictive.
-        # Indeed, if a warehouse is configured with several steps (e.g. "Pick + Pack + Ship") and
-        # one step is forced (creates a quant of qty = -1.0), it is not possible afterwards to
-        # correct the inventory unless the product leaves the stock.
-        picking_type = move.picking_id and move.picking_id.picking_type_id or False
-        if check_lot and lot_id and move.product_id.tracking == 'serial' and (not picking_type or (picking_type.use_create_lots or picking_type.use_existing_lots)):
-            other_quants = self.search([('product_id', '=', move.product_id.id), ('lot_id', '=', lot_id),
-                                        ('qty', '>', 0.0), ('location_id.usage', '=', 'internal')])
-            if other_quants:
-                # We raise an error if:
-                # - the total quantity is strictly larger than 1.0
-                # - there are more than one negative quant, to avoid situations where the user would
-                #   force the quantity at several steps of the process
-                if sum(other_quants.mapped('qty')) > 1.0 or len([q for q in other_quants.mapped('qty') if q < 0]) > 1:
-                    lot_name = self.env['stock.production.lot'].browse(lot_id).name
-                    raise UserError(_('The serial number %s is already in stock.') % lot_name + _("Otherwise make sure the right stock/owner is set."))
+        self = self.sudo()
+        quants = self._gather(product_id, location_id, lot_id=lot_id, package_id=package_id, owner_id=owner_id, strict=strict)
+        return sum(quants.mapped('quantity')) - sum(quants.mapped('reserved_quantity'))
 
     @api.model
-    def _quant_create_from_move(self, qty, move, lot_id=False, owner_id=False,
-                                src_package_id=False, dest_package_id=False,
-                                force_location_from=False, force_location_to=False):
-        '''Create a quant in the destination location and create a negative
-        quant in the source location if it's an internal location. '''
-        price_unit = move.get_price_unit()
-        location = force_location_to or move.location_dest_id
-        rounding = move.product_id.uom_id.rounding
-        vals = {
-            'product_id': move.product_id.id,
-            'location_id': location.id,
-            'qty': float_round(qty, precision_rounding=rounding),
-            'cost': price_unit,
-            'history_ids': [(4, move.id)],
-            'in_date': datetime.now().strftime(DEFAULT_SERVER_DATETIME_FORMAT),
-            'company_id': move.company_id.id,
-            'lot_id': lot_id,
-            'owner_id': owner_id,
-            'package_id': dest_package_id,
-        }
-        if move.location_id.usage == 'internal':
-            # if we were trying to move something from an internal location and reach here (quant creation),
-            # it means that a negative quant has to be created as well.
-            negative_vals = vals.copy()
-            negative_vals['location_id'] = force_location_from and force_location_from.id or move.location_id.id
-            negative_vals['qty'] = float_round(-qty, precision_rounding=rounding)
-            negative_vals['cost'] = price_unit
-            negative_vals['negative_move_id'] = move.id
-            negative_vals['package_id'] = src_package_id
-            negative_quant_id = self.sudo().create(negative_vals)
-            vals.update({'propagated_from_id': negative_quant_id.id})
-
-        picking_type = move.picking_id and move.picking_id.picking_type_id or False
-        if lot_id and move.product_id.tracking == 'serial' and (not picking_type or (picking_type.use_create_lots or picking_type.use_existing_lots)):
-            if qty != 1.0:
-                raise UserError(_('You should only receive by the piece with the same serial number'))
-
-        # create the quant as superuser, because we want to restrict the creation of quant manually: we should always use this method to create quants
-        return self.sudo().create(vals)
-
-    @api.multi
-    def _quant_update_from_move(self, move, location_dest_id, dest_package_id, lot_id=False, entire_pack=False):
-        vals = {
-            'location_id': location_dest_id.id,
-            'history_ids': [(4, move.id)],
-            'reservation_id': False}
-        if lot_id and any(quant for quant in self if not quant.lot_id.id):
-            vals['lot_id'] = lot_id
-        if not entire_pack:
-            vals.update({'package_id': dest_package_id})
-        self.write(vals)
-
-    @api.one
-    def _quant_reconcile_negative(self, move):
-        """
-            When new quant arrive in a location, try to reconcile it with
-            negative quants. If it's possible, apply the cost of the new
-            quant to the counterpart of the negative quant.
-        """
-        solving_quant = self
-        quants = self._search_quants_to_reconcile()
-        product_uom_rounding = self.product_id.uom_id.rounding
-        for quant_neg, qty in quants:
-            if not quant_neg or not solving_quant:
-                continue
-            quants_to_solve = self.search([('propagated_from_id', '=', quant_neg.id)])
-            if not quants_to_solve:
-                continue
-            solving_qty = qty
-            solved_quants = self.env['stock.quant'].sudo()
-            for to_solve_quant in quants_to_solve:
-                if float_compare(solving_qty, 0, precision_rounding=product_uom_rounding) <= 0:
+    def _increase_available_quantity(self, product_id, location_id, quantity, lot_id=None, package_id=None, owner_id=None, strict=True):
+        self = self.sudo()
+        quants = self._gather(product_id, location_id, lot_id=lot_id, package_id=package_id, owner_id=owner_id, strict=strict)
+        for quant in quants:
+            try:
+                with self._cr.savepoint():
+                    self._cr.execute("SELECT 1 FROM stock_quant WHERE id = %s FOR UPDATE NOWAIT", [quant.id], log_exceptions=False)
+                    quant.quantity += quantity
+                    # cleanup empty quants
+                    if quant.quantity == 0 and quant.reserved_quantity == 0:
+                        quant.unlink()
+                    break
+            except OperationalError, e:
+                if e.pgcode == '55P03':  # could not obtain the lock
                     continue
-                solved_quants |= to_solve_quant
-                to_solve_quant._quant_split(min(solving_qty, to_solve_quant.qty))
-                solving_qty -= min(solving_qty, to_solve_quant.qty)
-            remaining_solving_quant = solving_quant._quant_split(qty)
-            remaining_neg_quant = quant_neg._quant_split(-qty)
-            # if the reconciliation was not complete, we need to link together the remaining parts
-            if remaining_neg_quant:
-                remaining_to_solves = self.sudo().search([('propagated_from_id', '=', quant_neg.id), ('id', 'not in', solved_quants.ids)])
-                if remaining_to_solves:
-                    remaining_to_solves.write({'propagated_from_id': remaining_neg_quant.id})
-            if solving_quant.propagated_from_id and solved_quants:
-                solved_quants.write({'propagated_from_id': solving_quant.propagated_from_id.id})
-            # delete the reconciled quants, as it is replaced by the solved quants
-            quant_neg.sudo().with_context(force_unlink=True).unlink()
-            if solved_quants:
-                # price update + accounting entries adjustments
-                solved_quants._price_update(solving_quant.cost)
-                # merge history (and cost?)
-                solved_quants.write(solving_quant._prepare_history())
-            solving_quant.with_context(force_unlink=True).unlink()
-            solving_quant = remaining_solving_quant
-
-    def _prepare_history(self):
-        return {
-            'history_ids': [(4, history_move.id) for history_move in self.history_ids],
-        }
-
-    @api.multi
-    def _price_update(self, newprice):
-        # TDE note: use ACLs instead of sudoing everything
-        self.sudo().write({'cost': newprice})
-
-    @api.multi
-    def _search_quants_to_reconcile(self):
-        """ Searches negative quants to reconcile for where the quant to reconcile is put """
-        dom = ['&', '&', '&', '&',
-               ('qty', '<', 0),
-               ('location_id', 'child_of', self.location_id.id),
-               ('product_id', '=', self.product_id.id),
-               ('owner_id', '=', self.owner_id.id),
-               # Do not let the quant eat itself, or it will kill its history (e.g. returns / Stock -> Stock)
-               ('id', '!=', self.propagated_from_id.id)]
-        if self.package_id.id:
-            dom = ['&'] + dom + [('package_id', '=', self.package_id.id)]
-        if self.lot_id:
-            dom = ['&'] + dom + ['|', ('lot_id', '=', False), ('lot_id', '=', self.lot_id.id)]
-            order = 'lot_id, in_date'
+                else:
+                    raise
         else:
-            order = 'in_date'
-
-        rounding = self.product_id.uom_id.rounding
-        quants = []
-        quantity = self.qty
-        for quant in self.search(dom, order=order):
-            if float_compare(quantity, abs(quant.qty), precision_rounding=rounding) >= 0:
-                quants += [(quant, abs(quant.qty))]
-                quantity -= abs(quant.qty)
-            elif float_compare(quantity, 0.0, precision_rounding=rounding) != 0:
-                quants += [(quant, quantity)]
-                quantity = 0
-                break
-        return quants
+            self.create({
+                'product_id': product_id.id,
+                'location_id': location_id.id,
+                'quantity': quantity,
+                'lot_id': lot_id and lot_id.id,
+                'package_id': package_id and package_id.id,
+                'owner_id': owner_id and owner_id.id,
+            })
+        return self._get_available_quantity(product_id, location_id, lot_id=lot_id, package_id=package_id, owner_id=owner_id, strict=strict)
 
     @api.model
-    def quants_get_preferred_domain(self, qty, move, ops=False, lot_id=False, domain=None, preferred_domain_list=[]):
-        ''' This function tries to find quants for the given domain and move/ops, by trying to first limit
-            the choice on the quants that match the first item of preferred_domain_list as well. But if the qty requested is not reached
-            it tries to find the remaining quantity by looping on the preferred_domain_list (tries with the second item and so on).
-            Make sure the quants aren't found twice => all the domains of preferred_domain_list should be orthogonal
-        '''
-        return self.quants_get_reservation(
-            qty, move,
-            pack_operation_id=ops and ops.id or False,
-            lot_id=lot_id,
-            company_id=self.env.context.get('company_id', False),
-            domain=domain,
-            preferred_domain_list=preferred_domain_list)
-
-    def quants_get_reservation(self, qty, move, pack_operation_id=False, lot_id=False, company_id=False, domain=None, preferred_domain_list=None):
-        ''' This function tries to find quants for the given domain and move/ops, by trying to first limit
-            the choice on the quants that match the first item of preferred_domain_list as well. But if the qty requested is not reached
-            it tries to find the remaining quantity by looping on the preferred_domain_list (tries with the second item and so on).
-            Make sure the quants aren't found twice => all the domains of preferred_domain_list should be orthogonal
-        '''
-        # TDE FIXME: clean me
-        reservations = [(None, qty)]
-
-        pack_operation = self.env['stock.pack.operation'].browse(pack_operation_id)
-        location = pack_operation.location_id if pack_operation else move.location_id
-
-        # don't look for quants in location that are of type production, supplier or inventory.
-        if location.usage in ['inventory', 'production', 'supplier']:
-            return reservations
-            # return self._Reservation(reserved_quants, qty, qty, move, None)
-
-        restrict_lot_id = lot_id if pack_operation else move.restrict_lot_id.id or lot_id
-        removal_strategy = move.get_removal_strategy()
-
-        domain = self._quants_get_reservation_domain(
-            move,
-            pack_operation_id=pack_operation_id,
-            lot_id=lot_id,
-            company_id=company_id,
-            initial_domain=domain)
-
-        if not restrict_lot_id and not preferred_domain_list:
-            meta_domains = [[]]
-        elif restrict_lot_id and not preferred_domain_list:
-            meta_domains = [[('lot_id', '=', restrict_lot_id)], [('lot_id', '=', False)]]
-        elif restrict_lot_id and preferred_domain_list:
-            lot_list = []
-            no_lot_list = []
-            for inner_domain in preferred_domain_list:
-                lot_list.append(inner_domain + [('lot_id', '=', restrict_lot_id)])
-                no_lot_list.append(inner_domain + [('lot_id', '=', False)])
-            meta_domains = lot_list + no_lot_list
-        else:
-            meta_domains = preferred_domain_list
-
-        res_qty = qty
-        while (float_compare(res_qty, 0, precision_rounding=move.product_id.uom_id.rounding) and meta_domains):
-            additional_domain = meta_domains.pop(0)
-            reservations.pop()
-            new_reservations = self._quants_get_reservation(
-                res_qty, move,
-                ops=pack_operation,
-                domain=domain + additional_domain,
-                removal_strategy=removal_strategy)
-            for quant in new_reservations:
-                if quant[0]:
-                    res_qty -= quant[1]
-            reservations += new_reservations
-
-        return reservations
-
-    def _quants_get_reservation_domain(self, move, pack_operation_id=False, lot_id=False, company_id=False, initial_domain=None):
-        initial_domain = initial_domain if initial_domain is not None else [('qty', '>', 0.0)]
-        domain = initial_domain + [('product_id', '=', move.product_id.id)]
-
-        if pack_operation_id:
-            pack_operation = self.env['stock.pack.operation'].browse(pack_operation_id)
-            domain += [('location_id', '=', pack_operation.location_id.id)]
-            if pack_operation.owner_id:
-                domain += [('owner_id', '=', pack_operation.owner_id.id)]
-            if pack_operation.package_id and not pack_operation.product_id:
-                domain += [('package_id', 'child_of', pack_operation.package_id.id)]
-            elif pack_operation.package_id and pack_operation.product_id:
-                domain += [('package_id', '=', pack_operation.package_id.id)]
-            else:
-                domain += [('package_id', '=', False)]
-        else:
-            domain += [('location_id', 'child_of', move.location_id.id)]
-            if move.restrict_partner_id:
-                domain += [('owner_id', '=', move.restrict_partner_id.id)]
-
-        if company_id:
-            domain += [('company_id', '=', company_id)]
-        else:
-            domain += [('company_id', '=', move.company_id.id)]
-
-        return domain
+    def _decrease_available_quantity(self, product_id, location_id, quantity, lot_id=None, package_id=None, owner_id=None, strict=True):
+        return self._increase_available_quantity(product_id, location_id, -quantity, lot_id=lot_id, package_id=package_id, owner_id=owner_id, strict=strict)
 
     @api.model
-    def _quants_removal_get_order(self, removal_strategy=None):
-        if removal_strategy == 'fifo':
-            return 'in_date, id'
-        elif removal_strategy == 'lifo':
-            return 'in_date desc, id desc'
-        raise UserError(_('Removal strategy %s not implemented.') % (removal_strategy,))
-
-    def _quants_get_reservation(self, quantity, move, ops=False, domain=None, orderby=None, removal_strategy=None):
-        ''' Implementation of removal strategies.
-
-        :return: a structure containing an ordered list of tuples: quants and
-                 the quantity to remove from them. A tuple (None, qty)
-                 represents a qty not possible to reserve.
-        '''
-        # TDE FIXME: try to clean
-        if removal_strategy:
-            order = self._quants_removal_get_order(removal_strategy)
-        elif orderby:
-            order = orderby
-        else:
-            order = 'in_date'
-        rounding = move.product_id.uom_id.rounding
-        domain = domain if domain is not None else [('qty', '>', 0.0)]
-        res = []
-        offset = 0
-
-        remaining_quantity = quantity
-        quants = self.search(domain, order=order, limit=10, offset=offset)
-        while float_compare(remaining_quantity, 0, precision_rounding=rounding) > 0 and quants:
-            for quant in quants:
-                if float_compare(remaining_quantity, abs(quant.qty), precision_rounding=rounding) >= 0:
-                    # reserved_quants.append(self._ReservedQuant(quant, abs(quant.qty)))
-                    res += [(quant, abs(quant.qty))]
-                    remaining_quantity -= abs(quant.qty)
-                elif float_compare(remaining_quantity, 0.0, precision_rounding=rounding) != 0:
-                    # reserved_quants.append(self._ReservedQuant(quant, remaining_quantity))
-                    res += [(quant, remaining_quantity)]
-                    remaining_quantity = 0
-            offset += 10
-            quants = self.search(domain, order=order, limit=10, offset=offset)
-
-        if float_compare(remaining_quantity, 0, precision_rounding=rounding) > 0:
-            res.append((None, remaining_quantity))
+    def _increase_reserved_quantity(self, product_id, location_id, quantity, lot_id=None, package_id=None, owner_id=None, strict=False):
+        """ Increase the reserved quantity, i.e. increase `reserved_quantity` for the set of quants
+        sharing the combination of `product_id, location_id` if `strict` is set to False or sharing
+        the *exact same characteristics* otherwise. Typically, this method is called when reserving
+        a move or updating a reserved move line. When reserving a chained move, the strict flag
+        should be enabled (to reserve exactly what was brought). When the move is MTS,it could take
+        anything from the stock, so we disable the flag. When editing a move line, we naturally
+        enable the flag, to reflect the reservation according to the edition.
+
+        :return: a list of tuples (quant, quantity_reserved) showing on which quant the reservation
+            was done and how much the system was able to reserve on it
+        """
+        self = self.sudo()
+        quants = self._gather(product_id, location_id, lot_id=lot_id, package_id=package_id, owner_id=owner_id, strict=strict)
+
+        quants_quantity = sum(quants.mapped('quantity'))
+        available_quantity = quants_quantity - sum(quants.mapped('reserved_quantity'))
+        if quantity > 0 and quantity > available_quantity:
+            raise UserError(_('It is not possible to reserve more products than you have in stock.'))
+        elif quantity < 0 and abs(quantity) > sum(quants.mapped('reserved_quantity')):
+            raise UserError(_('It is not possible to unreserve more products than you have in stock.'))
+
+        reserved_quants = []
+        for quant in quants:
+            if quantity > 0:
+                max_quantity_on_quant = quant.quantity - quant.reserved_quantity
+                if max_quantity_on_quant <= 0:
+                    continue
+            else:
+                max_quantity_on_quant = quant.reserved_quantity
+            max_quantity_on_quant = min(max_quantity_on_quant, quantity)
 
-        return res
+            quant.reserved_quantity += max_quantity_on_quant
+            reserved_quants.append((quant, max_quantity_on_quant))
 
-    # Misc tools
-    # ----------------------------------------------------------------------
-
-    def _get_top_level_packages(self, product_to_location):
-        """ This method searches for as much possible higher level packages that
-        can be moved as a single operation, given a list of quants to move and
-        their suggested destination, and returns the list of matching packages. """
-        top_lvl_packages = self.env['stock.quant.package']
-        for package in self.mapped('package_id'):
-            all_in = True
-            top_package = self.env['stock.quant.package']
-            while package:
-                if any(quant not in self for quant in package.get_content()):
-                    all_in = False
-                if all_in:
-                    destinations = set([product_to_location[product] for product in package.get_content().mapped('product_id')])
-                    if len(destinations) > 1:
-                        all_in = False
-                if all_in:
-                    top_package = package
-                    package = package.parent_id
-                else:
-                    package = False
-            top_lvl_packages |= top_package
-        return top_lvl_packages
+            quantity -= max_quantity_on_quant
+            available_quantity -= max_quantity_on_quant
 
-    @api.multi
-    def _get_latest_move(self):
-        latest_move = self.history_ids[0]
-        for move in self.history_ids:
-            if move.date > latest_move.date:
-                latest_move = move
-        return latest_move
+            if quantity == 0 or available_quantity == 0:
+                break
+        return reserved_quants
 
-    @api.multi
-    def _quant_split(self, qty):
-        self.ensure_one()
-        rounding = self.product_id.uom_id.rounding
-        if float_compare(abs(self.qty), abs(qty), precision_rounding=rounding) <= 0: # if quant <= qty in abs, take it entirely
-            return False
-        qty_round = float_round(qty, precision_rounding=rounding)
-        new_qty_round = float_round(self.qty - qty, precision_rounding=rounding)
-        # Fetch the history_ids manually as it will not do a join with the stock moves then (=> a lot faster)
-        self._cr.execute("""SELECT move_id FROM stock_quant_move_rel WHERE quant_id = %s""", (self.id,))
-        res = self._cr.fetchall()
-        new_quant = self.sudo().copy(default={'qty': new_qty_round, 'history_ids': [(4, x[0]) for x in res]})
-        self.sudo().write({'qty': qty_round})
-        return new_quant
+    @api.model
+    def _decrease_reserved_quantity(self, product_id, location_id, quantity, lot_id=None, package_id=None, owner_id=None, strict=True):
+        """ Decrease the reserved quantity, i.e. decrease `reserved_quantity`, for the set of
+        quants sharing the *exact same characteristics* if `strict` is set to True or sharing the
+        combination of `product_id, location_id` otherwise. Typically, this method is called during
+        a move line's validation or a move line's unlink and `strict` should be `True` in these
+        cases, because the characteristics are known.
+
+        :return: a list of tuples (quant, quantity_unreserved) showing on which quant the decrease
+            of reservation was done and how much the system was able to unreserve on it
+        """
+        return self._increase_reserved_quantity(product_id, location_id, -quantity, lot_id=lot_id, package_id=package_id, owner_id=owner_id, strict=strict)
 
 
 class QuantPackage(models.Model):
