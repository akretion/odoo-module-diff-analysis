PR: https://github.com/odoo/odoo/pull/60501

From: 4dbcefb5e5b1878e81fe9be9fe48a785f813334f
From: std-odoo
Date: 2022-02-22 12:53:00

Structural Changes: 2
Total Changes: 210

[IMP] utm: ensure the uniqueness of the names of the UTM models

Purpose
=======
Ensure that the names of the UTMs models (campaign, medium and source)
are unique.

If not, generate automatically an unique name.

The name field is no more translatable; it makes no sense to translate
a technical which will be added in the URL, and can even cause issues
(the UTM record is not recognized because of the translation).

For the campaign, we keep a "translatable" name which is called
"title".

For the UTM source, use a mixin to generate automatically the name of
the source based on the content (_rec_name) of the record. So we remove
the override of create / write / copy in the different models and
ensure consistency between those models.

Task-2245823

closes odoo/odoo#60501

Related: odoo/enterprise#21882
Related: odoo/upgrade#1863
Signed-off-by: Warnon Aur√©lien (awa) <awa@odoo.com>

================================= pseudo patch: =================================

--- a/addons/utm/models/utm_campaign.py
+++ b/addons/utm/models/utm_campaign.py
@@ -7,8 +7,11 @@ from odoo import fields, models, api, SUPERUSER_ID
 class UtmCampaign(models.Model):
     _name = 'utm.campaign'
     _description = 'UTM Campaign'
+    _rec_name = 'title'
 
-    name = fields.Char(string='Campaign Name', required=True, translate=True)
+    name = fields.Char(string='Campaign Identifier', required=True, compute='_compute_name',
+                       store=True, readonly=False, precompute=True, translate=False)
+    title = fields.Char(string='Campaign Name', required=True, translate=True)
 
     user_id = fields.Many2one(
         'res.users', string='Responsible',
@@ -24,6 +27,26 @@ class UtmCampaign(models.Model):
     is_auto_campaign = fields.Boolean(default=False, string="Automatically Generated Campaign", help="Allows us to filter relevant Campaigns")
     color = fields.Integer(string='Color Index')
 
+    _sql_constraints = [
+        ('unique_name', 'UNIQUE(name)', 'The name must be unique'),
+    ]
+
+    @api.depends('title')
+    def _compute_name(self):
+        new_names = self.env['utm.mixin']._get_unique_names(self._name, [c.title for c in self])
+        for campaign, new_name in zip(self, new_names):
+            campaign.name = new_name
+
+    @api.model_create_multi
+    def create(self, vals_list):
+        for vals in vals_list:
+            if not vals.get('title') and vals.get('name'):
+                vals['title'] = vals['name']
+        new_names = self.env['utm.mixin']._get_unique_names(self._name, [vals.get('name') for vals in vals_list])
+        for vals, new_name in zip(vals_list, new_names):
+            vals['name'] = new_name
+        return super().create(vals_list)
+
     @api.model
     def _group_expand_stage_ids(self, stages, domain, order):
         """Read group customization in order to display all the stages in the

--- a/addons/utm/models/utm_medium.py
+++ b/addons/utm/models/utm_medium.py
@@ -11,9 +11,20 @@ class UtmMedium(models.Model):
     _description = 'UTM Medium'
     _order = 'name'
 
-    name = fields.Char(string='Medium Name', required=True, translate=True)
+    name = fields.Char(string='Medium Name', required=True, translate=False)
     active = fields.Boolean(default=True)
 
+    _sql_constraints = [
+        ('unique_name', 'UNIQUE(name)', 'The name must be unique'),
+    ]
+
+    @api.model_create_multi
+    def create(self, vals_list):
+        new_names = self.env['utm.mixin']._get_unique_names(self._name, [vals.get('name') for vals in vals_list])
+        for vals, new_name in zip(vals_list, new_names):
+            vals['name'] = new_name
+        return super().create(vals_list)
+
     @api.ondelete(at_uninstall=False)
     def _unlink_except_utm_medium_email(self):
         utm_medium_email = self.env.ref('utm.utm_medium_email', raise_if_not_found=False)

--- a/addons/utm/models/utm_mixin.py
+++ b/addons/utm/models/utm_mixin.py
@@ -1,8 +1,12 @@
 # -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
+import re
+from collections import defaultdict
+
 from odoo import api, fields, models
 from odoo.http import request
+from odoo.osv import expression
 
 
 class UtmMixin(models.AbstractModel):
@@ -34,14 +38,8 @@ class UtmMixin(models.AbstractModel):
                     value = request.httprequest.cookies.get(cookie_name)
                 # if we receive a string for a many2one, we search/create the id
                 if field.type == 'many2one' and isinstance(value, str) and value:
-                    Model = self.env[field.comodel_name]
-                    records = Model.search([('name', '=', value)], limit=1)
-                    if not records:
-                        if 'is_auto_campaign' in records._fields:
-                            records = Model.create({'name': value, 'is_auto_campaign': True})
-                        else:
-                            records = Model.create({'name': value})
-                    value = records.id
+                    record = self._find_or_create_record(field.comodel_name, value)
+                    value = record.id
                 if value:
                     values[field_name] = value
         return values
@@ -59,3 +57,81 @@ class UtmMixin(models.AbstractModel):
             ('utm_source', 'source_id', 'odoo_utm_source'),
             ('utm_medium', 'medium_id', 'odoo_utm_medium'),
         ]
+
+    def _find_or_create_record(self, model_name, name):
+        """Based on the model name and on the name of the record, retrieve the corresponding record or create it."""
+        Model = self.env[model_name]
+
+        record = Model.search([('name', '=', name)], limit=1)
+
+        if not record:
+            # No record found, create a new one
+            record_values = {'name': name}
+            if 'is_auto_campaign' in record._fields:
+                record_values['is_auto_campaign'] = True
+            record = Model.create(record_values)
+
+        return record
+
+    @api.model
+    def _get_unique_names(self, model_name, names):
+        """Generate unique names for the given model.
+
+        Take a list of names and return for each names, the new names to set
+        in the same order (with a counter added if needed).
+
+        E.G.
+            The name "test" already exists in database
+            Input: ['test', 'test [3]', 'bob', 'test', 'test']
+            Output: ['test [2]', 'test [3]', 'bob', 'test [4]', 'test [5]']
+
+        :param model_name: name of the model for which we will generate unique names
+        :param names: list of names, we will ensure that each name will be unique
+        :return: a list of new values for each name, in the same order
+        """
+        def _split_name_and_count(name):
+            """
+            Return the name part and the counter based on the given name.
+
+            e.g.
+                "Medium" -> "Medium", 1
+                "Medium [1234]" -> "Medium", 1234
+            """
+            name = name or ''
+            name_counter_re = r'(.*)\s+\[([0-9]+)\]'
+            match = re.match(name_counter_re, name)
+            if match:
+                return match.group(1), int(match.group(2) or '1')
+            return name, 1
+
+        # Remove potential counter part in each names
+        names_without_counter = {_split_name_and_count(name)[0] for name in names}
+
+        # Retrieve existing similar names
+        seach_domain = expression.OR([[('name', 'ilike', name)] for name in names_without_counter])
+        existing_names = {vals['name'] for vals in self.env[model_name].search_read(seach_domain, ['name'])}
+
+        # Count for each names, based on the names list given in argument
+        # and the record names in database
+        count_per_names = defaultdict(lambda: 0)
+        count_per_names.update({
+            name: max((
+                _split_name_and_count(existing_name)[1] + 1
+                for existing_name in existing_names
+                if existing_name == name or existing_name.startswith(f'{name} [')
+            ), default=1)
+            for name in names_without_counter
+        })
+
+        result = []
+        for name in names:
+            if not name:
+                result.append(False)
+                continue
+
+            name_without_counter = _split_name_and_count(name)[0]
+            counter = count_per_names[name_without_counter]
+            result.append(f'{name_without_counter} [{counter}]' if counter > 1 else name)
+            count_per_names[name_without_counter] += 1
+
+        return result

--- a/addons/utm/models/utm_source.py
+++ b/addons/utm/models/utm_source.py
@@ -2,11 +2,85 @@
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
 
-from odoo import fields, models
+from odoo import _, api, fields, models, tools
 
 
 class UtmSource(models.Model):
     _name = 'utm.source'
     _description = 'UTM Source'
 
-    name = fields.Char(string='Source Name', required=True, translate=True)
+    name = fields.Char(string='Source Name', required=True)
+
+    _sql_constraints = [
+        ('unique_name', 'UNIQUE(name)', 'The name must be unique'),
+    ]
+
+    @api.model_create_multi
+    def create(self, vals_list):
+        new_names = self.env['utm.mixin']._get_unique_names(self._name, [vals.get('name') for vals in vals_list])
+        for vals, new_name in zip(vals_list, new_names):
+            vals['name'] = new_name
+        return super().create(vals_list)
+
+    def _generate_name(self, record, content):
+        """Generate the UTM source name based on the content of the source."""
+        if not content:
+            return False
+
+        content = content.replace('\n', ' ')
+        if len(content) >= 24:
+            content = f'{content[:20]}...'
+
+        create_date = record.create_date or fields.date.today()
+        create_date = fields.date.strftime(create_date, tools.DEFAULT_SERVER_DATE_FORMAT)
+        model_description = self.env['ir.model']._get(record._name).name
+        return _(
+            '%(content)s (%(model_description)s created on %(create_date)s)',
+            content=content, model_description=model_description, create_date=create_date,
+        )
+
+
+class UtmSourceMixin(models.AbstractModel):
+    """Mixin responsible of generating the name of the source based on the content
+    (field defined by _rec_name) of the record (mailing, social post,...).
+    """
+    _name = 'utm.source.mixin'
+    _description = 'UTM Source Mixin'
+
+    name = fields.Char('Name', related='source_id.name', readonly=False)
+    source_id = fields.Many2one('utm.source', string='Source', required=True, ondelete='restrict', copy=False)
+
+    @api.model_create_multi
+    def create(self, vals_list):
+        """Create the UTM sources if necessary, generate the name based on the content in batch."""
+        # Create all required <utm.source>
+        utm_sources = self.env['utm.source'].create([
+            {'name': values.get('name') or self.env['utm.source']._generate_name(self, values.get(self._rec_name))}
+            for values in vals_list
+            if not values.get('source_id')
+        ])
+
+        # Update "vals_list" to add the ID of the newly created source
+        vals_list_missing_source = [values for values in vals_list if not values.get('source_id')]
+        for values, source in zip(vals_list_missing_source, utm_sources):
+            values['source_id'] = source.id
+
+        for values in vals_list:
+            if 'name' in values:
+                del values['name']
+
+        return super().create(vals_list)
+
+    def write(self, values):
+        if values.get(self._rec_name) and not values.get('name'):
+            values['name'] = self.env['utm.source']._generate_name(self, values[self._rec_name])
+        if values.get('name'):
+            values['name'] = self.env['utm.mixin']._get_unique_names(self._name, [values['name']])[0]
+
+        super().write(values)
+
+    def copy(self, default=None):
+        """Increment the counter when duplicating the source."""
+        default = default or {}
+        default['name'] = self.env['utm.mixin']._get_unique_names(self._name, [self.name])[0]
+        return super().copy(default)

--- a/addons/utm/models/utm_stage.py
+++ b/addons/utm/models/utm_stage.py
@@ -13,4 +13,4 @@ class UtmStage(models.Model):
     _order = 'sequence'
 
     name = fields.Char(required=True, translate=True)
-    sequence = fields.Integer()
+    sequence = fields.Integer(default=1)
