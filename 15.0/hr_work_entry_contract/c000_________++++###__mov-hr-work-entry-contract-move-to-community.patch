PR: https://github.com/odoo/odoo/pull/

From: c6998b3b145355ce711db7477f77b408d3734310
From: Arnaud Joset
Date: 2021-02-26 07:39:43

Structural Changes: 17
Total Changes: 537

[MOV] hr_work_entry_contract: move to community.

Before this commit, the module dependencies: hr_contract and hr_work_entry were defined in community.
As they could be integrated with some community applications, like hr_attendance or hr_holidays, it is more coherent to move them to community.

Taskid: 2222790

================================= pseudo patch: =================================

--- a/None
+++ b/addons/hr_work_entry_contract/models/__init__.py
@@ -0,0 +1,7 @@
+# -*- coding:utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from . import hr_contract
+from . import hr_employee
+from . import hr_work_entry
+from . import hr_work_intervals

--- a/None
+++ b/addons/hr_work_entry_contract/models/hr_contract.py
@@ -0,0 +1,255 @@
+# -*- coding:utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from collections import defaultdict
+from datetime import date, datetime
+from odoo import api, fields, models
+from odoo.addons.resource.models.resource_mixin import timezone_datetime
+from odoo.addons.resource.models.resource import datetime_to_string, string_to_datetime, Intervals
+from odoo.osv import expression
+
+import pytz
+
+class HrContract(models.Model):
+    _inherit = 'hr.contract'
+    _description = 'Employee Contract'
+
+    date_generated_from = fields.Datetime(string='Generated From', readonly=True, required=True,
+        default=lambda self: datetime.now().replace(hour=0, minute=0, second=0), copy=False)
+    date_generated_to = fields.Datetime(string='Generated To', readonly=True, required=True,
+        default=lambda self: datetime.now().replace(hour=0, minute=0, second=0), copy=False)
+
+    def _get_default_work_entry_type(self):
+        return self.env.ref('hr_work_entry.work_entry_type_attendance', raise_if_not_found=False)
+
+    def _get_leave_work_entry_type_dates(self, leave, date_from, date_to):
+        return self._get_leave_work_entry_type(leave)
+
+    def _get_leave_work_entry_type(self, leave):
+        return leave.work_entry_type_id
+
+    # Is used to add more values, for example leave_id (in hr_work_entry_holidays)
+    def _get_more_vals_leave_interval(self, interval, leaves):
+        return []
+
+    def _get_interval_leave_work_entry_type(self, interval, leaves):
+        # returns the work entry time related to the leave that
+        # includes the whole interval.
+        # Overriden in hr_work_entry_contract_holiday to select the
+        # global time off first (eg: Public Holiday > Home Working)
+        for leave in leaves:
+            if interval[0] >= leave[0] and interval[1] <= leave[1] and leave[2]:
+                interval_start = interval[0].astimezone(pytz.utc).replace(tzinfo=None)
+                interval_stop = interval[1].astimezone(pytz.utc).replace(tzinfo=None)
+                return self._get_leave_work_entry_type_dates(leave[2], interval_start, interval_stop)
+        return self.env.ref('hr_work_entry_contract.work_entry_type_leave')
+
+    def _get_contract_work_entries_values(self, date_start, date_stop):
+        self.ensure_one()
+        contract_vals = []
+        employee = self.employee_id
+        calendar = self.resource_calendar_id
+        resource = employee.resource_id
+        tz = pytz.timezone(calendar.tz)
+        start_dt = pytz.utc.localize(date_start) if not date_start.tzinfo else date_start
+        end_dt = pytz.utc.localize(date_stop) if not date_stop.tzinfo else date_stop
+
+        attendances = calendar._attendance_intervals_batch(
+            start_dt, end_dt, resources=resource, tz=tz
+        )[resource.id]
+
+        # Other calendars: In case the employee has declared time off in another calendar
+        # Example: Take a time off, then a credit time.
+        # YTI TODO: This mimics the behavior of _leave_intervals_batch, while waiting to be cleaned
+        # in master.
+        resources_list = [self.env['resource.resource'], resource]
+        resource_ids = [False, resource.id]
+        leave_domain = [
+            ('time_type', '=', 'leave'),
+            # ('calendar_id', '=', self.id), --> Get all the time offs
+            ('resource_id', 'in', resource_ids),
+            ('date_from', '<=', datetime_to_string(end_dt)),
+            ('date_to', '>=', datetime_to_string(start_dt)),
+            ('company_id', '=', self.env.company.id),
+        ]
+        result = defaultdict(lambda: [])
+        tz_dates = {}
+        for leave in self.env['resource.calendar.leaves'].search(leave_domain):
+            for resource in resources_list:
+                if leave.resource_id.id not in [False, resource.id]:
+                    continue
+                tz = tz if tz else pytz.timezone((resource or self).tz)
+                if (tz, start_dt) in tz_dates:
+                    start = tz_dates[(tz, start_dt)]
+                else:
+                    start = start_dt.astimezone(tz)
+                    tz_dates[(tz, start_dt)] = start
+                if (tz, end_dt) in tz_dates:
+                    end = tz_dates[(tz, end_dt)]
+                else:
+                    end = end_dt.astimezone(tz)
+                    tz_dates[(tz, end_dt)] = end
+                dt0 = string_to_datetime(leave.date_from).astimezone(tz)
+                dt1 = string_to_datetime(leave.date_to).astimezone(tz)
+                result[resource.id].append((max(start, dt0), min(end, dt1), leave))
+        mapped_leaves = {r.id: Intervals(result[r.id]) for r in resources_list}
+        leaves = mapped_leaves[resource.id]
+
+        real_attendances = attendances - leaves
+        real_leaves = attendances - real_attendances
+
+        # A leave period can be linked to several resource.calendar.leave
+        split_leaves = []
+        for leave_interval in leaves:
+            if leave_interval[2] and len(leave_interval[2]) > 1:
+                split_leaves += [(leave_interval[0], leave_interval[1], l) for l in leave_interval[2]]
+            else:
+                split_leaves += [(leave_interval[0], leave_interval[1], leave_interval[2])]
+        leaves = split_leaves
+
+        # Attendances
+        default_work_entry_type = self._get_default_work_entry_type()
+        for interval in real_attendances:
+            work_entry_type_id = interval[2].mapped('work_entry_type_id')[:1] or default_work_entry_type
+            # All benefits generated here are using datetimes converted from the employee's timezone
+            contract_vals += [{
+                'name': "%s: %s" % (work_entry_type_id.name, employee.name),
+                'date_start': interval[0].astimezone(pytz.utc).replace(tzinfo=None),
+                'date_stop': interval[1].astimezone(pytz.utc).replace(tzinfo=None),
+                'work_entry_type_id': work_entry_type_id.id,
+                'employee_id': employee.id,
+                'contract_id': self.id,
+                'company_id': self.company_id.id,
+                'state': 'draft',
+            }]
+
+        for interval in real_leaves:
+            # Could happen when a leave is configured on the interface on a day for which the
+            # employee is not supposed to work, i.e. no attendance_ids on the calendar.
+            # In that case, do try to generate an empty work entry, as this would raise a
+            # sql constraint error
+            if interval[0] == interval[1]:  # if start == stop
+                continue
+            leave_entry_type = self._get_interval_leave_work_entry_type(interval, leaves)
+            interval_start = interval[0].astimezone(pytz.utc).replace(tzinfo=None)
+            interval_stop = interval[1].astimezone(pytz.utc).replace(tzinfo=None)
+            contract_vals += [dict([
+                ('name', "%s%s" % (leave_entry_type.name + ": " if leave_entry_type else "", employee.name)),
+                ('date_start', interval_start),
+                ('date_stop', interval_stop),
+                ('work_entry_type_id', leave_entry_type.id),
+                ('employee_id', employee.id),
+                ('company_id', self.company_id.id),
+                ('state', 'draft'),
+                ('contract_id', self.id),
+            ] + self._get_more_vals_leave_interval(interval, leaves))]
+        return contract_vals
+
+    def _get_work_entries_values(self, date_start, date_stop):
+        """
+        Generate a work_entries list between date_start and date_stop for one contract.
+        :return: list of dictionnary.
+        """
+        vals_list = []
+        for contract in self:
+            contract_vals = contract._get_contract_work_entries_values(date_start, date_stop)
+
+            # If we generate work_entries which exceeds date_start or date_stop, we change boundaries on contract
+            if contract_vals:
+                date_stop_max = max([x['date_stop'] for x in contract_vals])
+                if date_stop_max > contract.date_generated_to:
+                    contract.date_generated_to = date_stop_max
+
+                date_start_min = min([x['date_start'] for x in contract_vals])
+                if date_start_min < contract.date_generated_from:
+                    contract.date_generated_from = date_start_min
+
+            vals_list += contract_vals
+
+        return vals_list
+
+    def _generate_work_entries(self, date_start, date_stop, force=False):
+        vals_list = []
+
+        date_start = fields.Datetime.to_datetime(date_start)
+        date_stop = datetime.combine(fields.Datetime.to_datetime(date_stop), datetime.max.time())
+
+        for contract in self:
+            contract_start = fields.Datetime.to_datetime(contract.date_start)
+            contract_stop = datetime.combine(fields.Datetime.to_datetime(contract.date_end or datetime.max.date()),
+                                             datetime.max.time())
+            date_start_work_entries = max(date_start, contract_start)
+            date_stop_work_entries = min(date_stop, contract_stop)
+            if force:
+                vals_list.extend(contract._get_work_entries_values(date_start_work_entries, date_stop_work_entries))
+                continue
+
+            # In case the date_generated_from == date_generated_to, move it to the date_start to
+            # avoid trying to generate several months/years of history for old contracts for which
+            # we've never generated the work entries.
+            if contract.date_generated_from == contract.date_generated_to:
+                contract.write({
+                    'date_generated_from': date_start,
+                    'date_generated_to': date_start,
+                })
+            # For each contract, we found each interval we must generate
+            last_generated_from = min(contract.date_generated_from, contract_stop)
+            if last_generated_from > date_start_work_entries:
+                contract.date_generated_from = date_start_work_entries
+                vals_list.extend(contract._get_work_entries_values(date_start_work_entries, last_generated_from))
+
+            last_generated_to = max(contract.date_generated_to, contract_start)
+            if last_generated_to < date_stop_work_entries:
+                contract.date_generated_to = date_stop_work_entries
+                vals_list.extend(contract._get_work_entries_values(last_generated_to, date_stop_work_entries))
+
+        if not vals_list:
+            return self.env['hr.work.entry']
+
+        return self.env['hr.work.entry'].create(vals_list)
+
+    def _remove_work_entries(self):
+        ''' Remove all work_entries that are outside contract period (function used after writing new start or/and end date) '''
+        all_we_to_unlink = self.env['hr.work.entry']
+        for contract in self:
+            date_start = fields.Datetime.to_datetime(contract.date_start)
+            if contract.date_generated_from < date_start:
+                we_to_remove = self.env['hr.work.entry'].search([('date_stop', '<=', date_start), ('contract_id', '=', contract.id)])
+                if we_to_remove:
+                    contract.date_generated_from = date_start
+                    all_we_to_unlink |= we_to_remove
+            if not contract.date_end:
+                continue
+            date_end = datetime.combine(contract.date_end, datetime.max.time())
+            if contract.date_generated_to > date_end:
+                we_to_remove = self.env['hr.work.entry'].search([('date_start', '>=', date_end), ('contract_id', '=', contract.id)])
+                if we_to_remove:
+                    contract.date_generated_to = date_end
+                    all_we_to_unlink |= we_to_remove
+        all_we_to_unlink.unlink()
+
+    def _cancel_work_entries(self):
+        if not self:
+            return
+        domain = [('state', '!=', 'validated')]
+        for contract in self:
+            date_start = fields.Datetime.to_datetime(contract.date_start)
+            contract_domain = [
+                ('contract_id', '=', contract.id),
+                ('date_start', '>=', date_start),
+            ]
+            if contract.date_end:
+                date_end = datetime.combine(contract.date_end, datetime.max.time())
+                contract_domain += [('date_stop', '<=', date_end)]
+            domain = expression.AND([domain, contract_domain])
+        work_entries = self.env['hr.work.entry'].search(domain)
+        if work_entries:
+            work_entries.unlink()
+
+    def write(self, vals):
+        result = super(HrContract, self).write(vals)
+        if vals.get('date_end') or vals.get('date_start'):
+            self.sudo()._remove_work_entries()
+        if vals.get('state') in ['draft', 'cancel']:
+            self._cancel_work_entries()
+        return result

--- a/None
+++ b/addons/hr_work_entry_contract/models/hr_employee.py
@@ -0,0 +1,20 @@
+# -*- coding:utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from odoo import api, fields, models
+
+
+class HrEmployee(models.Model):
+    _inherit = 'hr.employee'
+    _description = 'Employee'
+
+    def generate_work_entries(self, date_start, date_stop, force=False):
+        date_start = fields.Date.to_date(date_start)
+        date_stop = fields.Date.to_date(date_stop)
+
+        if self:
+            current_contracts = self._get_contracts(date_start, date_stop, states=['open', 'close'])
+        else:
+            current_contracts = self._get_all_contracts(date_start, date_stop, states=['open', 'close'])
+
+        return bool(current_contracts._generate_work_entries(date_start, date_stop, force))

--- a/None
+++ b/addons/hr_work_entry_contract/models/hr_work_entry.py
@@ -0,0 +1,157 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+import pytz
+
+from collections import defaultdict
+from contextlib import contextmanager
+from itertools import chain
+from dateutil.relativedelta import relativedelta
+
+from odoo import api, fields, models, _
+from odoo.exceptions import ValidationError
+from odoo.addons.hr_work_entry_contract.models.hr_work_intervals import WorkIntervals
+
+
+class HrWorkEntry(models.Model):
+    _inherit = 'hr.work.entry'
+
+    contract_id = fields.Many2one('hr.contract', string="Contract", required=True)
+    employee_id = fields.Many2one(domain=[('contract_ids.state', 'in', ('open', 'pending'))])
+
+    def _init_column(self, column_name):
+        if column_name != 'contract_id':
+            super()._init_column(column_name)
+        else:
+            self.env.cr.execute("""
+                UPDATE hr_work_entry AS _hwe
+                SET contract_id = result.contract_id
+                FROM (
+                    SELECT
+                        hc.id AS contract_id,
+                        array_agg(hwe.id) AS entry_ids
+                    FROM
+                        hr_work_entry AS hwe
+                    LEFT JOIN
+                        hr_contract AS hc
+                    ON
+                        hwe.employee_id=hc.employee_id AND
+                        hc.state in ('open', 'close') AND
+                        hwe.date_start >= hc.date_start AND
+                        hwe.date_stop < COALESCE(hc.date_end + integer '1', '9999-12-31 23:59:59')
+                    WHERE
+                        hwe.contract_id IS NULL
+                    GROUP BY
+                        hwe.employee_id, hc.id
+                ) AS result
+                WHERE _hwe.id = ANY(result.entry_ids)
+            """)
+
+    def _get_duration_is_valid(self):
+        return self.work_entry_type_id and self.work_entry_type_id.is_leave
+
+    @api.onchange('employee_id', 'date_start', 'date_stop')
+    def _onchange_contract_id(self):
+        vals = {
+            'employee_id': self.employee_id.id,
+            'date_start': self.date_start,
+            'date_stop': self.date_stop,
+        }
+        try:
+            res = self._set_current_contract(vals)
+        except ValidationError:
+            return
+        if res.get('contract_id'):
+            self.contract_id = res.get('contract_id')
+
+    @api.depends('date_start', 'duration')
+    def _compute_date_stop(self):
+        for work_entry in self:
+            if work_entry._get_duration_is_valid():
+                calendar = work_entry.contract_id.resource_calendar_id
+                if not calendar:
+                    continue
+                work_entry.date_stop = calendar.plan_hours(work_entry.duration, work_entry.date_start, compute_leaves=True)
+                continue
+            super(HrWorkEntry, work_entry)._compute_date_stop()
+
+    def _get_duration(self, date_start, date_stop):
+        if not date_start or not date_stop:
+            return 0
+        if self._get_duration_is_valid():
+            calendar = self.contract_id.resource_calendar_id
+            if not calendar:
+                return 0
+            employee = self.contract_id.employee_id
+            contract_data = employee._get_work_days_data_batch(
+                date_start, date_stop, compute_leaves=False, calendar=calendar
+            )[employee.id]
+            return contract_data.get('hours', 0)
+        return super()._get_duration(date_start, date_stop)
+
+    @api.model
+    def _set_current_contract(self, vals):
+        if not vals.get('contract_id') and vals.get('date_start') and vals.get('date_stop') and vals.get('employee_id'):
+            contract_start = fields.Datetime.to_datetime(vals.get('date_start')).date()
+            contract_end = fields.Datetime.to_datetime(vals.get('date_stop')).date()
+            employee = self.env['hr.employee'].browse(vals.get('employee_id'))
+            contracts = employee._get_contracts(contract_start, contract_end, states=['open', 'pending', 'close'])
+            if not contracts:
+                raise ValidationError(_("%s does not have a contract from %s to %s.") % (employee.name, contract_start, contract_end))
+            elif len(contracts) > 1:
+                raise ValidationError(_("%s has multiple contracts from %s to %s. A work entry cannot overlap multiple contracts.")
+                                      % (employee.name, contract_start, contract_end))
+            return dict(vals, contract_id=contracts[0].id)
+        return vals
+
+    @api.model_create_multi
+    def create(self, vals_list):
+        vals_list = [self._set_current_contract(vals) for vals in vals_list]
+        work_entries = super().create(vals_list)
+        return work_entries
+
+    def _check_if_error(self):
+        res = super()._check_if_error()
+        outside_calendar = self._mark_leaves_outside_schedule()
+        return res or outside_calendar
+
+    def _get_leaves_entries_outside_schedule(self):
+        return self.filtered(lambda w: w.work_entry_type_id.is_leave and w.state not in ('validated', 'cancelled'))
+
+    def _mark_leaves_outside_schedule(self):
+        """
+        Check leave work entries in `self` which are completely outside
+        the contract's theoretical calendar schedule. Mark them as conflicting.
+        :return: leave work entries completely outside the contract's calendar
+        """
+        work_entries = self._get_leaves_entries_outside_schedule()
+        entries_by_calendar = defaultdict(lambda: self.env['hr.work.entry'])
+        for work_entry in work_entries:
+            calendar = work_entry.contract_id.resource_calendar_id
+            entries_by_calendar[calendar] |= work_entry
+
+        outside_entries = self.env['hr.work.entry']
+        for calendar, entries in entries_by_calendar.items():
+            datetime_start = min(entries.mapped('date_start'))
+            datetime_stop = max(entries.mapped('date_stop'))
+
+            calendar_intervals = calendar._attendance_intervals_batch(pytz.utc.localize(datetime_start), pytz.utc.localize(datetime_stop))[False]
+            entries_intervals = entries._to_intervals()
+            overlapping_entries = self._from_intervals(entries_intervals & calendar_intervals)
+            outside_entries |= entries - overlapping_entries
+        outside_entries.write({'state': 'conflict'})
+        return bool(outside_entries)
+
+    def _to_intervals(self):
+        return WorkIntervals((w.date_start.replace(tzinfo=pytz.utc), w.date_stop.replace(tzinfo=pytz.utc), w) for w in self)
+
+    @api.model
+    def _from_intervals(self, intervals):
+        return self.browse(chain.from_iterable(recs.ids for start, end, recs in intervals))
+
+
+class HrWorkEntryType(models.Model):
+    _inherit = 'hr.work.entry.type'
+    _description = 'HR Work Entry Type'
+
+    is_leave = fields.Boolean(default=False, string="Time Off")

--- a/None
+++ b/addons/hr_work_entry_contract/models/hr_work_intervals.py
@@ -0,0 +1,98 @@
+# -*- coding:utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from itertools import chain
+
+
+def _boundaries(intervals, opening, closing):
+    """ Iterate on the boundaries of intervals. """
+    for start, stop, recs in intervals:
+        if start < stop:
+            yield (start, opening, recs)
+            yield (stop, closing, recs)
+
+
+class WorkIntervals(object):
+    """
+        This class is a modified copy of the ``Intervals`` class in the resource module.
+        A generic solution to handle intervals should probably be developped the day a similar
+        class is needed elsewhere.
+
+        This implementation differs from the resource implementation in its management
+        of two continuous intervals. Here, continuous intervals are not merged together
+        while they are merged in resource.
+        e.g.:
+        In resource: (1, 4, rec1) and (4, 10, rec2) are merged into (1, 10, rec1 | rec2)
+        Here: they remain two different intervals.
+        To implement this behaviour, the main implementation change is the way boundaries are sorted.
+    """
+    def __init__(self, intervals=()):
+        self._items = []
+        if intervals:
+            # normalize the representation of intervals
+            append = self._items.append
+            starts = []
+            recses = []
+            for value, flag, recs in sorted(_boundaries(sorted(intervals), 'start', 'stop'), key=lambda i: i[0]):
+                if flag == 'start':
+                    starts.append(value)
+                    recses.append(recs)
+                else:
+                    start = starts.pop()
+                    if not starts:
+                        append((start, value, recses[0].union(*recses)))
+                        recses.clear()
+
+    def __bool__(self):
+        return bool(self._items)
+
+    def __len__(self):
+        return len(self._items)
+
+    def __iter__(self):
+        return iter(self._items)
+
+    def __reversed__(self):
+        return reversed(self._items)
+
+    def __or__(self, other):
+        """ Return the union of two sets of intervals. """
+        return WorkIntervals(chain(self._items, other._items))
+
+    def __and__(self, other):
+        """ Return the intersection of two sets of intervals. """
+        return self._merge(other, False)
+
+    def __sub__(self, other):
+        """ Return the difference of two sets of intervals. """
+        return self._merge(other, True)
+
+    def _merge(self, other, difference):
+        """ Return the difference or intersection of two sets of intervals. """
+        result = WorkIntervals()
+        append = result._items.append
+
+        # using 'self' and 'other' below forces normalization
+        bounds1 = _boundaries(sorted(self), 'start', 'stop')
+        bounds2 = _boundaries(sorted(other), 'switch', 'switch')
+
+        start = None                    # set by start/stop
+        recs1 = None                    # set by start
+        enabled = difference            # changed by switch
+        for value, flag, recs in sorted(chain(bounds1, bounds2), key=lambda i: i[0]):
+            if flag == 'start':
+                start = value
+                recs1 = recs
+            elif flag == 'stop':
+                if enabled and start < value:
+                    append((start, value, recs1))
+                start = None
+            else:
+                if not enabled and start is not None:
+                    start = value
+                if enabled and start is not None and start < value:
+                    append((start, value, recs1))
+                enabled = not enabled
+
+        return result
+
