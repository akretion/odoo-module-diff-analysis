PR: https://github.com/odoo/odoo/pull/75906

From: b3fc41cc44b251be37b6aaf2931179afeb126d69
From: Thibault Delavall√©e
Date: 2022-08-12 21:37:03

Structural Changes: 4
Total Changes: 85

[IMP] mail: add a post server action

Currently only an email action based on template exists in server actions when
having mail app installed. It basically sends an email based on a mail template.

However being able to post a message on record is also useful. Instead of
sending emails it post on a document as a comment or as a note, like what
users can do using the chatter. Notification flow for those cases is the
classic from post: followers, specified partners, Inbox/Email, ...

Task-2613245 (Server actions mail update / cleaning)
Closes #45640

Part-of: odoo/odoo#75906

================================= pseudo patch: =================================

--- a/addons/mail/models/ir_actions_server.py
+++ b/addons/mail/models/ir_actions_server.py
@@ -8,27 +8,42 @@ from odoo.exceptions import ValidationError
 
 
 class ServerActions(models.Model):
-    """ Add email option in server actions. """
+    """ Add mail.thread related options in server actions. """
     _name = 'ir.actions.server'
     _description = 'Server Action'
     _inherit = ['ir.actions.server']
 
-    state = fields.Selection(selection_add=[
-        ('email', 'Send Email'),
-        ('followers', 'Add Followers'),
-        ('next_activity', 'Create Next Activity'),
-        ], ondelete={'email': 'cascade', 'followers': 'cascade', 'next_activity': 'cascade'})
+    state = fields.Selection(
+        selection_add=[('mail_post', 'Send Email'),
+                       ('followers', 'Add Followers'),
+                       ('next_activity', 'Create Next Activity'),
+        ],
+        ondelete={'mail_post': 'cascade',
+                  'followers': 'cascade',
+                  'next_activity': 'cascade',
+        }
+    )
     # Followers
     partner_ids = fields.Many2many(
         'res.partner', string='Add Followers',
         compute='_compute_partner_ids', readonly=False, store=True)
-    # Template
+    # Message Post / Email
     template_id = fields.Many2one(
         'mail.template', 'Email Template',
         domain="[('model_id', '=', model_id)]",
         compute='_compute_template_id',
         ondelete='set null', readonly=False, store=True,
     )
+    # Message post
+    mail_post_autofollow = fields.Boolean(
+        'Subscribe Recipients', compute='_compute_mail_post_autofollow',
+        readonly=False, store=True)
+    mail_post_method = fields.Selection(
+        selection=[('email', 'Email'), ('comment', 'Post as Message'), ('note', 'Post as Note')],
+        string='Send as',
+        compute='_compute_mail_post_method',
+        readonly=False, store=True,
+        help='Choose method for email sending:\nEMail: send directly emails\nPost as Message: post on document and notify followers\nPost as Note: log a note on document')
     # Next Activity
     activity_type_id = fields.Many2one(
         'mail.activity.type', string='Activity',
@@ -65,19 +80,37 @@ class ServerActions(models.Model):
     @api.depends('model_id', 'state')
     def _compute_template_id(self):
         to_reset = self.filtered(
-            lambda act: act.state != 'email' or \
+            lambda act: act.state != 'mail_post' or \
                         (act.model_id != act.template_id.model_id)
         )
         if to_reset:
             to_reset.template_id = False
 
+    @api.depends('state', 'mail_post_method')
+    def _compute_mail_post_autofollow(self):
+        to_reset = self.filtered(lambda act: act.state != 'mail_post' or act.mail_post_method == 'email')
+        if to_reset:
+            to_reset.mail_post_autofollow = False
+        other = self - to_reset
+        if other:
+            other.mail_post_autofollow = True
+
+    @api.depends('state')
+    def _compute_mail_post_method(self):
+        to_reset = self.filtered(lambda act: act.state != 'mail_post')
+        if to_reset:
+            to_reset.mail_post_method = False
+        other = self - to_reset
+        if other:
+            other.mail_post_method = 'email'
+
     @api.depends('state')
     def _compute_partner_ids(self):
         to_reset = self.filtered(lambda act: act.state != 'followers')
         if to_reset:
             to_reset.partner_ids = False
 
-    @api.depends('model_id')
+    @api.depends('model_id', 'state')
     def _compute_activity_type_id(self):
         to_reset = self.filtered(
             lambda act: act.state != 'next_activity' or \
@@ -106,7 +139,6 @@ class ServerActions(models.Model):
             if not activity.activity_user_field_name:
                 activity.activity_user_field_name = 'user_id'
 
-
     @api.constrains('activity_date_deadline_range')
     def _check_activity_date_deadline_range(self):
         if any(action.activity_date_deadline_range < 0 for action in self):
@@ -155,17 +187,40 @@ class ServerActions(models.Model):
                     return True
         return False
 
-    def _run_action_email(self, eval_context=None):
+    def _run_action_mail_post_multi(self, eval_context=None):
         # TDE CLEANME: when going to new api with server action, remove action
-        if not self.template_id or not self._context.get('active_id') or self._is_recompute():
+        if not self.template_id or (not self._context.get('active_ids') and not self._context.get('active_id')) or self._is_recompute():
             return False
+        res_ids = self._context.get('active_ids', [self._context.get('active_id')])
+
         # Clean context from default_type to avoid making attachment
         # with wrong values in subsequent operations
         cleaned_ctx = dict(self.env.context)
         cleaned_ctx.pop('default_type', None)
         cleaned_ctx.pop('default_parent_id', None)
-        self.template_id.with_context(cleaned_ctx).send_mail(self._context.get('active_id'), force_send=False,
-                                                             raise_exception=False)
+        cleaned_ctx['mail_create_nosubscribe'] = True  # do not subscribe random people to records
+        cleaned_ctx['mail_post_autofollow'] = self.mail_post_autofollow
+
+        if self.mail_post_method in ('comment', 'note'):
+            records = self.env[self.model_name].with_context(cleaned_ctx).browse(res_ids)
+            if self.mail_post_method == 'comment':
+                subtype_id = self.env['ir.model.data']._xmlid_to_res_id('mail.mt_comment')
+            else:
+                subtype_id = self.env['ir.model.data']._xmlid_to_res_id('mail.mt_note')
+            for record in records:
+                record.message_post_with_template(
+                    self.template_id.id,
+                    composition_mode='comment',
+                    subtype_id=subtype_id,
+                )
+        else:
+            template = self.template_id.with_context(cleaned_ctx)
+            for res_id in res_ids:
+                template.send_mail(
+                    res_id,
+                    force_send=False,
+                    raise_exception=False
+                )
         return False
 
     def _run_action_next_activity(self, eval_context=None):

--- a/addons/mail/models/mail_template.py
+++ b/addons/mail/models/mail_template.py
@@ -272,7 +272,7 @@ class MailTemplate(models.Model):
         Attachment = self.env['ir.attachment']  # TDE FIXME: should remove default_type from context
 
         # create a mail_mail based on values, without attachments
-        values = self.generate_email(res_id, ['subject', 'body_html', 'email_from', 'email_to', 'partner_to', 'email_cc', 'reply_to', 'scheduled_date'])
+        values = self.generate_email(res_id, ['auto_delete', 'subject', 'body_html', 'email_from', 'email_to', 'partner_to', 'email_cc', 'reply_to', 'scheduled_date'])
         values['recipient_ids'] = [Command.link(pid) for pid in values.get('partner_ids', list())]
         values['attachment_ids'] = [Command.link(aid) for aid in values.get('attachment_ids', list())]
         values.update(email_values or {})
