PR: https://github.com/odoo/odoo/pull/

From: 2d359b909bc27fd41125c9e44d9376b5a910f6d5
From: std-odoo
Date: 2021-07-09 12:32:28

Breaking data model changes score: 7, change matches:
+    mail_group_message_ids = fields.One2many('mail.group.message', 'mail_group_id', string='Pending Messages')
+    member_ids = fields.One2many('mail.group.member', 'mail_group_id', string='Members')
+    member_partner_ids = fields.Many2many('res.partner', string='Partners Member', compute='_compute_member_partner_ids', search='_search_member_partner_ids')
+    moderation_rule_ids = fields.One2many('mail.group.moderation', 'mail_group_id', string='Moderated Emails')
+    moderator_ids = fields.Many2many('res.users', 'mail_group_moderator_rel', string='Moderators',
+    attachment_ids = fields.Many2many(related='mail_message_id.attachment_ids', readonly=False)
+    group_message_child_ids = fields.One2many('mail.group.message', 'group_message_parent_id', string='Childs')

Total Changes: 888

[ADD] mail_group: add a new module to manage the mailing lists

Purpose
=======

The purpose of this new module is to manage the mailing lists. Now they
are no more <mail.channel> (will email_send set to True) but they have
their own model.

Specifications
==============

The mailing list are basically a public discussion that users can have
by email. They can respond to email, send new messages, etc... All the
members of the mailing list will receive the message by email.

Users can moderate the emails of the mailing list in the same way as
they did with the "email" mail channel.
* *accept*, will accept the emails and send it to the members of the
  mailing list
* *discard*, will drop the email without warning the author
* *reject*, will drop the email and send a notification email to the
  author
* *allow*, will accept the email and all other pending emails of the
  same author and create a whitelist for him
* *ban* will drop the email and all other pending emails of the same
  author and create a blacklist for him

Now a portal view is available (in /groups) and replace the old module
"Website Mail Channel" that was removed in the previous commit. In this
view, users can subscribe / unsubscribe to the mailing lists and some
links to this portal view are added in the footer of the emails of the
mailing list.

As before with mail channels, you can send guidelines to the members,
notify the moderators whose an action is required (in a CRON), send back
an email to the author of an email to say "Your message is waiting
moderation"...

Links
=====

Task-2510267
See odoo/odoo/pull/71599
See odoo/enterprise/pull/19296
See odoo/upgrade/pull/2600

================================= pseudo patch: =================================

--- a/None
+++ b/addons/mail_group/models/__init__.py
@@ -0,0 +1,7 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from . import mail_group
+from . import mail_group_member
+from . import mail_group_message
+from . import mail_group_moderation

--- a/None
+++ b/addons/mail_group/models/mail_group.py
@@ -0,0 +1,571 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+import base64
+import json
+import logging
+
+from ast import literal_eval
+from datetime import datetime
+from dateutil import relativedelta
+from werkzeug import urls
+from odoo.addons.http_routing.models.ir_http import slug
+
+from odoo import _, api, fields, models, modules, tools
+from odoo.exceptions import ValidationError, UserError
+from odoo.osv import expression
+from odoo.tools import email_normalize, hmac, generate_tracking_message_id
+
+_logger = logging.getLogger(__name__)
+
+GROUP_SEND_BATCH_SIZE = 500
+
+
+class MailGroup(models.Model):
+    """This model represents a mailing list.
+
+    Users send emails to an alias to create new group messages or reply to existing
+    group messages. Moderation can be activated on groups. In that case email have to
+    be validated or rejected.
+    """
+    _name = 'mail.group'
+    _description = 'Mailing List'
+    # TDE CHECK: use blaclist mixin
+    _inherit = ['mail.alias.mixin']
+
+    @api.model
+    def default_get(self, fields):
+        res = super(MailGroup, self).default_get(fields)
+        if not res.get('alias_contact') and (not fields or 'alias_contact' in fields):
+            res['alias_contact'] = 'everyone' if res.get('access_mode') == 'public' else 'followers'
+        return res
+
+    def _get_default_image(self):
+        image_path = modules.get_resource_path('mail', 'static/src/img', 'groupdefault.png')
+        with tools.file_open(image_path, 'rb') as fd:
+            return base64.b64encode(fd.read())
+
+    name = fields.Char('Name', required=True)
+    alias_name = fields.Char('Alias Name', copy=False, related='alias_id.alias_name', readonly=False)
+    description = fields.Text('Description')
+    image_128 = fields.Image('Image', max_width=128, max_height=128, default=_get_default_image)
+    # Messages
+    mail_group_message_ids = fields.One2many('mail.group.message', 'mail_group_id', string='Pending Messages')
+    mail_group_message_last_month_count = fields.Integer('Messages Per Month', compute='_compute_mail_group_message_last_month_count')
+    mail_group_message_moderation_count = fields.Integer('Messages Count', help='Messages that need an action', compute='_compute_mail_group_message_moderation_count')
+    # Members
+    member_ids = fields.One2many('mail.group.member', 'mail_group_id', string='Members')
+    member_partner_ids = fields.Many2many('res.partner', string='Partners Member', compute='_compute_member_partner_ids', search='_search_member_partner_ids')
+    member_count = fields.Integer('Members Count', compute='_compute_member_count')
+    # Moderation
+    is_moderator = fields.Boolean(string='Moderator', help='Current user is a moderator of the group', compute='_compute_is_moderator')
+    moderation = fields.Boolean(string='Moderate this group')
+    moderation_rule_count = fields.Integer(string='Moderated emails count', compute='_compute_moderation_rule_count')
+    moderation_rule_ids = fields.One2many('mail.group.moderation', 'mail_group_id', string='Moderated Emails')
+    moderator_ids = fields.Many2many('res.users', 'mail_group_moderator_rel', string='Moderators',
+                                     domain=lambda self: [('groups_id', 'in', self.env.ref('base.group_user').id)])
+    moderation_notify = fields.Boolean(
+        string='Automatic notification',
+        help='People receive an automatic notification about their message being waiting for moderation.')
+    moderation_notify_msg = fields.Text(string='Notification message')
+    moderation_guidelines = fields.Boolean(
+        string='Send guidelines to new subscribers',
+        help='Newcomers on this moderated group will automatically receive the guidelines.')
+    moderation_guidelines_msg = fields.Text(string='Guidelines')
+    # ACLs
+    access_mode = fields.Selection([
+        ('public', 'Everyone'),
+        ('members', 'Members only'),
+        ('groups', 'Selected group of users'),
+        ], string='Privacy', required=True, default='public')
+    access_group_id = fields.Many2one('res.groups', string='Authorized Group',
+                                      default=lambda self: self.env.ref('base.group_user'))
+    # UI
+    can_manage_members = fields.Boolean('Can Manage', help='Can manage the members', compute='_compute_can_manage_members')
+
+    @api.depends('mail_group_message_ids.create_date', 'mail_group_message_ids.moderation_status')
+    def _compute_mail_group_message_last_month_count(self):
+        month_date = datetime.today() - relativedelta.relativedelta(months=1)
+        messages_data = self.env['mail.group.message'].read_group([
+            ('create_date', '>=', fields.Datetime.to_string(month_date)),
+            ('moderation_status', '=', 'accepted'),
+        ], ['mail_group_id'], ['mail_group_id'])
+
+        # { mail_discusison_id: number_of_mail_group_message_last_month_count }
+        messages_data = {
+            message['mail_group_id'][0]: message['mail_group_id_count']
+            for message in messages_data
+        }
+
+        for group in self:
+            group.mail_group_message_last_month_count = messages_data.get(group.id, 0)
+
+    @api.depends('mail_group_message_ids.moderation_status')
+    def _compute_mail_group_message_moderation_count(self):
+        results = self.env['mail.group.message'].read_group(
+            [('moderation_status', '=', 'pending_moderation')],
+            ['mail_group_id'],
+            ['mail_group_id'],
+        )
+        result_per_group = {
+            result['mail_group_id'][0]: result['mail_group_id_count']
+            for result in results
+        }
+
+        for group in self:
+            group.mail_group_message_moderation_count = result_per_group.get(group.id)
+
+    @api.depends('member_ids')
+    def _compute_member_count(self):
+        for group in self:
+            group.member_count = len(group.member_ids)
+
+    @api.depends('member_ids')
+    def _compute_member_partner_ids(self):
+        for group in self:
+            group.member_partner_ids = group.member_ids.partner_id
+
+    def _search_member_partner_ids(self, operator, operand):
+        return [(
+            'member_ids',
+            'in',
+            self.env['mail.group.member'].sudo()._search([
+                ('partner_id', operator, operand)
+            ])
+        )]
+
+    @api.depends('moderator_ids')
+    @api.depends_context('uid')
+    def _compute_is_moderator(self):
+        for group in self:
+            group.is_moderator = self.env.user.id in group.moderator_ids.ids
+
+    @api.depends('moderation_rule_ids')
+    def _compute_moderation_rule_count(self):
+        for group in self:
+            group.moderation_rule_count = len(group.moderation_rule_ids)
+
+    @api.depends('is_moderator')
+    @api.depends_context('uid')
+    def _compute_can_manage_members(self):
+        is_admin = self.env.user.has_group('mail_group.group_mail_group_manager')
+        for group in self:
+            group.can_manage_members = is_admin or group.is_moderator
+
+    @api.onchange('access_mode')
+    def _onchange_access_mode(self):
+        if self.access_mode == 'public':
+            self.alias_contact = 'everyone'
+        else:
+            self.alias_contact = 'followers'
+
+    @api.onchange('moderation')
+    def _onchange_moderation(self):
+        if self.moderation and self.env.user not in self.moderator_ids:
+            self.moderator_ids |= self.env.user
+
+    # CONSTRAINTS
+
+    @api.constrains('moderator_ids')
+    def _check_moderator_email(self):
+        if any(not moderator.email for group in self for moderator in group.moderator_ids):
+            raise ValidationError(_('Moderators must have an email address.'))
+
+    @api.constrains('moderation_notify', 'moderation_notify_msg')
+    def _check_moderation_notify(self):
+        if any(group.moderation_notify and not group.moderation_notify_msg for group in self):
+            raise ValidationError(_('The notification message is missing.'))
+
+    @api.constrains('moderation_guidelines', 'moderation_guidelines_msg')
+    def _check_moderation_guidelines(self):
+        if any(group.moderation_guidelines and not group.moderation_guidelines_msg for group in self):
+            raise ValidationError(_('The guidelines description is missing.'))
+
+    @api.constrains('moderator_ids', 'moderation')
+    def _check_moderator_existence(self):
+        if any(not group.moderator_ids for group in self if group.moderation):
+            raise ValidationError(_('Moderated group must have moderators.'))
+
+    @api.constrains('access_mode', 'access_group_id')
+    def _check_access_mode(self):
+        if any(group.access_mode == 'groups' and not group.access_group_id for group in self):
+            raise ValidationError(_('The "Authorized Group" is missing.'))
+
+    def _alias_get_creation_values(self):
+        """Return the default values for the automatically created alias."""
+        values = super(MailGroup, self)._alias_get_creation_values()
+        values['alias_model_id'] = self.env['ir.model']._get('mail.group').id
+        values['alias_force_thread_id'] = self.id
+        values['alias_defaults'] = literal_eval(self.alias_defaults or '{}')
+        return values
+
+    # ------------------------------------------------------------
+    # MAILING
+    # ------------------------------------------------------------
+
+    def _alias_get_error_message(self, message, message_dict, alias):
+        self.ensure_one()
+
+        if alias.alias_contact == 'followers':
+            # Members only
+            author_id = message_dict.get('author_id', None)
+            email_from = message_dict.get('email_from')
+            if not self._find_member(email_from, author_id):
+                return _('Only members can send email to the mailing list.')
+            # Skip the verification because the partner is in the member list
+            return
+
+        return super(MailGroup, self)._alias_get_error_message(message, message_dict, alias)
+
+    @api.model
+    def message_new(self, msg_dict, custom_values=None):
+        """Add the method to make the mail gateway flow work with this model."""
+        return
+
+    @api.model
+    def message_update(self, msg_dict, update_vals=None):
+        """Add the method to make the mail gateway flow work with this model."""
+        return
+
+    @api.returns('mail.message', lambda value: value.id)
+    def message_post(self, body='', subject=None, email_from=None, author_id=None, **kwargs):
+        """ Custom posting process. This model does not inherit from ``mail.thread``
+        but uses mailgateway so few methods should be defined.
+
+        This custom posting process works as follow
+
+          * create a ``mail.message`` based on incoming email;
+          * create linked ``mail.group.message`` that encapsulates message in a
+            format used in mail groups;
+          * apply moderation rules;
+
+        :return message: newly-created mail.message
+        """
+        self.ensure_one()
+        # First create the <mail.message>
+        Mailthread = self.env['mail.thread']
+        values = dict((key, val) for key, val in kwargs.items() if key in self.env['mail.message']._fields)
+        author_id, email_from = Mailthread._message_compute_author(author_id, email_from, raise_exception=True)
+        values.update({
+            'author_id': author_id,
+            'body': body or '',
+            'email_from': email_from,
+            'model': self._name,
+            'partner_ids': [],
+            'reply_to': self.env['mail.message']._get_reply_to(values),
+            'res_id': self.id,
+            'subject': subject,
+        })
+        # ensure message ID so that replies go to the right thread
+        if not values.get('message_id'):
+            values['message_id'] = generate_tracking_message_id('%s-mail.group' % self.id)
+
+        attachments = kwargs.get('attachments') or []
+        attachment_ids = kwargs.get('attachment_ids') or []
+        attachement_values = Mailthread._message_post_process_attachments(attachments, attachment_ids, values)
+        values.update(attachement_values)
+
+        mail_message = Mailthread._message_create(values)
+
+        # Find the <mail.group.message> parent
+        group_message_parent_id = False
+        if mail_message.parent_id:
+            group_message_parent = self.env['mail.group.message'].search(
+                [('mail_message_id', '=', mail_message.parent_id.id)])
+            group_message_parent_id = group_message_parent.id if group_message_parent else False
+
+        moderation_status = 'pending_moderation' if self.moderation else 'accepted'
+
+        # Create the group message associated
+        group_message = self.env['mail.group.message'].create({
+            'mail_group_id': self.id,
+            'mail_message_id': mail_message.id,
+            'moderation_status': moderation_status,
+            'group_message_parent_id': group_message_parent_id,
+        })
+
+        # Check the moderation rule to determine if we should accept or reject the email
+        email_normalized = email_normalize(email_from)
+        moderation_rule = self.env['mail.group.moderation'].search([
+            ('mail_group_id', '=', self.id),
+            ('email', '=', email_normalized),
+        ], limit=1)
+
+        if not self.moderation:
+            self._notify_members(group_message)
+
+        elif moderation_rule and moderation_rule.status == 'allow':
+            group_message.action_moderate_accept()
+
+        elif moderation_rule and moderation_rule.status == 'ban':
+            group_message.action_moderate_reject()
+
+        elif self.moderation_notify:
+            self.env['mail.mail'].sudo().create({
+                'author_id': self.env.user.partner_id.id,
+                'auto_delete': True,
+                'body_html': group_message.mail_group_id.moderation_notify_msg,
+                'email_from': self.env.user.company_id.catchall_formatted or self.env.user.company_id.email_formatted,
+                'email_to': email_from,
+                'subject': 'Re: %s' % (subject or ''),
+                'state': 'outgoing'
+            })
+
+        return mail_message
+
+    def action_send_guidelines(self, members=None):
+        """ Send guidelines to given members. """
+        self.ensure_one()
+
+        if not self.env.is_admin() and not self.is_moderator:
+            raise UserError(_('Only an administrator or a moderator can send guidelines to group members.'))
+
+        if not self.moderation_guidelines_msg:
+            raise UserError(_('The guidelines description is empty.'))
+
+        template = self.env.ref('mail_group.mail_group_send_guidelines', raise_if_not_found=False)
+        if not template:
+            raise UserError(_('View "mail_group.mail_group_send_guidelines" was not found. No email has been sent. Please contact an administrator to fix this issue.'))
+
+        banned_emails = self.env['mail.group.moderation'].sudo().search([
+            ('status', '=', 'ban'),
+            ('mail_group_id', '=', self.id),
+        ]).mapped('email')
+
+        if members is None:
+            members = self.member_ids
+        members = members.filtered(lambda member: member.email_normalized not in banned_emails)
+
+        mails_values = []
+        for member in members:
+            company = member.partner_id.company_id or self.env.company
+            mails_values.append({
+                'author_id': self.env.user.partner_id.id,
+                'auto_delete': True,
+                'body_html': template._render({'group': self, 'member': member}, engine='ir.qweb', minimal_qcontext=True),
+                'email_from': company.catchall_formatted or company.email_formatted,
+                'email_to': member.email,
+                'model': 'mail.group',
+                'res_id': self.id,
+                'subject': _('Guidelines of group %s', self.name),
+            })
+
+        mails = self.env['mail.mail'].sudo().create(mails_values)
+
+        _logger.info('Send guidelines to %i members', len(mails))
+
+    def _notify_members(self, message):
+        """Send the given message to all members of the mail group (except the author)."""
+        self.ensure_one()
+
+        if message.mail_group_id != self:
+            raise UserError(_('The group of the message do not match.'))
+
+        if not message.mail_message_id.reply_to:
+            _logger.error('The alias or the catchall domain is missing, group might not work properly.')
+
+        base_url = self.get_base_url()
+        body = self.env['mail.render.mixin']._replace_local_links(message.body)
+        access_token = self._generate_group_access_token()
+        mail_values = []
+        for batch_members in tools.split_every(GROUP_SEND_BATCH_SIZE, self.member_ids):
+            for member in batch_members:
+                if member.email_normalized == message.email_from_normalized:
+                    # Do not send the email to his author
+                    continue
+
+                # SMTP headers related to the subscription
+                email_url_encoded = urls.url_quote(member.email_normalized)
+                headers = {
+                    'List-Archive': f'<{base_url}/groups/{slug(self)}>',
+                    'List-Subscribe': f'<{base_url}/groups?email={email_url_encoded}>',
+                    'List-Unsubscribe': f'<{base_url}/groups?unsubscribe&email={email_url_encoded}>',
+                }
+
+                # Add the footer (member specific) in the body
+                template_values = {
+                    'mailto': f'{self.alias_name}@{self.alias_domain}',
+                    'group_url': f'{base_url}/groups/{slug(self)}',
+                    'unsub_url':  f'{base_url}/groups?unsubscribe&group_id={self.id}&token={access_token}'
+                }
+                template = self.env.ref('mail_group.mail_group_footer')
+                footer = template._render(template_values, engine='ir.qweb', minimal_qcontext=True)
+                member_body = tools.append_content_to_html(body, footer)
+
+                mail_values.append({
+                    'auto_delete': True,
+                    'attachment_ids': message.attachment_ids.ids,
+                    'body_html': member_body,
+                    'email_from': message.email_from,
+                    'email_to': member.email,
+                    'headers': json.dumps(headers),
+                    'mail_message_id': message.mail_message_id.id,
+                    'message_id': message.mail_message_id.message_id,
+                    'model': 'mail.group',
+                    'reply_to': message.mail_message_id.reply_to,
+                    'res_id': self.id,
+                    'subject': message.subject,
+                })
+
+            if mail_values:
+                self.env['mail.mail'].sudo().create(mail_values)
+
+    @api.model
+    def _cron_notify_moderators(self):
+        moderated_groups = self.env['mail.group'].search([('moderation', '=', True)])
+        return moderated_groups._notify_moderators()
+
+    def _notify_moderators(self):
+        """Push a notification (Inbox / Email) to the moderators whose an action is waiting."""
+        template = self.env.ref('mail_group.mail_group_notify_moderation', raise_if_not_found=False)
+        if not template:
+            _logger.warning('Template "mail_group.mail_group_notify_moderation" was not found. Cannot send reminder notifications.')
+            return
+
+        results = self.env['mail.group.message'].read_group(
+            [('moderation_status', '=', 'pending_moderation'),
+             ('mail_group_id', 'in', self.ids)
+            ],
+            ['mail_group_id'],
+            ['mail_group_id'],
+        )
+        groups = self.browse([result['mail_group_id'][0] for result in results])
+        moderators_to_notify = groups.mapped('moderator_ids')
+
+        MailThread = self.env['mail.thread'].with_context(mail_notify_author=True)
+        for moderator in moderators_to_notify:
+            body = template._render({'record': moderator.partner_id}, engine='ir.qweb', minimal_qcontext=True)
+            email_from = moderator.company_id.catchall_formatted or moderator.company_id.email_formatted
+            MailThread.message_notify(
+                partner_ids=moderator.partner_id.ids,
+                subject=_('Messages are pending moderation'), body=body,
+                email_from=email_from,
+            )
+
+    # ------------------------------------------------------------
+    # MEMBERSHIP
+    # ------------------------------------------------------------
+
+    def _join_group(self, email, partner_id=None):
+        self.ensure_one()
+
+        if partner_id:
+            partner = self.env['res.partner'].browse(partner_id).exists()
+            email = partner.email
+
+        existing_member = self._find_member(email, partner_id)
+        if existing_member:
+            raise UserError(_('The email "%s" is already registered in this group.', email))
+
+        member = self.env['mail.group.member'].create({
+            'partner_id': partner_id,
+            'email': email,
+            'mail_group_id': self.id,
+        })
+
+        if self.moderation_guidelines:
+            # Automatically send the guidelines to the new member
+            self.action_send_guidelines(member)
+
+    def _leave_group(self, email, partner_id=None):
+        self.ensure_one()
+        member = self._find_member(email, partner_id)
+        if member:
+            member.unlink()
+
+    def _send_subscribe_confirmation_email(self, email):
+        """Send an email to the given address to subscribe / unsubscribe to the mailing list."""
+        self.ensure_one()
+        confirm_action_url = self._generate_action_url(email, 'subscribe')
+
+        template = self.env.ref('mail_group.mail_template_list_subscribe')
+        template.with_context(token_url=confirm_action_url).send_mail(
+            self.id,
+            force_send=True,
+            email_values={
+                'author_id': self.create_uid.partner_id.id,
+                'auto_delete': True,
+                'email_from': self.env.company.email_formatted,
+                'email_to': email,
+                'message_type': 'user_notification',
+            },
+            notif_layout='mail.mail_notification_light',
+        )
+        _logger.info('Subscription email sent to %s.', email)
+
+    def _send_unsubscribe_confirmation_email(self, email, action):
+        """Send an email to the given address to subscribe / unsubscribe to the mailing list."""
+        self.ensure_one()
+        confirm_action_url = self._generate_action_url(email, 'unsubscribe')
+
+        template = self.env.ref('mail_group.mail_template_list_unsubscribe')
+        template.with_context(token_url=confirm_action_url).send_mail(
+            self.id,
+            force_send=True,
+            email_values={
+                'author_id': self.create_uid.partner_id.id,
+                'auto_delete': True,
+                'email_from': self.env.company.email_formatted,
+                'email_to': email,
+                'message_type': 'user_notification',
+            },
+            notif_layout='mail.mail_notification_light',
+        )
+        _logger.info('Unsubscription email sent to %s.', email)
+
+    def _generate_action_url(self, email, action):
+        """Generate the confirmation URL to subscribe / unsubscribe from the mailing list."""
+        if action not in ['subscribe', 'unsubscribe']:
+            raise ValueError(_('Invalid action for URL generation (%s)', action))
+        self.ensure_one()
+
+        confirm_action_url = '/groups/subscribe?%s' % urls.url_encode({
+            'group_id': self.id,
+            'email': email,
+            'token': self._generate_action_token(email, action),
+            'action': action,
+        })
+        base_url = self.get_base_url()
+        confirm_action_url = urls.url_join(base_url, confirm_action_url)
+        return confirm_action_url
+
+    def _generate_action_token(self, email, action):
+        """Generate an action token to be able to subscribe / unsubscribe from the mailing list."""
+        if action not in ['subscribe', 'unsubscribe']:
+            raise ValueError(_('Invalid action for URL generation (%s)', action))
+        self.ensure_one()
+
+        email_normalized = email_normalize(email)
+        if not email_normalized:
+            raise UserError(_('Email %s is invalid', email))
+
+        data = (self.id, email_normalized, action)
+        return hmac(self.env(su=True), 'mail_group-email-subscription', data)
+
+    def _generate_group_access_token(self):
+        """Generate an action token to be able to subscribe / unsubscribe from the mailing list."""
+        self.ensure_one()
+        return hmac(self.env(su=True), 'mail_group-access-token-portal', self.id)
+
+    def _find_member(self, email, partner_id=None):
+        """Return the <mail.group.member> corresponding to the given email address."""
+        self.ensure_one()
+
+        result = self._find_members(email, partner_id)
+        return result.get(self.id)
+
+    def _find_members(self, email, partner_id):
+        """Get all the members record corresponding to the email / partner_id.
+
+        Can be called in batch and return a dictionary
+            {'group_id': <mail.group.member>}
+        """
+        domain = [('email_normalized', '=', email_normalize(email))]
+        if partner_id:
+            domain = expression.OR([domain, [('partner_id', '=', partner_id)]])
+        domain = expression.AND([domain, [('mail_group_id', 'in', self.ids)]])
+        members_data = self.env['mail.group.member'].sudo().search(domain)
+        return {
+            member.mail_group_id.id: member
+            for member in members_data
+        }

--- a/None
+++ b/addons/mail_group/models/mail_group_member.py
@@ -0,0 +1,42 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+import logging
+
+from odoo import api, fields, models
+from odoo.tools import email_normalize
+
+_logger = logging.getLogger(__name__)
+
+
+class MailGroupMember(models.Model):
+    """Models a group member that can be either an email address either a full partner."""
+    _name = 'mail.group.member'
+    _description = 'Mailing List Member'
+    _rec_name = 'email'
+
+    email = fields.Char(string='Email', compute='_compute_email', readonly=False, store=True)
+    email_normalized = fields.Char(
+        string='Normalized Email', compute='_compute_email_normalized',
+        index=True, store=True)
+    mail_group_id = fields.Many2one('mail.group', string='Group', required=True, ondelete='cascade')
+    partner_id = fields.Many2one('res.partner', 'Partner', ondelete='cascade')
+
+    _sql_constraints = [(
+        'unique_partner',
+        'UNIQUE(partner_id, mail_group_id)',
+        'This partner is already subscribed to the group',
+    )]
+
+    @api.depends('partner_id.email')
+    def _compute_email(self):
+        for member in self:
+            if member.partner_id:
+                member.email = member.partner_id.email
+            elif not member.email:
+                member.email = False
+
+    @api.depends('email')
+    def _compute_email_normalized(self):
+        for moderation in self:
+            moderation.email_normalized = email_normalize(moderation.email)

--- a/None
+++ b/addons/mail_group/models/mail_group_message.py
@@ -0,0 +1,227 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+import logging
+
+from odoo import _, api, fields, models, tools
+from odoo.exceptions import AccessError, UserError
+from odoo.osv import expression
+from odoo.tools import email_normalize
+
+_logger = logging.getLogger(__name__)
+
+
+class MailGroupMessage(models.Model):
+    """Emails belonging to a discussion group.
+
+    Those are build on <mail.message> with additional information related to specific
+    features of <mail.group> like better parent / children management and moderation.
+    """
+    _name = 'mail.group.message'
+    _description = 'Mailing List Message'
+    _rec_name = 'subject'
+    _order = 'create_date DESC'
+
+    # <mail.message> fields, can not be done with inherits because it will impact
+    # the performance of the <mail.message> model (different cache, so the ORM will need
+    # to do one more SQL query to be able to update the <mail.group.message> cache)
+    attachment_ids = fields.Many2many(related='mail_message_id.attachment_ids', readonly=False)
+    author_id = fields.Many2one(related='mail_message_id.author_id', readonly=False)
+    email_from = fields.Char(related='mail_message_id.email_from', readonly=False)
+    email_from_normalized = fields.Char('Normalized From', compute='_compute_email_from_normalized', store=True)
+    body = fields.Html(related='mail_message_id.body', readonly=False)
+    subject = fields.Char(related='mail_message_id.subject', readonly=False)
+    # thread
+    mail_group_id = fields.Many2one(
+        'mail.group', string='Group',
+        required=True, ondelete='cascade')
+    mail_message_id = fields.Many2one('mail.message', 'Mail Message', required=True, ondelete='cascade', index=True, copy=False)
+    # Parent and children
+    group_message_parent_id = fields.Many2one(
+        'mail.group.message', string='Parent', store=True,
+        inverse='_inverse_group_message_parent_id')
+    group_message_child_ids = fields.One2many('mail.group.message', 'group_message_parent_id', string='Childs')
+    # Moderation
+    moderation_status = fields.Selection(
+        [('pending_moderation', 'Pending Moderation'),
+         ('accepted', 'Accepted'),
+         ('rejected', 'Rejected')],
+        string='Status', index=True, copy=False,
+        required=True, default='pending_moderation')
+    moderator_id = fields.Many2one('res.users', string='Moderated By')
+
+    @api.depends('email_from')
+    def _compute_email_from_normalized(self):
+        for message in self:
+            message.email_from_normalized = email_normalize(message.email_from)
+
+    def _inverse_group_message_parent_id(self):
+        # TDE CHECK: check to remove
+        for message in self:
+            message.mail_message_id.parent_id = message.group_message_parent_id.mail_message_id
+
+    @api.constrains('mail_message_id')
+    def _constrains_mail_message_id(self):
+        for message in self:
+            if message.mail_message_id.model != 'mail.group':
+                raise AccessError(_(
+                    'Group message can only be linked to mail group. Current model is %s.',
+                    message.mail_message_id.model,
+                ))
+            if message.mail_message_id.res_id != message.mail_group_id.id:
+                raise AccessError(_('The record of the message should be the group.'))
+
+    @api.model_create_multi
+    def create(self, values_list):
+        for vals in values_list:
+            if not vals.get('mail_message_id'):
+                vals.update({
+                    'res_id': vals.get('mail_group_id'),
+                    'model': 'mail.group',
+                })
+                vals['mail_message_id'] = self.env['mail.message'].sudo().create({
+                    field: vals.pop(field)
+                    for field in self.env['mail.message']._fields
+                    if field in vals
+                }).id
+        return super(MailGroupMessage, self).create(values_list)
+
+    def copy(self, default=None):
+        default = dict(default or {})
+        default['mail_message_id'] = self.mail_message_id.copy().id
+        return super(MailGroupMessage, self).copy(default)
+
+    # --------------------------------------------------
+    # MODERATION API
+    # --------------------------------------------------
+
+    def action_moderate_accept(self):
+        """Accept the incoming email.
+
+        Will send the incoming email to all members of the group.
+        """
+        self._assert_moderable()
+        self.write({
+            'moderation_status': 'accepted',
+            'moderator_id': self.env.uid,
+        })
+
+        # Send the email to the members of the group
+        for message in self:
+            message.mail_group_id._notify_members(message)
+
+    def action_moderate_reject_with_comment(self, reject_subject, reject_comment):
+        self._assert_moderable()
+        if reject_subject or reject_comment:
+            self._moderate_send_reject_email(reject_subject, reject_comment)
+        self.action_moderate_reject()
+
+    def action_moderate_reject(self):
+        self._assert_moderable()
+        self.write({
+            'moderation_status': 'rejected',
+            'moderator_id': self.env.uid,
+        })
+
+    def action_allow(self):
+        self._assert_moderable()
+        self._create_moderation_rule('allow')
+
+        # Accept all emails of the same authors
+        same_author = self._get_pending_same_author_same_group()
+        same_author.action_moderate_accept()
+
+    def action_ban(self):
+        self._assert_moderable()
+        self._create_moderation_rule('ban')
+
+        # Reject all emails of the same author
+        same_author = self._get_pending_same_author_same_group()
+        same_author.action_moderate_reject()
+
+    def _get_pending_same_author_same_group(self):
+        """Return the pending messages of the same authors in the same groups."""
+        return self.search(
+            expression.AND([
+                expression.OR([
+                    [
+                        ('mail_group_id', '=', message.mail_group_id.id),
+                        ('email_from_normalized', '=', message.email_from_normalized),
+                    ] for message in self
+                ]),
+                [('moderation_status', '=', 'pending_moderation')],
+            ])
+        )
+
+    def _create_moderation_rule(self, status):
+        """Create a moderation rule <mail.group.moderation> with the given status.
+
+        Update existing moderation rule for the same email address if found,
+        otherwise create a new rule.
+        """
+        if status not in ('ban', 'allow'):
+            raise ValueError(_('Wrong status (%s)', status))
+
+        for message in self:
+            if not email_normalize(message.email_from):
+                raise UserError(_('The email "%s" is not valid.', message.email_from))
+
+        existing_moderation = self.env['mail.group.moderation'].search(
+            expression.OR([
+                [
+                    ('email', '=', email_normalize(message.email_from)),
+                    ('mail_group_id', '=', message.mail_group_id.id)
+                ] for message in self
+            ])
+        )
+        existing_moderation.status = status
+
+        # Add the value in a set to create only 1 moderation rule per (email_normalized, group)
+        moderation_to_create = {
+            (email_normalize(message.email_from), message.mail_group_id.id)
+            for message in self
+            if email_normalize(message.email_from) not in existing_moderation.mapped('email')
+        }
+
+        self.env['mail.group.moderation'].create([
+            {
+                'email': email,
+                'mail_group_id': mail_group_id,
+                'status': status,
+            } for email, mail_group_id in moderation_to_create])
+
+    def _assert_moderable(self):
+        """Raise an error if one of the current message can not be moderated.
+
+        A <mail.group.message> can only be moderated
+        if it's moderation status is "pending_moderation".
+        """
+        non_moderable_messages = self.filtered_domain([
+            ('moderation_status', '!=', 'pending_moderation'),
+        ])
+        if non_moderable_messages:
+            if len(self) == 1:
+                raise UserError(_('This message can not be moderated'))
+            raise UserError(_(
+                'Those messages can not be moderated: %s.',
+                ', '.join(non_moderable_messages.mapped('subject')),
+            ))
+
+    def _moderate_send_reject_email(self, subject, comment):
+        for message in self:
+            if not message.email_from:
+                continue
+
+            # TDE CHECK: markup
+            body_html = tools.append_content_to_html('<div>%s</div>' % tools.ustr(comment), message.body, plaintext=False)
+            body_html = self.env['mail.render.mixin']._replace_local_links(body_html)
+            self.env['mail.mail'].sudo().create({
+                'author_id': self.env.user.partner_id.id,
+                'auto_delete': True,
+                'body_html': body_html,
+                'email_from': self.env.user.email_formatted or self.env.company.catchall_formatted,
+                'email_to': message.email_from,
+                'references': message.mail_message_id.message_id,
+                'subject': subject,
+                'state': 'outgoing',
+            })

--- a/None
+++ b/addons/mail_group/models/mail_group_moderation.py
@@ -0,0 +1,41 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from odoo import fields, models, api, _
+from odoo.exceptions import UserError
+from odoo.tools import email_normalize
+
+
+class MailGroupModeration(models.Model):
+    """Represent the moderation rules for an email address in a group."""
+    _name = 'mail.group.moderation'
+    _description = 'Mailing List black/white list'
+
+    email = fields.Char(string='Email', required=True)
+    status = fields.Selection(
+        [('allow', 'Always Allow'), ('ban', 'Permanent Ban')],
+        string='Status', required=True, default='ban')
+    mail_group_id = fields.Many2one('mail.group', string='Group', required=True, ondelete='cascade')
+
+    _sql_constraints = [(
+        'mail_group_email_uniq',
+        'UNIQUE(mail_group_id, email)',
+        'You can create only one rule for a given email address in a group.',
+    )]
+
+    @api.model_create_multi
+    def create(self, vals_list):
+        for values in vals_list:
+            email_normalized = email_normalize(values.get('email'))
+            if not email_normalized:
+                raise UserError(_('Invalid email address %r', values.get('email')))
+            values['email'] = email_normalized
+        return super(MailGroupModeration, self).create(vals_list)
+
+    def write(self, values):
+        if 'email' in values:
+            email_normalized = email_normalize(values['email'])
+            if not email_normalized:
+                raise UserError(_('Invalid email address %r', values.get('email')))
+            values['email'] = email_normalized
+        return super(MailGroupModeration, self).write(values)
