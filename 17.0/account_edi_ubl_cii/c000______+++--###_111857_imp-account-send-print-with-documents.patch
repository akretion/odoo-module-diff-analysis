PR: https://github.com/odoo/odoo/pull/111857

From: 955091e707df1206ccda8314f1f182e2a37a8362
From: Laurent Smet
Date: 2023-03-03 18:10:10

Structural Changes: 16
Total Changes: 844

[IMP] account*: send&print with documents

Refactoring send&print wizard.
==============================

Main reason for this commit is that we want to let the user
decide when to generate the relevant documents / approvals
for its invoices. The natural choice is when the information
leaves Odoo. So now, each time the users decide to
download/send its invoices, he will be able to select the
relevant documents to be generated and the approvals to be
requested from the send&print wizard.

This used to happen automatically during the posting with lots
of undesirable behaviors (difficulty to update/revert, hard to
know exactly what will happen,...)

Main changes:

1/ Send&print wizard

- The model 'account.invoice.send' has been replaced by
'account.move.send' and became models.Model to handle
asynchrounous generation of documents (webservice,..) in
case of more than one invoice.

- The wizard is meant to be overriden in order to add
checkbox and document to be generated. A comprehensive exemple
can be found in account_edi_ubl_cii.

2/ Import invoice from attachments

- The decoding logic has moved from account_edi to account
on the attachemnts.

- The function _extend_with_attachments() serve as a common
entry point for import (from chatter, dashboard).

3/ Export invoice pdf / document

- All the specific actions to export attachments should be
implemented on the account.move and called from the wizard in
 _generate_documents()

- The official pdf for the invoice is now only generated once
 the user request it. In order to regenerate the pdf and
documents, it needs to be deleted.

task-id: 3117238
[enterprise](https://github.com/odoo/enterprise/pull/36757)
[community](https://github.com/odoo/odoo/pull/111857
)

[IMP] web: enable close on ir.actions.act_url in wizard

Before this commit, calling ir.actions.act_url on a modal
leaves the modal open. Which feels ackward in the send&print
wizard.

We now enable 'close' parameter on ir.actions.act_url. If set,
the wizard will close after act_url.

closes odoo/odoo#111857

Related: odoo/enterprise#36757
Related: odoo/upgrade#4387
Signed-off-by: Laurent Smet <las@odoo.com>

================================= pseudo patch: =================================

--- a/addons/account_edi_ubl_cii/models/__init__.py
+++ b/addons/account_edi_ubl_cii/models/__init__.py
@@ -1,8 +1,6 @@
 # -*- coding: utf-8 -*-
 
 from . import account_edi_common
-from . import account_edi_document
-from . import account_edi_format
 from . import account_edi_xml_cii_facturx
 from . import account_edi_xml_ubl_20
 from . import account_edi_xml_ubl_21
@@ -11,4 +9,6 @@ from . import account_edi_xml_ubl_xrechnung
 from . import account_edi_xml_ubl_nlcius
 from . import account_edi_xml_ubl_efff
 from . import account_edi_xml_ubl_a_nz
-from . import ir_actions_report
+from . import account_move_send
+from . import account_move
+from . import account_journal

--- a/addons/account_edi_ubl_cii/models/account_edi_common.py
+++ b/addons/account_edi_ubl_cii/models/account_edi_common.py
@@ -250,30 +250,28 @@ class AccountEdiCommon(models.AbstractModel):
     # Import invoice
     # -------------------------------------------------------------------------
 
-    def _import_invoice(self, journal, filename, tree, existing_invoice=None):
-        move_type, qty_factor = self._get_import_document_amount_sign(filename, tree)
+    def _import_invoice_ubl_cii(self, invoice, file_data, new=False):
+        tree = file_data['xml_tree']
+
+        # Not able to decode the move_type from the xml.
+        move_type, qty_factor = self._get_import_document_amount_sign(tree)
         if not move_type:
             return
+
+        # Check for inconsistent move_type.
+        journal = invoice.journal_id
         if journal.type == 'sale':
             move_type = 'out_' + move_type
         elif journal.type == 'purchase':
             move_type = 'in_' + move_type
         else:
             return
-        if existing_invoice and existing_invoice.move_type != move_type:
+        if not new and invoice.move_type != move_type:
             return
 
-        with (existing_invoice or self.env['account.move']).with_context(
-            default_move_type=move_type,
-            default_journal_id=journal.id,
-        )._get_edi_creation() as invoice:
-            logs = self._import_fill_invoice_form(journal, tree, invoice, qty_factor)
-
-        # For UBL, we should override the computed tax amount if it is less than 0.05 different of the one in the xml.
-        # In order to support use case where the tax total is adapted for rounding purpose.
-        # This has to be done after the first import in order to let Odoo compute the taxes before overriding if needed.
-        with invoice.with_context(account_predictive_bills_disable_prediction=True)._get_edi_creation() as invoice:
-            self._correct_invoice_tax_amount(tree, invoice)
+        # Update the invoice.
+        invoice.move_type = move_type
+        logs = self._import_fill_invoice_form(invoice, tree, qty_factor)
         if invoice:
             if logs:
                 body = _(
@@ -282,7 +280,12 @@ class AccountEdiCommon(models.AbstractModel):
                 )
             else:
                 body = _("<strong>Format used to import the invoice: %s</strong>", str(self._description))
-            invoice.with_context(no_new_invoice=True).message_post(body=body)
+            invoice.message_post(body=body)
+
+        # For UBL, we should override the computed tax amount if it is less than 0.05 different of the one in the xml.
+        # In order to support use case where the tax total is adapted for rounding purpose.
+        # This has to be done after the first import in order to let Odoo compute the taxes before overriding if needed.
+        self._correct_invoice_tax_amount(tree, invoice)
 
         # === Import the embedded PDF in the xml if some are found ===
 
@@ -310,9 +313,9 @@ class AccountEdiCommon(models.AbstractModel):
         if attachments:
             invoice.with_context(no_new_invoice=True).message_post(attachment_ids=attachments.ids)
 
-        return invoice
+        return True
 
-    def _import_fill_invoice_allowance_charge(self, tree, invoice, journal, qty_factor):
+    def _import_fill_invoice_allowance_charge(self, tree, invoice, qty_factor):
         logs = []
         if '{urn:oasis:names:specification:ubl:schema:xsd' in tree.tag:
             is_ubl = True
@@ -364,10 +367,10 @@ class AccountEdiCommon(models.AbstractModel):
             tax_ids = []
             for tax_categ_percent_el in allow_el.findall(tax_xpath):
                 tax = self.env['account.tax'].search([
-                    ('company_id', '=', journal.company_id.id),
+                    ('company_id', '=', invoice.company_id.id),
                     ('amount', '=', float(tax_categ_percent_el.text)),
                     ('amount_type', '=', 'percent'),
-                    ('type_tax_use', '=', journal.type),  # Journal type is ensured by _create_invoice_from_xml_tree to be either 'sale' or 'purchase'
+                    ('type_tax_use', '=', invoice.journal_id.type),  # Journal type is ensured by _create_invoice_from_xml_tree to be either 'sale' or 'purchase'
                 ], limit=1)
                 if tax:
                     tax_ids += tax.ids
@@ -570,16 +573,16 @@ class AccountEdiCommon(models.AbstractModel):
             'product_uom_id': product_uom_id,
         }
 
-    def _import_fill_invoice_line_taxes(self, journal, tax_nodes, invoice_line_form, inv_line_vals, logs):
+    def _import_fill_invoice_line_taxes(self, tax_nodes, invoice_line, inv_line_vals, logs):
         # Taxes: all amounts are tax excluded, so first try to fetch price_include=False taxes,
         # if no results, try to fetch the price_include=True taxes. If results, need to adapt the price_unit.
         inv_line_vals['taxes'] = []
         for tax_node in tax_nodes:
             amount = float(tax_node.text)
             domain = [
-                ('company_id', '=', journal.company_id.id),
+                ('company_id', '=', invoice_line.company_id.id),
                 ('amount_type', '=', 'percent'),
-                ('type_tax_use', '=', journal.type),
+                ('type_tax_use', '=', invoice_line.move_id.journal_id.type),
                 ('amount', '=', amount),
             ]
             tax_excl = self.env['account.tax'].search(domain + [('price_include', '=', False)], limit=1)
@@ -590,17 +593,17 @@ class AccountEdiCommon(models.AbstractModel):
                 inv_line_vals['taxes'].append(tax_incl.id)
                 inv_line_vals['price_unit'] *= (1 + tax_incl.amount / 100)
             else:
-                logs.append(_("Could not retrieve the tax: %s %% for line '%s'.", amount, invoice_line_form.name))
+                logs.append(_("Could not retrieve the tax: %s %% for line '%s'.", amount, invoice_line.name))
         # Set the values on the line_form
-        invoice_line_form.quantity = inv_line_vals['quantity']
+        invoice_line.quantity = inv_line_vals['quantity']
         if inv_line_vals.get('product_uom_id'):
-            invoice_line_form.product_uom_id = inv_line_vals['product_uom_id']
+            invoice_line.product_uom_id = inv_line_vals['product_uom_id']
         else:
             logs.append(
-                _("Could not retrieve the unit of measure for line with label '%s'.", invoice_line_form.name))
-        invoice_line_form.price_unit = inv_line_vals['price_unit']
-        invoice_line_form.discount = inv_line_vals['discount']
-        invoice_line_form.tax_ids = inv_line_vals['taxes']
+                _("Could not retrieve the unit of measure for line with label '%s'.", invoice_line.name))
+        invoice_line.price_unit = inv_line_vals['price_unit']
+        invoice_line.discount = inv_line_vals['discount']
+        invoice_line.tax_ids = inv_line_vals['taxes']
         return logs
 
     def _correct_invoice_tax_amount(self, tree, invoice):
@@ -620,9 +623,7 @@ class AccountEdiCommon(models.AbstractModel):
         elif invoice.move_type == 'out_refund':
             ecosio_format = ecosio_formats['credit_note']
         else:
-            invoice.with_context(no_new_invoice=True).message_post(
-                body="ECOSIO: could not validate xml, formats only exist for invoice or credit notes"
-            )
+            invoice.message_post(body="ECOSIO: could not validate xml, formats only exist for invoice or credit notes")
             return
         if not ecosio_format:
             return
@@ -645,11 +646,9 @@ class AccountEdiCommon(models.AbstractModel):
                         "<li><font style='color:Tomato;'><strong>" + detail['errorText'] + "</strong></font></li>")
 
         if errors_cnt == 0:
-            invoice.with_context(no_new_invoice=True).message_post(
-                body=f"<font style='color:Green;'><strong>ECOSIO: All clear for format {ecosio_format}!</strong></font>"
-            )
+            invoice.message_post(body=f"<font style='color:Green;'><strong>ECOSIO: All clear for format {ecosio_format}!</strong></font>")
         else:
-            invoice.with_context(no_new_invoice=True).message_post(
+            invoice.message_post(
                 body=f"<font style='color:Tomato;'><strong>ECOSIO ERRORS/WARNINGS for format {ecosio_format}</strong></font>: <ul> "
                      + "\n".join(report) + " </ul>"
             )

--- a/addons/account_edi_ubl_cii/models/account_edi_document.py
+++ b/None
@@ -1,14 +0,0 @@
-# -*- coding: utf-8 -*-
-
-from odoo import models
-
-
-class AccountEdiDocument(models.Model):
-    _inherit = "account.edi.document"
-
-    def _filter_edi_attachments_for_mailing(self):
-        self.ensure_one()
-        # Avoid having factur-x.xml in the 'send & print' wizard
-        if self.edi_format_id.code == 'facturx_1_0_05':
-            return {}
-        return super()._filter_edi_attachments_for_mailing()

--- a/addons/account_edi_ubl_cii/models/account_edi_format.py
+++ b/None
@@ -1,209 +0,0 @@
-# -*- coding: utf-8 -*-
-# Part of Odoo. See LICENSE file for full copyright and licensing details.
-
-from odoo import models, fields, _
-from odoo.addons.account_edi_ubl_cii.models.account_edi_common import COUNTRY_EAS
-
-import logging
-
-_logger = logging.getLogger(__name__)
-
-FORMAT_CODES = [
-    'facturx_1_0_05',
-    'ubl_bis3',
-    'ubl_de',
-    'nlcius_1',
-    'efff_1',
-    'ubl_2_1',
-    'ubl_a_nz',
-]
-
-class AccountEdiFormat(models.Model):
-    _inherit = 'account.edi.format'
-
-    ####################################################
-    # Helpers
-    ####################################################
-
-    def _infer_xml_builder_from_tree(self, tree):
-        self.ensure_one()
-        ubl_version = tree.find('{*}UBLVersionID')
-        customization_id = tree.find('{*}CustomizationID')
-        if tree.tag == '{urn:un:unece:uncefact:data:standard:CrossIndustryInvoice:100}CrossIndustryInvoice':
-            return self.env['account.edi.xml.cii']
-        if customization_id is not None:
-            if 'xrechnung' in customization_id.text:
-                return self.env['account.edi.xml.ubl_de']
-            if customization_id.text == 'urn:cen.eu:en16931:2017#compliant#urn:fdc:peppol.eu:2017:poacc:billing:3.0':
-                return self.env['account.edi.xml.ubl_bis3']
-            if customization_id.text == 'urn:cen.eu:en16931:2017#compliant#urn:fdc:nen.nl:nlcius:v1.0':
-                return self.env['account.edi.xml.ubl_nl']
-        if ubl_version is not None:
-            if ubl_version.text == '2.0':
-                return self.env['account.edi.xml.ubl_20']
-            if ubl_version.text == '2.1':
-                return self.env['account.edi.xml.ubl_21']
-        return
-
-    def _get_xml_builder(self, company):
-        # see https://communaute.chorus-pro.gouv.fr/wp-content/uploads/2017/08/20170630_Solution-portail_Dossier_Specifications_Fournisseurs_Chorus_Facture_V.1.pdf
-        # page 45 -> ubl 2.1 for France seems also supported
-        # Only show the Factur-X option for DE and FR companies. When generating the PDF, add a Factur-X xml if there
-        # isn't an existing one. So there's always a Factur-X in the PDF, even without the option.
-        if self.code == 'facturx_1_0_05' and company.country_id.code in ['DE', 'FR']:
-            return self.env['account.edi.xml.cii']
-        # if the company's country is not in the EAS mapping, nothing is generated
-        # 'NO' has to be present in COUNTRY_EAS
-        if self.code == 'ubl_bis3' and company.country_id.code in COUNTRY_EAS:
-            return self.env['account.edi.xml.ubl_bis3']
-        # the EDI option will only appear on the journal of dutch companies
-        if self.code == 'nlcius_1' and company.country_id.code == 'NL':
-            return self.env['account.edi.xml.ubl_nl']
-        # the EDI option will only appear on the journal of german companies
-        if self.code == 'ubl_de' and company.country_id.code == 'DE':
-            return self.env['account.edi.xml.ubl_de']
-        if self.code == 'efff_1' and company.country_id.code == 'BE':
-            return self.env['account.edi.xml.ubl_efff']
-        if self.code == 'ubl_a_nz' and company.country_id.code in ['AU', 'NZ']:
-            return self.env['account.edi.xml.ubl_a_nz']
-
-    def _is_ubl_cii_available(self, company):
-        """
-        Returns a boolean indicating whether it is possible to generate an xml file using one of the formats from this
-        module or not
-        """
-        return self._get_xml_builder(company) is not None
-
-    ####################################################
-    # Export: Account.edi.format override
-    ####################################################
-
-    def _is_compatible_with_journal(self, journal):
-        # EXTENDS account_edi
-        # the formats appear on the journal only if they are compatible (e.g. NLCIUS only appear for dutch companies)
-        self.ensure_one()
-        if self.code not in FORMAT_CODES:
-            return super()._is_compatible_with_journal(journal)
-        return self._is_ubl_cii_available(journal.company_id) and journal.type == 'sale'
-
-    def _is_enabled_by_default_on_journal(self, journal):
-        # EXTENDS account_edi
-        self.ensure_one()
-        if self.code not in FORMAT_CODES:
-            return super()._is_enabled_by_default_on_journal(journal)
-        return False
-
-    def _ubl_cii_post_invoice(self, invoice):
-        # EXTENDS account_edi
-        self.ensure_one()
-
-        builder = self._get_xml_builder(invoice.company_id)
-        # For now, the errors are not displayed anywhere, don't want to annoy the user
-        xml_content, errors = builder._export_invoice(invoice)
-
-        # DEBUG: send directly to the test platform (the one used by ecosio)
-        #response = self.env['account.edi.common']._check_xml_ecosio(invoice, xml_content, builder._export_invoice_ecosio_schematrons())
-
-        attachment_create_vals = {
-            'name': builder._export_invoice_filename(invoice),
-            'raw': xml_content,
-            'mimetype': 'application/xml',
-        }
-        # we don't want the Factur-X and E-FFF xml to appear in the attachment of the invoice when confirming it
-        # E-FFF will appear after the pdf is generated, Factur-X will never appear (it's contained in the PDF)
-        if self.code not in ['facturx_1_0_05', 'efff_1']:
-            attachment_create_vals.update({'res_id': invoice.id, 'res_model': 'account.move'})
-
-        attachment = self.env['ir.attachment'].create(attachment_create_vals)
-
-        res = {invoice: {'attachment': attachment}}
-        if errors and self.code == 'facturx_1_0_05':
-            res[invoice].update({
-                'success': False,
-                'error': _("Errors occured while creating the EDI document (format: %s). The receiver "
-                           "might refuse it.", builder._description)
-                         + '<p> <li>' + "</li> <li>".join(errors) + '</li> </p>',
-                'blocking_level': 'info',
-            })
-        else:
-            res[invoice]['success'] = True
-        return res
-
-    def _get_move_applicability(self, move):
-        # EXTENDS account_edi
-        self.ensure_one()
-        if self.code not in FORMAT_CODES:
-            return super()._get_move_applicability(move)
-
-        if self._is_ubl_cii_available(move.company_id) and move.move_type in ('out_invoice', 'out_refund'):
-            return {'post': self._ubl_cii_post_invoice}
-
-    def _is_embedding_to_invoice_pdf_needed(self):
-        # EXTENDS account_edi
-        self.ensure_one()
-
-        if self.code == 'facturx_1_0_05':
-            return True
-        return super()._is_embedding_to_invoice_pdf_needed()
-
-    def _prepare_invoice_report(self, pdf_writer, edi_document):
-        # EXTENDS account_edi
-        self.ensure_one()
-        if self.code != 'facturx_1_0_05':
-            return super()._prepare_invoice_report(pdf_writer, edi_document)
-        attachment = edi_document.sudo().attachment_id
-        if not attachment:
-            return
-
-        pdf_writer.embed_odoo_attachment(attachment, subtype='text/xml')
-        if not pdf_writer.is_pdfa:
-            try:
-                pdf_writer.convert_to_pdfa()
-            except Exception as e:
-                _logger.exception("Error while converting to PDF/A: %s", e)
-            metadata_template = self.env.ref('account_edi_ubl_cii.account_invoice_pdfa_3_facturx_metadata',
-                                             raise_if_not_found=False)
-            if metadata_template:
-                content = self.env['ir.qweb']._render('account_edi_ubl_cii.account_invoice_pdfa_3_facturx_metadata', {
-                    'title': edi_document.move_id.name,
-                    'date': fields.Date.context_today(self),
-                })
-                pdf_writer.add_file_metadata(content.encode())
-
-    ####################################################
-    # Import: Account.edi.format override
-    ####################################################
-
-    def _create_invoice_from_xml_tree(self, filename, tree, journal=None):
-        # EXTENDS account_edi
-        self.ensure_one()
-
-        if not self._is_ubl_cii_available(journal.company_id) and self.code != 'facturx_1_0_05':
-            return super()._create_invoice_from_xml_tree(filename, tree, journal=journal)
-
-        # infer the xml builder
-        invoice_xml_builder = self._infer_xml_builder_from_tree(tree)
-
-        if invoice_xml_builder is not None:
-            invoice = invoice_xml_builder._import_invoice(journal, filename, tree)
-            if invoice:
-                return invoice
-
-        return super()._create_invoice_from_xml_tree(filename, tree, journal=journal)
-
-    def _update_invoice_from_xml_tree(self, filename, tree, invoice):
-        # EXTENDS account_edi
-        self.ensure_one()
-
-        if not self._is_ubl_cii_available(invoice.company_id) and self.code != 'facturx_1_0_05':
-            return super()._update_invoice_from_xml_tree(filename, tree, invoice)
-
-        # infer the xml builder
-        invoice_xml_builder = self._infer_xml_builder_from_tree(tree)
-
-        if invoice_xml_builder is not None:
-            invoice = invoice_xml_builder._import_invoice(invoice.journal_id, filename, tree, invoice)
-            if invoice:
-                return invoice
-
-        return super()._update_invoice_from_xml_tree(filename, tree, invoice)

--- a/addons/account_edi_ubl_cii/models/account_edi_xml_cii_facturx.py
+++ b/addons/account_edi_ubl_cii/models/account_edi_xml_cii_facturx.py
@@ -1,6 +1,6 @@
 # -*- coding: utf-8 -*-
 from odoo import models, _
-from odoo.tools import DEFAULT_SERVER_DATE_FORMAT, float_repr, is_html_empty, html2plaintext, cleanup_xml_node
+from odoo.tools import DEFAULT_SERVER_DATE_FORMAT, float_repr, is_html_empty, html2plaintext, cleanup_xml_node, find_xml_value
 from lxml import etree
 
 from datetime import datetime
@@ -204,10 +204,10 @@ class AccountEdiXmlCII(models.AbstractModel):
     # IMPORT
     # -------------------------------------------------------------------------
 
-    def _import_fill_invoice_form(self, journal, tree, invoice, qty_factor):
+    def _import_fill_invoice_form(self, invoice, tree, qty_factor):
 
         def _find_value(xpath, element=tree):
-            return self.env['account.edi.format']._find_value(xpath, element, tree.nsmap)
+            return find_xml_value(xpath, element, tree.nsmap)
 
         logs = []
 
@@ -216,11 +216,12 @@ class AccountEdiXmlCII(models.AbstractModel):
 
         # ==== partner_id ====
 
-        partner_type = invoice.journal_id.type == 'purchase' and 'SellerTradeParty' or 'BuyerTradeParty'
-        invoice.partner_id = self.env['account.edi.format']._retrieve_partner(
+        partner_type = 'SellerTradeParty' if invoice.journal_id.type == 'purchase' else 'BuyerTradeParty'
+        invoice.partner_id = self.env['res.partner']._retrieve_partner(
             name=_find_value(f"//ram:{partner_type}/ram:Name"),
             mail=_find_value(f"//ram:{partner_type}//ram:URIID[@schemeID='SMTP']"),
             vat=_find_value(f"//ram:{partner_type}/ram:SpecifiedTaxRegistration/ram:ID"),
+            company=invoice.company_id,
         )
         if not invoice.partner_id:
             logs.append(_("Could not retrieve the %s.", _("customer") if invoice.is_sale_document() else _("vendor")))
@@ -289,7 +290,7 @@ class AccountEdiXmlCII(models.AbstractModel):
 
         # ==== invoice_line_ids: AllowanceCharge (document level) ====
 
-        logs += self._import_fill_invoice_allowance_charge(tree, invoice, journal, qty_factor)
+        logs += self._import_fill_invoice_allowance_charge(tree, invoice, qty_factor)
 
         # ==== Down Payment (prepaid amount) ====
 
@@ -303,7 +304,7 @@ class AccountEdiXmlCII(models.AbstractModel):
         if line_nodes is not None:
             for invl_el in line_nodes:
                 invoice_line = invoice.invoice_line_ids.create({'move_id': invoice.id})
-                invl_logs = self._import_fill_invoice_line_form(journal, invl_el, invoice, invoice_line, qty_factor)
+                invl_logs = self._import_fill_invoice_line_form(invoice.journal_id, invl_el, invoice, invoice_line, qty_factor)
                 logs += invl_logs
 
         return logs
@@ -312,11 +313,11 @@ class AccountEdiXmlCII(models.AbstractModel):
         logs = []
 
         def _find_value(xpath, element=tree):
-            return self.env['account.edi.format']._find_value(xpath, element, tree.nsmap)
+            return find_xml_value(xpath, element, tree.nsmap)
 
         # Product.
         name = _find_value('.//ram:SpecifiedTradeProduct/ram:Name', tree)
-        invoice_line.product_id = self.env['account.edi.format']._retrieve_product(
+        invoice_line.product_id = self.env['product.product']._retrieve_product(
             default_code=_find_value('.//ram:SpecifiedTradeProduct/ram:SellerAssignedID', tree),
             name=_find_value('.//ram:SpecifiedTradeProduct/ram:Name', tree),
             barcode=_find_value('.//ram:SpecifiedTradeProduct/ram:GlobalID', tree)
@@ -342,13 +343,13 @@ class AccountEdiXmlCII(models.AbstractModel):
         inv_line_vals = self._import_fill_invoice_line_values(tree, xpath_dict, invoice_line, qty_factor)
         # retrieve tax nodes
         tax_nodes = tree.findall('.//{*}ApplicableTradeTax/{*}RateApplicablePercent')
-        return self._import_fill_invoice_line_taxes(journal, tax_nodes, invoice_line, inv_line_vals, logs)
+        return self._import_fill_invoice_line_taxes(tax_nodes, invoice_line, inv_line_vals, logs)
 
     # -------------------------------------------------------------------------
     # IMPORT : helpers
     # -------------------------------------------------------------------------
 
-    def _get_import_document_amount_sign(self, filename, tree):
+    def _get_import_document_amount_sign(self, tree):
         """
         In factur-x, an invoice has code 380 and a credit note has code 381. However, a credit note can be expressed
         as an invoice with negative amounts. For this case, we need a factor to take the opposite of each quantity

--- a/addons/account_edi_ubl_cii/models/account_edi_xml_ubl_20.py
+++ b/addons/account_edi_ubl_cii/models/account_edi_xml_ubl_20.py
@@ -455,7 +455,7 @@ class AccountEdiXmlUBL20(models.AbstractModel):
     # IMPORT
     # -------------------------------------------------------------------------
 
-    def _import_fill_invoice_form(self, journal, tree, invoice, qty_factor):
+    def _import_fill_invoice_form(self, invoice, tree, qty_factor):
         logs = []
 
         if qty_factor == -1:
@@ -463,10 +463,7 @@ class AccountEdiXmlUBL20(models.AbstractModel):
 
         # ==== partner_id ====
 
-        partner = self._import_retrieve_info_from_map(
-            tree,
-            self._import_retrieve_partner_map(self.env.company, journal.type),
-        )
+        partner = self._import_retrieve_partner(tree, invoice)
         if partner:
             invoice.partner_id = partner
         else:
@@ -545,7 +542,7 @@ class AccountEdiXmlUBL20(models.AbstractModel):
 
         # ==== invoice_line_ids: AllowanceCharge (document level) ====
 
-        logs += self._import_fill_invoice_allowance_charge(tree, invoice, journal, qty_factor)
+        logs += self._import_fill_invoice_allowance_charge(tree, invoice, qty_factor)
 
         # ==== Down Payment (prepaid amount) ====
 
@@ -557,18 +554,18 @@ class AccountEdiXmlUBL20(models.AbstractModel):
         invoice_line_tag = 'InvoiceLine' if invoice.move_type in ('in_invoice', 'out_invoice') or qty_factor == -1 else 'CreditNoteLine'
         for i, invl_el in enumerate(tree.findall('./{*}' + invoice_line_tag)):
             invoice_line = invoice.invoice_line_ids.create({'move_id': invoice.id})
-            invl_logs = self._import_fill_invoice_line_form(journal, invl_el, invoice, invoice_line, qty_factor)
+            invl_logs = self._import_fill_invoice_line_form(invl_el, invoice_line, qty_factor)
             logs += invl_logs
 
         return logs
 
-    def _import_fill_invoice_line_form(self, journal, tree, invoice, invoice_line, qty_factor):
+    def _import_fill_invoice_line_form(self, tree, invoice_line, qty_factor):
         logs = []
 
         # Product
         product = self._import_retrieve_info_from_map(
             tree,
-            self._import_retrieve_product_map(journal),
+            self._import_retrieve_product_map(invoice_line.move_id.journal_id),
         )
         if product is not None:
             invoice_line.product_id = product
@@ -588,7 +585,7 @@ class AccountEdiXmlUBL20(models.AbstractModel):
             'gross_price_unit': './{*}Price/{*}AllowanceCharge/{*}BaseAmount',
             'rebate': './{*}Price/{*}AllowanceCharge/{*}Amount',
             'net_price_unit': './{*}Price/{*}PriceAmount',
-            'billed_qty':  './{*}InvoicedQuantity' if invoice.move_type in ('in_invoice', 'out_invoice') or qty_factor == -1 else './{*}CreditedQuantity',
+            'billed_qty':  './{*}InvoicedQuantity' if invoice_line.move_id.move_type in ('in_invoice', 'out_invoice') or qty_factor == -1 else './{*}CreditedQuantity',
             'allowance_charge': './/{*}AllowanceCharge',
             'allowance_charge_indicator': './{*}ChargeIndicator',  # below allowance_charge node
             'allowance_charge_amount': './{*}Amount',  # below allowance_charge node
@@ -603,7 +600,7 @@ class AccountEdiXmlUBL20(models.AbstractModel):
         if not tax_nodes:
             for elem in tree.findall('.//{*}TaxTotal'):
                 tax_nodes += elem.findall('.//{*}TaxSubtotal/{*}Percent')
-        return self._import_fill_invoice_line_taxes(journal, tax_nodes, invoice_line, inv_line_vals, logs)
+        return self._import_fill_invoice_line_taxes(tax_nodes, invoice_line, inv_line_vals, logs)
 
     def _correct_invoice_tax_amount(self, tree, invoice):
         """ The tax total may have been modified for rounding purpose, if so we should use the imported tax and not
@@ -631,7 +628,7 @@ class AccountEdiXmlUBL20(models.AbstractModel):
     # IMPORT : helpers
     # -------------------------------------------------------------------------
 
-    def _get_import_document_amount_sign(self, filename, tree):
+    def _get_import_document_amount_sign(self, tree):
         """
         In UBL, an invoice has tag 'Invoice' and a credit note has tag 'CreditNote'. However, a credit note can be
         expressed as an invoice with negative amounts. For this case, we need a factor to take the opposite
@@ -646,35 +643,23 @@ class AccountEdiXmlUBL20(models.AbstractModel):
             return 'refund', 1
         return None, None
 
-    def _import_retrieve_partner_map(self, company, move_type='purchase'):
-        role = "Customer" if move_type == 'sale' else "Supplier"
-
-        def with_vat(tree, extra_domain):
-            vat_node = tree.find(f'.//{{*}}Accounting{role}Party/{{*}}Party//{{*}}CompanyID')
-            vat = None if vat_node is None else vat_node.text
-            return self.env['account.edi.format']._retrieve_partner_with_vat(vat, extra_domain)
-
-        def with_phone_mail(tree, extra_domain):
-            phone_node = tree.find(f'.//{{*}}Accounting{role}Party/{{*}}Party//{{*}}Telephone')
-            mail_node = tree.find(f'.//{{*}}Accounting{role}Party/{{*}}Party//{{*}}ElectronicMail')
-
-            phone = None if phone_node is None else phone_node.text
-            mail = None if mail_node is None else mail_node.text
-            return self.env['account.edi.format']._retrieve_partner_with_phone_mail(phone, mail, extra_domain)
-
-        def with_name(tree, extra_domain):
-            name_node = tree.find(f'.//{{*}}Accounting{role}Party/{{*}}Party//{{*}}Name')
-            name = None if name_node is None else name_node.text
-            return self.env['account.edi.format']._retrieve_partner_with_name(name, extra_domain)
-
-        return {
-            10: lambda tree: with_vat(tree, [('company_id', '=', company.id)]),
-            20: lambda tree: with_vat(tree, []),
-            30: lambda tree: with_phone_mail(tree, [('company_id', '=', company.id)]),
-            40: lambda tree: with_phone_mail(tree, []),
-            50: lambda tree: with_name(tree, [('company_id', '=', company.id)]),
-            60: lambda tree: with_name(tree, []),
-        }
+    def _import_retrieve_partner(self, tree, invoice):
+        role = "Customer" if invoice.journal_id.type == 'sale' else "Supplier"
+        vat_node = tree.find(f'.//{{*}}Accounting{role}Party/{{*}}Party//{{*}}CompanyID')
+        vat = None if vat_node is None else vat_node.text
+        phone_node = tree.find(f'.//{{*}}Accounting{role}Party/{{*}}Party//{{*}}Telephone')
+        phone = None if phone_node is None else phone_node.text
+        mail_node = tree.find(f'.//{{*}}Accounting{role}Party/{{*}}Party//{{*}}ElectronicMail')
+        mail = None if mail_node is None else mail_node.text
+        name_node = tree.find(f'.//{{*}}Accounting{role}Party/{{*}}Party//{{*}}Name')
+        name = None if name_node is None else name_node.text
+        return self.env['res.partner']._retrieve_partner(
+            name=name,
+            phone=phone,
+            mail=mail,
+            vat=vat,
+            company=invoice.company_id,
+        )
 
     def _import_retrieve_product_map(self, company):
 

--- a/None
+++ b/addons/account_edi_ubl_cii/models/account_journal.py
@@ -0,0 +1,43 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from odoo import api, models, fields
+from odoo.addons.account_edi_ubl_cii.models.account_edi_common import COUNTRY_EAS
+
+
+class AccountJournal(models.Model):
+    _inherit = 'account.journal'
+
+    checkbox_cii_xml = fields.Boolean(string='CII Billing', default=False)
+    can_enable_cii_xml = fields.Boolean(compute='_compute_can_enable_ubl_cii_xml')
+
+    checkbox_ubl_xml = fields.Boolean(string='BIS Billing', default=False)
+    can_enable_ubl_xml = fields.Boolean(compute='_compute_can_enable_ubl_cii_xml')
+
+    @api.depends('type', 'company_id')
+    def _compute_can_enable_ubl_cii_xml(self):
+        for journal in self:
+            is_ubl_country = bool(journal._get_ubl_builder())
+            is_cii_country = bool(journal._get_cii_builder())
+            journal.can_enable_ubl_xml = journal.type == 'sale' and is_ubl_country
+            journal.can_enable_cii_xml = journal.type == 'sale' and is_cii_country
+
+    def _get_cii_builder(self):
+        self.ensure_one()
+
+        if self.country_code == 'FR':
+            return self.env['account.edi.xml.cii'], {'facturx_pdfa': True}
+        if self.country_code == 'DE':
+            return self.env['account.edi.xml.cii'], {'facturx_pdfa': True}
+
+    def _get_ubl_builder(self):
+        self.ensure_one()
+
+        if self.country_code == 'DE':
+            return self.env['account.edi.xml.ubl_de'], {}
+        if self.country_code in ('AU', 'NZ'):
+            return self.env['account.edi.xml.ubl_a_nz'], {}
+        if self.country_code == 'NL':
+            return self.env['account.edi.xml.ubl_nl'], {}
+        if self.country_code in COUNTRY_EAS:
+            return self.env['account.edi.xml.ubl_bis3'], {}

--- a/None
+++ b/addons/account_edi_ubl_cii/models/account_move.py
@@ -0,0 +1,62 @@
+# -*- coding: utf-8 -*-
+from odoo import api, fields, models
+
+
+class AccountMove(models.Model):
+    _inherit = 'account.move'
+
+    ubl_xml_id = fields.Many2one(
+        comodel_name='ir.attachment',
+        string="UBL Attachment",
+        compute=lambda self: self._compute_linked_attachment_id('ubl_xml_id', 'ubl_xml_file'),
+        depends=['ubl_xml_file']
+    )
+    ubl_xml_file = fields.Binary(
+        attachment=True,
+        string="UBL File",
+        copy=False,
+    )
+
+    cii_xml_id = fields.Many2one(
+        comodel_name='ir.attachment',
+        string="CII Attachment",
+        compute=lambda self: self._compute_linked_attachment_id('cii_xml_id', 'cii_xml_file'),
+        depends=['cii_xml_file']
+    )
+    cii_xml_file = fields.Binary(
+        comodel_name='ir.attachment',
+        string="CII File",
+        copy=False,
+    )
+
+    # -------------------------------------------------------------------------
+    # EDI
+    # -------------------------------------------------------------------------
+
+    @api.model
+    def _get_ubl_cii_builder_from_xml_tree(self, tree):
+        customization_id = tree.find('{*}CustomizationID')
+        if tree.tag == '{urn:un:unece:uncefact:data:standard:CrossIndustryInvoice:100}CrossIndustryInvoice':
+            return self.env['account.edi.xml.cii']
+        if customization_id is not None:
+            if 'xrechnung' in customization_id.text:
+                return self.env['account.edi.xml.ubl_de']
+            if customization_id.text == 'urn:cen.eu:en16931:2017#compliant#urn:fdc:peppol.eu:2017:poacc:billing:3.0':
+                return self.env['account.edi.xml.ubl_bis3']
+            if customization_id.text == 'urn:cen.eu:en16931:2017#compliant#urn:fdc:nen.nl:nlcius:v1.0':
+                return self.env['account.edi.xml.ubl_nl']
+        ubl_version = tree.find('{*}UBLVersionID')
+        if ubl_version is not None:
+            if ubl_version.text == '2.0':
+                return self.env['account.edi.xml.ubl_20']
+            if ubl_version.text == '2.1':
+                return self.env['account.edi.xml.ubl_21']
+
+    def _get_edi_decoder(self, file_data, new=False):
+        # EXTENDS 'account'
+        if file_data['type'] == 'xml':
+            ubl_cii_xml_builder = self._get_ubl_cii_builder_from_xml_tree(file_data['xml_tree'])
+            if ubl_cii_xml_builder is not None:
+                return ubl_cii_xml_builder._import_invoice_ubl_cii
+
+        return super()._get_edi_decoder(file_data, new=new)

--- a/None
+++ b/addons/account_edi_ubl_cii/models/account_move_send.py
@@ -0,0 +1,247 @@
+# -*- coding: utf-8 -*-
+import base64
+import logging
+import io
+
+from lxml import etree
+from xml.sax.saxutils import escape, quoteattr
+
+from odoo import _, api, fields, models, tools
+from odoo.tools import cleanup_xml_node
+from odoo.tools.pdf import OdooPdfFileReader, OdooPdfFileWriter
+
+_logger = logging.getLogger(__name__)
+
+
+class AccountMoveSend(models.Model):
+    _inherit = 'account.move.send'
+
+    enable_ubl_xml = fields.Boolean(compute='_compute_send_mail_extra_fields')
+    checkbox_ubl_xml = fields.Boolean(
+        string="BIS Billing",
+        compute='_compute_checkbox_ubl_xml',
+        store=True,
+        readonly=False,
+    )
+
+    enable_cii_xml = fields.Boolean(compute='_compute_send_mail_extra_fields')
+    checkbox_cii_xml = fields.Boolean(
+        string="CII Billing",
+        compute='_compute_checkbox_cii_xml',
+        store=True,
+        readonly=False,
+    )
+
+    @api.model
+    def _get_default_enable_cii_xml(self, move):
+        return move.journal_id._get_cii_builder() and\
+                not move.invoice_pdf_report_id and\
+                move.journal_id.checkbox_cii_xml
+
+    @api.model
+    def _get_default_enable_ubl_xml(self, move):
+        return move.journal_id._get_ubl_builder() and\
+                not move.invoice_pdf_report_id and\
+                move.journal_id.checkbox_ubl_xml
+
+    # -------------------------------------------------------------------------
+    # COMPUTE METHODS
+    # -------------------------------------------------------------------------
+
+    def _compute_send_mail_extra_fields(self):
+        # EXTENDS 'account'
+        super()._compute_send_mail_extra_fields()
+        for wizard in self:
+            wizard.enable_ubl_xml = any([self._get_default_enable_ubl_xml(m) for m in wizard.move_ids])
+            wizard.enable_cii_xml = any([self._get_default_enable_cii_xml(m) for m in wizard.move_ids])
+
+    @api.depends('checkbox_ubl_xml', 'checkbox_cii_xml')
+    def _compute_mail_attachments_widget(self):
+        # EXTENDS 'account' - add depends
+        super()._compute_mail_attachments_widget()
+
+    @api.depends('enable_cii_xml')
+    def _compute_checkbox_cii_xml(self):
+        for wizard in self:
+            wizard.checkbox_cii_xml = True
+
+    @api.depends('enable_ubl_xml')
+    def _compute_checkbox_ubl_xml(self):
+        for wizard in self:
+            wizard.checkbox_ubl_xml = True
+
+    # -------------------------------------------------------------------------
+    # ATTACHMENTS
+    # -------------------------------------------------------------------------
+
+    @api.model
+    def _get_linked_attachments(self, move):
+        # EXTENDS 'account'
+        return super()._get_linked_attachments(move) + move.cii_xml_id + move.ubl_xml_id
+
+    def _get_placeholder_mail_attachments_data(self, move):
+        # EXTENDS 'account'
+        results = super()._get_placeholder_mail_attachments_data(move)
+
+        if self.enable_ubl_xml and self.checkbox_ubl_xml:
+            builder, _options = move.journal_id._get_ubl_builder()
+            filename = builder._export_invoice_filename(move)
+            results.append({
+                'id': f'placeholder_{filename}',
+                'name': filename,
+                'mimetype': 'application/xml',
+                'placeholder': True,
+            })
+
+        return results
+
+    # -------------------------------------------------------------------------
+    # BUSINESS ACTIONS
+    # -------------------------------------------------------------------------
+
+    def _prepare_document(self, invoice):
+        # EXTENDS 'account'
+        results = super()._prepare_document(invoice)
+
+        xmls_to_prepare = []
+
+        # CII
+        cii_xml = self.checkbox_cii_xml and self._get_default_enable_cii_xml(invoice)
+        if cii_xml:
+            builder, options = invoice.journal_id._get_cii_builder()
+        else:
+            # Default XML acting as the default EDI for ODOO hidden from the users (facturx).
+            builder, options = self.env['account.edi.xml.cii'], {'skip_errors': True}
+
+        xmls_to_prepare.append(('cii', builder, options))
+
+        # UBL
+        ubl_xml = self.checkbox_ubl_xml and self._get_default_enable_ubl_xml(invoice)
+        if ubl_xml:
+            builder, options = invoice.journal_id._get_ubl_builder()
+            xmls_to_prepare.append(('ubl', builder, options))
+
+        for edi_type, builder, options in xmls_to_prepare:
+            xml_content, errors = builder._export_invoice(invoice)
+            filename = builder._export_invoice_filename(invoice)
+
+            # Failed.
+            if errors and not options.get('skip_errors'):
+                return {
+                    'error': "".join([
+                        _("Errors occur while creating the EDI document (format: %s):", builder._description),
+                        "\n",
+                        "<p><li>" + "</li><li>".join(errors) + "</li></p>" if self.mode == 'invoice_multi' \
+                            else "\n".join(errors)
+                    ]),
+                }
+
+            results[f'{edi_type}_xml_attachment_values'] = {
+                'name': filename,
+                'raw': xml_content,
+                'mimetype': 'application/xml',
+                'res_model': invoice._name,
+                'res_id': invoice.id,
+                'res_field': f'{edi_type}_xml_file', # Binary field
+            }
+            results[f'{edi_type}_xml_options'] = {
+                'builder': builder,
+                'options': options,
+            }
+
+        return results
+
+    def _postprocess_document(self, invoice, prepared_data):
+        # EXTENDS 'account'
+        super()._postprocess_document(invoice, prepared_data)
+
+        cii_xml = prepared_data.get('cii_xml_attachment_values')
+        ubl_xml = prepared_data.get('ubl_xml_attachment_values')
+
+        # Add PDF to XML
+        if ubl_xml:
+            self._postprocess_invoice_ubl_xml(invoice, prepared_data)
+
+        # Add XML to PDF (for all -> inter-portability)
+        if tools.config['test_enable']: # during tests, no wkhtmltopdf:
+            return
+
+        # Read pdf content.
+        reader_buffer = io.BytesIO(prepared_data['pdf_attachment_values']['raw'])
+        reader = OdooPdfFileReader(reader_buffer, strict=False)
+
+        # Post-process.
+        writer = OdooPdfFileWriter()
+        writer.cloneReaderDocumentRoot(reader)
+
+        writer.addAttachment(cii_xml['name'], cii_xml['raw'], subtype='text/xml')
+
+        # PDF-A.
+        options = prepared_data['cii_xml_options']['options']
+        if options.get('facturx_pdfa') and not writer.is_pdfa:
+            try:
+                writer.convert_to_pdfa()
+            except Exception as e:
+                _logger.exception("Error while converting to PDF/A: %s", e)
+
+            # Extra metadata to be Factur-x PDF-A compliant.
+            content = self.env['ir.qweb']._render(
+                'account_edi_ubl_cii.account_invoice_pdfa_3_facturx_metadata',
+                {
+                    'title': invoice.name,
+                    'date': fields.Date.context_today(self),
+                },
+            )
+            writer.add_file_metadata(content.encode())
+
+        # Replace the current content.
+        writer_buffer = io.BytesIO()
+        writer.write(writer_buffer)
+        prepared_data['pdf_attachment_values']['raw'] = writer_buffer.getvalue()
+        reader_buffer.close()
+        writer_buffer.close()
+
+    def _postprocess_invoice_ubl_xml(self, invoice, prepared_data):
+        # Add PDF to XML
+        tree = etree.fromstring(prepared_data['ubl_xml_attachment_values']['raw'])
+        anchor_elements = tree.xpath("//*[local-name()='AccountingSupplierParty']")
+        if not anchor_elements:
+            return
+
+        filename = prepared_data['pdf_attachment_values']['name']
+        content = prepared_data['pdf_attachment_values']['raw']
+        to_inject = f'''
+            <cac:AdditionalDocumentReference
+                xmlns="urn:oasis:names:specification:ubl:schema:xsd:Invoice-2"
+                xmlns:cbc="urn:oasis:names:specification:ubl:schema:xsd:CommonBasicComponents-2"
+                xmlns:cac="urn:oasis:names:specification:ubl:schema:xsd:CommonAggregateComponents-2">
+                <cbc:ID>{escape(filename)}</cbc:ID>
+                <cac:Attachment>
+                    <cbc:EmbeddedDocumentBinaryObject
+                        mimeCode="application/pdf"
+                        filename={quoteattr(filename)}>
+                        {base64.b64encode(content).decode()}
+                    </cbc:EmbeddedDocumentBinaryObject>
+                </cac:Attachment>
+            </cac:AdditionalDocumentReference>
+        '''
+
+        anchor_index = tree.index(anchor_elements[0])
+        tree.insert(anchor_index, etree.fromstring(to_inject))
+        prepared_data['ubl_xml_attachment_values']['raw'] = b"<?xml version='1.0' encoding='UTF-8'?>\n" \
+            + etree.tostring(cleanup_xml_node(tree))
+
+    def _link_document(self, invoice, prepared_data):
+        # EXTENDS 'account'
+        super()._link_document(invoice, prepared_data)
+
+        ubl_attachment_vals = prepared_data.get('ubl_xml_attachment_values')
+        if ubl_attachment_vals:
+            self.env['ir.attachment'].create(ubl_attachment_vals)
+            invoice.invalidate_model(fnames=['ubl_xml_id', 'ubl_xml_file'])
+
+        # during tests, no wkhtmltopdf, but we want to check CII xml
+        if tools.config['test_enable']:
+            cii_attachment_vals = prepared_data.get('cii_xml_attachment_values')
+            self.env['ir.attachment'].create(cii_attachment_vals)
+            invoice.invalidate_model(fnames=['cii_xml_id', 'cii_xml_file'])

--- a/addons/account_edi_ubl_cii/models/ir_actions_report.py
+++ b/None
@@ -1,102 +0,0 @@
-# -*- coding: utf-8 -*-
-# Part of Odoo. See LICENSE file for full copyright and licensing details.
-
-from odoo import models
-from odoo.tools import cleanup_xml_node
-from odoo.tools.pdf import OdooPdfFileReader, OdooPdfFileWriter
-
-from lxml import etree
-import base64
-from xml.sax.saxutils import escape, quoteattr
-import io
-
-
-class IrActionsReport(models.Model):
-    _inherit = 'ir.actions.report'
-
-    def _add_pdf_into_invoice_xml(self, invoice, stream_data):
-        format_codes = ['ubl_bis3', 'ubl_de', 'nlcius_1', 'efff_1']
-        edi_attachments = invoice.edi_document_ids.filtered(lambda d: d.edi_format_id.code in format_codes).sudo().attachment_id
-        for edi_attachment in edi_attachments:
-            old_xml = base64.b64decode(edi_attachment.with_context(bin_size=False).datas, validate=True)
-            tree = etree.fromstring(old_xml)
-            anchor_elements = tree.xpath("//*[local-name()='AccountingSupplierParty']")
-            additional_document_elements = tree.xpath("//*[local-name()='AdditionalDocumentReference']")
-            # with this clause, we ensure the xml are only postprocessed once (even when the invoice is reset to
-            # draft then validated again)
-            if anchor_elements and not additional_document_elements:
-                pdf_stream = stream_data['stream']
-                pdf_content_b64 = base64.b64encode(pdf_stream.getvalue()).decode()
-                pdf_name = '%s.pdf' % invoice.name.replace('/', '_')
-                to_inject = '''
-                    <cac:AdditionalDocumentReference
-                        xmlns="urn:oasis:names:specification:ubl:schema:xsd:Invoice-2"
-                        xmlns:cbc="urn:oasis:names:specification:ubl:schema:xsd:CommonBasicComponents-2"
-                        xmlns:cac="urn:oasis:names:specification:ubl:schema:xsd:CommonAggregateComponents-2">
-                        <cbc:ID>%s</cbc:ID>
-                        <cac:Attachment>
-                            <cbc:EmbeddedDocumentBinaryObject mimeCode="application/pdf" filename=%s>
-                                %s
-                            </cbc:EmbeddedDocumentBinaryObject>
-                        </cac:Attachment>
-                    </cac:AdditionalDocumentReference>
-                ''' % (escape(pdf_name), quoteattr(pdf_name), pdf_content_b64)
-
-                anchor_index = tree.index(anchor_elements[0])
-                tree.insert(anchor_index, etree.fromstring(to_inject))
-                new_xml = etree.tostring(cleanup_xml_node(tree))
-                edi_attachment.sudo().write({
-                    'res_model': 'account.move',
-                    'res_id': invoice.id,
-                    'datas': base64.b64encode(new_xml),
-                    'mimetype': 'application/xml',
-                })
-
-    def _render_qweb_pdf_prepare_streams(self, report_ref, data, res_ids=None):
-        # EXTENDS base
-        # Add the pdf report in the XML as base64 string.
-        collected_streams = super()._render_qweb_pdf_prepare_streams(report_ref, data, res_ids=res_ids)
-
-        if collected_streams \
-                and res_ids \
-                and self._get_report(report_ref).report_name in ('account.report_invoice_with_payments', 'account.report_invoice'):
-            for res_id, stream_data in collected_streams.items():
-                invoice = self.env['account.move'].browse(res_id)
-                self._add_pdf_into_invoice_xml(invoice, stream_data)
-
-            # If Factur-X isn't already generated, generate and embed it inside the PDF
-            if len(res_ids) == 1:
-                invoice = self.env['account.move'].browse(res_ids)
-                edi_doc_codes = invoice.edi_document_ids.edi_format_id.mapped('code')
-                # If Factur-X hasn't been generated, generate and embed it anyway
-                if invoice.is_sale_document() \
-                        and invoice.state == 'posted' \
-                        and 'facturx_1_0_05' not in edi_doc_codes \
-                        and self.env.ref('account_edi_ubl_cii.edi_facturx_1_0_05', raise_if_not_found=False):
-                    # Add the attachments to the pdf file
-                    pdf_stream = collected_streams[invoice.id]['stream']
-
-                    # Read pdf content.
-                    pdf_content = pdf_stream.getvalue()
-                    reader_buffer = io.BytesIO(pdf_content)
-                    reader = OdooPdfFileReader(reader_buffer, strict=False)
-
-                    # Post-process and embed the additional files.
-                    writer = OdooPdfFileWriter()
-                    writer.cloneReaderDocumentRoot(reader)
-
-                    # Generate and embed Factur-X
-                    xml_content, _errors = self.env['account.edi.xml.cii']._export_invoice(invoice)
-                    writer.addAttachment(
-                        name=self.env['account.edi.xml.cii']._export_invoice_filename(invoice),
-                        data=xml_content,
-                        subtype='text/xml',
-                    )
-
-                    # Replace the current content.
-                    pdf_stream.close()
-                    new_pdf_stream = io.BytesIO()
-                    writer.write(new_pdf_stream)
-                    collected_streams[invoice.id]['stream'] = new_pdf_stream
-
-        return collected_streams
