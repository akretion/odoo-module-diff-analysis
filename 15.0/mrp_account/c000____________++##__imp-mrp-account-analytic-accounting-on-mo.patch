PR: https://github.com/odoo/odoo/pull/

From: edacd76e21a7a353632a7abb0ce1ffd852209555
From: yhu-odoo
Date: 2021-08-27 16:40:49

Structural Changes: 8
Total Changes: 225

[IMP] mrp_account: analytic accounting on MO

Add analytic accounting for MO.

Post expense entries for:
  1. raw material cost (change with consumed)
  2. work center cost (change with real duration on work order)

Task-2469742
PR #68708

================================= pseudo patch: =================================

--- a/addons/mrp_account/models/__init__.py
+++ b/addons/mrp_account/models/__init__.py
@@ -1,6 +1,10 @@
 # -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from . import analytic_account
+from . import mrp_bom
 from . import mrp_workcenter
+from . import mrp_workorder
 from . import mrp_production
 from . import product
 from . import stock_move

--- a/None
+++ b/addons/mrp_account/models/mrp_bom.py
@@ -0,0 +1,10 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from odoo import fields, models
+
+class MrpBom(models.Model):
+    _inherit = 'mrp.bom'
+
+    analytic_account_id = fields.Many2one('account.analytic.account', 'Analytic Account', company_dependent=True,
+        help="Analytic account in which cost and revenue entries will take place for financial management of the manufacturing order.")

--- a/addons/mrp_account/models/mrp_production.py
+++ b/addons/mrp_account/models/mrp_production.py
@@ -3,7 +3,7 @@
 
 from ast import literal_eval
 
-from odoo import fields, models
+from odoo import api, fields, models
 from odoo.tools import float_is_zero, float_round
 
 
@@ -18,25 +18,68 @@ class MrpProduction(models.Model):
 
     extra_cost = fields.Float(copy=False, help='Extra cost per produced unit')
     show_valuation = fields.Boolean(compute='_compute_show_valuation')
+    analytic_account_id = fields.Many2one(
+        'account.analytic.account', 'Analytic Account', copy=True,
+        help="Analytic account in which cost and revenue entries will take\
+        place for financial management of the manufacturing order.",
+        compute='_compute_analytic_account_id', store=True, readonly=False)
 
     def _compute_show_valuation(self):
         for order in self:
             order.show_valuation = any(m.state == 'done' for m in order.move_finished_ids)
 
+    @api.depends('bom_id')
+    def _compute_analytic_account_id(self):
+        if self.bom_id.analytic_account_id:
+            self.analytic_account_id = self.bom_id.analytic_account_id
+
+    def write(self, vals):
+        res = super().write(vals)
+        if vals.get('name'):
+            for production in self:
+                production.move_raw_ids.analytic_account_line_id.ref = production.display_name
+                production.workorder_ids.mo_analytic_account_line_id.ref = production.display_name
+        return res
+
+    def action_view_stock_valuation_layers(self):
+        self.ensure_one()
+        domain = [('id', 'in', (self.move_raw_ids + self.move_finished_ids + self.scrap_ids.move_id).stock_valuation_layer_ids.ids)]
+        action = self.env["ir.actions.actions"]._for_xml_id("stock_account.stock_valuation_layer_action")
+        context = literal_eval(action['context'])
+        context.update(self.env.context)
+        context['no_at_date'] = True
+        context['search_default_group_by_product_id'] = False
+        return dict(action, domain=domain, context=context)
+
+    def action_view_analytic_account(self):
+        self.ensure_one()
+        return {
+            "type": "ir.actions.act_window",
+            "res_model": "account.analytic.account",
+            'res_id': self.analytic_account_id.id,
+            "context": {"create": False},
+            "name": "Analytic Account",
+            'view_mode': 'form',
+        }
+
     def _cal_price(self, consumed_moves):
         """Set a price unit on the finished move according to `consumed_moves`.
         """
         super(MrpProduction, self)._cal_price(consumed_moves)
         work_center_cost = 0
-        finished_move = self.move_finished_ids.filtered(lambda m: m.product_id == self.product_id and m.state not in ('done', 'cancel') and m.quantity_done > 0)
+        finished_move = self.move_finished_ids.filtered(
+            lambda x: x.product_id == self.product_id and x.state not in ('done', 'cancel') and x.quantity_done > 0)
         if finished_move:
             finished_move.ensure_one()
             for work_order in self.workorder_ids:
-                time_lines = work_order.time_ids.filtered(lambda x: x.date_end and not x.cost_already_recorded)
+                time_lines = work_order.time_ids.filtered(
+                    lambda x: x.date_end and not x.cost_already_recorded)
                 duration = sum(time_lines.mapped('duration'))
                 time_lines.write({'cost_already_recorded': True})
-                work_center_cost += (duration / 60.0) * work_order.workcenter_id.costs_hour
-            qty_done = finished_move.product_uom._compute_quantity(finished_move.quantity_done, finished_move.product_id.uom_id)
+                work_center_cost += (duration / 60.0) * \
+                    work_order.workcenter_id.costs_hour
+            qty_done = finished_move.product_uom._compute_quantity(
+                finished_move.quantity_done, finished_move.product_id.uom_id)
             extra_cost = self.extra_cost * qty_done
             total_cost = (sum(-m.stock_valuation_layer_ids.value for m in consumed_moves.sudo()) + work_center_cost + extra_cost)
             byproduct_moves = self.move_byproduct_ids.filtered(lambda m: m.state not in ('done', 'cancel') and m.quantity_done > 0)
@@ -51,51 +94,7 @@ class MrpProduction(models.Model):
                 finished_move.price_unit = total_cost * float_round(1 - byproduct_cost_share / 100, precision_rounding=0.0001) / qty_done
         return True
 
-    def _prepare_wc_analytic_line(self, wc_line):
-        wc = wc_line.workcenter_id
-        hours = wc_line.duration / 60.0
-        value = hours * wc.costs_hour
-        account = wc.costs_hour_account_id.id
-        return {
-            'name': wc_line.name + ' (H)',
-            'amount': -value,
-            'account_id': account,
-            'ref': wc.code,
-            'unit_amount': hours,
-            'company_id': self.company_id.id,
-        }
-
-    def _costs_generate(self):
-        """ Calculates total costs at the end of the production.
-        """
-        self.ensure_one()
-        AccountAnalyticLine = self.env['account.analytic.line'].sudo()
-        for wc_line in self.workorder_ids.filtered('workcenter_id.costs_hour_account_id'):
-            vals = self._prepare_wc_analytic_line(wc_line)
-            precision_rounding = (wc_line.workcenter_id.costs_hour_account_id.currency_id or self.company_id.currency_id).rounding
-            if not float_is_zero(vals.get('amount', 0.0), precision_rounding=precision_rounding):
-                # we use SUPERUSER_ID as we do not guarantee an mrp user
-                # has access to account analytic lines but still should be
-                # able to produce orders
-                AccountAnalyticLine.create(vals)
-
     def _get_backorder_mo_vals(self):
         res = super()._get_backorder_mo_vals()
         res['extra_cost'] = self.extra_cost
         return res
-
-    def button_mark_done(self):
-        res = super(MrpProduction, self).button_mark_done()
-        for order in self:
-            order._costs_generate()
-        return res
-
-    def action_view_stock_valuation_layers(self):
-        self.ensure_one()
-        domain = [('id', 'in', (self.move_raw_ids + self.move_finished_ids + self.scrap_ids.move_id).stock_valuation_layer_ids.ids)]
-        action = self.env["ir.actions.actions"]._for_xml_id("stock_account.stock_valuation_layer_action")
-        context = literal_eval(action['context'])
-        context.update(self.env.context)
-        context['no_at_date'] = True
-        context['search_default_group_by_product_id'] = False
-        return dict(action, domain=domain, context=context)

--- a/addons/mrp_account/models/mrp_workcenter.py
+++ b/addons/mrp_account/models/mrp_workcenter.py
@@ -7,5 +7,6 @@ from odoo import fields, models
 class MrpWorkcenter(models.Model):
     _inherit = 'mrp.workcenter'
 
-    costs_hour_account_id = fields.Many2one('account.analytic.account', string='Analytic Account',
-                                            help="Fill this only if you want automatic analytic accounting entries on production orders.")
+    costs_hour_account_id = fields.Many2one(
+        'account.analytic.account', string='Analytic Account',
+        help="Fill this only if you want automatic analytic accounting entries on production orders.")

--- a/None
+++ b/addons/mrp_account/models/mrp_workorder.py
@@ -0,0 +1,76 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from odoo import fields, models, _
+from odoo.tools import float_is_zero
+
+
+class MrpWorkorder(models.Model):
+    _inherit = 'mrp.workorder'
+
+    mo_analytic_account_line_id = fields.Many2one('account.analytic.line')
+    wc_analytic_account_line_id = fields.Many2one('account.analytic.line')
+
+    def _compute_duration(self):
+        res = super()._compute_duration()
+        self._create_or_update_analytic_entry()
+        return res
+
+    def _set_duration(self):
+        res = super()._set_duration()
+        self._create_or_update_analytic_entry()
+        return res
+
+    def action_cancel(self):
+        (self.mo_analytic_account_line_id | self.wc_analytic_account_line_id).unlink()
+        return super().action_cancel()
+
+    def _prepare_analytic_line_values(self, account, unit_amount, amount):
+        self.ensure_one()
+        return {
+            'name': _("[WC] %s", self.display_name),
+            'amount': amount,
+            'account_id': account.id,
+            'unit_amount': unit_amount,
+            'product_id': self.product_id.id,
+            'product_uom_id': self.product_id.uom_id.id,
+            'company_id': self.company_id.id,
+            'ref': self.production_id.name,
+        }
+
+    def _create_or_update_analytic_entry(self):
+        wo_to_link_mo_analytic_line = self.env['mrp.workorder']
+        wo_to_link_wc_analytic_line = self.env['mrp.workorder']
+        mo_analytic_line_vals_list = []
+        wc_analytic_line_vals_list = []
+        for wo in self.filtered(lambda wo: wo.production_id.analytic_account_id or wo.workcenter_id.costs_hour_account_id):
+            hours = wo.duration / 60.0
+            value = -hours * wo.workcenter_id.costs_hour
+            mo_account = wo.production_id.analytic_account_id
+            wc_account = wo.workcenter_id.costs_hour_account_id
+            if mo_account:
+                is_zero = float_is_zero(value, precision_rounding=mo_account.currency_id.rounding)
+                if wo.mo_analytic_account_line_id:
+                    wo.mo_analytic_account_line_id.write({
+                        'unit_amount': hours,
+                        'amount': value if not is_zero else 0,
+                    })
+                elif not is_zero:
+                    wo_to_link_mo_analytic_line += wo
+                    mo_analytic_line_vals_list.append(wo._prepare_analytic_line_values(mo_account, hours, value))
+            if wc_account and wc_account != mo_account:
+                is_zero = float_is_zero(value, precision_rounding=wc_account.currency_id.rounding)
+                if wo.wc_analytic_account_line_id:
+                    wo.wc_analytic_account_line_id.write({
+                        'unit_amount': hours,
+                        'amount': value if not is_zero else 0,
+                    })
+                elif not is_zero:
+                    wo_to_link_wc_analytic_line += wo
+                    wc_analytic_line_vals_list.append(wo._prepare_analytic_line_values(wc_account, hours, value))
+        analytic_lines = self.env['account.analytic.line'].sudo().create(mo_analytic_line_vals_list + wc_analytic_line_vals_list)
+        mo_analytic_lines, wc_analytic_lines = analytic_lines[:len(wo_to_link_mo_analytic_line)], analytic_lines[len(wo_to_link_mo_analytic_line):]
+        for wo, analytic_line in zip(wo_to_link_mo_analytic_line, mo_analytic_lines):
+            wo.mo_analytic_account_line_id = analytic_line
+        for wo, analytic_line in zip(wo_to_link_wc_analytic_line, wc_analytic_lines):
+            wo.wc_analytic_account_line_id = analytic_line

--- a/addons/mrp_account/models/stock_move.py
+++ b/addons/mrp_account/models/stock_move.py
@@ -1,15 +1,30 @@
 # -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
-from odoo import api, fields, models, _
+
+from odoo import _, models
 
 
 class StockMove(models.Model):
     _inherit = "stock.move"
 
-    def _is_returned(self, valued_type):
-        if self.unbuild_id:
-            return True
-        return super()._is_returned(valued_type)
+    def _filter_anglo_saxon_moves(self, product):
+        res = super(StockMove, self)._filter_anglo_saxon_moves(product)
+        res += self.filtered(lambda m: m.bom_line_id.bom_id.product_tmpl_id.id == product.product_tmpl_id.id)
+        return res
+
+    def _generate_analytic_lines_data(self, unit_amount, amount):
+        vals = super()._generate_analytic_lines_data(unit_amount, amount)
+        if self.raw_material_production_id.analytic_account_id:
+            vals['name'] = _('[Raw] %s', self.product_id.display_name)
+            vals['ref'] = self.raw_material_production_id.display_name
+            vals['category'] = 'manufacturing_order'
+        return vals
+
+    def _get_analytic_account(self):
+        account = self.raw_material_production_id.analytic_account_id
+        if account:
+            return account
+        return super()._get_analytic_account()
 
     def _get_src_account(self, accounts_data):
         if not self.unbuild_id:
@@ -23,7 +38,7 @@ class StockMove(models.Model):
         else:
             return self.location_id.valuation_in_account_id.id or accounts_data['stock_output'].id
 
-    def _filter_anglo_saxon_moves(self, product):
-        res = super(StockMove, self)._filter_anglo_saxon_moves(product)
-        res += self.filtered(lambda m: m.bom_line_id.bom_id.product_tmpl_id.id == product.product_tmpl_id.id)
-        return res
+    def _is_returned(self, valued_type):
+        if self.unbuild_id:
+            return True
+        return super()._is_returned(valued_type)
