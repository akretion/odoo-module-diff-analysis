PR: https://github.com/odoo/odoo/pull/29634

From: a3daff6bc121a42bf293ca91b8f522c26bac7c8a
From: jbm-odoo
Date: 2019-01-21 11:29:30

Structural Changes: 38
Total Changes: 240

[IMP] hr_holidays: Rename 'leave' into 'time off' + add dashboard

Purpose
=======

We need to use an international word to define holidays and leaves, rename everything into Time Off.
Employees needs a good dashboard and leaves summary

Specification
=============

1/ Add a new dashboard: https://balsamiq.cloud/sm5j0d/pg5w04r
   Create a new dashboard with a calendar and a summary of all time off and time off request
2/ Rename leaves into Time Off everywhere
3/ Improve general usability

TaskID: 1916871

closes odoo/odoo#29634

================================= pseudo patch: =================================

--- a/addons/hr_holidays/models/hr.py
+++ b/addons/hr_holidays/models/hr.py
@@ -16,7 +16,7 @@ class Department(models.Model):
     absence_of_today = fields.Integer(
         compute='_compute_leave_count', string='Absence by Today')
     leave_to_approve_count = fields.Integer(
-        compute='_compute_leave_count', string='Leave to Approve')
+        compute='_compute_leave_count', string='Time Off to Approve')
     allocation_to_approve_count = fields.Integer(
         compute='_compute_leave_count', string='Allocation to Approve')
     total_employee = fields.Integer(
@@ -64,14 +64,14 @@ class Employee(models.Model):
     _inherit = "hr.employee"
 
     leave_manager_id = fields.Many2one(
-        'res.users', string='Leave Responsible',
+        'res.users', string='Time Off Responsible',
         domain=lambda self: [('groups_id', 'in', self.env.ref('hr_holidays.group_hr_holidays_team_leader').id)],
-        help="User responsible of leaves approval. Should be Team Leader or Department Manager.")
+        help="User responsible of time off approval. Should be Team Leader or Department Manager.")
     remaining_leaves = fields.Float(
-        compute='_compute_remaining_leaves', string='Remaining Legal Leaves',
-        help='Total number of legal leaves allocated to this employee, change this value to create allocation/leave request. '
-             'Total based on all the leave types without overriding limit.')
-    current_leave_state = fields.Selection(compute='_compute_leave_status', string="Current Leave Status",
+        compute='_compute_remaining_leaves', string='Remaining Paid Time Off',
+        help='Total number of paid time off allocated to this employee, change this value to create allocation/time off request. '
+             'Total based on all the time off types without overriding limit.')
+    current_leave_state = fields.Selection(compute='_compute_leave_status', string="Current Time Off Status",
         selection=[
             ('draft', 'New'),
             ('confirm', 'Waiting Approval'),
@@ -80,11 +80,11 @@ class Employee(models.Model):
             ('validate', 'Approved'),
             ('cancel', 'Cancelled')
         ])
-    current_leave_id = fields.Many2one('hr.leave.type', compute='_compute_leave_status', string="Current Leave Type")
+    current_leave_id = fields.Many2one('hr.leave.type', compute='_compute_leave_status', string="Current Time Off Type")
     leave_date_from = fields.Date('From Date', compute='_compute_leave_status')
     leave_date_to = fields.Date('To Date', compute='_compute_leave_status')
-    leaves_count = fields.Float('Number of Leaves', compute='_compute_remaining_leaves')
-    show_leaves = fields.Boolean('Able to see Remaining Leaves', compute='_compute_show_leaves')
+    leaves_count = fields.Float('Number of Time Off', compute='_compute_remaining_leaves')
+    show_leaves = fields.Boolean('Able to see Remaining Time Off', compute='_compute_show_leaves')
     is_absent_totay = fields.Boolean('Absent Today', compute='_compute_absent_employee', search='_search_absent_employee')
 
     def _get_remaining_leaves(self):

--- a/addons/hr_holidays/models/hr_leave.py
+++ b/addons/hr_holidays/models/hr_leave.py
@@ -57,7 +57,7 @@ class HolidaysRequest(models.Model):
     leave request leave type.
     """
     _name = "hr.leave"
-    _description = "Leave"
+    _description = "Time Off"
     _order = "date_from desc"
     _inherit = ['mail.thread', 'mail.activity.mixin']
     _mail_post_access = 'read'
@@ -105,16 +105,16 @@ class HolidaysRequest(models.Model):
         ('validate1', 'Second Approval'),
         ('validate', 'Approved')
         ], string='Status', readonly=True, tracking=True, copy=False, default='confirm',
-        help="The status is set to 'To Submit', when a leave request is created." +
-        "\nThe status is 'To Approve', when leave request is confirmed by user." +
-        "\nThe status is 'Refused', when leave request is refused by manager." +
-        "\nThe status is 'Approved', when leave request is approved by manager.")
-    payslip_status = fields.Boolean('Reported in last payslips', help='Green this button when the leave has been taken into account in the payslip.')
+        help="The status is set to 'To Submit', when a time off request is created." +
+        "\nThe status is 'To Approve', when time off request is confirmed by user." +
+        "\nThe status is 'Refused', when time off request is refused by manager." +
+        "\nThe status is 'Approved', when time off request is approved by manager.")
+    payslip_status = fields.Boolean('Reported in last payslips', help='Green this button when the time off has been taken into account in the payslip.')
     report_note = fields.Text('HR Comments')
     user_id = fields.Many2one('res.users', string='User', related='employee_id.user_id', related_sudo=True, store=True, default=lambda self: self.env.uid, readonly=True)
     # leave type configuration
     holiday_status_id = fields.Many2one(
-        "hr.leave.type", string="Leave Type", required=True, readonly=True,
+        "hr.leave.type", string="Time Off Type", required=True, readonly=True,
         states={'draft': [('readonly', False)], 'confirm': [('readonly', False)]},
         domain=[('valid', '=', True)])
     leave_type_request_unit = fields.Selection(related='holiday_status_id.request_unit', readonly=True)
@@ -140,13 +140,13 @@ class HolidaysRequest(models.Model):
     number_of_days = fields.Float(
         'Duration (Days)', copy=False, readonly=True, tracking=True,
         states={'draft': [('readonly', False)], 'confirm': [('readonly', False)]},
-        help='Number of days of the leave request according to your working schedule.')
+        help='Number of days of the time off request. Used in the calculation. To manually correct the duration, use this field.')
     number_of_days_display = fields.Float(
         'Duration in days', compute='_compute_number_of_days_display', copy=False, readonly=True,
-        help='Number of days of the leave request. Used for interface.')
+        help='Number of days of the time off request according to your working schedule. Used for interface.')
     number_of_hours_display = fields.Float(
         'Duration in hours', compute='_compute_number_of_hours_display', copy=False, readonly=True,
-        help='Number of hours of the leave request according to your working schedule. Used for interface.')
+        help='Number of hours of the time off request according to your working schedule. Used for interface.')
     # details
     meeting_id = fields.Many2one('calendar.event', string='Meeting')
     parent_id = fields.Many2one('hr.leave', string='Parent', copy=False)
@@ -167,10 +167,10 @@ class HolidaysRequest(models.Model):
         states={'draft': [('readonly', False)], 'confirm': [('readonly', False)]})
     first_approver_id = fields.Many2one(
         'hr.employee', string='First Approval', readonly=True, copy=False,
-        help='This area is automatically filled by the user who validate the leave', oldname='manager_id')
+        help='This area is automatically filled by the user who validate the time off', oldname='manager_id')
     second_approver_id = fields.Many2one(
         'hr.employee', string='Second Approval', readonly=True, copy=False, oldname='manager_id2',
-        help='This area is automaticly filled by the user who validate the leave with second level (If Leave type need second validation)')
+        help='This area is automaticly filled by the user who validate the time off with second level (If time off type need second validation)')
     can_reset = fields.Boolean('Can reset', compute='_compute_can_reset')
     can_approve = fields.Boolean('Can Approve', compute='_compute_can_approve')
 
@@ -301,6 +301,10 @@ class HolidaysRequest(models.Model):
         self.date_to = timezone(tz).localize(datetime.combine(self.request_date_to, hour_to)).astimezone(UTC).replace(tzinfo=None)
         self._onchange_leave_dates()
 
+    @api.onchange('holiday_status_id')
+    def _onchange_holiday_status_id(self):
+        self.request_unit_half = False
+
     @api.onchange('request_unit_half')
     def _onchange_request_unit_half(self):
         if self.request_unit_half:
@@ -408,7 +412,7 @@ class HolidaysRequest(models.Model):
             ]
             nholidays = self.search_count(domain)
             if nholidays:
-                raise ValidationError(_('You can not have 2 leaves that overlaps on the same day.'))
+                raise ValidationError(_('You can not have 2 time off that overlaps on the same day.'))
 
     @api.constrains('state', 'number_of_days', 'holiday_status_id')
     def _check_holidays(self):
@@ -418,8 +422,8 @@ class HolidaysRequest(models.Model):
             leave_days = holiday.holiday_status_id.get_days(holiday.employee_id.id)[holiday.holiday_status_id.id]
             if float_compare(leave_days['remaining_leaves'], 0, precision_digits=2) == -1 or \
               float_compare(leave_days['virtual_remaining_leaves'], 0, precision_digits=2) == -1:
-                raise ValidationError(_('The number of remaining leaves is not sufficient for this leave type.\n'
-                                        'Please also check the leaves waiting for validation.'))
+                raise ValidationError(_('The number of remaining time off is not sufficient for this time off type.\n'
+                                        'Please also check the time off waiting for validation.'))
 
     def _get_number_of_days(self, date_from, date_to, employee_id):
         """ Returns a float equals to the timedelta between two dates given as string."""
@@ -497,7 +501,7 @@ class HolidaysRequest(models.Model):
         if leave_type.validation_type == 'no_validation':
             holiday.sudo().action_validate()
             holiday.message_subscribe(partner_ids=[holiday._get_responsible_for_approval().partner_id.id])
-            holiday.sudo().message_post(body=_("The leave has been automatically approved"), subtype="mt_comment") # Message from OdooBot (sudo)
+            holiday.sudo().message_post(body=_("The time off has been automatically approved"), subtype="mt_comment") # Message from OdooBot (sudo)
         holiday.activity_update()
         return holiday
 
@@ -536,7 +540,7 @@ class HolidaysRequest(models.Model):
     @api.multi
     def unlink(self):
         for holiday in self.filtered(lambda holiday: holiday.state not in ['draft', 'cancel', 'confirm']):
-            raise UserError(_('You cannot delete a leave which is in %s state.') % (holiday.state,))
+            raise UserError(_('You cannot delete a time off which is in %s state.') % (holiday.state,))
         return super(HolidaysRequest, self).unlink()
 
     @api.multi
@@ -549,7 +553,7 @@ class HolidaysRequest(models.Model):
 
     @api.multi
     def _create_resource_leave(self):
-        """ This method will create entry in resource calendar leave object at the time of holidays validated """
+        """ This method will create entry in resource calendar time off object at the time of holidays validated """
         for leave in self:
             date_from = fields.Datetime.from_string(leave.date_from)
             date_to = fields.Datetime.from_string(leave.date_to)
@@ -567,12 +571,12 @@ class HolidaysRequest(models.Model):
 
     @api.multi
     def _remove_resource_leave(self):
-        """ This method will create entry in resource calendar leave object at the time of holidays cancel/removed """
+        """ This method will create entry in resource calendar time off object at the time of holidays cancel/removed """
         return self.env['resource.calendar.leaves'].search([('holiday_id', 'in', self.ids)]).unlink()
 
     def _validate_leave_request(self):
-        """ Validate leave requests (holiday_type='employee')
-        by creating a calendar event and a resource leaves. """
+        """ Validate time off requests (holiday_type='employee')
+        by creating a calendar event and a resource time off. """
         for holiday in self.filtered(lambda request: request.holiday_type == 'employee'):
             meeting_values = holiday._prepare_holidays_meeting_values()
             meeting = self.env['calendar.event'].with_context(no_mail_to_attendees=True).create(meeting_values)
@@ -622,7 +626,7 @@ class HolidaysRequest(models.Model):
     def action_draft(self):
         for holiday in self:
             if holiday.state not in ['confirm', 'refuse']:
-                raise UserError(_('Leave request state must be "Refused" or "To Approve" in order to be reset to draft.'))
+                raise UserError(_('Time off request state must be "Refused" or "To Approve" in order to be reset to draft.'))
             holiday.write({
                 'state': 'draft',
                 'first_approver_id': False,
@@ -638,7 +642,7 @@ class HolidaysRequest(models.Model):
     @api.multi
     def action_confirm(self):
         if self.filtered(lambda holiday: holiday.state != 'draft'):
-            raise UserError(_('Leave request must be in Draft state ("To Submit") in order to confirm it.'))
+            raise UserError(_('Time off request must be in Draft state ("To Submit") in order to confirm it.'))
         self.write({'state': 'confirm'})
         self.activity_update()
         return True
@@ -648,7 +652,7 @@ class HolidaysRequest(models.Model):
         # if validation_type == 'both': this method is the first approval approval
         # if validation_type != 'both': this method calls action_validate() below
         if any(holiday.state != 'confirm' for holiday in self):
-            raise UserError(_('Leave request must be confirmed ("To Approve") in order to approve it.'))
+            raise UserError(_('Time off request must be confirmed ("To Approve") in order to approve it.'))
 
         current_employee = self.env['hr.employee'].search([('user_id', '=', self.env.uid)], limit=1)
         self.filtered(lambda hol: hol.validation_type == 'both').write({'state': 'validate1', 'first_approver_id': current_employee.id})
@@ -661,7 +665,7 @@ class HolidaysRequest(models.Model):
         current_employee = self.env['hr.employee'].search([('user_id', '=', self.env.uid)], limit=1)
         for holiday in self:
             if holiday.state not in ['confirm', 'validate1']:
-                raise UserError(_('Leave request must be confirmed in order to approve it.'))
+                raise UserError(_('Time off request must be confirmed in order to approve it.'))
 
             holiday.write({'state': 'validate'})
             if holiday.validation_type == 'both':
@@ -696,7 +700,7 @@ class HolidaysRequest(models.Model):
         current_employee = self.env['hr.employee'].search([('user_id', '=', self.env.uid)], limit=1)
         for holiday in self:
             if holiday.state not in ['confirm', 'validate', 'validate1']:
-                raise UserError(_('Leave request must be confirmed or validated in order to refuse it.'))
+                raise UserError(_('Time off request must be confirmed or validated in order to refuse it.'))
 
             if holiday.state == 'validate1':
                 holiday.write({'state': 'refuse', 'first_approver_id': current_employee.id})
@@ -723,27 +727,27 @@ class HolidaysRequest(models.Model):
 
             if state == 'draft':
                 if holiday.employee_id != current_employee and not is_manager:
-                    raise UserError(_('Only a Leave Manager can reset other people leaves.'))
+                    raise UserError(_('Only a Time Off Manager can reset other people time off.'))
                 continue
 
             if not is_team_leader:
-                raise UserError(_('Only a Team Leader, Leave Officer or Manager can approve or refuse leave requests.'))
+                raise UserError(_('Only a Team Leader, Time Off Officer or Manager can approve or refuse time off requests.'))
 
             if is_team_leader:
                 # use ir.rule based first access check: department, members, ... (see security.xml)
                 holiday.check_access_rule('write')
 
             if holiday.employee_id == current_employee and not is_manager:
-                raise UserError(_('Only a Leave Manager can approve its own requests.'))
+                raise UserError(_('Only a Time Off Manager can approve its own requests.'))
 
             if (state == 'validate1' and val_type == 'both') or (state == 'validate' and val_type == 'manager'):
                 manager = holiday.employee_id.parent_id or holiday.employee_id.department_id.manager_id
                 if (manager and manager != current_employee) and not self.env.user.has_group('hr_holidays.group_hr_holidays_manager'):
-                    raise UserError(_('You must be either %s\'s manager or Leave manager to approve this leave') % (holiday.employee_id.name))
+                    raise UserError(_('You must be either %s\'s manager or Time Off Manager to approve this time off') % (holiday.employee_id.name))
 
             if state == 'validate' and val_type == 'both':
                 if not self.env.user.has_group('hr_holidays.group_hr_holidays_manager'):
-                    raise UserError(_('Only an Leave Manager can apply the second approval on leave requests.'))
+                    raise UserError(_('Only an Time Off Manager can apply the second approval on time off requests.'))
 
     # ------------------------------------------------------------
     # Activity methods

--- a/addons/hr_holidays/models/hr_leave_allocation.py
+++ b/addons/hr_holidays/models/hr_leave_allocation.py
@@ -19,7 +19,7 @@ _logger = logging.getLogger(__name__)
 class HolidaysAllocation(models.Model):
     """ Allocation Requests Access specifications: similar to leave requests """
     _name = "hr.leave.allocation"
-    _description = "Leaves Allocation"
+    _description = "Time Off Allocation"
     _inherit = ['mail.thread', 'mail.activity.mixin']
     _mail_post_access = 'read'
 
@@ -30,7 +30,7 @@ class HolidaysAllocation(models.Model):
         if self.user_has_groups('hr_holidays.group_hr_holidays_user'):
             domain = [('valid', '=', True)]
         else:
-            domain = [('valid', '=', True), ('allocation_type', 'in', ('no', 'fixed_allocation'))]
+            domain = [('valid', '=', True), ('allocation_type', '=', 'fixed_allocation')]
         return self.env['hr.leave.type'].search(domain, limit=1)
 
     name = fields.Char('Description')
@@ -42,10 +42,10 @@ class HolidaysAllocation(models.Model):
         ('validate1', 'Second Approval'),
         ('validate', 'Approved')
         ], string='Status', readonly=True, tracking=True, copy=False, default='confirm',
-        help="The status is set to 'To Submit', when a leave request is created." +
-        "\nThe status is 'To Approve', when leave request is confirmed by user." +
-        "\nThe status is 'Refused', when leave request is refused by manager." +
-        "\nThe status is 'Approved', when leave request is approved by manager.")
+        help="The status is set to 'To Submit', when a time off request is created." +
+        "\nThe status is 'To Approve', when time off request is confirmed by user." +
+        "\nThe status is 'Refused', when time off request is refused by manager." +
+        "\nThe status is 'Approved', when time off request is approved by manager.")
     date_from = fields.Datetime(
         'Start Date', readonly=True, index=True, copy=False,
         states={'draft': [('readonly', False)], 'confirm': [('readonly', False)]}, tracking=True)
@@ -53,9 +53,9 @@ class HolidaysAllocation(models.Model):
         'End Date', readonly=True, copy=False,
         states={'draft': [('readonly', False)], 'confirm': [('readonly', False)]}, tracking=True)
     holiday_status_id = fields.Many2one(
-        "hr.leave.type", string="Leave Type", required=True, readonly=True,
+        "hr.leave.type", string="Time Off Type", required=True, readonly=True,
         states={'draft': [('readonly', False)], 'confirm': [('readonly', False)]},
-        domain=[('valid', '=', True)], default=_default_holiday_status_id)
+        domain=[('valid', '=', True), ('allocation_type', '!=', 'no')], default=_default_holiday_status_id)
     employee_id = fields.Many2one(
         'hr.employee', string='Employee', index=True, readonly=True,
         states={'draft': [('readonly', False)], 'confirm': [('readonly', False)]}, default=_default_employee, tracking=True)
@@ -63,7 +63,7 @@ class HolidaysAllocation(models.Model):
     notes = fields.Text('Reasons', readonly=True, states={'draft': [('readonly', False)], 'confirm': [('readonly', False)]})
     # duration
     number_of_days = fields.Float(
-        'Number of Days', tracking=True,
+        'Number of Days', tracking=True, default=1,
         help='Duration in days. Reference field to use when necessary.')
     number_of_days_display = fields.Float(
         'Duration (days)', compute='_compute_number_of_days_display',
@@ -77,10 +77,10 @@ class HolidaysAllocation(models.Model):
     linked_request_ids = fields.One2many('hr.leave.allocation', 'parent_id', string='Linked Requests')
     first_approver_id = fields.Many2one(
         'hr.employee', string='First Approval', readonly=True, copy=False,
-        help='This area is automatically filled by the user who validate the leave', oldname='manager_id')
+        help='This area is automatically filled by the user who validate the time off', oldname='manager_id')
     second_approver_id = fields.Many2one(
         'hr.employee', string='Second Approval', readonly=True, copy=False, oldname='manager_id2',
-        help='This area is automaticly filled by the user who validate the leave with second level (If Leave type need second validation)')
+        help='This area is automaticly filled by the user who validate the time off with second level (If time off type need second validation)')
     validation_type = fields.Selection('Validation Type', related='holiday_status_id.validation_type', readonly=True)
     can_reset = fields.Boolean('Can reset', compute='_compute_can_reset')
     can_approve = fields.Boolean('Can Approve', compute='_compute_can_approve')
@@ -357,12 +357,12 @@ class HolidaysAllocation(models.Model):
     @api.multi
     def unlink(self):
         for holiday in self.filtered(lambda holiday: holiday.state not in ['draft', 'cancel', 'confirm']):
-            raise UserError(_('You cannot delete a leave which is in %s state.') % (holiday.state,))
+            raise UserError(_('You cannot delete a time off which is in %s state.') % (holiday.state,))
         return super(HolidaysAllocation, self).unlink()
 
     @api.multi
     def copy_data(self, default=None):
-        raise UserError(_('A leave cannot be duplicated.'))
+        raise UserError(_('A time off cannot be duplicated.'))
 
     ####################################################
     # Business methods
@@ -392,7 +392,7 @@ class HolidaysAllocation(models.Model):
     def action_draft(self):
         for holiday in self:
             if holiday.state not in ['confirm', 'refuse']:
-                raise UserError(_('Leave request state must be "Refused" or "To Approve" in order to reset to Draft.'))
+                raise UserError(_('Time off request state must be "Refused" or "To Approve" in order to reset to Draft.'))
             holiday.write({
                 'state': 'draft',
                 'first_approver_id': False,
@@ -408,7 +408,7 @@ class HolidaysAllocation(models.Model):
     @api.multi
     def action_confirm(self):
         if self.filtered(lambda holiday: holiday.state != 'draft'):
-            raise UserError(_('Leave request must be in Draft state ("To Submit") in order to confirm it.'))
+            raise UserError(_('Time off request must be in Draft state ("To Submit") in order to confirm it.'))
         res = self.write({'state': 'confirm'})
         self.activity_update()
         return res
@@ -418,7 +418,7 @@ class HolidaysAllocation(models.Model):
         # if validation_type == 'both': this method is the first approval approval
         # if validation_type != 'both': this method calls action_validate() below
         if any(holiday.state != 'confirm' for holiday in self):
-            raise UserError(_('Leave request must be confirmed ("To Approve") in order to approve it.'))
+            raise UserError(_('Time off request must be confirmed ("To Approve") in order to approve it.'))
 
         current_employee = self.env['hr.employee'].search([('user_id', '=', self.env.uid)], limit=1)
 
@@ -432,7 +432,7 @@ class HolidaysAllocation(models.Model):
         current_employee = self.env['hr.employee'].search([('user_id', '=', self.env.uid)], limit=1)
         for holiday in self:
             if holiday.state not in ['confirm', 'validate1']:
-                raise UserError(_('Leave request must be confirmed in order to approve it.'))
+                raise UserError(_('Time off request must be confirmed in order to approve it.'))
 
             holiday.write({'state': 'validate'})
             if holiday.validation_type == 'both':
@@ -470,7 +470,7 @@ class HolidaysAllocation(models.Model):
         current_employee = self.env['hr.employee'].search([('user_id', '=', self.env.uid)], limit=1)
         for holiday in self:
             if holiday.state not in ['confirm', 'validate', 'validate1']:
-                raise UserError(_('Leave request must be confirmed or validated in order to refuse it.'))
+                raise UserError(_('Time off request must be confirmed or validated in order to refuse it.'))
 
             if holiday.state == 'validate1':
                 holiday.write({'state': 'refuse', 'first_approver_id': current_employee.id})
@@ -493,27 +493,27 @@ class HolidaysAllocation(models.Model):
 
             if state == 'draft':
                 if holiday.employee_id != current_employee and not is_manager:
-                    raise UserError(_('Only a Leave Manager can reset other people leaves.'))
+                    raise UserError(_('Only a time off Manager can reset other people time off.'))
                 continue
 
             if not is_officer:
-                raise UserError(_('Only a Leave Officer or Manager can approve or refuse leave requests.'))
+                raise UserError(_('Only a time off Officer or Manager can approve or refuse time off requests.'))
 
             if is_officer:
                 # use ir.rule based first access check: department, members, ... (see security.xml)
                 holiday.check_access_rule('write')
 
             if holiday.employee_id == current_employee and not is_manager:
-                raise UserError(_('Only a Leave Manager can approve its own requests.'))
+                raise UserError(_('Only a time off Manager can approve its own requests.'))
 
             if (state == 'validate1' and val_type == 'both') or (state == 'validate' and val_type == 'manager'):
                 manager = holiday.employee_id.parent_id or holiday.employee_id.department_id.manager_id
                 if (manager and manager != current_employee) and not self.env.user.has_group('hr_holidays.group_hr_holidays_manager'):
-                    raise UserError(_('You must be either %s\'s manager or Leave manager to approve this leave') % (holiday.employee_id.name))
+                    raise UserError(_('You must be either %s\'s manager or time off manager to approve this time off') % (holiday.employee_id.name))
 
             if state == 'validate' and val_type == 'both':
                 if not self.env.user.has_group('hr_holidays.group_hr_holidays_manager'):
-                    raise UserError(_('Only an Leave Manager can apply the second approval on leave requests.'))
+                    raise UserError(_('Only an time off Manager can apply the second approval on time off requests.'))
 
     # ------------------------------------------------------------
     # Activity methods

--- a/addons/hr_holidays/models/hr_leave_type.py
+++ b/addons/hr_holidays/models/hr_leave_type.py
@@ -6,6 +6,8 @@
 import datetime
 import logging
 
+from collections import defaultdict
+
 from odoo import api, fields, models
 from odoo.exceptions import ValidationError
 from odoo.tools.translate import _
@@ -16,16 +18,16 @@ _logger = logging.getLogger(__name__)
 
 class HolidaysType(models.Model):
     _name = "hr.leave.type"
-    _description = "Leave Type"
+    _description = "Time Off Type"
     _order = "sequence, id"
 
-    name = fields.Char('Leave Type', required=True, translate=True)
+    name = fields.Char('Time Off Type', required=True, translate=True)
     code = fields.Char('Code')
     sequence = fields.Integer(default=100,
-                              help='The type with the smallest sequence is the default value in leave request')
+                              help='The type with the smallest sequence is the default value in time off request')
     categ_id = fields.Many2one(
         'calendar.event.type', string='Meeting Type',
-        help='Once a leave is validated, Odoo will create a corresponding meeting of this type in the calendar.')
+        help='Once a time off is validated, Odoo will create a corresponding meeting of this type in the calendar.')
     color_name = fields.Selection([
         ('red', 'Red'),
         ('blue', 'Blue'),
@@ -43,50 +45,50 @@ class HolidaysType(models.Model):
         ('lavender', 'Lavender'),
         ('wheat', 'Wheat'),
         ('ivory', 'Ivory')], string='Color in Report', required=True, default='red',
-        help='This color will be used in the leaves summary located in Reporting > Leaves by Department.')
+        help='This color will be used in the time off summary located in Reporting > Time off by Department.')
     active = fields.Boolean('Active', default=True,
-                            help="If the active field is set to false, it will allow you to hide the leave type without removing it.")
-    max_leaves = fields.Float(compute='_compute_leaves', string='Maximum Allowed',
-                              help='This value is given by the sum of all leaves requests with a positive value.')
+                            help="If the active field is set to false, it will allow you to hide the time off type without removing it.")
+    max_leaves = fields.Float(compute='_compute_leaves', string='Maximum Allowed', search='_search_max_leaves',
+                              help='This value is given by the sum of all time off requests with a positive value.')
     leaves_taken = fields.Float(
-        compute='_compute_leaves', string='Leaves Already Taken',
-        help='This value is given by the sum of all leaves requests with a negative value.')
+        compute='_compute_leaves', string='Time off Already Taken',
+        help='This value is given by the sum of all time off requests with a negative value.')
     remaining_leaves = fields.Float(
-        compute='_compute_leaves', string='Remaining Leaves',
-        help='Maximum Leaves Allowed - Leaves Already Taken')
+        compute='_compute_leaves', string='Remaining Time Off',
+        help='Maximum Time Off Allowed - Time Off Already Taken')
     virtual_remaining_leaves = fields.Float(
-        compute='_compute_leaves', string='Virtual Remaining Leaves',
-        help='Maximum Leaves Allowed - Leaves Already Taken - Leaves Waiting Approval')
+        compute='_compute_leaves', string='Virtual Remaining Time Off',
+        help='Maximum Time Off Allowed - Time Off Already Taken - Time Off Waiting Approval')
     group_days_allocation = fields.Float(
         compute='_compute_group_days_allocation', string='Days Allocated')
     group_days_leave = fields.Float(
-        compute='_compute_group_days_leave', string='Group Leaves')
+        compute='_compute_group_days_leave', string='Group Time Off')
     company_id = fields.Many2one('res.company', string='Company', default=lambda self: self.env.user.company_id)
     validation_type = fields.Selection([
         ('no_validation', 'No Validation'),
         ('hr', 'Payroll Officer'),
         ('manager', 'Team Leader'),
-        ('both', 'Team Leader and Payroll Officer')], default='hr', string='Validation By')
+        ('both', 'Team Leader and Payroll Officer')], default='hr', string='Validation')
     allocation_type = fields.Selection([
-        ('fixed', 'Fixed by HR'),
-        ('fixed_allocation', 'Fixed by HR + allocation request'),
-        ('no', 'No allocation')],
-        default='fixed', string='Mode',
-        help='\tFixed by HR: allocated by HR and cannot be bypassed; users can request leaves;'
-             '\tFixed by HR + allocation request: allocated by HR and users can request leaves and allocations;'
-             '\tNo allocation: no allocation by default, users can freely request leaves;')
-    validity_start = fields.Date("Start Date", default=fields.Date.today,
-                                 help='Adding validity to types of leaves so that it cannot be selected outside this time period')
-    validity_stop = fields.Date("End Date")
+        ('no', 'No Allocation Needed'),
+        ('fixed_allocation', 'Free Allocation Request'),
+        ('fixed', 'Allocated by HR only')],
+        default='no', string='Mode',
+        help='\tNo Allocation Needed: no allocation by default, users can freely request time off;'
+             '\tFree Allocation Request: allocated by HR and users can request time off and allocations;'
+             '\tAllocated by HR only: allocated by HR and cannot be bypassed; users can request time off;')
+    validity_start = fields.Date("From", default=fields.Date.today,
+                                 help='Adding validity to types of time off so that it cannot be selected outside this time period')
+    validity_stop = fields.Date("To")
     valid = fields.Boolean(compute='_compute_valid', search='_search_valid', help='This indicates if it is still possible to use this type of leave')
-    time_type = fields.Selection([('leave', 'Leave'), ('other', 'Other')], default='leave', string="Kind of Leave",
+    time_type = fields.Selection([('leave', 'Time Off'), ('other', 'Other')], default='leave', string="Kind of Leave",
                                  help="Whether this should be computed as a holiday or as work time (eg: formation)")
     request_unit = fields.Selection([
-        ('day', 'Day'), ('hour', 'Hours')],
-        default='day', string='Take Leaves in', required=True)
+        ('day', 'Day'), ('half_day','Half Day'), ('hour', 'Hours')],
+        default='day', string='Take Time Off in', required=True)
     unpaid = fields.Boolean('Is Unpaid', default=False)
-    leave_notif_subtype_id = fields.Many2one('mail.message.subtype', string='Leave Notification Subtype')
-    allocation_notif_subtype_id = fields.Many2one('mail.message.subtype', string='Allocation Notification Subtype')
+    leave_notif_subtype_id = fields.Many2one('mail.message.subtype', string='Time Off Notification Subtype', default=lambda self: self.env.ref('hr_holidays.mt_leave', raise_if_not_found=False))
+    allocation_notif_subtype_id = fields.Many2one('mail.message.subtype', string='Allocation Notification Subtype', default=lambda self: self.env.ref('hr_holidays.mt_leave_allocation', raise_if_not_found=False))
 
     @api.multi
     @api.constrains('validity_start', 'validity_stop')
@@ -118,6 +120,35 @@ class HolidaysType(models.Model):
                 ('validity_stop', signs[0] if value else signs[1], dt),
                 ('validity_start', signs[1] if value else signs[0], dt)]
 
+    def _search_max_leaves(self, operator, value):
+        value = float(value)
+        employee_id = self._get_contextual_employee_id()
+        leaves = defaultdict(int)
+
+        if employee_id:
+            allocations = self.env['hr.leave.allocation'].search([
+                ('employee_id', '=', employee_id),
+                ('state', '=', 'validate')
+            ])
+            for allocation in allocations:
+                leaves[allocation.holiday_status_id.id] += allocation.number_of_days
+        valid_leave = []
+        for leave in leaves:
+            if operator == '>':
+                if leaves[leave] > value:
+                    valid_leave.append(leave)
+            elif operator == '<':
+                if leaves[leave] < value:
+                    valid_leave.append(leave)
+            elif operator == '=':
+                if leaves[leave] == value:
+                    valid_leave.append(leave)
+            elif operator == '!=':
+                if leaves[leave] != value:
+                    valid_leave.append(leave)
+
+        return [('id', 'in', valid_leave)]
+
     @api.multi
     def get_days(self, employee_id):
         # need to use `dict` constructor to create a dict per id
@@ -154,6 +185,19 @@ class HolidaysType(models.Model):
 
         return result
 
+    @api.multi
+    def get_days_all_request(self):
+        employee_id = self._get_contextual_employee_id()
+
+        leaves_type = self.search([])
+        leaves = leaves_type.get_days(employee_id)
+        leave_id_name = dict(zip(leaves_type.ids, leaves_type.mapped('name')))
+        leave_id_allocation_type = dict(zip(leaves_type.ids, leaves_type.mapped('allocation_type')))
+        result = [(leave_id_name[leave_id], {key: round(value, 2) for (key, value) in leave.items()}, leave_id_allocation_type[leave_id]) for leave_id, leave in leaves.items() if leave['virtual_remaining_leaves'] or leave['max_leaves']]
+
+        sort_key = lambda l: (l[2] == 'fixed', l[2] == 'fixed_allocation', l[1]['virtual_remaining_leaves'])
+        return sorted(result, key=sort_key, reverse=True)
+
     def _get_contextual_employee_id(self):
         if 'employee_id' in self._context:
             employee_id = self._context['employee_id']
@@ -235,7 +279,7 @@ class HolidaysType(models.Model):
         leave_ids = super(HolidaysType, self)._search(args, offset=offset, limit=limit, order=order, count=count, access_rights_uid=access_rights_uid)
         if not count and not order and employee_id:
             leaves = self.browse(leave_ids)
-            sort_key = lambda l: (l.allocation_type == 'fixed', l.allocation_type == 'fixed_allocation', l.virtual_remaining_leaves)
+            sort_key = lambda l: (l.allocation_type in ['fixed', 'fixed_allocation'], l.virtual_remaining_leaves)
             return leaves.sorted(key=sort_key, reverse=True).ids
         return leave_ids
 
