PR: https://github.com/odoo/odoo/pull/

From: 5a1645a8f8f3560eb778da90b6160b322ce0722e
From: RÃ©my Voet (ryv)
Date: 2020-01-23 14:59:57

Structural Changes: 3
Total Changes: 73

[ADD] sale_purchase_stock: link between PO<->SO in case of MTO

In order to improve the navigation between of SO and PO in the case of
MTO, add a direct link between PO<->SO. When the SO is confirmed
(with storable product(s) with MTO + buy),
PO is/are generated, in this case, add a stat button on each model form
to avoid to manually search the related SO with the source field (name).

task-1913392

================================= pseudo patch: =================================

--- a/addons/sale_purchase/models/purchase_order.py
+++ b/addons/sale_purchase/models/purchase_order.py
@@ -1,17 +1,50 @@
 # -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
-from odoo import api, fields, models
+from odoo import api, fields, models, _
 
 
 class PurchaseOrder(models.Model):
     _inherit = "purchase.order"
 
+    sale_order_count = fields.Integer(
+        "Number of Source Sale",
+        compute='_compute_sale_order_count',
+        groups='sales_team.group_sale_salesman')
+
+    @api.depends('order_line.sale_order_id')
+    def _compute_sale_order_count(self):
+        for purchase in self:
+            purchase.sale_order_count = len(purchase._get_sale_orders())
+
+    def action_view_sale_orders(self):
+        self.ensure_one()
+        sale_order_ids = self._get_sale_orders().ids
+        action = {
+            'res_model': 'sale.order',
+            'type': 'ir.actions.act_window',
+        }
+        if len(sale_order_ids) == 1:
+            action.update({
+                'view_mode': 'form',
+                'res_id': sale_order_ids[0],
+            })
+        else:
+            action.update({
+                'name': _('Sources Sale Orders %s' % self.name),
+                'domain': [('id', 'in', sale_order_ids)],
+                'view_mode': 'tree,form',
+            })
+        return action
+
     def button_cancel(self):
         result = super(PurchaseOrder, self).button_cancel()
         self.sudo()._activity_cancel_on_sale()
         return result
 
+    def _get_sale_orders(self):
+        return self.order_line.sale_order_id
+
     def _activity_cancel_on_sale(self):
         """ If some PO are cancelled, we need to put an activity on their origin SO (only the open ones). Since a PO can have
             been modified by several SO, when cancelling one PO, many next activities can be schedulded on different SO.

--- a/addons/sale_purchase/models/sale_order.py
+++ b/addons/sale_purchase/models/sale_order.py
@@ -11,17 +11,15 @@ from odoo.tools import float_compare
 class SaleOrder(models.Model):
     _inherit = 'sale.order'
 
-    purchase_order_count = fields.Integer("Number of Purchase Order", compute='_compute_purchase_order_count', groups='purchase.group_purchase_user')
+    purchase_order_count = fields.Integer(
+        "Number of Purchase Order Generated",
+        compute='_compute_purchase_order_count',
+        groups='purchase.group_purchase_user')
 
-    @api.depends('order_line.purchase_line_ids')
+    @api.depends('order_line.purchase_line_ids.order_id')
     def _compute_purchase_order_count(self):
-        purchase_line_data = self.env['purchase.order.line'].read_group(
-            [('sale_order_id', 'in', self.ids)],
-            ['sale_order_id', 'purchase_order_count:count_distinct(order_id)'], ['sale_order_id']
-        )
-        purchase_count_map = {item['sale_order_id'][0]: item['purchase_order_count'] for item in purchase_line_data}
         for order in self:
-            order.purchase_order_count = purchase_count_map.get(order.id, 0)
+            order.purchase_order_count = len(self._get_purchase_orders())
 
     def _action_confirm(self):
         result = super(SaleOrder, self)._action_confirm()
@@ -37,11 +35,29 @@ class SaleOrder(models.Model):
         self.sudo()._activity_cancel_on_purchase()
         return result
 
-    def action_view_purchase(self):
-        action = self.env.ref('purchase.purchase_rfq').read()[0]
-        action['domain'] = [('id', 'in', self.mapped('order_line.purchase_line_ids.order_id').ids)]
+    def action_view_purchase_orders(self):
+        self.ensure_one()
+        purchase_order_ids = self._get_purchase_orders().ids
+        action = {
+            'res_model': 'purchase.order',
+            'type': 'ir.actions.act_window',
+        }
+        if len(purchase_order_ids) == 1:
+            action.update({
+                'view_mode': 'form',
+                'res_id': purchase_order_ids[0],
+            })
+        else:
+            action.update({
+                'name': _("Purchase Order generated from %s" % self.name),
+                'domain': [('id', 'in', purchase_order_ids)],
+                'view_mode': 'tree,form',
+            })
         return action
 
+    def _get_purchase_orders(self):
+        return self.order_line.purchase_line_ids.order_id
+
     def _activity_cancel_on_purchase(self):
         """ If some SO are cancelled, we need to put an activity on their generated purchase. If sale lines of
             different sale orders impact different purchase, we only want one activity to be attached.
