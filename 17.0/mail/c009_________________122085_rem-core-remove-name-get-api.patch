PR: https://github.com/odoo/odoo/pull/122085

From: 3c62ca1eb96d571b2b686b5caee370324c589ab4
From: RÃ©my Voet (ryv)
Date: 2023-06-28 15:41:19

Structural Changes: 2
Total Changes: 38

[REM] core: remove `name_get` API

Rationale
=========

Since v8, the `display_name` field is present on all models. By default,
`display_name` uses `name_get` which has pretty much the same purpose
(return record name used by the web client). Gradually, many (backend)
developers (and the ORM: https://github.com/odoo/odoo/commit/6da1c3ac4c036eac289597602976538e243cb939)
started using `display_name` (more convenient than
`record.name_get()[0][1]`) but it still had the `name_get` override.
It becomes more complex than necessary and poeple start to misunderstand
the two (and sometimes override both, leading to inconstiencies between
`display_name`/`name_get`).

To simplify the ORM and the API, we decided to keep only one of them,
the `display_name` field:
- It is much more convenient from a backend point of view
(`record.name_get()[0][1]` vs `record.display_name`)
- It is cached during the same transaction (and invalidated if
its dependencies change)
- It can be overridden like any other compute field (override
`_compute_display_name` with any extra dependencies)
- `name_get` is replaced by `read(['display_name'])`
(API perceptive), which can actually be more efficient
(if `display_name`'s depends are correct, the ORM will only fetch the
fields it needs instead of every prefetchable field)

Changes
=======

- Deprecates `name_get` for the v17 and based the method on
`display_name` (the opposite of before)
- Converts all usage of `name_get`
- Overrides of `name_get` are now overrides of `_compute_display_name`
- For `res.partner`, rename the field store `display_name` into
`complete_name` because `display_name` context-dependent and it makes
no sense to have a compute store that is context-dependent.
- Previously, it was possible to return multiple names for the same
record with `name_get`, but it was tricky and most of the usage of
this `name_get` didn't take this into account. The only example of
this is the `name_get` of `product.product`
(now use `", ".join(<names>)`).

Part-of: odoo/odoo#122085

================================= pseudo patch: =================================

--- a/addons/mail/models/discuss/discuss_channel_member.py
+++ b/addons/mail/models/discuss/discuss_channel_member.py
@@ -59,8 +59,9 @@ class ChannelMember(models.Model):
         else:
             self.message_unread_counter = 0
 
-    def name_get(self):
-        return [(record.id, record.partner_id.name or record.guest_id.name) for record in self]
+    def _compute_display_name(self):
+        for record in self:
+            record.display_name = record.partner_id.name or record.guest_id.name
 
     def init(self):
         self.env.cr.execute("CREATE UNIQUE INDEX IF NOT EXISTS discuss_channel_member_partner_unique ON %s (channel_id, partner_id) WHERE partner_id IS NOT NULL" % self._table)

--- a/addons/mail/models/mail_activity.py
+++ b/addons/mail/models/mail_activity.py
@@ -404,12 +404,10 @@ class MailActivity(models.Model):
         )
         return activities._as_query(order)
 
-    def name_get(self):
-        res = []
+    def _compute_display_name(self):
         for record in self:
             name = record.summary or record.activity_type_id.display_name
-            res.append((record.id, name))
-        return res
+            record.display_name = name
 
     # ------------------------------------------------------
     # Business Methods

--- a/addons/mail/models/mail_alias.py
+++ b/addons/mail/models/mail_alias.py
@@ -147,20 +147,18 @@ class Alias(models.Model):
             vals['alias_name'] = self._clean_and_check_unique([vals.get('alias_name')])[0]
         return super(Alias, self).write(vals)
 
-    def name_get(self):
+    def _compute_display_name(self):
         """Return the mail alias display alias_name, including the implicit
            mail catchall domain if exists from config otherwise "New Alias".
            e.g. `jobs@mail.odoo.com` or `jobs` or 'New Alias'
         """
-        res = []
         for record in self:
             if record.alias_name and record.alias_domain:
-                res.append((record['id'], "%s@%s" % (record.alias_name, record.alias_domain)))
+                record.display_name = f"{record.alias_name}@{record.alias_domain}"
             elif record.alias_name:
-                res.append((record['id'], "%s" % (record.alias_name)))
+                record.display_name = record.alias_name
             else:
-                res.append((record['id'], _("Inactive Alias")))
-        return res
+                record.display_name = _("Inactive Alias")
 
     def _clean_and_check_unique(self, names):
         """When an alias name appears to already be an email, we keep the local

--- a/addons/mail/models/mail_message.py
+++ b/addons/mail/models/mail_message.py
@@ -103,7 +103,7 @@ class Message(models.Model):
     # related document
     model = fields.Char('Related Document Model')
     res_id = fields.Many2oneReference('Related Document ID', model_field='model')
-    record_name = fields.Char('Message Record Name') # name_get() of the related document
+    record_name = fields.Char('Message Record Name') # display_name of the related document
     link_preview_ids = fields.One2many('mail.link.preview', 'message_id', string='Link Previews', groups="base.group_erp_manager")
     # characteristics
     message_type = fields.Selection([
@@ -993,7 +993,7 @@ class Message(models.Model):
                     'email_from': 'sacha@pokemon.com' # email address or False
                     'subtype_id': (1, u'Discussions'),
                     'date': '2015-06-30 08:22:33',
-                    'partner_ids': [[7, "Sacha Du Bourg-Palette"]], # list of partner name_get
+                    'partner_ids': [[7, "Sacha Du Bourg-Palette"]], # list of partner convert_to_read
                     'message_type': u'comment',
                     'id': 59,
                     'subject': False
@@ -1194,7 +1194,7 @@ class Message(models.Model):
 
     @api.model
     def _get_record_name(self, values):
-        """ Return the related document name, using name_get. It is done using
+        """ Return the related document name, using display_name. It is done using
             SUPERUSER_ID, to be sure to have the record name correctly stored. """
         model = values.get('model', self.env.context.get('default_model'))
         res_id = values.get('res_id', self.env.context.get('default_res_id'))

--- a/addons/mail/models/mail_thread.py
+++ b/addons/mail/models/mail_thread.py
@@ -2712,7 +2712,7 @@ class MailThread(models.AbstractModel):
 
         :return str: default subject """
         self.ensure_one()
-        return self.name_get()[0][1]
+        return self.display_name
 
     def _message_create(self, values_list):
         """ Low-level helper to create mail.message records. It is mainly used

--- a/addons/mail/models/mail_tracking_value.py
+++ b/addons/mail/models/mail_tracking_value.py
@@ -78,8 +78,8 @@ class MailTracking(models.Model):
             values.update({
                 'old_value_integer': initial_value and initial_value.id or 0,
                 'new_value_integer': new_value and new_value.id or 0,
-                'old_value_char': initial_value and initial_value.sudo().name_get()[0][1] or '',
-                'new_value_char': new_value and new_value.sudo().name_get()[0][1] or ''
+                'old_value_char': initial_value and initial_value.sudo().display_name or '',
+                'new_value_char': new_value and new_value.sudo().display_name or ''
             })
         elif col_info['type'] in ['many2many', 'one2many']:
             values.update({

--- a/addons/mail/models/res_users_settings_volumes.py
+++ b/addons/mail/models/res_users_settings_volumes.py
@@ -22,8 +22,9 @@ class ResUsersSettingsVolumes(models.Model):
         ("partner_or_guest_exists", "CHECK((partner_id IS NOT NULL AND guest_id IS NULL) OR (partner_id IS NULL AND guest_id IS NOT NULL))", "A volume setting must have a partner or a guest."),
     ]
 
-    def name_get(self):
-        return [(rec.id, f'{rec.user_setting_id.user_id.name} - {rec.partner_id.name or rec.guest_id.name}') for rec in self]
+    def _compute_display_name(self):
+        for rec in self:
+            rec.display_name = f'{rec.user_setting_id.user_id.name} - {rec.partner_id.name or rec.guest_id.name}'
 
     def _discuss_users_settings_volume_format(self):
         return [{
