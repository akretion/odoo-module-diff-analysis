PR: https://github.com/odoo/odoo/pull/129562

From: 605943b5eaafe7e9224f0e7fb4fbdd020102c7a5
From: David Monnom (moda)
Date: 2023-08-31 04:13:04

Structural Changes: 22
Total Changes: 406

[ADD] point_of_sale,pos_*: add kiosk mode

*:point_of_sale,pos_adyen,pos_online_payment_self_order,pos_restaurant,
pos_sale,pos_self_order,pos_self_order_adyen,pos_self_order_restaurant,
pos_self_order_sale

This PR adds the kiosk to the existing `pos_self_order` module, which
until now has enabled end-users to order their restaurant meals directly
from their smartphones.

We've added the possibility of creating kiosks / totems (devices with
large touch screens) that allow users to order their menu directly
without having to go through a waiter.
Once the order has been placed, the user will be invited to pay either
by adyen, already integrated into this PR, or at the counter.

At the end of the order, the user will receive an order number and his
table number if `service at table` is activated.

Main differences with the Self-order mobile:
- Kiosk shouldn't be accessible publicly
- Kiosk should support payments via card readers

closes odoo/odoo#129562

Design: XLU
Dev: ADGU & MODA
Taskid: 3323163
Related: odoo/upgrade#5024
Signed-off-by: Adrien Guilliams (adgu) <adgu@odoo.com>

================================= pseudo patch: =================================

--- a/addons/pos_self_order/models/__init__.py
+++ b/addons/pos_self_order/models/__init__.py
@@ -4,6 +4,7 @@ from . import ir_http
 from . import pos_config
 from . import pos_order
 from . import pos_restaurant
+from . import pos_payment_method
 from . import pos_self_order_custom_link
 from . import product_product
 from . import res_config_settings

--- a/addons/pos_self_order/models/pos_config.py
+++ b/addons/pos_self_order/models/pos_config.py
@@ -1,17 +1,17 @@
 # -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
-from typing import Optional, List, Dict, Callable
+import io
 import uuid
-from werkzeug.urls import url_quote
 import base64
+from PIL import Image
+from typing import Optional, List, Dict
+from werkzeug.urls import url_quote
+from odoo.tools import image_to_base64
 
-
-from odoo import api, fields, models, modules
+from odoo import api, fields, models, modules, _
 from odoo.tools import file_open, split_every
 
-from odoo.addons.pos_self_order.models.product_product import ProductProduct
-
 
 class PosConfig(models.Model):
     _inherit = "pos.config"
@@ -25,6 +25,84 @@ class PosConfig(models.Model):
         )
         return base64.b64encode(file_open(image_path, "rb").read())
 
+    def _self_order_kiosk_default_languages(self):
+        return self.env["res.lang"].get_installed()
+
+    status = fields.Selection(
+        [("inactive", "Inactive"), ("active", "Active")],
+        string="Status",
+        compute="_compute_status",
+        store=False,
+    )
+    self_order_kiosk_url = fields.Char(compute="_compute_self_order_kiosk_url")
+    self_order_kiosk = fields.Boolean(
+        string="Kiosk",
+        help="Enable the kiosk mode for the Point of Sale",
+    )
+    self_order_kiosk_takeaway = fields.Boolean(
+        string="Takeaway",
+        help="Allow customers to order for takeaway",
+    )
+    self_order_kiosk_alternative_fp_id = fields.Many2one(
+        'account.fiscal.position',
+        string='Alternative Fiscal Position',
+        help='This is useful for restaurants with onsite and take-away services that imply specific tax rates.',
+    )
+    self_order_kiosk_mode = fields.Selection(
+        [("counter", "Pickup Counter"), ("table", "Service at Table")],
+        string="Kiosk Mode",
+        default="counter",
+        help="Choose the kiosk mode",
+        required=True,
+    )
+    self_order_kiosk_available_language_ids = fields.Many2many(
+        "res.lang",
+        string="Available Languages",
+        help="Languages available for the kiosk mode",
+        default=_self_order_kiosk_default_languages,
+    )
+    self_order_kiosk_default_language = fields.Many2one(
+        "res.lang",
+        string="Default Language",
+        help="Default language for the kiosk mode",
+        default=lambda self: self.env["res.lang"].search(
+            [("code", "=", self.env.lang)], limit=1
+        ),
+    )
+    self_order_kiosk_image_home = fields.Image(
+        string="Self Order Kiosk Image Home",
+        help="Image to display on the self order screen",
+        max_width=1080,
+        max_height=1920,
+        default=_self_order_default_image,
+    )
+    self_order_kiosk_image_eat = fields.Image(
+        string="Self Order Kiosk Image Eat",
+        help="Image to display on the self order screen",
+        max_width=1080,
+        max_height=1920,
+        default=_self_order_default_image,
+    )
+    self_order_kiosk_image_brand = fields.Image(
+        string="Self Order Kiosk Image Brand",
+        help="Image to display on the self order screen",
+        max_width=1200,
+        max_height=250,
+    )
+    self_order_kiosk_image_home_name = fields.Char(
+        string="Self Order Kiosk Image Home Name",
+        help="Name of the image to display on the self order screen",
+        default=_self_order_default_image_name,
+    )
+    self_order_kiosk_image_eat_name = fields.Char(
+        string="Self Order Kiosk Image Eat Name",
+        help="Name of the image to display on the self order screen",
+        default=_self_order_default_image_name,
+    )
+    self_order_kiosk_image_brand_name = fields.Char(
+        string="Self Order Kiosk Image Brand Name",
+        help="Name of the image to display on the self order screen",
+    )
     self_order_view_mode = fields.Boolean(
         string="QR Code Menu",
         help="Allow customers to view the menu on their phones by scanning the QR code on the table",
@@ -68,6 +146,13 @@ class PosConfig(models.Model):
         self.access_token = self._get_access_token()
         self.floor_ids.table_ids._update_identifier()
 
+    @api.onchange("self_order_kiosk")
+    def _self_order_kiosk_change(self):
+        for record in self:
+            if record.self_order_kiosk:
+                record.self_order_view_mode = False
+                record.self_order_table_mode = False
+
     @api.model
     def _init_access_token(self):
         pos_config_ids = self.env["pos.config"].search([])
@@ -101,6 +186,40 @@ class PosConfig(models.Model):
                 record.self_order_view_mode = False
                 record.self_order_table_mode = False
 
+    def _get_qr_code_data(self):
+        self.ensure_one()
+
+        table_qr_code = []
+        if self.self_order_table_mode:
+            table_qr_code.extend([{
+                    'name': floor.name,
+                    'type': 'table',
+                    'tables': [
+                        {
+                            'identifier': table.identifier,
+                            'id': table.id,
+                            'name': table.name,
+                            'url': self._get_self_order_url(table.id),
+                        }
+                        for table in floor.table_ids.filtered("active")
+                    ]
+                }
+                for floor in self.floor_ids]
+            )
+
+        # Here we use "range" to determine the number of QR codes to generate from
+        # this list, which will then be inserted into a PDF.
+        table_qr_code.extend([{
+            'name': 'Generic',
+            'type': 'default',
+            'tables': [{
+                'id': i,
+                'url': self._get_self_order_url(),
+            } for i in range(0, 11)]
+        }])
+
+        return table_qr_code
+
     def _get_self_order_route(self, table_id: Optional[int] = None) -> str:
         self.ensure_one()
         base_route = f"/menu/{self.id}"
@@ -155,10 +274,7 @@ class PosConfig(models.Model):
             )
         )
 
-    def _get_available_products(self) -> ProductProduct:
-        """
-        This function returns the products that are available in the given PosConfig
-        """
+    def _get_available_products(self):
         self.ensure_one()
         return (
             self.env["product.product"]
@@ -175,47 +291,144 @@ class PosConfig(models.Model):
             )
         )
 
+    def _get_available_categories(self):
+        self.ensure_one()
+        return (
+            self.env["pos.category"]
+            .search(
+                [
+                    *(
+                        self.limit_categories
+                        and self.iface_available_categ_ids
+                        and [("id", "in", self.iface_available_categ_ids.ids)]
+                        or []
+                    ),
+                ],
+                order="sequence",
+            )
+        )
+
     def _get_self_order_data(self) -> Dict:
         self.ensure_one()
         return {
             "pos_config_id": self.id,
+            "iface_start_categ_id": self.iface_start_categ_id.id,
             "company_name": self.company_id.name,
+            "company_color": self.company_id.color,
             "currency_id": self.currency_id.id,
             "show_prices_with_tax_included": self.iface_tax_included == "total",
             "custom_links": self._get_self_order_custom_links(),
             "products": self._get_available_products()._get_self_order_data(self),
-            "pos_category": self.env['pos.category'].search_read(fields=["name", "sequence"], order="sequence"),
+            "combos": self._get_combos_data(),
+            "pos_category": self._get_available_categories().read(["name", "sequence", "has_image"]),
             "has_active_session": self.has_active_session,
         }
 
-    def _get_qr_code_data(self):
+    def _get_combos_data(self):
         self.ensure_one()
+        combos = self.env["pos.combo"].search([])
 
-        table_qr_code = []
-        if self.self_order_table_mode:
-            table_qr_code.extend([{
-                    'name': floor.name,
-                    'type': 'table',
-                    'tables': [
-                        {
-                            'identifier': table.identifier,
-                            'id': table.id,
-                            'name': table.name,
-                            'url': self._get_self_order_url(table.id),
-                        }
-                        for table in floor.table_ids.filtered("active")
-                    ]
-                }
-                for floor in self.floor_ids]
-            )
+        return[{
+            'id': combo.id,
+            'name': combo.name,
+            'combo_line_ids': combo.combo_line_ids.read(['product_id', 'price', 'lst_price', 'combo_id'])
+        } for combo in combos]
 
-        table_qr_code.extend([{
-            'name': 'Generic',
-            'type': 'default',
-            'tables': [{
-                'id': i,
-                'url': self._get_self_order_url(),
-            } for i in range(0, 11)]
-        }])
+    def _get_self_order_mobile_data(self):
+        self.ensure_one()
+        return {
+            **self._get_self_order_data(),
+            "mobile_image_home": self._get_kiosk_image(self.self_order_image),
+        }
 
-        return table_qr_code
+    def _get_self_order_kiosk_data(self):
+        self.ensure_one()
+        payment_search_params = self.current_session_id._loader_params_pos_payment_method()
+        payment_methods = self.payment_method_ids.filtered(lambda p: p.use_payment_terminal == 'adyen').read(payment_search_params['search_params']['fields'])
+        default_language = self.self_order_kiosk_default_language.read(["code", "name", "iso_code", "flag_image_url"])
+
+        return {
+            **self._get_self_order_data(),
+            "avaiable_payment_methods": self.payment_method_ids.ids,
+            "pos_payment_methods": payment_methods,
+            "pos_session": self.current_session_id.read(["id", "access_token"])[0] if self.current_session_id else [],
+            "kiosk_mode": self.self_order_kiosk_mode,
+            "kiosk_takeaway": self.self_order_kiosk_takeaway,
+            "kiosk_alternative_fp": self.self_order_kiosk_alternative_fp_id.id,
+            "kiosk_image_home":  self._get_kiosk_image(self.self_order_kiosk_image_home),
+            "kiosk_image_eat": self._get_kiosk_image(self.self_order_kiosk_image_eat),
+            "kiosk_image_brand": self._get_kiosk_image(self.self_order_kiosk_image_brand),
+            "kiosk_default_language": default_language[0] if default_language else [],
+            "kiosk_available_languages": self.self_order_kiosk_available_language_ids.read(["code", "display_name", "iso_code", "flag_image_url"]),
+        }
+
+    def _get_kiosk_image(self, image):
+        image = Image.open(io.BytesIO(base64.b64decode(image))) if image else False
+        return image_to_base64(image, 'PNG').decode('utf-8') if image else False
+
+    def _split_qr_codes_list(self, floors: List[Dict], cols: int) -> List[Dict]:
+        """
+        :floors: the list of floors
+        :cols: the number of qr codes per row
+        """
+        self.ensure_one()
+        return [
+            {
+                "name": floor.get("name"),
+                "rows_of_tables": list(split_every(cols, floor["tables"], list)),
+            }
+            for floor in floors
+        ]
+
+    def _compute_self_order_kiosk_url(self):
+        for record in self:
+            domain = self.get_base_url()
+            record.self_order_kiosk_url = '%s/kiosk/%d?access_token=%s' % (domain, record.id, record.access_token)
+
+    def action_close_kiosk_session(self):
+        current_session_id = self.current_session_id
+
+        if current_session_id:
+            if current_session_id.order_ids:
+                current_session_id.order_ids.filtered(lambda o: o.state not in ['paid', 'invoiced']).unlink()
+
+            self.env['bus.bus']._sendone(f'pos_config-{self.access_token}', 'status', {
+                'status': 'closed',
+            })
+
+            return current_session_id.action_pos_session_closing_control()
+
+    def _compute_status(self):
+        for record in self:
+            record.status = 'active' if record.has_active_session else 'inactive'
+
+    def action_open_kiosk(self):
+        self.ensure_one()
+
+        return {
+            'name': _('Self Kiosk'),
+            'type': 'ir.actions.act_url',
+            'url': self.self_order_kiosk_url,
+        }
+
+    def action_open_wizard(self):
+        self.ensure_one()
+
+        if not self.current_session_id:
+            pos_session = self.env['pos.session'].create({'user_id': self.env.uid, 'config_id': self.id})
+            pos_session._ensure_access_token()
+            self.env['bus.bus']._sendone(f'pos_config-{self.access_token}', 'status', {
+                'status': 'open',
+                'pos_session': pos_session.read(['id', 'access_token'])[0],
+            })
+
+        return {
+            'name': _('Self Kiosk'),
+            'type': 'ir.actions.act_window',
+            'view_type': 'form',
+            'view_mode': 'form',
+            'res_model': 'pos.config',
+            'res_id': self.id,
+            'target': 'new',
+            'views': [(self.env.ref('pos_self_order.pos_self_order_kiosk_read_only_form_dialog').id, 'form')],
+        }

--- a/addons/pos_self_order/models/pos_order.py
+++ b/addons/pos_self_order/models/pos_order.py
@@ -11,6 +11,29 @@ class PosOrderLine(models.Model):
 
     # For the moment we need this to keep attributes consistency between the server and client_side.
     selected_attributes = fields.Json(string="Selected Attributes")
+    combo_parent_id = fields.Many2one('pos.order.line', string='Combo Parent')
+    combo_line_ids = fields.One2many('pos.order.line', 'combo_parent_id', string='Combo Lines')
+    combo_id = fields.Many2one('pos.combo', string='Combo line reference')
+
+    @api.model_create_multi
+    def create(self, vals_list):
+        for vals in vals_list:
+            if (vals.get('combo_parent_uuid')):
+                vals.update([
+                    ('combo_parent_id', self.search([('uuid', '=', vals.get('combo_parent_uuid'))]).id)
+                ])
+            if 'combo_parent_uuid' in vals:
+                del vals['combo_parent_uuid']
+        return super().create(vals_list)
+
+    def write(self, vals):
+        if (vals.get('combo_parent_uuid')):
+            vals.update([
+                ('combo_parent_id', self.search([('uuid', '=', vals.get('combo_parent_uuid'))]).id)
+            ])
+        if 'combo_parent_uuid' in vals:
+            del vals['combo_parent_uuid']
+        return super().write(vals)
 
     # FIXME: uuid already pass in pos and move note in pos_restaurant.
     def _export_for_ui(self, orderline):
@@ -24,6 +47,9 @@ class PosOrderLine(models.Model):
 class PosOrder(models.Model):
     _inherit = "pos.order"
 
+    tracking_number = fields.Integer(string="Tracking Number")
+    take_away = fields.Boolean(string="Take Away", default=False)
+
     @api.model
     def create_from_ui(self, orders, draft=False):
         orders = super().create_from_ui(orders, draft)
@@ -39,6 +65,14 @@ class PosOrder(models.Model):
 
         return super().remove_from_ui(server_ids)
 
+    def _order_fields(self, ui_order):
+        fields = super()._order_fields(ui_order)
+        fields.update({
+            'tracking_number': ui_order.get('tracking_number'),
+            'take_away': ui_order.get('take_away'),
+        })
+        return fields
+
     def _send_notification(self, order_ids):
         for order in order_ids:
             if order.access_token and order.state != 'draft':
@@ -53,8 +87,10 @@ class PosOrder(models.Model):
         return {
             "id": self.id,
             "pos_config_id": self.config_id.id,
+            "take_away": self.take_away,
             "pos_reference": self.pos_reference,
             "access_token": self.access_token,
+            "tracking_number": self.tracking_number,
             "state": self.state,
             "date_order": str(self.date_order),
             "amount_total": self.amount_total,

--- a/None
+++ b/addons/pos_self_order/models/pos_payment_method.py
@@ -0,0 +1,9 @@
+from odoo import models
+
+
+class PosPaymentMethod(models.Model):
+    _inherit = "pos.payment.method"
+
+    # will be overridden.
+    def payment_request_from_kiosk(self, order):
+        pass

--- a/addons/pos_self_order/models/product_product.py
+++ b/addons/pos_self_order/models/product_product.py
@@ -66,9 +66,6 @@ class ProductProduct(models.Model):
     def _get_price_info(
         self, pos_config: PosConfig, price: Optional[float] = None, qty: int = 1
     ) -> Dict[str, float]:
-        """
-        Function that returns a dict with the price info of a given product
-        """
         self.ensure_one()
         # if price == None it means that a price was not passed as a parameter, so we use the product's list price
         # it could happen that a price was passed, but it was 0; in that case we want to use this 0 as the argument,
@@ -77,32 +74,36 @@ class ProductProduct(models.Model):
             price = pos_config.pricelist_id._get_product_price(
                 self, qty, currency=pos_config.currency_id
             )
+
         price_info = pos_config.default_fiscal_position_id.map_tax(self.taxes_id).compute_all(
             price, pos_config.currency_id, qty, product=self
         )
 
+        display_price = price_info["total_included"] if pos_config.iface_tax_included == "total" else price_info["total_excluded"]
+        display_price = self.lst_price if self.combo_ids else display_price
+
         return {
-            "list_price": price_info["total_included"]
-            if pos_config.iface_tax_included == "total"
-            else price_info["total_excluded"],
-            "price_without_tax": price_info["total_excluded"],
-            "price_with_tax": price_info["total_included"],
+            "display_price": display_price,
+            "lst_price": self.lst_price
         }
 
+    def _get_product_for_ui(self, pos_config):
+        self.ensure_one()
+        return {
+                "price_info": self._get_price_info(pos_config),
+                "has_image": bool(self.image_1920),
+                "attributes": self._get_attributes(pos_config),
+                "name": self._get_name(),
+                "id": self.id,
+                "description_sale": self.description_sale,
+                "pos_categ_ids": self.pos_categ_ids.mapped("name") or ["Other"],
+                "pos_combo_ids": self.combo_ids.mapped("id") or False,
+                "is_pos_groupable": self.uom_id.is_pos_groupable,
+                "write_date": self.write_date.timestamp(),
+            }
+
     def _get_self_order_data(self, pos_config: PosConfig) -> List[Dict]:
-        """
-        returns the list of products with the necessary info for the self order app
-        """
         return [
-            {
-                "price_info": product._get_price_info(pos_config),
-                "has_image": bool(product.image_1920),
-                "attributes": product._get_attributes(pos_config),
-                "name": product._get_name(),
-                "id": product.id,
-                "description_sale": product.description_sale,
-                "pos_categ_ids": product.pos_categ_ids.mapped("name") or ["Other"],
-                "is_pos_groupable": product.uom_id.is_pos_groupable,
-            }
+            product._get_product_for_ui(pos_config)
             for product in self
         ]

--- a/addons/pos_self_order/models/res_config_settings.py
+++ b/addons/pos_self_order/models/res_config_settings.py
@@ -8,6 +8,18 @@ from odoo.tools.misc import split_every
 class ResConfigSettings(models.TransientModel):
     _inherit = "res.config.settings"
 
+    pos_self_order_kiosk = fields.Boolean(related="pos_config_id.self_order_kiosk", readonly=False)
+    pos_self_order_kiosk_mode = fields.Selection(related="pos_config_id.self_order_kiosk_mode", readonly=False)
+    pos_self_order_kiosk_takeaway = fields.Boolean(related="pos_config_id.self_order_kiosk_takeaway", readonly=False)
+    pos_self_order_kiosk_alternative_fp_id = fields.Many2one(related="pos_config_id.self_order_kiosk_alternative_fp_id", readonly=False)
+    pos_self_order_kiosk_image_home = fields.Image(related="pos_config_id.self_order_kiosk_image_home", readonly=False)
+    pos_self_order_kiosk_image_eat = fields.Image(related="pos_config_id.self_order_kiosk_image_eat", readonly=False)
+    pos_self_order_kiosk_image_brand = fields.Image(related="pos_config_id.self_order_kiosk_image_brand", readonly=False)
+    pos_self_order_kiosk_image_home_name = fields.Char(related="pos_config_id.self_order_kiosk_image_home_name", readonly=False)
+    pos_self_order_kiosk_image_eat_name = fields.Char(related="pos_config_id.self_order_kiosk_image_eat_name", readonly=False)
+    pos_self_order_kiosk_image_brand_name = fields.Char(related="pos_config_id.self_order_kiosk_image_brand_name", readonly=False)
+    pos_self_order_kiosk_available_language_ids = fields.Many2many(related="pos_config_id.self_order_kiosk_available_language_ids", readonly=False)
+    pos_self_order_kiosk_default_language = fields.Many2one(related="pos_config_id.self_order_kiosk_default_language", readonly=False)
     pos_self_order_view_mode = fields.Boolean(
         compute="_compute_pos_module_pos_self_order", store=True, readonly=False
     )
@@ -33,6 +45,22 @@ class ResConfigSettings(models.TransientModel):
         compute="_compute_pos_module_pos_self_order", store=True, readonly=False
     )
 
+    @api.onchange("pos_self_order_kiosk_default_language", "pos_self_order_kiosk_available_language_ids")
+    def _onchange_pos_self_order_kiosk_default_language(self):
+        if self.pos_self_order_kiosk_default_language not in self.pos_self_order_kiosk_available_language_ids:
+            self.pos_self_order_kiosk_available_language_ids = self.pos_self_order_kiosk_available_language_ids + self.pos_self_order_kiosk_default_language
+        if not self.pos_self_order_kiosk_default_language and self.pos_self_order_kiosk_available_language_ids:
+            self.pos_self_order_kiosk_default_language = self.pos_self_order_kiosk_available_language_ids[0]
+
+    @api.onchange("pos_self_order_kiosk")
+    def _self_order_kiosk_change(self):
+        for record in self:
+            record.is_kiosk_mode = record.pos_self_order_kiosk
+
+            if record.pos_config_id.self_order_kiosk:
+                record.pos_config_id.self_order_view_mode = False
+                record.pos_config_id.self_order_table_mode = False
+
     @api.depends("pos_config_id")
     def _compute_pos_module_pos_self_order(self):
         for res_config in self:
