PR: https://github.com/odoo/odoo/pull/106413

From: e7df30a565804d2130ecbbcd201c068073dbc16f
From: william
Date: 2023-03-07 17:02:19

Structural Changes: 1
Total Changes: 99

[IMP] account{,_sequence}: merge

This module was added in stable but was never intended as a separate
module.

closes odoo/odoo#106413

Related: odoo/upgrade#4073
Related: odoo/enterprise#37844
Signed-off-by: Josse Colpaert <jco@odoo.com>

================================= pseudo patch: =================================

--- a/addons/account/models/account_move.py
+++ b/addons/account/models/account_move.py
@@ -28,8 +28,8 @@ from odoo.tools import (
     formatLang,
     frozendict,
     get_lang,
+    index_exists,
     is_html_empty,
-    sql
 )
 
 _logger = logging.getLogger(__name__)
@@ -575,14 +575,29 @@ class AccountMove(models.Model):
     show_payment_term_details = fields.Boolean(compute="_compute_show_payment_term_details")
     show_discount_details = fields.Boolean(compute="_compute_show_payment_term_details")
 
+    _sql_constraints = [(
+        'unique_name', "", "Another entry with the same name already exists.",
+    )]
+
     def _auto_init(self):
         super()._auto_init()
-        self.env.cr.execute("""
-            CREATE INDEX IF NOT EXISTS account_move_to_check_idx
-            ON account_move(journal_id) WHERE to_check = true;
-            CREATE INDEX IF NOT EXISTS account_move_payment_idx
-            ON account_move(journal_id, state, payment_state, move_type, date);
-        """)
+        if not index_exists(self.env.cr, 'account_move_to_check_idx'):
+            self.env.cr.execute("""
+                CREATE INDEX account_move_to_check_idx
+                          ON account_move(journal_id)
+                       WHERE to_check = true
+            """)
+        if not index_exists(self.env.cr, 'account_move_payment_idx'):
+            self.env.cr.execute("""
+                CREATE INDEX account_move_payment_idx
+                          ON account_move(journal_id, state, payment_state, move_type, date)
+            """)
+        if not index_exists(self.env.cr, 'account_move_unique_name'):
+            self.env.cr.execute("""
+                CREATE UNIQUE INDEX account_move_unique_name
+                                 ON account_move(name, journal_id)
+                              WHERE (state = 'posted' AND name != '/')
+            """)
 
     # -------------------------------------------------------------------------
     # COMPUTE METHODS
@@ -723,7 +738,7 @@ class AccountMove(models.Model):
     @api.depends('journal_id', 'date')
     def _compute_highest_name(self):
         for record in self:
-            record.highest_name = record._get_last_sequence(lock=False)
+            record.highest_name = record._get_last_sequence()
 
     @api.depends('name', 'journal_id')
     def _compute_made_sequence_hole(self):
@@ -1671,7 +1686,7 @@ class AccountMove(models.Model):
 
     @api.onchange('journal_id')
     def _onchange_journal_id(self):
-        if not self.quick_edit_mode and self._get_last_sequence(lock=False):
+        if not self.quick_edit_mode and self._get_last_sequence():
             self.name = '/'
             self._compute_name()
 
@@ -1679,30 +1694,6 @@ class AccountMove(models.Model):
     # CONSTRAINT METHODS
     # -------------------------------------------------------------------------
 
-    @api.constrains('name', 'journal_id', 'state')
-    def _check_unique_sequence_number(self):
-        moves = self.filtered(lambda move: move.state == 'posted')
-        if not moves:
-            return
-
-        self.flush_model(['name', 'journal_id', 'move_type', 'state'])
-
-        # /!\ Computed stored fields are not yet inside the database.
-        self._cr.execute('''
-            SELECT move2.id, move2.name
-            FROM account_move move
-            INNER JOIN account_move move2 ON
-                move2.name = move.name
-                AND move2.journal_id = move.journal_id
-                AND move2.move_type = move.move_type
-                AND move2.id != move.id
-            WHERE move.id IN %s AND move2.state = 'posted'
-        ''', [tuple(moves.ids)])
-        res = self._cr.fetchall()
-        if res:
-            raise ValidationError(_('Posted journal entry must have an unique sequence number per company.\n'
-                                    'Problematic numbers: %s\n') % ', '.join(r[1] for r in res))
-
     @contextmanager
     def _check_balanced(self, container):
         ''' Assert the move is fully balanced debit = credit.
@@ -3854,7 +3845,7 @@ class AccountMove(models.Model):
         """
         lock_dates = self._get_violated_lock_dates(invoice_date, has_tax)
         today = fields.Date.today()
-        highest_name = self.highest_name or self._get_last_sequence(relaxed=True, lock=False)
+        highest_name = self.highest_name or self._get_last_sequence(relaxed=True)
         number_reset = self._deduce_sequence_number_reset(highest_name)
         if lock_dates:
             invoice_date = lock_dates[-1][0] + timedelta(days=1)

--- a/addons/account/models/sequence_mixin.py
+++ b/addons/account/models/sequence_mixin.py
@@ -3,11 +3,11 @@
 from odoo import api, fields, models, _
 from odoo.exceptions import ValidationError
 from odoo.tools.misc import format_date
-from odoo.tools import frozendict
+from odoo.tools import frozendict, mute_logger
 
 import re
 from collections import defaultdict
-from psycopg2 import sql
+from psycopg2 import sql, DatabaseError
 
 
 class SequenceMixin(models.AbstractModel):
@@ -138,7 +138,7 @@ class SequenceMixin(models.AbstractModel):
         self.ensure_one()
         return "00000000"
 
-    def _get_last_sequence(self, relaxed=False, with_prefix=None, lock=True):
+    def _get_last_sequence(self, relaxed=False, with_prefix=None):
         """Retrieve the previous sequence.
 
         This is done by taking the number with the greatest alphabetical value within
@@ -171,21 +171,12 @@ class SequenceMixin(models.AbstractModel):
             param['with_prefix'] = with_prefix
 
         query = f"""
-                SELECT {{field}} FROM {self._table}
+                SELECT {self._sequence_field} FROM {self._table}
                 {where_string}
                 AND sequence_prefix = (SELECT sequence_prefix FROM {self._table} {where_string} ORDER BY id DESC LIMIT 1)
                 ORDER BY sequence_number DESC
                 LIMIT 1
         """
-        if lock:
-            query = f"""
-            UPDATE {self._table} SET write_date = write_date WHERE id = (
-                {query.format(field='id')}
-            )
-            RETURNING {self._sequence_field};
-            """
-        else:
-            query = query.format(field=self._sequence_field)
 
         self.flush_model([self._sequence_field, 'sequence_number', 'sequence_prefix'])
         self.env.cr.execute(query, param)
@@ -242,15 +233,32 @@ class SequenceMixin(models.AbstractModel):
         if new:
             last_sequence = self._get_last_sequence(relaxed=True) or self._get_starting_sequence()
 
-        format, format_values = self._get_sequence_format_param(last_sequence)
+        format_string, format_values = self._get_sequence_format_param(last_sequence)
         if new:
             format_values['seq'] = 0
             format_values['year'] = self[self._sequence_date_field].year % (10 ** format_values['year_length'])
             format_values['month'] = self[self._sequence_date_field].month
-        format_values['seq'] = format_values['seq'] + 1
 
-        self[self._sequence_field] = format.format(**format_values)
+        # before flushing inside the savepoint (which may be rolled back!), make sure everything
+        # is already flushed, otherwise we could lose non-sequence fields values, as the ORM believes
+        # them to be flushed.
+        self.flush_recordset()
+        while True:
+            format_values['seq'] = format_values['seq'] + 1
+            sequence = format_string.format(**format_values)
+            try:
+                with self.env.cr.savepoint(flush=False), mute_logger('odoo.sql_db'):
+                    self[self._sequence_field] = sequence
+                    self.flush_recordset([self._sequence_field])
+                    break
+            except DatabaseError as e:
+                # 23P01 ExclusionViolation
+                # 23505 UniqueViolation
+                if e.pgcode not in ('23P01', '23505'):
+                    raise e
         self._compute_split_sequence()
+        self.flush_recordset(['sequence_prefix', 'sequence_number'])
+
 
     def _is_last_from_seq_chain(self):
         """Tells whether or not this element is the last one of the sequence chain.
