PR: https://github.com/odoo/odoo/pull/

From: a35df8d37170790257876a54aa54f2c3ab596c44
From: Darshil Trivedi
Date: 2018-07-19 12:43:08

Structural Changes: 31
Total Changes: 510

[IMP] stock: merge push and pull rules

Usability improvement:
- Common view for push and pull rules
- Add an help text in order to describe the rule
- Rules menu
- Warehouse checked by default on route created by a warehouse
- Lower the MTO route sequence in order to take it first.
- Tooltip cleaning

Technical improvement:
The purpose of this task was also to merge stock.location.path(push rule) and
procrement.rule. Those two model were design to execute the same task
but in a different direction. Thus it contains duplicate code.

Task ID 1852969.

================================= pseudo patch: =================================

--- a/addons/stock/models/procurement.py
+++ b/addons/stock/models/procurement.py
@@ -35,34 +35,139 @@ class ProcurementRule(models.Model):
         ('fixed', 'Fixed')], string="Propagation of Procurement Group", default='propagate')
     group_id = fields.Many2one('procurement.group', 'Fixed Procurement Group')
     action = fields.Selection(
-        selection=[('move', 'Move From Another Location')], string='Action',
+        selection=[('pull', 'Pull From'), ('push', 'Push To'), ('pull_push', 'Pull & Push')], string='Action',
         required=True)
     sequence = fields.Integer('Sequence', default=20)
-    company_id = fields.Many2one('res.company', 'Company')
-    location_id = fields.Many2one('stock.location', 'Procurement Location')
-    location_src_id = fields.Many2one('stock.location', 'Source Location', help="Source location is action=move")
+    company_id = fields.Many2one('res.company', 'Company',
+        default=lambda self: self.env.user.company_id)
+    location_id = fields.Many2one('stock.location', 'Destination Location', required=True)
+    location_src_id = fields.Many2one('stock.location', 'Source Location')
     route_id = fields.Many2one('stock.location.route', 'Route', required=True, ondelete='cascade')
     procure_method = fields.Selection([
         ('make_to_stock', 'Take From Stock'),
-        ('make_to_order', 'Create Procurement')], string='Move Supply Method',
+        ('make_to_order', 'Trigger Another Rule')], string='Move Supply Method',
         default='make_to_stock', required=True,
-        help="""Determines the procurement method of the stock move that will be generated: whether it will need to 'take from the available stock' in its source location or needs to ignore its stock and create a procurement over there.""")
+        help="""Create Procurement: A procurement will be created in the source location and the system will try to find a rule to resolve it. The available stock will be ignored.
+             Take from Stock: The products will be taken from the available stock.""")
     route_sequence = fields.Integer('Route Sequence', related='route_id.sequence', store=True)
     picking_type_id = fields.Many2one(
         'stock.picking.type', 'Operation Type',
-        required=True,
-        help="Operation Type determines the way the picking should be shown in the view, reports, ...")
-    delay = fields.Integer('Number of Days', default=0)
-    partner_address_id = fields.Many2one('res.partner', 'Partner Address')
+        required=True)
+    delay = fields.Integer('Delay', default=0, help="The expected date of the created transfer will be computed based on this delay.")
+    partner_address_id = fields.Many2one('res.partner', 'Partner Address', help="Address where goods should be delivered. Optional.")
     propagate = fields.Boolean(
         'Propagate cancel and split', default=True,
-        help='If checked, when the previous move of the move (which was generated by a next procurement) is cancelled or split, the move generated by this move will too')
-    warehouse_id = fields.Many2one('stock.warehouse', 'Served Warehouse', help='The warehouse this rule is for')
+        help="When ticked, if the move is splitted or cancelled, the next move will be too.")
+    warehouse_id = fields.Many2one('stock.warehouse', 'Warehouse')
     propagate_warehouse_id = fields.Many2one(
         'stock.warehouse', 'Warehouse to Propagate',
         help="The warehouse to propagate on the created move/procurement, which can be different of the warehouse this rule is for (e.g for resupplying rules from another warehouse)")
+    auto = fields.Selection([
+        ('manual', 'Manual Operation'),
+        ('transparent', 'Automatic No Step Added')], string='Automatic Move',
+        default='manual', index=True, required=True,
+        help="The 'Manual Operation' value will create a stock move after the current one. "
+             "With 'Automatic No Step Added', the location is replaced in the original move.")
+    rule_message = fields.Html(compute='_compute_action_message')
+
+    @api.onchange('picking_type_id')
+    def _onchange_picking_type(self):
+        """ Modify locations to the default picking type's locations source and
+        destination.
+        """
+        self.location_src_id = self.picking_type_id.default_location_src_id.id
+        self.location_id = self.picking_type_id.default_location_dest_id.id
+
+    @api.onchange('route_id', 'company_id')
+    def _onchange_route(self):
+        """ Ensure that the rule's company is the same than the route's company. """
+        self.company_id = self.route_id.company_id
+        if self.picking_type_id.warehouse_id.company_id != self.route_id.company_id:
+            self.picking_type_id = False
+        domain = {'company_id': self.route_id.company_id and [('id', '=', self.route_id.company_id.id)] or []}
+        return {'domain': domain}
+
+    def _get_message_values(self):
+        """ Return the source, destination and picking_type applied on a stock
+        rule. The purpose of this function is to avoid code duplication in
+        _get_message_dict functions since it often requires those data.
+        """
+        source = self.location_src_id and self.location_src_id.display_name or _('Source Location')
+        destination = self.location_id and self.location_id.display_name or _('Destination Location')
+        operation = self.picking_type_id and self.picking_type_id.name or _('Operation Type')
+        return source, destination, operation
+
+    def _get_message_dict(self):
+        """ Return a dict with the different possible message used for the
+        rule message. It should return one message for each stock.rule action
+        (except push and pull). This function is override in mrp and
+        purchase_stock in order to complete the dictionary.
+        """
+        message_dict = {}
+        source, destination, operation = self._get_message_values()
+        if self.action in ('push', 'pull', 'pull_push'):
+            suffix = ""
+            if self.procure_method == 'make_to_order' and self.location_src_id:
+                suffix = _("<br>A need is created in <b>%s</b> and a rule will be triggered to fulfill it.") % (source)
+            message_dict = {
+                'pull': _('When products are needed in <b>%s</b>, <br/> <b>%s</b> are created from <b>%s</b> to fulfill the need.') % (destination, operation, source) + suffix,
+                'push': _('When products arrive in <b>%s</b>, <br/> <b>%s</b> are created to send them in <b>%s</b>.') % (source, operation, destination)
+            }
+        return message_dict
+
+    @api.depends('action', 'location_id', 'location_src_id', 'picking_type_id', 'procure_method')
+    def _compute_action_message(self):
+        """ Generate dynamicaly a message that describe the rule purpose to the
+        end user.
+        """
+        for rule in self.filtered(lambda rule: rule.action):
+            message_dict = rule._get_message_dict()
+            message = message_dict.get(rule.action) and message_dict[rule.action] or ""
+            if rule.action == 'pull_push':
+                message = message_dict['pull'] + "<br/><br/>" + message_dict['push']
+            rule.rule_message = message
+
+    def _run_push(self, move):
+        """ Apply a push rule on a move.
+        If the rule is 'no step added' it will modify the destination location
+        on the move.
+        If the rule is 'manual operation' it will generate a new move in order
+        to complete the section define by the rule.
+        Care this function is not call by method run. It is called explicitely
+        in stock_move.py inside the method _push_apply
+        """
+        new_date = (datetime.strptime(move.date_expected, DEFAULT_SERVER_DATETIME_FORMAT) + relativedelta(days=self.delay)).strftime(DEFAULT_SERVER_DATETIME_FORMAT)
+        if self.auto == 'transparent':
+            move.write({
+                'date': new_date,
+                'date_expected': new_date,
+                'location_dest_id': self.location_id.id})
+            # avoid looping if a push rule is not well configured; otherwise call again push_apply to see if a next step is defined
+            if self.location_id != move.location_dest_id:
+                # TDE FIXME: should probably be done in the move model IMO
+                move._push_apply()
+        else:
+            new_move_vals = self._push_prepare_move_copy_values(move, new_date)
+            new_move = move.copy(new_move_vals)
+            move.write({'move_dest_ids': [(4, new_move.id)]})
+            new_move._action_confirm()
+
+    def _push_prepare_move_copy_values(self, move_to_copy, new_date):
+        new_move_vals = {
+            'origin': move_to_copy.origin or move_to_copy.picking_id.name or "/",
+            'location_id': move_to_copy.location_dest_id.id,
+            'location_dest_id': self.location_id.id,
+            'date': new_date,
+            'date_expected': new_date,
+            'company_id': self.company_id.id,
+            'picking_id': False,
+            'picking_type_id': self.picking_type_id.id,
+            'propagate': self.propagate,
+            'warehouse_id': self.warehouse_id.id,
+        }
+        return new_move_vals
 
-    def _run_move(self, product_id, product_qty, product_uom, location_id, name, origin, values):
+    def _run_pull(self, product_id, product_qty, product_uom, location_id, name, origin, values):
         if not self.location_src_id:
             msg = _('No source location defined on procurement rule: %s!') % (self.name, )
             raise UserError(msg)
@@ -83,7 +188,7 @@ class ProcurementRule(models.Model):
 
     def _get_stock_move_values(self, product_id, product_qty, product_uom, location_id, name, origin, values, group_id):
         ''' Returns a dictionary of values that will be used to create a stock move from a procurement.
-        This function assumes that the given procurement has a rule (action == 'move') set on it.
+        This function assumes that the given procurement has a rule (action == 'pull' or action == 'pull_push') set on it.
 
         :param procurement: browse record
         :rtype: dictionary
@@ -175,47 +280,55 @@ class ProcurementGroup(models.Model):
 
     @api.model
     def run(self, product_id, product_qty, product_uom, location_id, name, origin, values):
+        """ Method used in a procurement case. The purpose is to supply the
+        product passed as argument in the location also given as an argument.
+        In order to be able to find a suitable location that provide the product
+        it will search among stock.rule.
+        """
         values.setdefault('company_id', self.env['res.company']._company_default_get('procurement.group'))
         values.setdefault('priority', '1')
         values.setdefault('date_planned', fields.Datetime.now())
         rule = self._get_rule(product_id, location_id, values)
-
         if not rule:
             raise UserError(_('No procurement rule found in location "%s" for product "%s".\n Check routes configuration.') % (location_id.display_name, product_id.display_name))
-
-        if hasattr(rule, '_run_%s' % rule.action):
-            getattr(rule, '_run_%s' % rule.action)(product_id, product_qty, product_uom, location_id, name, origin, values)
+        action = 'pull' if rule.action == 'pull_push' else rule.action
+        if hasattr(rule, '_run_%s' % action):
+            getattr(rule, '_run_%s' % action)(product_id, product_qty, product_uom, location_id, name, origin, values)
         else:
-            _logger.error("The method _run_%s doesn't exist on the procument rules" % rule.action)
+            _logger.error("The method _run_%s doesn't exist on the procument rules" % action)
         return True
 
     @api.model
-    def _search_rule(self, product_id, values, domain):
+    def _search_rule(self, route_ids, product_id, warehouse_id, domain):
         """ First find a rule among the ones defined on the procurement
-        group; then try on the routes defined for the product; finally fallback
-        on the default behavior """
-        if values.get('warehouse_id', False):
-            domain = expression.AND([['|', ('warehouse_id', '=', values['warehouse_id'].id), ('warehouse_id', '=', False)], domain])
-        Pull = self.env['procurement.rule']
+        group, then try on the routes defined for the product, finally fallback
+        on the default behavior
+        """
+        if warehouse_id:
+            domain = expression.AND([['|', ('warehouse_id', '=', warehouse_id.id), ('warehouse_id', '=', False)], domain])
+        Rule = self.env['procurement.rule']
         res = self.env['procurement.rule']
-        if values.get('route_ids', False):
-            res = Pull.search(expression.AND([[('route_id', 'in', values['route_ids'].ids)], domain]), order='route_sequence, sequence', limit=1)
+        if route_ids:
+            res = Rule.search(expression.AND([[('route_id', 'in', route_ids.ids)], domain]), order='route_sequence, sequence', limit=1)
         if not res:
             product_routes = product_id.route_ids | product_id.categ_id.total_route_ids
             if product_routes:
-                res = Pull.search(expression.AND([[('route_id', 'in', product_routes.ids)], domain]), order='route_sequence, sequence', limit=1)
+                res = Rule.search(expression.AND([[('route_id', 'in', product_routes.ids)], domain]), order='route_sequence, sequence', limit=1)
         if not res:
-            warehouse_routes = values['warehouse_id'].route_ids
+            warehouse_routes = warehouse_id.route_ids
             if warehouse_routes:
-                res = Pull.search(expression.AND([[('route_id', 'in', warehouse_routes.ids)], domain]), order='route_sequence, sequence', limit=1)
+                res = Rule.search(expression.AND([[('route_id', 'in', warehouse_routes.ids)], domain]), order='route_sequence, sequence', limit=1)
         return res
 
     @api.model
     def _get_rule(self, product_id, location_id, values):
+        """ Find a pull rule for the location_id, fallback on the parent
+        locations if it could not be found.
+        """
         result = False
         location = location_id
         while (not result) and location:
-            result = self._search_rule(product_id, values, [('location_id', '=', location.id)])
+            result = self._search_rule(values.get('route_ids', False), product_id, values.get('warehouse_id', False), [('location_id', '=', location.id), ('action', '!=', 'push')])
             location = location.location_id
         return result
 

--- a/addons/stock/models/stock_location.py
+++ b/addons/stock/models/stock_location.py
@@ -148,12 +148,7 @@ class Route(models.Model):
     name = fields.Char('Route Name', required=True, translate=True)
     active = fields.Boolean('Active', default=True, help="If the active field is set to False, it will allow you to hide the route without removing it.")
     sequence = fields.Integer('Sequence', default=0)
-    pull_ids = fields.One2many('procurement.rule', 'route_id', 'Procurement Rules', copy=True, 
-        help="The demand represented by a procurement from e.g. a sale order, a reordering rule, another move, needs to be solved by applying a procurement rule. Depending on the action on the procurement rule,"\
-        "this triggers a purchase order, manufacturing order or another move. This way we create chains in the reverse order from the endpoint with the original demand to the starting point. "\
-        "That way, it is always known where we need to go and that is why they are preferred over push rules.")
-    push_ids = fields.One2many('stock.location.path', 'route_id', 'Push Rules', copy=True, 
-        help="When a move is foreseen to a location, the push rule will automatically create a move to a next location after. This is mainly only needed when creating manual operations e.g. 2/3 step manual purchase order or 2/3 step finished product manual manufacturing order. In other cases, it is important to use pull rules where you know where you are going based on a demand.")
+    rule_ids = fields.One2many('procurement.rule', 'route_id', 'Rules', copy=True)
     product_selectable = fields.Boolean('Applicable on Product', default=True, help="When checked, the route will be selectable in the Inventory tab of the Product form.  It will take priority over the Warehouse route. ")
     product_categ_selectable = fields.Boolean('Applicable on Product Category', help="When checked, the route will be selectable on the Product Category.  It will take priority over the Warehouse route. ")
     warehouse_selectable = fields.Boolean('Applicable on Warehouse', help="When a warehouse is selected for this route, this route should be seen as the default route when products pass through this warehouse.  This behaviour can be overridden by the routes on the Product/Product Categories or by the Preferred Routes on the Procurement")
@@ -167,13 +162,15 @@ class Route(models.Model):
     categ_ids = fields.Many2many('product.category', 'stock_location_route_categ', 'route_id', 'categ_id', 'Product Categories')
     warehouse_ids = fields.Many2many('stock.warehouse', 'stock_route_warehouse', 'route_id', 'warehouse_id', 'Warehouses')
 
-    def write(self, values):
-        '''when a route is deactivated, deactivate also its pull and push rules'''
-        res = super(Route, self).write(values)
-        if 'active' in values:
-            self.mapped('push_ids').filtered(lambda path: path.active != values['active']).write({'active': values['active']})
-            self.mapped('pull_ids').filtered(lambda rule: rule.active != values['active']).write({'active': values['active']})
-        return res
+    @api.onchange('warehouse_selectable')
+    def _onchange_warehouse_selectable(self):
+        if not self.warehouse_selectable:
+            self.warehouse_ids = []
+
+    def toggle_active(self):
+        for route in self:
+            route.with_context(active_test=False).rule_ids.filtered(lambda ru: ru.active == route.active).toggle_active()
+        super(Route, self).toggle_active()
 
     def view_product_ids(self):
         return {
@@ -194,70 +191,3 @@ class Route(models.Model):
             'type': 'ir.actions.act_window',
             'domain': [('route_ids', 'in', self.ids)],
         }
-
-
-class PushedFlow(models.Model):
-    _name = "stock.location.path"
-    _description = "Pushed Flow"
-    _order = "sequence, name"
-
-    name = fields.Char('Operation Name', required=True)
-    company_id = fields.Many2one(
-        'res.company', 'Company',
-        default=lambda self: self.env['res.company']._company_default_get('stock.location.path'), index=True)
-    route_id = fields.Many2one('stock.location.route', 'Route', required=True, ondelete='cascade')
-    location_from_id = fields.Many2one(
-        'stock.location', 'Source Location', index=True, ondelete='cascade', required=True,
-        help="This rule can be applied when a move is confirmed that has this location as destination location")
-    location_dest_id = fields.Many2one(
-        'stock.location', 'Destination Location', index=True, ondelete='cascade', required=True,
-        help="The new location where the goods need to go")
-    delay = fields.Integer('Delay (days)', default=0, help="Number of days needed to transfer the goods")
-    picking_type_id = fields.Many2one(
-        'stock.picking.type', 'Operation Type', required=True,
-        help="This is the operation type that will be put on the stock moves")
-    auto = fields.Selection([
-        ('manual', 'Manual Operation'),
-        ('transparent', 'Automatic No Step Added')], string='Automatic Move',
-        default='manual', index=True, required=True,
-        help="The 'Manual Operation' value will create a stock move after the current one. "
-             "With 'Automatic No Step Added', the location is replaced in the original move.")
-    propagate = fields.Boolean('Propagate cancel and split', default=True, help='If checked, when the previous move is cancelled or split, the move generated by this move will too')
-    active = fields.Boolean('Active', default=True)
-    warehouse_id = fields.Many2one('stock.warehouse', 'Warehouse')
-    route_sequence = fields.Integer('Route Sequence', related='route_id.sequence', store=True)
-    sequence = fields.Integer('Sequence')
-
-    def _apply(self, move):
-        new_date = (datetime.strptime(move.date_expected, DEFAULT_SERVER_DATETIME_FORMAT) + relativedelta.relativedelta(days=self.delay)).strftime(DEFAULT_SERVER_DATETIME_FORMAT)
-        if self.auto == 'transparent':
-            move.write({
-                'date': new_date,
-                'date_expected': new_date,
-                'location_dest_id': self.location_dest_id.id})
-            # avoid looping if a push rule is not well configured; otherwise call again push_apply to see if a next step is defined
-            if self.location_dest_id != move.location_dest_id:
-                # TDE FIXME: should probably be done in the move model IMO
-                move._push_apply()
-        else:
-            new_move_vals = self._prepare_move_copy_values(move, new_date)
-            new_move = move.copy(new_move_vals)
-            move.write({'move_dest_ids': [(4, new_move.id)]})
-            new_move._action_confirm()
-
-    def _prepare_move_copy_values(self, move_to_copy, new_date):
-        new_move_vals = {
-                'origin': move_to_copy.origin or move_to_copy.picking_id.name or "/",
-                'location_id': move_to_copy.location_dest_id.id,
-                'location_dest_id': self.location_dest_id.id,
-                'date': new_date,
-                'date_expected': new_date,
-                'company_id': self.company_id.id,
-                'picking_id': False,
-                'picking_type_id': self.picking_type_id.id,
-                'propagate': self.propagate,
-                'push_rule_id': self.id,
-                'warehouse_id': self.warehouse_id.id,
-            }
-
-        return new_move_vals

--- a/addons/stock/models/stock_move.py
+++ b/addons/stock/models/stock_move.py
@@ -123,8 +123,7 @@ class StockMove(models.Model):
     scrapped = fields.Boolean('Scrapped', related='location_dest_id.scrap_location', readonly=True, store=True)
     scrap_ids = fields.One2many('stock.scrap', 'move_id')
     group_id = fields.Many2one('procurement.group', 'Procurement Group', default=_default_group_id)
-    rule_id = fields.Many2one('procurement.rule', 'Procurement Rule', ondelete='restrict', help='The procurement rule that created this stock move')
-    push_rule_id = fields.Many2one('stock.location.path', 'Push Rule', ondelete='restrict', help='The push rule that created this stock move')
+    rule_id = fields.Many2one('procurement.rule', 'Stock Rule', ondelete='restrict', help='The stock rule that created this stock move')
     propagate = fields.Boolean(
         'Propagate cancel and split', default=True,
         help='If checked, when this move is cancelled, cancel the linked move too')
@@ -505,34 +504,20 @@ class StockMove(models.Model):
         return True
 
     def _push_apply(self):
-        # TDE CLEANME: I am quite sure I already saw this code somewhere ... in routing ??
-        Push = self.env['stock.location.path']
         for move in self:
             # if the move is already chained, there is no need to check push rules
             if move.move_dest_ids:
                 continue
             # if the move is a returned move, we don't want to check push rules, as returning a returned move is the only decent way
             # to receive goods without triggering the push rules again (which would duplicate chained operations)
-            domain = [('location_from_id', '=', move.location_dest_id.id)]
+            domain = [('location_src_id', '=', move.location_dest_id.id), ('action', 'in', ('push', 'pull_push'))]
             # first priority goes to the preferred routes defined on the move itself (e.g. coming from a SO line)
-            rules = self.env['stock.location.path']
-            if move.route_ids:
-                rules = Push.search(expression.AND([[('route_id', 'in', move.route_ids.ids)], domain]), order='route_sequence, sequence', limit=1)
-            # second priority goes to the route defined on the product and product category
-            if not rules:
-                product_routes = move.product_id.route_ids | move.product_id.categ_id.total_route_ids
-                if product_routes:
-                    rules = Push.search(expression.AND([[('route_id', 'in', product_routes.ids)], domain]), order='route_sequence, sequence', limit=1)
-            if not rules:
-                # TDE FIXME/ should those really be in a if / elif ??
-                # then we search on the warehouse if a rule can apply
-                if move.warehouse_id:
-                    rules = Push.search(expression.AND([[('route_id', 'in', move.warehouse_id.route_ids.ids)], domain]), order='route_sequence, sequence', limit=1)
-                elif move.picking_id.picking_type_id.warehouse_id:
-                    rules = Push.search(expression.AND([[('route_id', 'in', move.picking_id.picking_type_id.warehouse_id.route_ids.ids)], domain]), order='route_sequence, sequence', limit=1)
+            warehouse_id = move.warehouse_id or move.picking_id.picking_type_id.warehouse_id
+            rules = self.env['procurement.group']._search_rule(move.route_ids, move.product_id, warehouse_id, domain)
+
             # Make sure it is not returning the return
             if rules and (not move.origin_returned_move_id or move.origin_returned_move_id.location_dest_id.id != rules.location_dest_id.id):
-                rules._apply(move)
+                rules._run_push(move)
 
     def _merge_moves_fields(self):
         """ This method will return a dict of stock moveâ€™s values that represent the values of all moves in `self` merged. """

--- a/addons/stock/models/stock_warehouse.py
+++ b/addons/stock/models/stock_warehouse.py
@@ -19,7 +19,7 @@ class Warehouse(models.Model):
     _name = "stock.warehouse"
     _description = "Warehouse"
     # namedtuple used in helper methods generating values for routes
-    Routing = namedtuple('Routing', ['from_loc', 'dest_loc', 'picking_type'])
+    Routing = namedtuple('Routing', ['from_loc', 'dest_loc', 'picking_type', 'action'])
 
     name = fields.Char('Warehouse Name', index=True, required=True, default=lambda self: self.env['res.company']._company_default_get('stock.inventory').name)
     active = fields.Boolean('Active', default=True)
@@ -60,6 +60,7 @@ class Warehouse(models.Model):
     crossdock_route_id = fields.Many2one('stock.location.route', 'Crossdock Route', ondelete='restrict')
     reception_route_id = fields.Many2one('stock.location.route', 'Receipt Route', ondelete='restrict')
     delivery_route_id = fields.Many2one('stock.location.route', 'Delivery Route', ondelete='restrict')
+    warehouse_count = fields.Integer(compute='_compute_warehouse_count')
     resupply_wh_ids = fields.Many2many(
         'stock.warehouse', 'stock_wh_resupply_table', 'supplied_wh_id', 'supplier_wh_id',
         'Resupply Warehouses')
@@ -75,6 +76,11 @@ class Warehouse(models.Model):
         ('warehouse_code_uniq', 'unique(code, company_id)', 'The code of the warehouse must be unique per company!'),
     ]
 
+    @api.depends('name')
+    def _compute_warehouse_count(self):
+        for warehouse in self:
+            warehouse.warehouse_count = self.env['stock.warehouse'].search_count([('id', 'not in', warehouse.ids)])
+
     @api.depends('default_resupply_wh_id', 'resupply_wh_ids')
     def onchange_resupply_warehouses(self):
         # If we are removing the default resupply, we don't have default_resupply_wh_id # TDE note: and we want one
@@ -275,45 +281,36 @@ class Warehouse(models.Model):
             'crossdock_route_id': crossdock_route.id,
         }
 
+    def _find_existing_rule_or_create(self, rules_list):
+        """ This method will find existing rule or create new one"""
+        for rule_vals in rules_list:
+            existing_rule = self.env['procurement.rule'].search([
+                ('picking_type_id', '=', rule_vals['picking_type_id']),
+                ('location_src_id', '=', rule_vals['location_src_id']),
+                ('location_id', '=', rule_vals['location_id']),
+                ('route_id', '=', rule_vals['route_id']),
+                ('action', '=', rule_vals['action']),
+                ('active', '=', False),
+            ])
+            if not existing_rule:
+                self.env['procurement.rule'].create(rule_vals)
+            else:
+                existing_rule.write({'active': True})
+
     def _create_or_update_reception_route(self, routes_data):
         routes_data = routes_data or self.get_routes_dict()
         for warehouse in self:
             if warehouse.reception_route_id:
                 reception_route = warehouse.reception_route_id
                 reception_route.write({'name':  warehouse._format_routename(route_type=warehouse.reception_steps)})
-                reception_route.pull_ids.write({'active': False})
-                reception_route.push_ids.write({'active': False})
+                reception_route.rule_ids.write({'active': False})
             else:
                 warehouse.reception_route_id = reception_route = self.env['stock.location.route'].create(warehouse._get_reception_delivery_route_values(warehouse.reception_steps))
-            # push / procurement (pull) rules for reception
+            # procurement rules for reception
             routings = routes_data[warehouse.id][warehouse.reception_steps]
-            push_rules_list, pull_rules_list = warehouse._get_push_pull_rules_values(
-                routings, values={'active': True, 'route_id': reception_route.id},
-                push_values=None, pull_values={'procure_method': 'make_to_order'})
-            for push_vals in push_rules_list:
-                existing_push = self.env['stock.location.path'].search([
-                    ('picking_type_id', '=', push_vals['picking_type_id']),
-                    ('location_from_id', '=', push_vals['location_from_id']),
-                    ('location_dest_id', '=', push_vals['location_dest_id']),
-                    ('route_id', '=', push_vals['route_id']),
-                    ('active', '=', False),
-                ])
-                if not existing_push:
-                    self.env['stock.location.path'].create(push_vals)
-                else:
-                    existing_push.write({'active': True})
-            for pull_vals in pull_rules_list:
-                existing_pull = self.env['procurement.rule'].search([
-                    ('picking_type_id', '=', pull_vals['picking_type_id']),
-                    ('location_src_id', '=', pull_vals['location_src_id']),
-                    ('location_id', '=', pull_vals['location_id']),
-                    ('route_id', '=', pull_vals['route_id']),
-                    ('active', '=', False),
-                ])
-                if not existing_pull:
-                    self.env['procurement.rule'].create(pull_vals)
-                else:
-                    existing_pull.write({'active': True})
+            rules_list = warehouse._get_rule_values(
+                routings, values={'active': True, 'procure_method': 'make_to_order', 'route_id': reception_route.id})
+            warehouse._find_existing_rule_or_create(rules_list)
         return reception_route
 
     def _create_or_update_delivery_route(self, routes_data):
@@ -323,37 +320,27 @@ class Warehouse(models.Model):
             if warehouse.delivery_route_id:
                 delivery_route = warehouse.delivery_route_id
                 delivery_route.write({'name': warehouse._format_routename(route_type=warehouse.delivery_steps)})
-                delivery_route.pull_ids.write({'active': False})
+                delivery_route.rule_ids.write({'active': False})
             else:
                 delivery_route = self.env['stock.location.route'].create(warehouse._get_reception_delivery_route_values(warehouse.delivery_steps))
             # procurement (pull) rules for delivery
             routings = routes_data[warehouse.id][warehouse.delivery_steps]
-            dummy, pull_rules_list = warehouse._get_push_pull_rules_values(
+            rules_list = warehouse._get_rule_values(
                 routings, values={'active': True, 'route_id': delivery_route.id})
-            for pull_vals in pull_rules_list:
-                existing_pull = self.env['procurement.rule'].search([
-                    ('picking_type_id', '=', pull_vals['picking_type_id']),
-                    ('location_src_id', '=', pull_vals['location_src_id']),
-                    ('location_id', '=', pull_vals['location_id']),
-                    ('route_id', '=', pull_vals['route_id']),
-                    ('active', '=', False),
-                ])
-                if not existing_pull:
-                    self.env['procurement.rule'].create(pull_vals)
-                else:
-                    existing_pull.write({'active': True})
+            warehouse._find_existing_rule_or_create(rules_list)
         return delivery_route
 
     def _create_or_update_mto_pull(self, routes_data):
         """ Create MTO procurement rule and link it to the generic MTO route """
         routes_data = routes_data or self.get_routes_dict()
+        Rule = self.env['procurement.rule']
         for warehouse in self:
             routings = routes_data[warehouse.id][warehouse.delivery_steps]
             if warehouse.mto_pull_id:
                 mto_pull = warehouse.mto_pull_id
-                mto_pull.write(warehouse._get_mto_pull_rules_values(routings)[0])
+                mto_pull.write(warehouse._get_mto_rules_values(routings)[0])
             else:
-                mto_pull = self.env['procurement.rule'].create(warehouse._get_mto_pull_rules_values(routings)[0])
+                mto_pull = Rule.create(warehouse._get_mto_rules_values(routings)[0])
         return mto_pull
 
     def _create_or_update_crossdock_route(self, routes_data):
@@ -368,17 +355,16 @@ class Warehouse(models.Model):
                 crossdock_route = self.env['stock.location.route'].create(warehouse._get_crossdock_route_values())
                 # note: fixed cross-dock is logically mto
                 routings = routes_data[warehouse.id]['crossdock']
-                dummy, pull_rules_list = warehouse._get_push_pull_rules_values(
+                pull_list = warehouse._get_rule_values(
                     routings,
-                    values={'active': warehouse.delivery_steps != 'ship_only' and warehouse.reception_steps != 'one_step', 'route_id': crossdock_route.id},
-                    push_values=None, pull_values={'procure_method': 'make_to_order'})
-                for pull_vals in pull_rules_list:
-                    self.env['procurement.rule'].create(pull_vals)
+                    values={'procure_method': 'make_to_order', 'active': warehouse.delivery_steps != 'ship_only' and warehouse.reception_steps != 'one_step', 'route_id': crossdock_route.id})
+                for rule_vals in pull_list:
+                    self.env['procurement.rule'].create(rule_vals)
         return crossdock_route
 
     def create_resupply_routes(self, supplier_warehouses, default_resupply_wh):
         Route = self.env['stock.location.route']
-        Pull = self.env['procurement.rule']
+        Rule = self.env['procurement.rule']
 
         input_location, output_location = self._get_input_output_locations(self.reception_steps, self.delivery_steps)
         internal_transit_location, external_transit_location = self._get_transit_locations()
@@ -390,19 +376,19 @@ class Warehouse(models.Model):
             output_location = supplier_wh.lot_stock_id if supplier_wh.delivery_steps == 'ship_only' else supplier_wh.wh_output_stock_loc_id
             # Create extra MTO rule (only for 'ship only' because in the other cases MTO rules already exists)
             if supplier_wh.delivery_steps == 'ship_only':
-                Pull.create(supplier_wh._get_mto_pull_rules_values([
-                    self.Routing(output_location, transit_location, supplier_wh.out_type_id)])[0])
+                Rule.create(supplier_wh._get_mto_rules_values([
+                    self.Routing(output_location, transit_location, supplier_wh.out_type_id, 'pull')])[0])
 
             inter_wh_route = Route.create(self._get_inter_warehouse_route_values(supplier_wh))
 
             pull_rules_list = supplier_wh._get_supply_pull_rules_values(
-                [self.Routing(output_location, transit_location, supplier_wh.out_type_id)],
+                [self.Routing(output_location, transit_location, supplier_wh.out_type_id, 'pull')],
                 values={'route_id': inter_wh_route.id})
             pull_rules_list += self._get_supply_pull_rules_values(
-                [self.Routing(transit_location, input_location, self.in_type_id)],
+                [self.Routing(transit_location, input_location, self.in_type_id, 'pull')],
                 values={'route_id': inter_wh_route.id, 'propagate_warehouse_id': supplier_wh.id})
             for pull_rule_vals in pull_rules_list:
-                Pull.create(pull_rule_vals)
+                Rule.create(pull_rule_vals)
 
             # if the warehouse is also set as default resupply method, assign this route automatically to the warehouse
             if supplier_wh == default_resupply_wh:
@@ -444,21 +430,21 @@ class Warehouse(models.Model):
         customer_loc, supplier_loc = self._get_partner_locations()
         return dict((warehouse.id, {
             'one_step': [],
-            'two_steps': [self.Routing(warehouse.wh_input_stock_loc_id, warehouse.lot_stock_id, warehouse.int_type_id)],
+            'two_steps': [self.Routing(warehouse.wh_input_stock_loc_id, warehouse.lot_stock_id, warehouse.int_type_id, 'pull_push')],
             'three_steps': [
-                self.Routing(warehouse.wh_input_stock_loc_id, warehouse.wh_qc_stock_loc_id, warehouse.int_type_id),
-                self.Routing(warehouse.wh_qc_stock_loc_id, warehouse.lot_stock_id, warehouse.int_type_id)],
+                self.Routing(warehouse.wh_input_stock_loc_id, warehouse.wh_qc_stock_loc_id, warehouse.int_type_id, 'pull_push'),
+                self.Routing(warehouse.wh_qc_stock_loc_id, warehouse.lot_stock_id, warehouse.int_type_id, 'pull_push')],
             'crossdock': [
-                self.Routing(warehouse.wh_input_stock_loc_id, warehouse.wh_output_stock_loc_id, warehouse.int_type_id),
-                self.Routing(warehouse.wh_output_stock_loc_id, customer_loc, warehouse.out_type_id)],
-            'ship_only': [self.Routing(warehouse.lot_stock_id, customer_loc, warehouse.out_type_id)],
+                self.Routing(warehouse.wh_input_stock_loc_id, warehouse.wh_output_stock_loc_id, warehouse.int_type_id, 'pull'),
+                self.Routing(warehouse.wh_output_stock_loc_id, customer_loc, warehouse.out_type_id, 'pull')],
+            'ship_only': [self.Routing(warehouse.lot_stock_id, customer_loc, warehouse.out_type_id, 'pull')],
             'pick_ship': [
-                self.Routing(warehouse.lot_stock_id, warehouse.wh_output_stock_loc_id, warehouse.pick_type_id),
-                self.Routing(warehouse.wh_output_stock_loc_id, customer_loc, warehouse.out_type_id)],
+                self.Routing(warehouse.lot_stock_id, warehouse.wh_output_stock_loc_id, warehouse.pick_type_id, 'pull'),
+                self.Routing(warehouse.wh_output_stock_loc_id, customer_loc, warehouse.out_type_id, 'pull')],
             'pick_pack_ship': [
-                self.Routing(warehouse.lot_stock_id, warehouse.wh_pack_stock_loc_id, warehouse.pick_type_id),
-                self.Routing(warehouse.wh_pack_stock_loc_id, warehouse.wh_output_stock_loc_id, warehouse.pack_type_id),
-                self.Routing(warehouse.wh_output_stock_loc_id, customer_loc, warehouse.out_type_id)],
+                self.Routing(warehouse.lot_stock_id, warehouse.wh_pack_stock_loc_id, warehouse.pick_type_id, 'pull'),
+                self.Routing(warehouse.wh_pack_stock_loc_id, warehouse.wh_output_stock_loc_id, warehouse.pack_type_id,'pull'),
+                self.Routing(warehouse.wh_output_stock_loc_id, customer_loc, warehouse.out_type_id, 'pull')],
             'company_id': warehouse.company_id.id,
         }) for warehouse in self)
 
@@ -466,6 +452,7 @@ class Warehouse(models.Model):
         return {
             'name': self._format_routename(route_type=route_type),
             'product_categ_selectable': True,
+            'warehouse_selectable': True,
             'product_selectable': False,
             'company_id': self.company_id.id,
             'sequence': 10,
@@ -484,7 +471,7 @@ class Warehouse(models.Model):
     def _get_inter_warehouse_route_values(self, supplier_warehouse):
         return {
             'name': _('%s: Supply Product from %s') % (self.name, supplier_warehouse.name),
-            'warehouse_selectable': False,
+            'warehouse_selectable': True,
             'product_selectable': True,
             'product_categ_selectable': True,
             'supplied_wh_id': self.id,
@@ -495,7 +482,7 @@ class Warehouse(models.Model):
     def _get_crossdock_route_values(self):
         return {
             'name': self._format_routename(route_type='crossdock'),
-            'warehouse_selectable': False,
+            'warehouse_selectable': True,
             'product_selectable': True,
             'product_categ_selectable': True,
             'active': self.delivery_steps != 'ship_only' and self.reception_steps != 'one_step',
@@ -506,52 +493,44 @@ class Warehouse(models.Model):
     # Pull / Push tools
     # ------------------------------------------------------------
 
-    def _get_push_pull_rules_values(self, route_values, values=None, push_values=None, pull_values=None, name_suffix=''):
+
+    def _get_rule_values(self, route_values, values=None, name_suffix=''):
         first_rule = True
-        push_rules_list, pull_rules_list = [], []
+        rules_list = []
         for routing in route_values:
-            route_push_values = {
-                'name': self._format_rulename(routing.from_loc, routing.dest_loc, name_suffix),
-                'location_from_id': routing.from_loc.id,
-                'location_dest_id': routing.dest_loc.id,
-                'auto': 'manual',
-                'picking_type_id': routing.picking_type.id,
-                'warehouse_id': self.id,
-                'company_id': self.company_id.id,
-            }
-            route_push_values.update(values or {})
-            route_push_values.update(push_values or {})
-            push_rules_list.append(route_push_values)
-            route_pull_values = {
+            route_rule_values = {
                 'name': self._format_rulename(routing.from_loc, routing.dest_loc, name_suffix),
                 'location_src_id': routing.from_loc.id,
                 'location_id': routing.dest_loc.id,
-                'action': 'move',
+                'action': routing.action,
+                'auto': 'manual',
                 'picking_type_id': routing.picking_type.id,
                 'procure_method': first_rule is True and 'make_to_stock' or 'make_to_order',
                 'warehouse_id': self.id,
                 'company_id': self.company_id.id,
                 'propagate': routing.picking_type != self.pick_type_id,
             }
-            route_pull_values.update(values or {})
-            route_pull_values.update(pull_values or {})
-            pull_rules_list.append(route_pull_values)
+            route_rule_values.update(values or {})
+            rules_list.append(route_rule_values)
             first_rule = False
-        return push_rules_list, pull_rules_list
+        return rules_list
 
-    def _get_mto_pull_rules_values(self, route_values):
+    def _get_mto_rules_values(self, route_values):
         mto_route = self._get_mto_route()
-        dummy, pull_rules_list = self._get_push_pull_rules_values(route_values, pull_values={
+        rules_list = self._get_rule_values(route_values, values={
             'route_id': mto_route.id,
             'procure_method': 'make_to_order',
             'active': True}, name_suffix=_('MTO'))
-        return pull_rules_list
+        return rules_list
 
     def _get_supply_pull_rules_values(self, route_values, values=None):
-        dummy, pull_rules_list = self._get_push_pull_rules_values(route_values, values=values, pull_values={'active': True})
-        for pull_rules in pull_rules_list:
+        pull_values = {}
+        pull_values.update(values)
+        pull_values.update({'active': True})
+        rules_list = self._get_rule_values(route_values, values=pull_values)
+        for pull_rules in rules_list:
             pull_rules['procure_method'] = self.lot_stock_id.id != pull_rules['location_src_id'] and 'make_to_order' or 'make_to_stock'  # first part of the resuply route is MTS
-        return pull_rules_list
+        return rules_list
 
     def _update_reception_delivery_resupply(self, reception_new, delivery_new):
         """ Check if we need to change something to resupply warehouses and associated MTO rules """
@@ -566,23 +545,24 @@ class Warehouse(models.Model):
     def _check_delivery_resupply(self, new_location, change_to_multiple):
         """ Check if the resupply routes from this warehouse follow the changes of number of delivery steps
         Check routes being delivery bu this warehouse and change the rule going to transit location """
-        Pull = self.env["procurement.rule"]
+        Rule = self.env["procurement.rule"]
         routes = self.env['stock.location.route'].search([('supplier_wh_id', '=', self.id)])
-        pulls = Pull.search(['&', ('route_id', 'in', routes.ids), ('location_id.usage', '=', 'transit')])
-        pulls.write({
+        rules = Rule.search(['&', '&', ('route_id', 'in', routes.ids), ('action', '!=', 'push'), ('location_id.usage', '=', 'transit')])
+        rules.write({
             'location_src_id': new_location.id,
             'procure_method': change_to_multiple and "make_to_order" or "make_to_stock"})
         if not change_to_multiple:
             # If single delivery we should create the necessary MTO rules for the resupply
-            routings = [self.Routing(self.lot_stock_id , location, self.out_type_id) for location in pulls.mapped('location_id')]
-            mto_pull_vals = self._get_mto_pull_rules_values(routings)
-            for mto_pull_val in mto_pull_vals:
-                Pull.create(mto_pull_val)
+            routings = [self.Routing(self.lot_stock_id, location, self.out_type_id) for location in rules.mapped('location_id')]
+            mto_rule_vals = self._get_rule_values(routings)
+            for mto_rule_val in mto_rule_vals:
+                Rule.create(mto_rule_val)
         else:
             # We need to delete all the MTO procurement rules, otherwise they risk to be used in the system
-            Pull.search([
+            Rule.search([
                 '&', ('route_id', '=', self._get_mto_route().id),
                 ('location_id.usage', '=', 'transit'),
+                ('action', '!=', 'push'),
                 ('location_src_id', '=', self.lot_stock_id.id)]).write({'active': False})
 
     def _check_reception_resupply(self, new_location):
@@ -590,8 +570,12 @@ class Warehouse(models.Model):
         change their rule coming from the transit location """
         routes = self.env['stock.location.route'].search([('supplied_wh_id', 'in', self.ids)])
         self.env['procurement.rule'].search([
-            '&', ('route_id', 'in', routes.ids),
-            ('location_src_id.usage', '=', 'transit')]).write({'location_id': new_location.id})
+            '&',
+                ('route_id', 'in', routes.ids),
+                '&',
+                    ('action', '!=', 'push'),
+                    ('location_src_id.usage', '=', 'transit')
+        ]).write({'location_id': new_location.id})
 
     def _update_routes(self):
         routes_data = self.get_routes_dict()
@@ -625,10 +609,8 @@ class Warehouse(models.Model):
                 routes = warehouse.route_ids
                 for route in routes:
                     route.write({'name': route.name.replace(warehouse.name, new_name, 1)})
-                    for pull in route.pull_ids:
+                    for pull in route.rule_ids:
                         pull.write({'name': pull.name.replace(warehouse.name, new_name, 1)})
-                    for push in route.push_ids:
-                        push.write({'name': push.name.replace(warehouse.name, new_name, 1)})
                 if warehouse.mto_pull_id:
                     warehouse.mto_pull_id.write({'name': warehouse.mto_pull_id.name.replace(warehouse.name, new_name, 1)})
         for warehouse in self:
@@ -662,19 +644,12 @@ class Warehouse(models.Model):
             self.mapped('wh_output_stock_loc_id').write({'active': True})
 
     def _location_used(self, location):
-        pulls = self.env['procurement.rule'].search_count([
+        rules = self.env['procurement.rule'].search_count([
             '&',
             ('route_id', 'not in', [x.id for x in self.route_ids]),
             '|', ('location_src_id', '=', location.id),
             ('location_id', '=', location.id)])
-        if pulls:
-            return True
-        pushs = self.env['stock.location.path'].search_count([
-            '&',
-            ('route_id', 'not in', [x.id for x in self.route_ids]),
-            '|', ('location_from_id', '=', location.id),
-            ('location_dest_id', '=', location.id)])
-        if pushs:
+        if rules:
             return True
         return False
 
@@ -703,7 +678,10 @@ class Warehouse(models.Model):
         }
 
     def _format_rulename(self, from_loc, dest_loc, suffix):
-        return '%s: %s -> %s%s' % (self.code, from_loc.name, dest_loc.name, suffix)
+        rulename = '%s: %s â†’ %s' % (self.code, from_loc.name, dest_loc.name)
+        if suffix:
+            rulename += ' (' + suffix + ')'
+        return rulename
 
     def _format_routename(self, name=None, route_type=None):
         if route_type:
