PR: https://github.com/odoo/odoo/pull/

From: 90c055cd35fc0863f16001b5a3eaa8999ac224cb
From: Simon Lejeune
Date: 2019-08-07 14:11:21

Structural Changes: 6
Total Changes: 93

[REF] stock_landed_costs: create from vendor bill

Add a many2one on the landed cost to the vendor bill. Allow to create a
landed cost from a vendor bill if the product is a service. It will use
the price_subtotal of the account move line. Add a is_landed_costs_line
to separate products of landed costs on the account move line. It's a
checkbox. Ticking the checkbox will change the account of the account
move if the company is in anglo saxon accounting.

Tweak the accounts used by the landed costs so that everything is well
balanced (see the added tests). Auto reconcile AML when possible.

task-59011

================================= pseudo patch: =================================

--- a/addons/stock_landed_costs/models/__init__.py
+++ b/addons/stock_landed_costs/models/__init__.py
@@ -5,5 +5,6 @@ from . import product
 from . import res_company
 from . import res_config_settings
 from . import stock_landed_cost
+from . import account_move
 from . import stock_valuation_layer
 

--- a/None
+++ b/addons/stock_landed_costs/models/account_move.py
@@ -0,0 +1,75 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from odoo import api, fields, models
+
+
+class AccountMove(models.Model):
+    _inherit = 'account.move'
+
+    landed_costs_ids = fields.One2many('stock.landed.cost', 'vendor_bill_id', string='Landed Costs')
+    landed_costs_visible = fields.Boolean(compute='_compute_landed_costs_visible')
+
+    @api.depends('line_ids', 'line_ids.is_landed_costs_line')
+    def _compute_landed_costs_visible(self):
+        for account_move in self:
+            if account_move.landed_costs_ids:
+                account_move.landed_costs_visible = False
+            else:
+                account_move.landed_costs_visible = any(line.is_landed_costs_line for line in account_move.line_ids)
+
+    def button_create_landed_costs(self):
+        """Create a `stock.landed.cost` record associated to the account move of `self`, each
+        `stock.landed.costs` lines mirroring the current `account.move.line` of self.
+        """
+        self.ensure_one()
+        landed_costs_lines = self.line_ids.filtered(lambda line: line.is_landed_costs_line)
+
+        landed_costs = self.env['stock.landed.cost'].create({
+            'vendor_bill_id': self.id,
+            'cost_lines': [(0, 0, {
+                'product_id': l.product_id.id,
+                'name': l.product_id.name,
+                'account_id': l.product_id.product_tmpl_id.get_product_accounts()['stock_input'].id,
+                'price_unit': l.price_subtotal,
+                'split_method': 'equal',
+            }) for l in landed_costs_lines],
+        })
+        action = self.env.ref('stock_landed_costs.action_stock_landed_cost').read()[0]
+        return dict(action, view_mode='form', res_id=landed_costs.id, views=[(False, 'form')])
+
+    def action_view_landed_costs(self):
+        self.ensure_one()
+        action = self.env.ref('stock_landed_costs.action_stock_landed_cost').read()[0]
+        domain = [('id', 'in', self.landed_costs_ids.ids)]
+        context = dict(self.env.context, default_vendor_bill_id=self.id)
+        views = [(self.env.ref('stock_landed_costs.view_stock_landed_cost_tree2').id, 'tree'), (False, 'form'), (False, 'kanban')]
+        return dict(action, domain=domain, context=context, views=views)
+
+
+class AccountMoveLine(models.Model):
+    _inherit = 'account.move.line'
+
+    product_type = fields.Selection(related='product_id.type', readonly=True)
+    is_landed_costs_line = fields.Boolean()
+
+    @api.onchange('is_landed_costs_line')
+    def _onchange_is_landed_costs_line(self):
+        """Mark an invoice line as a landed cost line and adapt `self.account_id`. The default
+        value can be set according to `self.product_id.landed_cost_ok`."""
+        if self.product_id:
+            accounts = self.product_id.product_tmpl_id._get_product_accounts()
+            if self.product_type != 'service':
+                self.account_id = accounts['expense']
+                self.is_landed_costs_line = False
+            elif self.is_landed_costs_line and self.move_id.company_id.anglo_saxon_accounting:
+                self.account_id = accounts['stock_input']
+            else:
+                self.account_id = accounts['expense']
+
+    @api.onchange('product_id')
+    def _onchange_is_landed_costs_line_product(self):
+        if self.product_id.landed_cost_ok:
+            self.is_landed_costs_line = True
+        else:
+            self.is_landed_costs_line = False

--- a/addons/stock_landed_costs/models/stock_landed_cost.py
+++ b/addons/stock_landed_costs/models/stock_landed_cost.py
@@ -118,6 +118,7 @@ class LandedCost(models.Model):
                 'date': cost.date,
                 'ref': cost.name,
                 'line_ids': [],
+                'type': 'entry',
             }
             for line in cost.valuation_adjustment_lines.filtered(lambda line: line.move_id):
                 remaining_qty = sum(line.move_id.stock_valuation_layer_ids.mapped('remaining_qty'))
@@ -155,6 +156,13 @@ class LandedCost(models.Model):
             move = move.create(move_vals)
             cost.write({'state': 'done', 'account_move_id': move.id})
             move.post()
+
+            if cost.vendor_bill_id and cost.vendor_bill_id.state == 'posted' and cost.company_id.anglo_saxon_accounting:
+                all_amls = cost.vendor_bill_id.line_ids | cost.account_move_id.line_ids
+                for product in cost.cost_lines.product_id:
+                    accounts = product.product_tmpl_id.get_product_accounts()
+                    input_account = accounts['stock_input']
+                    all_amls.filtered(lambda aml: aml.account_id == input_account).reconcile()
         return True
 
     def _check_sum(self):
@@ -285,7 +293,8 @@ class LandedCostLine(models.Model):
         self.name = self.product_id.name or ''
         self.split_method = 'equal'
         self.price_unit = self.product_id.standard_price or 0.0
-        self.account_id = self.product_id.property_account_expense_id.id or self.product_id.categ_id.property_account_expense_categ_id.id
+        accounts_data = self.product_id.product_tmpl_id.get_product_accounts()
+        self.account_id = accounts_data['stock_input']
 
 
 class AdjustmentLines(models.Model):
@@ -341,7 +350,7 @@ class AdjustmentLines(models.Model):
         if self.move_id._is_dropshipped():
             debit_account_id = accounts.get('expense') and accounts['expense'].id or False
         already_out_account_id = accounts['stock_output'].id
-        credit_account_id = self.cost_line_id.account_id.id or cost_product.property_account_expense_id.id or cost_product.categ_id.property_account_expense_categ_id.id
+        credit_account_id = self.cost_line_id.account_id.id or cost_product.categ_id.property_stock_account_input_categ_id.id
 
         if not credit_account_id:
             raise UserError(_('Please configure Stock Expense Account for product: %s.') % (cost_product.name))
@@ -394,12 +403,12 @@ class AdjustmentLines(models.Model):
             AccountMoveLine.append([0, 0, debit_line])
             AccountMoveLine.append([0, 0, credit_line])
 
-            # TDE FIXME: oh dear
             if self.env.company.anglo_saxon_accounting:
+                expense_account_id = self.product_id.product_tmpl_id.get_product_accounts()['expense'].id
                 debit_line = dict(base_line,
                                   name=(self.name + ": " + str(qty_out) + _(' already out')),
                                   quantity=0,
-                                  account_id=credit_account_id)
+                                  account_id=expense_account_id)
                 credit_line = dict(base_line,
                                    name=(self.name + ": " + str(qty_out) + _(' already out')),
                                    quantity=0,
