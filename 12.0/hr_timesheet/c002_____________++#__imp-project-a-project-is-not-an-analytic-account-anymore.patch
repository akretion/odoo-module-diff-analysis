PR: https://github.com/odoo/odoo/pull/

From: 3dd3e2648329995ddc309081787e19005d48ccd0
From: jem-odoo
Date: 2018-04-06 12:30:47

Structural Changes: 7
Total Changes: 139

[IMP] project: a project is not an analytic account anymore !

This commit removes the inheritS between account.analytic.account and
project.project. This means :
- When a project is created, an analytic account is not necessarily
genareted
- project has now its own name, company_id and partner_id fields
- an analytic account can be linked to several project
- project module does not depend anymore of analytic, but hr_timesheet
does.

This change implied
- an analytic account is required on project to timesheet on
its tasks. So, when checking 'allow_timsheets', if an AA is not
provided at project creation, an AA will be generated.
- to timesheet on project, an active AA is required. We don't want
timesheeting on project linked to unused AA to avoid bad analytic
entries.

This prepare the fact a sale order can create multiple project, sharing
the same analytic account (the one from the SO).

================================= pseudo patch: =================================

--- a/addons/hr_timesheet/models/__init__.py
+++ b/addons/hr_timesheet/models/__init__.py
@@ -1,6 +1,7 @@
 # -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
+from . import analytic_account
 from . import hr
 from . import hr_timesheet
 from . import res_config_settings

--- a/None
+++ b/addons/hr_timesheet/models/analytic_account.py
@@ -0,0 +1,47 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from odoo import api, fields, models, _
+from odoo.exceptions import UserError
+
+
+class AccountAnalyticAccount(models.Model):
+    _inherit = 'account.analytic.account'
+    _description = 'Analytic Account'
+
+    company_uom_id = fields.Many2one('uom.uom', related='company_id.project_time_mode_id', string="Company UOM")
+    project_ids = fields.One2many('project.project', 'analytic_account_id', string='Projects')
+    project_count = fields.Integer("Project Count", compute='_compute_project_count')
+
+    @api.multi
+    def _compute_project_count(self):
+        project_data = self.env['project.project'].read_group([('analytic_account_id', 'in', self.ids)], ['analytic_account_id'], ['analytic_account_id'])
+        mapping = {m['analytic_account_id'][0]: m['analytic_account_id_count'] for m in project_data}
+        for account in self:
+            account.project_count = mapping.get(account.id, 0)
+
+    @api.multi
+    def unlink(self):
+        projects = self.env['project.project'].search([('analytic_account_id', 'in', self.ids)])
+        has_tasks = self.env['project.task'].search_count([('project_id', 'in', projects.ids)])
+        if has_tasks:
+            raise UserError(_('Please remove existing tasks in the project linked to the accounts you want to delete.'))
+        return super(AccountAnalyticAccount, self).unlink()
+
+    @api.multi
+    def action_view_projects(self):
+        projects = self.mapped('project_ids')
+        result = {
+            "type": "ir.actions.act_window",
+            "res_model": "project.project",
+            "views": [[False, "tree"], [False, "form"]],
+            "domain": [["id", "in", projects.ids]],
+            "context": {"create": False},
+            "name": "Projects",
+        }
+        if len(projects) == 1:
+            result['views'] = [(False, "form")]
+            result['res_id'] = projects.id
+        else:
+            result = {'type': 'ir.actions.act_window_close'}
+        return result

--- a/addons/hr_timesheet/models/hr_timesheet.py
+++ b/addons/hr_timesheet/models/hr_timesheet.py
@@ -1,7 +1,8 @@
 # -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
-from odoo import api, fields, models
+from odoo import api, fields, models, _
+from odoo.exceptions import UserError
 
 
 class AccountAnalyticLine(models.Model):
@@ -64,6 +65,8 @@ class AccountAnalyticLine(models.Model):
         if vals.get('project_id') and not vals.get('account_id'):
             project = self.env['project.project'].browse(vals.get('project_id'))
             vals['account_id'] = project.analytic_account_id.id
+            if not project.analytic_account_id.active:
+                raise UserError(_('The project you are timesheeting on is not linked to a active analytic account. Please the project configuration.'))
         # employee implies user
         if vals.get('employee_id') and not vals.get('user_id'):
             employee = self.env['hr.employee'].browse(vals['employee_id'])

--- a/addons/hr_timesheet/models/project.py
+++ b/addons/hr_timesheet/models/project.py
@@ -1,20 +1,89 @@
 # -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
-from odoo import models, fields, api
-from odoo.exceptions import UserError
-from odoo.tools.translate import _
+from odoo import models, fields, api, _
+from odoo.exceptions import UserError, ValidationError
 
 
 class Project(models.Model):
     _inherit = "project.project"
 
     allow_timesheets = fields.Boolean("Allow timesheets", default=True)
+    analytic_account_id = fields.Many2one('account.analytic.account', string="Analytic Account", ondelete='set null',
+        help="Link this project to an analytic account if you need financial management on projects. "
+             "It enables you to connect projects with budgets, planning, cost and revenue analysis, timesheets on projects, etc.")
+
+    @api.onchange('partner_id')
+    def _onchange_partner_id(self):
+        domain = []
+        if self.partner_id:
+            domain = [('partner_id', '=', self.partner_id.id)]
+        return {'domain': {'analytic_account_id': domain}}
+
+    @api.constrains('allow_timesheets', 'analytic_account_id')
+    def _check_allow_timesheet(self):
+        for project in self:
+            if project.allow_timesheets and not project.analytic_account_id:
+                raise ValidationError(_('To allow timesheet, your project %s should have an analytic account set.' % (project.name,)))
+
+    @api.model
+    def name_create(self, name):
+        """ Create a project with name_create should generate analytic account creation """
+        values = {
+            'name': name,
+            'allow_timesheets': True,
+        }
+        return self.create(values).name_get()[0]
+
+    @api.model
+    def create(self, values):
+        """ Create an analytic account if project allow timesheet and don't provide one """
+        allow_timesheets = values['allow_timesheets'] if 'allow_timesheets' in values else self.default_get(['allow_timesheets'])['allow_timesheets']
+        if allow_timesheets and not values.get('analytic_account_id'):
+            analytic_account = self._create_analytic_account(values)
+            values['analytic_account_id'] = analytic_account.id
+        return super(Project, self).create(values)
+
+    @api.multi
+    def write(self, values):
+        result = super(Project, self).write(values)
+        if values.get('allow_timesheets'):
+            for project in self:
+                if not project.analytic_account_id:
+                    analytic_account = project._create_analytic_account({
+                        'name': project.name,
+                        'company_id': project.company_id.id,
+                        'partner_id': project.partner_id.id,
+                    })
+                    project.write({'analytic_account_id': analytic_account.id})
+        return result
+
+    @api.multi
+    def unlink(self):
+        """ Delete the empty related analytic account """
+        analytic_accounts_to_delete = self.env['account.analytic.account']
+        for project in self:
+            if project.analytic_account_id and not project.analytic_account_id.line_ids:
+                analytic_accounts_to_delete |= project.analytic_account_id
+        result = super(Project, self).unlink()
+        analytic_accounts_to_delete.unlink()
+        return result
+
+    def _create_analytic_account(self, values):
+        analytic_account = self.env['account.analytic.account'].create({
+            'name': values.get('name', _('Unkwon Analytic Account')),
+            'company_id': values.get('company_id', self.env.user.company_id.id),
+            'partner_id': values.get('partner_id'),
+            'active': True,
+        })
+        return analytic_account
 
 
 class Task(models.Model):
     _inherit = "project.task"
 
+    analytic_account_id = fields.Many2one('account.analytic.account', string="Analytic Account", related='project_id.analytic_account_id', readonly=True)
+    allow_timesheets = fields.Boolean("Allow timesheets", compute='_compute_allow_timesheets', help="Timesheets can be logged on this task.")
     remaining_hours = fields.Float("Remaining Hours", compute='_compute_progress_hours', inverse='_inverse_remaining_hours', store=True, help="Total remaining time, can be re-estimated periodically by the assignee of the task.")
     effective_hours = fields.Float("Hours Spent", compute='_compute_effective_hours', compute_sudo=True, store=True, help="Computed using the sum of the task work done.")
     total_hours_spent = fields.Float("Total Hours", compute='_compute_progress_hours', store=True, help="Computed as: Time Spent + Sub-tasks Hours.")
@@ -22,10 +91,10 @@ class Task(models.Model):
     subtask_effective_hours = fields.Float("Sub-tasks Hours Spent", compute='_compute_subtask_effective_hours', store=True, help="Sum of actually spent hours on the subtask(s)", oldname='children_hours')
     timesheet_ids = fields.One2many('account.analytic.line', 'task_id', 'Timesheets')
 
-    @api.onchange('remaining_hours')
-    def _inverse_remaining_hours(self):
+    @api.depends('project_id.allow_timesheets', 'project_id.analytic_account_id')
+    def _compute_allow_timesheets(self):
         for task in self:
-            task.planned_hours = task.remaining_hours + task.effective_hours + task.subtask_effective_hours
+            task.allow_timesheets = task.project_id.allow_timesheets and task.project_id.analytic_account_id.active
 
     @api.depends('timesheet_ids.unit_amount')
     def _compute_effective_hours(self):
@@ -47,6 +116,11 @@ class Task(models.Model):
             task.remaining_hours = task.planned_hours - task.effective_hours - task.subtask_effective_hours
             task.total_hours_spent = task.effective_hours + task.subtask_effective_hours
 
+    @api.onchange('remaining_hours')
+    def _inverse_remaining_hours(self):
+        for task in self:
+            task.planned_hours = task.remaining_hours + task.effective_hours + task.subtask_effective_hours
+
     @api.depends('child_ids.effective_hours', 'child_ids.subtask_effective_hours')
     def _compute_subtask_effective_hours(self):
         for task in self:
