PR: https://github.com/odoo/odoo/pull/

From: 943da6df0f1d39e8e10869b25c5ba8cc13a2aa54
From: Arnold Moyaux
Date: 2020-04-22 07:52:45

Structural Changes: 15
Total Changes: 283

[IMP] stock, purchase_stock, mrp: Replenishment Report

New report to easily order missing products in each warehouse.
Orderpoint have a new type: 'manual'. Manual orderpoint are not
trigger by the scheduler but the user could create replenishment
from the report directly. The report use the forecast report in
order to detect missing quantity for today (it does not search
depending the lead time for each product warehouse due to lake
of performance). It compares missing quantity with incoming RFQ
and other ongoing orderpoint. If it still missing a new entry
for replenihsment is created (it's also automaticaly deleted if
the replenihsment has been done another way).

Task: 2161378

================================= pseudo patch: =================================

--- a/addons/stock/models/product.py
+++ b/addons/stock/models/product.py
@@ -2,8 +2,10 @@
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
 import operator as py_operator
+from ast import literal_eval
+from collections import defaultdict
 
-from odoo import _, api, fields, models
+from odoo import _, api, fields, models, SUPERUSER_ID
 from odoo.exceptions import UserError
 from odoo.osv import expression
 from odoo.tools.float_utils import float_round
@@ -424,6 +426,22 @@ class Product(models.Model):
                         res['fields']['qty_available']['string'] = _('Produced Qty')
         return res
 
+    def action_view_orderpoints(self):
+        action = self.env.ref('stock.action_orderpoint').read()[0]
+        action['context'] = literal_eval(action.get('context'))
+        action['context'].pop('search_default_trigger', False)
+        action['context'].update({
+            'search_default_filter_not_snoozed': True,
+        })
+        if self and len(self) == 1:
+            action['context'].update({
+                'default_product_id': self.ids[0],
+                'search_default_product_id': self.ids[0]
+            })
+        else:
+            action['domain'] = expression.AND([action.get('domain', []), [('product_id', 'in', self.ids)]])
+        return action
+
     def action_view_routes(self):
         return self.mapped('product_tmpl_id').action_view_routes()
 
@@ -518,6 +536,9 @@ class Product(models.Model):
             })
         return super().write(values)
 
+    def _get_quantity_in_progress(self, location_ids=False, warehouse_ids=False):
+        return defaultdict(float), defaultdict(float)
+
     def _get_rules_from_location(self, location, route_ids=False, seen_rules=False):
         if not seen_rules:
             seen_rules = self.env['stock.rule']
@@ -742,14 +763,7 @@ class ProductTemplate(models.Model):
         return self._get_action_view_related_putaway_rules(domain)
 
     def action_view_orderpoints(self):
-        products = self.mapped('product_variant_ids')
-        action = self.env.ref('stock.product_open_orderpoint').read()[0]
-        if products and len(products) == 1:
-            action['context'] = {'default_product_id': products.ids[0], 'search_default_product_id': products.ids[0]}
-        else:
-            action['domain'] = [('product_id', 'in', products.ids)]
-            action['context'] = {}
-        return action
+        return self.product_variant_ids.action_view_orderpoints()
 
     def action_view_stock_move_lines(self):
         self.ensure_one()

--- a/addons/stock/models/stock_orderpoint.py
+++ b/addons/stock/models/stock_orderpoint.py
@@ -5,6 +5,7 @@ import logging
 from collections import defaultdict
 from datetime import datetime, time
 from dateutil import relativedelta
+from itertools import groupby
 from json import dumps
 from psycopg2 import OperationalError
 
@@ -38,18 +39,22 @@ class StockWarehouseOrderpoint(models.Model):
     name = fields.Char(
         'Name', copy=False, required=True, readonly=True,
         default=lambda self: self.env['ir.sequence'].next_by_code('stock.orderpoint'))
+    trigger = fields.Selection([
+        ('auto', 'Auto'), ('manual', 'Manual')], string='Trigger', default='auto', required=True)
     active = fields.Boolean(
         'Active', default=True,
         help="If the active field is set to False, it will allow you to hide the orderpoint without removing it.")
+    snoozed_until = fields.Date('Snoozed', help="Hidden until next scheduler.")
     warehouse_id = fields.Many2one(
         'stock.warehouse', 'Warehouse',
         check_company=True, ondelete="cascade", required=True)
     location_id = fields.Many2one(
-        'stock.location', 'Location',
+        'stock.location', 'Location', index=True,
         ondelete="cascade", required=True, check_company=True)
     product_id = fields.Many2one(
-        'product.product', 'Product',
+        'product.product', 'Product', index=True,
         domain="[('type', '=', 'product'), '|', ('company_id', '=', False), ('company_id', '=', company_id)]", ondelete='cascade', required=True, check_company=True)
+    product_category_id = fields.Many2one('product.category', name='Product Category', related='product_id.categ_id', store=True)
     product_uom = fields.Many2one(
         'uom.uom', 'Unit of Measure', related='product_id.uom_id')
     product_uom_name = fields.Char(string='Product unit of measure label', related='product_uom.display_name', readonly=True)
@@ -73,8 +78,15 @@ class StockWarehouseOrderpoint(models.Model):
         default=lambda self: self.env.company)
     allowed_location_ids = fields.One2many(comodel_name='stock.location', compute='_compute_allowed_location_ids')
 
-    json_lead_days_popover = fields.Char(compute='_compute_lead_days')
+    rule_ids = fields.Many2many('stock.rule', string='Rules used', compute='_compute_rules')
+    json_lead_days_popover = fields.Char(compute='_compute_json_popover')
     lead_days_date = fields.Date(compute='_compute_lead_days')
+    allowed_route_ids = fields.Many2many('stock.location.route', compute='_compute_allowed_route_ids')
+    route_id = fields.Many2one(
+        'stock.location.route', string='Preferred Route', domain="[('id', 'in', allowed_route_ids)]")
+    qty_on_hand = fields.Float('On Hand', readonly=True, compute='_compute_qty')
+    qty_forecast = fields.Float('Forecast', readonly=True, compute='_compute_qty')
+    qty_to_order = fields.Float('To Order', compute='_compute_qty_to_order', store=True, readonly=False)
 
     _sql_constraints = [
         ('qty_multiple_check', 'CHECK( qty_multiple >= 0 )', 'Qty Multiple must be greater than or equal to zero.'),
@@ -93,44 +105,45 @@ class StockWarehouseOrderpoint(models.Model):
                 loc_domain = expression.AND([loc_domain, ['|', ('company_id', '=', False), ('company_id', '=', orderpoint.company_id.id)]])
             orderpoint.allowed_location_ids = self.env['stock.location'].search(loc_domain)
 
-    @api.depends('product_id', 'location_id', 'company_id', 'warehouse_id',
-                 'product_id.seller_ids', 'product_id.seller_ids.delay')
-    def _compute_lead_days(self):
+    @api.depends('warehouse_id', 'location_id')
+    def _compute_allowed_route_ids(self):
+        route_by_product = self.env['stock.location.route'].search([
+            ('product_selectable', '=', True),
+        ])
+        self.allowed_route_ids = route_by_product.ids
+
+    @api.depends('rule_ids', 'product_id.seller_ids', 'product_id.seller_ids.delay')
+    def _compute_json_popover(self):
         for orderpoint in self:
-            rules = orderpoint.product_id._get_rules_from_location(orderpoint.location_id)
-            lead_days, lead_days_description = rules._get_lead_days(orderpoint.product_id)
-            lead_days_date = fields.Date.today() + relativedelta.relativedelta(days=lead_days)
+            if not orderpoint.product_id or not orderpoint.location_id:
+                orderpoint.json_lead_days_popover = False
+                continue
+            dummy, lead_days_description = orderpoint.rule_ids._get_lead_days(orderpoint.product_id)
             orderpoint.json_lead_days_popover = dumps({
                 'title': _('Replenishment'),
                 'popoverTemplate': 'stock.leadDaysPopOver',
-                'lead_days_date': fields.Date.to_string(lead_days_date),
+                'lead_days_date': fields.Date.to_string(orderpoint.lead_days_date),
                 'lead_days_description': lead_days_description,
                 'today': fields.Date.to_string(fields.Date.today()),
             })
-            orderpoint.lead_days_date = lead_days_date
 
-    def _compute_qty(self):
-        orderpoints_contexts = defaultdict(lambda: self.env['stock.warehouse.orderpoint'])
+    @api.depends('rule_ids', 'product_id.seller_ids', 'product_id.seller_ids.delay')
+    def _compute_lead_days(self):
         for orderpoint in self:
-            orderpoint_context = orderpoint._get_product_context()
-            product_context = frozendict({**self.env.context, **orderpoint_context})
-            orderpoints_contexts[product_context] |= orderpoint
-        for orderpoint_context, orderpoints_by_context in orderpoints_contexts.items():
-            products_qty = orderpoints_by_context.product_id.with_context(orderpoint_context)._product_available()
-            products_qty_in_progress = orderpoints_by_context._quantity_in_progress()
-            for orderpoint in orderpoints_by_context:
-                orderpoint.qty_on_hand = products_qty[orderpoint.product_id.id]['qty_available']
-                orderpoint.qty_forecast = products_qty[orderpoint.product_id.id]['virtual_available'] + products_qty_in_progress[orderpoint.id]
-
-                qty_to_order = 0.0
-                rounding = orderpoint.product_uom.rounding
-                if float_compare(orderpoint.qty_forecast, orderpoint.product_min_qty, precision_rounding=rounding) < 0:
-                    qty_to_order = max(orderpoint.product_min_qty, orderpoint.product_max_qty) - orderpoint.qty_forecast
+            if not orderpoint.product_id or not orderpoint.location_id:
+                orderpoint.lead_days_date = False
+                continue
+            lead_days, dummy = orderpoint.rule_ids._get_lead_days(orderpoint.product_id)
+            lead_days_date = fields.Date.today() + relativedelta.relativedelta(days=lead_days)
+            orderpoint.lead_days_date = lead_days_date
 
-                    remainder = orderpoint.qty_multiple > 0 and qty_to_order % orderpoint.qty_multiple or 0.0
-                    if float_compare(remainder, 0.0, precision_rounding=rounding) > 0:
-                        qty_to_order += orderpoint.qty_multiple - remainder
-                orderpoint.qty_to_order = qty_to_order
+    @api.depends('route_id', 'product_id', 'location_id', 'company_id', 'warehouse_id', 'product_id.route_ids')
+    def _compute_rules(self):
+        for orderpoint in self:
+            if not orderpoint.product_id or not orderpoint.location_id:
+                orderpoint.rule_ids = False
+                continue
+            orderpoint.rule_ids = orderpoint.product_id._get_rules_from_location(orderpoint.location_id, route_ids=orderpoint.route_id)
 
     @api.constrains('product_id')
     def _check_product_uom(self):
@@ -138,11 +151,19 @@ class StockWarehouseOrderpoint(models.Model):
         if any(orderpoint.product_id.uom_id.category_id != orderpoint.product_uom.category_id for orderpoint in self):
             raise ValidationError(_('You have to select a product unit of measure that is in the same category than the default unit of measure of the product'))
 
+    @api.onchange('location_id')
+    def _onchange_location_id(self):
+        warehouse = self.location_id.get_warehouse().id
+        if warehouse:
+            self.warehouse_id = warehouse
+
     @api.onchange('warehouse_id')
     def _onchange_warehouse_id(self):
         """ Finds location id for changed warehouse. """
         if self.warehouse_id:
             self.location_id = self.warehouse_id.lot_stock_id.id
+        else:
+            self.location_id = False
 
     @api.onchange('product_id')
     def _onchange_product_id(self):
@@ -163,6 +184,58 @@ class StockWarehouseOrderpoint(models.Model):
                     raise UserError(_("Changing the company of this record is forbidden at this point, you should rather archive it and create a new one."))
         return super().write(vals)
 
+    @api.model
+    def action_open_orderpoints(self):
+        return self._get_orderpoint_action()
+
+    def action_replenish(self):
+        self._procure_orderpoint_confirm(company_id=self.env.company)
+        notification = False
+        if len(self) == 1:
+            notification = self._get_replenishment_order_notification()
+        # Forced to call compute quantity because we don't have a link.
+        self._compute_qty()
+        self.filtered(lambda o: o.create_uid.id == SUPERUSER_ID and o.qty_to_order <= 0.0 and o.trigger == 'manual').unlink()
+        return notification
+
+    def action_replenish_auto(self):
+        self.trigger = 'auto'
+        return self.action_replenish()
+
+    @api.depends('product_id', 'location_id', 'product_id.stock_move_ids', 'product_id.stock_move_ids.state')
+    def _compute_qty(self):
+        orderpoints_contexts = defaultdict(lambda: self.env['stock.warehouse.orderpoint'])
+        for orderpoint in self:
+            if not orderpoint.product_id or not orderpoint.location_id:
+                orderpoint.qty_on_hand = False
+                orderpoint.qty_forecast = False
+                continue
+            orderpoint_context = orderpoint._get_product_context()
+            product_context = frozendict({**self.env.context, **orderpoint_context})
+            orderpoints_contexts[product_context] |= orderpoint
+        for orderpoint_context, orderpoints_by_context in orderpoints_contexts.items():
+            products_qty = orderpoints_by_context.product_id.with_context(orderpoint_context)._product_available()
+            products_qty_in_progress = orderpoints_by_context._quantity_in_progress()
+            for orderpoint in orderpoints_by_context:
+                orderpoint.qty_on_hand = products_qty[orderpoint.product_id.id]['qty_available']
+                orderpoint.qty_forecast = products_qty[orderpoint.product_id.id]['virtual_available'] + products_qty_in_progress[orderpoint.id]
+
+    @api.depends('qty_multiple', 'qty_forecast', 'product_min_qty', 'product_max_qty')
+    def _compute_qty_to_order(self):
+        for orderpoint in self:
+            if not orderpoint.product_id or not orderpoint.location_id:
+                orderpoint.qty_to_order = False
+                continue
+            qty_to_order = 0.0
+            rounding = orderpoint.product_uom.rounding
+            if float_compare(orderpoint.qty_forecast, orderpoint.product_min_qty, precision_rounding=rounding) < 0:
+                qty_to_order = max(orderpoint.product_min_qty, orderpoint.product_max_qty) - orderpoint.qty_forecast
+
+                remainder = orderpoint.qty_multiple > 0 and qty_to_order % orderpoint.qty_multiple or 0.0
+                if float_compare(remainder, 0.0, precision_rounding=rounding) > 0:
+                    qty_to_order += orderpoint.qty_multiple - remainder
+            orderpoint.qty_to_order = qty_to_order
+
     def _get_product_context(self):
         """Used to call `virtual_available` when running an orderpoint."""
         self.ensure_one()
@@ -171,6 +244,102 @@ class StockWarehouseOrderpoint(models.Model):
             'to_date': datetime.combine(self.lead_days_date, time.max)
         }
 
+    def _get_orderpoint_action(self):
+        """Create manual orderpoints for missing product in each warehouses. It also removes
+        orderpoints that have been replenish. In order to do it:
+        - It uses the report.stock.quantity to find missing quantity per product/warehouse
+        - It checks if orderpoint already exist to refill this location.
+        - It checks if it exists other sources (e.g RFQ) tha refill the warehouse.
+        - It creates the orderpoints for missing quantity that were not refill by an upper option.
+
+        return replenish report ir.actions.act_window
+        """
+        action = self.env.ref('stock.action_orderpoint_replenish').read()[0]
+        action['context'] = self.env.context
+        orderpoints = self.env['stock.warehouse.orderpoint'].search([])
+        # Remove previous automatically created orderpoint that has been refilled.
+        to_remove = orderpoints.filtered(lambda o: o.create_uid.id == SUPERUSER_ID and o.qty_to_order <= 0.0 and o.trigger == 'manual')
+        to_remove.unlink()
+        orderpoints = orderpoints - to_remove
+        to_refill = defaultdict(float)
+        qty_by_product_warehouse = self.env['report.stock.quantity'].read_group(
+            [('date', '=', fields.date.today()), ('state', '=', 'forecast')],
+            ['product_id', 'product_qty', 'warehouse_id'],
+            ['product_id', 'warehouse_id'], lazy=False)
+        for group in qty_by_product_warehouse:
+            warehouse_id = group.get('warehouse_id') and group['warehouse_id'][0]
+            if group['product_qty'] >= 0.0 or not warehouse_id:
+                continue
+            to_refill[(group['product_id'][0], warehouse_id)] = group['product_qty']
+        if not to_refill:
+            return action
+
+        # Remove incoming quantity from other otigin than moves (e.g RFQ)
+        product_ids, warehouse_ids = zip(*to_refill)
+        # lot_stock_ids = [lot_stock_id_by_warehouse[w] for w in warehouse_ids]
+        dummy, qty_by_product_wh = self.env['product.product'].browse(product_ids)._get_quantity_in_progress(warehouse_ids=warehouse_ids)
+        rounding = self.env['decimal.precision'].precision_get('Product Unit of Measure')
+        for (product, warehouse), product_qty in to_refill.items():
+            qty_in_progress = qty_by_product_wh.get((product, warehouse)) or 0.0
+            qty_in_progress += sum(orderpoints.filtered(
+                lambda o: o.product_id.id == product and o.warehouse_id.id == warehouse
+            ).mapped('qty_to_order'))
+            # Add qty to order for other orderpoint under this warehouse.
+            if not qty_in_progress:
+                continue
+            to_refill[(product, warehouse)] = product_qty + qty_in_progress
+        to_refill = {k: v for k, v in to_refill.items() if float_compare(
+            v, 0.0, precision_digits=rounding) < 0.0}
+
+        lot_stock_id_by_warehouse = self.env['stock.warehouse'].search_read([
+            ('id', 'in', [g[1] for g in to_refill.keys()])
+        ], ['lot_stock_id'])
+        lot_stock_id_by_warehouse = {w['id']: w['lot_stock_id'][0] for w in lot_stock_id_by_warehouse}
+
+        product_qty_available = {}
+        for warehouse, group in groupby(sorted(to_refill, key=lambda p_w: p_w[1]), key=lambda p_w: p_w[1]):
+            products = self.env['product.product'].browse([p for p, w in group])
+            products_qty_available_list = products.with_context(location=lot_stock_id_by_warehouse[warehouse]).mapped('qty_available')
+            product_qty_available.update({(p.id, warehouse): q for p, q in zip(products, products_qty_available_list)})
+
+        orderpoint_values_list = []
+        for (product, warehouse), product_qty in to_refill.items():
+            lot_stock_id = lot_stock_id_by_warehouse[warehouse]
+            orderpoint = self.filtered(lambda o: o.product_id == product and o.location_id == lot_stock_id)
+            if orderpoint:
+                orderpoint[0].qty_forecast += product_qty
+            else:
+                orderpoint_values = self.env['stock.warehouse.orderpoint']._get_orderpoint_values(product, lot_stock_id)
+                orderpoint_values.update({
+                    'name': _('Replenishment Report'),
+                    'warehouse_id': warehouse,
+                    'company_id': self.env['stock.warehouse'].browse(warehouse).company_id.id,
+                })
+            orderpoint_values_list.append(orderpoint_values)
+
+        orderpoints = self.env['stock.warehouse.orderpoint'].with_user(SUPERUSER_ID).create(orderpoint_values_list)
+        for orderpoint in orderpoints:
+            orderpoint.route_id = orderpoint._get_default_route_id()
+        return action
+
+    @api.model
+    def _get_orderpoint_values(self, product, location):
+        return {
+            'product_id': product,
+            'location_id': location,
+            'product_max_qty': 0.0,
+            'product_min_qty': 0.0,
+            'trigger': 'manual',
+        }
+
+    def _get_replenishment_order_notification(self):
+        return False
+
+    def _quantity_in_progress(self):
+        """Return Quantities that are not yet in virtual stock but should be deduced from orderpoint rule
+        (example: purchases created from orderpoints)"""
+        return dict(self.mapped(lambda x: (x.id, 0.0)))
+
     def _prepare_procurement_values(self, date=False, group=False):
         """ Prepare specific key for moves or other components that will be created from a stock rule
         comming from an orderpoint. This method could be override in order to add other custom key that could
@@ -178,13 +347,14 @@ class StockWarehouseOrderpoint(models.Model):
         """
         date_planned = date or fields.Date.today()
         return {
+            'route_ids': self.route_id,
             'date_planned': date_planned,
             'warehouse_id': self.warehouse_id,
             'orderpoint_id': self,
             'group_id': group or self.group_id,
         }
 
-    def _procure_orderpoint_confirm(self, use_new_cursor=False, company_id=None):
+    def _procure_orderpoint_confirm(self, use_new_cursor=False, company_id=None, raise_user_error=True):
         """ Create procurements based on orderpoints.
         :param bool use_new_cursor: if set, use a dedicated cursor and auto-commit after processing
             1000 orderpoints.
@@ -213,7 +383,7 @@ class StockWarehouseOrderpoint(models.Model):
 
                 try:
                     with self.env.cr.savepoint():
-                        self.env['procurement.group'].with_context(from_orderpoint=True).run(procurements, raise_user_error=False)
+                        self.env['procurement.group'].with_context(from_orderpoint=True).run(procurements, raise_user_error=raise_user_error)
                 except ProcurementException as errors:
                     for procurement, error_msg in errors.procurement_exceptions:
                         orderpoints_exceptions += [(procurement.values.get('orderpoint_id'), error_msg)]
@@ -254,8 +424,3 @@ class StockWarehouseOrderpoint(models.Model):
 
     def _post_process_scheduler(self):
         return True
-
-    def _quantity_in_progress(self):
-        """Return Quantities that are not yet in virtual stock but should be deduced from orderpoint rule
-        (example: purchases created from orderpoints)"""
-        return dict(self.mapped(lambda x: (x.id, 0.0)))

--- a/addons/stock/models/stock_rule.py
+++ b/addons/stock/models/stock_rule.py
@@ -6,7 +6,7 @@ from collections import defaultdict, namedtuple
 
 from dateutil.relativedelta import relativedelta
 
-from odoo import _, api, fields, models, registry
+from odoo import SUPERUSER_ID, _, api, fields, models, registry
 from odoo.exceptions import UserError
 from odoo.osv import expression
 from odoo.tools import float_compare, float_is_zero, html_escape
@@ -502,7 +502,7 @@ class ProcurementGroup(models.Model):
         # Minimum stock rules
         domain = self._get_orderpoint_domain(company_id=company_id)
         orderpoints = self.env['stock.warehouse.orderpoint'].search(domain)
-        orderpoints.sudo()._procure_orderpoint_confirm(use_new_cursor=use_new_cursor, company_id=company_id)
+        orderpoints.sudo()._procure_orderpoint_confirm(use_new_cursor=use_new_cursor, company_id=company_id, raise_user_error=False)
 
         # Search all confirmed stock_moves and try to assign them
         domain = self._get_moves_to_assign_domain()
@@ -518,6 +518,7 @@ class ProcurementGroup(models.Model):
 
         # Merge duplicated quants
         self.env['stock.quant']._quant_tasks()
+
         if use_new_cursor:
             self._cr.commit()
 
@@ -542,6 +543,7 @@ class ProcurementGroup(models.Model):
 
     @api.model
     def _get_orderpoint_domain(self, company_id=False):
-        domain = [('company_id', '=', company_id)] if company_id else []
-        domain += [('product_id.active', '=', True)]
+        domain = [('trigger', '=', 'auto'), ('product_id.active', '=', True)]
+        if company_id:
+            domain += [('company_id', '=', company_id)]
         return domain
