PR: https://github.com/odoo/odoo/pull/82641

From: 7ceb079455582ec6bf3e1158457fb8f31f41a0ca
From: Didier (did)
Date: 2022-09-05 12:49:30

Structural Changes: 4
Total Changes: 156

[IMP] mail: implement link preview with OpenGraph Protocol

OpenGraph Protocol https://ogp.me/ allow us to get some data from the link that
are shared in message.

task-2365881

closes odoo/odoo#82641

Related: odoo/enterprise#30867
Signed-off-by: SÃ©bastien Theys (seb) <seb@odoo.com>

================================= pseudo patch: =================================

--- a/addons/mail/models/__init__.py
+++ b/addons/mail/models/__init__.py
@@ -23,6 +23,7 @@ from . import mail_activity
 from . import mail_blacklist
 from . import mail_followers
 from . import mail_gateway_allowed
+from . import mail_link_preview
 from . import mail_message_reaction
 from . import mail_message_schedule
 from . import mail_message_subtype

--- a/addons/mail/models/mail_guest.py
+++ b/addons/mail/models/mail_guest.py
@@ -113,6 +113,7 @@ class MailGuest(models.Model):
             'current_partner': False,
             'current_user_id': False,
             'current_user_settings': False,
+            'hasLinkPreviewFeature': self.env['mail.link.preview']._is_link_preview_enabled(),
             'menu_id': False,
             'needaction_inbox_counter': False,
             'partner_root': {

--- a/None
+++ b/addons/mail/models/mail_link_preview.py
@@ -0,0 +1,151 @@
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+
+from datetime import datetime
+from dateutil.relativedelta import relativedelta
+from lxml import html, etree
+from urllib.parse import urlparse
+import requests
+
+from odoo import api, models, fields
+
+
+class LinkPreview(models.Model):
+    _name = 'mail.link.preview'
+    _description = "Store link preview data"
+
+    message_id = fields.Many2one('mail.message', string='Message', index=True, ondelete='cascade', required=True)
+    source_url = fields.Char('url', required=True)
+    og_type = fields.Char('type')
+    og_title = fields.Char('title')
+    og_image = fields.Char('image')
+    og_description = fields.Text('description')
+    og_mimetype = fields.Char('mimetype')
+    image_mimetype = fields.Char('image_mimetype')
+    create_date = fields.Datetime(index=True)
+
+    @api.model
+    def _create_link_previews(self, message):
+        tree = html.fromstring(message.body)
+        urls = tree.xpath('//a/@href')
+        link_previews = self.env['mail.link.preview']
+        requests_session = requests.Session()
+        # Some websites are blocking non browser user agent.
+        requests_session.headers.update({
+            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; rv:91.0) Gecko/20100101 Firefox/91.0'
+        })
+        for url in set(urls):
+            if len(link_previews) >= 5:
+                break
+            link_previews |= self.env['mail.link.preview']._create_link_preview(url, message.id, requests_session)
+        if not link_previews:
+            return
+        guest = self.env['mail.guest']._get_guest_from_context()
+        if message.model == 'mail.channel' and message.res_id:
+            target = self.env['mail.channel'].browse(message.res_id)
+        elif self.env.user._is_public() and guest:
+            target = guest
+        else:
+            target = self.env.user.partner_id
+        self.env['bus.bus']._sendmany([(target, 'mail.link.preview/insert', link_previews._link_preview_format())])
+
+    @api.model
+    def _create_link_preview(self, url, message_id, request_session):
+        if self._is_domain_throttled(url):
+            return self.env['mail.link.preview']
+        link_preview_data = self._get_link_preview_from_url(url, request_session)
+        if link_preview_data:
+            link_preview_data['message_id'] = message_id
+            return self.create(link_preview_data)
+        return self.env['mail.link.preview']
+
+    def _delete_and_notify(self):
+        notifications = []
+        guest = self.env['mail.guest']._get_guest_from_context()
+        for link_preview in self:
+            if link_preview.message_id.model == 'mail.channel' and link_preview.message_id.res_id:
+                target = self.env['mail.channel'].browse(link_preview.message_id.res_id)
+            elif self.env.user._is_public() and guest:
+                target = guest
+            else:
+                target = self.env.user.partner_id
+            notifications.append((target, 'mail.link.preview/delete', {'id': link_preview.id}))
+        self.env['bus.bus']._sendmany(notifications)
+        self.unlink()
+
+    @api.model
+    def _is_link_preview_enabled(self):
+        link_preview_throttle = int(self.env['ir.config_parameter'].sudo().get_param('mail.link_preview_throttle', 99))
+        return link_preview_throttle > 0
+
+    @api.model
+    def _is_domain_throttled(self, url):
+        domain = urlparse(url).netloc
+        date_interval = fields.Datetime.to_string((datetime.now() - relativedelta(seconds=10)))
+        call_counter = self.search_count([
+            ('source_url', 'ilike', domain),
+            ('create_date', '>', date_interval),
+        ])
+        link_preview_throttle = int(self.env['ir.config_parameter'].get_param('mail.link_preview_throttle', 99))
+        return call_counter > link_preview_throttle
+
+    @api.model
+    def _get_link_preview_from_url(self, url, request_session):
+        try:
+            response = request_session.head(url, timeout=3, allow_redirects=True)
+        except requests.exceptions.RequestException:
+            return False
+        if response.status_code != requests.codes.ok:
+            return False
+        image_mimetype = (
+            'image/bmp',
+            'image/gif',
+            'image/jpeg',
+            'image/png',
+            'image/tiff',
+            'image/x-icon',
+        )
+        # Content-Type header can return a charset, but we just need the
+        # mimetype (eg: image/jpeg;charset=ISO-8859-1)
+        content_type = response.headers['Content-Type'].split(';')
+        if response.headers['Content-Type'].startswith(image_mimetype):
+            return {
+                'image_mimetype': content_type[0],
+                'source_url': url,
+            }
+        if response.headers['Content-Type'].startswith('text/html'):
+            return self._get_link_preview_from_html(url, request_session)
+        return False
+
+    def _get_link_preview_from_html(self, url, request_session):
+        response = request_session.get(url, timeout=3)
+        parser = etree.HTMLParser(encoding=response.encoding)
+        tree = html.fromstring(response.content, parser=parser)
+        og_title = tree.xpath('//meta[@property="og:title"]/@content')
+        if not og_title:
+            return False
+        og_description = tree.xpath('//meta[@property="og:description"]/@content')
+        og_type = tree.xpath('//meta[@property="og:type"]/@content')
+        og_image = tree.xpath('//meta[@property="og:image"]/@content')
+        og_mimetype = tree.xpath('//meta[@property="og:image:type"]/@content')
+        return {
+            'og_description': og_description[0] if og_description else None,
+            'og_image': og_image[0] if og_image else None,
+            'og_mimetype': og_mimetype[0] if og_mimetype else None,
+            'og_title': og_title[0],
+            'og_type': og_type[0] if og_type else None,
+            'source_url': url,
+        }
+
+    def _link_preview_format(self):
+        return [{
+            'id': preview.id,
+            'message': {'id': preview.message_id.id},
+            'image_mimetype': preview.image_mimetype,
+            'og_description': preview.og_description,
+            'og_image': preview.og_image,
+            'og_mimetype': preview.og_mimetype,
+            'og_title': preview.og_title,
+            'og_type': preview.og_type,
+            'source_url': preview.source_url,
+        } for preview in self]

--- a/addons/mail/models/mail_message.py
+++ b/addons/mail/models/mail_message.py
@@ -104,6 +104,7 @@ class Message(models.Model):
     model = fields.Char('Related Document Model')
     res_id = fields.Many2oneReference('Related Document ID', model_field='model')
     record_name = fields.Char('Message Record Name') # name_get() of the related document
+    link_preview_ids = fields.One2many('mail.link.preview', 'message_id', string='Link Previews', groups="base.group_erp_manager")
     # characteristics
     message_type = fields.Selection([
         ('email', 'Email'),
@@ -859,6 +860,7 @@ class Message(models.Model):
                 'notifications': message_sudo.notification_ids._filtered_for_web_client()._notification_format(),
                 'attachment_ids': message_sudo.attachment_ids._attachment_format() if not legacy else message_sudo.attachment_ids._attachment_format(legacy=True),
                 'trackingValues': allowed_tracking_ids._tracking_value_format(),
+                'linkPreviews': message_sudo.link_preview_ids._link_preview_format(),
                 'messageReactionGroups': reaction_groups,
                 'record_name': record_name,
             })

--- a/addons/mail/models/res_users.py
+++ b/addons/mail/models/res_users.py
@@ -189,6 +189,7 @@ class Users(models.Model):
             'current_partner': self.partner_id.mail_partner_format().get(self.partner_id),
             'current_user_id': self.id,
             'current_user_settings': self.env['res.users.settings']._find_or_create_for_user(self)._res_users_settings_format(),
+            'hasLinkPreviewFeature': self.env['mail.link.preview']._is_link_preview_enabled(),
             'internalUserGroupId': self.env.ref('base.group_user').id,
             'menu_id': self.env['ir.model.data']._xmlid_to_res_id('mail.menu_root_discuss'),
             'needaction_inbox_counter': self.partner_id._get_needaction_count(),
