PR: https://github.com/odoo/odoo/pull/133392

From: e8878a8b4c6dcf7927b5ec0623646cf2f2be477d
From: Florian Charlier
Date: 2023-10-24 12:38:13

Structural Changes: 4
Total Changes: 52

[IMP] {mass_mailing_,}sms: delay sms deletion

Also impacts test_mail_sms.

Purpose: let a cron do delete records to end the
sending transaction sooner.

Removing the foreign key between sms_sms and mailing_trace
is necessary as traces may have to be updated due to
delivery reports.
This is why we do it here and not with notifications
because only traces will trigger updates of a possibly
massive number of records and repeated concurrent updates.

We also replace the now obsolete "sms_sms_X" prefix as there
are not many "sms_id" to distinguish from.

Task-2560666

Part-of: odoo/odoo#133392

================================= pseudo patch: =================================

--- a/addons/sms/models/mail_notification.py
+++ b/addons/sms/models/mail_notification.py
@@ -1,7 +1,7 @@
 # -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
-from odoo import fields, models
+from odoo import api, fields, models
 
 
 class MailNotification(models.Model):
@@ -10,7 +10,9 @@ class MailNotification(models.Model):
     notification_type = fields.Selection(selection_add=[
         ('sms', 'SMS')
     ], ondelete={'sms': 'cascade'})
-    sms_id = fields.Many2one('sms.sms', string='SMS', index='btree_not_null', ondelete='set null')
+    sms_id_int = fields.Integer('SMS ID', index='btree_not_null')
+    # Used to give links on form view without foreign key. In most cases, you'd want to use sms_id_int or sms_tracker_ids.sms_uuid.
+    sms_id = fields.Many2one('sms.sms', string='SMS', store=False, compute='_compute_sms_id')
     sms_tracker_ids = fields.One2many('sms.tracker', 'mail_notification_id', string="SMS Trackers")
     sms_number = fields.Char('SMS Number')
     failure_type = fields.Selection(selection_add=[
@@ -28,3 +30,15 @@ class MailNotification(models.Model):
         ('sms_not_delivered', 'Not Delivered'),
         ('sms_rejected', 'Rejected'),
     ])
+
+    @api.depends('sms_id_int', 'notification_type')
+    def _compute_sms_id(self):
+        self.sms_id = False
+        sms_notifications = self.filtered(lambda n: n.notification_type == 'sms' and bool(n.sms_id_int))
+        if not sms_notifications:
+            return
+        existing_sms_ids = self.env['sms.sms'].sudo().search([
+            ('id', 'in', sms_notifications.mapped('sms_id_int')), ('to_delete', '!=', True)
+        ]).ids
+        for sms_notification in sms_notifications.filtered(lambda n: n.sms_id_int in set(existing_sms_ids)):
+            sms_notification.sms_id = sms_notification.sms_id_int

--- a/addons/sms/models/mail_thread.py
+++ b/addons/sms/models/mail_thread.py
@@ -305,7 +305,7 @@ class MailThread(models.AbstractModel):
                 'res_partner_id': sms.partner_id.id,
                 'sms_number': sms.number,
                 'notification_type': 'sms',
-                'sms_id': sms.id,
+                'sms_id_int': sms.id,
                 'sms_tracker_ids': [Command.create({'sms_uuid': sms.uuid})] if sms.state == 'outgoing' else False,
                 'is_read': True,  # discard Inbox notification
                 'notification_status': 'ready' if sms.state == 'outgoing' else 'exception',
@@ -323,7 +323,7 @@ class MailThread(models.AbstractModel):
                         notif.write({
                             'notification_type': 'sms',
                             'notification_status': 'ready',
-                            'sms_id': sms.id,
+                            'sms_id_int': sms.id,
                             'sms_tracker_ids': [Command.create({'sms_uuid': sms.uuid})],
                             'sms_number': sms.number,
                         })

--- a/addons/sms/models/sms_sms.py
+++ b/addons/sms/models/sms_sms.py
@@ -63,6 +63,10 @@ class SmsSms(models.Model):
         ('sms_optout', 'Opted Out'),
     ], copy=False)
     sms_tracker_id = fields.Many2one('sms.tracker', string='SMS trackers', compute='_compute_sms_tracker_id')
+    to_delete = fields.Boolean(
+        'Marked for deletion', default=False,
+        help='Will automatically be deleted, while notifications will not be deleted in any case.'
+    )
 
     _sql_constraints = [
         ('uuid_unique', 'unique(uuid)', 'UUID must be unique'),
@@ -93,7 +97,7 @@ class SmsSms(models.Model):
           :param auto_commit: commit after each batch of SMS;
           :param raise_exception: raise if there is an issue contacting IAP;
         """
-        self = self.filtered(lambda sms: sms.state == 'outgoing')
+        self = self.filtered(lambda sms: sms.state == 'outgoing' and not sms.to_delete)
         for batch_ids in self._split_batch():
             self.browse(batch_ids)._send(unlink_failed=unlink_failed, unlink_sent=unlink_sent, raise_exception=raise_exception)
             # auto-commit if asked except in testing mode
@@ -101,7 +105,7 @@ class SmsSms(models.Model):
                 self._cr.commit()
 
     def resend_failed(self):
-        sms_to_send = self.filtered(lambda sms: sms.state == 'error')
+        sms_to_send = self.filtered(lambda sms: sms.state == 'error' and not sms.to_delete)
         sms_to_send.state = 'outgoing'
         notification_title = _('Warning')
         notification_type = 'danger'
@@ -135,7 +139,7 @@ class SmsSms(models.Model):
        :param list ids: optional list of emails ids to send. If passed no search
          is performed, and these ids are used instead.
         """
-        domain = [('state', '=', 'outgoing')]
+        domain = [('state', '=', 'outgoing'), ('to_delete', '!=', True)]
 
         filtered_ids = self.search(domain, limit=10000).ids  # TDE note: arbitrary limit we might have to update
         if ids:
@@ -177,30 +181,30 @@ class SmsSms(models.Model):
 
         results_uuids = [result['uuid'] for result in results]
         all_sms_sudo = self.env['sms.sms'].sudo().search([('uuid', 'in', results_uuids)]).with_context(sms_skip_msg_notification=True)
-        mail_message_ids_sudo = all_sms_sudo.mail_message_id
 
         for iap_state, results_group in tools.groupby(results, key=lambda result: result['state']):
             sms_sudo = all_sms_sudo.filtered(lambda s: s.uuid in {result['uuid'] for result in results_group})
             if success_state := self.IAP_TO_SMS_STATE_SUCCESS.get(iap_state):
                 sms_sudo.sms_tracker_id._action_update_from_sms_state(success_state)
-                if unlink_sent:
-                    sms_sudo.unlink()
-                else:
-                    sms_sudo.write({'state': success_state, 'failure_type': False})
+                to_delete = {'to_delete': True} if unlink_sent else {}
+                sms_sudo.write({'state': success_state, 'failure_type': False, **to_delete})
             else:
                 failure_type = self.IAP_TO_SMS_FAILURE_TYPE.get(iap_state, 'unknown')
                 if failure_type != 'unknown':
                     sms_sudo.sms_tracker_id._action_update_from_sms_state('error', failure_type=failure_type)
                 else:
                     sms_sudo.sms_tracker_id._action_update_from_provider_error(iap_state)
-                if unlink_failed:
-                    sms_sudo.unlink()
-                else:
-                    sms_sudo.write({'state': 'error', 'failure_type': failure_type})
+                to_delete = {'to_delete': True} if unlink_failed else {}
+                sms_sudo.write({'state': 'error', 'failure_type': failure_type, **to_delete})
 
-        mail_message_ids_sudo._notify_message_notification_update()
+        all_sms_sudo.mail_message_id._notify_message_notification_update()
 
     def _update_sms_state_and_trackers(self, new_state, failure_type=None):
         """Update sms state update and related tracking records (notifications, traces)."""
         self.write({'state': new_state, 'failure_type': failure_type})
         self.sms_tracker_id._action_update_from_sms_state(new_state, failure_type=failure_type)
+
+    @api.autovacuum
+    def _gc_device(self):
+        self._cr.execute("DELETE FROM sms_sms WHERE to_delete = TRUE")
+        _logger.info("GC'd %d sms marked for deletion", self._cr.rowcount)
