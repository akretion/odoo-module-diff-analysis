PR: https://github.com/odoo/odoo/pull/91448

From: 080d41a34119191d20b3e07f72f6aeec677ee1a8
From: Laurent Smet
Date: 2022-06-07 08:16:14

Structural Changes: 5
Total Changes: 1637

[REF] account_accountant: Refactor the bank reconciliation widget

- Refactor the bank reconciliation widget to use more standards views and have a side-by-side kanban/widget views instead.
- Make sure the bank reconciliation widget is doing the same thing as the "reconcile" method on account.bank.statement.line. Then, what you see on the view is exactly what you get on the corresponding journal entry.
- Since the "reconcile" method is gone, clean the matching rules since it's now called only for one statement line at a time. Also, move the auto_validate feature into a CRON to avoid performance issues when opening the widget.

closes odoo/odoo#91448

Task: 2555114
Related: odoo/enterprise#27360
Related: odoo/upgrade#3555
Signed-off-by: William Andr√© (wan) <wan@odoo.com>

================================= pseudo patch: =================================

--- a/addons/account/models/account_bank_statement.py
+++ b/addons/account/models/account_bank_statement.py
@@ -1,11 +1,11 @@
 # -*- coding: utf-8 -*-
 
-import math
-
 from odoo import api, fields, models, _
-from odoo.tools import float_is_zero
+from odoo.tools import float_is_zero, html2plaintext
 from odoo.tools.misc import formatLang, format_date
 from odoo.exceptions import UserError, ValidationError
+from odoo.osv.expression import get_unaccent_wrapper
+from odoo.addons.base.models.res_bank import sanitize_account_number
 
 
 class AccountCashboxLine(models.Model):
@@ -524,10 +524,16 @@ class AccountBankStatementLine(models.Model):
     transaction_type = fields.Char(string='Transaction Type')
     payment_ref = fields.Char(string='Label', required=True)
     amount = fields.Monetary(currency_field='currency_id')
-    amount_currency = fields.Monetary(currency_field='foreign_currency_id',
-        help="The amount expressed in an optional other currency if it is a multi-currency entry.")
-    foreign_currency_id = fields.Many2one('res.currency', string='Foreign Currency',
-        help="The optional other currency if it is a multi-currency entry.")
+    amount_currency = fields.Monetary(
+        string="Amount in Currency",
+        currency_field='foreign_currency_id',
+        help="The amount expressed in an optional other currency if it is a multi-currency entry.",
+    )
+    foreign_currency_id = fields.Many2one(
+        comodel_name='res.currency',
+        string="Foreign Currency",
+        help="The optional other currency if it is a multi-currency entry.",
+    )
     amount_residual = fields.Float(string="Residual Amount",
         compute="_compute_is_reconciled",
         store=True,
@@ -575,156 +581,68 @@ class AccountBankStatementLine(models.Model):
                 other_lines += line
         return liquidity_lines, suspense_lines, other_lines
 
-    @api.model
-    def _prepare_liquidity_move_line_vals(self):
-        ''' Prepare values to create a new account.move.line record corresponding to the
-        liquidity line (having the bank/cash account).
-        :return:        The values to create a new account.move.line record.
-        '''
+    def _prepare_counterpart_amounts_using_st_line_rate(self, currency, balance, amount_currency):
+        """ Convert the amounts passed as parameters to the statement line currency using the rates provided by the
+        bank. The computed amounts are the one that could be set on the statement line as a counterpart journal item
+        to fully paid the provided amounts as parameters.
+
+        :param currency:        The currency in which is expressed 'amount_currency'.
+        :param balance:         The amount expressed in company currency. Only needed when the currency passed as
+                                parameter is neither the statement line's foreign currency, neither the journal's
+                                currency.
+        :param amount_currency: The amount expressed in the 'currency' passed as parameter.
+        :return:                A python dictionary containing:
+            * balance:          The amount to consider expressed in company's currency.
+            * amount_currency:  The amount to consider expressed in statement line's foreign currency.
+        """
         self.ensure_one()
 
-        statement = self.statement_id
-        journal = statement.journal_id
+        journal = self.journal_id
         company_currency = journal.company_id.currency_id
         journal_currency = journal.currency_id or company_currency
+        foreign_currency = self.foreign_currency_id or journal_currency or company_currency
 
-        if self.foreign_currency_id and journal_currency:
-            currency_id = journal_currency.id
-            if self.foreign_currency_id == company_currency:
-                amount_currency = self.amount
-                balance = self.amount_currency
-            else:
-                amount_currency = self.amount
-                balance = journal_currency._convert(amount_currency, company_currency, journal.company_id, self.date)
-        elif self.foreign_currency_id and not journal_currency:
-            amount_currency = self.amount_currency
-            balance = self.amount
-            currency_id = self.foreign_currency_id.id
-        elif not self.foreign_currency_id and journal_currency:
-            currency_id = journal_currency.id
-            amount_currency = self.amount
-            balance = journal_currency._convert(amount_currency, journal.company_id.currency_id, journal.company_id, self.date)
+        journal_amount = self.amount
+        if foreign_currency == journal_currency:
+            transaction_amount = journal_amount
         else:
-            currency_id = company_currency.id
-            amount_currency = self.amount
-            balance = self.amount
-
-        return {
-            'name': self.payment_ref,
-            'move_id': self.move_id.id,
-            'partner_id': self.partner_id.id,
-            'currency_id': currency_id,
-            'account_id': journal.default_account_id.id,
-            'debit': balance > 0 and balance or 0.0,
-            'credit': balance < 0 and -balance or 0.0,
-            'amount_currency': amount_currency,
-        }
-
-    @api.model
-    def _prepare_counterpart_move_line_vals(self, counterpart_vals, move_line=None):
-        ''' Prepare values to create a new account.move.line move_line.
-        By default, without specified 'counterpart_vals' or 'move_line', the counterpart line is
-        created using the suspense account. Otherwise, this method is also called during the
-        reconciliation to prepare the statement line's journal entry. In that case,
-        'counterpart_vals' will be used to create a custom account.move.line (from the reconciliation widget)
-        and 'move_line' will be used to create the counterpart of an existing account.move.line to which
-        the newly created journal item will be reconciled.
-        :param counterpart_vals:    A python dictionary containing:
-            'balance':                  Optional amount to consider during the reconciliation. If a foreign currency is set on the
-                                        counterpart line in the same foreign currency as the statement line, then this amount is
-                                        considered as the amount in foreign currency. If not specified, the full balance is took.
-                                        This value must be provided if move_line is not.
-            'amount_residual':          The residual amount to reconcile expressed in the company's currency.
-                                        /!\ This value should be equivalent to move_line.amount_residual except we want
-                                        to avoid browsing the record when the only thing we need in an overview of the
-                                        reconciliation, for example in the reconciliation widget.
-            'amount_residual_currency': The residual amount to reconcile expressed in the foreign's currency.
-                                        Using this key doesn't make sense without passing 'currency_id' in vals.
-                                        /!\ This value should be equivalent to move_line.amount_residual_currency except
-                                        we want to avoid browsing the record when the only thing we need in an overview
-                                        of the reconciliation, for example in the reconciliation widget.
-            **kwargs:                   Additional values that need to land on the account.move.line to create.
-        :param move_line:           An optional account.move.line move_line representing the counterpart line to reconcile.
-        :return:                    The values to create a new account.move.line move_line.
-        '''
-        self.ensure_one()
-
-        statement = self.statement_id
-        journal = statement.journal_id
-        company_currency = journal.company_id.currency_id
-        journal_currency = journal.currency_id or company_currency
-        foreign_currency = self.foreign_currency_id or journal_currency or company_currency
-        statement_line_rate = (self.amount_currency / self.amount) if self.amount else 0.0
-
-        balance_to_reconcile = counterpart_vals.pop('balance', None)
-        amount_residual = -counterpart_vals.pop('amount_residual', move_line.amount_residual if move_line else 0.0) \
-            if balance_to_reconcile is None else balance_to_reconcile
-        amount_residual_currency = -counterpart_vals.pop('amount_residual_currency', move_line.amount_residual_currency if move_line else 0.0)\
-            if balance_to_reconcile is None else balance_to_reconcile
-
-        if 'currency_id' in counterpart_vals:
-            currency_id = counterpart_vals['currency_id'] or company_currency.id
-        elif move_line:
-            currency_id = move_line.currency_id.id or company_currency.id
+            transaction_amount = self.amount_currency
+        if journal_currency == company_currency:
+            company_amount = journal_amount
+        elif foreign_currency == company_currency:
+            company_amount = transaction_amount
         else:
-            currency_id = foreign_currency.id
+            company_amount = journal_currency._convert(journal_amount, company_currency, journal.company_id, self.date)
 
-        if currency_id not in (foreign_currency.id, journal_currency.id):
-            currency_id = company_currency.id
-            amount_residual_currency = 0.0
+        rate_journal2foreign_curr = journal_amount and abs(transaction_amount) / abs(journal_amount)
+        rate_comp2journal_curr = company_amount and abs(journal_amount) / abs(company_amount)
 
-        amounts = {
-            company_currency.id: 0.0,
-            journal_currency.id: 0.0,
-            foreign_currency.id: 0.0,
-        }
-
-        amounts[currency_id] = amount_residual_currency
-        amounts[company_currency.id] = amount_residual
-
-        if currency_id == journal_currency.id and journal_currency != company_currency:
-            if foreign_currency != company_currency:
-                amounts[company_currency.id] = journal_currency._convert(amounts[currency_id], company_currency, journal.company_id, self.date)
-            if statement_line_rate:
-                amounts[foreign_currency.id] = amounts[currency_id] * statement_line_rate
-        elif currency_id == foreign_currency.id and self.foreign_currency_id:
-            if statement_line_rate:
-                amounts[journal_currency.id] = amounts[foreign_currency.id] / statement_line_rate
-                if foreign_currency != company_currency:
-                    amounts[company_currency.id] = journal_currency._convert(amounts[journal_currency.id], company_currency, journal.company_id, self.date)
-        else:
-            amounts[journal_currency.id] = company_currency._convert(amounts[company_currency.id], journal_currency, journal.company_id, self.date)
-            if statement_line_rate:
-                amounts[foreign_currency.id] = amounts[journal_currency.id] * statement_line_rate
-
-        if foreign_currency == company_currency and journal_currency != company_currency and self.foreign_currency_id:
-            balance = amounts[foreign_currency.id]
-        else:
-            balance = amounts[company_currency.id]
-
-        if foreign_currency != company_currency and self.foreign_currency_id:
-            amount_currency = amounts[foreign_currency.id]
-            currency_id = foreign_currency.id
-        elif journal_currency != company_currency and not self.foreign_currency_id:
-            amount_currency = amounts[journal_currency.id]
-            currency_id = journal_currency.id
+        if currency == foreign_currency:
+            trans_amount_currency = amount_currency
+            if rate_journal2foreign_curr:
+                journ_amount_currency = journal_currency.round(trans_amount_currency / rate_journal2foreign_curr)
+            else:
+                journ_amount_currency = 0.0
+            if rate_comp2journal_curr:
+                new_balance = company_currency.round(journ_amount_currency / rate_comp2journal_curr)
+            else:
+                new_balance = 0.0
+        elif currency == journal_currency:
+            trans_amount_currency = foreign_currency.round(amount_currency * rate_journal2foreign_curr)
+            if rate_comp2journal_curr:
+                new_balance = company_currency.round(amount_currency / rate_comp2journal_curr)
+            else:
+                new_balance = 0.0
         else:
-            amount_currency = amounts[company_currency.id]
-            currency_id = company_currency.id
+            journ_amount_currency = journal_currency.round(balance * rate_comp2journal_curr)
+            trans_amount_currency = foreign_currency.round(journ_amount_currency * rate_journal2foreign_curr)
+            new_balance = balance
 
         return {
-            **counterpart_vals,
-            'name': counterpart_vals.get('name', move_line.name if move_line else ''),
-            'move_id': self.move_id.id,
-            'partner_id': self.partner_id.id or counterpart_vals.get('partner_id', move_line.partner_id.id if move_line else False),
-            'currency_id': currency_id,
-            'account_id': counterpart_vals.get('account_id', move_line.account_id.id if move_line else False),
-            'debit': balance if balance > 0.0 else 0.0,
-            'credit': -balance if balance < 0.0 else 0.0,
-            'amount_currency': amount_currency,
+            'amount_currency': trans_amount_currency,
+            'balance': new_balance,
         }
 
-    @api.model
     def _prepare_move_line_default_vals(self, counterpart_account_id=None):
         ''' Prepare the dictionary to create the default account.move.lines for the current account.bank.statement.line
         record.
@@ -737,44 +655,49 @@ class AccountBankStatementLine(models.Model):
 
         if not counterpart_account_id:
             raise UserError(_(
-                "You can't create a new statement line without a suspense account set on the %s journal."
-            ) % self.journal_id.display_name)
+                "You can't create a new statement line without a suspense account set on the %s journal.",
+                self.journal_id.display_name,
+            ))
 
-        liquidity_line_vals = self._prepare_liquidity_move_line_vals()
+        journal = self.journal_id
+        company_currency = journal.company_id.currency_id
+        journal_currency = journal.currency_id or company_currency
+        foreign_currency = self.foreign_currency_id or journal_currency or company_currency
 
-        # Ensure the counterpart will have a balance exactly equals to the amount in journal currency.
-        # This avoid some rounding issues when the currency rate between two currencies is not symmetrical.
-        # E.g:
-        # A.convert(amount_a, B) = amount_b
-        # B.convert(amount_b, A) = amount_c != amount_a
+        journal_amount = self.amount
+        if foreign_currency == journal_currency:
+            transaction_amount = journal_amount
+        else:
+            transaction_amount = self.amount_currency
+        if journal_currency == company_currency:
+            company_amount = journal_amount
+        elif foreign_currency == company_currency:
+            company_amount = transaction_amount
+        else:
+            company_amount = journal_currency._convert(journal_amount, company_currency, journal.company_id, self.date)
 
-        counterpart_vals = {
+        liquidity_line_vals = {
             'name': self.payment_ref,
-            'account_id': counterpart_account_id,
-            'amount_residual': liquidity_line_vals['debit'] - liquidity_line_vals['credit'],
+            'move_id': self.move_id.id,
+            'partner_id': self.partner_id.id,
+            'account_id': journal.default_account_id.id,
+            'currency_id': journal_currency.id,
+            'amount_currency': journal_amount,
+            'debit': company_amount > 0 and company_amount or 0.0,
+            'credit': company_amount < 0 and -company_amount or 0.0,
         }
 
-        if self.foreign_currency_id and self.foreign_currency_id != self.company_currency_id:
-            # Ensure the counterpart will have exactly the same amount in foreign currency as the amount set in the
-            # statement line to avoid some rounding issues when making a currency conversion.
-
-            counterpart_vals.update({
-                'currency_id': self.foreign_currency_id.id,
-                'amount_residual_currency': self.amount_currency,
-            })
-        elif liquidity_line_vals['currency_id']:
-            # Ensure the counterpart will have a balance exactly equals to the amount in journal currency.
-            # This avoid some rounding issues when the currency rate between two currencies is not symmetrical.
-            # E.g:
-            # A.convert(amount_a, B) = amount_b
-            # B.convert(amount_b, A) = amount_c != amount_a
-
-            counterpart_vals.update({
-                'currency_id': liquidity_line_vals['currency_id'],
-                'amount_residual_currency': liquidity_line_vals['amount_currency'],
-            })
-
-        counterpart_line_vals = self._prepare_counterpart_move_line_vals(counterpart_vals)
+        # Create the counterpart line values.
+        counterpart_line_vals = {
+            'name': self.payment_ref,
+            'account_id': counterpart_account_id,
+            'move_id': self.move_id.id,
+            'partner_id': self.partner_id.id,
+            'currency_id': foreign_currency.id,
+            'amount_currency': -transaction_amount,
+            'debit': -company_amount if company_amount < 0.0 else 0.0,
+            'credit': company_amount if company_amount > 0.0 else 0.0,
+        }
         return [liquidity_line_vals, counterpart_line_vals]
 
     # -------------------------------------------------------------------------
@@ -1014,244 +937,129 @@ class AccountBankStatementLine(models.Model):
             st_line.move_id.write(st_line_vals)
 
     # -------------------------------------------------------------------------
-    # RECONCILIATION METHODS
+    # BUSINESS METHODS
     # -------------------------------------------------------------------------
 
-    def _prepare_reconciliation(self, lines_vals_list, allow_partial=False):
-        ''' Helper for the "reconcile" method used to get a full preview of the reconciliation result. This method is
-        quite useful to deal with reconcile models or the reconciliation widget because it ensures the values seen by
-        the user are exactly the values you get after reconciling.
-
-        :param lines_vals_list: See the 'reconcile' method.
-        :param allow_partial:   In case of matching a line having an higher amount, allow creating a partial instead
-                                an open balance on the statement line.
-        :return: The diff to be applied on the statement line as a tuple
-        (
-            lines_to_create:    The values to create the account.move.line on the statement line.
-            payments_to_create: The values to create the account.payments.
-            open_balance_vals:  A dictionary to create the open-balance line or None if the reconciliation is full.
-            existing_lines:     The counterpart lines to which the reconciliation will be done.
-        )
-        '''
-        self.ensure_one()
-        journal = self.journal_id
-        company_currency = journal.company_id.currency_id
-        foreign_currency = self.foreign_currency_id or journal.currency_id or company_currency
-
-        liquidity_lines, suspense_lines, other_lines = self._seek_for_lines()
-
-        # Ensure the statement line has not yet been already reconciled.
-        # If the move has 'to_check' enabled, it means the statement line has created some lines that
-        # need to be checked later and replaced by the real ones.
-        if not self.move_id.to_check and other_lines:
-            raise UserError(_("The statement line has already been reconciled."))
-
-        # A list of dictionary containing:
-        # - line_vals:          The values to create the account.move.line on the statement line.
-        # - payment_vals:       The optional values to create a bridge account.payment
-        # - counterpart_line:   The optional counterpart line to reconcile with 'line'.
-        reconciliation_overview = []
-
-        total_balance = liquidity_lines.balance
-        total_amount_currency = liquidity_lines.amount_currency
-        sign = 1 if liquidity_lines.balance > 0.0 else -1
-
-        # Step 1: Split 'lines_vals_list' into two batches:
-        # - The existing account.move.lines that need to be reconciled with the statement line.
-        #       => Will be managed at step 2.
-        # - The account.move.lines to be created from scratch.
-        #       => Will be managed directly.
-
-        # In case of the payment is matched directly with an higher amount, don't create an open
-        # balance but a partial reconciliation.
-        partial_rec_needed = allow_partial
-
-        to_browse_ids = []
-        to_process_vals = []
-        for vals in lines_vals_list:
-            # Don't modify the params directly.
-            vals = dict(vals)
-
-            if 'id' in vals:
-                # Existing account.move.line.
-                to_browse_ids.append(vals.pop('id'))
-                to_process_vals.append(vals)
-                if any(x in vals for x in ('balance', 'amount_residual', 'amount_residual_currency')):
-                    partial_rec_needed = False
-            else:
-                # Newly created account.move.line from scratch.
-                line_vals = self._prepare_counterpart_move_line_vals(vals)
-                total_balance += line_vals['debit'] - line_vals['credit']
-                total_amount_currency += line_vals['amount_currency']
-                reconciliation_overview.append({'line_vals': line_vals})
-                partial_rec_needed = False
-
-        # Step 2: Browse counterpart lines all in one and process them.
-
-        existing_lines = self.env['account.move.line'].browse(to_browse_ids)
-
-        i = 0
-        for line, counterpart_vals in zip(existing_lines, to_process_vals):
-            line_vals = self._prepare_counterpart_move_line_vals(counterpart_vals, move_line=line)
-            balance = line_vals['debit'] - line_vals['credit']
-            amount_currency = line_vals['amount_currency']
-            i += 1
-
-            if i == len(existing_lines):
-                # Last line.
-
-                if partial_rec_needed and sign * (total_amount_currency + amount_currency) < 0.0:
-
-                    # On the last aml, when the total matched amount becomes higher than the residual amount of the
-                    # statement line, make sure to not create an open balance later.
-                    line_vals = self._prepare_counterpart_move_line_vals(
-                        {
-                            **counterpart_vals,
-                            'amount_residual': -math.copysign(total_balance, balance),
-                            'amount_residual_currency': -math.copysign(total_amount_currency, amount_currency),
-                            'currency_id': foreign_currency.id,
-                        },
-                        move_line=line,
-                    )
-                    balance = line_vals['debit'] - line_vals['credit']
-                    amount_currency = line_vals['amount_currency']
-
-            elif sign * total_amount_currency < 0.0:
-                # The partial reconciliation is no longer an option since the total matched amount is now higher than
-                # the residual amount of the statement line but this is not the last line to process. Then, since we
-                # don't want to create zero balance lines, do nothing and let the open-balance be created like it
-                # should.
-                partial_rec_needed = False
-
-            total_balance += balance
-            total_amount_currency += amount_currency
-
-            reconciliation_overview.append({
-                'line_vals': line_vals,
-                'counterpart_line': line,
-            })
-
-        # Step 3: Fix rounding issue due to currency conversions.
-        # Add the remaining balance on the first encountered line starting with the custom ones.
-
-        if foreign_currency.is_zero(total_amount_currency) and not company_currency.is_zero(total_balance):
-            vals = reconciliation_overview[0]['line_vals']
-            new_balance = vals['debit'] - vals['credit'] - total_balance
-            vals.update({
-                'debit': new_balance if new_balance > 0.0 else 0.0,
-                'credit': -new_balance if new_balance < 0.0 else 0.0,
-            })
-            total_balance = 0.0
-
-        # Step 4: If the journal entry is not yet balanced, create an open balance.
+    def _get_st_line_strings_for_matching(self, allowed_fields=None):
+        """ Collect the strings that could be used on the statement line to perform some matching.
 
-        if self.company_currency_id.round(total_balance):
-            counterpart_vals = {
-                'name': '%s: %s' % (self.payment_ref, _('Open Balance')),
-                'balance': -total_balance,
-                'currency_id': self.company_currency_id.id,
-            }
-
-            partner = self.partner_id or existing_lines.mapped('partner_id')[:1]
-            if partner:
-                if self.amount > 0:
-                    open_balance_account = partner.with_company(self.company_id).property_account_receivable_id
-                else:
-                    open_balance_account = partner.with_company(self.company_id).property_account_payable_id
+        :param allowed_fields: A explicit list of fields to consider.
+        :return: A list of strings.
+        """
+        self.ensure_one()
 
-                counterpart_vals['account_id'] = open_balance_account.id
-                counterpart_vals['partner_id'] = partner.id
+        def _get_text_value(field_name):
+            if self._fields[field_name].type == 'html':
+                return html2plaintext(self[field_name])
             else:
-                if self.amount > 0:
-                    open_balance_account = self.company_id.partner_id.with_company(self.company_id).property_account_receivable_id
-                else:
-                    open_balance_account = self.company_id.partner_id.with_company(self.company_id).property_account_payable_id
-                counterpart_vals['account_id'] = open_balance_account.id
-
-            open_balance_vals = self._prepare_counterpart_move_line_vals(counterpart_vals)
-        else:
-            open_balance_vals = None
-
-        return reconciliation_overview, open_balance_vals
-
-    def reconcile(self, lines_vals_list, to_check=False, allow_partial=False):
-        ''' Perform a reconciliation on the current account.bank.statement.line with some
-        counterpart account.move.line.
-        If the statement line entry is not fully balanced after the reconciliation, an open balance will be created
-        using the partner.
-
-        :param lines_vals_list: A list of python dictionary containing:
-            'id':               Optional id of an existing account.move.line.
-                                For each line having an 'id', a new line will be created in the current statement line.
-            'balance':          Optional amount to consider during the reconciliation. If a foreign currency is set on the
-                                counterpart line in the same foreign currency as the statement line, then this amount is
-                                considered as the amount in foreign currency. If not specified, the full balance is taken.
-                                This value must be provided if 'id' is not.
-            **kwargs:           Custom values to be set on the newly created account.move.line.
-        :param to_check:        Mark the current statement line as "to_check" (see field for more details).
-        :param allow_partial:   In case of matching a line having an higher amount, allow creating a partial instead
-                                of an open balance on the statement line.
-        '''
+                return self[field_name]
+
+        st_line_text_values = []
+        if allowed_fields is None or 'payment_ref' in allowed_fields:
+            value = _get_text_value('payment_ref')
+            if value:
+                st_line_text_values.append(value)
+        if allowed_fields is None or 'narration' in allowed_fields:
+            value = _get_text_value('narration')
+            if value:
+                st_line_text_values.append(value)
+        if allowed_fields is None or 'ref' in allowed_fields:
+            value = _get_text_value('ref')
+            if value:
+                st_line_text_values.append(value)
+        return st_line_text_values
+
+    def _get_default_amls_matching_domain(self):
+        return [
+            # Base domain.
+            ('display_type', 'not in', ('line_section', 'line_note')),
+            ('move_id.state', '=', 'posted'),
+            ('company_id', '=', self.company_id.id),
+            # Reconciliation domain.
+            ('reconciled', '=', False),
+            ('account_id.reconcile', '=', True),
+            # Special domain for payments.
+            '|',
+            ('account_id.internal_type', 'not in', ('receivable', 'payable')),
+            ('payment_id', '=', False),
+            # Special domain for statement lines.
+            ('statement_line_id', '!=', self.id),
+        ]
+
+    def _retrieve_partner(self):
         self.ensure_one()
-        liquidity_lines, suspense_lines, other_lines = self._seek_for_lines()
-
-        reconciliation_overview, open_balance_vals = self._prepare_reconciliation(
-            lines_vals_list,
-            allow_partial=allow_partial,
-        )
-
-        # ==== Manage res.partner.bank ====
-
-        if self.account_number and self.partner_id and not self.partner_bank_id:
-            self.partner_bank_id = self._find_or_create_bank_account()
-
-        # ==== Check open balance ====
-
-        if open_balance_vals:
-            if not open_balance_vals.get('partner_id'):
-                raise UserError(_("Unable to create an open balance for a statement line without a partner set."))
-            if not open_balance_vals.get('account_id'):
-                raise UserError(_("Unable to create an open balance for a statement line because the receivable "
-                                  "/ payable accounts are missing on the partner."))
-
-        # ==== Create & reconcile lines on the bank statement line ====
 
-        to_create_commands = [(0, 0, open_balance_vals)] if open_balance_vals else []
-        to_delete_commands = [(2, line.id) for line in suspense_lines + other_lines]
-
-        # Cleanup previous lines.
-        self.move_id.with_context(check_move_validity=False, skip_account_move_synchronization=True, force_delete=True).write({
-            'line_ids': to_delete_commands + to_create_commands,
-            'to_check': to_check,
-        })
-
-        line_vals_list = [reconciliation_vals['line_vals'] for reconciliation_vals in reconciliation_overview]
-        new_lines = self.env['account.move.line'].create(line_vals_list)
-        new_lines = new_lines.with_context(skip_account_move_synchronization=True)
-        for reconciliation_vals, line in zip(reconciliation_overview, new_lines):
-            if reconciliation_vals.get('counterpart_line'):
-                counterpart_line = reconciliation_vals['counterpart_line']
-            else:
+        # Retrieve the partner from the statement line.
+        if self.partner_id:
+            return self.partner_id
+
+        # Retrieve the partner from the bank account.
+        if self.account_number:
+            account_number_nums = sanitize_account_number(self.account_number)
+            if account_number_nums:
+                domain = [('sanitized_acc_number', 'ilike', account_number_nums)]
+                for extra_domain in ([('company_id', '=', self.company_id.id)], []):
+                    bank_accounts = self.env['res.partner.bank'].search(extra_domain + domain)
+                    if len(bank_accounts.partner_id) == 1:
+                        return bank_accounts.partner_id
+
+        # Retrieve the partner from the partner name.
+        if self.partner_name:
+            domain = [
+                ('parent_id', '=', False),
+                ('name', 'ilike', self.partner_name),
+            ]
+            for extra_domain in ([('company_id', '=', self.company_id.id)], []):
+                partner = self.env['res.partner'].search(extra_domain + domain, limit=1)
+                if partner:
+                    return partner
+
+        # Retrieve the partner from the reconcile models.
+        rec_models = self.env['account.reconcile.model'].search([
+            ('rule_type', '!=', 'writeoff_button'),
+            ('company_id', '=', self.company_id.id),
+        ])
+        for rec_model in rec_models:
+            partner = rec_model._get_partner_from_mapping(self)
+            if partner and rec_model._is_applicable_for(self, partner):
+                return partner
+
+        # Retrieve the partner from statement line text values.
+        st_line_text_values = self._get_st_line_strings_for_matching()
+        unaccent = get_unaccent_wrapper(self._cr)
+        sub_queries = []
+        params = []
+        for text_value in st_line_text_values:
+            if not text_value:
                 continue
 
-            (line + counterpart_line).reconcile()
-
-        # Assign partner if needed (for example, when reconciling a statement
-        # line with no partner, with an invoice; assign the partner of this invoice)
-        if not self.partner_id:
-            rec_overview_partners = set(overview['counterpart_line'].partner_id.id
-                                        for overview in reconciliation_overview
-                                        if overview.get('counterpart_line'))
-            if len(rec_overview_partners) == 1 and rec_overview_partners != {False}:
-                self.line_ids.write({'partner_id': rec_overview_partners.pop()})
-
-        # Refresh analytic lines.
-        self.move_id.line_ids.analytic_line_ids.unlink()
-        self.move_id.line_ids.create_analytic_lines()
+            # Find a partner having a name contained inside the statement line values.
+            # Take care a partner could contain some special characters in its name that needs to be escaped.
+            sub_queries.append(rf'''
+                {unaccent("%s")} ~* ('^' || (
+                   SELECT STRING_AGG(CONCAT('(?=.*\m', chunk[1], '\M)'), '')
+                   FROM regexp_matches({unaccent('name')}, '\w{{3,}}', 'g') AS chunk
+                ))
+            ''')
+            params.append(text_value)
+
+        if sub_queries:
+            self.env['res.partner'].flush_model(['company_id', 'name'])
+            self._cr.execute(
+                '''
+                    SELECT id
+                    FROM res_partner
+                    WHERE (company_id IS NULL OR company_id = %s)
+                        AND name IS NOT NULL
+                        AND (''' + ') OR ('.join(sub_queries) + ''')
+                ''',
+                [self.company_id.id] + params,
+            )
+            rows = self._cr.fetchall()
+            if len(rows) == 1:
+                return self.env['res.partner'].browse(rows[0][0])
 
-    # -------------------------------------------------------------------------
-    # BUSINESS METHODS
-    # -------------------------------------------------------------------------
+        return self.env['res.partner']
 
     def _find_or_create_bank_account(self):
         bank_account = self.env['res.partner.bank'].search([

--- a/addons/account/models/account_journal_dashboard.py
+++ b/addons/account/models/account_journal_dashboard.py
@@ -486,10 +486,11 @@ class account_journal(models.Model):
 
     def to_check_ids(self):
         self.ensure_one()
-        domain = self.env['account.move.line']._get_suspense_moves_domain()
-        domain.append(('journal_id', '=', self.id))
-        statement_line_ids = self.env['account.move.line'].search(domain).mapped('statement_line_id')
-        return statement_line_ids
+        return self.env['account.bank.statement.line'].search([
+            ('journal_id', '=', self.id),
+            ('move_id.to_check', '=', True),
+            ('move_id.state', '=', 'posted'),
+        ])
 
     def _select_action_to_open(self):
         self.ensure_one()

--- a/addons/account/models/account_move.py
+++ b/addons/account/models/account_move.py
@@ -368,9 +368,6 @@ class AccountMove(models.Model):
     invoice_filter_type_domain = fields.Char(compute='_compute_invoice_filter_type_domain',
         help="Technical field used to have a dynamic domain on journal / taxes in the form view.")
     bank_partner_id = fields.Many2one('res.partner', help='Technical field to get the domain on the bank', compute='_compute_bank_partner_id')
-    invoice_has_matching_suspense_amount = fields.Boolean(compute='_compute_has_matching_suspense_amount',
-        groups='account.group_account_invoice,account.group_account_readonly',
-        help="Technical field used to display an alert on invoices if there is at least a matching amount in any supsense account.")
     tax_lock_date_message = fields.Char(
         compute='_compute_tax_lock_date_message',
         help="Technical field used to display a message when the invoice's accounting date is prior of the tax lock date.")
@@ -1531,33 +1528,6 @@ class AccountMove(models.Model):
 
             move.write({'line_ids': to_write})
 
-    def _get_domain_matching_suspense_moves(self):
-        self.ensure_one()
-        domain = self.env['account.move.line']._get_suspense_moves_domain()
-        domain += ['|', ('partner_id', '=?', self.partner_id.id), ('partner_id', '=', False)]
-        if self.is_inbound():
-            domain.append(('balance', '=', -self.amount_residual))
-        else:
-            domain.append(('balance', '=', self.amount_residual))
-        return domain
-
-    def _compute_has_matching_suspense_amount(self):
-        for r in self:
-            res = False
-            if r.state == 'posted' and r.is_invoice() and r.payment_state == 'not_paid':
-                domain = r._get_domain_matching_suspense_moves()
-                #there are more than one but less than 5 suspense moves matching the residual amount
-                if (0 < self.env['account.move.line'].search_count(domain) < 5):
-                    domain2 = [
-                        ('payment_state', '=', 'not_paid'),
-                        ('state', '=', 'posted'),
-                        ('amount_residual', '=', r.amount_residual),
-                        ('move_type', '=', r.move_type)]
-                    #there are less than 5 other open invoices of the same type with the same residual
-                    if self.env['account.move'].search_count(domain2) < 5:
-                        res = True
-            r.invoice_has_matching_suspense_amount = res
-
     @api.depends('partner_id', 'invoice_source_email', 'partner_id.name')
     def _compute_invoice_partner_display_info(self):
         for move in self:
@@ -2904,12 +2874,6 @@ class AccountMove(models.Model):
             move.to_check = False
 
     def button_draft(self):
-        AccountMoveLine = self.env['account.move.line']
-        excluded_move_ids = []
-
-        if self._context.get('suspense_moves_mode'):
-            excluded_move_ids = AccountMoveLine.search(AccountMoveLine._get_suspense_moves_domain() + [('move_id', 'in', self.ids)]).mapped('move_id').ids
-
         for move in self:
             if move in move.line_ids.mapped('full_reconcile_id.exchange_move_id'):
                 raise UserError(_('You cannot reset to draft an exchange difference journal entry.'))
@@ -2920,7 +2884,7 @@ class AccountMove(models.Model):
                 # so we also check tax_cash_basis_origin_move_id, which stays unchanged
                 # (we need both, as tax_cash_basis_origin_move_id did not exist in older versions).
                 raise UserError(_('You cannot reset to draft a tax cash basis journal entry.'))
-            if move.restrict_mode_hash_table and move.state == 'posted' and move.id not in excluded_move_ids:
+            if move.restrict_mode_hash_table and move.state == 'posted':
                 raise UserError(_('You cannot modify a posted entry of this journal because it is in strict mode.'))
             # We remove all the analytics entries for this journal
             move.mapped('line_ids.analytic_line_ids').unlink()
@@ -3395,7 +3359,7 @@ class AccountMove(models.Model):
 class AccountMoveLine(models.Model):
     _name = "account.move.line"
     _description = "Journal Item"
-    _order = "date desc, move_name desc, id"
+    _order = "date desc, move_name desc, sequence, id"
     _check_company_auto = True
 
     # ==== Business fields ====
@@ -5783,13 +5747,35 @@ class AccountMoveLine(models.Model):
         action['context'] = ctx
         return action
 
-    @api.model
-    def _get_suspense_moves_domain(self):
-        return [
-            ('move_id.to_check', '=', True),
-            ('full_reconcile_id', '=', False),
-            ('statement_line_id', '!=', False),
-        ]
+    def action_open_business_doc_from_aml(self):
+        self.ensure_one()
+
+        if self.payment_id:
+            name = _("Payment")
+            res_model = 'account.payment'
+            res_id = self.payment_id.id
+        elif self.statement_line_id:
+            name = _("Bank Transaction")
+            res_model = 'account.bank.statement.line'
+            res_id = self.statement_line_id.id
+        else:
+            name = _("Journal Entry")
+            res_model = 'account.move'
+            res_id = self.move_id.id
+
+        return {
+            'name': name,
+            'type': 'ir.actions.act_window',
+            'view_mode': 'form',
+            'view_id': self.env.ref('account.view_move_form').id,
+            'res_model': res_model,
+            'res_id': res_id,
+            'context': {
+                'create': False,
+                'delete': False,
+            },
+            'target': 'current',
+        }
 
     def _get_attachment_domains(self):
         self.ensure_one()

--- a/addons/account/models/account_reconcile_model.py
+++ b/addons/account/models/account_reconcile_model.py
@@ -115,6 +115,105 @@ class AccountReconcileModelLine(models.Model):
                 except re.error:
                     raise UserError(_('The regex is not valid'))
 
+    def _prepare_aml_vals(self, partner):
+        """ Prepare a dictionary that will be used later to create a new journal item (account.move.line) for the
+        given reconcile model line.
+
+        :param partner: The partner to be linked to the journal item.
+        :return:        A python dictionary.
+        """
+        self.ensure_one()
+
+        taxes = self.tax_ids
+        if taxes and partner:
+            fiscal_position = self.env['account.fiscal.position']._get_fiscal_position(partner)
+            if fiscal_position:
+                taxes = fiscal_position.map_tax(taxes)
+
+        return {
+            'name': self.label,
+            'account_id': self.account_id.id,
+            'partner_id': partner.id,
+            'analytic_account_id': self.analytic_account_id.id,
+            'analytic_tag_ids': [Command.set(self.analytic_tag_ids.ids)],
+            'tax_ids': [Command.set(taxes.ids)],
+            'reconcile_model_id': self.model_id.id,
+        }
+
+    def _apply_in_manual_widget(self, residual_amount_currency, partner, currency):
+        """ Prepare a dictionary that will be used later to create a new journal item (account.move.line) for the
+        given reconcile model line used by the manual reconciliation widget.
+
+        Note: 'journal_id' is added to the returned dictionary even if it is a related readonly field.
+        It's a hack for the manual reconciliation widget. Indeed, a single journal entry will be created for each
+        journal.
+
+        :param residual_amount_currency:    The current balance expressed in the account's currency.
+        :param partner:                     The partner to be linked to the journal item.
+        :param currency:                    The currency set on the account in the manual reconciliation widget.
+        :return:                            A python dictionary.
+        """
+        self.ensure_one()
+
+        if self.amount_type == 'percentage':
+            amount_currency = currency.round(residual_amount_currency * (self.amount / 100.0))
+        elif self.amount_type == 'fixed':
+            sign = 1 if residual_amount_currency > 0.0 else -1
+            amount_currency = currency.round(self.amount * sign)
+        else:
+            raise UserError(_("This reconciliation model can't be used in the manual reconciliation widget because its "
+                              "configuration is not adapted"))
+
+        return {
+            **self._prepare_aml_vals(partner),
+            'currency_id': currency.id,
+            'amount_currency': amount_currency,
+            'journal_id': self.journal_id.id,
+        }
+
+    def _apply_in_bank_widget(self, residual_amount_currency, partner, st_line):
+        """ Prepare a dictionary that will be used later to create a new journal item (account.move.line) for the
+        given reconcile model line used by the bank reconciliation widget.
+
+        :param residual_amount_currency:    The current balance expressed in the statement line's currency.
+        :param partner:                     The partner to be linked to the journal item.
+        :param st_line:                     The statement line mounted inside the bank reconciliation widget.
+        :return:                            A python dictionary.
+        """
+        self.ensure_one()
+        currency = st_line.foreign_currency_id or st_line.journal_id.currency_id or st_line.company_currency_id
+
+        amount_currency = None
+        if self.amount_type == 'percentage_st_line':
+            amount_currency = currency.round(residual_amount_currency * (self.amount / 100.0))
+        elif self.amount_type == 'regex':
+            match = re.search(self.amount_string, st_line.payment_ref)
+            if match:
+                sign = 1 if residual_amount_currency > 0.0 else -1
+                decimal_separator = self.model_id.decimal_separator
+                try:
+                    extracted_match_group = re.sub(r'[^\d' + decimal_separator + ']', '', match.group(1))
+                    extracted_balance = float(extracted_match_group.replace(decimal_separator, '.'))
+                    amount_currency = copysign(extracted_balance * sign, residual_amount_currency)
+                except ValueError:
+                    amount_currency = 0.0
+            else:
+                amount_currency = 0.0
+
+        if amount_currency is None:
+            aml_vals = self._apply_in_manual_widget(residual_amount_currency, partner, currency)
+        else:
+            aml_vals = {
+                **self._prepare_aml_vals(partner),
+                'currency_id': currency.id,
+                'amount_currency': amount_currency,
+            }
+
+        if not aml_vals['name']:
+            aml_vals['name'] = st_line.payment_ref
+
+        return aml_vals
+
 
 class AccountReconcileModel(models.Model):
     _name = 'account.reconcile.model'
@@ -312,7 +411,35 @@ class AccountReconcileModel(models.Model):
     # RECONCILIATION PROCESS
     ####################################################
 
-    def _get_taxes_move_lines_dict(self, tax, base_line_dict, statement_line=None):
+    def _apply_lines_for_bank_widget(self, residual_amount_currency, partner, st_line):
+        """ Apply the reconciliation model lines to the statement line passed as parameter.
+
+        :param residual_amount_currency:    The open balance of the statement line in the bank reconciliation widget
+                                            expressed in the statement line currency.
+        :param partner:                     The partner set on the wizard.
+        :param st_line:                     The statement line processed by the bank reconciliation widget.
+        :return:                            A list of python dictionaries (one per reconcile model line) representing
+                                            the journal items to be created by the current reconcile model.
+        """
+        self.ensure_one()
+        currency = st_line.foreign_currency_id or st_line.journal_id.currency_id or st_line.company_currency_id
+        if currency.is_zero(residual_amount_currency):
+            return []
+
+        vals_list = []
+        for line in self.line_ids:
+            vals = line._apply_in_bank_widget(residual_amount_currency, partner, st_line)
+            amount_currency = vals['amount_currency']
+
+            if currency.is_zero(amount_currency):
+                continue
+
+            vals_list.append(vals)
+            residual_amount_currency -= amount_currency
+
+        return vals_list
+
+    def _get_taxes_move_lines_dict(self, tax, base_line_dict):
         ''' Get move.lines dict (to be passed to the create()) corresponding to a tax.
         :param tax:             An account.tax record.
         :param base_line_dict:  A dict representing the move.line containing the base amount.
@@ -322,10 +449,7 @@ class AccountReconcileModel(models.Model):
         balance = base_line_dict['balance']
 
         tax_type = tax.type_tax_use
-        if statement_line:
-            is_refund = (tax_type == 'sale' and balance > 0) or (tax_type == 'purchase' and balance < 0)
-        else:
-            is_refund = (tax_type == 'sale' and balance < 0) or (tax_type == 'purchase' and balance > 0)
+        is_refund = (tax_type == 'sale' and balance < 0) or (tax_type == 'purchase' and balance > 0)
 
         res = tax.compute_all(balance, is_refund=is_refund)
 
@@ -347,6 +471,7 @@ class AccountReconcileModel(models.Model):
                 'tax_repartition_line_id': tax_res['tax_repartition_line_id'],
                 'tax_ids': [(6, 0, tax_res['tax_ids'])],
                 'tax_tag_ids': [(6, 0, tax_res['tag_ids'])],
+                'group_tax_id': tax_res['group'].id if tax_res['group'] else False,
                 'currency_id': False,
                 'reconcile_model_id': self.id,
             })
@@ -362,10 +487,9 @@ class AccountReconcileModel(models.Model):
         base_line_dict['tax_tag_ids'] = [(6, 0, res['base_tags'])]
         return new_aml_dicts
 
-    def _get_write_off_move_lines_dict(self, st_line, residual_balance, partner_id):
-        ''' Get move.lines dict (to be passed to the create()) corresponding to the reconciliation model's write-off lines.
-        :param st_line:             An account.bank.statement.line record.(possibly empty, if performing manual reconciliation)
-        :param residual_balance:    The residual balance of the statement line.
+    def _get_write_off_move_lines_dict(self, residual_balance, partner_id):
+        ''' Get move.lines dict corresponding to the reconciliation model's write-off lines.
+        :param residual_balance:    The residual balance of the account on the manual reconciliation widget.
         :return: A list of dict representing move.lines to be created corresponding to the write-off lines.
         '''
         self.ensure_one()
@@ -373,38 +497,12 @@ class AccountReconcileModel(models.Model):
         if self.rule_type == 'invoice_matching' and (not self.allow_payment_tolerance or self.payment_tolerance_param == 0):
             return []
 
-        if st_line:
-            currency = st_line.foreign_currency_id or st_line.currency_id
-            matched_candidates_values = self._process_matched_candidates_data(st_line)
-            st_line_residual = matched_candidates_values['balance_sign'] * matched_candidates_values['residual_balance_curr']
-        else:
-            currency = self.company_id.currency_id
-
-            # No statement line
-            if any(x.amount_type == 'percentage_st_line' for x in self.line_ids):
-                return []
+        currency = self.company_id.currency_id
 
         lines_vals_list = []
         for line in self.line_ids:
             if line.amount_type == 'percentage':
                 balance = currency.round(residual_balance * (line.amount / 100.0))
-            elif line.amount_type == 'percentage_st_line':
-                if st_line:
-                    balance = currency.round(st_line_residual * (line.amount / 100.0))
-                else:
-                    balance = 0.0
-            elif line.amount_type == 'regex':
-                match = re.search(line.amount_string, st_line.payment_ref)
-                if match:
-                    sign = 1 if residual_balance > 0.0 else -1
-                    try:
-                        extracted_match_group = re.sub(r'[^\d' + self.decimal_separator + ']', '', match.group(1))
-                        extracted_balance = float(extracted_match_group.replace(self.decimal_separator, '.'))
-                        balance = copysign(extracted_balance * sign, residual_balance)
-                    except ValueError:
-                        balance = 0
-                else:
-                    balance = 0
             elif line.amount_type == 'fixed':
                 balance = currency.round(line.amount * (1 if residual_balance > 0.0 else -1))
 
@@ -412,7 +510,7 @@ class AccountReconcileModel(models.Model):
                 continue
 
             writeoff_line = {
-                'name': line.label or st_line.payment_ref,
+                'name': line.label,
                 'balance': balance,
                 'debit': balance > 0 and balance or 0,
                 'credit': balance < 0 and -balance or 0,
@@ -438,7 +536,7 @@ class AccountReconcileModel(models.Model):
                 # only allow to set the force_tax_included field if we have one tax selected
                 if line.force_tax_included:
                     taxes = taxes[0].with_context(force_price_include=True)
-                tax_vals_list = self._get_taxes_move_lines_dict(taxes, writeoff_line, statement_line=st_line)
+                tax_vals_list = self._get_taxes_move_lines_dict(taxes, writeoff_line)
                 lines_vals_list += tax_vals_list
                 if not line.force_tax_included:
                     for tax_line in tax_vals_list:
@@ -450,76 +548,56 @@ class AccountReconcileModel(models.Model):
     # RECONCILIATION CRITERIA
     ####################################################
 
-    def _apply_rules(self, st_lines, excluded_ids=None, partner_map=None):
+    def _apply_rules(self, st_line, partner):
         ''' Apply criteria to get candidates for all reconciliation models.
 
         This function is called in enterprise by the reconciliation widget to match
-        the statement lines with the available candidates (using the reconciliation models).
-
-        :param st_lines:        Account.bank.statement.lines recordset.
-        :param excluded_ids:    Account.move.lines to exclude.
-        :param partner_map:     Dict mapping each line with new partner eventually.
-        :return:                A dict mapping each statement line id with:
-            * aml_ids:      A list of account.move.line ids.
-            * model:        An account.reconcile.model record (optional).
-            * status:       'reconciled' if the lines has been already reconciled, 'write_off' if the write-off must be
-                            applied on the statement line.
+        the statement line with the available candidates (using the reconciliation models).
+
+        :param st_line: The statement line to match.
+        :param partner: The partner to consider.
+        :return:        A dict mapping each statement line id with:
+            * aml_ids:          A list of account.move.line ids.
+            * model:            An account.reconcile.model record (optional).
+            * status:           'reconciled' if the lines has been already reconciled, 'write_off' if the write-off
+                                must be applied on the statement line.
+            * auto_reconcile:   A flag indicating if the match is enough significant to auto reconcile the candidates.
         '''
-        # This functions uses SQL to compute its results. We need to flush before doing anything more.
-        for model_name in ('account.bank.statement', 'account.bank.statement.line', 'account.move', 'account.move.line', 'res.company', 'account.journal', 'account.account'):
-            self.env[model_name].flush_model()
-
-        results = {line.id: {'aml_ids': []} for line in st_lines}
-
         available_models = self.filtered(lambda m: m.rule_type != 'writeoff_button').sorted()
-        aml_ids_to_exclude = set() # Keep track of already processed amls.
-        reconciled_amls_ids = set() # Keep track of already reconciled amls.
-
-        # First associate with each rec models all the statement lines for which it is applicable
-        lines_with_partner_per_model = defaultdict(lambda: [])
-        for st_line in st_lines:
-
-            # Statement lines created in old versions could have a residual amount of zero. In that case, don't try to
-            # match anything.
-            if not st_line.amount_residual:
-                continue
-
-            mapped_partner = (partner_map and partner_map.get(st_line.id) and self.env['res.partner'].browse(partner_map[st_line.id])) or st_line.partner_id
-
-            for rec_model in available_models:
-                partner = mapped_partner or rec_model._get_partner_from_mapping(st_line)
 
-                if rec_model._is_applicable_for(st_line, partner):
-                    lines_with_partner_per_model[rec_model].append((st_line, partner))
-
-        # Execute only one SQL query for each model (for performance)
-        matched_lines = self.env['account.bank.statement.line']
         for rec_model in available_models:
 
-            # We filter the lines for this model, in case a previous one has already found something for them
-            filtered_st_lines_with_partner = [x for x in lines_with_partner_per_model[rec_model] if x[0] not in matched_lines]
-
-            if not filtered_st_lines_with_partner:
-                # No unreconciled statement line for this model
+            if not rec_model._is_applicable_for(st_line, partner):
                 continue
 
-            all_model_candidates = rec_model._get_candidates(filtered_st_lines_with_partner, excluded_ids)
-
-            for st_line, partner in filtered_st_lines_with_partner:
-                candidates = all_model_candidates[st_line.id]
-                if candidates:
-                    model_rslt, new_reconciled_aml_ids, new_treated_aml_ids = rec_model._get_rule_result(st_line, candidates, aml_ids_to_exclude, reconciled_amls_ids, partner)
-
-                    if model_rslt:
-                        # We inject the selected partner (possibly coming from the rec model)
-                        model_rslt['partner']= partner
-
-                        results[st_line.id] = model_rslt
-                        reconciled_amls_ids |= new_reconciled_aml_ids
-                        aml_ids_to_exclude |= new_treated_aml_ids
-                        matched_lines += st_line
-
-        return results
+            if rec_model.rule_type == 'invoice_matching':
+                rules_map = rec_model._get_invoice_matching_rules_map()
+                for rule_index in sorted(rules_map.keys()):
+                    for rule_method in rules_map[rule_index]:
+                        candidate_vals = rule_method(st_line, partner)
+                        if not candidate_vals:
+                            continue
+
+                        if candidate_vals.get('amls'):
+                            res = rec_model._get_invoice_matching_amls_result(st_line, partner, candidate_vals)
+                            if res:
+                                return {
+                                    **res,
+                                    'model': rec_model,
+                                }
+                        else:
+                            return {
+                                **candidate_vals,
+                                'model': rec_model,
+                            }
+
+            elif rec_model.rule_type == 'writeoff_suggestion':
+                return {
+                    'model': rec_model,
+                    'status': 'write_off',
+                    'auto_reconcile': rec_model.auto_reconcile,
+                }
+        return {}
 
     def _is_applicable_for(self, st_line, partner):
         """ Returns true iff this reconciliation model can be used to search for matches
@@ -555,201 +633,147 @@ class AccountReconcileModel(models.Model):
 
         return True
 
-    def _get_candidates(self, st_lines_with_partner, excluded_ids):
-        """ Returns the match candidates for this rule, with respect to the provided parameters.
+    def _get_invoice_matching_amls_domain(self, st_line, partner):
+        aml_domain = st_line._get_default_amls_matching_domain()
 
-        :param st_lines_with_partner: A list of tuples (statement_line, partner),
-                                      associating each statement line to treate with
-                                      the corresponding partner, given by the partner map
-        :param excluded_ids: a set containing the ids of the amls to ignore during the search
-                             (because they already been matched by another rule)
-        """
-        self.ensure_one()
-
-        treatment_map = {
-            'invoice_matching': lambda x: x._get_invoice_matching_query(st_lines_with_partner, excluded_ids),
-            'writeoff_suggestion': lambda x: x._get_writeoff_suggestion_query(st_lines_with_partner, excluded_ids),
-        }
-
-        query_generator = treatment_map[self.rule_type]
-        query, params = query_generator(self)
-        self._cr.execute(query, params)
-
-        rslt = defaultdict(lambda: [])
-        for candidate_dict in self._cr.dictfetchall():
-            rslt[candidate_dict['id']].append(candidate_dict)
-
-        return rslt
-
-    def _get_invoice_matching_query(self, st_lines_with_partner, excluded_ids):
-        ''' Returns the query applying the current invoice_matching reconciliation
-        model to the provided statement lines.
-
-        :param st_lines_with_partner: A list of tuples (statement_line, partner),
-                                      associating each statement line to treate with
-                                      the corresponding partner, given by the partner map
-        :param excluded_ids:    Account.move.lines to exclude.
-        :return:                (query, params)
-        '''
-        self.ensure_one()
-        if self.rule_type != 'invoice_matching':
-            raise UserError(_('Programmation Error: Can\'t call _get_invoice_matching_query() for different rules than \'invoice_matching\''))
-
-        unaccent = get_unaccent_wrapper(self._cr)
-
-        # N.B: 'communication_flag' is there to distinguish invoice matching through the number/reference
-        # (higher priority) from invoice matching using the partner (lower priority).
-        query = r'''
-        SELECT
-            st_line.id                          AS id,
-            aml.id                              AS aml_id,
-            aml.currency_id                     AS aml_currency_id,
-            aml.date_maturity                   AS aml_date_maturity,
-            aml.amount_residual                 AS aml_amount_residual,
-            aml.amount_residual_currency        AS aml_amount_residual_currency,
-            ''' + self._get_select_communication_flag() + r''' AS communication_flag,
-            ''' + self._get_select_payment_reference_flag() + r''' AS payment_reference_flag
-        FROM account_bank_statement_line st_line
-        JOIN account_move st_line_move          ON st_line_move.id = st_line.move_id
-        JOIN res_company company                ON company.id = st_line_move.company_id
-        , account_move_line aml
-        LEFT JOIN account_move move             ON move.id = aml.move_id AND move.state = 'posted'
-        LEFT JOIN account_account account       ON account.id = aml.account_id
-        LEFT JOIN res_partner aml_partner       ON aml.partner_id = aml_partner.id
-        LEFT JOIN account_payment payment       ON payment.move_id = move.id
-        WHERE
-            aml.company_id = st_line_move.company_id
-            AND move.state = 'posted'
-            AND account.reconcile IS TRUE
-            AND aml.reconciled IS FALSE
-        '''
+        if st_line.amount > 0.0:
+            aml_domain.append(('balance', '>', 0.0))
+        else:
+            aml_domain.append(('balance', '<', 0.0))
 
-        # Add conditions to handle each of the statement lines we want to match
-        st_lines_queries = []
-        for st_line, partner in st_lines_with_partner:
-            # In case we don't have any partner for this line, we try assigning one with the rule mapping
-            if st_line.amount > 0:
-                st_line_subquery = r"aml.balance > 0"
-            else:
-                st_line_subquery = r"aml.balance < 0"
+        currency = st_line.foreign_currency_id or st_line.currency_id
+        if self.match_same_currency:
+            aml_domain.append(('currency_id', '=', currency.id))
 
-            if self.match_same_currency:
-                st_line_subquery += r" AND COALESCE(aml.currency_id, company.currency_id) = %s" % (st_line.foreign_currency_id.id or st_line.move_id.currency_id.id)
+        if partner:
+            aml_domain.append(('partner_id', '=', partner.id))
 
-            if partner:
-                st_line_subquery += r" AND aml.partner_id = %s" % partner.id
-            else:
-                st_line_fields_consideration = [
-                    (self.match_text_location_label, 'st_line.payment_ref'),
-                    (self.match_text_location_note, 'st_line_move.narration'),
-                    (self.match_text_location_reference, 'st_line_move.ref'),
-                ]
-
-                no_partner_query = " OR ".join([
-                    r"""
-                        (
-                            substring(REGEXP_REPLACE(""" + sql_field + r""", '[^0-9\s]', '', 'g'), '\S(?:.*\S)*') != ''
-                            AND
-                            (
-                                (""" + self._get_select_communication_flag() + r""")
-                                OR
-                                (""" + self._get_select_payment_reference_flag() + r""")
-                            )
-                        )
-                        OR
-                        (
-                            /* We also match statement lines without partners with amls
-                            whose partner's name's parts (splitting on space) are all present
-                            within the payment_ref, in any order, with any characters between them. */
-
-                            aml_partner.name IS NOT NULL
-                            AND """ + unaccent(sql_field) + r""" ~* ('^' || (
-                                SELECT string_agg(concat('(?=.*\m', chunk[1], '\M)'), '')
-                                  FROM regexp_matches(""" + unaccent("aml_partner.name") + r""", '\w{3,}', 'g') AS chunk
-                            ))
-                        )
-                    """
-                    for consider_field, sql_field in st_line_fields_consideration
-                    if consider_field
-                ])
-
-                if no_partner_query:
-                    st_line_subquery += " AND " + no_partner_query
-
-            st_lines_queries.append(r"st_line.id = %s AND (%s)" % (st_line.id, st_line_subquery))
-
-        query += r" AND (%s) " % " OR ".join(st_lines_queries)
-
-        params = {}
-
-        # If this reconciliation model defines a past_months_limit, we add a condition
-        # to the query to only search on move lines that are younger than this limit.
         if self.past_months_limit:
             date_limit = fields.Date.context_today(self) - relativedelta(months=self.past_months_limit)
-            query += "AND aml.date >= %(aml_date_limit)s"
-            params['aml_date_limit'] = date_limit
-
-        # Filter out excluded account.move.line.
-        if excluded_ids:
-            query += 'AND aml.id NOT IN %(excluded_aml_ids)s'
-            params['excluded_aml_ids'] = tuple(excluded_ids)
+            aml_domain.append(('date', '>=', fields.Date.to_string(date_limit)))
 
-        if self.matching_order == 'new_first':
-            query += ' ORDER BY aml_date_maturity DESC, aml_id DESC'
-        else:
-            query += ' ORDER BY aml_date_maturity ASC, aml_id ASC'
+        return aml_domain
 
-        return query, params
+    def _get_invoice_matching_st_line_tokens(self, st_line):
+        """ Parse the textual information from the statement line passed as parameter
+        in order to extract from it the meaningful information in order to perform the matching.
 
-    def _get_select_communication_flag(self):
-        self.ensure_one()
-        # Determine a matching or not with the statement line communication using the aml.name, move.name or move.ref.
-        st_ref_list = []
-        if self.match_text_location_label:
-            st_ref_list += ['st_line.payment_ref']
-        if self.match_text_location_note:
-            st_ref_list += ['st_line_move.narration']
-        if self.match_text_location_reference:
-            st_ref_list += ['st_line_move.ref']
-
-        st_ref = " || ' ' || ".join(
-            "COALESCE(%s, '')" % st_ref_name
-            for st_ref_name in st_ref_list
-        )
-        if not st_ref:
-            return "FALSE"
-
-        statement_compare = r"""(
-                {move_field} IS NOT NULL AND substring(REGEXP_REPLACE({move_field}, '[^0-9\s]', '', 'g'), '\S(?:.*\S)*') != ''
-                AND (
-                    regexp_split_to_array(substring(REGEXP_REPLACE({move_field}, '[^0-9\s]', '', 'g'), '\S(?:.*\S)*'),'\s+')
-                    && regexp_split_to_array(substring(REGEXP_REPLACE({st_ref}, '[^0-9\s]', '', 'g'), '\S(?:.*\S)*'), '\s+')
-                )
-            )"""
-        return " OR ".join(
-            statement_compare.format(move_field=field, st_ref=st_ref)
-            for field in ['aml.name', 'move.name', 'move.ref']
-        )
+        :param st_line: A statement line.
+        :return: A list of tokens, each one being a string.
+        """
+        st_line_text_values = st_line._get_st_line_strings_for_matching(allowed_fields=(
+            'payment_ref' if self.match_text_location_label else None,
+            'narration' if self.match_text_location_note else None,
+            'ref' if self.match_text_location_reference else None,
+        ))
+        significant_token_size = 4
+        tokens = []
+        for text_value in st_line_text_values:
+            for token in (text_value or '').split():
+                # The token is too short to be significant.
+                if len(token) < significant_token_size:
+                    continue
+
+                formatted_token = ''.join(x for x in token if x.isdecimal())
+
+                # The token is too short after formatting to be significant.
+                if len(formatted_token) < significant_token_size:
+                    continue
+
+                tokens.append(formatted_token)
+        return tokens
+
+    def _get_invoice_matching_amls_candidates(self, st_line, partner):
+        """ Returns the match candidates for the 'invoice_matching' rule, with respect to the provided parameters.
+
+        :param st_line: A statement line.
+        :param partner: The partner associated to the statement line.
+        """
+        assert self.rule_type == 'invoice_matching'
+        self.env['account.move'].flush_model()
+        self.env['account.move.line'].flush_model()
 
-    def _get_select_payment_reference_flag(self):
-        # Determine a matching or not with the statement line communication using the move.payment_reference.
-        st_ref_list = []
-        if self.match_text_location_label:
-            st_ref_list += ['st_line.payment_ref']
-        if self.match_text_location_note:
-            st_ref_list += ['st_line_move.narration']
-        if self.match_text_location_reference:
-            st_ref_list += ['st_line_move.ref']
-        if not st_ref_list:
-            return "FALSE"
-
-        # payment_reference is not used on account.move for payments; ref is used instead
-        return r'''((move.payment_reference IS NOT NULL OR (payment.id IS NOT NULL AND move.ref IS NOT NULL)) AND ({}))'''.format(
-            ' OR '.join(
-                rf"regexp_replace(CASE WHEN payment.id IS NULL THEN move.payment_reference ELSE move.ref END, '\s+', '', 'g') = regexp_replace({st_ref}, '\s+', '', 'g')"
-                for st_ref in st_ref_list
+        if self.matching_order == 'new_first':
+            order_by = 'sub.date_maturity DESC, sub.date DESC, sub.id DESC'
+        else:
+            order_by = 'sub.date_maturity ASC, sub.date ASC, sub.id ASC'
+
+        aml_domain = self._get_invoice_matching_amls_domain(st_line, partner)
+        query = self.env['account.move.line']._where_calc(aml_domain)
+        tables, where_clause, where_params = query.get_sql()
+
+        tokens = self._get_invoice_matching_st_line_tokens(st_line)
+        if tokens:
+            sub_queries = []
+            for table_alias, field in (
+                ('account_move_line', 'name'),
+                ('account_move_line__move_id', 'name'),
+                ('account_move_line__move_id', 'ref'),
+            ):
+                sub_queries.append(rf'''
+                    SELECT
+                        account_move_line.id,
+                        account_move_line.date,
+                        account_move_line.date_maturity,
+                        UNNEST(
+                            REGEXP_SPLIT_TO_ARRAY(
+                                SUBSTRING(
+                                    REGEXP_REPLACE({table_alias}.{field}, '[^0-9\s]', '', 'g'),
+                                    '\S(?:.*\S)*'
+                                ),
+                                '\s+'
+                            )
+                        ) AS token
+                    FROM {tables}
+                    WHERE {where_clause} AND {table_alias}.{field} IS NOT NULL
+                ''')
+
+            self._cr.execute(
+                '''
+                    SELECT
+                        sub.id,
+                        COUNT(*) AS nb_match
+                    FROM (''' + ' UNION ALL '.join(sub_queries) + ''') AS sub
+                    WHERE sub.token IN %s
+                    GROUP BY sub.date_maturity, sub.date, sub.id
+                    HAVING COUNT(*) > 0
+                    ORDER BY nb_match DESC, ''' + order_by + '''
+                ''',
+                (where_params * 3) + [tuple(tokens)],
             )
-        )
+            candidate_ids = [r[0] for r in self._cr.fetchall()]
+            if candidate_ids:
+                return {
+                    'allow_auto_reconcile': True,
+                    'amls': self.env['account.move.line'].browse(candidate_ids),
+                }
+
+        # Search without any matching based on textual information.
+        if partner:
+
+            if self.matching_order == 'new_first':
+                order = 'date_maturity DESC, date DESC, id DESC'
+            else:
+                order = 'date_maturity ASC, date ASC, id ASC'
+
+            amls = self.env['account.move.line'].search(aml_domain, order=order)
+            if amls:
+                return {
+                    'allow_auto_reconcile': False,
+                    'amls': amls,
+                }
+
+    def _get_invoice_matching_rules_map(self):
+        """ Get a mapping <priority_order, rule> that could be overridden in others modules.
+
+        :return: a mapping <priority_order, rule> where:
+            * priority_order:   Defines in which order the rules will be evaluated, the lowest comes first.
+                                This is extremely important since the algorithm stops when a rule returns some candidates.
+            * rule:             Method taking <st_line, partner> as parameters and returning the candidates journal items found.
+        """
+        rules_map = defaultdict(list)
+        rules_map[10].append(self._get_invoice_matching_amls_candidates)
+        return rules_map
 
     def _get_partner_from_mapping(self, st_line):
         """Find partner with mapping defined on model.
@@ -778,224 +802,80 @@ class AccountReconcileModel(models.Model):
                 return partner_mapping.partner_id
         return self.env['res.partner']
 
-    def _get_writeoff_suggestion_query(self, st_lines_with_partner, excluded_ids=None):
-        ''' Returns the query applying the current writeoff_suggestion reconciliation
-        model to the provided statement lines.
-
-        :param st_lines_with_partner: A list of tuples (statement_line, partner),
-                                      associating each statement line to treate with
-                                      the corresponding partner, given by the partner map
-        :param excluded_ids:    Account.move.lines to exclude.
-        :return:                (query, params)
-        '''
-        self.ensure_one()
-
-        if self.rule_type != 'writeoff_suggestion':
-            raise UserError(_("Programmation Error: Can't call _get_writeoff_suggestion_query() for different rules than 'writeoff_suggestion'"))
-
-        query = '''
-            SELECT
-                st_line.id                          AS id
-            FROM account_bank_statement_line st_line
-            WHERE st_line.id IN %(st_line_ids)s
-        '''
-        params = {
-            'st_line_ids': tuple(st_line.id for (st_line, partner) in st_lines_with_partner),
-        }
-
-        return query, params
-
-    def _get_rule_result(self, st_line, candidates, aml_ids_to_exclude, reconciled_amls_ids, partner_map):
-        """ Get the result of a rule from the list of available candidates, depending on the
-        other reconciliations performed by previous rules.
-        """
-        self.ensure_one()
+    def _get_invoice_matching_amls_result(self, st_line, partner, candidate_vals):
+        st_line_currency = st_line.foreign_currency_id or st_line.currency_id
 
-        if self.rule_type == 'invoice_matching':
-            return self._get_invoice_matching_rule_result(st_line, candidates, aml_ids_to_exclude, reconciled_amls_ids, partner_map)
-        elif self.rule_type == 'writeoff_suggestion':
-            return self._get_writeoff_suggestion_rule_result(st_line, partner_map), set(), set()
-        else:
-            return None, set(), set()
+        amls = candidate_vals['amls']
+        if amls.currency_id == st_line_currency:
+            st_line_amount = st_line._prepare_move_line_default_vals()[1]['amount_currency']
+            sign = 1 if st_line_amount > 0.0 else -1
 
-    def _get_invoice_matching_rule_result(self, st_line, candidates, aml_ids_to_exclude, reconciled_amls_ids, partner):
-        new_reconciled_aml_ids = set()
-        new_treated_aml_ids = set()
-        candidates, priorities = self._filter_candidates(candidates, aml_ids_to_exclude, reconciled_amls_ids)
+            kepts_amls = self.env['account.move.line']
+            sum_aml_residual = 0.0
+            for aml in amls:
 
-        st_line_currency = st_line.foreign_currency_id or st_line.currency_id
-        candidate_currencies = set(candidate['aml_currency_id'] for candidate in candidates)
-        kept_candidates = candidates
-        if candidate_currencies == {st_line_currency.id}:
-            kept_candidates = []
-            sum_kept_candidates = 0
-            for candidate in candidates:
-                candidate_residual = candidate['aml_amount_residual_currency']
-
-                if st_line_currency.compare_amounts(candidate_residual, -st_line.amount_residual) == 0:
+                if st_line_currency.compare_amounts(st_line_amount, -aml.amount_residual_currency) == 0:
                     # Special case: the amounts are the same, submit the line directly.
-                    kept_candidates = [candidate]
+                    kepts_amls = aml
                     break
 
-                elif st_line_currency.compare_amounts(abs(sum_kept_candidates), abs(st_line.amount_residual)) < 0:
-                    # Candidates' and statement line's balances have the same sign, thanks to _get_invoice_matching_query.
-                    # We hence can compare their absolute value without any issue.
+                elif st_line_currency.compare_amounts(sign * (st_line_amount + sum_aml_residual), 0.0) > 0:
                     # Here, we still have room for other candidates ; so we add the current one to the list we keep.
                     # Then, we continue iterating, even if there is no room anymore, just in case one of the following candidates
                     # is an exact match, which would then be preferred on the current candidates.
-                    kept_candidates.append(candidate)
-                    sum_kept_candidates += candidate_residual
-
-        # It is possible kept_candidates now contain less different priorities; update them
-        kept_candidates_by_priority = self._sort_reconciliation_candidates_by_priority(kept_candidates, aml_ids_to_exclude, reconciled_amls_ids)
-        priorities = set(kept_candidates_by_priority.keys())
+                    kepts_amls |= aml
+                    sum_aml_residual += aml.amount_residual_currency
+        else:
+            kepts_amls = amls
 
         # We check the amount criteria of the reconciliation model, and select the
         # kept_candidates if they pass the verification.
-        matched_candidates_values = self._process_matched_candidates_data(st_line, kept_candidates)
-        status = self._check_rule_propositions(matched_candidates_values)
+        status = self._check_rule_propositions(st_line, kepts_amls)
         if 'rejected' in status:
-            rslt = None
-        else:
-            rslt = {
-                'model': self,
-                'aml_ids': [candidate['aml_id'] for candidate in kept_candidates],
-            }
-            new_treated_aml_ids = set(rslt['aml_ids'])
-
-            # Create write-off lines (in company's currency).
-            if 'allow_write_off' in status:
-                residual_balance_after_rec = matched_candidates_values['residual_balance_curr'] + matched_candidates_values['candidates_balance_curr']
-                writeoff_vals_list = self._get_write_off_move_lines_dict(
-                    st_line,
-                    matched_candidates_values['balance_sign'] * residual_balance_after_rec,
-                    partner.id,
-                )
-                if writeoff_vals_list:
-                    rslt['status'] = 'write_off'
-                    rslt['write_off_vals'] = writeoff_vals_list
-            else:
-                writeoff_vals_list = []
-
-            # Reconcile.
-            if 'allow_auto_reconcile' in status:
-
-                # Process auto-reconciliation. We only do that for the first two priorities, if they are not matched elsewhere.
-                aml_ids = [candidate['aml_id'] for candidate in kept_candidates]
-                lines_vals_list = [{'id': aml_id} for aml_id in aml_ids]
-
-                if lines_vals_list and priorities & {1, 3} and self.auto_reconcile:
-
-                    # Ensure this will not raise an error if case of missing account to create an open balance.
-                    dummy, open_balance_vals = st_line._prepare_reconciliation(lines_vals_list + writeoff_vals_list)
+            return None
 
-                    if not open_balance_vals or open_balance_vals.get('account_id'):
+        rslt = {'amls': kepts_amls}
 
-                        if not st_line.partner_id and partner:
-                            st_line.partner_id = partner
+        if 'allow_write_off' in status and self.line_ids:
+            rslt['status'] = 'write_off'
 
-                        st_line.reconcile(lines_vals_list + writeoff_vals_list, allow_partial=True)
+        if 'allow_auto_reconcile' in status and candidate_vals['allow_auto_reconcile'] and self.auto_reconcile:
+            rslt['auto_reconcile'] = True
 
-                        rslt['status'] = 'reconciled'
-                        rslt['reconciled_lines'] = st_line.line_ids
-                        new_reconciled_aml_ids = new_treated_aml_ids
-
-        return rslt, new_reconciled_aml_ids, new_treated_aml_ids
-
-    def _process_matched_candidates_data(self, statement_line, candidates=None):
-        """ Simulate the reconciliation of the statement line with the candidates and
-        compute some useful data to perform all the matching rules logic.
-
-        :param statement_line:  An account.bank.statement.line record.
-        :param candidates:      Fetched account.move.lines from query (dict).
-        :return:                A python dict containing:
-            * currency:                 The currency of the transaction.
-            * statement_line:           The statement line matching the candidates.
-            * candidates:               Fetched account.move.lines from query (dict).
-            * reconciliation_overview:  The computed reconciliation from '_prepare_reconciliation'.
-            * open_balance_vals:        The open balance returned by '_prepare_reconciliation'.
-            * balance_sign:             The sign applied to the balance to make amounts always positive.
-            * residual_balance:         The residual balance of the statement line before reconciling anything,
-                                        always positive and expressed in company's currency.
-            * candidates_balance:       The balance of candidates lines expressed in company's currency.
-            * residual_balance_curr:    The residual balance of the statement line before reconciling anything,
-                                        always positive and expressed in transaction's currency.
-            * candidates_balance_curr:  The balance of candidates lines expressed in transaction's currency.
-        """
-        candidates = candidates or []
-
-        reconciliation_overview, open_balance_vals = statement_line._prepare_reconciliation([{
-            'currency_id': aml['aml_currency_id'],
-            'amount_residual': aml['aml_amount_residual'],
-            'amount_residual_currency': aml['aml_amount_residual_currency'],
-        } for aml in candidates])
-
-        # Compute 'residual_balance', the remaining amount to reconcile of the statement line expressed in the
-        # transaction currency.
-        liquidity_lines, suspense_lines, dummy = statement_line._seek_for_lines()
-        if statement_line.to_check:
-            stl_residual_balance = -liquidity_lines.balance
-            stl_residual_balance_curr = -liquidity_lines.amount_currency
-        elif suspense_lines.account_id.reconcile:
-            stl_residual_balance = sum(suspense_lines.mapped('amount_residual'))
-            stl_residual_balance_curr = sum(suspense_lines.mapped('amount_residual_currency'))
-        else:
-            stl_residual_balance = sum(suspense_lines.mapped('balance'))
-            stl_residual_balance_curr = sum(suspense_lines.mapped('amount_currency'))
-
-        # Compute 'reconciled_balance', the total reconciled amount to be reconciled by the candidates.
-        candidates_balance = 0.0
-        candidates_balance_curr = 0.0
-        for reconciliation_vals in reconciliation_overview:
-            line_vals = reconciliation_vals['line_vals']
-            candidates_balance -= line_vals['debit'] - line_vals['credit']
-            if line_vals['currency_id']:
-                candidates_balance_curr -= line_vals['amount_currency']
-            else:
-                candidates_balance_curr -= line_vals['debit'] - line_vals['credit']
-
-        # Sign amount to ease computation. Multiplying any amount from the statement line makes it positive.
-        balance_sign = 1 if stl_residual_balance > 0.0 else -1
-
-        return {
-            'currency': statement_line.foreign_currency_id or statement_line.currency_id,
-            'statement_line': statement_line,
-            'candidates': candidates,
-            'reconciliation_overview': reconciliation_overview,
-            'open_balance_vals': open_balance_vals,
-            'balance_sign': balance_sign,
-            'residual_balance': balance_sign * stl_residual_balance,
-            'candidates_balance': balance_sign * candidates_balance,
-            'residual_balance_curr': balance_sign * stl_residual_balance_curr,
-            'candidates_balance_curr': balance_sign * candidates_balance_curr,
-        }
+        return rslt
 
-    def _check_rule_propositions(self, matched_candidates_values):
+    def _check_rule_propositions(self, st_line, amls):
         """ Check restrictions that can't be handled for each move.line separately.
         Note: Only used by models having a type equals to 'invoice_matching'.
 
-        :param matched_candidates_values: The values computed by '_process_matched_candidates_data'.
+        :param st_line:     The statement line.
+        :param amls:        The candidates account.move.line.
         :return: A string representing what to do with the candidates:
             * rejected:             Reject candidates.
             * allow_write_off:      Allow to generate the write-off from the reconcile model lines if specified.
             * allow_auto_reconcile: Allow to automatically reconcile entries if 'auto_validate' is enabled.
         """
-        candidates = matched_candidates_values['candidates']
-        currency = matched_candidates_values['currency']
-
         if not self.allow_payment_tolerance:
             return {'allow_write_off', 'allow_auto_reconcile'}
-        if not candidates:
+        if not amls:
             return {'rejected'}
 
+        currency = st_line.foreign_currency_id or st_line.currency_id
+        st_line_amount_curr = st_line._prepare_move_line_default_vals()[1]['amount_currency']
+        amls_amount_curr = sum(
+            st_line._prepare_counterpart_amounts_using_st_line_rate(aml.currency_id, aml.amount_residual, aml.amount_residual_currency)['amount_currency']
+            for aml in amls
+        )
+        sign = 1 if st_line_amount_curr > 0.0 else -1
+        amount_curr_after_rec = sign * (amls_amount_curr + st_line_amount_curr)
+
         # The statement line will be fully reconciled.
-        residual_balance_after_rec = matched_candidates_values['residual_balance_curr'] + matched_candidates_values['candidates_balance_curr']
-        if currency.is_zero(residual_balance_after_rec):
+        if currency.is_zero(amount_curr_after_rec):
             return {'allow_auto_reconcile'}
 
         # The payment amount is higher than the sum of invoices.
         # In that case, don't check the tolerance and don't try to generate any write-off.
-        if residual_balance_after_rec > 0.0:
+        if amount_curr_after_rec > 0.0:
             return {'allow_auto_reconcile'}
 
         # No tolerance, reject the candidates.
@@ -1004,104 +884,12 @@ class AccountReconcileModel(models.Model):
 
         # If the tolerance is expressed as a fixed amount, check the residual payment amount doesn't exceed the
         # tolerance.
-        if self.payment_tolerance_type == 'fixed_amount' and -residual_balance_after_rec <= self.payment_tolerance_param:
+        if self.payment_tolerance_type == 'fixed_amount' and -amount_curr_after_rec <= self.payment_tolerance_param:
             return {'allow_write_off', 'allow_auto_reconcile'}
 
         # The tolerance is expressed as a percentage between 0 and 100.0.
-        reconciled_percentage_left = (residual_balance_after_rec / matched_candidates_values['candidates_balance_curr']) * 100.0
+        reconciled_percentage_left = (abs(amount_curr_after_rec / amls_amount_curr)) * 100.0
         if self.payment_tolerance_type == 'percentage' and reconciled_percentage_left <= self.payment_tolerance_param:
             return {'allow_write_off', 'allow_auto_reconcile'}
 
         return {'rejected'}
-
-    def _filter_candidates(self, candidates, aml_ids_to_exclude, reconciled_amls_ids):
-        """ Sorts reconciliation candidates by priority and filters them so that only
-        the most prioritary are kept.
-        """
-        candidates_by_priority = self._sort_reconciliation_candidates_by_priority(candidates, aml_ids_to_exclude, reconciled_amls_ids)
-
-        # This can happen if the candidates were already reconciled at this point
-        if not candidates_by_priority:
-            return [], set()
-
-        max_priority = min(candidates_by_priority.keys())
-
-        filtered_candidates = candidates_by_priority[max_priority]
-        filtered_priorities = {max_priority,}
-
-        if max_priority in (1, 3, 5):
-            # We also keep the already proposed values of the same priority level
-            proposed_priority = max_priority + 1
-            filtered_candidates += candidates_by_priority[proposed_priority]
-            if candidates_by_priority[proposed_priority]:
-                filtered_priorities.add(proposed_priority)
-
-        return filtered_candidates, filtered_priorities
-
-    def _sort_reconciliation_candidates_by_priority(self, candidates, already_proposed_aml_ids, already_reconciled_aml_ids):
-        """ Sorts the provided candidates and returns a mapping of candidates by
-        priority (1 being the highest).
-
-        The priorities are defined as follows:
-
-        1: payment_reference_flag is true,  so the move's payment_reference
-           field matches the statement line's.
-
-        2: Same as 1, but the candidates have already been proposed for a previous statement line
-
-        3: communication_flag is true, so either the move's ref, move's name or
-           aml's name match the statement line's payment reference.
-
-        4: Same as 3, but the candidates have already been proposed for a previous statement line
-
-        5: candidates proposed by the query, but no match with the statement
-           line's payment ref could be found.
-
-        6: Same as 5, but the candidates have already been proposed for a previous statement line
-        """
-        candidates_by_priority = defaultdict(lambda: [])
-
-        for candidate in filter(lambda x: x['aml_id'] not in already_reconciled_aml_ids, candidates):
-
-            if candidate['payment_reference_flag']:
-                priority = 1
-            elif candidate['communication_flag']:
-                priority = 3
-            else:
-                priority = 5
-
-            if candidate['aml_id'] in already_proposed_aml_ids:
-                # So, priorities 2, 4 and 6 are created here
-                priority += 1
-
-            candidates_by_priority[priority].append(candidate)
-
-        return candidates_by_priority
-
-    def _get_writeoff_suggestion_rule_result(self, st_line, partner):
-        # Create write-off lines.
-        matched_candidates_values = self._process_matched_candidates_data(st_line)
-        residual_balance_after_rec = matched_candidates_values['residual_balance_curr'] + matched_candidates_values['candidates_balance_curr']
-        writeoff_vals_list = self._get_write_off_move_lines_dict(
-            st_line,
-            matched_candidates_values['balance_sign'] * residual_balance_after_rec,
-            partner.id,
-        )
-
-        rslt = {
-            'model': self,
-            'status': 'write_off',
-            'aml_ids': [],
-            'write_off_vals': writeoff_vals_list,
-        }
-
-        # Process auto-reconciliation.
-        if writeoff_vals_list and self.auto_reconcile:
-            if not st_line.partner_id and partner:
-                st_line.partner_id = partner
-
-            st_line.reconcile(writeoff_vals_list)
-            rslt['status'] = 'reconciled'
-            rslt['reconciled_lines'] = st_line.line_ids
-
-        return rslt

--- a/addons/account/models/company.py
+++ b/addons/account/models/company.py
@@ -254,6 +254,32 @@ class ResCompany(models.Model):
             if account.code.startswith(old_code):
                 account.write({'code': self.get_new_account_code(account.code, old_code, new_code)})
 
+    def _get_fiscalyear_lock_statement_lines_redirect_action(self, unreconciled_statement_lines):
+        """ Get the action redirecting to the statement lines that are not already reconciled when setting a fiscal
+        year lock date.
+
+        :param unreconciled_statement_lines: The statement lines.
+        :return: A dictionary representing a window action.
+        """
+        statements = unreconciled_statement_lines.statement_id
+        action = {
+            'name': _("Unreconciled Statements"),
+            'type': 'ir.actions.act_window',
+            'res_model': 'account.bank.statement',
+            'context': {'create': False},
+        }
+        if len(statements) == 1:
+            action.update({
+                'view_mode': 'form',
+                'res_id': statements.id,
+            })
+        else:
+            action.update({
+                'view_mode': 'list,form',
+                'domain': [('id', 'in', statements.ids)],
+            })
+        return action
+
     def _validate_fiscalyear_lock(self, values):
         if values.get('fiscalyear_lock_date'):
 
@@ -283,11 +309,7 @@ class ResCompany(models.Model):
             if unreconciled_statement_lines:
                 error_msg = _("There are still unreconciled bank statement lines in the period you want to lock."
                             "You should either reconcile or delete them.")
-                action_error = {
-                    'type': 'ir.actions.client',
-                    'tag': 'bank_statement_reconciliation_view',
-                    'context': {'statement_line_ids': unreconciled_statement_lines.ids, 'company_ids': self.ids},
-                }
+                action_error = self._get_fiscalyear_lock_statement_lines_redirect_action(unreconciled_statement_lines)
                 raise RedirectWarning(error_msg, action_error, _('Show Unreconciled Bank Statement Line'))
 
     def _get_user_fiscal_lock_date(self):
