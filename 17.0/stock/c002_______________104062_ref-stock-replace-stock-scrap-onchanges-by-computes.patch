PR: https://github.com/odoo/odoo/pull/104062

From: c21cf21de48a7a81ee692d246e52d850fedc9f6c
From: JF Aubert
Date: 2022-12-02 12:41:48

Structural Changes: 2
Total Changes: 84

[REF] stock: replace stock.scrap onchanges by computes

closes odoo/odoo#104062

Task: 2985735
Signed-off-by: Tiffany Chang <tic@odoo.com>

================================= pseudo patch: =================================

--- a/addons/stock/models/stock_scrap.py
+++ b/addons/stock/models/stock_scrap.py
@@ -12,17 +12,6 @@ class StockScrap(models.Model):
     _order = 'id desc'
     _description = 'Scrap'
 
-    def _get_default_scrap_location_id(self):
-        company_id = self.env.context.get('default_company_id') or self.env.company.id
-        return self.env['stock.location'].search([('scrap_location', '=', True), ('company_id', 'in', [company_id, False])], limit=1).id
-
-    def _get_default_location_id(self):
-        company_id = self.env.context.get('default_company_id') or self.env.company.id
-        warehouse = self.env['stock.warehouse'].search([('company_id', '=', company_id)], limit=1)
-        if warehouse:
-            return warehouse.lot_stock_id.id
-        return None
-
     name = fields.Char(
         'Reference',  default=lambda self: _('New'),
         copy=False, readonly=True, required=True,
@@ -48,11 +37,13 @@ class StockScrap(models.Model):
     move_id = fields.Many2one('stock.move', 'Scrap Move', readonly=True, check_company=True, copy=False)
     picking_id = fields.Many2one('stock.picking', 'Picking', states={'done': [('readonly', True)]}, check_company=True)
     location_id = fields.Many2one(
-        'stock.location', 'Source Location', domain="[('usage', '=', 'internal'), ('company_id', 'in', [company_id, False])]",
-        required=True, states={'done': [('readonly', True)]}, default=_get_default_location_id, check_company=True)
+        'stock.location', 'Source Location',
+        compute='_compute_location_id', store=True, required=True, precompute=True, states={'done': [('readonly', True)]},
+        domain="[('usage', '=', 'internal'), ('company_id', 'in', [company_id, False])]", check_company=True)
     scrap_location_id = fields.Many2one(
-        'stock.location', 'Scrap Location', default=_get_default_scrap_location_id,
-        domain="[('scrap_location', '=', True), ('company_id', 'in', [company_id, False])]", required=True, states={'done': [('readonly', True)]}, check_company=True)
+        'stock.location', 'Scrap Location',
+        compute='_compute_scrap_location_id', store=True, required=True, precompute=True, states={'done': [('readonly', True)]},
+        domain="[('scrap_location', '=', True), ('company_id', 'in', [company_id, False])]", check_company=True)
     scrap_qty = fields.Float(
         'Quantity', required=True, states={'done': [('readonly', True)]}, digits='Product Unit of Measure',
         compute='_compute_scrap_qty', precompute=True, readonly=False, store=True)
@@ -67,49 +58,38 @@ class StockScrap(models.Model):
         for scrap in self:
             scrap.product_uom_id = scrap.product_id.uom_id
 
-    @api.depends('move_id', 'move_id.move_line_ids.qty_done')
+    @api.depends('company_id', 'picking_id')
+    def _compute_location_id(self):
+        groups = self.env['stock.warehouse']._read_group(
+            [('company_id', 'in', self.company_id.ids)], ['min_id:min(id)'], ['company_id'])
+        locations_per_company = {
+            group['company_id'][0]: self.env['stock.warehouse'].browse(group['min_id']).lot_stock_id
+            for group in groups
+        }
+        for scrap in self:
+            if scrap.picking_id:
+                scrap.location_id = scrap.picking_id.location_dest_id if scrap.picking_id.state == 'done' else scrap.picking_id.location_id
+            else:
+                scrap.location_id = locations_per_company[scrap.company_id.id]
+
+    @api.depends('company_id')
+    def _compute_scrap_location_id(self):
+        groups = self.env['stock.location']._read_group(
+            [('company_id', 'in', self.company_id.ids), ('scrap_location', '=', True)], ['min_id:min(id)'], ['company_id'])
+        locations_per_company = {
+            group['company_id'][0]: self.env['stock.location'].browse(group['min_id'])
+            for group in groups
+        }
+        for scrap in self:
+            scrap.scrap_location_id = locations_per_company[scrap.company_id.id]
+
+    @api.depends('move_id', 'move_id.move_line_ids.qty_done', 'product_id')
     def _compute_scrap_qty(self):
         self.scrap_qty = 1
         for scrap in self:
             if scrap.move_id:
                 scrap.scrap_qty = scrap.move_id.quantity_done
 
-    @api.onchange('picking_id')
-    def _onchange_picking_id(self):
-        if self.picking_id:
-            self.location_id = (self.picking_id.state == 'done') and self.picking_id.location_dest_id.id or self.picking_id.location_id.id
-
-    @api.onchange('product_id')
-    def _onchange_product_id(self):
-        if self.product_id:
-            if self.tracking == 'serial':
-                self.scrap_qty = 1
-            # Check if we can get a more precise location instead of
-            # the default location (a location corresponding to where the
-            # reserved product is stored)
-            if self.picking_id:
-                for move_line in self.picking_id.move_line_ids:
-                    if move_line.product_id == self.product_id:
-                        self.location_id = move_line.location_id if move_line.state != 'done' else move_line.location_dest_id
-                        break
-
-    @api.onchange('company_id')
-    def _onchange_company_id(self):
-        if self.company_id:
-            warehouse = self.env['stock.warehouse'].search([('company_id', '=', self.company_id.id)], limit=1)
-            # Change the locations only if their company doesn't match the company set, otherwise
-            # user defaults are overridden.
-            if self.location_id.company_id != self.company_id:
-                self.location_id = warehouse.lot_stock_id
-            if self.scrap_location_id.company_id != self.company_id:
-                self.scrap_location_id = self.env['stock.location'].search([
-                    ('scrap_location', '=', True),
-                    ('company_id', 'in', [self.company_id.id, False]),
-                ], limit=1)
-        else:
-            self.location_id = False
-            self.scrap_location_id = False
-
     @api.onchange('lot_id')
     def _onchange_serial_number(self):
         if self.product_id.tracking == 'serial' and self.lot_id:
