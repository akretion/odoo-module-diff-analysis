PR: https://github.com/odoo/odoo/pull/

From: 1bf2bfd2a1b72d8f3954ba79a0f116ee579d4e14
From: Yannick Tivisse
Date: 2019-12-19 16:21:17

Structural Changes: 6
Total Changes: 96

[IMP] hr_timesheet: Small cleaning and linting

================================= pseudo patch: =================================

--- a/addons/hr_timesheet/models/hr_timesheet.py
+++ b/addons/hr_timesheet/models/hr_timesheet.py
@@ -48,12 +48,9 @@ class AccountAnalyticLine(models.Model):
     employee_id = fields.Many2one('hr.employee', "Employee", check_company=True, domain=_domain_employee_id)
     department_id = fields.Many2one('hr.department', "Department", compute='_compute_department_id', store=True, compute_sudo=True)
     encoding_uom_id = fields.Many2one('uom.uom', compute='_compute_encoding_uom_id')
-
-    # Timer Fields
     display_timer = fields.Boolean(
         compute='_compute_display_timer',
-        help="used to display the timer if the encoding unit is 'Hours'"
-    )
+        help="Technical field used to display the timer if the encoding unit is 'Hours'.")
 
     def _compute_encoding_uom_id(self):
         for analytic_line in self:
@@ -82,10 +79,6 @@ class AccountAnalyticLine(models.Model):
         for line in self:
             line.department_id = line.employee_id.department_id
 
-    # ----------------------------------------------------
-    # ORM overrides
-    # ----------------------------------------------------
-
     @api.model_create_multi
     def create(self, vals_list):
         default_user_id = self._default_user()
@@ -134,10 +127,6 @@ class AccountAnalyticLine(models.Model):
             node.set('string', _('Duration (%s)') % (re.sub(r'[\(\)]', '', encoding_uom.name or '')))
         return etree.tostring(doc, encoding='unicode')
 
-    # ----------------------------------------------------
-    # Business Methods
-    # ----------------------------------------------------
-
     def _timesheet_get_portal_domain(self):
         return ['|', '&',
                 ('task_id.project_id.privacy_visibility', '=', 'portal'),
@@ -207,51 +196,37 @@ class AccountAnalyticLine(models.Model):
                 })
         return result
 
-    # ----------------------------------------------------
-    # Timer Methods
-    # ----------------------------------------------------
     def _compute_display_timer(self):
-        """ Check if the encoding unit is 'Hours',
-
-            if yes then the timer button is displayed
-        """
+        uom_hour = self.env.ref('uom.product_uom_hour')
         for analytic_line in self:
-            analytic_line.display_timer = analytic_line.encoding_uom_id.id == self.env.ref('uom.product_uom_hour').id
+            analytic_line.display_timer = analytic_line.encoding_uom_id == uom_hour
 
     def action_timer_start(self):
-        """ Action start the timer of the current timesheet.
-
-            Start timer and search if another timer hasn't been launched.
+        """ Start timer and search if another timer hasn't been launched.
             If yes, then stop the timer before launch this timer.
         """
-        self.ensure_one()
         if not self.timer_start and self.display_timer:
             self._stop_running_timers()
             super().action_timer_start()
 
     def _stop_running_timers(self):
         """ Search if a timesheet has a timer activated and stop the timer.
-
             Check if a timer is activated for another timesheet
             if yes, then update unit_amount field and stop timer,
             otherwise, do nothing.
         """
         analytic_line = self.search([('timer_start', '!=', False), ('user_id', '=', self.env.uid)])
-
         if analytic_line:
             analytic_line.action_timer_stop()
 
     def action_timer_stop(self):
         """ Action stop the timer of the current timesheet.
-
             When the timer must be stopped, we must calculate the new
             unit_amount based on the timer and the previous value of
             unit_amount for the current timesheet.
         """
-        self.ensure_one()
         if self.timer_start and self.display_timer:
             minutes_spent = self._get_minutes_spent()
-
             if self.unit_amount == 0 and minutes_spent < 1:
                 # Check if unit_amount equals 0 and minutes_spent is less than 1 minute,
                 # if yes, then remove the timesheet
@@ -261,7 +236,5 @@ class AccountAnalyticLine(models.Model):
                     amount = self.unit_amount
                 else:
                     amount = self.unit_amount + minutes_spent * 60 / 3600
-
                 self.write({'unit_amount': amount})
-
                 super().action_timer_stop()

--- a/addons/hr_timesheet/models/project.py
+++ b/addons/hr_timesheet/models/project.py
@@ -20,15 +20,12 @@ class Project(models.Model):
     allow_timesheet_timer = fields.Boolean('Timesheet Timer', default=False, help="Use a timer to record timesheets on tasks")
 
     _sql_constraints = [
-        ('timer_only_when_timesheet', "CHECK((allow_timesheets = 'f' AND allow_timesheet_timer = 'f') OR (allow_timesheets = 't'))", 'The timesheet timer can only be activated on project allowing timesheet.'),
+        ('timer_only_when_timesheet', "CHECK((allow_timesheets = 'f' AND allow_timesheet_timer = 'f') OR (allow_timesheets = 't'))", 'The timesheet timer can only be activated on project allowing timesheets.'),
     ]
 
     @api.onchange('partner_id')
     def _onchange_partner_id(self):
-        domain = []
-        if self.partner_id:
-            domain = [('partner_id', '=', self.partner_id.id)]
-        return {'domain': {'analytic_account_id': domain}}
+        return {'domain': {'analytic_account_id': [('partner_id', '=', self.partner_id.id)] if self.partner_id else []}}
 
     @api.onchange('analytic_account_id')
     def _onchange_analytic_account(self):
@@ -74,16 +71,12 @@ class Project(models.Model):
                     project._create_analytic_account()
         result = super(Project, self).write(values)
         if 'allow_timesheet_timer' in values and not values.get('allow_timesheet_timer'):
-            self.env['project.task'].with_context(active_test=False).search([('project_id', 'in', self.ids)]).write({
+            self.with_context(active_test=False).mapped('task_ids').write({
                 'timer_start': False,
                 'timer_pause': False,
             })
         return result
 
-    # ---------------------------------------------------
-    #  Business Methods
-    # ---------------------------------------------------
-
     @api.model
     def _init_data_analytic_account(self):
         self.search([('analytic_account_id', '=', False), ('allow_timesheets', '=', True)])._create_analytic_account()
@@ -102,8 +95,9 @@ class Task(models.Model):
     subtask_effective_hours = fields.Float("Sub-tasks Hours Spent", compute='_compute_subtask_effective_hours', store=True, help="Sum of actually spent hours on the subtask(s)")
     timesheet_ids = fields.One2many('account.analytic.line', 'task_id', 'Timesheets')
 
-    timer_start = fields.Datetime("Timesheet Timer Start", default=None)
+    timer_start = fields.Datetime("Timesheet Timer Start")
     timer_pause = fields.Datetime("Timesheet Timer Last Pause")
+    # YTI FIXME: Those field seems quite useless
     timesheet_timer_first_start = fields.Datetime("Timesheet Timer First Use", readonly=True)
     timesheet_timer_last_stop = fields.Datetime("Timesheet Timer Last Use", readonly=True)
     display_timesheet_timer = fields.Boolean("Display Timesheet Time", compute='_compute_display_timesheet_timer')
@@ -145,10 +139,6 @@ class Task(models.Model):
         for task in self:
             task.display_timesheet_timer = task.allow_timesheets and task.project_id.allow_timesheet_timer and task.analytic_account_active
 
-    # ---------------------------------------------------------
-    # ORM
-    # ---------------------------------------------------------
-
     def write(self, values):
         # a timesheet must have an analytic account (and a project)
         if 'project_id' in values and self and not values.get('project_id'):
@@ -173,10 +163,6 @@ class Task(models.Model):
         result['arch'] = self.env['account.analytic.line']._apply_timesheet_label(result['arch'])
         return result
 
-    # ---------------------------------------------------------
-    # Timer Methods
-    # ---------------------------------------------------------
-
     def action_timer_start(self):
         self.ensure_one()
         if not self.timesheet_timer_first_start:
@@ -201,7 +187,7 @@ class Task(models.Model):
 
     def _action_create_timesheet(self, time_spent):
         return {
-            "name": _("Confirm Time Spent"),
+            "name": _("Validate Spent Time"),
             "type": 'ir.actions.act_window',
             "res_model": 'project.task.create.timesheet',
             "views": [[False, "form"]],

--- a/addons/hr_timesheet/models/timer_mixin.py
+++ b/addons/hr_timesheet/models/timer_mixin.py
@@ -7,25 +7,20 @@ from odoo import models, fields, api
 class TimerMixin(models.AbstractModel):
     _name = 'timer.mixin'
     _description = 'Timer Mixin'
+    # YTI Note: This mixin is supposed to be extended to
+    # any models
 
     timer_start = fields.Datetime("Timer Start")
     timer_pause = fields.Datetime("Timer Last Pause")
-
-    # is_timer_running field is used with timer_toggle_button widget
-    # to create a timer button in the view.
-    # If the timer field is set on False,
-    # then it displays a button with fa-icon-play icon.
-    # Otherwise, it displays a button with fa-icon-stop icon
     is_timer_running = fields.Boolean(compute="_compute_timer")
 
     @api.depends('timer_start')
-    def _compute_timer(self) -> None:
+    def _compute_timer(self):
         for record in self:
             record.is_timer_running = bool(record.timer_start)
 
-    def action_timer_start(self) -> None:
+    def action_timer_start(self):
         """ Action start the timer.
-
             Start timer and search if another timer hasn't been launched.
             If yes, then stop the timer before launch this timer.
         """
@@ -45,32 +40,26 @@ class TimerMixin(models.AbstractModel):
         self.write({'timer_start': False, 'timer_pause': False})
         return minutes_spent
 
-    def _get_minutes_spent(self) -> float:
-        """ Compute the minutes spent with the timer
-
-            :return minutes spent
-        """
+    def _get_minutes_spent(self):
         start_time = self.timer_start
         stop_time = fields.Datetime.now()
-
         # timer was either running or paused
         if self.timer_pause:
             start_time += (stop_time - self.timer_pause)
-
         return (stop_time - start_time).total_seconds() / 60
 
-    def action_timer_pause(self) -> None:
+    def action_timer_pause(self):
         self.write({'timer_pause': fields.Datetime.now()})
 
-    def action_timer_resume(self) -> None:
+    def action_timer_resume(self):
         new_start = self.timer_start + (fields.Datetime.now() - self.timer_pause)
         self.write({'timer_start': new_start, 'timer_pause': False})
 
+    @api.model
     def get_server_time(self):
-        """ Get the time of the server
-
-            The problem with the timer, it's the time can be different between server side and client side.
-            We need to have the time of the server and don't use the local time. Then, we have a timer beginning at 0:00
-            and not 23:59 or something else.
+        """ Returns the server time.
+            The timer widget needs the server time instead of the client time
+            to avoid time desynchronization issues like the timer beginning at 0:00
+            and not 23:59 and so on.
         """
         return fields.Datetime.now()
