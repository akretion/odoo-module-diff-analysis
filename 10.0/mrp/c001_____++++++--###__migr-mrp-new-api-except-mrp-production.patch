PR: https://github.com/odoo/odoo/pull/

From: 30850f99f8dd2bda5d672712f6195abf527464a1
From: Dhaval Panchal
Date: 2016-07-04 14:22:35

Structural Changes: 131
Total Changes: 1770

[MIGR] mrp: new API except mrp_production

MRP module is migrated to the new API. It excludes mrp models that will change
quit a lot during the new MRP conversion. Actually most of the code is not
migrated, but at least side models and their methods are already migrated.
This should lessen the diff when writing the new MRP.

================================= pseudo patch: =================================

--- a/addons/mrp/models/mrp_bom.py
+++ b/addons/mrp/models/mrp_bom.py
@@ -4,132 +4,146 @@
 import time
 
 import openerp.addons.decimal_precision as dp
-from openerp import tools
-from openerp.exceptions import UserError
-from openerp.osv import fields, osv
 from openerp.tools import DEFAULT_SERVER_DATE_FORMAT
-from openerp.tools.translate import _
 
+from odoo import api, fields, models, tools, _
+from odoo.exceptions import UserError
 
-class mrp_bom(osv.osv):
-    """
-    Defines bills of material for a product.
-    """
+
+class BoM(models.Model):
+    """ Defines bills of material for a product. """
     _name = 'mrp.bom'
     _description = 'Bill of Material'
+    _order = "sequence"
+    _rec_name = 'code'
     _inherit = ['mail.thread']
 
-    _columns = {
-        'code': fields.char('Reference', size=16),
-        'active': fields.boolean('Active', help="If the active field is set to False, it will allow you to hide the bills of material without removing it."),
-        'type': fields.selection([('normal','Manufacture this product'),('phantom','Ship this product as a set of components (kit)')], 'BoM Type', required=True,
-                help= "Set: When processing a sales order for this product, the delivery order will contain the raw materials, instead of the finished product."),
-        'position': fields.char('Internal Reference', help="Reference to a position in an external plan."),
-        'product_tmpl_id': fields.many2one('product.template', 'Product', domain="[('type', 'in', ['product', 'consu'])]", required=True),
-        'product_id': fields.many2one('product.product', 'Product Variant',
-            domain="['&', ('product_tmpl_id','=',product_tmpl_id), ('type', 'in', ['product', 'consu'])]",
-            help="If a product variant is defined the BOM is available only for this product."),
-        'bom_line_ids': fields.one2many('mrp.bom.line', 'bom_id', 'BoM Lines', copy=True),
-        'product_qty': fields.float('Product Quantity', required=True, digits_compute=dp.get_precision('Product Unit of Measure')),
-        'product_uom': fields.many2one('product.uom', 'Product Unit of Measure', required=True, help="Unit of Measure (Unit of Measure) is the unit of measurement for the inventory control"),
-        'date_start': fields.date('Valid From', help="Validity of this BoM. Keep empty if it's always valid."),
-        'date_stop': fields.date('Valid Until', help="Validity of this BoM. Keep empty if it's always valid."),
-        'sequence': fields.integer('Sequence', help="Gives the sequence order when displaying a list of bills of material."),
-        'routing_id': fields.many2one('mrp.routing', 'Routing', help="The list of operations (list of work centers) to produce the finished product. "\
-                "The routing is mainly used to compute work center costs during operations and to plan future loads on work centers based on production planning."),
-        'product_rounding': fields.float('Product Rounding', help="Rounding applied on the product quantity."),
-        'product_efficiency': fields.float('Manufacturing Efficiency', required=True, help="A factor of 0.9 means a loss of 10% during the production process."),
-        'property_ids': fields.many2many('mrp.property', string='Properties'),
-        'company_id': fields.many2one('res.company', 'Company', required=True),
-    }
-
-    def _get_uom_id(self, cr, uid, *args):
-        return self.pool["product.uom"].search(cr, uid, [], limit=1, order='id')[0]
-    _defaults = {
-        'active': lambda *a: 1,
-        'product_qty': lambda *a: 1.0,
-        'product_efficiency': lambda *a: 1.0,
-        'product_rounding': lambda *a: 0.0,
-        'type': lambda *a: 'normal',
-        'product_uom': _get_uom_id,
-        'company_id': lambda self, cr, uid, c: self.pool.get('res.company')._company_default_get(cr, uid, 'mrp.bom', context=c),
-    }
-    _order = "sequence"
+    def _get_default_product_uom(self):
+        return self.env['product.uom'].search([], limit=1, order='id').id
+
+    code = fields.Char('Reference')
+    active = fields.Boolean(
+        'Active', default=True,
+        help="If the active field is set to False, it will allow you to hide the bills of material without removing it.")
+    type = fields.Selection([
+        ('normal', 'Manufacture this product'),
+        ('phantom', 'Ship this product as a set of components (kit)')],
+        string='BoM Type', default='normal', required=True,
+        help="Set: When processing a sales order for this product, the delivery order will contain the raw materials, instead of the finished product.")
+    position = fields.Char('Internal Reference', help="Reference to a position in an external plan.")
+    product_tmpl_id = fields.Many2one(
+        'product.template', 'Product',
+        domain="[('type', 'in', ['product', 'consu'])]",
+        required=True)
+    product_id = fields.Many2one(
+        'product.product', 'Product Variant',
+        domain="['&', ('product_tmpl_id', '=', product_tmpl_id), ('type', 'in', ['product', 'consu'])]",
+        help="If a product variant is defined the BOM is available only for this product.")
+    bom_line_ids = fields.One2many('mrp.bom.line', 'bom_id', 'BoM Lines', copy=True)
+    product_qty = fields.Float(
+        'Product Quantity', default=1.0,
+        digits_compute=dp.get_precision('Product Unit of Measure'), required=True)
+    product_uom = fields.Many2one(
+        'product.uom', 'Product Unit of Measure',
+        default=_get_default_product_uom, required=True,
+        help="Unit of Measure (Unit of Measure) is the unit of measurement for the inventory control")
+    date_start = fields.Date('Valid From', help="Validity of this BoM. Keep empty if it's always valid.")
+    date_stop = fields.Date('Valid Until', help="Validity of this BoM. Keep empty if it's always valid.")
+    sequence = fields.Integer('Sequence', help="Gives the sequence order when displaying a list of bills of material.")
+    routing_id = fields.Many2one(
+        'mrp.routing', 'Routing',
+        help="The list of operations (list of work centers) to produce the finished product. "
+             "The routing is mainly used to compute work center costs during operations and to "
+             "plan future loads on work centers based on production planning.")
+    product_rounding = fields.Float(
+        'Product Rounding', default=0.0,
+        help="Rounding applied on the product quantity.")
+    product_efficiency = fields.Float(
+        'Manufacturing Efficiency',
+        default=1.0, required=True,
+        help="A factor of 0.9 means a loss of 10% during the production process.")
+    property_ids = fields.Many2many('mrp.property', string='Properties')
+    company_id = fields.Many2one(
+        'res.company', 'Company',
+        default=lambda self: self.env['res.company']._company_default_get('mrp.bom'),
+        required=True)
+
+    @api.multi
+    def name_get(self):
+        return [(bom.id, '%s%s' % (bom.code and '[%s]' % bom.code or '', bom.product_tmpl_id.name)) for bom in self]
+
+    @api.multi
+    def unlink(self):
+        if self.env['mrp.production'].search([('bom_id', 'in', self.ids), ('state', 'not in', ['done', 'cancel'])], limit=1):
+            raise UserError(_('You can not delete a Bill of Material with running manufacturing orders.\nPlease close or cancel it first.'))
+        return super(BoM, self).unlink()
+
+    @api.onchange('product_uom')
+    def onchange_product_uom(self):
+        res = {}
+        if not self.product_uom or not self.product_tmpl_id:
+            return res
+        if self.product_uom.category_id != self.product_tmpl_id.uom_id.category_id:
+            res['warning'] = {'title': _('Warning'), 'message': _('The Product Unit of Measure you chose has a different category than in the product form.')}
+            self.product_uom = self.product_id.uom_id.id
+        return res
 
+    @api.onchange('product_tmpl_id')
+    def onchange_product_tmpl_id(self):
+        if self.product_tmpl_id:
+            self.product_uom = self.product_tmpl_id.uom_id.id
 
-    def _bom_find(self, cr, uid, product_tmpl_id=None, product_id=None, properties=None, context=None):
-        """ Finds BoM for particular product and product uom.
-        @param product_tmpl_id: Selected product.
-        @param product_uom: Unit of measure of a product.
-        @param properties: List of related properties.
-        @return: False or BoM id.
-        """
-        if not context:
-            context = {}
+    @api.model
+    @api.returns('self', lambda value: value.id)
+    def _bom_find(self, product_tmpl_id=None, product_id=None, properties=None, company_id=False):
+        """ Finds BoM for particular product and product uom. """
         if properties is None:
             properties = []
+
+        domain = ['|', ('date_start', '=', False), ('date_start', '<=', time.strftime(DEFAULT_SERVER_DATE_FORMAT)),
+                  '|', ('date_stop', '=', False), ('date_stop', '>=', time.strftime(DEFAULT_SERVER_DATE_FORMAT))]
         if product_id:
             if not product_tmpl_id:
-                product_tmpl_id = self.pool['product.product'].browse(cr, uid, product_id, context=context).product_tmpl_id.id
-            domain = [
-                '|',
-                    ('product_id', '=', product_id),
-                    '&',
-                        ('product_id', '=', False),
-                        ('product_tmpl_id', '=', product_tmpl_id)
-            ]
+                product_tmpl_id = self.env['product.product'].browse(product_id).product_tmpl_id.id
+            domain += ['|',
+                       ('product_id', '=', product_id),
+                       '&', ('product_id', '=', False), ('product_tmpl_id', '=', product_tmpl_id)]
         elif product_tmpl_id:
-            domain = [('product_id', '=', False), ('product_tmpl_id', '=', product_tmpl_id)]
+            domain += [('product_id', '=', False), ('product_tmpl_id', '=', product_tmpl_id)]
         else:
             # neither product nor template, makes no sense to search
             return False
-        if context.get('company_id'):
-            domain = domain + [('company_id', '=', context['company_id'])]
-        domain = domain + [ '|', ('date_start', '=', False), ('date_start', '<=', time.strftime(DEFAULT_SERVER_DATE_FORMAT)),
-                            '|', ('date_stop', '=', False), ('date_stop', '>=', time.strftime(DEFAULT_SERVER_DATE_FORMAT))]
+        if self._context.get('company_id', company_id):
+            domain += [('company_id', '=', self._context.get('company_id', company_id))]
         # order to prioritize bom with product_id over the one without
-        ids = self.search(cr, uid, domain, order='sequence, product_id', context=context)
+        boms = self.search(domain, order='sequence, product_id')
         # Search a BoM which has all properties specified, or if you can not find one, you could
         # pass a BoM without any properties with the smallest sequence
-        bom_empty_prop = False
-        for bom in self.pool.get('mrp.bom').browse(cr, uid, ids, context=context):
-            if not set(map(int, bom.property_ids or [])) - set(properties or []):
+        bom_empty_prop = self.env['mrp.bom']
+        for bom in boms:
+            if not set(bom.property_ids.ids) - set(properties):
                 if not properties or bom.property_ids:
-                    return bom.id
+                    return bom
                 elif not bom_empty_prop:
-                    bom_empty_prop = bom.id
+                    bom_empty_prop = bom
         return bom_empty_prop
 
-    def _skip_bom_line(self, cr, uid, line, product, context=None):
-        """ Control if a BoM line should be produce, can be inherited for add
-        custom control.
-        @param line: BoM line.
-        @param product: Selected product produced.
-        @return: True or False
-        """
-        if line.date_start and line.date_start > time.strftime(DEFAULT_SERVER_DATE_FORMAT) or \
-            line.date_stop and line.date_stop < time.strftime(DEFAULT_SERVER_DATE_FORMAT):
-                return True
-        # all bom_line_id variant values must be in the product
-        if line.attribute_value_ids:
-            if not product or (set(map(int,line.attribute_value_ids or [])) - set(map(int,product.attribute_value_ids))):
-                return True
-        return False
-
-    def _prepare_wc_line(self, cr, uid, bom, wc_use, level=0, factor=1, context=None):
-        wc = wc_use.workcenter_id
-        d, m = divmod(factor, wc_use.workcenter_id.capacity_per_cycle)
+    @api.multi
+    def _prepare_wc_line(self, routing_workcenter, level=0, factor=1):
+        workcenter = routing_workcenter.workcenter_id
+        d, m = divmod(factor, routing_workcenter.workcenter_id.capacity_per_cycle)
         mult = (d + (m and 1.0 or 0.0))
-        cycle = mult * wc_use.cycle_nbr
+        cycle = mult * routing_workcenter.cycle_nbr
         return {
-            'name': tools.ustr(wc_use.name) + ' - ' + tools.ustr(bom.product_tmpl_id.name_get()[0][1]),
-            'workcenter_id': wc.id,
-            'sequence': level + (wc_use.sequence or 0),
+            'name': tools.ustr(routing_workcenter.name) + ' - ' + tools.ustr(self.product_tmpl_id.name_get()[0][1]),
+            'workcenter_id': workcenter.id,
+            'sequence': level + (routing_workcenter.sequence or 0),
             'cycle': cycle,
-            'hour': float(wc_use.hour_nbr * mult + ((wc.time_start or 0.0) + (wc.time_stop or 0.0) + cycle * (wc.time_cycle or 0.0)) * (wc.time_efficiency or 100)),
+            'hour': float(routing_workcenter.hour_nbr * mult + ((workcenter.time_start or 0.0) + (workcenter.time_stop or 0.0) + cycle * (workcenter.time_cycle or 0.0)) * (workcenter.time_efficiency or 100)),
         }
 
-    def _prepare_consume_line(self, cr, uid, bom_line_id, quantity, context=None):
+    @api.model
+    def _prepare_consume_line(self, bom_line_id, quantity):
         return {
             'name': bom_line_id.product_id.name,
             'product_id': bom_line_id.product_id.id,
@@ -137,7 +151,8 @@ class mrp_bom(osv.osv):
             'product_uom': bom_line_id.product_uom.id
         }
 
-    def _bom_explode(self, cr, uid, bom, product, factor, properties=None, level=0, routing_id=False, previous_products=None, master_bom=None, context=None):
+    @api.model
+    def _bom_explode(self, bom, product, factor, properties=None, level=0, routing_id=False, previous_products=None, master_bom=None):
         """ Finds Products and Work Centers for related BoM for manufacturing order.
         @param bom: BoM of particular product template.
         @param product: Select a particular variant of the BoM. If False use BoM without variants.
@@ -149,11 +164,10 @@ class mrp_bom(osv.osv):
         @return: result: List of dictionaries containing product details.
                  result2: List of dictionaries containing Work Center details.
         """
-        uom_obj = self.pool.get("product.uom")
-        routing_obj = self.pool.get('mrp.routing')
+        UoM = self.env["product.uom"]
+        Routing = self.env['mrp.routing']
         master_bom = master_bom or bom
 
-
         def _factor(factor, product_efficiency, product_rounding):
             factor = factor / (product_efficiency or 1.0)
             if product_rounding:
@@ -169,15 +183,13 @@ class mrp_bom(osv.osv):
         result = []
         result2 = []
 
-        routing = (routing_id and routing_obj.browse(cr, uid, routing_id)) or bom.routing_id or False
+        routing = (routing_id and Routing.browse(routing_id)) or bom.routing_id or False
         if routing:
             for wc_use in routing.workcenter_lines:
-                result2.append(self._prepare_wc_line(
-                    cr, uid, bom, wc_use, level=level, factor=factor,
-                    context=context))
+                result2.append(bom._prepare_wc_line(wc_use, level=level, factor=factor))
 
         for bom_line_id in bom.bom_line_ids:
-            if self._skip_bom_line(cr, uid, bom_line_id, product, context=context):
+            if bom_line_id._skip_bom_line(product):
                 continue
             if set(map(int, bom_line_id.property_ids or [])) - set(properties or []):
                 continue
@@ -186,151 +198,117 @@ class mrp_bom(osv.osv):
                 raise UserError(_('BoM "%s" contains a BoM line with a product recursion: "%s".') % (master_bom.code or "", bom_line_id.product_id.name_get()[0][1]))
 
             quantity = _factor(bom_line_id.product_qty * factor, bom_line_id.product_efficiency, bom_line_id.product_rounding)
-            bom_id = self._bom_find(cr, uid, product_id=bom_line_id.product_id.id, properties=properties, context=context)
+            new_bom = self._bom_find(product_id=bom_line_id.product_id.id, properties=properties)
 
-            #If BoM should not behave like kit, just add the product, otherwise explode further
-            if (not bom_id) or (self.browse(cr, uid, bom_id, context=context).type != "phantom"):
-                result.append(self._prepare_consume_line(
-                    cr, uid, bom_line_id, quantity, context=context))
+            # If BoM should not behave like kit, just add the product, otherwise explode further
+            if not new_bom or new_bom.type != "phantom":
+                result.append(self._prepare_consume_line(bom_line_id, quantity))
             else:
                 all_prod = [bom.product_tmpl_id.id] + (previous_products or [])
-                bom2 = self.browse(cr, uid, bom_id, context=context)
                 # We need to convert to units/UoM of chosen BoM
-                factor2 = uom_obj._compute_qty(cr, uid, bom_line_id.product_uom.id, quantity, bom2.product_uom.id)
-                quantity2 = factor2 / bom2.product_qty
-                res = self._bom_explode(cr, uid, bom2, bom_line_id.product_id, quantity2,
-                    properties=properties, level=level + 10, previous_products=all_prod, master_bom=master_bom, context=context)
+                factor2 = UoM._compute_qty_obj(bom_line_id.product_uom, quantity, new_bom.product_uom)
+                quantity2 = factor2 / new_bom.product_qty
+                res = self._bom_explode(
+                    new_bom, bom_line_id.product_id, quantity2,
+                    properties=properties, level=level + 10, previous_products=all_prod, master_bom=master_bom)
                 result = result + res[0]
                 result2 = result2 + res[1]
         return result, result2
 
-    def copy_data(self, cr, uid, id, default=None, context=None):
-        if default is None:
-            default = {}
-        bom_data = self.read(cr, uid, id, [], context=context)
-        default.update(name=_("%s (copy)") % (bom_data['display_name']))
-        return super(mrp_bom, self).copy_data(cr, uid, id, default, context=context)
-
-    def onchange_uom(self, cr, uid, ids, product_tmpl_id, product_uom, context=None):
-        res = {'value': {}}
-        if not product_uom or not product_tmpl_id:
-            return res
-        product = self.pool.get('product.template').browse(cr, uid, product_tmpl_id, context=context)
-        uom = self.pool.get('product.uom').browse(cr, uid, product_uom, context=context)
-        if uom.category_id.id != product.uom_id.category_id.id:
-            res['warning'] = {'title': _('Warning'), 'message': _('The Product Unit of Measure you chose has a different category than in the product form.')}
-            res['value'].update({'product_uom': product.uom_id.id})
-        return res
-
-    def unlink(self, cr, uid, ids, context=None):
-        if self.pool['mrp.production'].search(cr, uid, [('bom_id', 'in', ids), ('state', 'not in', ['done', 'cancel'])], context=context):
-            raise UserError(_('You can not delete a Bill of Material with running manufacturing orders.\nPlease close or cancel it first.'))
-        return super(mrp_bom, self).unlink(cr, uid, ids, context=context)
-
-    def onchange_product_tmpl_id(self, cr, uid, ids, product_tmpl_id, product_qty=0, context=None):
-        """ Changes UoM and name if product_id changes.
-        @param product_id: Changed product_id
-        @return:  Dictionary of changed values
-        """
-        res = {}
-        if product_tmpl_id:
-            prod = self.pool.get('product.template').browse(cr, uid, product_tmpl_id, context=context)
-            res['value'] = {
-                'product_uom': prod.uom_id.id,
-            }
-        return res
-
-    def name_get(self, cr, uid, ids, context=None):
-        res = []
-        for record in self.browse(cr, uid, ids, context=context):
-            name = record.product_tmpl_id.name
-            if record.code:
-                name = '[%s] %s' % (record.code, name)
-            res.append((record.id, name))
-        return res
-
 
-class mrp_bom_line(osv.osv):
+class BoMLine(models.Model):
     _name = 'mrp.bom.line'
     _order = "sequence"
     _rec_name = "product_id"
 
-    def _get_child_bom_lines(self, cr, uid, ids, field_name, arg, context=None):
-        """If the BOM line refers to a BOM, return the ids of the child BOM lines"""
-        bom_obj = self.pool['mrp.bom']
-        res = {}
-        for bom_line in self.browse(cr, uid, ids, context=context):
-            bom_id = bom_obj._bom_find(cr, uid,
-                product_tmpl_id=bom_line.product_id.product_tmpl_id.id,
-                product_id=bom_line.product_id.id, context=context)
-            if bom_id:
-                child_bom = bom_obj.browse(cr, uid, bom_id, context=context)
-                res[bom_line.id] = [x.id for x in child_bom.bom_line_ids]
-            else:
-                res[bom_line.id] = False
-        return res
+    product_id = fields.Many2one(
+        'product.product', 'Product',
+        required=True)
+    product_qty = fields.Float(
+        'Product Quantity', default=1.0,
+        digits_compute=dp.get_precision('Product Unit of Measure'), required=True)
+    product_uom = fields.Many2one(
+        'product.uom', 'Product Unit of Measure',
+        default=lambda self: self.env['mrp.bom']._get_default_product_uom(),
+        required=True,
+        help="Unit of Measure (Unit of Measure) is the unit of measurement for the inventory control")
+    date_start = fields.Date('Valid From', help="Validity of component. Keep empty if it's always valid.")
+    date_stop = fields.Date('Valid Until', help="Validity of component. Keep empty if it's always valid.")
+    sequence = fields.Integer(
+        'Sequence', default=1,
+        help="Gives the sequence order when displaying.")
+    routing_id = fields.Many2one(
+        'mrp.routing', 'Routing',
+        help="The list of operations (list of work centers) to produce the finished product. The "
+             "routing is mainly used to compute work center costs during operations and to plan "
+             "future loads on work centers based on production planning.")
+    product_rounding = fields.Float(
+        'Product Rounding', default=0.0,
+        help="Rounding applied on the product quantity.")
+    product_efficiency = fields.Float(
+        'Manufacturing Efficiency',
+        default=1.0, required=True,
+        help="A factor of 0.9 means a loss of 10% within the production process.")
+    property_ids = fields.Many2many('mrp.property', string='Properties')  # Not used
+    bom_id = fields.Many2one(
+        'mrp.bom', 'Parent BoM',
+        index=True, ondelete='cascade', required=True)
+    attribute_value_ids = fields.Many2many(
+        'product.attribute.value', string='Variants',
+        help="BOM Product Variants needed form apply this line.")
+    child_line_ids = fields.One2many(
+        'mrp.bom.line', string="BOM lines of the referred bom",
+        compute='_compute_child_line_ids')
+
+    @api.one
+    @api.depends('product_id')
+    def _compute_child_line_ids(self):
+        """ If the BOM line refers to a BOM, return the ids of the child BOM lines """
+        if not self.product_id:
+            self.child_line_ids = False
+            return
+        bom = self.env['mrp.bom']._bom_find(
+            product_tmpl_id=self.product_id.product_tmpl_id.id,
+            product_id=self.product_id.id)
+        if bom:
+            self.child_line_ids = bom.bom_line_ids.ids
+        else:
+            self.child_line_ids = False
 
-    _columns = {
-        'product_id': fields.many2one('product.product', 'Product', required=True),
-        'product_qty': fields.float('Product Quantity', required=True, digits_compute=dp.get_precision('Product Unit of Measure')),
-        'product_uom': fields.many2one('product.uom', 'Product Unit of Measure', required=True,
-            help="Unit of Measure (Unit of Measure) is the unit of measurement for the inventory control"),
-        
-        'date_start': fields.date('Valid From', help="Validity of component. Keep empty if it's always valid."),
-        'date_stop': fields.date('Valid Until', help="Validity of component. Keep empty if it's always valid."),
-        'sequence': fields.integer('Sequence', help="Gives the sequence order when displaying."),
-        'routing_id': fields.many2one('mrp.routing', 'Routing', help="The list of operations (list of work centers) to produce the finished product. The routing is mainly used to compute work center costs during operations and to plan future loads on work centers based on production planning."),
-        'product_rounding': fields.float('Product Rounding', help="Rounding applied on the product quantity."),
-        'product_efficiency': fields.float('Manufacturing Efficiency', required=True, help="A factor of 0.9 means a loss of 10% within the production process."),
-        'property_ids': fields.many2many('mrp.property', string='Properties'), #Not used
-
-        'bom_id': fields.many2one('mrp.bom', 'Parent BoM', ondelete='cascade', select=True, required=True),
-        'attribute_value_ids': fields.many2many('product.attribute.value', string='Variants', help="BOM Product Variants needed form apply this line."),
-        'child_line_ids': fields.function(_get_child_bom_lines, relation="mrp.bom.line", string="BOM lines of the referred bom", type="one2many")
-    }
-
-    def _get_uom_id(self, cr, uid, *args):
-        return self.pool["product.uom"].search(cr, uid, [], limit=1, order='id')[0]
-    _defaults = {
-        'product_qty': lambda *a: 1.0,
-        'product_efficiency': lambda *a: 1.0,
-        'product_rounding': lambda *a: 0.0,
-        'product_uom': _get_uom_id,
-        'sequence': 1,
-    }
     _sql_constraints = [
         ('bom_qty_zero', 'CHECK (product_qty>0)', 'All product quantities must be greater than 0.\n' \
             'You should install the mrp_byproduct module if you want to manage extra products on BoMs !'),
     ]
 
-    def create(self, cr, uid, values, context=None):
-        if context is None:
-            context = {}
-        product_obj = self.pool.get('product.product')
-        if 'product_id' in values and not 'product_uom' in values:
-            values['product_uom'] = product_obj.browse(cr, uid, values.get('product_id'), context=context).uom_id.id
-        return super(mrp_bom_line, self).create(cr, uid, values, context=context)
-
-    def onchange_uom(self, cr, uid, ids, product_id, product_uom, context=None):
-        res = {'value': {}}
-        if not product_uom or not product_id:
+    @api.model
+    def create(self, values):
+        if 'product_id' in values and not values.get('product_uom'):
+            values['product_uom'] = self.env['product.product'].browse(values['product_id']).uom_id.id
+        return super(BoMLine, self).create(values)
+
+    @api.onchange('product_uom')
+    def onchange_uom(self):
+        res = {}
+        if not self.product_uom or not self.product_id:
             return res
-        product = self.pool.get('product.product').browse(cr, uid, product_id, context=context)
-        uom = self.pool.get('product.uom').browse(cr, uid, product_uom, context=context)
-        if uom.category_id.id != product.uom_id.category_id.id:
+        if self.product_uom.category_id != self.product_id.uom_id.category_id:
             res['warning'] = {'title': _('Warning'), 'message': _('The Product Unit of Measure you chose has a different category than in the product form.')}
-            res['value'].update({'product_uom': product.uom_id.id})
+            self.product_uom = self.product_id.uom_id.id
         return res
 
-    def onchange_product_id(self, cr, uid, ids, product_id, product_qty=0, context=None):
-        """ Changes UoM if product_id changes.
-        @param product_id: Changed product_id
-        @return:  Dictionary of changed values
-        """
-        res = {}
-        if product_id:
-            prod = self.pool.get('product.product').browse(cr, uid, product_id, context=context)
-            res['value'] = {
-                'product_uom': prod.uom_id.id,
-            }
-        return res
\ No newline at end of file
+    @api.onchange('product_id')
+    def onchange_product_id(self):
+        if self.product_id:
+            self.product_uom = self.product_id.uom_id.id
+
+    def _skip_bom_line(self, product):
+        """ Control if a BoM line should be produce, can be inherited for add
+        custom control. """
+        if self.date_start and self.date_start > time.strftime(DEFAULT_SERVER_DATE_FORMAT) or \
+                self.date_stop and self.date_stop < time.strftime(DEFAULT_SERVER_DATE_FORMAT):
+            return True
+        # all bom_line_id variant values must be in the product
+        if self.attribute_value_ids:
+            if not product or (set(self.attribute_value_ids.ids) - set(product.attribute_value_ids.ids)):
+                return True
+        return False

--- a/addons/mrp/models/mrp_config_settings.py
+++ b/addons/mrp/models/mrp_config_settings.py
@@ -1,46 +1,39 @@
 # -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
-from openerp.osv import fields, osv
-from openerp.tools.translate import _
+from odoo import fields, models
 
-class mrp_config_settings(osv.osv_memory):
+
+class MrpConfigSettings(models.TransientModel):
     _name = 'mrp.config.settings'
     _inherit = 'res.config.settings'
 
-    _columns = {
-        'group_product_variant': fields.selection([
-            (0, "No variants on products"),
-            (1, 'Products can have several attributes, defining variants (Example: size, color,...)')
-            ], "Product Variants",
-            help='Work with product variant allows you to define some variant of the same products, an ease the product management in the ecommerce for example',
-            implied_group='product.group_product_variant'),
-        'module_mrp_operations': fields.selection([
-            (0, "Do not use a planning for the work orders "),
-            (1, "Allow detailed planning of work orders")
-            ], "Work Order Planning",
-            help='This allows to add state, date_start,date_stop in production order operation lines (in the "Work Centers" tab).\n'
-                 '-This installs the module mrp_operations.'),
-        'module_mrp_byproduct': fields.selection([
-            (0, "No by-products in bills of materials (A + B --> C)"),
-            (1, "Bills of materials may produce residual products (A + B --> C + D)")
-            ], "By-Products",
-            help='You can configure by-products in the bill of material.\n'
-                 'Without this module: A + B + C -> D.\n'
-                 'With this module: A + B + C -> D + E.\n'
-                 '-This installs the module mrp_byproduct.'),
-        'group_mrp_routings': fields.selection([
-            (0, "Manage production by manufacturing orders"),
-            (1, "Manage production by work orders")
-            ], "Routings",
-            implied_group='mrp.group_mrp_routings',
-            help='Work Order Operations allow you to create and manage the manufacturing operations that should be followed '
-                 'within your work centers in order to produce a product. They are attached to bills of materials '
-                 'that will define the required raw materials.'),
-        'group_rounding_efficiency': fields.selection([
-            (0, "No rounding and efficiency on bills of materials"),
-            (1, "Manage rounding and efficiency of bills of materials components")
-            ], "Rounding efficiency",
-            implied_group='mrp.group_rounding_efficiency',
-            help="""Allow to manage product rounding on quantity and product efficiency during production process"""),
-    }
+    group_product_variant = fields.Selection([
+        (0, "No variants on products"),
+        (1, 'Products can have several attributes, defining variants (Example: size, color,...)')], "Product Variants",
+        help='Work with product variant allows you to define some variant of the same products, an ease the product management in the ecommerce for example',
+        implied_group='product.group_product_variant')
+    module_mrp_operations = fields.Selection([
+        (0, "Do not use a planning for the work orders "),
+        (1, "Allow detailed planning of work orders")], "Work Order Planning",
+        help='This allows to add state, date_start,date_stop in production order operation lines (in the "Work Centers" tab).\n'
+             '-This installs the module mrp_operations.')
+    module_mrp_byproduct = fields.Selection([
+        (0, "No by-products in bills of materials (A + B --> C)"),
+        (1, "Bills of materials may produce residual products (A + B --> C + D)")], "By-Products",
+        help='You can configure by-products in the bill of material.\n'
+             'Without this module: A + B + C -> D.\n'
+             'With this module: A + B + C -> D + E.\n'
+             '-This installs the module mrp_byproduct.')
+    group_mrp_routings = fields.Selection([
+        (0, "Manage production by manufacturing orders"),
+        (1, "Manage production by work orders")], "Routings",
+        implied_group='mrp.group_mrp_routings',
+        help='Work Order Operations allow you to create and manage the manufacturing operations that should be followed '
+             'within your work centers in order to produce a product. They are attached to bills of materials '
+             'that will define the required raw materials.')
+    group_rounding_efficiency = fields.Selection([
+        (0, "No rounding and efficiency on bills of materials"),
+        (1, "Manage rounding and efficiency of bills of materials components")], "Rounding efficiency",
+        implied_group='mrp.group_rounding_efficiency',
+        help="""Allow to manage product rounding on quantity and product efficiency during production process""")

--- a/addons/mrp/models/mrp_production.py
+++ b/addons/mrp/models/mrp_production.py
@@ -5,249 +5,221 @@ import time
 from collections import OrderedDict
 
 import openerp.addons.decimal_precision as dp
-from openerp.osv import fields, osv
 from openerp.tools import float_compare, float_is_zero
-from openerp.tools.translate import _
 from openerp import SUPERUSER_ID
 from openerp.exceptions import UserError, AccessError
 
+from odoo import api, fields, models, _
 
-class mrp_production(osv.osv):
-    """
-    Production Orders / Manufacturing Orders
-    """
+
+class MrpProduction(models.Model):
+    """ Manufacturing Orders """
     _name = 'mrp.production'
+    _inherit = ['mail.thread', 'ir.needaction_mixin']
     _description = 'Manufacturing Order'
     _date_name = 'date_planned'
-    _inherit = ['mail.thread', 'ir.needaction_mixin']
-
-    def _production_calc(self, cr, uid, ids, prop, unknow_none, context=None):
-        """ Calculates total hours and total no. of cycles for a production order.
-        @param prop: Name of field.
-        @param unknow_none:
-        @return: Dictionary of values.
-        """
-        result = {}
-        for prod in self.browse(cr, uid, ids, context=context):
-            result[prod.id] = {
-                'hour_total': 0.0,
-                'cycle_total': 0.0,
-            }
-            for wc in prod.workcenter_lines:
-                result[prod.id]['hour_total'] += wc.hour
-                result[prod.id]['cycle_total'] += wc.cycle
-        return result
-
-    def _get_workcenter_line(self, cr, uid, ids, context=None):
-        result = {}
-        for line in self.pool['mrp.production.workcenter.line'].browse(cr, uid, ids, context=context):
-            result[line.production_id.id] = True
-        return result.keys()
-
-    def _src_id_default(self, cr, uid, ids, context=None):
-        try:
-            location_model, location_id = self.pool.get('ir.model.data').get_object_reference(cr, uid, 'stock', 'stock_location_stock')
-            self.pool.get('stock.location').check_access_rule(cr, uid, [location_id], 'read', context=context)
-        except (AccessError, ValueError):
-            location_id = False
-        return location_id
-
-    def _dest_id_default(self, cr, uid, ids, context=None):
-        try:
-            location_model, location_id = self.pool.get('ir.model.data').get_object_reference(cr, uid, 'stock', 'stock_location_stock')
-            self.pool.get('stock.location').check_access_rule(cr, uid, [location_id], 'read', context=context)
-        except (AccessError, ValueError):
-            location_id = False
-        return location_id
-
-    def _get_progress(self, cr, uid, ids, name, arg, context=None):
-        """ Return product quantity percentage """
-        result = dict.fromkeys(ids, 100)
-        for mrp_production in self.browse(cr, uid, ids, context=context):
-            if mrp_production.product_qty:
-                done = 0.0
-                for move in mrp_production.move_created_ids2:
-                    if not move.scrapped and move.product_id == mrp_production.product_id:
-                        done += move.product_qty
-                result[mrp_production.id] = done / mrp_production.product_qty * 100
-        return result
-
-    def _moves_assigned(self, cr, uid, ids, name, arg, context=None):
-        """ Test whether all the consume lines are assigned """
-        res = {}
-        for production in self.browse(cr, uid, ids, context=context):
-            res[production.id] = True
-            states = [x.state != 'assigned' for x in production.move_lines if x]
-            if any(states) or len(states) == 0: #When no moves, ready_production will be False, but test_ready will pass
-                res[production.id] = False
-        return res
-
-    def _mrp_from_move(self, cr, uid, ids, context=None):
-        """ Return mrp"""
-        res = []
-        for move in self.browse(cr, uid, ids, context=context):
-            res += self.pool.get("mrp.production").search(cr, uid, [('move_lines', 'in', move.id)], context=context)
-        return res
+    _order = 'priority desc, date_planned asc'
 
-    _columns = {
-        'name': fields.char('Reference', required=True, readonly=True, states={'draft': [('readonly', False)]}, copy=False),
-        'origin': fields.char('Source Document', readonly=True, states={'draft': [('readonly', False)]},
-            help="Reference of the document that generated this production order request.", copy=False),
-        'priority': fields.selection([('0', 'Not urgent'), ('1', 'Normal'), ('2', 'Urgent'), ('3', 'Very Urgent')], 'Priority',
-            select=True, readonly=True, states=dict.fromkeys(['draft', 'confirmed'], [('readonly', False)])),
-
-        'product_id': fields.many2one('product.product', 'Product', required=True, readonly=True, states={'draft': [('readonly', False)]}, 
-                                      domain=[('type', 'in', ['product', 'consu'])]),
-        'product_qty': fields.float('Product Quantity', digits_compute=dp.get_precision('Product Unit of Measure'), required=True, readonly=True, states={'draft': [('readonly', False)]}),
-        'product_uom': fields.many2one('product.uom', 'Product Unit of Measure', required=True, readonly=True, states={'draft': [('readonly', False)]}),
-        'progress': fields.function(_get_progress, type='float',
-            string='Production progress'),
-
-        'location_src_id': fields.many2one('stock.location', 'Raw Materials Location', required=True,
-            readonly=True, states={'draft': [('readonly', False)]},
-            help="Location where the system will look for components."),
-        'location_dest_id': fields.many2one('stock.location', 'Finished Products Location', required=True,
-            readonly=True, states={'draft': [('readonly', False)]},
-            help="Location where the system will stock the finished products."),
-        'date_planned': fields.datetime('Scheduled Date', required=True, select=1, readonly=True, states={'draft': [('readonly', False)]}, copy=False),
-        'date_start': fields.datetime('Start Date', select=True, readonly=True, copy=False),
-        'date_finished': fields.datetime('End Date', select=True, readonly=True, copy=False),
-        'bom_id': fields.many2one('mrp.bom', 'Bill of Material', readonly=True, states={'draft': [('readonly', False)]},
-            help="Bill of Materials allow you to define the list of required raw materials to make a finished product."),
-        'routing_id': fields.many2one('mrp.routing', string='Routing', on_delete='set null', readonly=True, states={'draft': [('readonly', False)]},
-            help="The list of operations (list of work centers) to produce the finished product. The routing is mainly used to compute work center costs during operations and to plan future loads on work centers based on production plannification."),
-        'move_prod_id': fields.many2one('stock.move', 'Product Move', readonly=True, copy=False),
-        'move_lines': fields.one2many('stock.move', 'raw_material_production_id', 'Products to Consume',
-            domain=[('state', 'not in', ('done', 'cancel'))], readonly=True, states={'draft': [('readonly', False)]}),
-        'move_lines2': fields.one2many('stock.move', 'raw_material_production_id', 'Consumed Products',
-            domain=[('state', 'in', ('done', 'cancel'))], readonly=True),
-        'move_created_ids': fields.one2many('stock.move', 'production_id', 'Products to Produce',
-            domain=[('state', 'not in', ('done', 'cancel'))], readonly=True),
-        'move_created_ids2': fields.one2many('stock.move', 'production_id', 'Produced Products',
-            domain=[('state', 'in', ('done', 'cancel'))], readonly=True),
-        'product_lines': fields.one2many('mrp.production.product.line', 'production_id', 'Scheduled goods',
-            readonly=True),
-        'workcenter_lines': fields.one2many('mrp.production.workcenter.line', 'production_id', 'Work Centers Utilisation',
-            readonly=True, states={'draft': [('readonly', False)]}),
-        'state': fields.selection(
-            [('draft', 'New'), ('cancel', 'Cancelled'), ('confirmed', 'Awaiting Raw Materials'),
-                ('ready', 'Ready to Produce'), ('in_production', 'Production Started'), ('done', 'Done')],
-            string='Status', readonly=True,
-            track_visibility='onchange', copy=False,
-            help="When the production order is created the status is set to 'Draft'.\n"
-                "If the order is confirmed the status is set to 'Waiting Goods.\n"
-                "If any exceptions are there, the status is set to 'Picking Exception.\n"
-                "If the stock is available then the status is set to 'Ready to Produce.\n"
-                "When the production gets started then the status is set to 'In Production.\n"
-                "When the production is over, the status is set to 'Done'."),
-        'hour_total': fields.function(_production_calc, type='float', string='Total Hours', multi='workorder', store={
-            _name: (lambda self, cr, uid, ids, c={}: ids, ['workcenter_lines'], 40),
-            'mrp.production.workcenter.line': (_get_workcenter_line, ['hour', 'cycle'], 40),
-        }),
-        'cycle_total': fields.function(_production_calc, type='float', string='Total Cycles', multi='workorder', store={
-            _name: (lambda self, cr, uid, ids, c={}: ids, ['workcenter_lines'], 40),
-            'mrp.production.workcenter.line': (_get_workcenter_line, ['hour', 'cycle'], 40),
-        }),
-        'user_id': fields.many2one('res.users', 'Responsible'),
-        'company_id': fields.many2one('res.company', 'Company', required=True),
-        'ready_production': fields.function(_moves_assigned, type='boolean', string="Ready for production", store={'stock.move': (_mrp_from_move, ['state'], 10)}),
-        'product_tmpl_id': fields.related('product_id', 'product_tmpl_id', type='many2one', relation='product.template', string='Product Template'),
-    }
-
-    _defaults = {
-        'priority': lambda *a: '1',
-        'state': lambda *a: 'draft',
-        'date_planned': lambda *a: time.strftime('%Y-%m-%d %H:%M:%S'),
-        'product_qty': lambda *a: 1.0,
-        'user_id': lambda self, cr, uid, c: uid,
-        'name': lambda self, cr, uid, context: self.pool['ir.sequence'].next_by_code(cr, uid, 'mrp.production', context=context) or '/',
-        'company_id': lambda self, cr, uid, c: self.pool.get('res.company')._company_default_get(cr, uid, 'mrp.production', context=c),
-        'location_src_id': _src_id_default,
-        'location_dest_id': _dest_id_default
-    }
+    @api.model
+    def _get_default_location_src_id(self):
+        location = self.env.ref('stock.stock_location_stock', raise_if_not_found=False)
+        if location:
+            try:
+                location.check_access_rule('read')
+                return location.id
+            except AccessError:
+                pass
+        return False
+
+    @api.model
+    def _get_default_location_dest_id(self):
+        return self._get_default_location_src_id()
+
+    name = fields.Char(
+        'Reference',
+        copy=False, default=lambda self: self.env['ir.sequence'].next_by_code('mrp.production') or '/',
+        readonly=True, required=True,
+        states={'draft': [('readonly', False)]})
+    origin = fields.Char(
+        'Source Document',
+        copy=False, readonly=True,
+        states={'draft': [('readonly', False)]},
+        help="Reference of the document that generated this production order request.")
+    priority = fields.Selection([
+        ('0', 'Not urgent'),
+        ('1', 'Normal'),
+        ('2', 'Urgent'),
+        ('3', 'Very Urgent')], 'Priority',
+        default='1', index=True, readonly=True,
+        states=dict.fromkeys(['draft', 'confirmed'], [('readonly', False)]))
+
+    product_id = fields.Many2one(
+        'product.product', 'Product',
+        domain=[('type', 'in', ['product', 'consu'])],
+        readonly=True, required=True,
+        states={'draft': [('readonly', False)]})
+    product_tmpl_id = fields.Many2one(
+        'product.template', 'Product Template',
+        related='product_id.product_tmpl_id')
+    product_qty = fields.Float(
+        'Product Quantity',
+        default=1.0, digits_compute=dp.get_precision('Product Unit of Measure'),
+        readonly=True, required=True,
+        states={'draft': [('readonly', False)]})
+    product_uom = fields.Many2one(
+        'product.uom', 'Product Unit of Measure',
+        readonly=True, required=True,
+        states={'draft': [('readonly', False)]})
+    progress = fields.Float('Production progress', compute='_compute_progress')
+
+    location_src_id = fields.Many2one(
+        'stock.location', 'Raw Materials Location',
+        default=_get_default_location_src_id,
+        readonly=True,  required=True,
+        states={'draft': [('readonly', False)]},
+        help="Location where the system will look for components.")
+    location_dest_id = fields.Many2one(
+        'stock.location', 'Finished Products Location',
+        default=_get_default_location_dest_id,
+        readonly=True,  required=True,
+        states={'draft': [('readonly', False)]},
+        help="Location where the system will stock the finished products.")
+    date_planned = fields.Datetime(
+        'Scheduled Date',
+        copy=False, default=fields.Datetime.now,
+        index=True, required=True, readonly=True,
+        states={'draft': [('readonly', False)]})
+    date_start = fields.Datetime('Start Date', copy=False, index=True, readonly=True)
+    date_finished = fields.Datetime('End Date', copy=False, index=True, readonly=True)
+    bom_id = fields.Many2one(
+        'mrp.bom', 'Bill of Material',
+        readonly=True, states={'draft': [('readonly', False)]},
+        help="Bill of Materials allow you to define the list of required raw materials to make a finished product.")
+    routing_id = fields.Many2one(
+        'mrp.routing', 'Routing',
+        on_delete='set null', readonly=True,
+        states={'draft': [('readonly', False)]},
+        help="The list of operations (list of work centers) to produce the finished product. The routing "
+             "is mainly used to compute work center costs during operations and to plan future loads on "
+             "work centers based on production plannification.")
+    move_prod_id = fields.Many2one(
+        'stock.move', 'Product Move',
+        copy=False, readonly=True)
+    move_lines = fields.One2many(
+        'stock.move', 'raw_material_production_id', 'Products to Consume',
+        domain=[('state', 'not in', ('done', 'cancel'))],
+        readonly=True, states={'draft': [('readonly', False)]})
+    move_lines2 = fields.One2many(
+        'stock.move', 'raw_material_production_id', 'Consumed Products',
+        domain=[('state', 'in', ('done', 'cancel'))],
+        readonly=True)
+    move_created_ids = fields.One2many(
+        'stock.move', 'production_id', 'Products to Produce',
+        domain=[('state', 'not in', ('done', 'cancel'))],
+        readonly=True)
+    move_created_ids2 = fields.One2many(
+        'stock.move', 'production_id', 'Produced Products',
+        domain=[('state', 'in', ('done', 'cancel'))],
+        readonly=True)
+    product_lines = fields.One2many(
+        'mrp.production.product.line', 'production_id', 'Scheduled goods',
+        readonly=True)
+    workcenter_lines = fields.One2many(
+        'mrp.production.workcenter.line', 'production_id', 'Work Centers Utilisation',
+        readonly=True,
+        states={'draft': [('readonly', False)]})
+    state = fields.Selection([
+        ('draft', 'New'),
+        ('cancel', 'Cancelled'),
+        ('confirmed', 'Awaiting Raw Materials'),
+        ('ready', 'Ready to Produce'),
+        ('in_production', 'Production Started'),
+        ('done', 'Done')], string='Status',
+        copy=False, default='draft', readonly=True, track_visibility='onchange',
+        help="When the production order is created the status is set to 'Draft'.\n"
+             "If the order is confirmed the status is set to 'Waiting Goods.\n"
+             "If any exceptions are there, the status is set to 'Picking Exception.\n"
+             "If the stock is available then the status is set to 'Ready to Produce.\n"
+             "When the production gets started then the status is set to 'In Production.\n"
+             "When the production is over, the status is set to 'Done'.")
+    hour_total = fields.Float('Total Hours', compute='_compute_hour_total', store=True)
+    cycle_total = fields.Float('Total Cycles', compute='_compute_cycle_total', store=True)
+    user_id = fields.Many2one('res.users', 'Responsible', default=lambda self: self._uid)
+    company_id = fields.Many2one(
+        'res.company', 'Company',
+        default=lambda self: self.env['res.company']._company_default_get('mrp.production'),
+        required=True)
+    ready_production = fields.Boolean(
+        "Ready for production", compute='_compute_ready_production', store=True)
 
     _sql_constraints = [
         ('name_uniq', 'unique(name, company_id)', 'Reference must be unique per Company!'),
     ]
 
-    _order = 'priority desc, date_planned asc'
-
-    def _check_qty(self, cr, uid, ids, context=None):
-        for order in self.browse(cr, uid, ids, context=context):
-            if order.product_qty <= 0:
-                return False
-        return True
+    @api.one
+    def _compute_progress(self):
+        """ Return product quantity percentage """
+        if self.product_qty:
+            self.progress = self.move_created_ids2 and sum(
+                move.product_qty for move in self.move_created_ids2.filtered(
+                    lambda move: not move.scrapped and move.product_id == self.product_id)
+                ) or 0.0 / self.product_qty
+
+    @api.one
+    @api.depends('workcenter_lines.hour')
+    def _compute_hour_total(self):
+        self.hour_total = self.workcenter_lines and sum(wc_line.hour for wc_line in self.workcenter_lines) or 0.0
+
+    @api.one
+    @api.depends('workcenter_lines.cycle')
+    def _compute_cycle_total(self):
+        self.cycle_total = self.workcenter_lines and sum(wc_line.cycle for wc_line in self.workcenter_lines) or 0.0
+
+    @api.one
+    @api.depends('move_lines.state')
+    def _compute_ready_production(self):
+        """ Test whether all the consume lines are assigned """
+        self.ready_production = self.move_lines and all(move.state == 'assigned' for move in self.move_lines)
+
+    @api.multi
+    @api.constrains('product_qty')
+    def _check_qty(self):
+        if any(production.product_qty <= 0 for production in self):
+            raise UserError(_('Order quantity cannot be negative or zero!'))
+
+    @api.onchange('location_src_id', 'location_dest_id')
+    def onchange_location_id(self):
+        """ Changes destination location if source location is changed. """
+        if self.location_src_id and not self.location_dest_id:
+            self.location_dest_id = self.location_src_id.id
+
+    @api.onchange('product_id')
+    def onchange_product_id(self):
+        """ Finds UoM of changed product. """
+        if not self.product_id:
+            self.bom_id = False
+        else:
+            bom = self.env['mrp.bom']._bom_find(product_id=self.product_id.id, properties=[])
+            self.bom_id = bom.id
+        self.product_uom = self.product_id.uom_id.id
+        self.product_tmpl_id = self.product_id.product_tmpl_id.id
 
-    _constraints = [
-        (_check_qty, 'Order quantity cannot be negative or zero!', ['product_qty']),
-    ]
+    @api.onchange('bom_id')
+    def onchange_bom_id(self):
+        """ Finds routing for changed BoM. """
+        self.routing_id = self.bom_id.routing_id.id
 
-    def create(self, cr, uid, values, context=None):
-        if context is None:
-            context = {}
-        product_obj = self.pool.get('product.product')
-        if 'product_id' in values and not 'product_uom' in values:
-            values['product_uom'] = product_obj.browse(cr, uid, values.get('product_id'), context=context).uom_id.id
-        return super(mrp_production, self).create(cr, uid, values, context=context)
+    @api.model
+    def create(self, values):
+        if values.get('product_id') and 'product_uom' not in values:
+            values['product_uom'] = self.env['product.product'].browse(values['product_id']).uom_id.id
+        return super(MrpProduction, self).create(values)
 
-    def unlink(self, cr, uid, ids, context=None):
-        for production in self.browse(cr, uid, ids, context=context):
-            if production.state not in ('draft', 'cancel'):
-                state_label = dict(production.fields_get(['state'])['state']['selection']).get(production.state)
-                raise UserError(_('Cannot delete a manufacturing order in state \'%s\'.') % state_label)
-        return super(mrp_production, self).unlink(cr, uid, ids, context=context)
-
-    def location_id_change(self, cr, uid, ids, src, dest, context=None):
-        """ Changes destination location if source location is changed.
-        @param src: Source location id.
-        @param dest: Destination location id.
-        @return: Dictionary of values.
-        """
-        if dest:
-            return {}
-        if src:
-            return {'value': {'location_dest_id': src}}
-        return {}
-
-    def product_id_change(self, cr, uid, ids, product_id, product_qty=0, context=None):
-        """ Finds UoM of changed product.
-        @param product_id: Id of changed product.
-        @return: Dictionary of values.
-        """
-        result = {}
-        if not product_id:
-            return {'value': {
-                'product_uom': False,
-                'bom_id': False,
-                'routing_id': False,
-                'product_tmpl_id': False
-            }}
-        bom_obj = self.pool.get('mrp.bom')
-        product = self.pool.get('product.product').browse(cr, uid, product_id, context=context)
-        bom_id = bom_obj._bom_find(cr, uid, product_id=product.id, properties=[], context=context)
-        routing_id = False
-        if bom_id:
-            bom_point = bom_obj.browse(cr, uid, bom_id, context=context)
-            routing_id = bom_point.routing_id.id or False
-        product_uom_id = product.uom_id and product.uom_id.id or False
-        result['value'] = {'product_uom': product_uom_id, 'bom_id': bom_id, 'routing_id': routing_id, 'product_tmpl_id': product.product_tmpl_id}
-        return result
-
-    def bom_id_change(self, cr, uid, ids, bom_id, context=None):
-        """ Finds routing for changed BoM.
-        @param product: Id of product.
-        @return: Dictionary of values.
-        """
-        if not bom_id:
-            return {'value': {
-                'routing_id': False
-            }}
-        bom_point = self.pool.get('mrp.bom').browse(cr, uid, bom_id, context=context)
-        routing_id = bom_point.routing_id.id or False
-        result = {
-            'routing_id': routing_id
-        }
-        return {'value': result}
+    @api.multi
+    def unlink(self):
+        if any(production.state not in ('draft', 'cancel') for production in self):
+            raise UserError(_('Cannot delete a manufacturing order not in draft or cancel state'))
+        return super(MrpProduction, self).unlink()
 
 
     def _prepare_lines(self, cr, uid, production, properties=None, context=None):
@@ -271,7 +243,6 @@ class mrp_production(osv.osv):
         # product_lines, workcenter_lines
         return bom_obj._bom_explode(cr, uid, bom_point, production.product_id, factor / bom_point.product_qty, properties, routing_id=production.routing_id.id, context=context)
 
-
     def _action_compute_lines(self, cr, uid, ids, properties=None, context=None):
         """ Compute product_lines and workcenter_lines from BoM structure
         @return: product_lines
@@ -302,12 +273,13 @@ class mrp_production(osv.osv):
                 workcenter_line_obj.create(cr, uid, line, context)
         return results
 
-    def action_compute(self, cr, uid, ids, properties=None, context=None):
+    @api.multi
+    def action_compute(self, properties=None):
         """ Computes bills of material of a product.
         @param properties: List containing dictionaries of properties.
         @return: No. of products.
         """
-        return len(self._action_compute_lines(cr, uid, ids, properties=properties, context=context))
+        return len(self._action_compute_lines(properties=properties))
 
     def action_cancel(self, cr, uid, ids, context=None):
         """ Cancels the production order and related stock moves.
@@ -504,10 +476,9 @@ class mrp_production(osv.osv):
         for wc_line in production.workcenter_lines:
             wc = wc_line.workcenter_id
             total_cost += wc_line.hour*wc.costs_hour + wc_line.cycle*wc.costs_cycle
-
         return total_cost
 
-    def action_produce(self, cr, uid, production_id, production_qty, production_mode, wiz=False, context=None):
+    def action_produce(self, cr, uid, ids, production_qty, production_mode, wiz=False, context=None):
         """ To produce final product based on production mode (consume/consume&produce).
         If Production mode is consume, all stock move lines of raw materials will be done/consumed.
         If Production mode is consume & produce, all stock move lines of raw materials will be done/consumed
@@ -520,7 +491,7 @@ class mrp_production(osv.osv):
         """
         stock_mov_obj = self.pool.get('stock.move')
         uom_obj = self.pool.get("product.uom")
-        production = self.browse(cr, uid, production_id, context=context)
+        production = self.browse(cr, uid, ids[0], context=context)
         production_qty_uom = uom_obj._compute_qty(cr, uid, production.product_uom.id, production_qty, production.product_id.uom_id.id)
         precision = self.pool['decimal.precision'].precision_get(cr, uid, 'Product Unit of Measure')
 
@@ -572,7 +543,7 @@ class mrp_production(osv.osv):
                 is_main_product = (produce_product.product_id.id == production.product_id.id) and production.product_id.cost_method=='real'
                 if is_main_product:
                     total_cost = self._calculate_total_cost(cr, uid, list(total_consume_moves), context=context)
-                    production_cost = self._calculate_workcenter_cost(cr, uid, production_id, context=context)
+                    production_cost = self._calculate_workcenter_cost(cr, uid, production.id, context=context)
                     price_unit = (total_cost + production_cost) / production_qty_uom
 
                 lot_id = False
@@ -583,24 +554,24 @@ class mrp_production(osv.osv):
                     stock_mov_obj.write(cr, uid, [produce_product.id], {'price_unit': price_unit}, context=context)
                 new_moves = stock_mov_obj.action_consume(cr, uid, [produce_product.id], qty,
                                                          location_id=produce_product.location_id.id, restrict_lot_id=lot_id, context=context)
-                stock_mov_obj.write(cr, uid, new_moves, {'production_id': production_id}, context=context)
+                stock_mov_obj.write(cr, uid, new_moves, {'production_id': production.id}, context=context)
                 if not float_is_zero(remaining_qty, precision_digits=precision):
                     # In case you need to make more than planned
                     #consumed more in wizard than previously planned
                     extra_move_id = stock_mov_obj.copy(cr, uid, produce_product.id, default={'product_uom_qty': remaining_qty,
-                                                                                             'production_id': production_id}, context=context)
+                                                                                             'production_id': production.id}, context=context)
                     if is_main_product:
                         stock_mov_obj.write(cr, uid, [extra_move_id], {'price_unit': price_unit}, context=context)
                     stock_mov_obj.action_confirm(cr, uid, [extra_move_id], context=context)
                     stock_mov_obj.action_done(cr, uid, [extra_move_id], context=context)
 
-        self.message_post(cr, uid, production_id, body=_("%s produced") % self._description, context=context)
+        self.message_post(cr, uid, production.id, body=_("%s produced") % self._description, context=context)
 
         # Remove remaining products to consume if no more products to produce
         if not production.move_created_ids and production.move_lines:
             stock_mov_obj.action_cancel(cr, uid, [x.id for x in production.move_lines], context=context)
 
-        self.signal_workflow(cr, uid, [production_id], 'button_produce_done')
+        self.signal_workflow(cr, uid, [production.id], 'button_produce_done')
         return True
 
     def _costs_generate(self, cr, uid, production):
@@ -648,27 +619,22 @@ class mrp_production(osv.osv):
                     })
         return amount
 
-    def action_in_production(self, cr, uid, ids, context=None):
-        """ Changes state to In Production and writes starting date.
-        @return: True
-        """
-        return self.write(cr, uid, ids, {'state': 'in_production', 'date_start': time.strftime('%Y-%m-%d %H:%M:%S')})
+    @api.multi
+    def action_in_production(self):
+        """ Changes state to In Production and writes starting date. """
+        return self.write({'state': 'in_production', 'date_start': fields.Datetime.now()})
 
     def consume_lines_get(self, cr, uid, ids, *args):
+        # TDE: DEAD CODE
         res = []
         for order in self.browse(cr, uid, ids, context={}):
             res += [x.id for x in order.move_lines]
         return res
 
-    def test_ready(self, cr, uid, ids):
-        res = True
-        for production in self.browse(cr, uid, ids):
-            if production.move_lines and not production.ready_production:
-                res = False
-        return res
+    @api.multi
+    def test_ready(self):
+        return all(production.ready_production for production in self)
 
-    
-    
     def _make_production_produce_line(self, cr, uid, production, context=None):
         stock_move = self.pool.get('stock.move')
         proc_obj = self.pool.get('procurement.order')
@@ -847,34 +813,32 @@ class mrp_production(osv.osv):
         return True
 
 
-class mrp_production_workcenter_line(osv.osv):
+class ProductionWorkcenterLine(models.Model):
     _name = 'mrp.production.workcenter.line'
     _description = 'Work Order'
     _order = 'sequence'
     _inherit = ['mail.thread']
 
-    _columns = {
-        'name': fields.char('Work Order', required=True),
-        'workcenter_id': fields.many2one('mrp.workcenter', 'Work Center', required=True),
-        'cycle': fields.float('Number of Cycles', digits=(16, 2)),
-        'hour': fields.float('Number of Hours', digits=(16, 2)),
-        'sequence': fields.integer('Sequence', required=True, help="Gives the sequence order when displaying a list of work orders."),
-        'production_id': fields.many2one('mrp.production', 'Manufacturing Order',
-            track_visibility='onchange', select=True, ondelete='cascade', required=True),
-    }
-    _defaults = {
-        'sequence': lambda *a: 1,
-        'hour': lambda *a: 0,
-        'cycle': lambda *a: 0,
-    }
-
-class mrp_production_product_line(osv.osv):
+    name = fields.Char('Work Order', required=True)
+    workcenter_id = fields.Many2one('mrp.workcenter', 'Work Center', required=True)
+    cycle = fields.Float(
+        'Number of Cycles', default=0.0, digits=(16, 2))
+    hour = fields.Float(
+        'Number of Hours', default=0.0, digits=(16, 2))
+    sequence = fields.Integer(
+        'Sequence', default=1,
+        required=True, help="Gives the sequence order when displaying a list of work orders.")
+    production_id = fields.Many2one(
+        'mrp.production', 'Manufacturing Order',
+        index=True, ondelete='cascade', required=True, track_visibility='onchange')
+
+
+class ProductionProductLine(models.Model):
     _name = 'mrp.production.product.line'
     _description = 'Production Scheduled Product'
-    _columns = {
-        'name': fields.char('Name', required=True),
-        'product_id': fields.many2one('product.product', 'Product', required=True),
-        'product_qty': fields.float('Product Quantity', digits_compute=dp.get_precision('Product Unit of Measure'), required=True),
-        'product_uom': fields.many2one('product.uom', 'Product Unit of Measure', required=True),
-        'production_id': fields.many2one('mrp.production', 'Production Order', select=True),
-    }
+
+    name = fields.Char('Name', required=True)
+    product_id = fields.Many2one('product.product', 'Product', required=True)
+    product_qty = fields.Float('Product Quantity', digits_compute=dp.get_precision('Product Unit of Measure'), required=True)
+    product_uom = fields.Many2one('product.uom', 'Product Unit of Measure', required=True)
+    production_id = fields.Many2one('mrp.production', 'Production Order', select=True)

--- a/addons/mrp/models/mrp_property.py
+++ b/addons/mrp/models/mrp_property.py
@@ -1,33 +1,29 @@
 # -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
-from openerp.osv import fields, osv
+from odoo import fields, models
 
 
-class mrp_property_group(osv.osv):
-    """
-    Group of mrp properties.
-    """
+class PropertyGroup(models.Model):
+    """ Group of mrp properties."""
     _name = 'mrp.property.group'
     _description = 'Property Group'
-    _columns = {
-        'name': fields.char('Property Group', required=True),
-        'description': fields.text('Description'),
-    }
 
+    name = fields.Char('Property Group', required=True)
+    description = fields.Text('Description')
 
-class mrp_property(osv.osv):
-    """
-    Properties of mrp.
-    """
+
+class Property(models.Model):
+    """ Properties of mrp """
     _name = 'mrp.property'
     _description = 'Property'
-    _columns = {
-        'name': fields.char('Name', required=True),
-        'composition': fields.selection([('min','min'),('max','max'),('plus','plus')], 'Properties composition', required=True, help="Not used in computations, for information purpose only."),
-        'group_id': fields.many2one('mrp.property.group', 'Property Group', required=True),
-        'description': fields.text('Description'),
-    }
-    _defaults = {
-        'composition': lambda *a: 'min',
-    }
+
+    name = fields.Char('Name', required=True)
+    composition = fields.Selection([
+        ('min', 'min'),
+        ('max', 'max'),
+        ('plus', 'plus')], string='Properties composition',
+        default='min', required=True,
+        help="Not used in computations, for information purpose only.")
+    group_id = fields.Many2one('mrp.property.group', 'Property Group', required=True)
+    description = fields.Text('Description')

--- a/addons/mrp/models/mrp_routing.py
+++ b/addons/mrp/models/mrp_routing.py
@@ -1,57 +1,57 @@
 # -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
-from openerp.osv import fields, osv
+from odoo import fields, models
 
 
-class mrp_routing(osv.osv):
-    """
-    For specifying the routings of Work Centers.
-    """
+class Routing(models.Model):
+    """ For specifying the routings of Work Centers. """
     _name = 'mrp.routing'
     _description = 'Routings'
-    _columns = {
-        'name': fields.char('Name', required=True),
-        'active': fields.boolean('Active', help="If the active field is set to False, it will allow you to hide the routing without removing it."),
-        'code': fields.char('Code', size=8),
 
-        'note': fields.text('Description'),
-        'workcenter_lines': fields.one2many('mrp.routing.workcenter', 'routing_id', 'Work Centers', copy=True),
+    name = fields.Char('Name', required=True)
+    active = fields.Boolean(
+        'Active', default=True,
+        help="If the active field is set to False, it will allow you to hide the routing without removing it.")
+    code = fields.Char('Code', size=8)
+    note = fields.Text('Description')
+    workcenter_lines = fields.One2many(
+        'mrp.routing.workcenter', 'routing_id', 'Work Centers', copy=True)
+    location_id = fields.Many2one(
+        'stock.location', 'Production Location',
+        help="Keep empty if you produce at the location where the finished products are needed."
+             "Set a location if you produce at a fixed location. This can be a partner location "
+             "if you subcontract the manufacturing operations.")
+    company_id = fields.Many2one(
+        'res.company', 'Company',
+        default=lambda self: self.env['res.company']._company_default_get('mrp.routing'))
 
-        'location_id': fields.many2one('stock.location', 'Production Location',
-            help="Keep empty if you produce at the location where the finished products are needed." \
-                "Set a location if you produce at a fixed location. This can be a partner location " \
-                "if you subcontract the manufacturing operations."
-        ),
-        'company_id': fields.many2one('res.company', 'Company'),
-    }
-    _defaults = {
-        'active': lambda *a: 1,
-        'company_id': lambda self, cr, uid, context: self.pool.get('res.company')._company_default_get(cr, uid, 'mrp.routing', context=context)
-    }
 
-class mrp_routing_workcenter(osv.osv):
-    """
-    Defines working cycles and hours of a Work Center using routings.
-    """
+class RoutingWorkcenter(models.Model):
+    """ Defines working cycles and hours of a Work Center using routings. """
     _name = 'mrp.routing.workcenter'
     _description = 'Work Center Usage'
     _order = 'sequence, id'
-    _columns = {
-        'workcenter_id': fields.many2one('mrp.workcenter', 'Work Center', required=True),
-        'name': fields.char('Name', required=True),
-        'sequence': fields.integer('Sequence', help="Gives the sequence order when displaying a list of routing Work Centers."),
-        'cycle_nbr': fields.float('Number of Cycles', required=True,
-            help="Number of iterations this work center has to do in the specified operation of the routing."),
-        'hour_nbr': fields.float('Number of Hours', required=True, help="Time in hours for this Work Center to achieve the operation of the specified routing."),
-        'routing_id': fields.many2one('mrp.routing', 'Parent Routing', select=True, ondelete='cascade',
-             help="Routings indicates all the Work Centers used, for how long and/or cycles." \
-                "If Routings is set then,the third tab of a production order (Work Centers) will be automatically pre-completed."),
-        'note': fields.text('Description'),
-        'company_id': fields.related('routing_id', 'company_id', type='many2one', relation='res.company', string='Company', store=True, readonly=True),
-    }
-    _defaults = {
-        'cycle_nbr': lambda *a: 1.0,
-        'hour_nbr': lambda *a: 0.0,
-        'sequence': 100,
-    }
\ No newline at end of file
+
+    workcenter_id = fields.Many2one('mrp.workcenter', 'Work Center', required=True)
+    name = fields.Char('Name', required=True)
+    sequence = fields.Integer(
+        'Sequence', default=100,
+        help="Gives the sequence order when displaying a list of routing Work Centers.")
+    cycle_nbr = fields.Float(
+        'Number of Cycles',
+        default=1.0, required=True,
+        help="Number of iterations this work center has to do in the specified operation of the routing.")
+    hour_nbr = fields.Float(
+        'Number of Hours',
+        default=0.0, required=True,
+        help="Time in hours for this Work Center to achieve the operation of the specified routing.")
+    routing_id = fields.Many2one(
+        'mrp.routing', 'Parent Routing',
+        index=True, ondelete='cascade',
+        help="Routings indicates all the Work Centers used, for how long and/or cycles."
+             "If Routings is set then,the third tab of a production order (Work Centers) will be automatically pre-completed.")
+    note = fields.Text('Description')
+    company_id = fields.Many2one(
+        'res.company', 'Company', related='routing_id.company_id',
+        readonly=True, store=True)

--- a/addons/mrp/models/mrp_workcenter.py
+++ b/addons/mrp/models/mrp_workcenter.py
@@ -1,57 +1,62 @@
 # -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
-from openerp.osv import fields, osv
+from odoo import api, exceptions, fields, models, _
 
-#----------------------------------------------------------
+# ----------------------------------------------------------
 # Work Centers
-#----------------------------------------------------------
+# ----------------------------------------------------------
 # capacity_hour : capacity per hour. default: 1.0.
 #          Eg: If 5 concurrent operations at one time: capacity = 5 (because 5 employees)
 # unit_per_cycle : how many units are produced for one cycle
 
 
-class mrp_workcenter(osv.osv):
+class WorkCenter(models.Model):
     _name = 'mrp.workcenter'
     _description = 'Work Center'
-    _inherits = {'resource.resource':"resource_id"}
-    _columns = {
-        'active': fields.boolean('Active'),
-        'note': fields.text('Description', help="Description of the Work Center. Explain here what's a cycle according to this Work Center."),
-        'capacity_per_cycle': fields.float('Capacity per Cycle', help="Number of operations this Work Center can do in parallel. If this Work Center represents a team of 5 workers, the capacity per cycle is 5."),
-        'time_cycle': fields.float('Time for 1 cycle (hour)', help="Time in hours for doing one cycle."),
-        'time_start': fields.float('Time before prod.', help="Time in hours for the setup."),
-        'time_stop': fields.float('Time after prod.', help="Time in hours for the cleaning."),
-        'costs_hour': fields.float('Cost per hour', help="Specify Cost of Work Center per hour."),
-        'costs_hour_account_id': fields.many2one('account.analytic.account', 'Hour Account',
-            help="Fill this only if you want automatic analytic accounting entries on production orders."),
-        'costs_cycle': fields.float('Cost per cycle', help="Specify Cost of Work Center per cycle."),
-        'costs_cycle_account_id': fields.many2one('account.analytic.account', 'Cycle Account',
-            help="Fill this only if you want automatic analytic accounting entries on production orders."),
-        'costs_general_account_id': fields.many2one('account.account', 'General Account', domain=[('deprecated', '=', False)]),
-        'resource_id': fields.many2one('resource.resource','Resource', ondelete='cascade', required=True),
-        'product_id': fields.many2one('product.product','Work Center Product', help="Fill this product to easily track your production costs in the analytic accounting."),
-    }
-    _defaults = {
-        'active': True,
-        'capacity_per_cycle': 1.0,
-        'resource_type': 'material',
-     }
-
-    def on_change_product_cost(self, cr, uid, ids, product_id, context=None):
-        value = {}
-
-        if product_id:
-            cost = self.pool.get('product.product').browse(cr, uid, product_id, context=context)
-            value = {'costs_hour': cost.standard_price}
-        return {'value': value}
-
-    def _check_capacity_per_cycle(self, cr, uid, ids, context=None):
-        for obj in self.browse(cr, uid, ids, context=context):
-            if obj.capacity_per_cycle <= 0.0:
-                return False
-        return True
-
-    _constraints = [
-        (_check_capacity_per_cycle, 'The capacity per cycle must be strictly positive.', ['capacity_per_cycle']),
-    ]
\ No newline at end of file
+    _inherits = {'resource.resource': 'resource_id'}
+
+    active = fields.Boolean('Active', default=True)
+    note = fields.Text(
+        'Description',
+        help="Description of the Work Center. Explain here what's a cycle according to this Work Center.")
+    capacity_per_cycle = fields.Float(
+        'Capacity per Cycle', default=1.0,
+        help="Number of operations this Work Center can do in parallel. If this Work "
+             "Center represents a team of 5 workers, the capacity per cycle is 5.")
+    time_cycle = fields.Float(
+        'Time for 1 cycle (hour)', help="Time in hours for doing one cycle.")
+    time_start = fields.Float(
+        'Time before prod.', help="Time in hours for the setup.")
+    time_stop = fields.Float(
+        'Time after prod.', help="Time in hours for the cleaning.")
+    costs_hour = fields.Float(
+        'Cost per hour', help="Specify Cost of Work Center per hour.")
+    costs_hour_account_id = fields.Many2one(
+        'account.analytic.account', 'Hour Account',
+        help="Fill this only if you want automatic analytic accounting entries on production orders.")
+    costs_cycle = fields.Float(
+        'Cost per cycle', help="Specify Cost of Work Center per cycle.")
+    costs_cycle_account_id = fields.Many2one(
+        'account.analytic.account', 'Cycle Account',
+        help="Fill this only if you want automatic analytic accounting entries on production orders.")
+    costs_general_account_id = fields.Many2one(
+        'account.account', 'General Account',
+        domain=[('deprecated', '=', False)])
+    resource_id = fields.Many2one(
+        'resource.resource', 'Resource',
+        ondelete='cascade', required=True)
+    product_id = fields.Many2one(
+        'product.product', 'Work Center Product',
+        help="Fill this product to easily track your production costs in the analytic accounting.")
+
+    @api.multi
+    @api.constrains('capacity_per_cycle')
+    def _check_capacity_per_cycle(self):
+        if any(workcenter.capacity_per_cycle <= 0.0 for workcenter in self):
+            raise exceptions.UserError(_('The capacity per cycle must be strictly positive.'))
+
+    @api.onchange('product_id')
+    def on_change_product_id(self):
+        if self.product_id:
+            self.costs_hour = self.product_id.standard_price

--- a/addons/mrp/models/procurement.py
+++ b/addons/mrp/models/procurement.py
@@ -3,113 +3,106 @@
 
 from datetime import datetime
 from dateutil.relativedelta import relativedelta
-from openerp.osv import osv, fields
-from openerp.tools.translate import _
-from openerp.tools import DEFAULT_SERVER_DATETIME_FORMAT
-from openerp import SUPERUSER_ID
 
-class procurement_rule(osv.osv):
+from odoo import api, fields, models, _
+from odoo.tools import DEFAULT_SERVER_DATETIME_FORMAT
+
+
+class ProcurementRule(models.Model):
     _inherit = 'procurement.rule'
 
-    def _get_action(self, cr, uid, context=None):
-        return [('manufacture', _('Manufacture'))] + super(procurement_rule, self)._get_action(cr, uid, context=context)
+    @api.model
+    def _get_action(self):
+        return [('manufacture', _('Manufacture'))] + super(ProcurementRule, self)._get_action()
 
 
-class procurement_order(osv.osv):
+class ProcurementOrder(models.Model):
     _inherit = 'procurement.order'
-    _columns = {
-        'bom_id': fields.many2one('mrp.bom', 'BoM', ondelete='cascade', select=True),
-        'property_ids': fields.many2many('mrp.property', 'procurement_property_rel', 'procurement_id','property_id', 'Properties'),
-        'production_id': fields.many2one('mrp.production', 'Manufacturing Order'),
-    }
 
-    def propagate_cancels(self, cr, uid, ids, context=None):
-        for procurement in self.browse(cr, uid, ids, context=context):
-            if procurement.rule_id.action == 'manufacture' and procurement.production_id:
-                self.pool.get('mrp.production').action_cancel(cr, uid, [procurement.production_id.id], context=context)
-        return super(procurement_order, self).propagate_cancels(cr, uid, ids, context=context)
+    bom_id = fields.Many2one('mrp.bom', 'BoM', ondelete='cascade', select=True)
+    property_ids = fields.Many2many('mrp.property', 'procurement_property_rel', 'procurement_id','property_id', 'Properties')
+    production_id = fields.Many2one('mrp.production', 'Manufacturing Order')
 
-    def _run(self, cr, uid, ids, context=None):
-        procurement = self.browse(cr, uid, ids[0], context=context)
-        if procurement.rule_id and procurement.rule_id.action == 'manufacture':
-            #make a manufacturing order for the procurement
-            return self.make_mo(cr, uid, [procurement.id], context=context)[procurement.id]
-        return super(procurement_order, self)._run(cr, uid, ids, context=context)
+    @api.multi
+    def propagate_cancels(self):
+        to_propagate = self.filtered(lambda procurement: procurement.rule_id.action == 'manufacture' and procurement.production_id).mapped('production_id')
+        if to_propagate:
+            to_propagate.action_cancel()
+        return super(ProcurementOrder, self).propagate_cancels()
 
-    def _check(self, cr, uid, ids, context=None):
-        procurement = self.browse(cr, uid, ids[0], context=context)
-        if procurement.production_id and procurement.production_id.state == 'done':  # TOCHECK: no better method? 
+    @api.multi
+    def _run(self):
+        if self.rule_id and self.rule_id.action == 'manufacture':
+            # make a manufacturing order for the procurement
+            return self.make_mo()[self.id]
+        return super(ProcurementOrder, self)._run()
+
+    @api.multi
+    def _check(self):
+        if self.production_id and self.production_id.state == 'done':  # TOCHECK: no better method? 
             return True
-        return super(procurement_order, self)._check(cr, uid, ids, context=context)
+        return super(ProcurementOrder, self)._check()
 
-    def check_bom_exists(self, cr, uid, ids, context=None):
+    @api.multi
+    def check_bom_exists(self):
         """ Finds the bill of material for the product from procurement order.
         @return: True or False
         """
-        for procurement in self.browse(cr, uid, ids, context=context):
-            properties = [x.id for x in procurement.property_ids]
-            bom_id = self.pool.get('mrp.bom')._bom_find(cr, uid, product_id=procurement.product_id.id,
-                                                        properties=properties, context=context)
-            if not bom_id:
+        for procurement in self:
+            # TDE FIXME: properties -> property_ids
+            bom = self.env['mrp.bom']._bom_find(product_id=procurement.product_id.id, properties=procurement.property_ids.ids)
+            if not bom:
                 return False
         return True
 
-    def _get_date_planned(self, cr, uid, procurement, context=None):
-        format_date_planned = datetime.strptime(procurement.date_planned,
+    def _get_date_planned(self):
+        format_date_planned = datetime.strptime(self.date_planned,
                                                 DEFAULT_SERVER_DATETIME_FORMAT)
-        date_planned = format_date_planned - relativedelta(days=procurement.product_id.produce_delay or 0.0)
-        date_planned = date_planned - relativedelta(days=procurement.company_id.manufacturing_lead)
+        date_planned = format_date_planned - relativedelta(days=self.product_id.produce_delay or 0.0)
+        date_planned = date_planned - relativedelta(days=self.company_id.manufacturing_lead)
         return date_planned
 
-    def _prepare_mo_vals(self, cr, uid, procurement, context=None):
-        res_id = procurement.move_dest_id and procurement.move_dest_id.id or False
-        newdate = self._get_date_planned(cr, uid, procurement, context=context)
-        bom_obj = self.pool.get('mrp.bom')
-        if procurement.bom_id:
-            bom_id = procurement.bom_id.id
-            routing_id = procurement.bom_id.routing_id.id
+    def _prepare_mo_vals(self):
+        BoM = self.env['mrp.bom'].with_context(company_id=self.company_id.id)
+        if self.bom_id:
+            bom = self.bom_id
+            routing_id = self.bom_id.routing_id.id
         else:
-            properties = [x.id for x in procurement.property_ids]
-            bom_id = bom_obj._bom_find(cr, uid, product_id=procurement.product_id.id,
-                                       properties=properties, context=dict(context, company_id=procurement.company_id.id))
-            bom = bom_obj.browse(cr, uid, bom_id, context=context)
+            bom = BoM._bom_find(product_id=self.product_id.id,
+                                properties=self.property_ids.ids)
             routing_id = bom.routing_id.id
         return {
-            'origin': procurement.origin,
-            'product_id': procurement.product_id.id,
-            'product_qty': procurement.product_qty,
-            'product_uom': procurement.product_uom.id,
-            'location_src_id': procurement.rule_id.location_src_id.id or procurement.location_id.id,
-            'location_dest_id': procurement.location_id.id,
-            'bom_id': bom_id,
+            'origin': self.origin,
+            'product_id': self.product_id.id,
+            'product_qty': self.product_qty,
+            'product_uom': self.product_uom.id,
+            'location_src_id': self.rule_id.location_src_id.id or self.location_id.id,
+            'location_dest_id': self.location_id.id,
+            'bom_id': bom.id,
             'routing_id': routing_id,
-            'date_planned': newdate.strftime('%Y-%m-%d %H:%M:%S'),
-            'move_prod_id': res_id,
-            'company_id': procurement.company_id.id,
+            'date_planned': self._get_date_planned().strftime('%Y-%m-%d %H:%M:%S'),  # TDE FIXME: use tools
+            'move_prod_id': self.move_dest_id.id,
+            'company_id': self.company_id.id,
         }
 
-    def make_mo(self, cr, uid, ids, context=None):
+    @api.multi
+    def make_mo(self):
         """ Make Manufacturing(production) order from procurement
         @return: New created Production Orders procurement wise
         """
         res = {}
-        production_obj = self.pool.get('mrp.production')
-        procurement_obj = self.pool.get('procurement.order')
-        for procurement in procurement_obj.browse(cr, uid, ids, context=context):
-            if self.check_bom_exists(cr, uid, [procurement.id], context=context):
-                #create the MO as SUPERUSER because the current user may not have the rights to do it (mto product launched by a sale for example)
-                vals = self._prepare_mo_vals(cr, uid, procurement, context=context)
-                produce_id = production_obj.create(cr, SUPERUSER_ID, vals, context=dict(context, force_company=procurement.company_id.id))
-                res[procurement.id] = produce_id
-                self.write(cr, uid, [procurement.id], {'production_id': produce_id})
-                self.production_order_create_note(cr, uid, procurement, context=context)
-                production_obj.action_compute(cr, uid, [produce_id], properties=[x.id for x in procurement.property_ids])
-                production_obj.signal_workflow(cr, uid, [produce_id], 'button_confirm')
+        Production = self.env['mrp.production']
+        for procurement in self:
+            ProductionSudo = Production.sudo().with_context(force_company=procurement.company_id.id)
+            if procurement.check_bom_exists():
+                # create the MO as SUPERUSER because the current user may not have the rights to do it (mto product launched by a sale for example)
+                production = ProductionSudo.create(procurement._prepare_mo_vals())
+                res[procurement.id] = production.id
+                procurement.write({'production_id': production.id})
+                procurement.message_post(body=_("Manufacturing Order <em>%s</em> created.") % (production.name))
+                production.action_compute(properties=procurement.property_ids.ids)
+                production.signal_workflow('button_confirm')
             else:
                 res[procurement.id] = False
-                self.message_post(cr, uid, [procurement.id], body=_("No BoM exists for this product!"), context=context)
+                procurement.message_post(body=_("No BoM exists for this product!"))
         return res
-
-    def production_order_create_note(self, cr, uid, procurement, context=None):
-        body = _("Manufacturing Order <em>%s</em> created.") % (procurement.production_id.name,)
-        self.message_post(cr, uid, [procurement.id], body=body, context=context)

--- a/addons/mrp/models/product.py
+++ b/addons/mrp/models/product.py
@@ -1,71 +1,64 @@
 # -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
-from openerp.osv import fields, osv
+from odoo import api, fields, models
 
 
-class product_template(osv.osv):
+class ProductTemplate(models.Model):
     _inherit = "product.template"
-    def _bom_orders_count(self, cr, uid, ids, field_name, arg, context=None):
-        Bom = self.pool('mrp.bom')
-        res = {}
-        for product_tmpl_id in ids:
-            nb = Bom.search_count(cr, uid, [('product_tmpl_id', '=', product_tmpl_id)], context=context)
-            res[product_tmpl_id] = {
-                'bom_count': nb,
-            }
-        return res
 
-    def _bom_orders_count_mo(self, cr, uid, ids, name, arg, context=None):
-        res = {}
-        for product_tmpl_id in self.browse(cr, uid, ids):
-            res[product_tmpl_id.id] = sum([p.mo_count for p in product_tmpl_id.product_variant_ids])
-        return res
+    bom_ids = fields.One2many('mrp.bom', 'product_tmpl_id','Bill of Materials')
+    bom_count = fields.Integer(compute='_compute_bom_count', string='# Bill of Material')
+    mo_count = fields.Integer(compute='_compute_mo_count', string='# Manufacturing Orders')
+    produce_delay = fields.Float(
+        'Manufacturing Lead Time', default=0.0,
+        help="Average delay in days to produce this product. In the case of multi-level BOM, the manufacturing lead times of the components will be added.")
 
-    _columns = {
-        'bom_ids': fields.one2many('mrp.bom', 'product_tmpl_id','Bill of Materials'),
-        'bom_count': fields.function(_bom_orders_count, string='# Bill of Material', type='integer', multi="_bom_order_count"),
-        'mo_count': fields.function(_bom_orders_count_mo, string='# Manufacturing Orders', type='integer'),
-        'produce_delay': fields.float('Manufacturing Lead Time', help="Average delay in days to produce this product. In the case of multi-level BOM, the manufacturing lead times of the components will be added."),
-    }
+    @api.multi
+    def _compute_bom_count(self):
+        read_group_res = self.env['mrp.bom'].read_group([('product_tmpl_id', 'in', self.ids)], ['product_tmpl_id'], ['product_tmpl_id'])
+        mapped_data = dict([(data['product_tmpl_id'][0], data['product_tmpl_id_count']) for data in read_group_res])
+        for product in self:
+            product.mo_count = mapped_data.get(product.id, 0)
 
-    _defaults = {
-        'produce_delay': 0,
-    }
+    @api.one
+    def _compute_mo_count(self):
+        self.mo_count = sum(self.mapped('product_variant_ids').mapped('mo_count'))
 
-    def action_view_mos(self, cr, uid, ids, context=None):
-        product_ids = [variant.id for template in self.browse(cr, uid, ids, context=context) for variant in template.product_variant_ids]
-        result = self.pool['ir.actions.act_window'].for_xml_id(cr, uid, 'mrp', 'act_product_mrp_production')
-        if len(ids) == 1 and len(product_ids) == 1:
-            result['context'] = {'default_product_id': product_ids[0], 'search_default_product_id': product_ids[0]}
+    @api.multi
+    def action_view_mos(self):
+        # TDE FIXME: get_products does not exists
+        product_ids = self.mapped('product_variant_ids').ids
+        action = self.env.ref('mrp.act_product_mrp_production').read()[0]
+        if len(self) == 1 and len(product_ids) == 1:
+            action['context'] = {'default_product_id': product_ids[0], 'search_default_product_id': product_ids[0]}
         else:
-            result['domain'] = [('product_id', 'in', product_ids)]
-            result['context'] = {}
-        return result
+            action['domain'] = [('product_id', 'in', product_ids)]
+            action['context'] = {}
+        return action
 
 
-class product_product(osv.osv):
+class ProductProduct(models.Model):
     _inherit = "product.product"
-    def _bom_orders_count(self, cr, uid, ids, field_name, arg, context=None):
-        Production = self.pool('mrp.production')
-        res = {}
-        for product_id in ids:
-            res[product_id] = Production.search_count(cr,uid, [('product_id', '=', product_id)], context=context)
-        return res
 
-    _columns = {
-        'mo_count': fields.function(_bom_orders_count, string='# Manufacturing Orders', type='integer'),
-    }
+    mo_count = fields.Integer(compute='_compute_mo_count', string='# Manufacturing Orders')
 
-    def action_view_bom(self, cr, uid, ids, context=None):
-        result = self.pool['ir.actions.act_window'].for_xml_id(cr, uid, 'mrp', 'product_open_bom')
-        templates = [product.product_tmpl_id.id for product in self.browse(cr, uid, ids, context=context)]
+    @api.multi
+    def _compute_mo_count(self):
+        read_group_res = self.env['mrp.production'].read_group([('product_id', 'in', self.ids)], ['product_id'], ['product_id'])
+        mapped_data = dict([(data['product_id'][0], data['product_id_count']) for data in read_group_res])
+        for product in self:
+            product.mo_count = mapped_data.get(product.id, 0)
+
+    @api.multi
+    def action_view_bom(self):
+        action = self.env.ref('mrp.product_open_bom').read()[0]
+        template_ids = self.mapped('producdt_tmpl_id').ids
         # bom specific to this variant or global to template
-        context = {
-            'search_default_product_tmpl_id': templates[0],
-            'search_default_product_id': ids[0],
-            'default_product_tmpl_id': templates[0],
-            'default_product_id': ids[0],
+        action['context'] = {
+            'search_default_product_tmpl_id': template_ids[0],
+            'search_default_product_id': self.ids[0],
+            'default_product_tmpl_id': template_ids[0],
+            'default_product_id': self.ids[0],
         }
-        result['context'] = str(context)
-        return result
+        return action

--- a/addons/mrp/models/res_company.py
+++ b/addons/mrp/models/res_company.py
@@ -1,14 +1,12 @@
 # -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
-from openerp.osv import osv,fields
+from odoo import fields, models
 
-class company(osv.osv):
+
+class Company(models.Model):
     _inherit = 'res.company'
-    _columns = {
-        'manufacturing_lead': fields.float('Manufacturing Lead Time', required=True,
-            help="Security days for each manufacturing operation."),
-    }
-    _defaults = {
-        'manufacturing_lead': lambda *a: 0.0,
-    }
+
+    manufacturing_lead = fields.Float(
+        'Manufacturing Lead Time', default=0.0, required=True,
+        help="Security days for each manufacturing operation.")

--- a/addons/mrp/models/stock_move.py
+++ b/addons/mrp/models/stock_move.py
@@ -1,49 +1,78 @@
 # -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
-import time
+from odoo import api, fields, models, workflow, _
+from odoo import SUPERUSER_ID
+from odoo.tools import float_compare
+from odoo.exceptions import UserError
 
-from openerp import api
-from openerp.osv import fields
-from openerp.osv import osv
-from openerp.tools.translate import _
-from openerp import SUPERUSER_ID
-from openerp.tools import DEFAULT_SERVER_DATETIME_FORMAT, float_compare
-from openerp.exceptions import UserError
 
-class StockMove(osv.osv):
+class StockMove(models.Model):
     _inherit = 'stock.move'
 
-    _columns = {
-        'production_id': fields.many2one('mrp.production', 'Production Order for Produced Products', select=True, copy=False),
-        'raw_material_production_id': fields.many2one('mrp.production', 'Production Order for Raw Materials', select=True),
-        'consumed_for': fields.many2one('stock.move', 'Consumed for', help='Technical field used to make the traceability of produced products'),
-    }
+    production_id = fields.Many2one(
+        'mrp.production', 'Production Order for Produced Products',
+        copy=False, index=True)
+    raw_material_production_id = fields.Many2one(
+        'mrp.production', 'Production Order for Raw Materials',
+        index=True)
+    consumed_for = fields.Many2one(
+        'stock.move', 'Consumed for',
+        help='Technical field used to make the traceability of produced products')
+
+    # @api.multi
+    # def write(self, vals):
+    #     res = super(StockMove, self).write(vals)
+    #     if vals.get('state') == 'assigned':
+    #         orders = self.filtered(lambda move: move.raw_material_production_id.state == 'confirmed').mapped('raw_material_production_id')
+    #         orders = orders.filtered(lambda order: order.test_ready)
+    #         for order in orders:
+    #             workflow.trg_validate(self._uid, 'mrp.production', order.id, 'moves_ready', self._cr)
+    #     return res
 
-    def get_code_from_locs(self, cr, uid, ids, location_id=False, location_dest_id=False, context=None):
+    def write(self, cr, uid, ids, vals, context=None):
+        if isinstance(ids, (int, long)):
+            ids = [ids]
+        res = super(StockMove, self).write(cr, uid, ids, vals, context=context)
+        from openerp import workflow
+        if vals.get('state') == 'assigned':
+            moves = self.browse(cr, uid, ids, context=context)
+            orders = list(set([x.raw_material_production_id.id for x in moves if x.raw_material_production_id and x.raw_material_production_id.state == 'confirmed']))
+            for order_id in orders:
+                if self.pool.get('mrp.production').test_ready(cr, uid, [order_id]):
+                    workflow.trg_validate(uid, 'mrp.production', order_id, 'moves_ready', cr)
+        return res
+
+    @api.multi
+    def get_code_from_locs(self, location_id=False, location_dest_id=False):
         """
         Returns the code the picking type should have.  This can easily be used
         to check if a move is internal or not
         move, location_id and location_dest_id are browse records
         """
-        move = self.browse(cr, uid, ids[0], context=context)
-        # TDE note: called only in MRP
         code = 'internal'
-        src_loc = location_id or move.location_id
-        dest_loc = location_dest_id or move.location_dest_id
+        src_loc = location_id or self.location_id
+        dest_loc = location_dest_id or self.location_dest_id
         if src_loc.usage == 'internal' and dest_loc.usage != 'internal':
             code = 'outgoing'
         if src_loc.usage != 'internal' and dest_loc.usage == 'internal':
             code = 'incoming'
         return code
 
-    def check_tracking(self, cr, uid, ids, ops, context=None):
-        super(StockMove, self).check_tracking(cr, uid, ids, ops, context=context)
-        move = self.browse(cr, uid, ids[0], context=context)
-        if move.raw_material_production_id and move.product_id.tracking!='none' and move.location_dest_id.usage == 'production' and move.raw_material_production_id.product_id.tracking != 'none' and not move.consumed_for:
-            raise UserError(_("Because the product %s requires it, you must assign a serial number to your raw material %s to proceed further in your production. Please use the 'Produce' button to do so.") % (move.raw_material_production_id.product_id.name, move.product_id.name))
-
-    def _action_explode(self, cr, uid, move, context=None):
+    @api.multi
+    def check_tracking(self, ops):
+        super(StockMove, self).check_tracking(ops)
+        for move in self:
+            if move.raw_material_production_id and \
+                    move.product_id.tracking !='none' and \
+                    move.location_dest_id.usage == 'production' and \
+                    move.raw_material_production_id.product_id.tracking != 'none' and \
+                    not move.consumed_for:
+                raise UserError(
+                    _("Because the product %s requires it, you must assign a serial number to your raw material %s to proceed further in your production. Please use the 'Produce' button to do so.") % (
+                        move.raw_material_production_id.product_id.name, move.product_id.name))
+
+    def _action_explode(self, cr, uid, ids, context=None):
         """ Explodes pickings.
         @param move: Stock moves
         @return: True
@@ -57,6 +86,7 @@ class StockMove(osv.osv):
         uom_obj = self.pool.get("product.uom")
         to_explode_again_ids = []
         property_ids = context.get('property_ids') or []
+        move = self.browse(cr, uid, ids[0], context=context)
         bis = bom_obj._bom_find(cr, SUPERUSER_ID, product_id=move.product_id.id, properties=property_ids)
         bom_point = bom_obj.browse(cr, SUPERUSER_ID, bis, context=context)
         if bis and bom_point.type == 'phantom':
@@ -98,13 +128,13 @@ class StockMove(osv.osv):
                             proc = proc_obj.copy(cr, uid, move.procurement_id.id, default=valdef, context=context)
                         else:
                             proc = proc_obj.create(cr, uid, valdef, context=context)
-                        proc_obj.run(cr, uid, [proc], context=context) #could be omitted
-            
-            #check if new moves needs to be exploded
+                        proc_obj.run(cr, uid, [proc], context=context)  # could be omitted
+
+            # check if new moves needs to be exploded
             if to_explode_again_ids:
                 for new_move in self.browse(cr, uid, to_explode_again_ids, context=context):
-                    processed_ids.extend(self._action_explode(cr, uid, new_move, context=context))
-            
+                    processed_ids.extend(new_move._action_explode())
+
             if not move.split_from and move.procurement_id:
                 # Check if procurements have been made to wait for
                 moves = move.procurement_id.move_ids
@@ -114,27 +144,28 @@ class StockMove(osv.osv):
             if processed_ids and move.state == 'assigned':
                 # Set the state of resulting moves according to 'assigned' as the original move is assigned
                 move_obj.write(cr, uid, list(set(processed_ids) - set([move.id])), {'state': 'assigned'}, context=context)
-                
-            #delete the move with original product which is not relevant anymore
+
+            # delete the move with original product which is not relevant anymore
             move_obj.unlink(cr, SUPERUSER_ID, [move.id], context=context)
-            #return list of newly created move
+            # return list of newly created move
             return processed_ids
 
         return [move.id]
 
-    def action_confirm(self, cr, uid, ids, context=None):
-        move_ids = []
-        for move in self.browse(cr, uid, ids, context=context):
-            #in order to explode a move, we must have a picking_type_id on that move because otherwise the move
-            #won't be assigned to a picking and it would be weird to explode a move into several if they aren't
-            #all grouped in the same picking.
+    @api.multi
+    def action_confirm(self):
+        moves = self.env['stock.move']
+        for move in self:
+            # in order to explode a move, we must have a picking_type_id on that move because otherwise the move
+            # won't be assigned to a picking and it would be weird to explode a move into several if they aren't
+            # all grouped in the same picking.
             if move.picking_type_id:
-                move_ids.extend(self._action_explode(cr, uid, move, context=context))
+                moves |= moves.browse(move._action_explode())
             else:
-                move_ids.append(move.id)
+                moves |= move
 
-        #we go further with the list of ids potentially changed by action_explode
-        return super(StockMove, self).action_confirm(cr, uid, move_ids, context=context)
+        # we go further with the list of ids potentially changed by action_explode
+        return super(StockMove, moves).action_confirm()
 
     def action_consume(self, cr, uid, ids, product_qty, location_id=False, restrict_lot_id=False, restrict_partner_id=False,
                        consumed_for=False, context=None):
@@ -209,16 +240,3 @@ class StockMove(osv.osv):
                 self.write(cr, uid, new_moves, {'production_id': move.production_id.id}, context=context)
             res += new_moves
         return res
-
-    def write(self, cr, uid, ids, vals, context=None):
-        if isinstance(ids, (int, long)):
-            ids = [ids]
-        res = super(StockMove, self).write(cr, uid, ids, vals, context=context)
-        from openerp import workflow
-        if vals.get('state') == 'assigned':
-            moves = self.browse(cr, uid, ids, context=context)
-            orders = list(set([x.raw_material_production_id.id for x in moves if x.raw_material_production_id and x.raw_material_production_id.state == 'confirmed']))
-            for order_id in orders:
-                if self.pool.get('mrp.production').test_ready(cr, uid, [order_id]):
-                    workflow.trg_validate(uid, 'mrp.production', order_id, 'moves_ready', cr)
-        return res

--- a/addons/mrp/models/stock_warehouse.py
+++ b/addons/mrp/models/stock_warehouse.py
@@ -2,85 +2,85 @@
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
 
-from openerp import api
-from openerp.osv import fields
-from openerp.osv import osv
-from openerp.tools.translate import _
-from openerp.exceptions import UserError
+from odoo import api, exceptions, fields, models, _
 
 
-class stock_warehouse(osv.osv):
+class StockWarehouse(models.Model):
     _inherit = 'stock.warehouse'
-    _columns = {
-        'manufacture_to_resupply': fields.boolean('Manufacture in this Warehouse', 
-                                                  help="When products are manufactured, they can be manufactured in this warehouse."),
-        'manufacture_pull_id': fields.many2one('procurement.rule', 'Manufacture Rule'),
-    }
 
-    _defaults = {
-        'manufacture_to_resupply': True,
-    }
+    manufacture_to_resupply = fields.Boolean(
+        'Manufacture in this Warehouse', default=True,
+        help="When products are manufactured, they can be manufactured in this warehouse.")
+    manufacture_pull_id = fields.Many2one(
+        'procurement.rule', 'Manufacture Rule')
 
-    def _get_manufacture_pull_rule(self, cr, uid, warehouse, context=None):
-        route_obj = self.pool.get('stock.location.route')
-        data_obj = self.pool.get('ir.model.data')
-        try:
-            manufacture_route_id = data_obj.get_object_reference(cr, uid, 'mrp', 'route_warehouse0_manufacture')[1]
-        except:
-            manufacture_route_id = route_obj.search(cr, uid, [('name', 'like', _('Manufacture'))], context=context)
-            manufacture_route_id = manufacture_route_id and manufacture_route_id[0] or False
-        if not manufacture_route_id:
-            raise UserError(_('Can\'t find any generic Manufacture route.'))
+    @api.multi
+    def write(self, vals):
+        if 'manufacture_to_resupply' in vals:
+            if vals.get("manufacture_to_resupply"):
+                for warehouse in self.filtered(lambda warehouse: not warehouse.manufacture_pull_id):
+                    manufacture_pull = warehouse._create_or_update_manufacture_pull(self.get_routes_dict())
+                    vals['manufacture_pull_id'] = manufacture_pull.id
+            else:
+                self.mapped('manufacture_pull_id').unlink()
+        return super(StockWarehouse, self).write(vals)
 
-        return {
-            'name': warehouse._format_routename(_(' Manufacture')),
-            'location_id': warehouse.lot_stock_id.id,
-            'route_id': manufacture_route_id,
-            'action': 'manufacture',
-            'picking_type_id': warehouse.int_type_id.id,
-            'propagate': False, 
-            'warehouse_id': warehouse.id,
-        }
+    @api.multi
+    def get_routes_dict(self):
+        result = super(StockWarehouse, self).get_routes_dict()
+        for warehouse in self:
+            result[warehouse.id]['manufacture'] = [self.Routing(warehouse.lot_stock_id, warehouse.lot_stock_id, warehouse.int_type_id)]
+        return result
 
-    def create_routes(self, cr, uid, ids, context=None):
-        pull_obj = self.pool.get('procurement.rule')
-        res = super(stock_warehouse, self).create_routes(cr, uid, ids, context=context)
-        warehouse = self.browse(cr, uid, ids, context=context)[0]
-        if warehouse.manufacture_to_resupply:
-            manufacture_pull_vals = self._get_manufacture_pull_rule(cr, uid, warehouse, context=context)
-            manufacture_pull_id = pull_obj.create(cr, uid, manufacture_pull_vals, context=context)
-            res['manufacture_pull_id'] = manufacture_pull_id
-        return res
+    def _get_manufacture_route_id(self):
+        manufacture_route_id = self.env.ref('mrp.route_warehouse0_manufacture').id
+        if not manufacture_route_id:
+            manufacture_route_id = self.env['stock.location.route'].search([('name', 'like', _('Manufacture'))], limit=1).id
+        if not manufacture_route_id:
+            raise exceptions.UserError(_('Can\'t find any generic Manufacture route.'))
+        return manufacture_route_id
 
-    def write(self, cr, uid, ids, vals, context=None):
-        pull_obj = self.pool.get('procurement.rule')
-        if isinstance(ids, (int, long)):
-            ids = [ids]
+    def _get_manufacture_pull_rules_values(self, route_values):
+        dummy, pull_rules_list = self._get_push_pull_rules_values(route_values, pull_values={
+            'name': self._format_routename(_(' Manufacture')),
+            'location_src_id': False,  # TDE FIXME
+            'action': 'manufacture',
+            'route_id': self._get_manufacture_route_id(),
+            'propagate': False,
+            'active': True})
+        return pull_rules_list
 
-        if 'manufacture_to_resupply' in vals:
-            if vals.get("manufacture_to_resupply"):
-                for warehouse in self.browse(cr, uid, ids, context=context):
-                    if not warehouse.manufacture_pull_id:
-                        manufacture_pull_vals = self._get_manufacture_pull_rule(cr, uid, warehouse, context=context)
-                        manufacture_pull_id = pull_obj.create(cr, uid, manufacture_pull_vals, context=context)
-                        vals['manufacture_pull_id'] = manufacture_pull_id
+    def _create_or_update_manufacture_pull(self, routes_data):
+        routes_data = routes_data or self.get_routes_dict()
+        for warehouse in self:
+            routings = routes_data[warehouse.id]['manufacture']
+            if warehouse.manufacture_pull_id:
+                manufacture_pull = warehouse.manufacture_pull_id
+                manufacture_pull.write(warehouse._get_manufacture_pull_rules_values(routings)[0])
             else:
-                for warehouse in self.browse(cr, uid, ids, context=context):
-                    if warehouse.manufacture_pull_id:
-                        pull_obj.unlink(cr, uid, warehouse.manufacture_pull_id.id, context=context)
-        return super(stock_warehouse, self).write(cr, uid, ids, vals, context=context)
+                manufacture_pull = self.env['procurement.rule'].create(warehouse._get_manufacture_pull_rules_values(routings)[0])
+        return manufacture_pull
+
+    @api.multi
+    def create_routes(self):
+        res = super(StockWarehouse, self).create_routes()
+        self.ensure_one()
+        routes_data = self.get_routes_dict()
+        manufacture_pull = self._create_or_update_manufacture_pull(routes_data)
+        res['manufacture_pull_id'] = manufacture_pull.id
+        return res
 
     @api.multi
     def _get_all_routes(self):
-        routes = super(stock_warehouse, self).get_all_routes_for_wh()
+        routes = super(StockWarehouse, self).get_all_routes_for_wh()
         routes |= self.filtered(lambda self: self.manufacture_to_resupply and self.manufacture_pull_id and self.manufacture_pull_id.route_id).mapped('manufacture_pull_id').mapped('route_id')
         return routes
 
-    def _handle_renaming(self, cr, uid, ids, name, code, context=None):
-        res = super(stock_warehouse, self)._handle_renaming(cr, uid, ids, name, code, context=context)
-        warehouse = self.browse(cr, uid, ids[0], context=context)
-        pull_obj = self.pool.get('procurement.rule')
-        #change the manufacture procurement rule name
-        if warehouse.manufacture_pull_id:
-            pull_obj.write(cr, uid, warehouse.manufacture_pull_id.id, {'name': warehouse.manufacture_pull_id.name.replace(warehouse.name, name, 1)}, context=context)
+    @api.multi
+    def _handle_renaming(self, name, code):
+        res = super(StockWarehouse, self)._handle_renaming(name, code)
+        # change the manufacture procurement rule name
+        for warehouse in self:
+            if warehouse.manufacture_pull_id:
+                warehouse.manufacture_pull_id.write({'name': warehouse.manufacture_pull_id.name.replace(warehouse.name, name, 1)})
         return res
