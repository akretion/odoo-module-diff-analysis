PR: https://github.com/odoo/odoo/pull/160547

From: 2b438810eb69010b5855d0b1353c68a04209763a
From: Audric Onockx (auon)
Date: 2024-04-05 19:15:05

Structural Changes: 38
Total Changes: 2538

[REF] sale_[timesheet,project]: split model per file

Each of those modules now contains a folder `models`,
which contains one file per odoo model.

closes odoo/odoo#160547

Signed-off-by: Xavier Bol (xbo) <xbo@odoo.com>

================================= pseudo patch: =================================

--- a/addons/sale_timesheet/models/__init__.py
+++ b/addons/sale_timesheet/models/__init__.py
@@ -1,12 +1,17 @@
 # -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
-from . import account
+from . import account_move_line
 from . import account_move
-from . import product
-from . import project
+from . import hr_employee
+from . import hr_timesheet
+from . import product_product
+from . import product_template
+from . import project_project
+from . import project_sale_line_employee_map
+from . import project_task_recurrency
+from . import project_task
 from . import project_update
-from . import sale_order
 from . import res_config_settings
-from . import project_sale_line_employee_map
-from . import hr_employee
+from . import sale_order_line
+from . import sale_order

--- a/addons/sale_timesheet/models/account_move.py
+++ b/addons/sale_timesheet/models/account_move.py
@@ -1,4 +1,3 @@
-# -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
 from collections import defaultdict
@@ -82,50 +81,3 @@ class AccountMove(models.Model):
                     domain = expression.AND([domain, [('date', '<=', end_date)]])
                 timesheets = self.env['account.analytic.line'].sudo().search(domain)
                 timesheets.write({'timesheet_invoice_id': line.move_id.id})
-
-
-class AccountMoveLine(models.Model):
-    _inherit = 'account.move.line'
-
-    @api.model
-    def _timesheet_domain_get_invoiced_lines(self, sale_line_delivery):
-        """ Get the domain for the timesheet to link to the created invoice
-            :param sale_line_delivery: recordset of sale.order.line to invoice
-            :return a normalized domain
-        """
-        return [
-            ('so_line', 'in', sale_line_delivery.ids),
-            ('project_id', '!=', False),
-            '|', '|',
-                ('timesheet_invoice_id', '=', False),
-                ('timesheet_invoice_id.state', '=', 'cancel'),
-                ('timesheet_invoice_id.payment_state', '=', 'reversed')
-        ]
-
-    def unlink(self):
-        move_line_read_group = self.env['account.move.line'].search_read([
-            ('move_id.move_type', '=', 'out_invoice'),
-            ('move_id.state', '=', 'draft'),
-            ('sale_line_ids.product_id.invoice_policy', '=', 'delivery'),
-            ('sale_line_ids.product_id.service_type', '=', 'timesheet'),
-            ('id', 'in', self.ids)],
-            ['move_id', 'sale_line_ids'])
-
-        sale_line_ids_per_move = defaultdict(lambda: self.env['sale.order.line'])
-        for move_line in move_line_read_group:
-            sale_line_ids_per_move[move_line['move_id'][0]] += self.env['sale.order.line'].browse(move_line['sale_line_ids'])
-
-        timesheet_read_group = self.sudo().env['account.analytic.line']._read_group([
-            ('timesheet_invoice_id.move_type', '=', 'out_invoice'),
-            ('timesheet_invoice_id.state', '=', 'draft'),
-            ('timesheet_invoice_id', 'in', self.move_id.ids)],
-            ['timesheet_invoice_id', 'so_line'],
-            ['id:array_agg'])
-
-        timesheet_ids = []
-        for timesheet_invoice, so_line, ids in timesheet_read_group:
-            if so_line.id in sale_line_ids_per_move[timesheet_invoice.id].ids:
-                timesheet_ids += ids
-
-        self.sudo().env['account.analytic.line'].browse(timesheet_ids).write({'timesheet_invoice_id': False})
-        return super().unlink()

--- a/None
+++ b/addons/sale_timesheet/models/account_move_line.py
@@ -0,0 +1,52 @@
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from collections import defaultdict
+
+from odoo import api, models
+
+
+class AccountMoveLine(models.Model):
+    _inherit = 'account.move.line'
+
+    @api.model
+    def _timesheet_domain_get_invoiced_lines(self, sale_line_delivery):
+        """ Get the domain for the timesheet to link to the created invoice
+            :param sale_line_delivery: recordset of sale.order.line to invoice
+            :return a normalized domain
+        """
+        return [
+            ('so_line', 'in', sale_line_delivery.ids),
+            ('project_id', '!=', False),
+            '|', '|',
+                ('timesheet_invoice_id', '=', False),
+                ('timesheet_invoice_id.state', '=', 'cancel'),
+                ('timesheet_invoice_id.payment_state', '=', 'reversed')
+        ]
+
+    def unlink(self):
+        move_line_read_group = self.env['account.move.line'].search_read([
+            ('move_id.move_type', '=', 'out_invoice'),
+            ('move_id.state', '=', 'draft'),
+            ('sale_line_ids.product_id.invoice_policy', '=', 'delivery'),
+            ('sale_line_ids.product_id.service_type', '=', 'timesheet'),
+            ('id', 'in', self.ids)],
+            ['move_id', 'sale_line_ids'])
+
+        sale_line_ids_per_move = defaultdict(lambda: self.env['sale.order.line'])
+        for move_line in move_line_read_group:
+            sale_line_ids_per_move[move_line['move_id'][0]] += self.env['sale.order.line'].browse(move_line['sale_line_ids'])
+
+        timesheet_read_group = self.sudo().env['account.analytic.line']._read_group([
+            ('timesheet_invoice_id.move_type', '=', 'out_invoice'),
+            ('timesheet_invoice_id.state', '=', 'draft'),
+            ('timesheet_invoice_id', 'in', self.move_id.ids)],
+            ['timesheet_invoice_id', 'so_line'],
+            ['id:array_agg'])
+
+        timesheet_ids = []
+        for timesheet_invoice, so_line, ids in timesheet_read_group:
+            if so_line.id in sale_line_ids_per_move[timesheet_invoice.id].ids:
+                timesheet_ids += ids
+
+        self.sudo().env['account.analytic.line'].browse(timesheet_ids).write({'timesheet_invoice_id': False})
+        return super().unlink()

--- a/addons/sale_timesheet/models/account.py
+++ b/addons/sale_timesheet/models/hr_timesheet.py
@@ -1,4 +1,3 @@
-# -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
 from odoo.exceptions import UserError
@@ -135,7 +134,7 @@ class AccountAnalyticLine(models.Model):
             since in ordered quantity, the timesheet quantity is not invoiced,
             thus there is no meaning of showing invoice with ordered quantity.
         """
-        domain = super(AccountAnalyticLine, self)._timesheet_get_portal_domain()
+        domain = super()._timesheet_get_portal_domain()
         return expression.AND([domain, [('timesheet_invoice_type', 'in', ['billable_time', 'non_billable', 'billable_fixed'])]])
 
     @api.model
@@ -155,7 +154,7 @@ class AccountAnalyticLine(models.Model):
         ]
 
     def _get_timesheets_to_merge(self):
-        res = super(AccountAnalyticLine, self)._get_timesheets_to_merge()
+        res = super()._get_timesheets_to_merge()
         return res.filtered(lambda l: not l.timesheet_invoice_id or l.timesheet_invoice_id.state != 'posted')
 
     @api.ondelete(at_uninstall=False)

--- a/None
+++ b/addons/sale_timesheet/models/product_product.py
@@ -0,0 +1,56 @@
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+import threading
+
+from odoo import api, models, tools, _
+from odoo.exceptions import ValidationError
+
+
+class ProductProduct(models.Model):
+    _inherit = 'product.product'
+
+    @tools.ormcache()
+    def _get_default_uom_id(self):
+        return self.env.ref('uom.product_uom_unit')
+
+    def _is_delivered_timesheet(self):
+        """ Check if the product is a delivered timesheet """
+        self.ensure_one()
+        return self.type == 'service' and self.service_policy == 'delivered_timesheet'
+
+    @api.onchange('type', 'service_type', 'service_policy')
+    def _onchange_service_fields(self):
+        for record in self:
+            if record.type == 'service' and record.service_type == 'timesheet' and \
+               not (record._origin.service_policy and record.service_policy == record._origin.service_policy):
+                record.uom_id = self.env.ref('uom.product_uom_hour')
+            elif record._origin.uom_id:
+                record.uom_id = record._origin.uom_id
+            else:
+                record.uom_id = self._get_default_uom_id()
+            record.uom_po_id = record.uom_id
+
+    @api.onchange('service_policy')
+    def _onchange_service_policy(self):
+        self._inverse_service_policy()
+        vals = self.product_tmpl_id._get_onchange_service_policy_updates(self.service_tracking,
+                                                                        self.service_policy,
+                                                                        self.project_id,
+                                                                        self.project_template_id)
+        if vals:
+            self.update(vals)
+
+    @api.ondelete(at_uninstall=False)
+    def _unlink_except_master_data(self):
+        time_product = self.env.ref('sale_timesheet.time_product')
+        if time_product in self:
+            raise ValidationError(_('The %s product is required by the Timesheets app and cannot be archived nor deleted.', time_product.name))
+
+    def write(self, vals):
+        # timesheet product can't be archived
+        test_mode = getattr(threading.current_thread(), 'testing', False) or self.env.registry.in_test_mode()
+        if not test_mode and 'active' in vals and not vals['active']:
+            time_product = self.env.ref('sale_timesheet.time_product')
+            if time_product in self:
+                raise ValidationError(_('The %s product is required by the Timesheets app and cannot be archived nor deleted.', time_product.name))
+        return super().write(vals)

--- a/addons/sale_timesheet/models/product.py
+++ b/addons/sale_timesheet/models/product_template.py
@@ -1,9 +1,8 @@
-# -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
 import threading
 
-from odoo import api, fields, models, tools, _
+from odoo import api, fields, models, _
 from odoo.exceptions import ValidationError
 
 
@@ -44,7 +43,7 @@ class ProductTemplate(models.Model):
         for product_template in self:
             if not product_template.visible_expense_policy:
                 product_template.visible_expense_policy = visibility
-        return super(ProductTemplate, self)._compute_visible_expense_policy()
+        return super()._compute_visible_expense_policy()
 
     @api.depends('service_tracking', 'service_policy', 'type', 'sale_ok')
     def _compute_product_tooltip(self):
@@ -125,54 +124,4 @@ class ProductTemplate(models.Model):
             time_product = self.env.ref('sale_timesheet.time_product')
             if time_product.product_tmpl_id in self:
                 raise ValidationError(_('The %s product is required by the Timesheets app and cannot be archived nor deleted.', time_product.name))
-        return super(ProductTemplate, self).write(vals)
-
-
-class ProductProduct(models.Model):
-    _inherit = 'product.product'
-
-    @tools.ormcache()
-    def _get_default_uom_id(self):
-        return self.env.ref('uom.product_uom_unit')
-
-    def _is_delivered_timesheet(self):
-        """ Check if the product is a delivered timesheet """
-        self.ensure_one()
-        return self.type == 'service' and self.service_policy == 'delivered_timesheet'
-
-    @api.onchange('type', 'service_type', 'service_policy')
-    def _onchange_service_fields(self):
-        for record in self:
-            if record.type == 'service' and record.service_type == 'timesheet' and \
-               not (record._origin.service_policy and record.service_policy == record._origin.service_policy):
-                record.uom_id = self.env.ref('uom.product_uom_hour')
-            elif record._origin.uom_id:
-                record.uom_id = record._origin.uom_id
-            else:
-                record.uom_id = self._get_default_uom_id()
-            record.uom_po_id = record.uom_id
-
-    @api.onchange('service_policy')
-    def _onchange_service_policy(self):
-        self._inverse_service_policy()
-        vals = self.product_tmpl_id._get_onchange_service_policy_updates(self.service_tracking,
-                                                                        self.service_policy,
-                                                                        self.project_id,
-                                                                        self.project_template_id)
-        if vals:
-            self.update(vals)
-
-    @api.ondelete(at_uninstall=False)
-    def _unlink_except_master_data(self):
-        time_product = self.env.ref('sale_timesheet.time_product')
-        if time_product in self:
-            raise ValidationError(_('The %s product is required by the Timesheets app and cannot be archived nor deleted.', time_product.name))
-
-    def write(self, vals):
-        # timesheet product can't be archived
-        test_mode = getattr(threading.current_thread(), 'testing', False) or self.env.registry.in_test_mode()
-        if not test_mode and 'active' in vals and not vals['active']:
-            time_product = self.env.ref('sale_timesheet.time_product')
-            if time_product in self:
-                raise ValidationError(_('The %s product is required by the Timesheets app and cannot be archived nor deleted.', time_product.name))
-        return super(ProductProduct, self).write(vals)
+        return super().write(vals)

--- a/addons/sale_timesheet/models/project.py
+++ b/addons/sale_timesheet/models/project_project.py
@@ -1,23 +1,20 @@
-# -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
 import json
 
-from collections import defaultdict
-
 from odoo import api, fields, models, _, _lt
 from odoo.osv import expression
 from odoo.tools import SQL
 from odoo.exceptions import ValidationError, UserError
 
-# YTI PLEASE SPLIT ME
-class Project(models.Model):
+
+class ProjectProject(models.Model):
     _inherit = 'project.project'
 
     @api.model
     def default_get(self, fields):
         """ Pre-fill timesheet product as "Time" data product when creating new project allowing billable tasks by default. """
-        result = super(Project, self).default_get(fields)
+        result = super().default_get(fields)
         if 'timesheet_product_id' in fields and result.get('allow_billable') and result.get('allow_timesheets') and not result.get('timesheet_product_id'):
             default_product = self.env.ref('sale_timesheet.time_product', False)
             if default_product:
@@ -164,7 +161,7 @@ class Project(models.Model):
             if project.allow_billable and project.allow_timesheets and project.pricing_type != 'task_rate':
                 sol = project.sale_line_id or project.sale_line_employee_ids.sale_line_id[:1]
                 project.partner_id = sol.order_partner_id
-        super(Project, self - billable_projects)._compute_partner_id()
+        super(ProjectProject, self - billable_projects)._compute_partner_id()
 
     @api.depends('partner_id')
     def _compute_sale_line_id(self):
@@ -184,7 +181,7 @@ class Project(models.Model):
     @api.depends('sale_line_employee_ids.sale_line_id', 'allow_billable')
     def _compute_sale_order_count(self):
         billable_projects = self.filtered('allow_billable')
-        super(Project, billable_projects)._compute_sale_order_count()
+        super(ProjectProject, billable_projects)._compute_sale_order_count()
         non_billable_projects = self - billable_projects
         non_billable_projects.sale_order_line_count = 0
         non_billable_projects.sale_order_count = 0
@@ -202,7 +199,7 @@ class Project(models.Model):
                 raise ValidationError(_("You cannot link a billable project to a sales order item that comes from an expense or a vendor bill."))
 
     def write(self, values):
-        res = super(Project, self).write(values)
+        res = super().write(values)
         if 'allow_billable' in values and not values.get('allow_billable'):
             self.task_ids._get_timesheet().write({
                 'so_line': False,
@@ -287,7 +284,7 @@ class Project(models.Model):
     # ----------------------------
 
     def get_panel_data(self):
-        panel_data = super(Project, self).get_panel_data()
+        panel_data = super().get_panel_data()
         return {
             **panel_data,
             'analytic_account_id': self.analytic_account_id.id,
@@ -439,7 +436,7 @@ class Project(models.Model):
         def merge_profitability_data(a, b):
             return {
                 'data': a['data'] + b['data'],
-                'total': {key: a['total'][key] + b['total'][key] for key in a['total'].keys() if key in b['total']}
+                'total': {key: a['total'][key] + b['total'][key] for key in a['total'] if key in b['total']}
             }
 
         for revenue in profitability_items['revenues']['data']:
@@ -492,120 +489,3 @@ class Project(models.Model):
             super()._get_profitability_items(with_action),
             with_action
         )
-
-
-class ProjectTask(models.Model):
-    _inherit = "project.task"
-
-    def _get_default_partner_id(self, project, parent):
-        res = super()._get_default_partner_id(project, parent)
-        if not res and project:
-            # project in sudo if the current user is a portal user.
-            related_project = project
-            if self.env.user._is_portal() and not self.env.user._is_internal():
-                related_project = related_project.sudo()
-            if related_project.pricing_type == 'employee_rate':
-                return related_project.sale_line_employee_ids.sale_line_id.order_partner_id[:1]
-        return res
-
-    sale_order_id = fields.Many2one(domain="['|', '|', ('partner_id', '=', partner_id), ('partner_id', 'child_of', commercial_partner_id), ('partner_id', 'parent_of', partner_id)]")
-    so_analytic_account_id = fields.Many2one(related='sale_order_id.analytic_account_id', string='Sale Order Analytic Account')
-    pricing_type = fields.Selection(related="project_id.pricing_type")
-    is_project_map_empty = fields.Boolean("Is Project map empty", compute='_compute_is_project_map_empty')
-    has_multi_sol = fields.Boolean(compute='_compute_has_multi_sol', compute_sudo=True)
-    timesheet_product_id = fields.Many2one(related="project_id.timesheet_product_id")
-    remaining_hours_so = fields.Float('Remaining Hours on SO', compute='_compute_remaining_hours_so', search='_search_remaining_hours_so', compute_sudo=True)
-    remaining_hours_available = fields.Boolean(related="sale_line_id.remaining_hours_available")
-
-    @property
-    def SELF_READABLE_FIELDS(self):
-        return super().SELF_READABLE_FIELDS | {
-            'remaining_hours_available',
-            'remaining_hours_so',
-        }
-
-    @api.depends('sale_line_id', 'timesheet_ids', 'timesheet_ids.unit_amount')
-    def _compute_remaining_hours_so(self):
-        # TODO This is not yet perfectly working as timesheet.so_line stick to its old value although changed
-        #      in the task From View.
-        timesheets = self.timesheet_ids.filtered(lambda t: t.task_id.sale_line_id in (t.so_line, t._origin.so_line) and t.so_line.remaining_hours_available)
-
-        mapped_remaining_hours = {task._origin.id: task.sale_line_id and task.sale_line_id.remaining_hours or 0.0 for task in self}
-        uom_hour = self.env.ref('uom.product_uom_hour')
-        for timesheet in timesheets:
-            delta = 0
-            if timesheet._origin.so_line == timesheet.task_id.sale_line_id:
-                delta += timesheet._origin.unit_amount
-            if timesheet.so_line == timesheet.task_id.sale_line_id:
-                delta -= timesheet.unit_amount
-            if delta:
-                mapped_remaining_hours[timesheet.task_id._origin.id] += timesheet.product_uom_id._compute_quantity(delta, uom_hour)
-
-        for task in self:
-            task.remaining_hours_so = mapped_remaining_hours[task._origin.id]
-
-    @api.model
-    def _search_remaining_hours_so(self, operator, value):
-        return [('sale_line_id.remaining_hours', operator, value)]
-
-    @api.depends('so_analytic_account_id.active')
-    def _compute_analytic_account_active(self):
-        super()._compute_analytic_account_active()
-        for task in self:
-            task.analytic_account_active = task.analytic_account_active or task.so_analytic_account_id.active
-
-    def _inverse_partner_id(self):
-        super()._inverse_partner_id()
-        for task in self:
-            if task.allow_billable and not task.sale_line_id:
-                task.sale_line_id = task._get_last_sol_of_customer()
-
-    @api.depends('sale_line_id.order_partner_id', 'parent_id.sale_line_id', 'project_id.sale_line_id', 'allow_billable')
-    def _compute_sale_line(self):
-        super()._compute_sale_line()
-        for task in self:
-            if task.allow_billable and not task.sale_line_id:
-                task.sale_line_id = task._get_last_sol_of_customer()
-
-    @api.depends('project_id.sale_line_employee_ids')
-    def _compute_is_project_map_empty(self):
-        for task in self:
-            task.is_project_map_empty = not bool(task.sudo().project_id.sale_line_employee_ids)
-
-    @api.depends('timesheet_ids')
-    def _compute_has_multi_sol(self):
-        for task in self:
-            task.has_multi_sol = task.timesheet_ids and task.timesheet_ids.so_line != task.sale_line_id
-
-    def _get_last_sol_of_customer(self):
-        # Get the last SOL made for the customer in the current task where we need to compute
-        self.ensure_one()
-        if not self.partner_id.commercial_partner_id or not self.allow_billable:
-            return False
-        domain = [
-            ('company_id', '=?', self.company_id.id),
-            ('is_service', '=', True),
-            ('order_partner_id', 'child_of', self.partner_id.commercial_partner_id.ids),
-            ('is_expense', '=', False),
-            ('state', '=', 'sale'),
-            ('remaining_hours', '>', 0),
-            ('is_downpayment', '=', False),
-        ]
-        if self.project_id.pricing_type != 'task_rate' and self.project_sale_order_id and self.partner_id.commercial_partner_id == self.project_id.partner_id.commercial_partner_id:
-            domain.append(('order_id', '=?', self.project_sale_order_id.id))
-        return self.env['sale.order.line'].search(domain, limit=1)
-
-    def _get_timesheet(self):
-        # return not invoiced timesheet and timesheet without so_line or so_line linked to task
-        timesheet_ids = super(ProjectTask, self)._get_timesheet()
-        return timesheet_ids.filtered(lambda t: t._is_not_billed())
-
-    def _get_action_view_so_ids(self):
-        return list(set((self.sale_order_id + self.timesheet_ids.so_line.order_id).ids))
-
-class ProjectTaskRecurrence(models.Model):
-    _inherit = 'project.task.recurrence'
-
-    @api.model
-    def _get_recurring_fields_to_copy(self):
-        return super(ProjectTaskRecurrence, self)._get_recurring_fields_to_copy() + ['so_analytic_account_id']

--- a/None
+++ b/addons/sale_timesheet/models/project_task.py
@@ -0,0 +1,113 @@
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from odoo import api, fields, models
+
+
+class ProjectTask(models.Model):
+    _inherit = "project.task"
+
+    def _get_default_partner_id(self, project, parent):
+        res = super()._get_default_partner_id(project, parent)
+        if not res and project:
+            # project in sudo if the current user is a portal user.
+            related_project = project
+            if self.env.user._is_portal() and not self.env.user._is_internal():
+                related_project = related_project.sudo()
+            if related_project.pricing_type == 'employee_rate':
+                return related_project.sale_line_employee_ids.sale_line_id.order_partner_id[:1]
+        return res
+
+    sale_order_id = fields.Many2one(domain="['|', '|', ('partner_id', '=', partner_id), ('partner_id', 'child_of', commercial_partner_id), ('partner_id', 'parent_of', partner_id)]")
+    so_analytic_account_id = fields.Many2one(related='sale_order_id.analytic_account_id', string='Sale Order Analytic Account')
+    pricing_type = fields.Selection(related="project_id.pricing_type")
+    is_project_map_empty = fields.Boolean("Is Project map empty", compute='_compute_is_project_map_empty')
+    has_multi_sol = fields.Boolean(compute='_compute_has_multi_sol', compute_sudo=True)
+    timesheet_product_id = fields.Many2one(related="project_id.timesheet_product_id")
+    remaining_hours_so = fields.Float('Remaining Hours on SO', compute='_compute_remaining_hours_so', search='_search_remaining_hours_so', compute_sudo=True)
+    remaining_hours_available = fields.Boolean(related="sale_line_id.remaining_hours_available")
+
+    @property
+    def SELF_READABLE_FIELDS(self):
+        return super().SELF_READABLE_FIELDS | {
+            'remaining_hours_available',
+            'remaining_hours_so',
+        }
+
+    @api.depends('sale_line_id', 'timesheet_ids', 'timesheet_ids.unit_amount')
+    def _compute_remaining_hours_so(self):
+        # TODO This is not yet perfectly working as timesheet.so_line stick to its old value although changed
+        #      in the task From View.
+        timesheets = self.timesheet_ids.filtered(lambda t: t.task_id.sale_line_id in (t.so_line, t._origin.so_line) and t.so_line.remaining_hours_available)
+
+        mapped_remaining_hours = {task._origin.id: task.sale_line_id and task.sale_line_id.remaining_hours or 0.0 for task in self}
+        uom_hour = self.env.ref('uom.product_uom_hour')
+        for timesheet in timesheets:
+            delta = 0
+            if timesheet._origin.so_line == timesheet.task_id.sale_line_id:
+                delta += timesheet._origin.unit_amount
+            if timesheet.so_line == timesheet.task_id.sale_line_id:
+                delta -= timesheet.unit_amount
+            if delta:
+                mapped_remaining_hours[timesheet.task_id._origin.id] += timesheet.product_uom_id._compute_quantity(delta, uom_hour)
+
+        for task in self:
+            task.remaining_hours_so = mapped_remaining_hours[task._origin.id]
+
+    @api.model
+    def _search_remaining_hours_so(self, operator, value):
+        return [('sale_line_id.remaining_hours', operator, value)]
+
+    @api.depends('so_analytic_account_id.active')
+    def _compute_analytic_account_active(self):
+        super()._compute_analytic_account_active()
+        for task in self:
+            task.analytic_account_active = task.analytic_account_active or task.so_analytic_account_id.active
+
+    def _inverse_partner_id(self):
+        super()._inverse_partner_id()
+        for task in self:
+            if task.allow_billable and not task.sale_line_id:
+                task.sale_line_id = task._get_last_sol_of_customer()
+
+    @api.depends('sale_line_id.order_partner_id', 'parent_id.sale_line_id', 'project_id.sale_line_id', 'allow_billable')
+    def _compute_sale_line(self):
+        super()._compute_sale_line()
+        for task in self:
+            if task.allow_billable and not task.sale_line_id:
+                task.sale_line_id = task._get_last_sol_of_customer()
+
+    @api.depends('project_id.sale_line_employee_ids')
+    def _compute_is_project_map_empty(self):
+        for task in self:
+            task.is_project_map_empty = not bool(task.sudo().project_id.sale_line_employee_ids)
+
+    @api.depends('timesheet_ids')
+    def _compute_has_multi_sol(self):
+        for task in self:
+            task.has_multi_sol = task.timesheet_ids and task.timesheet_ids.so_line != task.sale_line_id
+
+    def _get_last_sol_of_customer(self):
+        # Get the last SOL made for the customer in the current task where we need to compute
+        self.ensure_one()
+        if not self.partner_id.commercial_partner_id or not self.allow_billable:
+            return False
+        domain = [
+            ('company_id', '=?', self.company_id.id),
+            ('is_service', '=', True),
+            ('order_partner_id', 'child_of', self.partner_id.commercial_partner_id.ids),
+            ('is_expense', '=', False),
+            ('state', '=', 'sale'),
+            ('remaining_hours', '>', 0),
+            ('is_downpayment', '=', False),
+        ]
+        if self.project_id.pricing_type != 'task_rate' and self.project_sale_order_id and self.partner_id.commercial_partner_id == self.project_id.partner_id.commercial_partner_id:
+            domain.append(('order_id', '=?', self.project_sale_order_id.id))
+        return self.env['sale.order.line'].search(domain, limit=1)
+
+    def _get_timesheet(self):
+        # return not invoiced timesheet and timesheet without so_line or so_line linked to task
+        timesheet_ids = super()._get_timesheet()
+        return timesheet_ids.filtered(lambda t: t._is_not_billed())
+
+    def _get_action_view_so_ids(self):
+        return list(set((self.sale_order_id + self.timesheet_ids.so_line.order_id).ids))

--- a/None
+++ b/addons/sale_timesheet/models/project_task_recurrency.py
@@ -0,0 +1,11 @@
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from odoo import api, models
+
+
+class ProjectTaskRecurrence(models.Model):
+    _inherit = 'project.task.recurrence'
+
+    @api.model
+    def _get_recurring_fields_to_copy(self):
+        return super()._get_recurring_fields_to_copy() + ['so_analytic_account_id']

--- a/addons/sale_timesheet/models/sale_order.py
+++ b/addons/sale_timesheet/models/sale_order.py
@@ -1,11 +1,8 @@
-# -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
-import math
 from collections import defaultdict
 
 from odoo import api, fields, models, _
-from odoo.osv import expression
 from odoo.tools import float_compare
 
 
@@ -153,218 +150,3 @@ class SaleOrder(models.Model):
         moves._link_timesheets_to_invoice(self.env.context.get("timesheet_start_date"), self.env.context.get("timesheet_end_date"))
         self._reset_has_displayed_warning_upsell_order_lines()
         return moves
-
-
-class SaleOrderLine(models.Model):
-    _inherit = "sale.order.line"
-
-    qty_delivered_method = fields.Selection(selection_add=[('timesheet', 'Timesheets')])
-    analytic_line_ids = fields.One2many(domain=[('project_id', '=', False)])  # only analytic lines, not timesheets (since this field determine if SO line came from expense)
-    remaining_hours_available = fields.Boolean(compute='_compute_remaining_hours_available', compute_sudo=True)
-    remaining_hours = fields.Float('Remaining Hours on SO', compute='_compute_remaining_hours', compute_sudo=True, store=True)
-    has_displayed_warning_upsell = fields.Boolean('Has Displayed Warning Upsell', copy=False)
-    timesheet_ids = fields.One2many('account.analytic.line', 'so_line', domain=[('project_id', '!=', False)], string='Timesheets')
-
-    @api.depends('remaining_hours_available', 'remaining_hours')
-    @api.depends_context('with_remaining_hours', 'company')
-    def _compute_display_name(self):
-        super()._compute_display_name()
-        with_remaining_hours = self.env.context.get('with_remaining_hours')
-        if with_remaining_hours and any(line.remaining_hours_available for line in self):
-            company = self.env.company
-            encoding_uom = company.timesheet_encode_uom_id
-            is_hour = is_day = False
-            unit_label = ''
-            if encoding_uom == self.env.ref('uom.product_uom_hour'):
-                is_hour = True
-                unit_label = _('remaining')
-            elif encoding_uom == self.env.ref('uom.product_uom_day'):
-                is_day = True
-                unit_label = _('days remaining')
-            for line in self:
-                if line.remaining_hours_available:
-                    remaining_time = ''
-                    if is_hour:
-                        hours, minutes = divmod(abs(line.remaining_hours) * 60, 60)
-                        round_minutes = minutes / 30
-                        minutes = math.ceil(round_minutes) if line.remaining_hours >= 0 else math.floor(round_minutes)
-                        if minutes > 1:
-                            minutes = 0
-                            hours += 1
-                        else:
-                            minutes = minutes * 30
-                        remaining_time = ' ({sign}{hours:02.0f}:{minutes:02.0f} {remaining})'.format(
-                            sign='-' if line.remaining_hours < 0 else '',
-                            hours=hours,
-                            minutes=minutes,
-                            remaining=unit_label)
-                    elif is_day:
-                        remaining_days = company.project_time_mode_id._compute_quantity(line.remaining_hours, encoding_uom, round=False)
-                        remaining_time = ' ({qty:.02f} {unit})'.format(
-                            qty=remaining_days,
-                            unit=unit_label
-                        )
-                    name = '{name}{remaining_time}'.format(
-                        name=line.display_name,
-                        remaining_time=remaining_time
-                    )
-                    line.display_name = name
-
-    @api.depends('product_id.service_policy')
-    def _compute_remaining_hours_available(self):
-        uom_hour = self.env.ref('uom.product_uom_hour')
-        for line in self:
-            is_ordered_prepaid = line.product_id.service_policy == 'ordered_prepaid'
-            is_time_product = line.product_uom.category_id == uom_hour.category_id
-            line.remaining_hours_available = is_ordered_prepaid and is_time_product
-
-    @api.depends('qty_delivered', 'product_uom_qty', 'analytic_line_ids')
-    def _compute_remaining_hours(self):
-        uom_hour = self.env.ref('uom.product_uom_hour')
-        for line in self:
-            remaining_hours = None
-            if line.remaining_hours_available:
-                qty_left = line.product_uom_qty - line.qty_delivered
-                remaining_hours = line.product_uom._compute_quantity(qty_left, uom_hour)
-            line.remaining_hours = remaining_hours
-
-    @api.depends('product_id')
-    def _compute_qty_delivered_method(self):
-        """ Sale Timesheet module compute delivered qty for product [('type', 'in', ['service']), ('service_type', '=', 'timesheet')] """
-        super(SaleOrderLine, self)._compute_qty_delivered_method()
-        for line in self:
-            if not line.is_expense and line.product_id.type == 'service' and line.product_id.service_type == 'timesheet':
-                line.qty_delivered_method = 'timesheet'
-
-    @api.depends('analytic_line_ids.project_id', 'project_id.pricing_type')
-    def _compute_qty_delivered(self):
-        super(SaleOrderLine, self)._compute_qty_delivered()
-        lines_by_timesheet = self.filtered(lambda sol: sol.qty_delivered_method == 'timesheet')
-        domain = lines_by_timesheet._timesheet_compute_delivered_quantity_domain()
-        mapping = lines_by_timesheet.sudo()._get_delivered_quantity_by_analytic(domain)
-        for line in lines_by_timesheet:
-            line.qty_delivered = mapping.get(line.id or line._origin.id, 0.0)
-
-    def _timesheet_compute_delivered_quantity_domain(self):
-        """ Hook for validated timesheet in addionnal module """
-        domain = [('project_id', '!=', False)]
-        if self._context.get('accrual_entry_date'):
-            domain += [('date', '<=', self._context['accrual_entry_date'])]
-        return domain
-
-    ###########################################
-    # Service : Project and task generation
-    ###########################################
-
-    def _convert_qty_company_hours(self, dest_company):
-        company_time_uom_id = dest_company.project_time_mode_id
-        allocated_hours = 0.0
-        product_uom = self.product_uom
-        if product_uom == self.env.ref('uom.product_uom_unit'):
-            product_uom = self.env.ref('uom.product_uom_hour')
-        if product_uom.category_id == company_time_uom_id.category_id:
-            if product_uom != company_time_uom_id:
-                allocated_hours = product_uom._compute_quantity(self.product_uom_qty, company_time_uom_id)
-            else:
-                allocated_hours = self.product_uom_qty
-        return allocated_hours
-
-    def _timesheet_create_project(self):
-        project = super()._timesheet_create_project()
-        # we can skip all the allocated hours calculation if allocated hours is already set on the template project
-        if self.product_id.project_template_id.allocated_hours:
-            project.write({
-                'allocated_hours': self.product_id.project_template_id.allocated_hours,
-                'allow_timesheets': True,
-            })
-            return project
-        project_uom = self.company_id.project_time_mode_id
-        uom_unit = self.env.ref('uom.product_uom_unit')
-        uom_hour = self.env.ref('uom.product_uom_hour')
-
-        # dict of inverse factors for each relevant UoM found in SO
-        factor_inv_per_id = {
-            uom.id: uom.factor_inv
-            for uom in self.order_id.order_line.product_uom
-            if uom.category_id == project_uom.category_id
-        }
-        # if sold as units, assume hours for time allocation
-        factor_inv_per_id[uom_unit.id] = uom_hour.factor_inv
-
-        allocated_hours = 0.0
-        # method only called once per project, so also allocate hours for
-        # all lines in SO that will share the same project
-        for line in self.order_id.order_line:
-            if line.is_service \
-                    and line.product_id.service_tracking in ['task_in_project', 'project_only'] \
-                    and line.product_id.project_template_id == self.product_id.project_template_id \
-                    and line.product_uom.id in factor_inv_per_id:
-                uom_factor = project_uom.factor * factor_inv_per_id[line.product_uom.id]
-                allocated_hours += line.product_uom_qty * uom_factor
-
-        project.write({
-            'allocated_hours': allocated_hours,
-            'allow_timesheets': True,
-        })
-        return project
-
-    def _timesheet_create_project_prepare_values(self):
-        """Generate project values"""
-        values = super()._timesheet_create_project_prepare_values()
-        values['allow_billable'] = True
-        return values
-
-    def _recompute_qty_to_invoice(self, start_date, end_date):
-        """ Recompute the qty_to_invoice field for product containing timesheets
-
-            Search the existed timesheets between the given period in parameter.
-            Retrieve the unit_amount of this timesheet and then recompute
-            the qty_to_invoice for each current product.
-
-            :param start_date: the start date of the period
-            :param end_date: the end date of the period
-        """
-        lines_by_timesheet = self.filtered(lambda sol: sol.product_id and sol.product_id._is_delivered_timesheet())
-        domain = lines_by_timesheet._timesheet_compute_delivered_quantity_domain()
-        refund_account_moves = self.order_id.invoice_ids.filtered(lambda am: am.state == 'posted' and am.move_type == 'out_refund').reversed_entry_id
-        timesheet_domain = [
-            '|',
-            ('timesheet_invoice_id', '=', False),
-            ('timesheet_invoice_id.state', '=', 'cancel')]
-        if refund_account_moves:
-            credited_timesheet_domain = [('timesheet_invoice_id.state', '=', 'posted'), ('timesheet_invoice_id', 'in', refund_account_moves.ids)]
-            timesheet_domain = expression.OR([timesheet_domain, credited_timesheet_domain])
-        domain = expression.AND([domain, timesheet_domain])
-        if start_date:
-            domain = expression.AND([domain, [('date', '>=', start_date)]])
-        if end_date:
-            domain = expression.AND([domain, [('date', '<=', end_date)]])
-        mapping = lines_by_timesheet.sudo()._get_delivered_quantity_by_analytic(domain)
-
-        for line in lines_by_timesheet:
-            qty_to_invoice = mapping.get(line.id, 0.0)
-            if qty_to_invoice:
-                line.qty_to_invoice = qty_to_invoice
-            else:
-                prev_inv_status = line.invoice_status
-                line.qty_to_invoice = qty_to_invoice
-                line.invoice_status = prev_inv_status
-
-    def _get_action_per_item(self):
-        """ Get action per Sales Order Item
-
-            When the Sales Order Item contains a service product then the action will be View Timesheets.
-
-            :returns: Dict containing id of SOL as key and the action as value
-        """
-        action_per_sol = super()._get_action_per_item()
-        timesheet_action = self.env.ref('sale_timesheet.timesheet_action_from_sales_order_item').id
-        timesheet_ids_per_sol = {}
-        if self.env.user.has_group('hr_timesheet.group_hr_timesheet_user'):
-            timesheet_read_group = self.env['account.analytic.line']._read_group([('so_line', 'in', self.ids), ('project_id', '!=', False)], ['so_line'], ['id:array_agg'])
-            timesheet_ids_per_sol = {so_line.id: ids for so_line, ids in timesheet_read_group}
-        for sol in self:
-            timesheet_ids = timesheet_ids_per_sol.get(sol.id, [])
-            if sol.is_service and len(timesheet_ids) > 0:
-                action_per_sol[sol.id] = timesheet_action, timesheet_ids[0] if len(timesheet_ids) == 1 else False
-        return action_per_sol

--- a/None
+++ b/addons/sale_timesheet/models/sale_order_line.py
@@ -0,0 +1,215 @@
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+import math
+
+from odoo import api, fields, models, _
+from odoo.osv import expression
+
+
+class SaleOrderLine(models.Model):
+    _inherit = "sale.order.line"
+
+    qty_delivered_method = fields.Selection(selection_add=[('timesheet', 'Timesheets')])
+    analytic_line_ids = fields.One2many(domain=[('project_id', '=', False)])  # only analytic lines, not timesheets (since this field determine if SO line came from expense)
+    remaining_hours_available = fields.Boolean(compute='_compute_remaining_hours_available', compute_sudo=True)
+    remaining_hours = fields.Float('Remaining Hours on SO', compute='_compute_remaining_hours', compute_sudo=True, store=True)
+    has_displayed_warning_upsell = fields.Boolean('Has Displayed Warning Upsell', copy=False)
+    timesheet_ids = fields.One2many('account.analytic.line', 'so_line', domain=[('project_id', '!=', False)], string='Timesheets')
+
+    @api.depends('remaining_hours_available', 'remaining_hours')
+    @api.depends_context('with_remaining_hours', 'company')
+    def _compute_display_name(self):
+        super()._compute_display_name()
+        with_remaining_hours = self.env.context.get('with_remaining_hours')
+        if with_remaining_hours and any(line.remaining_hours_available for line in self):
+            company = self.env.company
+            encoding_uom = company.timesheet_encode_uom_id
+            is_hour = is_day = False
+            unit_label = ''
+            if encoding_uom == self.env.ref('uom.product_uom_hour'):
+                is_hour = True
+                unit_label = _('remaining')
+            elif encoding_uom == self.env.ref('uom.product_uom_day'):
+                is_day = True
+                unit_label = _('days remaining')
+            for line in self:
+                if line.remaining_hours_available:
+                    remaining_time = ''
+                    if is_hour:
+                        hours, minutes = divmod(abs(line.remaining_hours) * 60, 60)
+                        round_minutes = minutes / 30
+                        minutes = math.ceil(round_minutes) if line.remaining_hours >= 0 else math.floor(round_minutes)
+                        if minutes > 1:
+                            minutes = 0
+                            hours += 1
+                        else:
+                            minutes = minutes * 30
+                        remaining_time = ' ({sign}{hours:02.0f}:{minutes:02.0f} {remaining})'.format(
+                            sign='-' if line.remaining_hours < 0 else '',
+                            hours=hours,
+                            minutes=minutes,
+                            remaining=unit_label)
+                    elif is_day:
+                        remaining_days = company.project_time_mode_id._compute_quantity(line.remaining_hours, encoding_uom, round=False)
+                        remaining_time = f' ({remaining_days:.02f} {unit_label})'
+                    name = f'{line.display_name}{remaining_time}'
+                    line.display_name = name
+
+    @api.depends('product_id.service_policy')
+    def _compute_remaining_hours_available(self):
+        uom_hour = self.env.ref('uom.product_uom_hour')
+        for line in self:
+            is_ordered_prepaid = line.product_id.service_policy == 'ordered_prepaid'
+            is_time_product = line.product_uom.category_id == uom_hour.category_id
+            line.remaining_hours_available = is_ordered_prepaid and is_time_product
+
+    @api.depends('qty_delivered', 'product_uom_qty', 'analytic_line_ids')
+    def _compute_remaining_hours(self):
+        uom_hour = self.env.ref('uom.product_uom_hour')
+        for line in self:
+            remaining_hours = None
+            if line.remaining_hours_available:
+                qty_left = line.product_uom_qty - line.qty_delivered
+                remaining_hours = line.product_uom._compute_quantity(qty_left, uom_hour)
+            line.remaining_hours = remaining_hours
+
+    @api.depends('product_id')
+    def _compute_qty_delivered_method(self):
+        """ Sale Timesheet module compute delivered qty for product [('type', 'in', ['service']), ('service_type', '=', 'timesheet')] """
+        super()._compute_qty_delivered_method()
+        for line in self:
+            if not line.is_expense and line.product_id.type == 'service' and line.product_id.service_type == 'timesheet':
+                line.qty_delivered_method = 'timesheet'
+
+    @api.depends('analytic_line_ids.project_id', 'project_id.pricing_type')
+    def _compute_qty_delivered(self):
+        super()._compute_qty_delivered()
+        lines_by_timesheet = self.filtered(lambda sol: sol.qty_delivered_method == 'timesheet')
+        domain = lines_by_timesheet._timesheet_compute_delivered_quantity_domain()
+        mapping = lines_by_timesheet.sudo()._get_delivered_quantity_by_analytic(domain)
+        for line in lines_by_timesheet:
+            line.qty_delivered = mapping.get(line.id or line._origin.id, 0.0)
+
+    def _timesheet_compute_delivered_quantity_domain(self):
+        """ Hook for validated timesheet in addionnal module """
+        domain = [('project_id', '!=', False)]
+        if self._context.get('accrual_entry_date'):
+            domain += [('date', '<=', self._context['accrual_entry_date'])]
+        return domain
+
+    ###########################################
+    # Service : Project and task generation
+    ###########################################
+
+    def _convert_qty_company_hours(self, dest_company):
+        company_time_uom_id = dest_company.project_time_mode_id
+        allocated_hours = 0.0
+        product_uom = self.product_uom
+        if product_uom == self.env.ref('uom.product_uom_unit'):
+            product_uom = self.env.ref('uom.product_uom_hour')
+        if product_uom.category_id == company_time_uom_id.category_id:
+            if product_uom != company_time_uom_id:
+                allocated_hours = product_uom._compute_quantity(self.product_uom_qty, company_time_uom_id)
+            else:
+                allocated_hours = self.product_uom_qty
+        return allocated_hours
+
+    def _timesheet_create_project(self):
+        project = super()._timesheet_create_project()
+        # we can skip all the allocated hours calculation if allocated hours is already set on the template project
+        if self.product_id.project_template_id.allocated_hours:
+            project.write({
+                'allocated_hours': self.product_id.project_template_id.allocated_hours,
+                'allow_timesheets': True,
+            })
+            return project
+        project_uom = self.company_id.project_time_mode_id
+        uom_unit = self.env.ref('uom.product_uom_unit')
+        uom_hour = self.env.ref('uom.product_uom_hour')
+
+        # dict of inverse factors for each relevant UoM found in SO
+        factor_inv_per_id = {
+            uom.id: uom.factor_inv
+            for uom in self.order_id.order_line.product_uom
+            if uom.category_id == project_uom.category_id
+        }
+        # if sold as units, assume hours for time allocation
+        factor_inv_per_id[uom_unit.id] = uom_hour.factor_inv
+
+        allocated_hours = 0.0
+        # method only called once per project, so also allocate hours for
+        # all lines in SO that will share the same project
+        for line in self.order_id.order_line:
+            if line.is_service \
+                    and line.product_id.service_tracking in ['task_in_project', 'project_only'] \
+                    and line.product_id.project_template_id == self.product_id.project_template_id \
+                    and line.product_uom.id in factor_inv_per_id:
+                uom_factor = project_uom.factor * factor_inv_per_id[line.product_uom.id]
+                allocated_hours += line.product_uom_qty * uom_factor
+
+        project.write({
+            'allocated_hours': allocated_hours,
+            'allow_timesheets': True,
+        })
+        return project
+
+    def _timesheet_create_project_prepare_values(self):
+        """Generate project values"""
+        values = super()._timesheet_create_project_prepare_values()
+        values['allow_billable'] = True
+        return values
+
+    def _recompute_qty_to_invoice(self, start_date, end_date):
+        """ Recompute the qty_to_invoice field for product containing timesheets
+
+            Search the existed timesheets between the given period in parameter.
+            Retrieve the unit_amount of this timesheet and then recompute
+            the qty_to_invoice for each current product.
+
+            :param start_date: the start date of the period
+            :param end_date: the end date of the period
+        """
+        lines_by_timesheet = self.filtered(lambda sol: sol.product_id and sol.product_id._is_delivered_timesheet())
+        domain = lines_by_timesheet._timesheet_compute_delivered_quantity_domain()
+        refund_account_moves = self.order_id.invoice_ids.filtered(lambda am: am.state == 'posted' and am.move_type == 'out_refund').reversed_entry_id
+        timesheet_domain = [
+            '|',
+            ('timesheet_invoice_id', '=', False),
+            ('timesheet_invoice_id.state', '=', 'cancel')]
+        if refund_account_moves:
+            credited_timesheet_domain = [('timesheet_invoice_id.state', '=', 'posted'), ('timesheet_invoice_id', 'in', refund_account_moves.ids)]
+            timesheet_domain = expression.OR([timesheet_domain, credited_timesheet_domain])
+        domain = expression.AND([domain, timesheet_domain])
+        if start_date:
+            domain = expression.AND([domain, [('date', '>=', start_date)]])
+        if end_date:
+            domain = expression.AND([domain, [('date', '<=', end_date)]])
+        mapping = lines_by_timesheet.sudo()._get_delivered_quantity_by_analytic(domain)
+
+        for line in lines_by_timesheet:
+            qty_to_invoice = mapping.get(line.id, 0.0)
+            if qty_to_invoice:
+                line.qty_to_invoice = qty_to_invoice
+            else:
+                prev_inv_status = line.invoice_status
+                line.qty_to_invoice = qty_to_invoice
+                line.invoice_status = prev_inv_status
+
+    def _get_action_per_item(self):
+        """ Get action per Sales Order Item
+
+            When the Sales Order Item contains a service product then the action will be View Timesheets.
+
+            :returns: Dict containing id of SOL as key and the action as value
+        """
+        action_per_sol = super()._get_action_per_item()
+        timesheet_action = self.env.ref('sale_timesheet.timesheet_action_from_sales_order_item').id
+        timesheet_ids_per_sol = {}
+        if self.env.user.has_group('hr_timesheet.group_hr_timesheet_user'):
+            timesheet_read_group = self.env['account.analytic.line']._read_group([('so_line', 'in', self.ids), ('project_id', '!=', False)], ['so_line'], ['id:array_agg'])
+            timesheet_ids_per_sol = {so_line.id: ids for so_line, ids in timesheet_read_group}
+        for sol in self:
+            timesheet_ids = timesheet_ids_per_sol.get(sol.id, [])
+            if sol.is_service and len(timesheet_ids) > 0:
+                action_per_sol[sol.id] = timesheet_action, timesheet_ids[0] if len(timesheet_ids) == 1 else False
+        return action_per_sol
