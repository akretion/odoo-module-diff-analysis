PR: https://github.com/odoo/odoo/pull/

From: 449f25463843767ba41a9a8c2adfdd4ceb2f2e5c
From: JÃ©rome Maes
Date: 2015-09-01 18:16:09

Breaking data model changes score: 2, change matches:
-    state = fields.Selection([('open', 'Open'), ('folded', 'Folded'), ('closed', 'Closed')], string='Status', default='open')
-    seen_datetime = fields.Datetime('Last Seen Datetime')

Total Changes: 521

[REF] mail : include real time, and replace Timeline features

This commit add instant messaging features in mail module to make it a real team collaboration tool. Lots of these new features will replace Timeleine view (which is not removed in this commit). Many files have been moved, split or created for a better structure.

- My Channels : A user can be member of channel (mail.channel). These are discussion group, but also an aggregate of notification. Setting a channel as document follower, it will receive all the message (of the chatter) in real time, as information stream.

- A new Inbox : this aims to replace the timeline view. The user will see its channels grouped by 'slot', and receive the message in real time. Jump to the form view, invite people, create private discussion group, talk directly to another employee, ... are the main features. Your message can still be starred. The 'Inbox' will only contain your needaction.

- Needaction concept : a needaction is a message calling you to do something. If you follow a document as a person, the posted message will be 'needaction' for you. It can also be a message where you are mention with a '@my_name' (this feature is not added in this commit).

- The chatter doesn't change so much. It still allow you to see the discussion about the document, to star some message, and treat your needaction.

- Chat : the only way to have a minified conversation is from the Inbox Client Action. It allow you to keep an eye on a channel when working on document.

- Compose Message : it is now common to the Inbox, and the chatter. It offers shortcode substitution, attachments management, and optional subtype.

- UI : the chat window has been clean, they have a new look now.

To do so,
- Chatter code have been completely rewrite, independently of timeline view
- Add 'bus' as mail dependency, to insure real time
- A mail.message is broadcasted on the bus channel (db, mail.channel, channel_id), and a channel header on (db, res.partner, partner_id)
- Extracting mail_thread mixin used for Chatter and ChatMailThread (Inbox client action). This uniformize the programming structure with the server side
- Clean CSS style and use LESS instead of CSS
- Define a new messafe format (message_format method in mail_message.py), compatible with fetching and broadcasting
- Apply guideline coding conventions

This commit also break the module im_livechat, since im_chat models don't exists anymore and will be fixed in the next commit.

Thanks to Thibault Delavallee (tde) for the long debates and precious advices, Richard Mathot (rim) for the support, Simon Lejeune (sle) for the client action layout, and the Usability Team (apr, lle, bst yti) for the long testing.

Conflicts:
	addons/mail/models/mail_thread.py

================================= pseudo patch: =================================

--- a/addons/mail/models/mail_channel.py
+++ b/addons/mail/models/mail_channel.py
@@ -1,21 +1,28 @@
 # -*- coding: utf-8 -*-
 
+import datetime
+import time
 import uuid
 
 from openerp import _, api, fields, models, modules, tools
+from openerp.tools.misc import DEFAULT_SERVER_DATETIME_FORMAT
 from openerp.exceptions import UserError
 
+from openerp.addons.bus.models.bus_presence import AWAY_TIMER
+
 
 class ChannelPartner(models.Model):
     _name = 'mail.channel.partner'
     _description = 'Last Seen Many2many'
+    _table = 'mail_channel_partner'
     _rec_name = 'partner_id'
 
     partner_id = fields.Many2one('res.partner', string='Recipient')
     channel_id = fields.Many2one('mail.channel', string='Channel')
     seen_message_id = fields.Many2one('mail.message', string='Last Seen')
-    state = fields.Selection([('open', 'Open'), ('folded', 'Folded'), ('closed', 'Closed')], string='Status', default='open')
-    seen_datetime = fields.Datetime('Last Seen Datetime')
+    fold_state = fields.Selection([('open', 'Open'), ('folded', 'Folded'), ('closed', 'Closed')], string='Conversation Fold State', default='open')
+    is_minimized = fields.Boolean("Conversation is minimied")
+    is_pinned = fields.Boolean("Is pinned on the interface", default=True)
 
 
 class Channel(models.Model):
@@ -124,10 +131,6 @@ class Channel(models.Model):
             self._subscribe_users()
         return result
 
-    def _notify(self, message):
-        # DO SOMETHING USEFULL
-        return True
-
     def _subscribe_users(self):
         for mail_channel in self:
             mail_channel.write({'channel_partner_ids': [(4, pid) for pid in mail_channel.mapped('group_ids').mapped('users').mapped('partner_id').ids]})
@@ -164,138 +167,310 @@ class Channel(models.Model):
         res['headers'] = repr(headers)
         return res
 
-
-    # --------------------------
-    # Session Methods
-    # --------------------------
     @api.multi
-    def session_info(self):
-        """ Get the header of the current session
-            :returns the values of the session
-            :rtype : dict
+    @api.returns('self', lambda value: value.id)
+    def message_post(self, body='', subject=None, message_type='notification', subtype=None, parent_id=False, attachments=None, content_subtype='html', **kwargs):
+        # auto pin 'direct_message' channel partner
+        self.filtered(lambda channel: channel.channel_type == 'direct_message').mapped('channel_last_seen_partner_ids').write({'is_pinned': True})
+        # apply shortcode (text only) subsitution
+        body = self.env['mail.shortcode'].apply_shortcode(body, shortcode_type='text')
+        message = super(Channel, self).message_post(body=body, message_type=message_type, subtype=subtype, content_subtype=content_subtype, **kwargs)
+        return message
+
+    #------------------------------------------------------
+    # Instant Messaging API
+    #------------------------------------------------------
+    # A channel header should be broadcasted:
+    #   - when adding user to channel (only to the new added partners)
+    #   - when folding/minimizing a channel (only to the user making the action)
+    # A message should be broadcasted:
+    #   - when a message is posted on a channel (to the channel, using _notify() method)
+
+    # Anonymous method
+    @api.multi
+    def _broadcast(self, partner_ids):
+        """ Broadcast the current channel header to the given partner ids
+            :param partner_ids : the partner to notify
         """
-        self.ensure_one()
-        info = {
-            'uuid': self.uuid,
-            'users': self.session_user_info(),
-            'state': 'open',
-        }
-        # add user session state, if available and if user is logged
-        if self._uid:
-            domain = [('user_id', '=', self._uid), ('session_id', 'in', self.ids)]
-            session_state = self.env['im_chat.conversation_state'].search(domain, limit=1)
-            if session_state:
-                info['state'] = session_state.state
-        return info
+        notifications = []
+        for partner in self.env['res.partner'].browse(partner_ids):
+            user_id = partner.user_ids and partner.user_ids[0] or False
+            if user_id:
+                for channel_info in self.sudo(user_id).channel_info():
+                    notifications.append([(self._cr.dbname, 'res.partner', partner.id), channel_info])
+        self.env['bus.bus'].sendmany(notifications)
 
     @api.multi
-    def session_user_info(self):
-        """ Get the user infos for all the identified user in the session
-            :returns a list of user infos
-            :rtype : list(dict)
+    def _notify(self, message):
+        """ Broadcast the given message on the current channels.
+            Send the message on the Bus Channel (uuid for public mail.channel, and partner private bus channel (the tuple)).
+            A partner will receive only on message on its bus channel, even if this message belongs to multiple mail channel. Then 'channel_ids' field
+            of the received message indicates on wich mail channel the message should be displayed.
+            :param : mail.message to broadcast
         """
-        self.ensure_one()
-        return self.env['res.users'].browse(self.user_ids.ids).read(['id', 'name', 'im_status'])
+        message.ensure_one()
+        message_values = message.message_format()[0]
 
-    @api.model
-    def session_user_image(self, uuid, user_id):
-        """ Get the avatar of a user in the given session
-            :param uuid : the uuid of the session
-            :param user_id : the user identifier
-        """
-        # get the session
-        image_b64 = False
-        if user_id:
-            session = self.env["im_chat.session"].search([('uuid', '=', uuid)], limit=1)
-            if session and session.sudo(user_id).is_in_session():
-                image_b64 = self.env["res.users"].sudo().browse(user_id).image_small
-        # set default image if not found
-        if not image_b64:
-            image_b64 = 'R0lGODlhAQABAIABAP///wAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=='
-        return image_b64
+        notifications = []
+        for channel in self:
+            message_values['channel_ids'] = [channel.id]
+            notifications.append([(self._cr.dbname, 'mail.channel', channel.id), dict(message_values)])
+            # add uuid to allow anonymous to listen
+            if channel.public == 'public':
+                notifications.append([channel.uuid, dict(message_values)])
+        self.env['bus.bus'].sendmany(notifications)
 
-    @api.model
-    def session_get(self, user_to):
-        """ Get the canonical session between 2 users, create it if needed.
-            To reuse an old session, this one must be private, and contains only 2 users.
-            :param user_to : the identifier of the user
-            :returns a session header, or False if the user_to was False
-            :rtype : dict
-        """
-        if user_to:
-            session = self.search([('user_ids', 'in', user_to), ('user_ids', 'in', [self._uid])], limit=1)
-            if not (session and len(session.user_ids) == 2 and session.is_private()):
-                session = self.create({'user_ids': [(6, 0, (user_to, self._uid))]})
-            return session.session_info()
-
-    # --------------------------
-    # Utils Methods
-    # --------------------------
     @api.multi
-    def is_private(self):
-        """ Return true if the session is private between identified users (no external messages).
-            The only way to do that is to check if there is a message without author (from_id is False).
+    def channel_info(self):
+        """ Get the informations header for the current channels
+            :returns a list of channels values
+            :rtype : list(dict)
         """
-        self.ensure_one()
-        message_ids = self.env["im_chat.message"].search([('to_id', 'in', self.ids), ('from_id', '=', None)])
-        return len(message_ids) == 0
+        channel_infos = []
+        partner_channels = self.env['mail.channel.partner']
+        # find the channel partner state, if logged user
+        if self.env.user and self.env.user.partner_id:
+            partner_channels = self.env['mail.channel.partner'].search([('partner_id', '=', self.env.user.partner_id.id), ('channel_id', 'in', self.ids)])
+        # for each channel, build the information header and include the logged partner information
+        for channel in self:
+            info = {
+                'id': channel.id,
+                'name': channel.name,
+                'uuid': channel.uuid,
+                'state': 'open',
+                'is_minimized': False,
+                'channel_type': channel.channel_type,
+                'public': channel.public,
+            }
+            # add the partner for 'direct mesage' channel
+            if channel.channel_type == 'chat':
+                info['direct_partner'] = channel.sudo().channel_partner_ids.filtered(lambda p: p.id != self.env.user.partner_id.id).read(['id', 'name', 'im_status'])
+            # add user session state, if available and if user is logged
+            if partner_channels.ids:
+                partner_channel = partner_channels.filtered(lambda c: channel.id == c.channel_id.id)
+                if len(partner_channel) >= 1:
+                    partner_channel = partner_channel[0]
+                    info['state'] = partner_channel.fold_state or 'open'
+                    info['is_minimized'] = partner_channel.is_minimized
+                    info['seen_message_id'] = partner_channel.seen_message_id.id
+                # add needaction and unread counter, since the user is logged
+                info['message_needaction_counter'] = channel.message_needaction_counter
+                info['message_unread_counter'] = channel.message_unread_counter
+            channel_infos.append(info)
+        return channel_infos
 
     @api.multi
-    def is_in_session(self):
-        """ Return True if the current user is in the user_ids of the session. False otherwise.
-            Note : the user need to be logged
+    def channel_fetch_message(self, last_id=False, limit=20):
+        """ Return message values of the current channel.
+            :param last_id : last message id to start the research
+            :param limit : maximum number of messages to fetch
+            :returns list of messages values
+            :rtype : list(dict)
         """
         self.ensure_one()
-        user_id = self._uid
-        return user_id and user_id in [u.id for u in self.user_ids]
+        domain = [("channel_ids", "in", self.ids)]
+        if last_id:
+            domain.append(("id", "<", last_id))
+        return self.env['mail.message'].message_fetch(domain=domain, limit=limit)
+
+    # User methods
+    @api.model
+    def channel_get(self, partners_to, pin=True):
+        """ Get the canonical private channel between some partners, create it if needed.
+            To reuse an old channel (conversation), this one must be private, and contains
+            only the given partners.
+            :param partners_to : list of res.partner ids to add to the conversation
+            :param pin : True if getting the channel should pin it for the current user
+            :returns a channel header, or False if the users_to was False
+            :rtype : dict
+        """
+        if partners_to:
+            partners_to.append(self.env.user.partner_id.id)
+            # determine type according to the number of partner in the channel
+            self.env.cr.execute("""
+                SELECT P.channel_id as channel_id
+                FROM mail_channel C, mail_channel_partner P
+                WHERE P.channel_id = C.id
+                    AND C.public LIKE 'private'
+                    AND P.partner_id IN %s
+                    AND channel_type LIKE 'chat'
+                GROUP BY P.channel_id
+                HAVING COUNT(P.partner_id) = %s
+            """, (tuple(partners_to), len(partners_to),))
+            result = self.env.cr.dictfetchall()
+            if result:
+                # get the existing channel between the given partners
+                channel = self.browse(result[0].get('channel_id'))
+                # pin up the channel for the current partner
+                if pin:
+                    self.env['mail.channel.partner'].search([('partner_id', '=', self.env.user.partner_id.id), ('channel_id', '=', channel.id)]).write({'is_pinned': True})
+            else:
+                # create a new one
+                channel = self.create({
+                    'channel_partner_ids': [(6, 0, partners_to)],
+                    'public': 'private',
+                    'channel_type': 'chat',
+                    'name': ', '.join(self.env['res.partner'].sudo().browse(partners_to).mapped('name')),
+                })
+                # broadcast the channel header to the other partner (not me)
+                channel._broadcast(partners_to)
+            return channel.channel_info()[0]
+        return False
 
     @api.model
-    def update_state(self, uuid, state=None):
+    def channel_fold(self, uuid, state=None):
         """ Update the fold_state of the given session. In order to syncronize web browser
             tabs, the change will be broadcast to himself (the current user channel).
-            Note : the user need to be logged
-            :param status : the new status of the session for the current user.
+            Note: the user need to be logged
+            :param state : the new status of the session for the current user.
         """
-        domain = [('user_id', '=', self._uid), ('session_id.uuid', '=', uuid)]
-        for session_state in self.env['im_chat.conversation_state'].search(domain):
+        domain = [('partner_id', '=', self.env.user.partner_id.id), ('channel_id.uuid', '=', uuid)]
+        for session_state in self.env['mail.channel.partner'].search(domain):
             if not state:
-                state = session_state.state
-                if session_state.state == 'open':
+                state = session_state.fold_state
+                if session_state.fold_state == 'open':
                     state = 'folded'
                 else:
                     state = 'open'
-            session_state.write({'state': state})
-            self.env['bus.bus'].sendone((self._cr.dbname, 'im_chat.session', self._uid), session_state.session_id.session_info())
+            session_state.write({
+                'fold_state': state,
+                'is_minimized': bool(state != 'closed'),
+                'seen_datetime': time.strftime(DEFAULT_SERVER_DATETIME_FORMAT),  # TODO JEM (to check) set seen_datetime to read needaction
+            })
+            self.env['bus.bus'].sendone((self._cr.dbname, 'res.partner', self.env.user.partner_id.id), session_state.channel_id.channel_info()[0])
 
+    @api.model
+    def channel_minimize(self, uuid, minimized=True):
+        values = {
+            'fold_state': minimized and 'open' or 'closed',
+            'is_minimized': minimized
+        }
+        domain = [('partner_id', '=', self.env.user.partner_id.id), ('channel_id.uuid', '=', uuid)]
+        channel_partners = self.env['mail.channel.partner'].search(domain)
+        channel_partners.write(values)
+        self.env['bus.bus'].sendone((self._cr.dbname, 'res.partner', self.env.user.partner_id.id), channel_partners.channel_id.channel_info()[0])
+
+    @api.model
+    def channel_pin(self, uuid, pinned=False):
+        # add the person in the channel, and pin it (or unpin it)
+        channel = self.search([('uuid', '=', uuid)])
+        channel_partners = self.env['mail.channel.partner'].search([('partner_id', '=', self.env.user.partner_id.id), ('channel_id', '=', channel.id)])
+        if channel_partners:
+            channel_partners.write({'is_pinned': pinned})
+
+    @api.multi
+    def channel_seen(self):
+        self.ensure_one()
+        if self.channel_message_ids.ids:
+            last_message_id = self.channel_message_ids.ids[0] # zero is the index of the last message
+            self.env['mail.channel.partner'].search([('channel_id', 'in', self.ids), ('partner_id', '=', self.env.user.partner_id.id)]).write({'seen_message_id': last_message_id})
+
+    @api.multi
+    def channel_invite(self, partner_ids):
+        """ Add the given partner_ids to the current channels and broadcast the channel header to them.
+            :param partner_ids : list of partner id to add
+        """
+        partners = self.env['res.partner'].browse(partner_ids)
+        # add the partner
+        for channel in self:
+            partners_to_add = partners - channel.channel_partner_ids
+            channel.write({'channel_partner_ids': [(4, partner_id) for partner_id in partners_to_add.ids]})
+        # broadcast the channel header to the added partner
+        self._broadcast(partner_ids)
+
+    #------------------------------------------------------
+    # Instant Messaging View Specific (Slack Client Action)
+    #------------------------------------------------------
     @api.model
     def get_init_notifications(self):
         """ Get unread messages and old messages received less than AWAY_TIMER
-            ago and the session_info for open or folded window
+            ago of minimized channel ONLY. This aims to set the minimized channel
+            when refreshing the page.
             Note : the user need to be logged
         """
+        # get current user's minimzed channel
+        minimized_channels = self.env['mail.channel.partner'].search([('is_minimized', '=', True), ('partner_id', '=', self.env.user.partner_id.id)]).mapped('channel_id')
+
         # get the message since the AWAY_TIMER
         threshold = datetime.datetime.now() - datetime.timedelta(seconds=AWAY_TIMER)
         threshold = threshold.strftime(DEFAULT_SERVER_DATETIME_FORMAT)
-        domain = [('to_id.user_ids', 'in', [self._uid]), ('create_date', '>', threshold)]
+        domain = [('channel_ids', 'in', minimized_channels.ids), ('create_date', '>', threshold)]
 
         # get the message since the last poll of the user
-        presence = self.env['im_chat.presence'].search([('user_id', '=', self._uid)], limit=1)
+        presence = self.env['bus.presence'].search([('user_id', '=', self._uid)], limit=1)
         if presence:
             domain.append(('create_date', '>', presence.last_poll))
-        messages = self.search_read(domain, ['from_id', 'to_id', 'create_date', 'type', 'message'], order='id asc')
 
-        # get the session of the messages and the not-closed ones
-        session_ids = [m['to_id'][0] for m in messages]
-        domain = [('user_id', '=', self._uid), '|', ('state', '!=', 'closed'), ('session_id', 'in', session_ids)]
-        session_states = self.env['im_chat.conversation_state'].search(domain)
-        # re-open the session where a message have been recieved recently
-        session_states.filtered(lambda r: r.state == 'closed').write({'state': 'folded'})
+        # do the message search
+        message_values = self.env['mail.message'].message_fetch(domain=domain)
 
-        # create the notifications (session infos first, then messages)
+        # create the notifications (channel infos first, then messages)
         notifications = []
-        for state in session_states:
-            session_infos = state.session_id.session_info()
-            notifications.append([(self._cr.dbname, 'im_chat.session', self._uid), session_infos])
-        for message in messages:
-            notifications.append([(self._cr.dbname, 'im_chat.session', self._uid), message])
+        for channel_info in minimized_channels.channel_info():
+            notifications.append([(self._cr.dbname, 'res.partner', self.env.user.partner_id.id), channel_info])
+        for message_value in message_values:
+            for channel_id in message_value['channel_ids']:
+                if channel_id in minimized_channels.ids:
+                    message_value['channel_ids'] = [channel_id]
+                    notifications.append([(self._cr.dbname, 'mail.channel', channel_id), dict(message_value)])
         return notifications
+
+    @api.model
+    def channel_fetch_slot(self):
+        """ Return the channels of the user grouped by 'slot' (channel, direct_message or private_group), and
+            the mapping between partner_id/channel_id for direct_message channels.
+            :returns dict : the grouped channels and the mapping
+        """
+        values = {}
+        my_partner_id = self.env.user.partner_id.id
+        pinned_channels = self.env['mail.channel.partner'].search([('partner_id', '=', my_partner_id), ('is_pinned', '=', True)]).mapped('channel_id')
+
+        # get the group/public channels
+        values['channel_channel'] = self.search([('channel_type', '=', 'channel'), ('public', 'in', ['public', 'groups']), ('channel_partner_ids', 'in', [my_partner_id])]).channel_info()
+
+        # get the pinned 'direct message' channel
+        direct_message_channels = self.search([('channel_type', '=', 'chat'), ('id', 'in', pinned_channels.ids)])
+        values['channel_direct_message'] = direct_message_channels.channel_info()
+
+        # get the partner of the pinned 'direct message' channels with mapping partner/channel
+        direct_channel_partner = direct_message_channels.mapped('channel_last_seen_partner_ids').filtered(lambda cp: cp.partner_id.id != my_partner_id)
+        values['mapping'] = dict((item.partner_id.id, item.channel_id.id) for item in direct_channel_partner)
+        # partners of the 'direct message' channels
+        values['partners'] = direct_message_channels.mapped('channel_partner_ids').filtered(lambda partner: partner.id != my_partner_id).read(['id', 'name', 'im_status'])
+
+        # get the private group
+        values['channel_private_group'] = self.search([('channel_type', '=', 'channel'), ('public', '=', 'private'), ('channel_partner_ids', 'in', [my_partner_id])]).channel_info()
+        return values
+
+    @api.model
+    def channel_search_to_join(self, name=None, domain=None):
+        """ Return the channel info of the channel the current partner can join
+            :param name : the name of the researched channels
+            :param domain : the base domain of the research
+            :returns dict : channel dict
+        """
+        if not domain:
+            domain = []
+        domain += [('channel_type', '=', 'channel'), ('channel_partner_ids', 'not in', [self.env.user.partner_id.id])]
+        if name:
+            domain.append(('name', 'ilike', '%'+name+'%'))
+        return self.search(domain).read(['name', 'public', 'uuid', 'channel_type'])
+
+    @api.multi
+    def channel_join_and_get_info(self):
+        self.ensure_one()
+        self.action_follow()
+        return self.channel_info()[0]
+
+    @api.model
+    def channel_create(self, name, privacy='public'):
+        """ Create a channel and add the current partner, broadcast it (to make the user directly
+            listen to it when polling)
+            :param name : the name of the channel to create
+            :param privacy : privacy of the channel. Should be 'public' or 'private'.
+            :return dict : channel header
+        """
+        # create the channel
+        new_channel = self.create({'name': name, 'public': privacy})
+        new_channel.action_follow()
+        return new_channel.channel_info()[0]

--- a/addons/mail/models/mail_message.py
+++ b/addons/mail/models/mail_message.py
@@ -248,12 +248,12 @@ class Message(models.Model):
                     tracking_value_ids.append(tracking_tree[tracking_value.id])
 
             message_dict.update({
-                'is_author': pid == author[0],
+                #'is_author': pid == author[0],
                 'author_id': author,
                 'partner_ids': partner_ids,
                 'attachment_ids': attachment_ids,
                 'tracking_value_ids': tracking_value_ids,
-                'user_pid': pid
+                #'user_pid': pid
                 })
 
         return True
@@ -281,7 +281,8 @@ class Message(models.Model):
                 'record_name': self.record_name,
                 'subject': self.subject,
                 'date': self.date,
-                'needaction': self.needaction,
+                #'needaction': self.needaction, JEM : not used.
+                'needaction_partner_ids': self.needaction_partner_ids.ids,
                 'parent_id': parent_id,
                 'is_private': is_private,
                 'author_id': False,
@@ -291,12 +292,13 @@ class Message(models.Model):
                 'is_favorite': self.starred,
                 'attachment_ids': [],
                 'tracking_value_ids': [],
+                'channel_ids': self.channel_ids.ids,
             }
 
     @api.cr_uid_context
     def message_read_wrapper(self, cr, uid, ids=None, domain=None, context=None,
                              thread_level=0, parent_id=False, limit=None, child_limit=None):
-        return self.message_read(cr, uid, ids, domain=domain, thread_level=thread_level, context=context, 
+        return self.message_read(cr, uid, ids, domain=domain, thread_level=thread_level, context=context,
                                  parent_id=parent_id, limit=limit, child_limit=child_limit)
 
     @api.multi
@@ -308,7 +310,7 @@ class Message(models.Model):
             well formed threads, if uid has access to them.
 
             After reading the messages, expandable messages are added in the
-            message list. It consists in messages holding the 'read more' data: 
+            message list. It consists in messages holding the 'read more' data:
             number of messages to read, domain to apply.
 
             :param list ids: optional IDs to fetch
@@ -320,7 +322,7 @@ class Message(models.Model):
             :param int limit: number of messages to fetch, before adding the
                 ancestors and expandables
             :param int child_limit: number of child messages to fetch
-            :return dict: 
+            :return dict:
                 - int: number of messages read (status 'unread' to 'read')
                 - list: list of threads [[messages_of_thread1], [messages_of_thread2]]
         """
@@ -397,7 +399,7 @@ class Message(models.Model):
                            'nb_messages': more_count,
                            'parent_id': parent}
 
-                    if parent and thread_level: 
+                    if parent and thread_level:
                         #insert expandable before parent message
                         parent_tree[parent].insert(len(parent_tree[parent])-1, exp)
                     else:
@@ -408,7 +410,7 @@ class Message(models.Model):
             parent_list = parent_tree.values()
             parent_list = sorted(parent_list, key=lambda item: max([msg.get('id') for msg in item]), reverse=True)
 
-            #add 'thread' expandable 
+            #add 'thread' expandable
             if thread_level:
                 exp_domain = domain + [('id', '<', min(self.ids)), ('id', 'not in', parent_ids), ('parent_id', 'not in', parent_ids)]
                 more_count = self.search_count(exp_domain)
@@ -419,15 +421,80 @@ class Message(models.Model):
                                         'parent_id': parent_id}])
 
             nb_read = 0
-            if context and 'mail_read_set_read' in context and context['mail_read_set_read']: 
+            if context and 'mail_read_set_read' in context and context['mail_read_set_read']:
                 nb_read = self.set_message_read(True, create_missing=False)
 
         else:
             nb_read = 0
-            parent_list = [] 
+            parent_list = []
 
         return {'nb_read': nb_read, 'threads': parent_list}
 
+
+    @api.model
+    def message_fetch(self, domain, limit=20):
+        return self.search(domain, limit=limit).message_format()
+
+    @api.multi
+    def message_format(self):
+        """ Get the message values in the format for web client. Since message values can be broadcasted,
+            computed fields MUST NOT BE READ and broadcasted.
+            :returns list(dict).
+             Example :
+                {
+                    'body': HTML content of the message
+                    'model': u'res.partner',
+                    'record_name': u'Agrolait',
+                    'attachment_ids': [
+                        {
+                            'file_type_icon': u'webimage',
+                            'id': 45,
+                            'name': u'sample.png',
+                            'filename': u'sample.png'
+                        }
+                    ],
+                    'needaction_partner_ids': [], # list of partner ids
+                    'res_id': 7,
+                    'tracking_value_ids': [
+                        {
+                            'old_value': "",
+                            'changed_field': "Customer",
+                            'id': 2965,
+                            'new_value': "Axelor"
+                        }
+                    ],
+                    'author_id': (3, u'Administrator'),
+                    'author_avatar': .... # base64 of the author avatar
+                    'email_from': 'sacha@pokemon.com' # email address or False
+                    'subtype_id': (1, u'Discussions'),
+                    'channel_ids': [], # list of channel ids
+                    'date': '2015-06-30 08:22:33',
+                    'partner_ids': [[7, "Sacha Du Bourg-Palette"]], # list of partner name_get
+                    'message_type': u'comment',
+                    'id': 59,
+                    'subject': False
+                    'is_note': True # only if the subtype is internal
+                }
+        """
+        message_values = self.read([
+            'id', 'body', 'date', 'author_id', 'author_avatar', 'email_from',  # base message fields
+            'message_type', 'subtype_id', 'subject',  # message specific
+            'model', 'res_id', 'record_name',  # document related
+            'channel_ids', 'partner_ids',  # recipients
+            'needaction_partner_ids',  # list of partner ids for whom the message is a needaction
+            'starred_partner_ids',  # list of partner ids for whom the message is starred
+        ])
+        message_tree = dict((m.id, m) for m in self)
+        self._message_read_dict_postprocess(message_values, message_tree)
+
+        # add is_note flag
+        internal_subtype_ids = self.env['mail.message.subtype'].search([('internal', '=', True)]).ids
+        for message in message_values:
+            if message['subtype_id'] and message['subtype_id'][0]:
+                message['is_note'] = bool(message['subtype_id'][0] in internal_subtype_ids)
+        return message_values
+
+
     #------------------------------------------------------
     # mail_message internals
     #------------------------------------------------------
@@ -750,7 +817,9 @@ class Message(models.Model):
         self_sudo = self.sudo()
 
         # TDE CHECK: add partners / channels as arguments to be able to notify a message with / without computation ??
-        self.ensure_one()  # tde: not sure, just for testing, will see
+        self.ensure_one()  # tde: not sure, just for testinh, will see
+        partners = self.env['res.partner'] | self.partner_ids
+        channels = self.env['mail.channel'] | self.channel_ids
 
         # all followers of the mail.message document have to be added as partners and notified
         # and filter to employees only if the subtype is internal

--- a/addons/mail/models/mail_shortcode.py
+++ b/addons/mail/models/mail_shortcode.py
@@ -5,44 +5,55 @@ import re
 from openerp import api, fields, models
 
 
-class ImChatShortcode(models.Model):
+class MailShortcode(models.Model):
     """ Shortcode
-        Canned Responses, allowing the user to defined shortcuts in its chat message.
-        These shortcode are globals and are available for every user. Smiley use this mecanism.
+        Canned Responses, allowing the user to defined shortcuts in its message. Should be applied before storing message in database.
+        Emoji allowing replacing text with image for visual effect. Should be applied when the message is displayed (only for final rendering).
+        These shortcodes are global and are available for every user.
     """
 
-    _name = 'im_chat.shortcode'
+    _name = 'mail.shortcode'
     _description = 'Canned Response / Shortcode'
 
     source = fields.Char('Shortcut', required=True, index=True, help="The shortcut which must be replace in the Chat Messages")
     substitution = fields.Char('Substitution', required=True, index=True, help="The excaped html code replacing the shortcut")
     description = fields.Char('Description')
+    shortcode_type = fields.Selection([('image', 'Smiley'), ('text', 'Canned Response')], required=True, default='text',
+        help="* Smiley are only used for HTML code to display an image "\
+             "* Text (default value) is use to substitute text with another text")
 
     @api.model
     def create(self, values):
         if values.get('substitution'):
             values['substitution'] = self._sanitize_shorcode(values['substitution'])
-        return super(ImChatShortcode, self).create(values)
+        return super(MailShortcode, self).create(values)
 
     @api.multi
     def write(self, values):
         if values.get('substitution'):
             values['substitution'] = self._sanitize_shorcode(values['substitution'])
-        return super(ImChatShortcode, self).write(values)
+        return super(MailShortcode, self).write(values)
 
     def _sanitize_shorcode(self, substitution):
         """ Sanitize the shortcode substitution :
-                 - HTML substitution : only allow the img tag (smiley)
-                 - escape other substitutions to avoid XSS
+                - HTML substitution : only allow the img tag (emoji)
+                - escape other substitutions to avoid XSS
         """
-        is_img_tag = re.match(r'''^<img\s+src=('|")([^'"]*)\1\s*/?>$''', substitution, re.M|re.I)
+        is_img_tag = re.match(r'''^<img\s+src=('|")([^'"]*)\1\s*/?>$''', substitution, re.M | re.I)
         if is_img_tag:
             return substitution
         return cgi.escape(substitution)
 
     @api.model
-    def replace_shortcode(self, message):
-        for shortcode in self.search([]):
+    def apply_shortcode(self, message, shortcode_type=None):
+        """ Apply the substitution on the given text
+            :param message : the text where the shortcode will be applied
+            :param shortcode_type : shortcode type that should be applied during the substitution
+        """
+        domain = []
+        if shortcode_type:
+            domain.append(('shortcode_type', '=', shortcode_type))
+        for shortcode in self.search(domain):
             regex = '(?:^|\s)(%s)(?:\s|$)' % re.escape(shortcode.source)
             message = re.sub(regex, " " + shortcode.substitution + " ", message)
         return message

--- a/addons/mail/models/mail_thread.py
+++ b/addons/mail/models/mail_thread.py
@@ -346,6 +346,9 @@ class MailThread(models.AbstractModel):
                         ('res_model', 'in', [False, self._name]),
                         ('internal', '=', True)], ['name', 'description', 'sequence'])
                     options['internal_subtypes'] = internal_subtypes
+                # emoji list
+                options['emoji_list'] = self.env['mail.shortcode'].search([('shortcode_type', '=', 'image')]).read(['source', 'description', 'substitution'])
+                # save options on the node
                 node.set('options', json.dumps(options))
             res['arch'] = etree.tostring(doc)
         return res
@@ -1855,9 +1858,9 @@ class MailThread(models.AbstractModel):
 
     @api.multi
     def message_set_read(self):
-        # Nothing done here currently. Will be implemented with the final
-        # slack modeling.
-        return True
+        messages = self.env['mail.message'].search([('model', '=', self._name), ('res_id', 'in', self.ids), ('needaction', '=', True)])
+        messages.write({'needaction_partner_ids': [(3, self.env.user.partner_id.id)]})
+        return messages.ids
 
     @api.multi
     def message_change_thread(self, new_thread):

--- a/addons/mail/models/res_partner.py
+++ b/addons/mail/models/res_partner.py
@@ -173,3 +173,12 @@ class Partner(models.Model):
             emails.send()
 
         return True
+
+    @api.model
+    def get_needaction_count(self):
+        """ compute the number of needaction of the current user """
+        self.env.cr.execute("""
+            SELECT count(*) as needaction_count
+            FROM mail_message_res_partner_needaction_rel R
+            WHERE R.res_partner_id = %s """, (self.env.user.partner_id.id,))
+        return self.env.cr.dictfetchall()[0].get('needaction_count')
