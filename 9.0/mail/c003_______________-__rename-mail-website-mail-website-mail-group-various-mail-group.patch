PR: https://github.com/odoo/odoo/pull/

From: 2c36354ca9c3939cc222e4fdad4adba6d3c0e315
From: Thibault Delavall√©e
Date: 2015-07-09 09:12:50

Structural Changes: 3
Total Changes: 62

[RENAME] mail, website_mail, website_mail_group, various: mail.group
model has been renamed to mail.channel to prepare the slack modeling.

In future commits the mail.group model will be merged with the channel
model from im_chat. The first move is to rename mail.group into
mail.channel to have a model that will unite both features.

================================= pseudo patch: =================================

--- a/addons/mail/models/ir_ui_menu.py
+++ b/addons/mail/models/ir_ui_menu.py
@@ -5,26 +5,26 @@ from openerp import api, fields, models
 
 class IrUiMenu(models.Model):
     """ Override of ir.ui.menu class. When adding mail_thread module, each
-        new mail.group will create a menu entry. This overrides checks that
-        the current user is in the mail.group followers. If not, the menu
+        new mail.channel will create a menu entry. This overrides checks that
+        the current user is in the mail.channel followers. If not, the menu
         entry is taken off the list of menu ids. This way the user will see
-        menu entries for the mail.group he is following.
+        menu entries for the mail.channel he is following.
     """
     _inherit = 'ir.ui.menu'
 
-    mail_group_id = fields.Many2one('mail.group', 'Mail Group')
+    mail_channel_id = fields.Many2one('mail.channel', 'Mail Group')
 
     def search(self, cr, uid, args, offset=0, limit=None, order=None, context=None, count=False):
-        """ Remove mail.group menu entries when the user is not a follower."""
+        """ Remove mail.channel menu entries when the user is not a follower."""
         ids = super(IrUiMenu, self).search(cr, uid, args, offset=offset,
                                            limit=limit, order=order,
                                            context=context, count=False)
         if ids:
             cr.execute("""
                 SELECT id FROM ir_ui_menu m
-                WHERE m.mail_group_id IS NULL OR EXISTS (
+                WHERE m.mail_channel_id IS NULL OR EXISTS (
                         SELECT 1 FROM mail_followers
-                        WHERE res_model = 'mail.group' AND res_id = m.mail_group_id
+                        WHERE res_model = 'mail.channel' AND res_id = m.mail_channel_id
                             AND partner_id = (SELECT partner_id FROM res_users WHERE id = %s)
                         ) AND id in %s
                 """, (uid, tuple(ids)))

--- a/addons/mail/models/mail_channel.py
+++ b/addons/mail/models/mail_channel.py
@@ -5,10 +5,10 @@ from openerp.exceptions import UserError
 
 
 class MailGroup(models.Model):
-    """ A mail_group is a collection of users sharing messages in a discussion
+    """ A mail.channel is a collection of users sharing messages in a discussion
         group. The group mechanics are based on the followers. """
     _description = 'Discussion group'
-    _name = 'mail.group'
+    _name = 'mail.channel'
     _mail_flat_thread = False
     _mail_post_access = 'read'
     _inherit = ['mail.thread']
@@ -30,8 +30,8 @@ class MailGroup(models.Model):
     group_public_id = fields.Many2one('res.groups', string='Authorized Group',
                                       default=lambda self: self.env.ref('base.group_user'))
     group_ids = fields.Many2many(
-        'res.groups', rel='mail_group_res_group_rel',
-        id1='mail_group_id', id2='groups_id', string='Auto Subscription',
+        'res.groups', rel='mail_channel_res_group_rel',
+        id1='mail_channel_id', id2='groups_id', string='Auto Subscription',
         help="Members of those groups will automatically added as followers. "
              "Note that they will be able to manage their subscription manually "
              "if necessary.")
@@ -79,8 +79,8 @@ class MailGroup(models.Model):
         # Create action window for this group and link the menu to it
         inbox_ref = self.env.ref('mail.action_mail_group_feeds')
         search_ref = self.env.ref('mail.view_message_search')
-        act_domain = [('model', '=', 'mail.group'), ('res_id', '=', group.id)]
-        act_context = {'default_model': 'mail.group',
+        act_domain = [('model', '=', 'mail.channel'), ('res_id', '=', group.id)]
+        act_context = {'default_model': 'mail.channel',
                        'default_res_id': group.id,
                        'options': {'view_mailbox': False,
                                    'view_inbox': True,
@@ -97,7 +97,7 @@ class MailGroup(models.Model):
                                                     'res_model': act_res_model,
                                                     'search_view_id': act_search_view_id,
                                                     'name': vals['name']})
-        menu.write({'action': 'ir.actions.act_window,%d' % new_action.id, 'mail_group_id': group.id})
+        menu.write({'action': 'ir.actions.act_window,%d' % new_action.id, 'mail_channel_id': group.id})
 
         if vals.get('group_ids'):
             group._subscribe_users()
@@ -108,15 +108,15 @@ class MailGroup(models.Model):
         aliases = self.mapped('alias_id')
         menus = self.mapped('menu_id')
 
-        # Delete mail_group
+        # Delete mail.channel
         try:
-            all_emp_group = self.env.ref('mail.group_all_employees')
+            all_emp_group = self.env.ref('mail.channel_all_employees')
         except ValueError:
             all_emp_group = None
         if all_emp_group and all_emp_group in self:
             raise UserError(_('You cannot delete those groups, as the Whole Company group is required by other modules.'))
         res = super(MailGroup, self).unlink()
-        # Cascade-delete mail aliases as well, as they should not exist without the mail group.
+        # Cascade-delete mail aliases as well, as they should not exist without the mail.channel.
         aliases.sudo().unlink()
         # Cascade-delete menu entries as well
         menus.sudo().unlink()
@@ -148,9 +148,9 @@ class MailGroup(models.Model):
     _generate_header_description = _get_header
 
     def _subscribe_users(self):
-        for mail_group in self:
-            partner_ids = mail_group.mapped('group_ids').mapped('users').mapped('partner_id')
-            mail_group.message_subscribe(partner_ids.ids)
+        for mail_channel in self:
+            partner_ids = mail_channel.mapped('group_ids').mapped('users').mapped('partner_id')
+            mail_channel.message_subscribe(partner_ids.ids)
 
     @api.multi
     def action_follow(self):

--- a/addons/mail/models/mail_followers.py
+++ b/addons/mail/models/mail_followers.py
@@ -159,9 +159,9 @@ class Notification(models.Model):
 
         # compute email body (signature, company data)
         body_html = message.body
-        # add user signature except for mail groups, where users are usually adding their own signatures already
+        # add user signature except for mail.channels, where users are usually adding their own signatures already
         user_id = message.author_id and message.author_id.user_ids and message.author_id.user_ids[0] and message.author_id.user_ids[0].id or None
-        signature_company = self.get_signature_footer(user_id, res_model=message.model, res_id=message.res_id, user_signature=(user_signature and message.model != 'mail.group'))
+        signature_company = self.get_signature_footer(user_id, res_model=message.model, res_id=message.res_id, user_signature=(user_signature and message.model != 'mail.channel'))
         if signature_company:
             body_html = tools.append_content_to_html(body_html, signature_company, plaintext=False, container_tag='div')
 

--- a/addons/mail/models/res_users.py
+++ b/addons/mail/models/res_users.py
@@ -123,9 +123,9 @@ class Users(models.Model):
         return dict((res_id, list()) for res_id in self._ids)
 
 
-class res_users_mail_group(models.Model):
+class res_users_mail_channel(models.Model):
     """ Update of res.users class
-        - if adding groups to an user, check mail.groups linked to this user
+        - if adding groups to an user, check mail.channels linked to this user
           group, and the user. This is done by overriding the write method.
     """
     _name = 'res.users'
@@ -133,18 +133,18 @@ class res_users_mail_group(models.Model):
 
     @api.multi
     def write(self, vals):
-        write_res = super(res_users_mail_group, self).write(vals)
+        write_res = super(res_users_mail_channel, self).write(vals)
         if vals.get('groups_id'):
             # form: {'group_ids': [(3, 10), (3, 3), (4, 10), (4, 3)]} or {'group_ids': [(6, 0, [ids]}
             user_group_ids = [command[1] for command in vals['groups_id'] if command[0] == 4]
             user_group_ids += [id for command in vals['groups_id'] if command[0] == 6 for id in command[2]]
-            self.env['mail.group'].search([('group_ids', 'in', user_group_ids)]).message_subscribe_users(self._ids)
+            self.env['mail.channel'].search([('group_ids', 'in', user_group_ids)]).message_subscribe_users(self._ids)
         return write_res
 
 
-class res_groups_mail_group(models.Model):
+class res_groups_mail_channel(models.Model):
     """ Update of res.groups class
-        - if adding users from a group, check mail.groups linked to this user
+        - if adding users from a group, check mail.channels linked to this user
           group and subscribe them. This is done by overriding the write method.
     """
     _name = 'res.groups'
@@ -152,10 +152,10 @@ class res_groups_mail_group(models.Model):
 
     @api.multi
     def write(self, vals, context=None):
-        write_res = super(res_groups_mail_group, self).write(vals)
+        write_res = super(res_groups_mail_channel, self).write(vals)
         if vals.get('users'):
             # form: {'group_ids': [(3, 10), (3, 3), (4, 10), (4, 3)]} or {'group_ids': [(6, 0, [ids]}
             user_ids = [command[1] for command in vals['users'] if command[0] == 4]
             user_ids += [id for command in vals['users'] if command[0] == 6 for id in command[2]]
-            self.env['mail.group'].search([('group_ids', 'in', self._ids)]).message_subscribe_users(user_ids)
+            self.env['mail.channel'].search([('group_ids', 'in', self._ids)]).message_subscribe_users(user_ids)
         return write_res

--- a/addons/mail/models/update.py
+++ b/addons/mail/models/update.py
@@ -93,7 +93,7 @@ class publisher_warranty_contract(AbstractModel):
             # old behavior based on res.log; now on mail.message, that is not necessarily installed
             IMD = self.pool['ir.model.data']
             user = self.pool['res.users'].browse(cr, SUPERUSER_ID, SUPERUSER_ID)
-            poster = IMD.xmlid_to_object(cr, SUPERUSER_ID, 'mail.group_all_employees', context=context)
+            poster = IMD.xmlid_to_object(cr, SUPERUSER_ID, 'mail.channel_all_employees', context=context)
             if not (poster and poster.exists()):
                 if not user.exists():
                     return True
