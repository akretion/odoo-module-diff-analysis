PR: https://github.com/odoo/odoo/pull/

From: 960360afe478a8f7b9c456721b5591154952a37d
From: Raphael Collet
Date: 2018-08-06 12:37:19

Structural Changes: 3
Total Changes: 54

[REF] *: use native date/datetime for Date/Datetime fields

From this commit onwards, Date fields will return datetime.date objects and Datetime fields will return datetime.datetime objects, this implies a number of things that are clearly explained both in the ORM API for master.

This commit also introduces a number of helper functions for dates and datetimes that are exposed in tools.date_utils and fields.Date[time], explained in the documentation as well.

Task-ID: 47189

================================= pseudo patch: =================================

--- a/addons/account/models/account_fiscal_year.py
+++ b/addons/account/models/account_fiscal_year.py
@@ -2,7 +2,6 @@
 
 from odoo.exceptions import ValidationError
 from odoo import api, fields, models, _
-from odoo.tools import DEFAULT_SERVER_DATE_FORMAT
 
 
 from datetime import datetime
@@ -37,8 +36,8 @@ class AccountFiscalYear(models.Model):
         '''
         for fy in self:
             # Starting date must be prior to the ending date
-            date_from = datetime.strptime(fy.date_from, DEFAULT_SERVER_DATE_FORMAT)
-            date_to = datetime.strptime(fy.date_to, DEFAULT_SERVER_DATE_FORMAT)
+            date_from = fy.date_from
+            date_to = fy.date_to
             if date_to < date_from:
                 raise ValidationError(_('The ending date must not be prior to the starting date.'))
 

--- a/addons/account/models/account_invoice.py
+++ b/addons/account/models/account_invoice.py
@@ -10,7 +10,8 @@ from dateutil.relativedelta import relativedelta
 from werkzeug.urls import url_encode
 
 from odoo import api, exceptions, fields, models, _
-from odoo.tools import email_re, email_split, email_escape_char, float_is_zero, float_compare, pycompat
+from odoo.tools import email_re, email_split, email_escape_char, float_is_zero, float_compare, \
+    pycompat, date_utils
 from odoo.tools.misc import formatLang
 
 from odoo.exceptions import AccessError, UserError, RedirectWarning, ValidationError, Warning
@@ -216,7 +217,7 @@ class AccountInvoice(models.Model):
         self.payments_widget = json.dumps(False)
         if self.payment_move_line_ids:
             info = {'title': _('Less Payment'), 'outstanding': False, 'content': self._get_payments_vals()}
-            self.payments_widget = json.dumps(info)
+            self.payments_widget = json.dumps(info, default=date_utils.json_default)
 
     @api.one
     @api.depends('move_id.line_ids.amount_residual')

--- a/addons/account/models/account_journal_dashboard.py
+++ b/addons/account/models/account_journal_dashboard.py
@@ -76,7 +76,7 @@ class account_journal(models.Model):
                         """
         self.env.cr.execute(query, (self.id, last_month, today))
         for val in self.env.cr.dictfetchall():
-            date = datetime.strptime(val['date'], DF)
+            date = val['date']
             if val['date'] != today.strftime(DF):  # make sure the last point in the graph is today
                 data[:0] = [build_graph_data(date, amount)]
             amount -= val['amount']
@@ -92,7 +92,7 @@ class account_journal(models.Model):
     @api.multi
     def get_bar_graph_datas(self):
         data = []
-        today = datetime.strptime(fields.Date.context_today(self), DF)
+        today = fields.Date.context_today(self)
         data.append({'label': _('Past'), 'value':0.0, 'type': 'past'})
         day_of_week = int(format_datetime(today, 'e', locale=self._context.get('lang') or 'en_US'))
         first_day_of_week = today + timedelta(days=-day_of_week+1)

--- a/addons/account/models/account_move.py
+++ b/addons/account/models/account_move.py
@@ -1,6 +1,7 @@
 # -*- coding: utf-8 -*-
 
 import time
+from datetime import date
 from collections import OrderedDict
 from odoo import api, fields, models, _
 from odoo.osv import expression
@@ -345,10 +346,10 @@ class AccountMove(models.Model):
     @api.multi
     def _check_lock_date(self):
         for move in self:
-            lock_date = max(move.company_id.period_lock_date or '0000-00-00', move.company_id.fiscalyear_lock_date or '0000-00-00')
+            lock_date = max(move.company_id.period_lock_date or date.min, move.company_id.fiscalyear_lock_date or date.min)
             if self.user_has_groups('account.group_account_manager'):
                 lock_date = move.company_id.fiscalyear_lock_date
-            if move.date <= (lock_date or '0000-00-00'):
+            if move.date <= (lock_date or date.min):
                 if self.user_has_groups('account.group_account_manager'):
                     message = _("You cannot add/modify entries prior to and inclusive of the lock date %s") % (lock_date)
                 else:
@@ -738,7 +739,7 @@ class AccountMoveLine(models.Model):
         total_debit = 0
         total_credit = 0
         total_amount_currency = 0
-        maxdate = '0000-00-00'
+        maxdate = date.min
         to_balance = {}
         for aml in amls:
             total_debit += aml.debit
@@ -947,7 +948,7 @@ class AccountMoveLine(models.Model):
             total = 0
             total_currency = 0
             writeoff_lines = []
-            date = time.strftime('%Y-%m-%d')
+            date = fields.Date.today()
             for vals in lines:
                 # Check and complete vals
                 if 'account_id' not in vals or 'journal_id' not in vals:
@@ -955,7 +956,7 @@ class AccountMoveLine(models.Model):
                 if ('debit' in vals) ^ ('credit' in vals):
                     raise UserError(_("Either pass both debit and credit or none."))
                 if 'date' not in vals:
-                    vals['date'] = self._context.get('date_p') or time.strftime('%Y-%m-%d')
+                    vals['date'] = self._context.get('date_p') or fields.Date.today()
                     if vals['date'] < date:
                         date = vals['date']
                 if 'name' not in vals:
@@ -1369,8 +1370,8 @@ class AccountPartialReconcile(models.Model):
     def _compute_max_date(self):
         for rec in self:
             rec.max_date = max(
-                fields.Datetime.from_string(rec.debit_move_id.date),
-                fields.Datetime.from_string(rec.credit_move_id.date)
+                rec.debit_move_id.date,
+                rec.credit_move_id.date
             )
 
     @api.model
@@ -1608,6 +1609,6 @@ class AccountFullReconcile(models.Model):
         # The move date should be the maximum date between payment and invoice
         # (in case of payment in advance). However, we should make sure the
         # move date is not recorded after the end of year closing.
-        if move_date > (company.fiscalyear_lock_date or '0000-00-00'):
+        if move_date > (company.fiscalyear_lock_date or date.min):
             res['date'] = move_date
         return res

--- a/addons/account/models/company.py
+++ b/addons/account/models/company.py
@@ -9,7 +9,7 @@ from odoo import fields, models, api, _
 from odoo.exceptions import ValidationError, UserError, RedirectWarning
 from odoo.tools.misc import DEFAULT_SERVER_DATE_FORMAT
 from odoo.tools.float_utils import float_round, float_is_zero
-from odoo.tools import DEFAULT_SERVER_DATE_FORMAT, date_utils
+from odoo.tools import date_utils
 
 
 class ResCompany(models.Model):
@@ -110,16 +110,15 @@ Best Regards,'''))
         :param vals: The values passed to the write method.
         '''
         period_lock_date = vals.get('period_lock_date') and\
-            time.strptime(vals['period_lock_date'], DEFAULT_SERVER_DATE_FORMAT)
+            fields.Date.from_string(vals['period_lock_date'])
         fiscalyear_lock_date = vals.get('fiscalyear_lock_date') and\
-            time.strptime(vals['fiscalyear_lock_date'], DEFAULT_SERVER_DATE_FORMAT)
+            fields.Date.from_string(vals['fiscalyear_lock_date'])
 
-        previous_month = datetime.strptime(fields.Date.today(), DEFAULT_SERVER_DATE_FORMAT) + relativedelta(months=-1)
+        previous_month = fields.Date.today() + relativedelta(months=-1)
         days_previous_month = calendar.monthrange(previous_month.year, previous_month.month)
-        previous_month = previous_month.replace(day=days_previous_month[1]).timetuple()
+        previous_month = previous_month.replace(day=days_previous_month[1])
         for company in self:
-            old_fiscalyear_lock_date = company.fiscalyear_lock_date and\
-                time.strptime(company.fiscalyear_lock_date, DEFAULT_SERVER_DATE_FORMAT)
+            old_fiscalyear_lock_date = company.fiscalyear_lock_date
 
             # The user attempts to remove the lock date for advisors
             if old_fiscalyear_lock_date and not fiscalyear_lock_date and 'fiscalyear_lock_date' in vals:
@@ -143,7 +142,7 @@ Best Regards,'''))
             # In case of no new period lock date in vals, fallback to the one defined in the company
             if not period_lock_date:
                 if company.period_lock_date:
-                    period_lock_date = time.strptime(company.period_lock_date, DEFAULT_SERVER_DATE_FORMAT)
+                    period_lock_date = company.period_lock_date
                 else:
                     continue
 
@@ -182,8 +181,8 @@ Best Regards,'''))
         ], limit=1)
         if fiscalyear:
             return {
-                'date_from': datetime.strptime(fiscalyear.date_from, DEFAULT_SERVER_DATE_FORMAT).date(),
-                'date_to': datetime.strptime(fiscalyear.date_to, DEFAULT_SERVER_DATE_FORMAT).date(),
+                'date_from': fiscalyear.date_from,
+                'date_to': fiscalyear.date_to,
                 'record': fiscalyear,
             }
 
@@ -204,7 +203,7 @@ Best Regards,'''))
             ('date_to', '>=', date_from_str),
         ], limit=1)
         if fiscalyear_from:
-            date_from = datetime.strptime(fiscalyear_from.date_to, DEFAULT_SERVER_DATE_FORMAT).date() + timedelta(days=1)
+            date_from = fiscalyear_from.date_to + timedelta(days=1)
 
         fiscalyear_to = self.env['account.fiscal.year'].search([
             ('company_id', '=', self.id),
@@ -212,7 +211,7 @@ Best Regards,'''))
             ('date_to', '>=', date_to_str),
         ], limit=1)
         if fiscalyear_to:
-            date_to = datetime.strptime(fiscalyear_to.date_from, DEFAULT_SERVER_DATE_FORMAT).date() - timedelta(days=1)
+            date_to = fiscalyear_to.date_from - timedelta(days=1)
 
         return {'date_from': date_from, 'date_to': date_to}
 
