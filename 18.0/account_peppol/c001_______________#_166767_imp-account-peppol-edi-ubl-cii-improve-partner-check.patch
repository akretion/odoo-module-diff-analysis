PR: https://github.com/odoo/odoo/pull/166767

From: 22705716c4f6bcddb3483b662fd6a6cfaa7c7c4e
From: aliya
Date: 2024-05-27 13:17:14

Structural Changes: 2
Total Changes: 150

[IMP] account_{peppol,edi_ubl_cii}: improve partner check

- When a user wants to register on Odoo SMP but they are registered somewhere else,
we throw an error that asks them to deregister from another service.
Sometimes users might not know where they are registered,
so it would be helpful to pass that information about their current registration in the error message as well
- Currently, we check whether a partner is a valid by calling their SMP url.
But it is possible that a participant exists on Peppol network
but cannot receive that specific format that a user has selected for them.
A valid participant is one that both exists and can receive the document.

task-3870271

closes odoo/odoo#166767

X-original-commit: e62a86939b0b327e2c16a82b0829dac80ef1ff32
Signed-off-by: Laurent Smet (las) <las@odoo.com>
Signed-off-by: Aliya Tastemirova (alta) <alta@odoo.com>

================================= pseudo patch: =================================

--- a/addons/account_peppol/models/account_move.py
+++ b/addons/account_peppol/models/account_move.py
@@ -56,7 +56,7 @@ class AccountMove(models.Model):
         for move in self:
             if all([
                 move.company_id.account_peppol_proxy_state == 'active',
-                move.partner_id.account_peppol_is_endpoint_valid,
+                move.commercial_partner_id.account_peppol_is_endpoint_valid,
                 move.state == 'posted',
                 move.move_type in ('out_invoice', 'out_refund', 'out_receipt'),
                 not move.peppol_move_state,

--- a/addons/account_peppol/models/res_config_settings.py
+++ b/addons/account_peppol/models/res_config_settings.py
@@ -155,11 +155,20 @@ class ResConfigSettings(models.TransientModel):
         company = self.company_id
         edi_proxy_client = self.env['account_edi_proxy_client.user']
         edi_identification = edi_proxy_client._get_proxy_identification(company, 'peppol')
-        if company.partner_id._check_peppol_participant_exists(edi_identification) and not self.account_peppol_migration_key:
-            raise UserError(
-                _("A participant with these details has already been registered on the network. "
-                  "If you have previously registered to an alternative Peppol service, please deregister from that service, "
-                  "or request a migration key before trying again."))
+
+        if (
+            not self.account_peppol_migration_key
+            and (participant_info := company.partner_id._check_peppol_participant_exists(edi_identification, check_company=True))
+        ):
+            error_msg = _(
+                "A participant with these details has already been registered on the network. "
+                "If you have previously registered to an alternative Peppol service, please deregister from that service, "
+                "or request a migration key before trying again. "
+            )
+
+            if isinstance(participant_info, str):
+                error_msg += _("The Peppol service that is used is likely to be %s.", participant_info)
+            raise UserError(error_msg)
 
         edi_user = edi_proxy_client.sudo()._register_proxy_user(company, 'peppol', self.account_peppol_edi_mode)
         self.account_peppol_proxy_state = 'not_verified'

--- a/addons/account_peppol/models/res_partner.py
+++ b/addons/account_peppol/models/res_partner.py
@@ -1,6 +1,7 @@
 # -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
+import contextlib
 import requests
 from lxml import etree
 from hashlib import md5
@@ -29,54 +30,138 @@ class ResPartner(models.Model):
     account_peppol_verification_label = fields.Selection(
         selection=[
             ('not_verified', 'Not verified yet'),
-            ('not_valid', 'Not valid'),
+            ('not_valid', 'Not valid'),  # does not exist on Peppol at all
+            ('not_valid_format', 'Cannot receive this format'),  # registered on Peppol but cannot receive the selected document type
             ('valid', 'Valid'),
         ],
         string='Peppol endpoint validity',
         compute='_compute_account_peppol_verification_label',
         copy=False,
-    ) # field to compute the label to show for partner endpoint
+    )  # field to compute the label to show for partner endpoint
+    is_peppol_edi_format = fields.Boolean(compute='_compute_is_peppol_edi_format')
 
-    @api.depends('peppol_eas', 'peppol_endpoint', 'ubl_cii_format')
-    def _compute_account_peppol_is_endpoint_valid(self):
-        for partner in self:
-            partner.button_account_peppol_check_partner_endpoint()
+    @api.model
+    def fields_get(self, allfields=None, attributes=None):
+        # TODO: remove in master
+        res = super().fields_get(allfields, attributes)
 
-    @api.depends('account_peppol_is_endpoint_valid', 'account_peppol_validity_last_check')
-    def _compute_account_peppol_verification_label(self):
-        for partner in self:
-            if not partner.account_peppol_validity_last_check:
-                partner.account_peppol_verification_label = 'not_verified'
-            elif partner.account_peppol_is_endpoint_valid:
-                partner.account_peppol_verification_label = 'valid'
-            else:
-                partner.account_peppol_verification_label = 'not_valid'
+        # the orm_cache does not contain the new selections added in stable: clear the cache once
+        existing_selection = res.get('account_peppol_verification_label', {}).get('selection')
+        if existing_selection is None:
+            return res
+
+        not_valid_format_label = next(x for x in self._fields['account_peppol_verification_label'].selection if x[0] == 'not_valid_format')
+        need_update = not_valid_format_label not in existing_selection
+
+        if need_update:
+            self.env['ir.model.fields'].invalidate_model(['selection_ids'])
+            self.env['ir.model.fields.selection']._update_selection(
+                'res.partner',
+                'account_peppol_verification_label',
+                self._fields['account_peppol_verification_label'].selection,
+            )
+            self.env.registry.clear_cache()
+            return super().fields_get(allfields, attributes)
+        return res
+
+    # -------------------------------------------------------------------------
+    # HELPER METHODS
+    # -------------------------------------------------------------------------
 
     @api.model
-    def _check_peppol_participant_exists(self, edi_identification):
+    def _get_participant_info(self, edi_identification):
         hash_participant = md5(edi_identification.lower().encode()).hexdigest()
         endpoint_participant = parse.quote_plus(f"iso6523-actorid-upis::{edi_identification}")
         peppol_user = self.env.company.account_edi_proxy_client_ids.filtered(lambda user: user.proxy_type == 'peppol')
-        sml_zone = 'acc.edelivery' if peppol_user.edi_mode == 'test' else 'edelivery'
+        edi_mode = peppol_user and peppol_user.edi_mode or self.env['ir.config_parameter'].sudo().get_param('account_peppol.edi.mode')
+        sml_zone = 'acc.edelivery' if edi_mode == 'test' else 'edelivery'
         smp_url = f"http://B-{hash_participant}.iso6523-actorid-upis.{sml_zone}.tech.ec.europa.eu/{endpoint_participant}"
 
         try:
             response = requests.get(smp_url, timeout=TIMEOUT)
         except requests.exceptions.ConnectionError:
-            return False
+            return None
         if response.status_code != 200:
+            return None
+        return etree.fromstring(response.content)
+
+    @api.model
+    def _check_peppol_participant_exists(self, edi_identification, check_company=False, ubl_cii_format=False):
+        participant_info = self._get_participant_info(edi_identification)
+        if participant_info is None:
             return False
-        participant_info = etree.XML(response.content)
+
         participant_identifier = participant_info.findtext('{*}ParticipantIdentifier')
         service_metadata = participant_info.find('.//{*}ServiceMetadataReference')
         service_href = ''
         if service_metadata is not None:
             service_href = service_metadata.attrib.get('href', '')
+
         if edi_identification != participant_identifier or 'hermes-belgium' in service_href:
             # all Belgian companies are pre-registered on hermes-belgium, so they will
             # technically have an existing SMP url but they are not real Peppol participants
             return False
-        return True
+
+        if check_company:
+            # if we are only checking company's existence on the network, we don't care about what documents they can receive
+            if not service_href:
+                return True
+
+            access_point_contact = True
+            with contextlib.suppress(requests.exceptions.RequestException, etree.XMLSyntaxError):
+                response = requests.get(service_href, timeout=TIMEOUT)
+                if response.status_code == 200:
+                    access_point_info = etree.fromstring(response.content)
+                    access_point_contact = access_point_info.findtext('.//{*}TechnicalContactUrl') or access_point_info.findtext('.//{*}TechnicalInformationUrl')
+            return access_point_contact
+
+        return self._check_document_type_support(participant_info, ubl_cii_format)
+
+    def _check_document_type_support(self, participant_info, ubl_cii_format):
+        service_metadata = participant_info.find('.//{*}ServiceMetadataReferenceCollection')
+        if service_metadata is None:
+            return False
+
+        document_type = self.env['account.edi.xml.ubl_21']._get_customization_ids()[ubl_cii_format]
+        for service in service_metadata.iterfind('{*}ServiceMetadataReference'):
+            if document_type in parse.unquote_plus(service.attrib.get('href', '')):
+                return True
+        return False
+
+    # -------------------------------------------------------------------------
+    # COMPUTE METHODS
+    # -------------------------------------------------------------------------
+
+    @api.depends('ubl_cii_format')
+    def _compute_is_peppol_edi_format(self):
+        for partner in self:
+            partner.is_peppol_edi_format = partner.ubl_cii_format not in (False, 'facturx', 'oioubl_201', 'ciusro')
+
+    @api.depends('peppol_eas', 'peppol_endpoint', 'ubl_cii_format')
+    def _compute_account_peppol_is_endpoint_valid(self):
+        for partner in self:
+            partner.button_account_peppol_check_partner_endpoint()
+
+    @api.depends('account_peppol_is_endpoint_valid', 'account_peppol_validity_last_check')
+    def _compute_account_peppol_verification_label(self):
+        for partner in self:
+            if not partner.account_peppol_validity_last_check:
+                partner.account_peppol_verification_label = 'not_verified'
+            elif (
+                partner.is_peppol_edi_format
+                and (participant_info := self._get_participant_info(f'{partner.peppol_eas}:{partner.peppol_endpoint}'.lower())) is not None
+                and not partner._check_document_type_support(participant_info, partner.ubl_cii_format)
+            ):
+                # the partner might exist on the network, but not be able to receive that specific format
+                partner.account_peppol_verification_label = 'not_valid_format'
+            elif partner.account_peppol_is_endpoint_valid:
+                partner.account_peppol_verification_label = 'valid'
+            else:
+                partner.account_peppol_verification_label = 'not_valid'
+
+    # -------------------------------------------------------------------------
+    # BUSINESS ACTIONS
+    # -------------------------------------------------------------------------
 
     @handle_demo
     def button_account_peppol_check_partner_endpoint(self):
@@ -90,10 +175,10 @@ class ResPartner(models.Model):
         """
         self.ensure_one()
 
-        if not (self.peppol_eas and self.peppol_endpoint) or self.ubl_cii_format in (False, 'facturx', 'oioubl_201'):
+        if not (self.peppol_eas and self.peppol_endpoint) or not self.is_peppol_edi_format:
             self.account_peppol_is_endpoint_valid = False
         else:
             edi_identification = f'{self.peppol_eas}:{self.peppol_endpoint}'.lower()
             self.account_peppol_validity_last_check = fields.Date.context_today(self)
-            self.account_peppol_is_endpoint_valid = self._check_peppol_participant_exists(edi_identification)
+            self.account_peppol_is_endpoint_valid = bool(self._check_peppol_participant_exists(edi_identification, ubl_cii_format=self.ubl_cii_format))
         return False
