PR: https://github.com/odoo/odoo/pull/

From: 48672703aa92336cb8fcee4984037e364ae7e657
From: Tiffany Chang (tic)
Date: 2020-06-15 14:59:41

Structural Changes: 4
Total Changes: 53

[REF] mrp: update MO lock/unlock settings

This commit updates 4 features related to a MO being locked/unlocked.

1. Manufacturing orders are by default unlocked. A new configuration
setting has been added so users can set the default to be locked.
This setting only applies to new manufacturing orders after the setting
has been changed.

2. A MO now shows the same button options regardless if it is
locked/unlocked ('scrap', 'cancel', 'unreserve')

3. Workers can always change "Consumed Quantities"/"Produced" when
clicking on a component/finished product line unless state=Done and MO
is_locked. This includes adding new components/finished products.

4. Workers can now change "To Consume" quantity when clicking on a
component line, unlocked, and not in states 'Done' or 'Cancel'.

This is part of specification 6-Lock/Unlock of overall Editing in MO
form and backorders task.

Task: 2241471

================================= pseudo patch: =================================

--- a/addons/mrp/models/mrp_production.py
+++ b/addons/mrp/models/mrp_production.py
@@ -59,6 +59,10 @@ class MrpProduction(models.Model):
             return fields.Datetime.to_datetime(self.env.context.get('default_date_planned_start')) + datetime.timedelta(hours=1)
         return datetime.datetime.now() + datetime.timedelta(hours=1)
 
+    @api.model
+    def _get_default_is_locked(self):
+        return self.user_has_groups('mrp.group_locked_by_default')
+
     name = fields.Char(
         'Reference', copy=False, readonly=True, default=lambda x: _('New'))
     backorder_sequence = fields.Integer("Backorder Sequence", default=0, help="Backorder sequence, if equals to 0 means there is not related backorder")
@@ -223,7 +227,7 @@ class MrpProduction(models.Model):
     scrap_count = fields.Integer(compute='_compute_scrap_move_count', string='Scrap Move')
     priority = fields.Selection([('0', 'Not urgent'), ('1', 'Normal'), ('2', 'Urgent'), ('3', 'Very Urgent')], 'Priority',
                                 readonly=True, states={'draft': [('readonly', False)]}, default='1')
-    is_locked = fields.Boolean('Is Locked', default=True, copy=False)
+    is_locked = fields.Boolean('Is Locked', default=_get_default_is_locked, copy=False)
     is_planned = fields.Boolean('Its Operations are Planned', compute="_compute_is_planned")
     show_final_lots = fields.Boolean('Show Final Lots', compute='_compute_show_lots')
     production_location_id = fields.Many2one('stock.location', "Production Location", compute="_compute_production_location", store=True)
@@ -242,6 +246,7 @@ class MrpProduction(models.Model):
     mrp_production_child_count = fields.Integer("Number of generated MO", compute='_compute_mrp_production_child_count')
     mrp_production_source_count = fields.Integer("Number of source MO", compute='_compute_mrp_production_source_count')
     mrp_production_backorder_count = fields.Integer("Count of linked backorder", compute='_compute_mrp_production_backorder')
+    show_lock = fields.Boolean('Show Lock/unlock buttons', compute='_compute_show_lock')
 
     @api.depends('product_id', 'bom_id', 'company_id')
     def _compute_allowed_product_ids(self):
@@ -277,8 +282,9 @@ class MrpProduction(models.Model):
     @api.depends('move_raw_ids.date_expected', 'move_finished_ids.date_expected')
     def _compute_dates_planned(self):
         for production in self:
-            production.date_planned_start = max(production.mapped('move_raw_ids.date_expected') or [fields.Datetime.now()])
-            production.date_planned_finished = max(production.mapped('move_finished_ids.date_expected') or [production.date_deadline or fields.Datetime.now()])
+            if production.state != 'done':
+                production.date_planned_start = max(production.mapped('move_raw_ids.date_expected') or [fields.Datetime.now()])
+                production.date_planned_finished = max(production.mapped('move_finished_ids.date_expected') or [production.date_deadline or fields.Datetime.now()])
 
     def _set_date_planned_start(self):
         self.move_raw_ids.write({'date_expected': self.date_planned_start})
@@ -465,16 +471,16 @@ class MrpProduction(models.Model):
                 elif relevant_move_state != 'draft':
                     production.reservation_state = relevant_move_state
 
-    @api.depends('move_raw_ids', 'is_locked', 'state', 'move_raw_ids.quantity_done')
+    @api.depends('move_raw_ids', 'state', 'move_raw_ids.product_uom_qty')
     def _compute_unreserve_visible(self):
         for order in self:
-            already_reserved = order.is_locked and order.state not in ('done', 'cancel') and order.mapped('move_raw_ids.move_line_ids')
+            already_reserved = order.state not in ('done', 'cancel') and order.mapped('move_raw_ids.move_line_ids')
             any_quantity_done = any([m.quantity_done > 0 for m in order.move_raw_ids])
 
             order.unreserve_visible = not any_quantity_done and already_reserved
-            order.reserve_visible = order.state in ('confirmed', 'progress', 'to_close') and any(move.state in ['confirmed', 'partially_available'] for move in order.move_raw_ids.filtered(lambda m: m.product_uom_qty))
+            order.reserve_visible = (order.is_planned or order.state in ('confirmed', 'progress', 'to_close')) and any(move.state in ['confirmed', 'partially_available'] for move in order.move_raw_ids.filtered(lambda m: m.product_uom_qty))
 
-    @api.depends('workorder_ids.state', 'move_finished_ids', 'move_finished_ids.quantity_done', 'is_locked')
+    @api.depends('workorder_ids.state', 'move_finished_ids', 'move_finished_ids.quantity_done')
     def _get_produced_qty(self):
         for production in self:
             done_moves = production.move_finished_ids.filtered(lambda x: x.state != 'cancel' and x.product_id.id == production.product_id.id)
@@ -496,6 +502,11 @@ class MrpProduction(models.Model):
     def _set_move_byproduct_ids(self):
         self.move_finished_ids |= self.move_byproduct_ids
 
+    @api.depends('state')
+    def _compute_show_lock(self):
+        for order in self:
+            order.show_lock = self.env.user.has_group('mrp.group_locked_by_default') and order.id is not False and order.state not in {'cancel', 'draft'}
+
     _sql_constraints = [
         ('name_uniq', 'unique(name, company_id)', 'Reference must be unique per Company!'),
         ('qty_positive', 'check (product_qty > 0)', 'The quantity to produce must be positive!'),
@@ -628,10 +639,29 @@ class MrpProduction(models.Model):
             if 'date_planned_start' in vals:
                 if production.state in ['done', 'cancel']:
                     raise UserError(_('You cannot move a manufacturing order once it is cancelled or done.'))
-                if production.state not in ('draft', 'confirmed') and production.workorder_ids and not self.env.context.get('force_date', False):
-                    raise UserError(_('You cannot move a planned manufacturing order.'))
+                if production.state == 'done' and not self.env.context.get('force_date', False):
+                    raise UserError(_('You cannot move a done manufacturing order.'))
             if ('move_raw_ids' in vals or 'move_finished_ids' in vals) and production.state != 'draft':
+                if production.state == 'done':
+                    # for some reason moves added after state = 'done' won't save group_id, reference if added in
+                    # "stock_move.default_get()"
+                    production.move_raw_ids.filtered(lambda move: move.additional and move.date_expected > production.date_planned_start).write({
+                        'group_id': production.procurement_group_id.id,
+                        'reference': production.name,
+                        'date_expected': production.date_planned_start,
+                    })
+                    production.move_finished_ids.filtered(lambda move: move.additional and move.date_expected > production.date_planned_finished).write({
+                        'reference': production.name,
+                        'date_expected': production.date_planned_finished,
+                    })
                 production._autoconfirm_production()
+            if production.state == 'done' and ('lot_producing_id' in vals or 'qty_producing' in vals):
+                finished_move_lines = production.move_finished_ids.filtered(
+                    lambda move: move.product_id == self.product_id and move.state == 'done').mapped('move_line_ids')
+                if 'lot_producing_id' in vals:
+                    finished_move_lines.write({'lot_id': vals.get('lot_producing_id')})
+                if 'qty_producing' in vals:
+                    finished_move_lines.write({'qty_done': vals.get('qty_producing')})
             if not production.bom_id.operation_ids and vals.get('date_planned_start') and not vals.get('date_planned_finished'):
                 new_date_planned_start = fields.Datetime.to_datetime(vals.get('date_planned_start'))
                 if not production.date_planned_finished or new_date_planned_start >= production.date_planned_finished:

--- a/addons/mrp/models/res_config_settings.py
+++ b/addons/mrp/models/res_config_settings.py
@@ -18,6 +18,7 @@ class ResConfigSettings(models.TransientModel):
     module_mrp_subcontracting = fields.Boolean("Subcontracting")
     group_mrp_routings = fields.Boolean("MRP Work Orders",
         implied_group='mrp.group_mrp_routings')
+    group_locked_by_default = fields.Boolean("Lock Quantities To Consume", implied_group='mrp.group_locked_by_default')
 
     @api.onchange('use_manufacturing_lead')
     def _onchange_use_manufacturing_lead(self):

--- a/addons/mrp/models/stock_move.py
+++ b/addons/mrp/models/stock_move.py
@@ -139,12 +139,14 @@ class StockMove(models.Model):
         for move in self:
             move.needs_lots = move.product_id.tracking != 'none'
 
-    @api.depends('raw_material_production_id.is_locked', 'picking_id.is_locked')
+    @api.depends('raw_material_production_id.is_locked', 'production_id.is_locked')
     def _compute_is_locked(self):
         super(StockMove, self)._compute_is_locked()
         for move in self:
             if move.raw_material_production_id:
                 move.is_locked = move.raw_material_production_id.is_locked
+            if move.production_id:
+                move.is_locked = move.production_id.is_locked
 
     @api.depends('state')
     def _compute_is_done(self):
