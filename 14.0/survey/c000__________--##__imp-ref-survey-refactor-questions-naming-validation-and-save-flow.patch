PR: https://github.com/odoo/odoo/pull/

From: 3bb4ac8dc6ec1271c789bb36253cb880e596806a
From: David Beguin
Date: 2019-11-19 12:52:22

Structural Changes: 4
Total Changes: 501

[IMP-REF] survey : refactor questions naming, validation and save flow

This commit simplifies the answer_tag and question name
by removing the survey_id (uses now only question id) for the most simple cases

Factorise the save and validate survey answers to avoid duplicate code

Review posted submit data :
- process all questions by question type (instead of using form data
(key,value) that needed key parsing and was un-typed)
- regroup answers by questions and adapt all validation and save flow
- remove post data in save and validate question methods
  and uses directly the answer(s)
- remove useless input names

The tests have been adapted consequently

Task ID : 1930132
PR #32419

================================= pseudo patch: =================================

--- a/addons/survey/models/survey_question.py
+++ b/addons/survey/models/survey_question.py
@@ -152,173 +152,102 @@ class SurveyQuestion(models.Model):
             self.question_type = False
 
     # Validation methods
-
-    def validate_question(self, post, answer_tag):
-        """ Validate question, depending on question type and parameters """
-        self.ensure_one()
-        try:
-            checker = getattr(self, 'validate_' + self.question_type)
-        except AttributeError:
-            _logger.warning(self.question_type + ": This type of question has no validation method")
-            return {}
-        else:
-            return checker(post, answer_tag)
-
-    def validate_free_text(self, post, answer_tag):
-        self.ensure_one()
-        errors = {}
-        answer = post[answer_tag].strip()
-        # Empty answer to mandatory question
-        if self.constr_mandatory and not answer:
-            errors.update({answer_tag: self.constr_error_msg})
-        return errors
-
-    def validate_textbox(self, post, answer_tag):
+    def validate_question(self, answer, comment=None):
+        """ Validate question, depending on question type and parameters
+         for simple choice, text, date and number, answer is simply the answer of the question.
+         For other multiple choices questions, answer is a list of answers (the selected choices
+         or a list of selected answers per question -for matrix type-):
+            - Simple answer : answer = 'example' or 2 or question_answer_id or 2019/10/10
+            - Multiple choice : answer = [question_answer_id1, question_answer_id2, question_answer_id3]
+            - Matrix: answer = { 'rowId1' : [colId1, colId2,...], 'rowId2' : [colId1, colId3, ...] }
+
+         return dict {question.id (int): error (str)} -> empty dict if no validation error.
+         """
         self.ensure_one()
-        errors = {}
-        answer = post[answer_tag].strip()
+        if isinstance(answer, str):
+            answer = answer.strip()
         # Empty answer to mandatory question
-        if self.constr_mandatory and not answer:
-            errors.update({answer_tag: self.constr_error_msg})
+        if self.constr_mandatory and not answer and self.question_type not in ['simple_choice', 'multiple_choice']:
+            return {self.id: self.constr_error_msg}
+
+        # because in choices question types, comment can count as answer
+        if answer or self.question_type in ['simple_choice', 'multiple_choice']:
+            if self.question_type == 'textbox':
+                return self._validate_textbox(answer)
+            elif self.question_type == 'numerical_box':
+                return self._validate_numerical_box(answer)
+            elif self.question_type in ['date', 'datetime']:
+                return self._validate_date(answer)
+            elif self.question_type in ['simple_choice', 'multiple_choice']:
+                return self._validate_choice(answer, comment)
+            elif self.question_type == 'matrix':
+                return self._validate_matrix(answer)
+        return {}
+
+    def _validate_textbox(self, answer):
         # Email format validation
-        # Note: this validation is very basic:
-        #     all the strings of the form
-        #     <something>@<anything>.<extension>
-        #     will be accepted
-        if answer and self.validation_email:
+        # all the strings of the form "<something>@<anything>.<extension>" will be accepted
+        if self.validation_email:
             if not email_validator.match(answer):
-                errors.update({answer_tag: _('This answer must be an email address')})
+                return {self.id: _('This answer must be an email address')}
+
         # Answer validation (if properly defined)
         # Length of the answer must be in a range
-        if answer and self.validation_required:
+        if self.validation_required:
             if not (self.validation_length_min <= len(answer) <= self.validation_length_max):
-                errors.update({answer_tag: self.validation_error_msg})
-        return errors
+                return {self.id: self.validation_error_msg}
+        return {}
 
-    def validate_numerical_box(self, post, answer_tag):
-        self.ensure_one()
-        errors = {}
-        answer = post[answer_tag].strip()
-        # Empty answer to mandatory question
-        if self.constr_mandatory and not answer:
-            errors.update({answer_tag: self.constr_error_msg})
-        # Checks if user input is a number
-        if answer:
-            try:
-                floatanswer = float(answer)
-            except ValueError:
-                errors.update({answer_tag: _('This is not a number')})
-        # Answer validation (if properly defined)
-        if answer and self.validation_required:
+    def _validate_numerical_box(self, answer):
+        try:
+            floatanswer = float(answer)
+        except ValueError:
+            return {self.id: _('This is not a number')}
+
+        if self.validation_required:
             # Answer is not in the right range
             with tools.ignore(Exception):
-                floatanswer = float(answer)  # check that it is a float has been done hereunder
                 if not (self.validation_min_float_value <= floatanswer <= self.validation_max_float_value):
-                    errors.update({answer_tag: self.validation_error_msg})
-        return errors
+                    return {self.id: self.validation_error_msg}
+        return {}
 
-    def date_validation(self, date_type, post, answer_tag, min_value, max_value):
-        self.ensure_one()
-        errors = {}
-        if date_type not in ('date', 'datetime'):
-            raise ValueError("Unexpected date type value")
-        answer = post[answer_tag].strip()
-        # Empty answer to mandatory question
-        if self.constr_mandatory and not answer:
-            errors.update({answer_tag: self.constr_error_msg})
+    def _validate_date(self, answer):
+        isDatetime = self.question_type == 'datetime'
         # Checks if user input is a date
-        if answer:
-            try:
-                if date_type == 'datetime':
-                    dateanswer = fields.Datetime.from_string(answer)
-                else:
-                    dateanswer = fields.Date.from_string(answer)
-            except ValueError:
-                errors.update({answer_tag: _('This is not a date')})
-                return errors
-        # Answer validation (if properly defined)
-        if answer and self.validation_required:
-            # Answer is not in the right range
-            try:
-                if date_type == 'datetime':
-                    date_from_string = fields.Datetime.from_string
-                else:
-                    date_from_string = fields.Date.from_string
-                dateanswer = date_from_string(answer)
-                min_date = date_from_string(min_value)
-                max_date = date_from_string(max_value)
-
-                if min_date and max_date and not (min_date <= dateanswer <= max_date):
-                    # If Minimum and Maximum Date are entered
-                    errors.update({answer_tag: self.validation_error_msg})
-                elif min_date and not min_date <= dateanswer:
-                    # If only Minimum Date is entered and not Define Maximum Date
-                    errors.update({answer_tag: self.validation_error_msg})
-                elif max_date and not dateanswer <= max_date:
-                    # If only Maximum Date is entered and not Define Minimum Date
-                    errors.update({answer_tag: self.validation_error_msg})
-            except ValueError:  # check that it is a date has been done hereunder
-                pass
-        return errors
-
-    def validate_date(self, post, answer_tag):
-        return self.date_validation('date', post, answer_tag, self.validation_min_date, self.validation_max_date)
-
-    def validate_datetime(self, post, answer_tag):
-        return self.date_validation('datetime', post, answer_tag, self.validation_min_datetime, self.validation_max_datetime)
-
-    def validate_simple_choice(self, post, answer_tag):
-        self.ensure_one()
-        errors = {}
-        if self.comments_allowed:
-            comment_tag = "%s_%s" % (answer_tag, 'comment')
-        # Empty answer to mandatory self
-        if self.constr_mandatory and answer_tag not in post:
-            errors.update({answer_tag: self.constr_error_msg})
-        if self.constr_mandatory and answer_tag in post and not post[answer_tag].strip():
-            errors.update({answer_tag: self.constr_error_msg})
-        # Answer is a comment and is empty
-        if self.constr_mandatory and answer_tag in post and post[answer_tag] == "-1" and self.comment_count_as_answer and comment_tag in post and not post[comment_tag].strip():
-            errors.update({answer_tag: self.constr_error_msg})
-        return errors
-
-    def validate_multiple_choice(self, post, answer_tag):
-        self.ensure_one()
-        errors = {}
-        if self.constr_mandatory:
-            answer_candidates = dict_keys_startswith(post, answer_tag)
-            comment_flag = answer_candidates.pop(("%s_%s" % (answer_tag, -1)), None)
-            if self.comments_allowed:
-                comment_answer = answer_candidates.pop(("%s_%s" % (answer_tag, 'comment')), '').strip()
-            # Preventing answers with blank value
-            if all(not answer.strip() for answer in answer_candidates.values()) and answer_candidates:
-                errors.update({answer_tag: self.constr_error_msg})
-            # There is no answer neither comments (if comments count as answer)
-            if not answer_candidates and self.comment_count_as_answer and (not comment_flag or not comment_answer):
-                errors.update({answer_tag: self.constr_error_msg})
-            # There is no answer at all
-            if not answer_candidates and not self.comment_count_as_answer:
-                errors.update({answer_tag: self.constr_error_msg})
-        return errors
-
-    def validate_matrix(self, post, answer_tag):
-        self.ensure_one()
-        errors = {}
-        if self.constr_mandatory:
-            lines_number = len(self.labels_ids_2)
-            answer_candidates = dict_keys_startswith(post, answer_tag)
-            answer_candidates.pop(("%s_%s" % (answer_tag, 'comment')), '').strip()
-            # Number of lines that have been answered
-            if self.matrix_subtype == 'simple':
-                answer_number = len(answer_candidates)
-            elif self.matrix_subtype == 'multiple':
-                answer_number = len({sk.rsplit('_', 1)[0] for sk in answer_candidates})
+        try:
+            dateanswer = fields.Datetime.from_string(answer) if isDatetime else fields.Date.from_string(answer)
+        except ValueError:
+            return {self.id: _('This is not a date')}
+        if self.validation_required:
+            # Check if answer is in the right range
+            if isDatetime:
+                min_date = fields.Datetime.from_string(self.validation_min_datetime)
+                max_date = fields.Datetime.from_string(self.validation_max_datetime)
+                dateanswer = fields.Datetime.from_string(answer)
             else:
-                raise RuntimeError("Invalid matrix subtype")
-            # Validate that each line has been answered
-            if answer_number != lines_number:
-                errors.update({answer_tag: self.constr_error_msg})
-        return errors
+                min_date = fields.Date.from_string(self.validation_min_date)
+                max_date = fields.Date.from_string(self.validation_max_date)
+                dateanswer = fields.Date.from_string(answer)
+
+            if (min_date and max_date and not (min_date <= dateanswer <= max_date))\
+                    or (min_date and not min_date <= dateanswer)\
+                    or (max_date and not dateanswer <= max_date):
+                return {self.id: self.validation_error_msg}
+        return {}
+
+    def _validate_choice(self, answer, comment):
+        # Empty comment
+        if self.constr_mandatory \
+                and not answer \
+                and not (self.comments_allowed and self.comment_count_as_answer and comment):
+            return {self.id: self.constr_error_msg}
+        return {}
+
+    def _validate_matrix(self, answers):
+        # Validate that each line has been answered
+        if self.constr_mandatory and len(self.labels_ids_2) != len(answers):
+            return {self.id: self.constr_error_msg}
+        return {}
 
     @api.depends('survey_id.question_and_page_ids.is_page', 'survey_id.question_and_page_ids.sequence')
     def _compute_question_ids(self):

--- a/addons/survey/models/survey_user.py
+++ b/addons/survey/models/survey_user.py
@@ -267,240 +267,96 @@ class SurveyUserInputLine(models.Model):
             vals.update({'answer_score': self.env['survey.label'].browse(int(value_suggested)).answer_score})
         return super(SurveyUserInputLine, self).write(vals)
 
+    def _get_save_line_values(self, answer, answer_type):
+        if not answer or (isinstance(answer, str) and not answer.strip()):
+            return {'answer_type': None, 'skipped': True}
+        if answer_type == 'suggestion':
+            return {'answer_type': answer_type, 'value_suggested': answer}
+        value = float(answer) if answer_type == 'number' else answer
+        return {'answer_type': answer_type, 'value_' + answer_type: value}
+
     @api.model
-    def save_lines(self, user_input_id, question, post, answer_tag):
+    def save_lines(self, user_input_id, question, answer, comment=None):
         """ Save answers to questions, depending on question type
 
             If an answer already exists for question and user_input_id, it will be
-            overwritten (in order to maintain data consistency).
+            overwritten (or deleted for 'choice' questions) (in order to maintain data consistency).
         """
-        try:
-            saver = getattr(self, 'save_line_' + question.question_type)
-        except AttributeError:
-            _logger.error(question.question_type + ": This type of question has no saving function")
-            return False
-        else:
-            saver(user_input_id, question, post, answer_tag)
-
-    @api.model
-    def save_line_free_text(self, user_input_id, question, post, answer_tag):
         vals = {
             'user_input_id': user_input_id,
             'question_id': question.id,
             'survey_id': question.survey_id.id,
             'skipped': False,
         }
-        if answer_tag in post and post[answer_tag].strip():
-            vals.update({'answer_type': 'free_text', 'value_free_text': post[answer_tag]})
-        else:
-            vals.update({'answer_type': None, 'skipped': True})
-        old_uil = self.search([
+        old_answers = self.search([
             ('user_input_id', '=', user_input_id),
             ('survey_id', '=', question.survey_id.id),
             ('question_id', '=', question.id)
         ])
-        if old_uil:
-            old_uil.write(vals)
-        else:
-            old_uil.create(vals)
-        return True
 
-    @api.model
-    def save_line_textbox(self, user_input_id, question, post, answer_tag):
-        vals = {
-            'user_input_id': user_input_id,
-            'question_id': question.id,
-            'survey_id': question.survey_id.id,
-            'skipped': False
-        }
-        if answer_tag in post and post[answer_tag].strip():
-            vals.update({'answer_type': 'text', 'value_text': post[answer_tag]})
-        else:
-            vals.update({'answer_type': None, 'skipped': True})
-        old_uil = self.search([
-            ('user_input_id', '=', user_input_id),
-            ('survey_id', '=', question.survey_id.id),
-            ('question_id', '=', question.id)
-        ])
-        if old_uil:
-            old_uil.write(vals)
+        if question.question_type in ['textbox', 'free_text', 'numerical_box', 'date', 'datetime']:
+            self._save_line_simple_answer(vals, old_answers, question, answer)
+        elif question.question_type in ['simple_choice', 'multiple_choice']:
+            self._save_line_choice(vals, old_answers, question, answer, comment)
+        elif question.question_type == 'matrix':
+            self._save_line_matrix(vals, old_answers, answer, comment)
         else:
-            old_uil.create(vals)
-        return True
+            raise AttributeError(question.question_type + ": This type of question has no saving function")
 
     @api.model
-    def save_line_numerical_box(self, user_input_id, question, post, answer_tag):
-        vals = {
-            'user_input_id': user_input_id,
-            'question_id': question.id,
-            'survey_id': question.survey_id.id,
-            'skipped': False
-        }
-        if answer_tag in post and post[answer_tag].strip():
-            vals.update({'answer_type': 'number', 'value_number': float(post[answer_tag])})
+    def _save_line_simple_answer(self, vals, old_answers, question, answer):
+        answer_type = question.question_type
+        if question.question_type == 'textbox':
+            answer_type = 'text'
+        elif question.question_type == 'numerical_box':
+            answer_type = 'number'
+
+        vals.update(self._get_save_line_values(answer, answer_type))
+        if old_answers:
+            old_answers.write(vals)
         else:
-            vals.update({'answer_type': None, 'skipped': True})
-        old_uil = self.search([
-            ('user_input_id', '=', user_input_id),
-            ('survey_id', '=', question.survey_id.id),
-            ('question_id', '=', question.id)
-        ])
-        if old_uil:
-            old_uil.write(vals)
-        else:
-            old_uil.create(vals)
+            self.create(vals)
         return True
 
     @api.model
-    def save_line_date(self, user_input_id, question, post, answer_tag):
-        vals = {
-            'user_input_id': user_input_id,
-            'question_id': question.id,
-            'survey_id': question.survey_id.id,
-            'skipped': False
-        }
-        if answer_tag in post and post[answer_tag].strip():
-            vals.update({'answer_type': 'date', 'value_date': post[answer_tag]})
-        else:
-            vals.update({'answer_type': None, 'skipped': True})
-        old_uil = self.search([
-            ('user_input_id', '=', user_input_id),
-            ('survey_id', '=', question.survey_id.id),
-            ('question_id', '=', question.id)
-        ])
-        if old_uil:
-            old_uil.write(vals)
-        else:
-            old_uil.create(vals)
-        return True
+    def _save_line_choice(self, vals, old_answers, question, answers, comment):
+        if not (isinstance(answers, list)):
+            answers = [answers]
+
+        vals_list = []
+        if question.question_type == 'simple_choice':
+            if not (question.comment_count_as_answer and question.comments_allowed and comment):
+                for answer in answers:
+                    vals.update(self._get_save_line_values(answer, 'suggestion'))
+                    vals_list.append(vals.copy())
+        elif question.question_type == 'multiple_choice':
+            for answer in answers:
+                vals.update(self._get_save_line_values(answer, 'suggestion'))
+                vals_list.append(vals.copy())
+
+        if comment:
+            vals.update({'answer_type': 'text', 'value_text': comment, 'skipped': False, 'value_suggested': False})
+            vals_list.append(vals.copy())
+
+        old_answers.sudo().unlink()
+        self.create(vals_list)
 
-    @api.model
-    def save_line_datetime(self, user_input_id, question, post, answer_tag):
-        vals = {
-            'user_input_id': user_input_id,
-            'question_id': question.id,
-            'survey_id': question.survey_id.id,
-            'skipped': False
-        }
-        if answer_tag in post and post[answer_tag].strip():
-            vals.update({'answer_type': 'datetime', 'value_datetime': post[answer_tag]})
-        else:
-            vals.update({'answer_type': None, 'skipped': True})
-        old_uil = self.search([
-            ('user_input_id', '=', user_input_id),
-            ('survey_id', '=', question.survey_id.id),
-            ('question_id', '=', question.id)
-        ])
-        if old_uil:
-            old_uil.write(vals)
-        else:
-            old_uil.create(vals)
         return True
 
     @api.model
-    def save_line_simple_choice(self, user_input_id, question, post, answer_tag):
-        vals = {
-            'user_input_id': user_input_id,
-            'question_id': question.id,
-            'survey_id': question.survey_id.id,
-            'skipped': False
-        }
-        old_uil = self.search([
-            ('user_input_id', '=', user_input_id),
-            ('survey_id', '=', question.survey_id.id),
-            ('question_id', '=', question.id)
-        ])
-        old_uil.sudo().unlink()
-
-        if answer_tag in post and post[answer_tag].strip():
-            vals.update({'answer_type': 'suggestion', 'value_suggested': int(post[answer_tag])})
-        else:
-            vals.update({'answer_type': None, 'skipped': True})
-
-        # '-1' indicates 'comment count as an answer' so do not need to record it
-        if post.get(answer_tag) and post.get(answer_tag) != '-1':
-            self.create(vals)
-
-        comment_answer = post.pop(("%s_%s" % (answer_tag, 'comment')), '').strip()
-        if comment_answer:
-            vals.update({'answer_type': 'text', 'value_text': comment_answer, 'skipped': False, 'value_suggested': False})
-            self.create(vals)
+    def _save_line_matrix(self, vals, old_answers, answers, comment):
+        vals_list = []
 
-        return True
-
-    @api.model
-    def save_line_multiple_choice(self, user_input_id, question, post, answer_tag):
-        vals = {
-            'user_input_id': user_input_id,
-            'question_id': question.id,
-            'survey_id': question.survey_id.id,
-            'skipped': False
-        }
-        old_uil = self.search([
-            ('user_input_id', '=', user_input_id),
-            ('survey_id', '=', question.survey_id.id),
-            ('question_id', '=', question.id)
-        ])
-        old_uil.sudo().unlink()
-
-        ca_dict = dict_keys_startswith(post, answer_tag + '_')
-        comment_answer = ca_dict.pop(("%s_%s" % (answer_tag, 'comment')), '').strip()
-        if len(ca_dict) > 0:
-            for key in ca_dict:
-                # '-1' indicates 'comment count as an answer' so do not need to record it
-                if key != ('%s_%s' % (answer_tag, '-1')):
-                    val = ca_dict[key]
-                    vals.update({'answer_type': 'suggestion', 'value_suggested': bool(val) and int(val)})
-                    self.create(vals)
-        if comment_answer:
-            vals.update({'answer_type': 'text', 'value_text': comment_answer, 'value_suggested': False})
-            self.create(vals)
-        if not ca_dict and not comment_answer:
-            vals.update({'answer_type': None, 'skipped': True})
-            self.create(vals)
-        return True
+        for row_key, row_answer in answers.items():
+            for answer in row_answer:
+                vals.update({'answer_type': 'suggestion', 'value_suggested': answer, 'value_suggested_row': row_key})
+                vals_list.append(vals.copy())
 
-    @api.model
-    def save_line_matrix(self, user_input_id, question, post, answer_tag):
-        vals = {
-            'user_input_id': user_input_id,
-            'question_id': question.id,
-            'survey_id': question.survey_id.id,
-            'skipped': False
-        }
-        old_uil = self.search([
-            ('user_input_id', '=', user_input_id),
-            ('survey_id', '=', question.survey_id.id),
-            ('question_id', '=', question.id)
-        ])
-        old_uil.sudo().unlink()
+        if comment:
+            vals.update({'answer_type': 'text', 'value_text': comment, 'skipped': False, 'value_suggested': False})
+            vals_list.append(vals.copy())
 
-        no_answers = True
-        ca_dict = dict_keys_startswith(post, answer_tag + '_')
+        old_answers.sudo().unlink()
+        self.create(vals_list)
 
-        comment_answer = ca_dict.pop(("%s_%s" % (answer_tag, 'comment')), '').strip()
-        if comment_answer:
-            vals.update({'answer_type': 'text', 'value_text': comment_answer})
-            self.create(vals)
-            no_answers = False
-
-        if question.matrix_subtype == 'simple':
-            for row in question.labels_ids_2:
-                a_tag = "%s_%s" % (answer_tag, row.id)
-                if a_tag in ca_dict:
-                    no_answers = False
-                    vals.update({'answer_type': 'suggestion', 'value_suggested': ca_dict[a_tag], 'value_suggested_row': row.id})
-                    self.create(vals)
-
-        elif question.matrix_subtype == 'multiple':
-            for col in question.labels_ids:
-                for row in question.labels_ids_2:
-                    a_tag = "%s_%s_%s" % (answer_tag, row.id, col.id)
-                    if a_tag in ca_dict:
-                        no_answers = False
-                        vals.update({'answer_type': 'suggestion', 'value_suggested': col.id, 'value_suggested_row': row.id})
-                        self.create(vals)
-        if no_answers:
-            vals.update({'answer_type': None, 'skipped': True})
-            self.create(vals)
         return True
