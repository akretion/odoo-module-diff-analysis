PR: https://github.com/odoo/odoo/pull/

From: a223111b922d3c3d8957f894bf20a156eb96d324
From: Mahendra barad
Date: 2015-09-01 06:14:16

Structural Changes: 43
Total Changes: 489

[IMP] delivery, website_sale_delivery: refactoring and usability

* migration to new API
* removed delivery.grid object, has been merged with delivery.carrier
* change view of delivery.carrier (price rules, etc.)
* tests from yml to py
* website : restrict the list of countries for delivery address in the shop

================================= pseudo patch: =================================

--- a/addons/delivery/models/__init__.py
+++ b/addons/delivery/models/__init__.py
@@ -1,24 +1,10 @@
 # -*- coding: utf-8 -*-
-##############################################################################
-#
-#    Odoo, Open Source Business Applications
-#    Copyright (c) 2015 Odoo S.A. <http://openerp.com>
-#
-#    This program is free software: you can redistribute it and/or modify
-#    it under the terms of the GNU Affero General Public License as
-#    published by the Free Software Foundation, either version 3 of the
-#    License, or (at your option) any later version.
-#
-#    This program is distributed in the hope that it will be useful,
-#    but WITHOUT ANY WARRANTY; without even the implied warranty of
-#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-#    GNU Affero General Public License for more details.
-#
-#    You should have received a copy of the GNU Affero General Public License
-#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
-#
-##############################################################################
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
 
 import delivery_carrier
+import delivery_price_rule
+import product_template
 import sale_order
+import partner
 import stock_picking
+import stock_move

--- a/addons/delivery/models/delivery_carrier.py
+++ b/addons/delivery/models/delivery_carrier.py
@@ -1,33 +1,19 @@
 # -*- coding: utf-8 -*-
-##############################################################################
-#
-#    Odoo, Open Source Business Applications
-#    Copyright (c) 2015 Odoo S.A. <http://openerp.com>
-#
-#    This program is free software: you can redistribute it and/or modify
-#    it under the terms of the GNU Affero General Public License as
-#    published by the Free Software Foundation, either version 3 of the
-#    License, or (at your option) any later version.
-#
-#    This program is distributed in the hope that it will be useful,
-#    but WITHOUT ANY WARRANTY; without even the implied warranty of
-#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-#    GNU Affero General Public License for more details.
-#
-#    You should have received a copy of the GNU Affero General Public License
-#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
-#
-##############################################################################
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
 
 import logging
-from openerp import models, fields, api
+from openerp import api, fields, models, _
 from openerp.exceptions import UserError
 
 _logger = logging.getLogger(__name__)
 
 
 class DeliveryCarrier(models.Model):
-    _inherit = 'delivery.carrier'
+    _name = 'delivery.carrier'
+    _inherits = {'product.product': 'product_id'}
+    _description = "Carrier"
+    _order = 'sequence, id'
+
     ''' A Shipping Provider
 
     In order to add your own external provider, follow these steps:
@@ -47,10 +33,40 @@ class DeliveryCarrier(models.Model):
     # Internals for shipping providers #
     # -------------------------------- #
 
-    delivery_type = fields.Selection([('grid', 'Default Delivery')], string="Delivery Type", default='grid', required='True')
-
+    sequence = fields.Integer(help="Determine the display order", default=10)
+    # This field will be overwritten by internal shipping providers by adding their own type (ex: 'fedex')
+    delivery_type = fields.Selection([('fixed', 'Fixed Price'), ('base_on_rule', 'Based on Rules')], string='Price Computation', default='fixed', required=True)
+    product_type = fields.Selection(related='product_id.type', default='service')
+    product_sale_ok = fields.Boolean(related='product_id.sale_ok', default=False)
+    partner_id = fields.Many2one('res.partner', string='Transporter Company', required=True, help="The partner that is doing the delivery service.")
+    product_id = fields.Many2one('product.product', string='Delivery Product', required=True, ondelete="cascade")
     price = fields.Float(compute='get_price')
     available = fields.Boolean(compute='get_price')
+    free_if_more_than = fields.Boolean('Free if Order total is more than', help="If the order is more expensive than a certain amount, the customer can benefit from a free shipping", default=False)
+    amount = fields.Float(string='Amount', help="Amount of the order to benefit from a free shipping, expressed in the company currency")
+    country_ids = fields.Many2many('res.country', 'delivery_carrier_country_rel', 'carrier_id', 'country_id', 'Countries')
+    state_ids = fields.Many2many('res.country.state', 'delivery_carrier_state_rel', 'carrier_id', 'state_id', 'States')
+    zip_from = fields.Char('Zip From')
+    zip_to = fields.Char('Zip To')
+    price_rule_ids = fields.One2many('delivery.price.rule', 'carrier_id', 'Pricing Rules', copy=True)
+    state = fields.Selection([('test', 'Testing'), ('production', 'Production')], 'State')
+    fixed_price = fields.Float(compute='_compute_fixed_price', inverse='_set_product_fixed_price', store=True, string='Fixed Price',help="Keep empty if the pricing depends on the advanced pricing per destination")
+
+    @api.depends('product_id.list_price', 'product_id.product_tmpl_id.list_price')
+    def _compute_fixed_price(self):
+        for carrier in self:
+            carrier.fixed_price = carrier.product_id.list_price
+
+    def _set_product_fixed_price(self):
+        for carrier in self:
+            carrier.product_id.list_price = carrier.fixed_price
+
+    @api.onchange('delivery_type')
+    def onchange_delivery_type(self):
+        if self.delivery_type in ["fixed", "base_on_rule"]:
+            self.state = 'production'
+        else:
+            self.state = 'test'
 
     @api.one
     def get_price(self):
@@ -63,19 +79,27 @@ class DeliveryCarrier(models.Model):
         if order_id:
             # FIXME: temporary hack until we refactor the delivery API in master
 
-            if self.delivery_type != 'grid':
+            order = SaleOrder.browse(order_id)
+            if self.delivery_type not in ['fixed', 'base_on_rule']:
                 try:
-                    order = SaleOrder.browse(order_id)
                     self.price = self.get_shipping_price_from_so(order)[0]
                     self.available = True
                 except UserError as e:
-                        # no suitable delivery method found, probably configuration error
-                        _logger.info("Carrier %s: %s, not found", self.name, e.name)
-                        self.price = 0.0
+                    # No suitable delivery method found, probably configuration error
+                    _logger.info("Carrier %s: %s, not found", self.name, e.name)
+                    self.price = 0.0
             else:
-                res = super(DeliveryCarrier, self).get_price('price', [])
-                self.available = res[self.id]['available']
-                self.price = res[self.id]['price']
+                carrier = self.verify_carrier(order.partner_shipping_id)
+                if carrier:
+                    try:
+                        self.price = carrier.get_price_available(order)
+                        self.available = True
+                    except UserError, e:
+                        # No suitable delivery method found, probably configuration error
+                        _logger.info("Carrier %s: %s", carrier.name, e.name)
+                        self.price = 0.0
+                else:
+                    self.price = 0.0
 
     # -------------------------- #
     # API for external providers #
@@ -123,3 +147,113 @@ class DeliveryCarrier(models.Model):
         self.ensure_one()
         if hasattr(self, '%s_cancel_shipment' % self.delivery_type):
             return getattr(self, '%s_cancel_shipment' % self.delivery_type)(pickings)
+
+    @api.onchange('state_ids')
+    def onchange_states(self):
+        self.country_ids = [(6, 0, self.country_ids.ids + self.state_ids.mapped('country_id.id'))]
+
+    @api.onchange('country_ids')
+    def onchange_countries(self):
+        self.state_ids = [(6, 0, self.state_ids.filtered(lambda state: state.id in self.country_ids.mapped('state_ids').ids).ids)]
+
+    @api.multi
+    def verify_carrier(self, contact):
+        self.ensure_one()
+        if self.country_ids and contact.country_id not in self.country_ids:
+            return False
+        if self.state_ids and contact.state_id not in self.state_ids:
+            return False
+        if self.zip_from and (contact.zip or '') < self.zip_from:
+            return False
+        if self.zip_to and (contact.zip or '') > self.zip_to:
+            return False
+        return self
+
+    @api.multi
+    def create_price_rules(self):
+        PriceRule = self.env['delivery.price.rule']
+        for record in self:
+            # If using advanced pricing per destination: do not change
+            if record.delivery_type == 'base_on_rule':
+                continue
+
+            # Not using advanced pricing per destination: override lines
+            if record.delivery_type == 'base_on_rule' and not (record.fixed_price is not False or record.free_if_more_than):
+                record.price_rule_ids.unlink()
+
+            # Check that float, else 0.0 is False
+            if not (record.fixed_price is not False or record.free_if_more_than):
+                continue
+
+            if record.delivery_type == 'fixed':
+                PriceRule.search([('carrier_id', '=', record.id)]).unlink()
+
+            line_data = {
+                'carrier_id': record.id,
+                'variable': 'price',
+                'operator': '>=',
+            }
+            # Create the delivery price rules
+            if record.free_if_more_than:
+                line_data.update({
+                    'max_value': record.amount,
+                    'standard_price': 0.0,
+                    'list_base_price': 0.0,
+                })
+                PriceRule.create(line_data)
+            if record.fixed_price is not False:
+                line_data.update({
+                    'max_value': 0.0,
+                    'standard_price': record.fixed_price,
+                    'list_base_price': record.fixed_price,
+                })
+                PriceRule.create(line_data)
+        return True
+
+    @api.model
+    def create(self, vals):
+        res = super(DeliveryCarrier, self).create(vals)
+        res.create_price_rules()
+        return res
+
+    @api.multi
+    def write(self, vals):
+        res = super(DeliveryCarrier, self).write(vals)
+        self.create_price_rules()
+        return res
+
+    @api.multi
+    def get_price_available(self, order):
+        self.ensure_one()
+        total = weight = volume = quantity = 0
+        total_delivery = 0.0
+        ProductUom = self.env['product.uom']
+        for line in order.order_line:
+            if line.state == 'cancel':
+                continue
+            if line.is_delivery:
+                total_delivery += line.price_total
+            if not line.product_id or line.is_delivery:
+                continue
+            qty = ProductUom._compute_qty(line.product_uom.id, line.product_uom_qty, line.product_id.uom_id.id)
+            weight += (line.product_id.weight or 0.0) * qty
+            volume += (line.product_id.volume or 0.0) * qty
+            quantity += qty
+        total = (order.amount_total or 0.0) - total_delivery
+
+        return self.get_price_from_picking(total, weight, volume, quantity)
+
+    def get_price_from_picking(self, total, weight, volume, quantity):
+        price = 0.0
+        criteria_found = False
+        price_dict = {'price': total, 'volume': volume, 'weight': weight, 'wv': volume * weight, 'quantity': quantity}
+        for line in self.price_rule_ids:
+            test = eval(line.variable + line.operator + str(line.max_value), price_dict)
+            if test:
+                price = line.list_base_price + line.list_price * price_dict[line.variable_factor]
+                criteria_found = True
+                break
+        if not criteria_found:
+            raise UserError(_("Selected product in the delivery method doesn't fulfill any of the delivery carrier(s) criteria."))
+
+        return price

--- a/None
+++ b/addons/delivery/models/delivery_price_rule.py
@@ -0,0 +1,34 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from openerp import models, fields, api
+import openerp.addons.decimal_precision as dp
+
+
+class PriceRule(models.Model):
+    _name = "delivery.price.rule"
+    _description = "Delivery Price Rules"
+    _order = 'sequence, list_price'
+
+    @api.depends('variable', 'operator', 'max_value', 'list_base_price', 'list_price', 'variable_factor')
+    def _get_name(self):
+        for rule in self:
+            name = 'if %s %s %s then' % (rule.variable, rule.operator, rule.max_value)
+            if rule.list_base_price and not rule.list_price:
+                name = '%s fixed price %s' % (name, rule.list_base_price)
+            elif rule.list_price and not rule.list_base_price:
+                name = '%s %s times %s' % (name, rule.list_price, rule.variable_factor)
+            else:
+                name = '%s fixed price %s and %s times %s Extra' % (name, rule.list_base_price, rule.list_price, rule.variable_factor)
+            rule.name = name
+
+    name = fields.Char(compute='_get_name')
+    sequence = fields.Integer(required=True, help="Gives the sequence order when calculating delivery carrier.", default=10)
+    carrier_id = fields.Many2one('delivery.carrier', 'Carrier', required=True, ondelete='cascade')
+    variable = fields.Selection([('weight', 'Weight'), ('volume', 'Volume'), ('wv', 'Weight * Volume'), ('price', 'Price'), ('quantity', 'Quantity')], 'Variable', required=True, default='weight')
+    operator = fields.Selection([('==', '='), ('<=', '<='), ('<', '<'), ('>=', '>='), ('>', '>')], 'Operator', required=True, default='<=')
+    max_value = fields.Float('Maximum Value', required=True)
+    variable_factor = fields.Selection([('weight', 'Weight'), ('volume', 'Volume'), ('wv', 'Weight * Volume'), ('price', 'Price'), ('quantity', 'Quantity')], 'Variable Factor', required=True, default='weight')
+    list_base_price = fields.Float(string='Sale Base Price', digits_compute=dp.get_precision('Product Price'), required=True, default=0.0)
+    list_price = fields.Float('Sale Price', digits_compute=dp.get_precision('Product Price'), required=True, default=0.0)
+    standard_price = fields.Float('Cost Price', digits_compute=dp.get_precision('Product Price'), required=True, default=0.0)

--- a/None
+++ b/addons/delivery/models/partner.py
@@ -0,0 +1,10 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from openerp import fields, models
+
+
+class ResPartner(models.Model):
+    _inherit = 'res.partner'
+
+    property_delivery_carrier_id = fields.Many2one('delivery.carrier', company_dependent=True, string="Delivery Method", help="This delivery method will be used when invoicing from picking.")

--- a/None
+++ b/addons/delivery/models/product_template.py
@@ -0,0 +1,19 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from openerp import api, models
+
+
+class ProductTemplate(models.Model):
+    _inherit = 'product.template'
+
+    @api.multi
+    def write(self, vals):
+        res = super(ProductTemplate, self).write(vals)
+        if vals.get('list_price'):
+            DeliveryCarrier = self.env['delivery.carrier']
+            for template in self:
+                carrier = DeliveryCarrier.search([('product_id', 'in', template.product_variant_ids.ids)])
+                if carrier:
+                    carrier.create_price_rules()
+        return res

--- a/addons/delivery/models/sale_order.py
+++ b/addons/delivery/models/sale_order.py
@@ -1,23 +1,5 @@
 # -*- coding: utf-8 -*-
-##############################################################################
-#
-#    Odoo, Open Source Business Applications
-#    Copyright (c) 2015 Odoo S.A. <http://openerp.com>
-#
-#    This program is free software: you can redistribute it and/or modify
-#    it under the terms of the GNU Affero General Public License as
-#    published by the Free Software Foundation, either version 3 of the
-#    License, or (at your option) any later version.
-#
-#    This program is distributed in the hope that it will be useful,
-#    but WITHOUT ANY WARRANTY; without even the implied warranty of
-#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-#    GNU Affero General Public License for more details.
-#
-#    You should have received a copy of the GNU Affero General Public License
-#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
-#
-##############################################################################
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
 
 from openerp import models, fields, api, _
 from openerp.exceptions import UserError
@@ -27,19 +9,29 @@ class SaleOrder(models.Model):
     _inherit = 'sale.order'
 
     delivery_price = fields.Float(string='Estimated Delivery Price', compute='_compute_delivery_price', store=True)
+    carrier_id = fields.Many2one("delivery.carrier", string="Delivery Method", help="Fill this field if you plan to invoice the shipping based on picking.")
 
     @api.depends('carrier_id', 'partner_id', 'order_line')
     def _compute_delivery_price(self):
         for order in self:
             if order.state != 'draft':
-                # we do not want to recompute the shipping price of an already validated/done SO
+                # We do not want to recompute the shipping price of an already validated/done SO
                 continue
             elif order.carrier_id.delivery_type != 'grid' and not order.order_line:
-                # prevent SOAP call to external shipping provider when SO has no lines yet
+                # Prevent SOAP call to external shipping provider when SO has no lines yet
                 continue
             else:
                 order.delivery_price = order.carrier_id.with_context(order_id=order.id).price
 
+    @api.onchange('partner_id')
+    def onchange_partner_id_dtype(self):
+        if self.partner_id:
+            self.carrier_id = self.partner_id.property_delivery_carrier_id
+
+    @api.multi
+    def _delivery_unset(self):
+        self.env['sale.order.line'].search([('order_id', 'in', self.ids), ('is_delivery', '=', True)]).unlink()
+
     @api.multi
     def delivery_set(self):
 
@@ -49,16 +41,26 @@ class SaleOrder(models.Model):
         self._delivery_unset()
 
         for order in self:
-            if order.carrier_id and order.carrier_id.delivery_type != 'grid':
-                # Shipping providers are used when delivery_type is other than 'grid'
-
+            carrier = order.carrier_id
+            if carrier:
                 if order.state not in ('draft', 'sent'):
                     raise UserError(_('The order state have to be draft to add delivery lines.'))
 
-                carrier = order.carrier_id
-                account_id = carrier.product_id.property_account_income.id
+                if carrier.delivery_type not in ['fixed', 'base_on_rule']:
+                    # Shipping providers are used when delivery_type is other than 'fixed' or 'base_on_rule'
+                    price_unit = order.carrier_id.get_shipping_price_from_so(order)[0]
+                else:
+                    # Classic grid-based carriers
+                    carrier = order.carrier_id.verify_carrier(order.partner_shipping_id)
+                    if not carrier:
+                        raise UserError(_('No carrier matching.'))
+                    price_unit = carrier.get_price_available(order)
+                    if order.company_id.currency_id.id != order.pricelist_id.currency_id.id:
+                        price_unit = order.company_id.currency_id.with_context(date=order.date_order).compute(order.pricelist_id.currency_id.id, price_unit)
+
+                account_id = carrier.product_id.property_account_income_id.id
                 if not account_id:
-                    account_id = carrier.product_id.categ_id.property_account_income_categ.id
+                    account_id = carrier.product_id.categ_id.property_account_income_categ_id.id
 
                 # Apply fiscal position
                 taxes = carrier.product_id.taxes_id
@@ -67,17 +69,23 @@ class SaleOrder(models.Model):
                     account_id = order.fiscal_position_id.map_account(account_id)
                     taxes_ids = order.fiscal_position_id.map_tax(taxes).ids
 
+                # Create the sale order line
                 SaleOrderLine.create({
                     'order_id': order.id,
-                    'name': order.carrier_id.name,
+                    'name': carrier.name,
                     'product_uom_qty': 1,
-                    'product_uom': order.carrier_id.product_id.uom_id.id,
-                    'product_id': order.carrier_id.product_id.id,
-                    'price_unit': order.carrier_id.get_shipping_price_from_so(order)[0],
+                    'product_uom': carrier.product_id.uom_id.id,
+                    'product_id': carrier.product_id.id,
+                    'price_unit': price_unit,
                     'tax_id': [(6, 0, taxes_ids)],
                     'is_delivery': True
                 })
 
             else:
-                # Classic grid-based carriers
-                super(SaleOrder, self).delivery_set()
+                raise UserError(_('No carrier set for this order.'))
+
+
+class SaleOrderLine(models.Model):
+    _inherit = 'sale.order.line'
+
+    is_delivery = fields.Boolean(string="Is a Delivery", default=False)

--- a/None
+++ b/addons/delivery/models/stock_move.py
@@ -0,0 +1,39 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from openerp import api, fields, models
+
+import openerp.addons.decimal_precision as dp
+
+
+class StockMove(models.Model):
+    _inherit = 'stock.move'
+
+    def _default_uom(self):
+        uom_categ_id = self.env.ref('product.product_uom_categ_kgm').id
+        return self.env['product.uom'].search([('category_id', '=', uom_categ_id), ('factor', '=', 1)], limit=1)
+
+    weight = fields.Float(compute='_cal_move_weight', digits_compute=dp.get_precision('Stock Weight'), store=True)
+    weight_uom_id = fields.Many2one('product.uom', string='Unit of Measure', required=True, readonly=True, help="Unit of Measure (Unit of Measure) is the unit of measurement for Weight", default=_default_uom)
+
+    @api.depends('product_id', 'product_uom_qty', 'product_uom')
+    def _cal_move_weight(self):
+        for move in self.filtered(lambda moves: moves.product_id.weight > 0.00):
+            move.weight = (move.product_qty * move.product_id.weight)
+
+    @api.multi
+    def action_confirm(self):
+        """
+            Pass the carrier to the picking from the sales order
+            (Should also work in case of Phantom BoMs when on explosion the original move is deleted)
+        """
+        procs_to_check = []
+        for move in self:
+            if move.procurement_id and move.procurement_id.sale_line_id and move.procurement_id.sale_line_id.order_id.carrier_id:
+                procs_to_check += [move.procurement_id]
+        res = super(StockMove, self).action_confirm()
+        for proc in procs_to_check:
+            pickings = (proc.move_ids.mapped('picking_id')).filtered(lambda record: not record.carrier_id)
+            if pickings:
+                pickings.write({'carrier_id': proc.sale_line_id.order_id.carrier_id.id})
+        return res

--- a/addons/delivery/models/stock_picking.py
+++ b/addons/delivery/models/stock_picking.py
@@ -1,47 +1,48 @@
 # -*- coding: utf-8 -*-
-##############################################################################
-#
-#    Odoo, Open Source Business Applications
-#    Copyright (c) 2015 Odoo S.A. <http://openerp.com>
-#
-#    This program is free software: you can redistribute it and/or modify
-#    it under the terms of the GNU Affero General Public License as
-#    published by the Free Software Foundation, either version 3 of the
-#    License, or (at your option) any later version.
-#
-#    This program is distributed in the hope that it will be useful,
-#    but WITHOUT ANY WARRANTY; without even the implied warranty of
-#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-#    GNU Affero General Public License for more details.
-#
-#    You should have received a copy of the GNU Affero General Public License
-#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
-#
-##############################################################################
-
-from openerp import models, fields, api
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from openerp import models, fields, api, _
+from openerp.exceptions import UserError
+
+import openerp.addons.decimal_precision as dp
+
 
 class StockPicking(models.Model):
     _inherit = 'stock.picking'
 
+    def _default_uom(self):
+        uom_categ_id = self.env.ref('product.product_uom_categ_kgm').id
+        return self.env['product.uom'].search([('category_id', '=', uom_categ_id), ('factor', '=', 1)], limit=1)
+
     carrier_price = fields.Float(string="Shipping Cost", readonly=True)
     delivery_type = fields.Selection(related='carrier_id.delivery_type', readonly=True)
+    carrier_id = fields.Many2one("delivery.carrier", string="Carrier")
+    volume = fields.Float(copy=False)
+    weight = fields.Float(compute='_cal_weight', digits_compute=dp.get_precision('Stock Weight'), store=True)
+    carrier_tracking_ref = fields.Char(string='Carrier Tracking Ref', copy=False)
+    number_of_packages = fields.Integer(string='Number of Packages', copy=False)
+    weight_uom_id = fields.Many2one('product.uom', string='Unit of Measure', required=True, readonly="1", help="Unit of measurement for Weight", default=_default_uom)
+
+    @api.depends('product_id', 'move_lines')
+    def _cal_weight(self):
+        for picking in self:
+            picking.weight = sum(move.weight for move in picking.move_lines if move.state != 'cancel')
 
     @api.multi
     def do_transfer(self):
+        self.ensure_one()
         res = super(StockPicking, self).do_transfer()
 
-        if self.carrier_id and self.carrier_id.delivery_type != 'grid':
+        if self.carrier_id and self.carrier_id.delivery_type not in ['fixed', 'base_on_rule']:
             self.send_to_shipper()
         return res
 
-    # Signature due to strange old api methods
-    @api.model
-    def _prepare_shipping_invoice_line(self, picking, invoice):
-        picking.ensure_one()
+    @api.multi
+    def _prepare_shipping_invoice_line(self, invoice):
+        self.ensure_one()
         invoice.ensure_one()
 
-        carrier = picking.carrier_id
+        carrier = self.carrier_id
 
         # No carrier
         if not carrier:
@@ -51,12 +52,18 @@ class StockPicking(models.Model):
             return None
 
         # Classic carrier
-        if carrier.delivery_type == 'grid':
-            return super(StockPicking, self)._prepare_shipping_invoice_line(picking, invoice)
-
-        # Shipping provider
-        price = picking.carrier_price
-
+        if carrier.delivery_type in ['fixed', 'base_on_rule']:
+            carrier = carrier.verify_carrier(self.partner_id)
+            if not carrier:
+                raise UserError(_('The carrier %s (id: %d) has no delivery method!') % (self.carrier_id.name, self.carrier_id.id))
+            quantity = sum([line.product_uom_qty for line in self.move_lines])
+            price = carrier.get_price_from_picking(invoice.amount_untaxed, self.weight, self.volume, quantity)
+        else:
+            # Shipping provider
+            price = self.carrier_price
+
+        if invoice.company_id.currency_id.id != invoice.currency_id.id:
+            price = invoice.company_id.currency_id.with_context(date=invoice.date_invoice).compute(invoice.currency_id.id, price)
         account_id = carrier.product_id.property_account_income.id
         if not account_id:
             account_id = carrier.product_id.categ_id.property_account_income_categ.id
@@ -65,8 +72,8 @@ class StockPicking(models.Model):
         taxes_ids = taxes.ids
 
         # Apply original SO fiscal position
-        if picking.sale_id.fiscal_position_id:
-            fpos = picking.sale_id.fiscal_position_id
+        if self.sale_id.fiscal_position_id:
+            fpos = self.sale_id.fiscal_position_id
             account_id = fpos.map_account(account_id)
             taxes_ids = fpos.map_tax(taxes).ids
 
@@ -83,12 +90,24 @@ class StockPicking(models.Model):
 
         return res
 
-    @api.one
+    @api.model
+    def _invoice_create_line(self, moves, journal_id, inv_type='out_invoice'):
+        InvoiceLine = self.env['account.invoice.line']
+        invoice_ids = super(StockPicking, self)._invoice_create_line(moves, journal_id, inv_type=inv_type)
+        for move in moves:
+            for invoice in move.picking_id.sale_id.invoice_ids.filtered(lambda invoice: invoice.id in invoice_ids):
+                invoice_line = move.picking_id._prepare_shipping_invoice_line(invoice)
+                if invoice_line:
+                    InvoiceLine.create(invoice_line)
+        return invoice_ids
+
+    @api.multi
     def send_to_shipper(self):
+        self.ensure_one()
         res = self.carrier_id.send_shipping(self)[0]
         self.carrier_price = res['exact_price']
         self.carrier_tracking_ref = res['tracking_number']
-        msg = "Shipment sent to carrier %s for expedition with tracking number %s" % (self.carrier_id.name, self.carrier_tracking_ref)
+        msg = _("Shipment sent to carrier %s for expedition with tracking number %s") % (self.carrier_id.name, self.carrier_tracking_ref)
         self.message_post(body=msg)
 
     @api.multi
