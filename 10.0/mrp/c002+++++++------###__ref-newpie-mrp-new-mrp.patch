PR: https://github.com/odoo/odoo/pull/

From: 2ddc35a5300e89981c0572ae6749aee946f34e9d
From: Josse Colpaert
Date: 2016-07-04 14:22:37

Structural Changes: 266
Total Changes: 3359

[REF][NEWPIE] mrp: new MRP

This commit contains the core of the new MRP. It contains a whole refactoring
of the MRP application, with improved and new features, written in new API.
Among other here are the main manufacturing workflow improvements :

 - Picking type not only for pickings but also for manufacturing orders
 - Properties replaced by picking type
 - BoM can only be produced with its routing (no other)
 - Either produce without routing with only production orders, or produce with
   routing
 - By default, there is an order in the work orders (serially), but you can
   override it to be able to work in parallel
 - Time clocking on work orders and block time on work centers with reporting
   on OEE, performance, losses, ...
 - Real-time adaptation of timings on operations
 - Lots/serial numbers can be inputted like in the pickings on manufacturing
   orders.  It is also possible to input them in the work orders.
 - Material availability independent of production order state (possibility to
   start production when only part of it is there)
 - Work sheets on work orders
 - Put messages on work orders to make your workers pay attention to something
 - Full traceability link to see for each produced piece of stock, the
   consumed pieces, ...
 - Separate scrap object (a scrap is not done based on an original move
   anymore)
 - Separate unbuild system (if you want to unbuild into its original
   components)

Thanks to all people that helped during this development, notably but not
limited to Chirag A Dodiya (cod@odoo.com), Gaurav Panchal (gan@odoo.com),
Jignesh Rathod (jir@odoo.com), Mansi Trivedi (mtr@odoo.com), Pariket Trivedi
(ptr@odoo.com).

================================= pseudo patch: =================================

--- a/addons/mrp/models/__init__.py
+++ b/addons/mrp/models/__init__.py
@@ -1,14 +1,20 @@
 # -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
+import ir_attachment
 import mrp_config_settings
 import mrp_bom
-import mrp_production
-import mrp_property
+import mrp_message
 import mrp_routing
 import mrp_workcenter
+import mrp_production
+import mrp_unbuild
+import mrp_workorder
 import procurement
 import product
 import res_company
 import stock_move
-import stock_warehouse
\ No newline at end of file
+import stock_picking
+import stock_quant
+import stock_scrap
+import stock_warehouse

--- a/None
+++ b/addons/mrp/models/ir_attachment.py
@@ -0,0 +1,15 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from odoo import fields, models
+
+
+class IrAttachment(models.Model):
+    _inherit = 'ir.attachment'
+    _order = "priority desc, id desc"
+
+    priority = fields.Selection([
+        ('0', 'Normal'),
+        ('1', 'Low'),
+        ('2', 'High'),
+        ('3', 'Very High')], string="Priority", help="Gives the sequence order when displaying a list of tasks.")

--- a/addons/mrp/models/mrp_bom.py
+++ b/addons/mrp/models/mrp_bom.py
@@ -1,24 +1,20 @@
 # -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
-import time
-
-import openerp.addons.decimal_precision as dp
-from openerp.tools import DEFAULT_SERVER_DATE_FORMAT
-
-from odoo import api, fields, models, tools, _
+from odoo import api, fields, models, _
+from odoo.addons import decimal_precision as dp
 from odoo.exceptions import UserError
 
 
-class BoM(models.Model):
-    """ Defines bills of material for a product. """
+class MrpBom(models.Model):
+    """ Defines bills of material for a product or a product template """
     _name = 'mrp.bom'
     _description = 'Bill of Material'
-    _order = "sequence"
-    _rec_name = 'code'
     _inherit = ['mail.thread']
+    _rec_name = 'product_tmpl_id'
+    _order = "sequence"
 
-    def _get_default_product_uom(self):
+    def _get_default_product_uom_id(self):
         return self.env['product.uom'].search([], limit=1, order='id').id
 
     code = fields.Char('Reference')
@@ -27,288 +23,241 @@ class BoM(models.Model):
         help="If the active field is set to False, it will allow you to hide the bills of material without removing it.")
     type = fields.Selection([
         ('normal', 'Manufacture this product'),
-        ('phantom', 'Ship this product as a set of components (kit)')],
-        string='BoM Type', default='normal', required=True,
-        help="Set: When processing a sales order for this product, the delivery order will contain the raw materials, instead of the finished product.")
-    position = fields.Char('Internal Reference', help="Reference to a position in an external plan.")
+        ('phantom', 'Ship this product as a set of components (kit)')], 'BoM Type',
+        default='normal', required=True,
+        help="Kit (Phantom): When processing a sales order for this product, the delivery order will contain the raw materials, instead of the finished product.")
     product_tmpl_id = fields.Many2one(
         'product.template', 'Product',
-        domain="[('type', 'in', ['product', 'consu'])]",
-        required=True)
+        domain="[('type', 'in', ['product', 'consu'])]", required=True)
     product_id = fields.Many2one(
         'product.product', 'Product Variant',
         domain="['&', ('product_tmpl_id', '=', product_tmpl_id), ('type', 'in', ['product', 'consu'])]",
         help="If a product variant is defined the BOM is available only for this product.")
     bom_line_ids = fields.One2many('mrp.bom.line', 'bom_id', 'BoM Lines', copy=True)
     product_qty = fields.Float(
-        'Product Quantity', default=1.0,
-        digits_compute=dp.get_precision('Product Unit of Measure'), required=True)
-    product_uom = fields.Many2one(
+        'Quantity', default=1.0,
+        digits_compute=dp.get_precision('Unit of Measure'), required=True)
+    product_uom_id = fields.Many2one(
         'product.uom', 'Product Unit of Measure',
-        default=_get_default_product_uom, required=True,
+        default=_get_default_product_uom_id, oldname='product_uom', required=True,
         help="Unit of Measure (Unit of Measure) is the unit of measurement for the inventory control")
-    date_start = fields.Date('Valid From', help="Validity of this BoM. Keep empty if it's always valid.")
-    date_stop = fields.Date('Valid Until', help="Validity of this BoM. Keep empty if it's always valid.")
     sequence = fields.Integer('Sequence', help="Gives the sequence order when displaying a list of bills of material.")
     routing_id = fields.Many2one(
         'mrp.routing', 'Routing',
-        help="The list of operations (list of work centers) to produce the finished product. "
-             "The routing is mainly used to compute work center costs during operations and to "
-             "plan future loads on work centers based on production planning.")
-    product_rounding = fields.Float(
-        'Product Rounding', default=0.0,
-        help="Rounding applied on the product quantity.")
-    product_efficiency = fields.Float(
-        'Manufacturing Efficiency',
-        default=1.0, required=True,
-        help="A factor of 0.9 means a loss of 10% during the production process.")
-    property_ids = fields.Many2many('mrp.property', string='Properties')
+        help="The operations for producing this BoM.  When a routing is specified, the production orders will "
+             " be executed through work orders, otherwise everything is processed in the production order itself. ")
+    ready_to_produce = fields.Selection([
+        ('all_available', 'All components available'),
+        ('asap', 'The components of 1st operation')], string='Manufacturing Readiness',
+        default='asap', required=True)
+    picking_type_id = fields.Many2one(
+        'stock.picking.type', 'Picking Type', domain=[('code', '=', 'mrp_operation')],
+        help="When a procurement has a ‘produce’ route with a picking type set, it will try to create "
+             "a Manufacturing Order for that product using a BoM of the same picking type. That allows "
+             "to define procurement rules which trigger different manufacturing orders with different BoMs. ")
     company_id = fields.Many2one(
         'res.company', 'Company',
         default=lambda self: self.env['res.company']._company_default_get('mrp.bom'),
         required=True)
 
-    @api.multi
-    def name_get(self):
-        return [(bom.id, '%s%s' % (bom.code and '[%s]' % bom.code or '', bom.product_tmpl_id.name)) for bom in self]
-
-    @api.multi
-    def unlink(self):
-        if self.env['mrp.production'].search([('bom_id', 'in', self.ids), ('state', 'not in', ['done', 'cancel'])], limit=1):
-            raise UserError(_('You can not delete a Bill of Material with running manufacturing orders.\nPlease close or cancel it first.'))
-        return super(BoM, self).unlink()
-
-    @api.onchange('product_uom')
-    def onchange_product_uom(self):
+    @api.onchange('product_uom_id')
+    def onchange_product_uom_id(self):
         res = {}
-        if not self.product_uom or not self.product_tmpl_id:
-            return res
-        if self.product_uom.category_id != self.product_tmpl_id.uom_id.category_id:
+        if not self.product_uom_id or not self.product_tmpl_id:
+            return
+        if self.product_uom_id.category_id.id != self.product_tmpl_id.uom_id.category_id.id:
+            self.product_uom_id = self.product_tmpl_id.uom_id.id
             res['warning'] = {'title': _('Warning'), 'message': _('The Product Unit of Measure you chose has a different category than in the product form.')}
-            self.product_uom = self.product_id.uom_id.id
         return res
 
     @api.onchange('product_tmpl_id')
     def onchange_product_tmpl_id(self):
         if self.product_tmpl_id:
-            self.product_uom = self.product_tmpl_id.uom_id.id
+            self.product_uom_id = self.product_tmpl_id.uom_id.id
 
-    @api.model
-    @api.returns('self', lambda value: value.id)
-    def _bom_find(self, product_tmpl_id=None, product_id=None, properties=None, company_id=False):
-        """ Finds BoM for particular product and product uom. """
-        if properties is None:
-            properties = []
+    @api.multi
+    def name_get(self):
+        return [(bom.id, '%s%s' % (bom.code and '%s: ' % bom.code or '', bom.product_tmpl_id.display_name)) for bom in self]
 
-        domain = ['|', ('date_start', '=', False), ('date_start', '<=', time.strftime(DEFAULT_SERVER_DATE_FORMAT)),
-                  '|', ('date_stop', '=', False), ('date_stop', '>=', time.strftime(DEFAULT_SERVER_DATE_FORMAT))]
-        if product_id:
-            if not product_tmpl_id:
-                product_tmpl_id = self.env['product.product'].browse(product_id).product_tmpl_id.id
-            domain += ['|',
-                       ('product_id', '=', product_id),
-                       '&', ('product_id', '=', False), ('product_tmpl_id', '=', product_tmpl_id)]
-        elif product_tmpl_id:
-            domain += [('product_id', '=', False), ('product_tmpl_id', '=', product_tmpl_id)]
+    @api.multi
+    def unlink(self):
+        if self.env['mrp.production'].search([('bom_id', 'in', self.ids), ('state', 'not in', ['done', 'cancel'])], limit=1):
+            raise UserError(_('You can not delete a Bill of Material with running manufacturing orders.\nPlease close or cancel it first.'))
+        return super(MrpBom, self).unlink()
+
+    @api.model
+    def _bom_find(self, product_tmpl=None, product=None, picking_type=None, company_id=False):
+        """ Finds BoM for particular product, picking and company """
+        if product:
+            if not product_tmpl:
+                product_tmpl = product.product_tmpl_id
+            domain = ['|', ('product_id', '=', product.id), '&', ('product_id', '=', False), ('product_tmpl_id', '=', product_tmpl.id)]
+        elif product_tmpl:
+            domain = [('product_tmpl_id', '=', product_tmpl.id)]
         else:
             # neither product nor template, makes no sense to search
             return False
-        if self._context.get('company_id', company_id):
-            domain += [('company_id', '=', self._context.get('company_id', company_id))]
+        if picking_type:
+            domain += ['|', ('picking_type_id', '=', picking_type.id), ('picking_type_id', '=', False)]
+        if company_id or self.env.context.get('company_id'):
+            domain = domain + [('company_id', '=', company_id or self.env.context.get('company_id'))]
         # order to prioritize bom with product_id over the one without
-        boms = self.search(domain, order='sequence, product_id')
-        # Search a BoM which has all properties specified, or if you can not find one, you could
-        # pass a BoM without any properties with the smallest sequence
-        bom_empty_prop = self.env['mrp.bom']
-        for bom in boms:
-            if not set(bom.property_ids.ids) - set(properties):
-                if not properties or bom.property_ids:
-                    return bom
-                elif not bom_empty_prop:
-                    bom_empty_prop = bom
-        return bom_empty_prop
+        return self.search(domain, order='sequence, product_id', limit=1)
 
-    @api.multi
-    def _prepare_wc_line(self, routing_workcenter, level=0, factor=1):
-        workcenter = routing_workcenter.workcenter_id
-        d, m = divmod(factor, routing_workcenter.workcenter_id.capacity_per_cycle)
-        mult = (d + (m and 1.0 or 0.0))
-        cycle = mult * routing_workcenter.cycle_nbr
-        return {
-            'name': tools.ustr(routing_workcenter.name) + ' - ' + tools.ustr(self.product_tmpl_id.name_get()[0][1]),
-            'workcenter_id': workcenter.id,
-            'sequence': level + (routing_workcenter.sequence or 0),
-            'cycle': cycle,
-            'hour': float(routing_workcenter.hour_nbr * mult + ((workcenter.time_start or 0.0) + (workcenter.time_stop or 0.0) + cycle * (workcenter.time_cycle or 0.0)) * (workcenter.time_efficiency or 100)),
-        }
-
-    @api.model
-    def _prepare_consume_line(self, bom_line_id, quantity):
-        return {
-            'name': bom_line_id.product_id.name,
-            'product_id': bom_line_id.product_id.id,
-            'product_qty': quantity,
-            'product_uom': bom_line_id.product_uom.id
-        }
-
-    @api.model
-    def _bom_explode(self, bom, product, factor, properties=None, level=0, routing_id=False, previous_products=None, master_bom=None):
-        """ Finds Products and Work Centers for related BoM for manufacturing order.
-        @param bom: BoM of particular product template.
-        @param product: Select a particular variant of the BoM. If False use BoM without variants.
-        @param factor: Factor represents the quantity, but in UoM of the BoM, taking into account the numbers produced by the BoM
-        @param properties: A List of properties Ids.
-        @param level: Depth level to find BoM lines starts from 10.
-        @param previous_products: List of product previously use by bom explore to avoid recursion
-        @param master_bom: When recursion, used to display the name of the master bom
-        @return: result: List of dictionaries containing product details.
-                 result2: List of dictionaries containing Work Center details.
-        """
-        UoM = self.env["product.uom"]
-        Routing = self.env['mrp.routing']
-        master_bom = master_bom or bom
+    def explode(self, product, quantity, picking_type=False):
+        boms_done = [(self, {'qty': quantity, 'product': product, 'original_qty': quantity})]
+        lines_done = []
+        templates_done = self.env['product.template']
 
-        def _factor(factor, product_efficiency, product_rounding):
-            factor = factor / (product_efficiency or 1.0)
-            if product_rounding:
-                factor = tools.float_round(factor,
-                                           precision_rounding=product_rounding,
-                                           rounding_method='UP')
-            if factor < product_rounding:
-                factor = product_rounding
-            return factor
+        bom_lines = [(bom_line, product, quantity) for bom_line in self.bom_line_ids]
+        while bom_lines:
+            current_line, current_product, current_qty = bom_lines[0]
+            bom_lines = bom_lines[1:]
 
-        factor = _factor(factor, bom.product_efficiency, bom.product_rounding)
-
-        result = []
-        result2 = []
-
-        routing = (routing_id and Routing.browse(routing_id)) or bom.routing_id or False
-        if routing:
-            for wc_use in routing.workcenter_lines:
-                result2.append(bom._prepare_wc_line(wc_use, level=level, factor=factor))
-
-        for bom_line_id in bom.bom_line_ids:
-            if bom_line_id._skip_bom_line(product):
+            if current_line._skip_bom_line(current_product):
                 continue
-            if set(map(int, bom_line_id.property_ids or [])) - set(properties or []):
-                continue
-
-            if previous_products and bom_line_id.product_id.product_tmpl_id.id in previous_products:
-                raise UserError(_('BoM "%s" contains a BoM line with a product recursion: "%s".') % (master_bom.code or "", bom_line_id.product_id.name_get()[0][1]))
+            if current_line.product_id.product_tmpl_id in templates_done:
+                raise UserError(_('Recursion error !'))
 
-            quantity = _factor(bom_line_id.product_qty * factor, bom_line_id.product_efficiency, bom_line_id.product_rounding)
-            new_bom = self._bom_find(product_id=bom_line_id.product_id.id, properties=properties)
+            line_quantity = current_qty * current_line.product_qty / current_line.bom_id.product_qty
 
-            # If BoM should not behave like kit, just add the product, otherwise explode further
-            if not new_bom or new_bom.type != "phantom":
-                result.append(self._prepare_consume_line(bom_line_id, quantity))
+            bom = self._bom_find(product=current_line.product_id, picking_type=picking_type or self.picking_type_id, company_id=self.company_id.id)
+            if bom.type == 'phantom':
+                converted_line_quantity = self.env['product.uom']._compute_qty_obj(current_line.product_uom_id, line_quantity, bom.product_uom_id)
+                bom_lines = [(line, current_line.product_id, line_quantity) for line in bom.bom_line_ids] + bom_lines
+                templates_done |= current_line.product_id.product_tmpl_id
+                boms_done.append((bom, {'qty': converted_line_quantity, 'product': current_product, 'original_qty': quantity}))
             else:
-                all_prod = [bom.product_tmpl_id.id] + (previous_products or [])
-                # We need to convert to units/UoM of chosen BoM
-                factor2 = UoM._compute_qty_obj(bom_line_id.product_uom, quantity, new_bom.product_uom)
-                quantity2 = factor2 / new_bom.product_qty
-                res = self._bom_explode(
-                    new_bom, bom_line_id.product_id, quantity2,
-                    properties=properties, level=level + 10, previous_products=all_prod, master_bom=master_bom)
-                result = result + res[0]
-                result2 = result2 + res[1]
-        return result, result2
+                lines_done.append((current_line, {'qty': line_quantity, 'product': current_product, 'original_qty': quantity}))
 
+        return boms_done, lines_done
 
-class BoMLine(models.Model):
+
+class MrpBomLine(models.Model):
     _name = 'mrp.bom.line'
     _order = "sequence"
     _rec_name = "product_id"
 
+    def _get_default_product_uom_id(self):
+        return self.env['product.uom'].search([], limit=1, order='id').id
+
     product_id = fields.Many2one(
-        'product.product', 'Product',
-        required=True)
+        'product.product', 'Product', required=True)
     product_qty = fields.Float(
         'Product Quantity', default=1.0,
         digits_compute=dp.get_precision('Product Unit of Measure'), required=True)
-    product_uom = fields.Many2one(
+    product_uom_id = fields.Many2one(
         'product.uom', 'Product Unit of Measure',
-        default=lambda self: self.env['mrp.bom']._get_default_product_uom(),
-        required=True,
+        default=_get_default_product_uom_id,
+        oldname='product_uom', required=True,
         help="Unit of Measure (Unit of Measure) is the unit of measurement for the inventory control")
-    date_start = fields.Date('Valid From', help="Validity of component. Keep empty if it's always valid.")
-    date_stop = fields.Date('Valid Until', help="Validity of component. Keep empty if it's always valid.")
     sequence = fields.Integer(
         'Sequence', default=1,
         help="Gives the sequence order when displaying.")
     routing_id = fields.Many2one(
         'mrp.routing', 'Routing',
-        help="The list of operations (list of work centers) to produce the finished product. The "
-             "routing is mainly used to compute work center costs during operations and to plan "
-             "future loads on work centers based on production planning.")
-    product_rounding = fields.Float(
-        'Product Rounding', default=0.0,
-        help="Rounding applied on the product quantity.")
-    product_efficiency = fields.Float(
-        'Manufacturing Efficiency',
-        default=1.0, required=True,
-        help="A factor of 0.9 means a loss of 10% within the production process.")
-    property_ids = fields.Many2many('mrp.property', string='Properties')  # Not used
+        related='bom_id.routing_id', store=True,
+        help="The list of operations to produce the finished product. The routing is mainly used to "
+             "compute work center costs during operations and to plan future loads on work centers "
+             "based on production planning.")
     bom_id = fields.Many2one(
         'mrp.bom', 'Parent BoM',
         index=True, ondelete='cascade', required=True)
     attribute_value_ids = fields.Many2many(
         'product.attribute.value', string='Variants',
         help="BOM Product Variants needed form apply this line.")
+    operation_id = fields.Many2one(
+        'mrp.routing.workcenter', 'Consumed in Operation',
+        help="The operation where the components are consumed, or the finished products created.")
+    child_bom_id = fields.Many2one(
+        'mrp.bom', 'Sub BoM', compute='_compute_child_bom_id')
     child_line_ids = fields.One2many(
         'mrp.bom.line', string="BOM lines of the referred bom",
         compute='_compute_child_line_ids')
+    has_attachments = fields.Boolean('Has Attachments', compute='_compute_has_attachments')
+
+    _sql_constraints = [
+        ('bom_qty_zero', 'CHECK (product_qty>0)', 'All product quantities must be greater than 0.\n'
+            'You should install the mrp_byproduct module if you want to manage extra products on BoMs !'),
+    ]
 
     @api.one
-    @api.depends('product_id')
-    def _compute_child_line_ids(self):
-        """ If the BOM line refers to a BOM, return the ids of the child BOM lines """
+    @api.depends('product_id', 'bom_id')
+    def _compute_child_bom_id(self):
         if not self.product_id:
-            self.child_line_ids = False
-            return
-        bom = self.env['mrp.bom']._bom_find(
-            product_tmpl_id=self.product_id.product_tmpl_id.id,
-            product_id=self.product_id.id)
-        if bom:
-            self.child_line_ids = bom.bom_line_ids.ids
+            self.child_bom_id = False
         else:
-            self.child_line_ids = False
+            self.child_bom_id = self.env['mrp.bom']._bom_find(
+                product_tmpl=self.product_id.product_tmpl_id,
+                product=self.product_id,
+                picking_type=self.bom_id.picking_type_id)
 
-    _sql_constraints = [
-        ('bom_qty_zero', 'CHECK (product_qty>0)', 'All product quantities must be greater than 0.\n' \
-            'You should install the mrp_byproduct module if you want to manage extra products on BoMs !'),
-    ]
+    @api.one
+    @api.depends('product_id')
+    def _compute_has_attachments(self):
+        nbr_attach = self.env['ir.attachment'].search_count([
+            '|',
+            '&', ('res_model', '=', 'product.product'), ('res_id', '=', self.product_id.id),
+            '&', ('res_model', '=', 'product.template'), ('res_id', '=', self.product_id.product_tmpl_id.id)])
+        self.has_attachments = bool(nbr_attach)
 
-    @api.model
-    def create(self, values):
-        if 'product_id' in values and not values.get('product_uom'):
-            values['product_uom'] = self.env['product.product'].browse(values['product_id']).uom_id.id
-        return super(BoMLine, self).create(values)
+    @api.one
+    @api.depends('child_bom_id')
+    def _compute_child_line_ids(self):
+        """ If the BOM line refers to a BOM, return the ids of the child BOM lines """
+        self.child_line_ids = self.child_bom_id.bom_line_ids.ids
 
-    @api.onchange('product_uom')
-    def onchange_uom(self):
+    @api.onchange('product_uom_id')
+    def onchange_product_uom_id(self):
         res = {}
-        if not self.product_uom or not self.product_id:
+        if not self.product_uom_id or not self.product_id:
             return res
-        if self.product_uom.category_id != self.product_id.uom_id.category_id:
+        if self.product_uom_id.category_id != self.product_id.uom_id.category_id:
+            self.product_uom_id = self.product_id.uom_id.id
             res['warning'] = {'title': _('Warning'), 'message': _('The Product Unit of Measure you chose has a different category than in the product form.')}
-            self.product_uom = self.product_id.uom_id.id
         return res
 
     @api.onchange('product_id')
     def onchange_product_id(self):
         if self.product_id:
-            self.product_uom = self.product_id.uom_id.id
+            self.product_uom_id = self.product_id.uom_id.id
+
+    @api.model
+    def create(self, values):
+        if 'product_id' in values and 'product_uom_id' not in values:
+            values['product_uom_id'] = self.env['product.product'].browse(values['product_id']).uom_id.id
+        return super(MrpBomLine, self).create(values)
 
     def _skip_bom_line(self, product):
         """ Control if a BoM line should be produce, can be inherited for add
-        custom control. """
-        if self.date_start and self.date_start > time.strftime(DEFAULT_SERVER_DATE_FORMAT) or \
-                self.date_stop and self.date_stop < time.strftime(DEFAULT_SERVER_DATE_FORMAT):
-            return True
-        # all bom_line_id variant values must be in the product
+        custom control. It currently checks that all variant values are in the
+        product. """
         if self.attribute_value_ids:
-            if not product or (set(self.attribute_value_ids.ids) - set(product.attribute_value_ids.ids)):
+            if not product or self.attribute_value_ids - product.attribute_value_ids:
                 return True
         return False
+
+    @api.multi
+    def action_see_attachments(self):
+        domain = [
+            '|',
+            '&', ('res_model', '=', 'product.product'), ('res_id', '=', self.product_id.id),
+            '&', ('res_model', '=', 'product.template'), ('res_id', '=', self.product_id.product_tmpl_id.id)]
+        attachment_view = self.env.ref('mrp.view_document_file_kanban_mrp')
+        return {
+            'name': _('Attachments'),
+            'domain': domain,
+            'res_model': 'ir.attachment',
+            'type': 'ir.actions.act_window',
+            'view_id': attachment_view.id,
+            'views': [(attachment_view.id, 'kanban'), (False, 'form')],
+            'view_mode': 'kanban,tree,form',
+            'view_type': 'form',
+            'help': _('''<p class="oe_view_nocontent_create">
+                        Documents are attached to the tasks and issues of your project.</p><p>
+                        Send messages or log internal notes with attachments to link
+                        documents to your project.
+                    </p>'''),
+            'limit': 80,
+            'context': "{'default_res_model': '%s','default_res_id': %d}" % ('product.product', self.product_id.id)
+        }

--- a/addons/mrp/models/mrp_config_settings.py
+++ b/addons/mrp/models/mrp_config_settings.py
@@ -13,11 +13,6 @@ class MrpConfigSettings(models.TransientModel):
         (1, 'Products can have several attributes, defining variants (Example: size, color,...)')], "Product Variants",
         help='Work with product variant allows you to define some variant of the same products, an ease the product management in the ecommerce for example',
         implied_group='product.group_product_variant')
-    module_mrp_operations = fields.Selection([
-        (0, "Do not use a planning for the work orders "),
-        (1, "Allow detailed planning of work orders")], "Work Order Planning",
-        help='This allows to add state, date_start,date_stop in production order operation lines (in the "Work Centers" tab).\n'
-             '-This installs the module mrp_operations.')
     module_mrp_byproduct = fields.Selection([
         (0, "No by-products in bills of materials (A + B --> C)"),
         (1, "Bills of materials may produce residual products (A + B --> C + D)")], "By-Products",
@@ -25,15 +20,22 @@ class MrpConfigSettings(models.TransientModel):
              'Without this module: A + B + C -> D.\n'
              'With this module: A + B + C -> D + E.\n'
              '-This installs the module mrp_byproduct.')
+    module_mrp_plm = fields.Selection([
+        (0, "No product lifecycle management"),
+        (1, "Manage engineering changes, versions and documents")
+        ], string="PLM")
+    module_mrp_maintenance = fields.Selection([
+        (0, "No maintenance machine and work centers"),
+        (1, "Preventive and Corrective maintenance management")
+        ], string="Maintenance")
+    module_quality_mrp = fields.Selection([
+        (0, "No quality control"),
+        (1, "Manage quality control points, checks and measures")
+        ], string="Quality")
     group_mrp_routings = fields.Selection([
         (0, "Manage production by manufacturing orders"),
-        (1, "Manage production by work orders")], "Routings",
+        (1, "Manage production by work orders")], "Routings & Planning",
         implied_group='mrp.group_mrp_routings',
         help='Work Order Operations allow you to create and manage the manufacturing operations that should be followed '
              'within your work centers in order to produce a product. They are attached to bills of materials '
              'that will define the required raw materials.')
-    group_rounding_efficiency = fields.Selection([
-        (0, "No rounding and efficiency on bills of materials"),
-        (1, "Manage rounding and efficiency of bills of materials components")], "Rounding efficiency",
-        implied_group='mrp.group_rounding_efficiency',
-        help="""Allow to manage product rounding on quantity and product efficiency during production process""")

--- a/None
+++ b/addons/mrp/models/mrp_message.py
@@ -0,0 +1,36 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from datetime import datetime
+from dateutil.relativedelta import relativedelta
+
+from odoo import api, fields, models
+from odoo.tools import html2plaintext
+
+
+class MrpProductionMessage(models.Model):
+    _name = "mrp.message"
+    _description = "Production Message"
+
+    @api.model
+    def _default_valid_until(self):
+        return datetime.today() + relativedelta(days=7)
+
+    name = fields.Text(compute='_get_note_first_line', store=True)
+    message = fields.Html(required=True)
+    product_tmpl_id = fields.Many2one('product.template', 'Product Template')
+    product_id = fields.Many2one('product.product', string="Product")
+    bom_id = fields.Many2one('mrp.bom', 'Bill of Material', domain="[('product_id', '=', product_id)]")
+    workcenter_id = fields.Many2one('mrp.workcenter', string='Work Center')
+    valid_until = fields.Date('Validity Date', default=_default_valid_until, required=True)
+    routing_id = fields.Many2one('mrp.routing', string='Routing')
+
+    @api.depends('message')
+    def _get_note_first_line(self):
+        for message in self:
+            message.name = (message.message and html2plaintext(message.message) or "").strip().replace('*', '').split("\n")[0]
+
+    @api.multi
+    def save(self):
+        """ Used in a wizard-like form view, manual save button when in edit mode """
+        return True

--- a/addons/mrp/models/mrp_production.py
+++ b/addons/mrp/models/mrp_production.py
@@ -1,844 +1,538 @@
 # -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
-import time
-from collections import OrderedDict
-
-import openerp.addons.decimal_precision as dp
-from openerp.tools import float_compare, float_is_zero
-from openerp import SUPERUSER_ID
-from openerp.exceptions import UserError, AccessError
+from collections import defaultdict
+import math
 
 from odoo import api, fields, models, _
+from odoo.addons import decimal_precision as dp
+from odoo.exceptions import UserError
 
 
 class MrpProduction(models.Model):
     """ Manufacturing Orders """
     _name = 'mrp.production'
-    _inherit = ['mail.thread', 'ir.needaction_mixin']
     _description = 'Manufacturing Order'
-    _date_name = 'date_planned'
-    _order = 'priority desc, date_planned asc'
+    _date_name = 'date_planned_start'
+    _inherit = ['mail.thread', 'ir.needaction_mixin']
+    _order = 'date_planned_start asc,id'
+
+    @api.model
+    def _get_default_picking_type(self):
+        return self.env['stock.picking.type'].search([
+            ('code', '=', 'mrp_operation'),
+            ('warehouse_id.company_id', 'in', [self.env.context.get('company_id', self.env.user.company_id.id), False])],
+            limit=1).id
 
     @api.model
     def _get_default_location_src_id(self):
-        location = self.env.ref('stock.stock_location_stock', raise_if_not_found=False)
-        if location:
-            try:
-                location.check_access_rule('read')
-                return location.id
-            except AccessError:
-                pass
-        return False
+        location = False
+        if self._context.get('default_picking_type_id'):
+            location = self.env['stock.picking.type'].browse(self.env.context['default_picking_type_id']).default_location_src_id
+        if not location:
+            location = self.env.ref('stock.stock_location_stock', raise_if_not_found=False)
+        return location and location.id or False
 
     @api.model
     def _get_default_location_dest_id(self):
-        return self._get_default_location_src_id()
+        location = False
+        if self._context.get('default_picking_type_id'):
+            location = self.env['stock.picking.type'].browse(self.env.context['default_picking_type_id']).default_location_dest_id
+        if not location:
+            location = self.env.ref('stock.stock_location_stock', raise_if_not_found=False)
+        return location and location.id or False
 
     name = fields.Char(
-        'Reference',
-        copy=False, default=lambda self: self.env['ir.sequence'].next_by_code('mrp.production') or '/',
-        readonly=True, required=True,
-        states={'draft': [('readonly', False)]})
+        'Reference', copy=False, readonly=True, default=lambda x: _('New'))
     origin = fields.Char(
-        'Source Document',
-        copy=False, readonly=True,
-        states={'draft': [('readonly', False)]},
+        'Source', copy=False,
         help="Reference of the document that generated this production order request.")
-    priority = fields.Selection([
-        ('0', 'Not urgent'),
-        ('1', 'Normal'),
-        ('2', 'Urgent'),
-        ('3', 'Very Urgent')], 'Priority',
-        default='1', index=True, readonly=True,
-        states=dict.fromkeys(['draft', 'confirmed'], [('readonly', False)]))
 
     product_id = fields.Many2one(
         'product.product', 'Product',
         domain=[('type', 'in', ['product', 'consu'])],
         readonly=True, required=True,
-        states={'draft': [('readonly', False)]})
-    product_tmpl_id = fields.Many2one(
-        'product.template', 'Product Template',
-        related='product_id.product_tmpl_id')
+        states={'confirmed': [('readonly', False)]})
+    product_tmpl_id = fields.Many2one('product.template', 'Product Template', related='product_id.product_tmpl_id')
     product_qty = fields.Float(
-        'Product Quantity',
+        'Quantity to Produce',
         default=1.0, digits_compute=dp.get_precision('Product Unit of Measure'),
         readonly=True, required=True,
-        states={'draft': [('readonly', False)]})
-    product_uom = fields.Many2one(
+        states={'confirmed': [('readonly', False)]})
+    product_uom_id = fields.Many2one(
         'product.uom', 'Product Unit of Measure',
-        readonly=True, required=True,
-        states={'draft': [('readonly', False)]})
-    progress = fields.Float('Production progress', compute='_compute_progress')
-
+        oldname='product_uom', readonly=True, required=True,
+        states={'confirmed': [('readonly', False)]})
+    picking_type_id = fields.Many2one(
+        'stock.picking.type', 'Picking Type',
+        default=_get_default_picking_type, required=True)
     location_src_id = fields.Many2one(
         'stock.location', 'Raw Materials Location',
         default=_get_default_location_src_id,
         readonly=True,  required=True,
-        states={'draft': [('readonly', False)]},
+        states={'confirmed': [('readonly', False)]},
         help="Location where the system will look for components.")
     location_dest_id = fields.Many2one(
         'stock.location', 'Finished Products Location',
         default=_get_default_location_dest_id,
         readonly=True,  required=True,
-        states={'draft': [('readonly', False)]},
+        states={'confirmed': [('readonly', False)]},
         help="Location where the system will stock the finished products.")
-    date_planned = fields.Datetime(
-        'Scheduled Date',
-        copy=False, default=fields.Datetime.now,
+    date_planned_start = fields.Datetime(
+        'Expected Start Date', copy=False, default=fields.Datetime.now,
         index=True, required=True, readonly=True,
-        states={'draft': [('readonly', False)]})
+        states={'confirmed': [('readonly', False)]}, oldname="date_planned")
+    date_planned_finished = fields.Datetime(
+        'Expected End Date', copy=False, default=fields.Datetime.now,
+        index=True, readonly=True,
+        states={'confirmed': [('readonly', False)]})
     date_start = fields.Datetime('Start Date', copy=False, index=True, readonly=True)
     date_finished = fields.Datetime('End Date', copy=False, index=True, readonly=True)
     bom_id = fields.Many2one(
         'mrp.bom', 'Bill of Material',
-        readonly=True, states={'draft': [('readonly', False)]},
+        readonly=True, states={'confirmed': [('readonly', False)]},
         help="Bill of Materials allow you to define the list of required raw materials to make a finished product.")
     routing_id = fields.Many2one(
         'mrp.routing', 'Routing',
-        on_delete='set null', readonly=True,
-        states={'draft': [('readonly', False)]},
+        readonly=True, related='bom_id.routing_id', store=True,
         help="The list of operations (list of work centers) to produce the finished product. The routing "
              "is mainly used to compute work center costs during operations and to plan future loads on "
-             "work centers based on production plannification.")
-    move_prod_id = fields.Many2one(
-        'stock.move', 'Product Move',
-        copy=False, readonly=True)
-    move_lines = fields.One2many(
-        'stock.move', 'raw_material_production_id', 'Products to Consume',
-        domain=[('state', 'not in', ('done', 'cancel'))],
-        readonly=True, states={'draft': [('readonly', False)]})
-    move_lines2 = fields.One2many(
-        'stock.move', 'raw_material_production_id', 'Consumed Products',
-        domain=[('state', 'in', ('done', 'cancel'))],
-        readonly=True)
-    move_created_ids = fields.One2many(
-        'stock.move', 'production_id', 'Products to Produce',
-        domain=[('state', 'not in', ('done', 'cancel'))],
-        readonly=True)
-    move_created_ids2 = fields.One2many(
-        'stock.move', 'production_id', 'Produced Products',
-        domain=[('state', 'in', ('done', 'cancel'))],
-        readonly=True)
-    product_lines = fields.One2many(
-        'mrp.production.product.line', 'production_id', 'Scheduled goods',
-        readonly=True)
-    workcenter_lines = fields.One2many(
-        'mrp.production.workcenter.line', 'production_id', 'Work Centers Utilisation',
-        readonly=True,
-        states={'draft': [('readonly', False)]})
+             "work centers based on production planning.")
+    move_raw_ids = fields.One2many(
+        'stock.move', 'raw_material_production_id', 'Raw Materials', oldname='move_lines',
+        copy=False, states={'done': [('readonly', True)], 'cancel': [('readonly', True)]}, 
+        domain=[('scrapped', '=', False)])
+    move_finished_ids = fields.One2many(
+        'stock.move', 'production_id', 'Finished Products',
+        copy=False, states={'done': [('readonly', True)], 'cancel': [('readonly', True)]}, 
+        domain=[('scrapped', '=', False)])
+    workorder_ids = fields.One2many(
+        'mrp.workorder', 'production_id', 'Work Orders',
+        copy=False, oldname='workcenter_lines', readonly=True)
+    workorder_count = fields.Integer('# Work Orders', compute='_compute_workorder_count')
+    workorder_done_count = fields.Integer('# Done Work Orders', compute='_compute_workorder_done_count')
+
     state = fields.Selection([
-        ('draft', 'New'),
-        ('cancel', 'Cancelled'),
-        ('confirmed', 'Awaiting Raw Materials'),
-        ('ready', 'Ready to Produce'),
-        ('in_production', 'Production Started'),
-        ('done', 'Done')], string='Status',
-        copy=False, default='draft', readonly=True, track_visibility='onchange',
-        help="When the production order is created the status is set to 'Draft'.\n"
-             "If the order is confirmed the status is set to 'Waiting Goods.\n"
-             "If any exceptions are there, the status is set to 'Picking Exception.\n"
-             "If the stock is available then the status is set to 'Ready to Produce.\n"
-             "When the production gets started then the status is set to 'In Production.\n"
-             "When the production is over, the status is set to 'Done'.")
-    hour_total = fields.Float('Total Hours', compute='_compute_hour_total', store=True)
-    cycle_total = fields.Float('Total Cycles', compute='_compute_cycle_total', store=True)
+        ('confirmed', 'Confirmed'),
+        ('planned', 'Planned'),
+        ('progress', 'In Progress'),
+        ('done', 'Done'),
+        ('cancel', 'Cancelled')], string='State',
+        copy=False, default='confirmed', track_visibility='onchange')
+    availability = fields.Selection([
+        ('assigned', 'Available'),
+        ('partially_available', 'Partially Available'),
+        ('waiting', 'Waiting'),
+        ('none', 'None')], string='Availability',
+        compute='_compute_availability', store=True)
+
+    post_visible = fields.Boolean(
+        'Inventory Post Visible', compute='_compute_post_visible',
+        help='Technical field to check when we can post')
+
     user_id = fields.Many2one('res.users', 'Responsible', default=lambda self: self._uid)
     company_id = fields.Many2one(
         'res.company', 'Company',
         default=lambda self: self.env['res.company']._company_default_get('mrp.production'),
         required=True)
-    ready_production = fields.Boolean(
-        "Ready for production", compute='_compute_ready_production', store=True)
+
+    check_to_done = fields.Boolean(compute="_get_produced_qty", string="Check Produced Qty", 
+        help="Technical Field to see if we can show 'Mark as Done' button")
+    qty_produced = fields.Float(compute="_get_produced_qty", string="Quantity Produced")
+    procurement_group_id = fields.Many2one(
+        'procurement.group', 'Procurement Group',
+        copy=False)
+    procurement_ids = fields.One2many('procurement.order', 'production_id', 'Related Procurements')
+    propagate = fields.Boolean(
+        'Propagate cancel and split',
+        help='If checked, when the previous move of the move (which was generated by a next procurement) is cancelled or split, the move generated by this move will too')
+    has_moves = fields.Boolean(compute='_has_moves')
+    scrap_ids = fields.One2many('stock.scrap', 'production_id', 'Scraps')
+    scrap_count = fields.Integer(compute='_compute_scrap_move_count', string='Scrap Move')
+
+    @api.multi
+    @api.depends('workorder_ids')
+    def _compute_workorder_count(self):
+        data = self.env['mrp.workorder'].read_group([('production_id', 'in', self.ids)], ['production_id'], ['production_id'])
+        count_data = dict((item['production_id'][0], item['production_id_count']) for item in data)
+        for production in self:
+            production.workorder_count = count_data.get(production.id, 0)
+
+    @api.multi
+    @api.depends('workorder_ids.state')
+    def _compute_workorder_done_count(self):
+        data = self.env['mrp.workorder'].read_group([
+            ('production_id', 'in', self.ids),
+            ('state', '=', 'done')], ['production_id'], ['production_id'])
+        count_data = dict((item['production_id'][0], item['production_id_count']) for item in data)
+        for production in self:
+            production.workorder_done_count = count_data.get(production.id, 0)
+
+    @api.multi
+    @api.depends('move_raw_ids.state', 'move_raw_ids.partially_available', 'workorder_ids.move_raw_ids', 'bom_id.ready_to_produce')
+    def _compute_availability(self):
+        for order in self:
+            if not order.move_raw_ids:
+                order.availability = 'none'
+                continue
+            if order.bom_id.ready_to_produce == 'all_available':
+                order.availability = any(move.state not in ('assigned', 'done', 'cancel') for move in order.move_raw_ids) and 'waiting' or 'assigned'
+            else:
+                partial_list = [x.partially_available and x.state in ('waiting', 'confirmed', 'assigned') for x in order.move_raw_ids]
+                assigned_list = [x.state in ('assigned', 'done', 'cancel') for x in order.move_raw_ids]
+                order.availability = (all(assigned_list) and 'assigned') or (any(partial_list) and 'partially_available') or 'waiting'
+
+    @api.multi
+    @api.depends('move_raw_ids.quantity_done', 'move_finished_ids.quantity_done')
+    def _compute_post_visible(self):
+        for order in self:
+            order.post_visible = any(order.move_raw_ids.filtered(lambda x: (x.quantity_done) > 0 and (x.state not in ['done', 'cancel']))) or \
+                any(order.move_finished_ids.filtered(lambda x: (x.quantity_done) > 0 and (x.state not in ['done', 'cancel'])))
+
+    @api.multi
+    @api.depends('workorder_ids.state', 'move_finished_ids')
+    def _get_produced_qty(self):
+        for production in self:
+            done_moves = production.move_finished_ids.filtered(lambda x: x.state != 'cancel' and x.product_id.id == production.product_id.id)
+            qty_produced = sum(done_moves.mapped('quantity_done'))
+            wo_done = True
+            if any([x.state not in ('done', 'cancel') for x in production.workorder_ids]):
+                wo_done = False
+            production.check_to_done = done_moves and (qty_produced >= production.product_qty) and (production.state not in ('done', 'cancel')) and wo_done
+            production.qty_produced = qty_produced
+        return True
+
+    @api.multi
+    @api.depends('move_raw_ids')
+    def _has_moves(self):
+        for mo in self:
+            mo.has_moves = any(mo.move_raw_ids)
+
+    @api.multi
+    def _compute_scrap_move_count(self):
+        data = self.env['stock.scrap'].read_group([('production_id', 'in', self.ids)], ['production_id'], ['production_id'])
+        count_data = dict((item['production_id'][0], item['production_id_count']) for item in data)
+        for production in self:
+            production.scrap_count = count_data.get(production.id, 0)
+
 
     _sql_constraints = [
         ('name_uniq', 'unique(name, company_id)', 'Reference must be unique per Company!'),
+        ('qty_positive', 'check (product_qty > 0)', 'The quantity to produce must be positive!'),
     ]
 
-    @api.one
-    def _compute_progress(self):
-        """ Return product quantity percentage """
-        if self.product_qty:
-            self.progress = self.move_created_ids2 and sum(
-                move.product_qty for move in self.move_created_ids2.filtered(
-                    lambda move: not move.scrapped and move.product_id == self.product_id)
-                ) or 0.0 / self.product_qty
-
-    @api.one
-    @api.depends('workcenter_lines.hour')
-    def _compute_hour_total(self):
-        self.hour_total = self.workcenter_lines and sum(wc_line.hour for wc_line in self.workcenter_lines) or 0.0
-
-    @api.one
-    @api.depends('workcenter_lines.cycle')
-    def _compute_cycle_total(self):
-        self.cycle_total = self.workcenter_lines and sum(wc_line.cycle for wc_line in self.workcenter_lines) or 0.0
-
-    @api.one
-    @api.depends('move_lines.state')
-    def _compute_ready_production(self):
-        """ Test whether all the consume lines are assigned """
-        self.ready_production = self.move_lines and all(move.state == 'assigned' for move in self.move_lines)
-
-    @api.multi
-    @api.constrains('product_qty')
-    def _check_qty(self):
-        if any(production.product_qty <= 0 for production in self):
-            raise UserError(_('Order quantity cannot be negative or zero!'))
-
-    @api.onchange('location_src_id', 'location_dest_id')
-    def onchange_location_id(self):
-        """ Changes destination location if source location is changed. """
-        if self.location_src_id and not self.location_dest_id:
-            self.location_dest_id = self.location_src_id.id
-
-    @api.onchange('product_id')
+    @api.onchange('product_id', 'picking_type_id', 'company_id')
     def onchange_product_id(self):
         """ Finds UoM of changed product. """
         if not self.product_id:
             self.bom_id = False
         else:
-            bom = self.env['mrp.bom']._bom_find(product_id=self.product_id.id, properties=[])
+            bom = self.env['mrp.bom']._bom_find(product=self.product_id, picking_type=self.picking_type_id, company_id=self.company_id.id)
             self.bom_id = bom.id
-        self.product_uom = self.product_id.uom_id.id
-        self.product_tmpl_id = self.product_id.product_tmpl_id.id
+            self.product_uom_id = self.product_id.uom_id.id
+            return {'domain': {'product_uom_id': [('category_id', '=', self.product_id.uom_id.category_id.id)]}}
+
+    @api.onchange('picking_type_id')
+    def onchange_picking_type(self):
+        location = self.env.ref('stock.stock_location_stock')
+        self.location_src_id = self.picking_type_id.default_location_src_id.id or location.id
+        self.location_dest_id = self.picking_type_id.default_location_dest_id.id or location.id
 
     @api.onchange('bom_id')
     def onchange_bom_id(self):
-        """ Finds routing for changed BoM. """
         self.routing_id = self.bom_id.routing_id.id
 
     @api.model
     def create(self, values):
-        if values.get('product_id') and 'product_uom' not in values:
-            values['product_uom'] = self.env['product.product'].browse(values['product_id']).uom_id.id
-        return super(MrpProduction, self).create(values)
+        if not values.get('name', False) or values['name'] == 'New':
+            values['name'] = self.env['ir.sequence'].next_by_code('mrp.production') or _('New')
+        if not values.get('procurement_group_id'):
+            values['procurement_group_id'] = self.env["procurement.group"].create({'name': values['name']}).id
+        production = super(MrpProduction, self).create(values)
+        production._generate_moves()
+        return production
 
     @api.multi
     def unlink(self):
-        if any(production.state not in ('draft', 'cancel') for production in self):
-            raise UserError(_('Cannot delete a manufacturing order not in draft or cancel state'))
+        if any(production.state != 'cancel' for production in self):
+            raise UserError(_('Cannot delete a manufacturing order not in cancel state'))
         return super(MrpProduction, self).unlink()
 
+    @api.multi
+    def _generate_moves(self):
+        for production in self:
+            production._generate_finished_moves()
+            factor = self.env['product.uom']._compute_qty(production.product_uom_id.id, production.product_qty, production.bom_id.product_uom_id.id)
+            boms, lines = production.bom_id.explode(production.product_id, factor, picking_type=production.bom_id.picking_type_id)
+            production._generate_raw_moves(lines)
+            # Check for all draft moves whether they are mto or not
+            self._adjust_procure_method()
+            self.move_raw_ids.action_confirm()
+        return True
 
-    def _prepare_lines(self, cr, uid, production, properties=None, context=None):
-        # search BoM structure and route
-        bom_obj = self.pool.get('mrp.bom')
-        uom_obj = self.pool.get('product.uom')
-        bom_point = production.bom_id
-        bom_id = production.bom_id.id
-        if not bom_point:
-            bom_id = bom_obj._bom_find(cr, uid, product_id=production.product_id.id, properties=properties, context=context)
-            if bom_id:
-                bom_point = bom_obj.browse(cr, uid, bom_id)
-                routing_id = bom_point.routing_id.id or False
-                self.write(cr, uid, [production.id], {'bom_id': bom_id, 'routing_id': routing_id})
-
-        if not bom_id:
-            raise UserError(_("Cannot find a bill of material for this product."))
-
-        # get components and workcenter_lines from BoM structure
-        factor = uom_obj._compute_qty(cr, uid, production.product_uom.id, production.product_qty, bom_point.product_uom.id)
-        # product_lines, workcenter_lines
-        return bom_obj._bom_explode(cr, uid, bom_point, production.product_id, factor / bom_point.product_qty, properties, routing_id=production.routing_id.id, context=context)
-
-    def _action_compute_lines(self, cr, uid, ids, properties=None, context=None):
-        """ Compute product_lines and workcenter_lines from BoM structure
-        @return: product_lines
-        """
-        if properties is None:
-            properties = []
-        results = []
-        prod_line_obj = self.pool.get('mrp.production.product.line')
-        workcenter_line_obj = self.pool.get('mrp.production.workcenter.line')
-        for production in self.browse(cr, uid, ids, context=context):
-            #unlink product_lines
-            prod_line_obj.unlink(cr, SUPERUSER_ID, [line.id for line in production.product_lines], context=context)
-            #unlink workcenter_lines
-            workcenter_line_obj.unlink(cr, SUPERUSER_ID, [line.id for line in production.workcenter_lines], context=context)
-
-            res = self._prepare_lines(cr, uid, production, properties=properties, context=context)
-            results = res[0] # product_lines
-            results2 = res[1] # workcenter_lines
-
-            # reset product_lines in production order
-            for line in results:
-                line['production_id'] = production.id
-                prod_line_obj.create(cr, uid, line)
-
-            #reset workcenter_lines in production order
-            for line in results2:
-                line['production_id'] = production.id
-                workcenter_line_obj.create(cr, uid, line, context)
-        return results
+    def _generate_finished_moves(self):
+        move = self.env['stock.move'].create({
+            'name': self.name,
+            'date': self.date_planned_start,
+            'date_expected': self.date_planned_start,
+            'product_id': self.product_id.id,
+            'product_uom': self.product_uom_id.id,
+            'product_uom_qty': self.product_qty,
+            'location_id': self.product_id.property_stock_production.id,
+            'location_dest_id': self.location_dest_id.id,
+            'move_dest_id': self.procurement_ids and self.procurement_ids[0].move_dest_id.id or False,
+            'procurement_id': self.procurement_ids and self.procurement_ids[0].id or False,
+            'company_id': self.company_id.id,
+            'production_id': self.id,
+            'origin': self.name,
+            'group_id': self.procurement_group_id.id,
+        })
+        move.action_confirm()
+        return move
 
-    @api.multi
-    def action_compute(self, properties=None):
-        """ Computes bills of material of a product.
-        @param properties: List containing dictionaries of properties.
-        @return: No. of products.
-        """
-        return len(self._action_compute_lines(properties=properties))
+    def _generate_raw_moves(self, exploded_lines):
+        self.ensure_one()
+        moves = self.env['stock.move']
+        for bom_line, line_data in exploded_lines:
+            moves += self._generate_raw_move(bom_line, line_data['qty'])
+        return moves
+
+    def _generate_raw_move(self, bom_line, quantity):
+        if bom_line.child_bom_id and bom_line.child_bom_id.type == 'phantom':
+            return self.env['stock.move']
+        if bom_line.product_id.type not in ['product', 'consu']:
+            return self.env['stock.move']
+        if self.bom_id.routing_id and self.bom_id.routing_id.location_id:
+            source_location = self.bom_id.routing_id.location_id
+        else:
+            source_location = self.location_src_id
+        original_quantity = self.env['product.uom']._compute_qty(self.product_uom_id.id, self.product_qty, self.bom_id.product_uom_id.id)
 
-    def action_cancel(self, cr, uid, ids, context=None):
-        """ Cancels the production order and related stock moves.
-        @return: True
-        """
-        if context is None:
-            context = {}
-        move_obj = self.pool.get('stock.move')
-        proc_obj = self.pool.get('procurement.order')
-        for production in self.browse(cr, uid, ids, context=context):
-            if production.move_created_ids:
-                move_obj.action_cancel(cr, uid, [x.id for x in production.move_created_ids])
-            procs = proc_obj.search(cr, uid, [('move_dest_id', 'in', [x.id for x in production.move_lines])], context=context)
-            if procs:
-                proc_obj.cancel(cr, uid, procs, context=context)
-            move_obj.action_cancel(cr, uid, [x.id for x in production.move_lines])
-        self.write(cr, uid, ids, {'state': 'cancel'})
-        # Put related procurements in exception
-        proc_obj = self.pool.get("procurement.order")
-        procs = proc_obj.search(cr, uid, [('production_id', 'in', ids)], context=context)
-        if procs:
-            proc_obj.message_post(cr, uid, procs, body=_('Manufacturing order cancelled.'), context=context)
-            proc_obj.write(cr, uid, procs, {'state': 'exception'}, context=context)
-        return True
+        data = {
+            'name': self.name,
+            'date': self.date_planned_start,
+            'bom_line_id': bom_line.id,
+            'product_id': bom_line.product_id.id,
+            'product_uom_qty': quantity,
+            'product_uom': bom_line.product_uom_id.id,
+            'location_id': source_location.id,
+            'location_dest_id': self.product_id.property_stock_production.id,
+            'raw_material_production_id': self.id,
+            'company_id': self.company_id.id,
+            'operation_id': bom_line.operation_id.id,
+            'price_unit': bom_line.product_id.standard_price,
+            'procure_method': 'make_to_stock',
+            'origin': self.name,
+            'warehouse_id': source_location.get_warehouse().id,
+            'group_id': self.procurement_group_id.id,
+            'propagate': self.propagate,
+            'unit_factor': quantity / original_quantity,
+        }
+        return self.env['stock.move'].create(data)
 
-    def action_ready(self, cr, uid, ids, context=None):
-        """ Changes the production state to Ready and location id of stock move.
-        @return: True
-        """
-        move_obj = self.pool.get('stock.move')
-        self.write(cr, uid, ids, {'state': 'ready'})
+    @api.multi
+    def _adjust_procure_method(self):
+        try:
+            mto_route = self.env['stock.warehouse']._get_mto_route()
+        except:
+            mto_route = False
+        for move in self.move_raw_ids:
+            product = move.product_id
+            routes = product.route_ids + product.categ_id.route_ids
+            # TODO: optimize with read_group?
+            pull = self.env['procurement.rule'].search([('route_id', 'in', [x.id for x in routes]), ('location_src_id', '=', move.location_id.id),
+                                                        ('location_id', '=', move.location_dest_id.id)], limit=1)
+            if pull and (pull.procure_method == 'make_to_order'):
+                move.procure_method = pull.procure_method
+            elif not pull: # If there is no make_to_stock rule either
+                if mto_route and mto_route.id in [x.id for x in routes]:
+                    move.procure_method = 'make_to_order'
 
-        for production in self.browse(cr, uid, ids, context=context):
-            if not production.move_created_ids:
-                self._make_production_produce_line(cr, uid, production, context=context)
+    @api.multi
+    def _update_raw_move(self, bom_line, quantity, **kw):
+        self.ensure_one()
+        move = self.move_raw_ids.filtered(lambda x: x.bom_line_id.id == bom_line.id and x.state not in ('done', 'cancel'))
+        if move:
+            move.write({'product_uom_qty': quantity})
+            return move
+        else:
+            self._generate_raw_move(bom_line, quantity)
 
-            if production.move_prod_id and production.move_prod_id.location_id.id != production.location_dest_id.id:
-                move_obj.write(cr, uid, [production.move_prod_id.id],
-                        {'location_id': production.location_dest_id.id})
+    @api.multi
+    def action_assign(self):
+        for production in self:
+            move_to_assign = production.move_raw_ids.filtered(lambda x: x.state in ('confirmed', 'waiting', 'assigned'))
+            move_to_assign.action_assign()
         return True
 
-    def _compute_costs_from_production(self, cr, uid, ids, context=None):
-        """ Generate workcenter costs in analytic accounts"""
-        for production in self.browse(cr, uid, ids):
-            total_cost = self._costs_generate(cr, uid, production)
+    @api.multi
+    def button_plan(self):
+        """ Create work orders. And probably do stuff, like things. """
+        orders_to_plan = self.filtered(lambda order: order.routing_id and order.state == 'confirmed')
+        UoM = self.env['product.uom']
+        for order in orders_to_plan:
+            quantity = UoM._compute_qty_obj(order.product_uom_id, order.product_qty, order.bom_id.product_uom_id)
+            boms, lines = order.bom_id.explode(order.product_id, quantity, picking_type=order.bom_id.picking_type_id)
+            order._generate_workorders(boms)
+        orders_to_plan.write({'state': 'planned'})
 
-    def action_production_end(self, cr, uid, ids, context=None):
-        """ Changes production state to Finish and writes finished date.
-        @return: True
-        """
-        self._compute_costs_from_production(cr, uid, ids, context)
-        write_res = self.write(cr, uid, ids, {'state': 'done', 'date_finished': time.strftime('%Y-%m-%d %H:%M:%S')})
-        # Check related procurements
-        proc_obj = self.pool.get("procurement.order")
-        procs = proc_obj.search(cr, uid, [('production_id', 'in', ids)], context=context)
-        proc_obj.check(cr, uid, procs, context=context)
-        return write_res
-
-    def test_production_done(self, cr, uid, ids):
-        """ Tests whether production is done or not.
-        @return: True or False
-        """
-        res = True
-        for production in self.browse(cr, uid, ids):
-            if production.move_lines:
-                res = False
-
-            if production.move_created_ids:
-                res = False
-        return res
-
-    def _get_produced_qty(self, cr, uid, production, context=None):
-        ''' returns the produced quantity of product 'production.product_id' for the given production, in the product UoM
-        '''
-        produced_qty = 0
-        for produced_product in production.move_created_ids2:
-            if (produced_product.scrapped) or (produced_product.product_id.id != production.product_id.id):
-                continue
-            produced_qty += produced_product.product_qty
-        return produced_qty
-
-    def _get_consumed_data(self, cr, uid, production, context=None):
-        ''' returns a dictionary containing for each raw material of the given production, its quantity already consumed (in the raw material UoM)
-        '''
-        consumed_data = {}
-        # Calculate already consumed qtys
-        for consumed in production.move_lines2:
-            if consumed.scrapped:
-                continue
-            if not consumed_data.get(consumed.product_id.id, False):
-                consumed_data[consumed.product_id.id] = 0
-            consumed_data[consumed.product_id.id] += consumed.product_qty
-        return consumed_data
+    @api.multi
+    def _generate_workorders(self, exploded_boms):
+        workorders = self.env['mrp.workorder']
+        for bom, bom_data in exploded_boms:
+            workorders += self._workorders_create(bom, bom_data['qty'])
+        return workorders
 
-    def _calculate_qty(self, cr, uid, production, product_qty=0.0, context=None):
+    def _workorders_create(self, bom, qty):
         """
-            Calculates the quantity still needed to produce an extra number of products
-            product_qty is in the uom of the product
+        :param bom: in case of recursive boms: we could create work orders for child
+                    BoMs
         """
-        quant_obj = self.pool.get("stock.quant")
-        uom_obj = self.pool.get("product.uom")
-        produced_qty = self._get_produced_qty(cr, uid, production, context=context)
-        consumed_data = self._get_consumed_data(cr, uid, production, context=context)
-
-        #In case no product_qty is given, take the remaining qty to produce for the given production
-        if not product_qty:
-            product_qty = uom_obj._compute_qty(cr, uid, production.product_uom.id, production.product_qty, production.product_id.uom_id.id) - produced_qty
-        production_qty = uom_obj._compute_qty(cr, uid, production.product_uom.id, production.product_qty, production.product_id.uom_id.id)
-
-        scheduled_qty = OrderedDict()
-        for scheduled in production.product_lines:
-            if scheduled.product_id.type not in ['product', 'consu']:
-                continue
-            qty = uom_obj._compute_qty(cr, uid, scheduled.product_uom.id, scheduled.product_qty, scheduled.product_id.uom_id.id)
-            if scheduled_qty.get(scheduled.product_id.id):
-                scheduled_qty[scheduled.product_id.id] += qty
-            else:
-                scheduled_qty[scheduled.product_id.id] = qty
-        dicts = OrderedDict()
-        # Find product qty to be consumed and consume it
-        for product_id in scheduled_qty.keys():
-
-            consumed_qty = consumed_data.get(product_id, 0.0)
-            
-            # qty available for consume and produce
-            sched_product_qty = scheduled_qty[product_id]
-            qty_avail = sched_product_qty - consumed_qty
-            if qty_avail <= 0.0:
-                # there will be nothing to consume for this raw material
-                continue
+        workorders = self.env['mrp.workorder']
 
-            if not dicts.get(product_id):
-                dicts[product_id] = {}
+        use_serial = any(product.tracking == 'serial' for product in self.mapped('move_finished_ids.product_id'))
+        if use_serial:
+            quantity = 1.0
+        else:
+            quantity = self.product_qty - sum(self.move_finished_ids.mapped('quantity_done'))
+            quantity = quantity if (quantity > 0) else 0
+
+        # TDE FIXME: what is qty compared to quantity ??
+        for operation in bom.routing_id.operation_ids:
+            # create workorder
+            cycle_number = math.ceil(qty / bom.product_qty / operation.workcenter_id.capacity)  # TODO: float_round UP
+            duration_expected = (operation.workcenter_id.time_start +
+                                 operation.workcenter_id.time_stop +
+                                 cycle_number * operation.time_cycle * 100.0 / operation.workcenter_id.time_efficiency)
+            workorder = workorders.create({
+                'name': operation.name,
+                'production_id': self.id,
+                'workcenter_id': operation.workcenter_id.id,
+                'operation_id': operation.id,
+                'duration_expected': duration_expected,
+                'state': len(workorders) == 0 and 'ready' or 'pending',
+                'qty_producing': quantity,
+                'capacity': operation.workcenter_id.capacity,
+            })
+            if workorders:
+                workorders[-1].next_work_order_id = workorder.id
+            workorders += workorder
+
+            # assign moves; last operation receive all unassigned moves (which case ?)
+            moves_raw = self.move_raw_ids.filtered(lambda move: move.operation_id == operation)
+            if len(workorders) == len(bom.routing_id.operation_ids):
+                moves_raw |= self.move_raw_ids.filtered(lambda move: move.operation_id == False)
+            moves_finished = self.move_finished_ids.filtered(lambda move: move.operation_id == operation)
+            moves_raw.mapped('move_lot_ids').write({'workorder_id': workorder.id})
+            (moves_finished + moves_raw).write({'workorder_id': workorder.id})
+
+            workorder._generate_lot_ids()
+        return workorders
 
-            # total qty of consumed product we need after this consumption
-            if product_qty + produced_qty <= production_qty:
-                total_consume = ((product_qty + produced_qty) * sched_product_qty / production_qty)
-            else:
-                total_consume = sched_product_qty
-            qty = total_consume - consumed_qty
-
-            # Search for quants related to this related move
-            for move in production.move_lines:
-                if qty <= 0.0:
-                    break
-                if move.product_id.id != product_id:
-                    continue
-
-                q = min(move.product_qty, qty)
-                quants = quant_obj.quants_get_preferred_domain(cr, uid, q, move, domain=[('qty', '>', 0.0)],
-                                                     preferred_domain_list=[[('reservation_id', '=', move.id)]], context=context)
-                for quant, quant_qty in quants:
-                    if quant:
-                        lot_id = quant.lot_id.id
-                        if not product_id in dicts.keys():
-                            dicts[product_id] = {lot_id: quant_qty}
-                        elif lot_id in dicts[product_id].keys():
-                            dicts[product_id][lot_id] += quant_qty
-                        else:
-                            dicts[product_id][lot_id] = quant_qty
-                        qty -= quant_qty
-            if float_compare(qty, 0, self.pool['decimal.precision'].precision_get(cr, uid, 'Product Unit of Measure')) == 1:
-                if dicts[product_id].get(False):
-                    dicts[product_id][False] += qty
-                else:
-                    dicts[product_id][False] = qty
-
-        consume_lines = []
-        for prod in dicts.keys():
-            for lot, qty in dicts[prod].items():
-                consume_lines.append({'product_id': prod, 'product_qty': qty, 'lot_id': lot})
-        return consume_lines
-
-    def _calculate_produce_line_qty(self, cr, uid, move, quantity, context=None):
-        """ Compute the quantity and remainig quantity of products to produce.
-        :param move: Record set of stock move that needs to be produced, identify the product to produce.
-        :param quantity: specify quantity to produce in the uom of the production order.
-        :return: The quantity and remaining quantity of product produce.
-        """
-        qty = min(quantity, move.product_qty)
-        remaining_qty = quantity - qty
-        return qty, remaining_qty
-
-    def _calculate_total_cost(self, cr, uid, total_consume_moves, context=None):
-        total_cost = 0
-        for consumed_move in self.pool['stock.move'].browse(cr, uid, total_consume_moves, context=context):
-            total_cost += sum([x.inventory_value for x in consumed_move.quant_ids if x.qty > 0])
-        return total_cost
-
-    def _calculate_workcenter_cost(self, cr, uid, production_id, context=None):
-        """ Compute the planned production cost from the workcenters """
-        production = self.browse(cr, uid, production_id, context=context)
-        total_cost = 0.0
-        for wc_line in production.workcenter_lines:
-            wc = wc_line.workcenter_id
-            total_cost += wc_line.hour*wc.costs_hour + wc_line.cycle*wc.costs_cycle
-        return total_cost
-
-    def action_produce(self, cr, uid, ids, production_qty, production_mode, wiz=False, context=None):
-        """ To produce final product based on production mode (consume/consume&produce).
-        If Production mode is consume, all stock move lines of raw materials will be done/consumed.
-        If Production mode is consume & produce, all stock move lines of raw materials will be done/consumed
-        and stock move lines of final product will be also done/produced.
-        @param production_id: the ID of mrp.production object
-        @param production_qty: specify qty to produce in the uom of the production order
-        @param production_mode: specify production mode (consume/consume&produce).
-        @param wiz: the mrp produce product wizard, which will tell the amount of consumed products needed
-        @return: True
-        """
-        stock_mov_obj = self.pool.get('stock.move')
-        uom_obj = self.pool.get("product.uom")
-        production = self.browse(cr, uid, ids[0], context=context)
-        production_qty_uom = uom_obj._compute_qty(cr, uid, production.product_uom.id, production_qty, production.product_id.uom_id.id)
-        precision = self.pool['decimal.precision'].precision_get(cr, uid, 'Product Unit of Measure')
-
-        main_production_move = False
-        if production_mode == 'consume_produce':
-            for produce_product in production.move_created_ids:
-                if produce_product.product_id.id == production.product_id.id:
-                    main_production_move = produce_product.id
-
-        total_consume_moves = set()
-        if production_mode in ['consume', 'consume_produce']:
-            if wiz:
-                consume_lines = []
-                for cons in wiz.consume_lines:
-                    consume_lines.append({'product_id': cons.product_id.id, 'lot_id': cons.lot_id.id, 'product_qty': cons.product_qty})
-            else:
-                consume_lines = self._calculate_qty(cr, uid, production, production_qty_uom, context=context)
-            for consume in consume_lines:
-                remaining_qty = consume['product_qty']
-                for raw_material_line in production.move_lines:
-                    if raw_material_line.state in ('done', 'cancel'):
-                        continue
-                    if remaining_qty <= 0:
-                        break
-                    if consume['product_id'] != raw_material_line.product_id.id:
-                        continue
-                    consumed_qty = min(remaining_qty, raw_material_line.product_qty)
-                    stock_mov_obj.action_consume(cr, uid, [raw_material_line.id], consumed_qty, raw_material_line.location_id.id,
-                                                 restrict_lot_id=consume['lot_id'], consumed_for=main_production_move, context=context)
-                    total_consume_moves.add(raw_material_line.id)
-                    remaining_qty -= consumed_qty
-                if not float_is_zero(remaining_qty, precision_digits=precision):
-                    #consumed more in wizard than previously planned
-                    product = self.pool.get('product.product').browse(cr, uid, consume['product_id'], context=context)
-                    extra_move_id = self._make_consume_line_from_data(cr, uid, production, product, product.uom_id.id, remaining_qty, context=context)
-                    stock_mov_obj.write(cr, uid, [extra_move_id], {'restrict_lot_id': consume['lot_id'],
-                                                                    'consumed_for': main_production_move}, context=context)
-                    stock_mov_obj.action_done(cr, uid, [extra_move_id], context=context)
-                    total_consume_moves.add(extra_move_id)
-
-        if production_mode == 'consume_produce':
-            # add production lines that have already been consumed since the last 'consume & produce'
-            last_production_date = production.move_created_ids2 and max(production.move_created_ids2.mapped('date')) or False
-            already_consumed_lines = production.move_lines2.filtered(lambda l: l.date > last_production_date)
-            total_consume_moves = total_consume_moves.union(already_consumed_lines.ids)
-
-            price_unit = 0
-            for produce_product in production.move_created_ids:
-                is_main_product = (produce_product.product_id.id == production.product_id.id) and production.product_id.cost_method=='real'
-                if is_main_product:
-                    total_cost = self._calculate_total_cost(cr, uid, list(total_consume_moves), context=context)
-                    production_cost = self._calculate_workcenter_cost(cr, uid, production.id, context=context)
-                    price_unit = (total_cost + production_cost) / production_qty_uom
-
-                lot_id = False
-                if wiz:
-                    lot_id = wiz.lot_id.id
-                qty, remaining_qty = self._calculate_produce_line_qty(cr, uid, produce_product, production_qty_uom, context=context)
-                if is_main_product and price_unit:
-                    stock_mov_obj.write(cr, uid, [produce_product.id], {'price_unit': price_unit}, context=context)
-                new_moves = stock_mov_obj.action_consume(cr, uid, [produce_product.id], qty,
-                                                         location_id=produce_product.location_id.id, restrict_lot_id=lot_id, context=context)
-                stock_mov_obj.write(cr, uid, new_moves, {'production_id': production.id}, context=context)
-                if not float_is_zero(remaining_qty, precision_digits=precision):
-                    # In case you need to make more than planned
-                    #consumed more in wizard than previously planned
-                    extra_move_id = stock_mov_obj.copy(cr, uid, produce_product.id, default={'product_uom_qty': remaining_qty,
-                                                                                             'production_id': production.id}, context=context)
-                    if is_main_product:
-                        stock_mov_obj.write(cr, uid, [extra_move_id], {'price_unit': price_unit}, context=context)
-                    stock_mov_obj.action_confirm(cr, uid, [extra_move_id], context=context)
-                    stock_mov_obj.action_done(cr, uid, [extra_move_id], context=context)
-
-        self.message_post(cr, uid, production.id, body=_("%s produced") % self._description, context=context)
-
-        # Remove remaining products to consume if no more products to produce
-        if not production.move_created_ids and production.move_lines:
-            stock_mov_obj.action_cancel(cr, uid, [x.id for x in production.move_lines], context=context)
-
-        self.signal_workflow(cr, uid, [production.id], 'button_produce_done')
+    @api.multi
+    def action_cancel(self):
+        """ Cancels production order, unfinished stock moves and set procurement
+        orders in exception """
+        if any(workorder.state == 'progress' for workorder in self.mapped('workorder_ids')):
+            raise UserError(_('You can not cancel production order, a work order is still in progress.'))
+        ProcurementOrder = self.env['procurement.order']
+        for production in self:
+            production.workorder_ids.filtered(lambda x: x.state != 'cancel').action_cancel()
+
+            finish_moves = production.move_finished_ids.filtered(lambda x: x.state not in ('done', 'cancel'))
+            production.move_raw_ids.filtered(lambda x: x.state not in ('done', 'cancel')).action_cancel()
+            finish_moves.action_cancel()
+
+            procurements = ProcurementOrder.search([('move_dest_id', 'in', finish_moves.ids)])
+            if procurements:
+                procurements.cancel()
+
+        # Put relatfinish_to_canceled procurements in exception -> I agree
+        ProcurementOrder.search([('production_id', 'in', self.ids)]).write({'state': 'exception'})
+
+        self.write({'state': 'cancel'})
         return True
 
-    def _costs_generate(self, cr, uid, production):
-        """ Calculates total costs at the end of the production.
-        @param production: Id of production order.
-        @return: Calculated amount.
-        """
-        amount = 0.0
-        analytic_line_obj = self.pool.get('account.analytic.line')
-        for wc_line in production.workcenter_lines:
-            wc = wc_line.workcenter_id
-            if wc.costs_general_account_id:
-                # Cost per hour
-                value = wc_line.hour * wc.costs_hour
-                account = wc.costs_hour_account_id.id
-                if value and account:
-                    amount += value
-                    # we user SUPERUSER_ID as we do not garantee an mrp user
-                    # has access to account analytic lines but still should be
-                    # able to produce orders
-                    analytic_line_obj.create(cr, SUPERUSER_ID, {
-                        'name': wc_line.name + ' (H)',
-                        'amount': value,
-                        'account_id': account,
-                        'general_account_id': wc.costs_general_account_id.id,
-                        'ref': wc.code,
-                        'product_id': wc.product_id.id,
-                        'unit_amount': wc_line.hour,
-                        'product_uom_id': wc.product_id and wc.product_id.uom_id.id or False
-                    })
-                # Cost per cycle
-                value = wc_line.cycle * wc.costs_cycle
-                account = wc.costs_cycle_account_id.id
-                if value and account:
-                    amount += value
-                    analytic_line_obj.create(cr, SUPERUSER_ID, {
-                        'name': wc_line.name + ' (C)',
-                        'amount': value,
-                        'account_id': account,
-                        'general_account_id': wc.costs_general_account_id.id,
-                        'ref': wc.code,
-                        'product_id': wc.product_id.id,
-                        'unit_amount': wc_line.cycle,
-                        'product_uom_id': wc.product_id and wc.product_id.uom_id.id or False
-                    })
-        return amount
-
     @api.multi
-    def action_in_production(self):
-        """ Changes state to In Production and writes starting date. """
-        return self.write({'state': 'in_production', 'date_start': fields.Datetime.now()})
+    def _cal_price(self, consumed_moves):
+        return True
 
-    def consume_lines_get(self, cr, uid, ids, *args):
-        # TDE: DEAD CODE
-        res = []
-        for order in self.browse(cr, uid, ids, context={}):
-            res += [x.id for x in order.move_lines]
-        return res
+    @api.multi
+    def post_inventory(self):
+        for order in self:
+            moves_to_do = order.move_raw_ids
+            moves_to_do.action_done()
+            #order.move_finished_ids.filtered(lambda x: x.state not in ('done','cancel')).move_validate()
+            order._cal_price(moves_to_do)
+            moves_to_finish = order.move_finished_ids
+            moves_to_finish.action_done()
+            for move in moves_to_finish:
+                #Group quants by lots
+                lot_quants = {}
+                raw_lot_quants = {}
+                quants = self.env['stock.quant']
+                if move.has_tracking != 'none':
+                    for quant in move.quant_ids:
+                        lot_quants.setdefault(quant.lot_id.id, self.env['stock.quant'])
+                        raw_lot_quants.setdefault(quant.lot_id.id, self.env['stock.quant'])
+                        lot_quants[quant.lot_id.id] |= quant
+                for move_raw in moves_to_do:
+                    if (move.has_tracking != 'none') and (move_raw.has_tracking != 'none'):
+                        for lot in lot_quants:
+                            lots = move_raw.move_lot_ids.filtered(lambda x: x.lot_produced_id.id == lot).mapped('lot_id')
+                            raw_lot_quants[lot] |= move_raw.quant_ids.filtered(lambda x: (x.lot_id in lots) and (x.qty > 0.0))
+                    else:
+                        quants |= move_raw.quant_ids.filtered(lambda x: x.qty > 0.0)
+                if move.has_tracking != 'none':
+                    for lot in lot_quants:
+                        lot_quants[lot].sudo().write({'consumed_quant_ids': [(6, 0, [x.id for x in raw_lot_quants[lot] | quants])]})
+                else:
+                    move.quant_ids.sudo().write({'consumed_quant_ids': [(6, 0, [x.id for x in quants])]})
+            order.action_assign()
+        return True
 
     @api.multi
-    def test_ready(self):
-        return all(production.ready_production for production in self)
-
-    def _make_production_produce_line(self, cr, uid, production, context=None):
-        stock_move = self.pool.get('stock.move')
-        proc_obj = self.pool.get('procurement.order')
-        source_location_id = production.product_id.property_stock_production.id
-        destination_location_id = production.location_dest_id.id
-        procs = proc_obj.search(cr, uid, [('production_id', '=', production.id)], context=context)
-        procurement = procs and\
-            proc_obj.browse(cr, uid, procs[0], context=context) or False
-        data = {
-            'name': production.name,
-            'date': production.date_planned,
-            'date_expected': production.date_planned,
-            'product_id': production.product_id.id,
-            'product_uom': production.product_uom.id,
-            'product_uom_qty': production.product_qty,
-            'location_id': source_location_id,
-            'location_dest_id': destination_location_id,
-            'move_dest_id': production.move_prod_id.id,
-            'procurement_id': procurement and procurement.id,
-            'company_id': production.company_id.id,
-            'production_id': production.id,
-            'origin': production.name,
-            'group_id': procurement and procurement.group_id.id,
-        }
-        move_id = stock_move.create(cr, uid, data, context=context)
-        # TDE FIXME: necessary return ?
-        stock_move.action_confirm(cr, uid, [move_id], context=context)
-        return move_id
-
-    def _get_raw_material_procure_method(self, cr, uid, product, location_id=False, location_dest_id=False, context=None):
-        '''This method returns the procure_method to use when creating the stock move for the production raw materials
-        Besides the standard configuration of looking if the product or product category has the MTO route,
-        you can also define a rule e.g. from Stock to Production (which might be used in the future like the sale orders)
-        '''
-        warehouse_obj = self.pool['stock.warehouse']
-        routes = product.route_ids + product.categ_id.total_route_ids
-
-        if location_id and location_dest_id:
-            pull_obj = self.pool['procurement.rule']
-            pulls = pull_obj.search(cr, uid, [('route_id', 'in', [x.id for x in routes]),
-                                            ('location_id', '=', location_dest_id),
-                                            ('location_src_id', '=', location_id)], limit=1, context=context)
-            if pulls:
-                return pull_obj.browse(cr, uid, pulls[0], context=context).procure_method
+    def button_mark_done(self):
+        self.ensure_one()
+        for wo in self.workorder_ids:
+            if wo.time_ids.filtered(lambda x: (not x.date_end) and (x.loss_type in ('productive', 'performance'))):
+                raise UserError(_('Work order %s is still running') % wo.name)
+        self.post_inventory()
+        moves_to_cancel = (self.move_raw_ids | self.move_finished_ids).filtered(lambda x: x.state not in ('done', 'cancel'))
+        moves_to_cancel.action_cancel()
+        self.write({'state': 'done', 'date_finished': fields.datetime.now()})
+        self.env["procurement.order"].search([('production_id', 'in', self.ids)]).check()
+        self.write({'state': 'done'})
 
-        try:
-            mto_route = warehouse_obj._get_mto_route(cr, uid, context=context)
-        except:
-            return "make_to_stock"
-
-        if mto_route in [x.id for x in routes]:
-            return "make_to_order"
-        return "make_to_stock"
-
-    def _create_previous_move(self, cr, uid, move_id, product, source_location_id, dest_location_id, context=None):
-        '''
-        When the routing gives a different location than the raw material location of the production order, 
-        we should create an extra move from the raw material location to the location of the routing, which 
-        precedes the consumption line (chained).  The picking type depends on the warehouse in which this happens
-        and the type of locations. 
-        '''
-        loc_obj = self.pool.get("stock.location")
-        stock_move = self.pool.get('stock.move')
-        type_obj = self.pool.get('stock.picking.type')
-        # Need to search for a picking type
-        move = stock_move.browse(cr, uid, move_id, context=context)
-        src_loc = loc_obj.browse(cr, uid, source_location_id, context=context)
-        dest_loc = loc_obj.browse(cr, uid, dest_location_id, context=context)
-        code = stock_move.get_code_from_locs(cr, uid, [move.id], src_loc, dest_loc, context=context)
-        if code == 'outgoing':
-            check_loc = src_loc
-        else:
-            check_loc = dest_loc
-        wh = loc_obj.get_warehouse(cr, uid, [check_loc.id], context=context)
-        domain = [('code', '=', code)]
-        if wh: 
-            domain += [('warehouse_id', '=', wh)]
-        types = type_obj.search(cr, uid, domain, context=context)
-        move = stock_move.copy(cr, uid, move_id, default = {
-            'location_id': source_location_id,
-            'location_dest_id': dest_location_id,
-            'procure_method': self._get_raw_material_procure_method(cr, uid, product, location_id=source_location_id,
-                                                                    location_dest_id=dest_location_id, context=context),
-            'raw_material_production_id': False, 
-            'move_dest_id': move_id,
-            'picking_type_id': types and types[0] or False,
-        }, context=context)
-        return move
+    @api.multi
+    def do_unreserve(self):
+        for production in self:
+            production.move_raw_ids.filtered(lambda x: x.state not in ('done', 'cancel')).do_unreserve()
 
-    def _make_consume_line_from_data(self, cr, uid, production, product, uom_id, qty, context=None):
-        stock_move = self.pool.get('stock.move')
-        loc_obj = self.pool.get('stock.location')
-        # Internal shipment is created for Stockable and Consumer Products
-        if product.type not in ('product', 'consu'):
-            return False
-        # Take routing location as a Source Location.
-        source_location_id = production.location_src_id.id
-        prod_location_id = source_location_id
-        prev_move= False
-        if production.bom_id.routing_id and production.bom_id.routing_id.location_id and production.bom_id.routing_id.location_id.id != source_location_id:
-            source_location_id = production.bom_id.routing_id.location_id.id
-            prev_move = True
-
-        destination_location_id = production.product_id.property_stock_production.id
-        move_id = stock_move.create(cr, uid, {
-            'name': production.name,
-            'date': production.date_planned,
-            'date_expected': production.date_planned,
-            'product_id': product.id,
-            'product_uom_qty': qty,
-            'product_uom': uom_id,
-            'location_id': source_location_id,
-            'location_dest_id': destination_location_id,
-            'company_id': production.company_id.id,
-            'procure_method': prev_move and 'make_to_stock' or self._get_raw_material_procure_method(cr, uid, product, location_id=source_location_id,
-                                                                                                     location_dest_id=destination_location_id, context=context), #Make_to_stock avoids creating procurement
-            'raw_material_production_id': production.id,
-            #this saves us a browse in create()
-            'price_unit': product.standard_price,
-            'origin': production.name,
-            'warehouse_id': loc_obj.get_warehouse(cr, uid, [production.location_src_id.id], context=context),
-            'group_id': production.move_prod_id.group_id.id,
-        }, context=context)
-        
-        if prev_move:
-            prev_move = self._create_previous_move(cr, uid, move_id, product, prod_location_id, source_location_id, context=context)
-            stock_move.action_confirm(cr, uid, [prev_move], context=context)
-        return move_id
-
-    def _make_production_consume_line(self, cr, uid, line, context=None):
-        return self._make_consume_line_from_data(cr, uid, line.production_id, line.product_id, line.product_uom.id, line.product_qty, context=context)
-
-    def action_confirm(self, cr, uid, ids, context=None):
-        """ Confirms production order.
-        @return: Newly generated Shipment Id.
-        """
-        user_lang = self.pool.get('res.users').browse(cr, uid, [uid]).partner_id.lang
-        context = dict(context, lang=user_lang)
-        uncompute_ids = filter(lambda x: x, [not x.product_lines and x.id or False for x in self.browse(cr, uid, ids, context=context)])
-        self.action_compute(cr, uid, uncompute_ids, context=context)
-        for production in self.browse(cr, uid, ids, context=context):
-            self._make_production_produce_line(cr, uid, production, context=context)
-            stock_moves = []
-            for line in production.product_lines:
-                if line.product_id.type in ['product', 'consu']:
-                    stock_move_id = self._make_production_consume_line(cr, uid, line, context=context)
-                    stock_moves.append(stock_move_id)
-            if stock_moves:
-                self.pool.get('stock.move').action_confirm(cr, uid, stock_moves, context=context)
-            production.write({'state': 'confirmed'})
-        return 0
-
-    def action_assign(self, cr, uid, ids, context=None):
-        """
-        Checks the availability on the consume lines of the production order
-        """
-        from openerp import workflow
-        move_obj = self.pool.get("stock.move")
-        for production in self.browse(cr, uid, ids, context=context):
-            move_obj.action_assign(cr, uid, [x.id for x in production.move_lines], context=context)
-            if self.pool.get('mrp.production').test_ready(cr, uid, [production.id]):
-                workflow.trg_validate(uid, 'mrp.production', production.id, 'moves_ready', cr)
-
-
-    def force_production(self, cr, uid, ids, *args):
-        """ Assigns products.
-        @param *args: Arguments
-        @return: True
-        """
-        from openerp import workflow
-        move_obj = self.pool.get('stock.move')
-        for order in self.browse(cr, uid, ids):
-            move_obj.force_assign(cr, uid, [x.id for x in order.move_lines])
-            if self.pool.get('mrp.production').test_ready(cr, uid, [order.id]):
-                workflow.trg_validate(uid, 'mrp.production', order.id, 'moves_ready', cr)
-        return True
+    @api.multi
+    def button_unreserve(self):
+        self.ensure_one()
+        self.do_unreserve()
 
+    @api.multi
+    def button_scrap(self):
+        self.ensure_one()
+        return {
+            'name': _('Scrap'),
+            'view_type': 'form',
+            'view_mode': 'form',
+            'res_model': 'stock.scrap',
+            'view_id': self.env.ref('stock.stock_scrap_form_view2').id,
+            'type': 'ir.actions.act_window',
+            'context': {'default_production_id': self.id,
+                        'product_ids': (self.move_raw_ids.filtered(lambda x: x.state not in ('done', 'cancel')) | self.move_finished_ids.filtered(lambda x: x.state == 'done')).mapped('product_id').ids,
+                        },
+            'target': 'new',
+        }
 
-class ProductionWorkcenterLine(models.Model):
-    _name = 'mrp.production.workcenter.line'
-    _description = 'Work Order'
-    _order = 'sequence'
-    _inherit = ['mail.thread']
-
-    name = fields.Char('Work Order', required=True)
-    workcenter_id = fields.Many2one('mrp.workcenter', 'Work Center', required=True)
-    cycle = fields.Float(
-        'Number of Cycles', default=0.0, digits=(16, 2))
-    hour = fields.Float(
-        'Number of Hours', default=0.0, digits=(16, 2))
-    sequence = fields.Integer(
-        'Sequence', default=1,
-        required=True, help="Gives the sequence order when displaying a list of work orders.")
-    production_id = fields.Many2one(
-        'mrp.production', 'Manufacturing Order',
-        index=True, ondelete='cascade', required=True, track_visibility='onchange')
-
-
-class ProductionProductLine(models.Model):
-    _name = 'mrp.production.product.line'
-    _description = 'Production Scheduled Product'
-
-    name = fields.Char('Name', required=True)
-    product_id = fields.Many2one('product.product', 'Product', required=True)
-    product_qty = fields.Float('Product Quantity', digits_compute=dp.get_precision('Product Unit of Measure'), required=True)
-    product_uom = fields.Many2one('product.uom', 'Product Unit of Measure', required=True)
-    production_id = fields.Many2one('mrp.production', 'Production Order', select=True)
+    @api.multi
+    def action_see_move_scrap(self):
+        self.ensure_one()
+        action = self.env.ref('stock.action_stock_scrap').read()[0]
+        action['domain'] = [('production_id', '=', self.id)]
+        return action

--- a/addons/mrp/models/mrp_property.py
+++ b/None
@@ -1,29 +0,0 @@
-# -*- coding: utf-8 -*-
-# Part of Odoo. See LICENSE file for full copyright and licensing details.
-
-from odoo import fields, models
-
-
-class PropertyGroup(models.Model):
-    """ Group of mrp properties."""
-    _name = 'mrp.property.group'
-    _description = 'Property Group'
-
-    name = fields.Char('Property Group', required=True)
-    description = fields.Text('Description')
-
-
-class Property(models.Model):
-    """ Properties of mrp """
-    _name = 'mrp.property'
-    _description = 'Property'
-
-    name = fields.Char('Name', required=True)
-    composition = fields.Selection([
-        ('min', 'min'),
-        ('max', 'max'),
-        ('plus', 'plus')], string='Properties composition',
-        default='min', required=True,
-        help="Not used in computations, for information purpose only.")
-    group_id = fields.Many2one('mrp.property.group', 'Property Group', required=True)
-    description = fields.Text('Description')

--- a/addons/mrp/models/mrp_routing.py
+++ b/addons/mrp/models/mrp_routing.py
@@ -1,57 +1,100 @@
 # -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
-from odoo import fields, models
+from openerp import api, fields, models, _
 
 
-class Routing(models.Model):
-    """ For specifying the routings of Work Centers. """
+class MrpRouting(models.Model):
+    """ Specifies routings of work centers """
     _name = 'mrp.routing'
     _description = 'Routings'
 
-    name = fields.Char('Name', required=True)
+    name = fields.Char('Routing Name', required=True)
     active = fields.Boolean(
         'Active', default=True,
         help="If the active field is set to False, it will allow you to hide the routing without removing it.")
-    code = fields.Char('Code', size=8)
+    code = fields.Char(
+        'Reference',
+        copy=False, default=lambda self: _('New'), readonly=True)
     note = fields.Text('Description')
-    workcenter_lines = fields.One2many(
-        'mrp.routing.workcenter', 'routing_id', 'Work Centers', copy=True)
+    operation_ids = fields.One2many(
+        'mrp.routing.workcenter', 'routing_id', 'Operations',
+        copy=True, oldname='workcenter_lines')
     location_id = fields.Many2one(
         'stock.location', 'Production Location',
-        help="Keep empty if you produce at the location where the finished products are needed."
+        help="Keep empty if you produce at the location where you find the raw materials."
              "Set a location if you produce at a fixed location. This can be a partner location "
              "if you subcontract the manufacturing operations.")
     company_id = fields.Many2one(
         'res.company', 'Company',
         default=lambda self: self.env['res.company']._company_default_get('mrp.routing'))
 
+    @api.model
+    def create(self, vals):
+        if 'code' not in vals or vals['code'] == _('New'):
+            vals['code'] = self.env['ir.sequence'].next_by_code('mrp.routing') or _('New')
+        return super(MrpRouting, self).create(vals)
 
-class RoutingWorkcenter(models.Model):
-    """ Defines working cycles and hours of a Work Center using routings. """
+
+class MrpRoutingWorkcenter(models.Model):
     _name = 'mrp.routing.workcenter'
     _description = 'Work Center Usage'
     _order = 'sequence, id'
 
+    name = fields.Char('Operation', required=True)
     workcenter_id = fields.Many2one('mrp.workcenter', 'Work Center', required=True)
-    name = fields.Char('Name', required=True)
     sequence = fields.Integer(
         'Sequence', default=100,
         help="Gives the sequence order when displaying a list of routing Work Centers.")
-    cycle_nbr = fields.Float(
-        'Number of Cycles',
-        default=1.0, required=True,
-        help="Number of iterations this work center has to do in the specified operation of the routing.")
-    hour_nbr = fields.Float(
-        'Number of Hours',
-        default=0.0, required=True,
-        help="Time in hours for this Work Center to achieve the operation of the specified routing.")
     routing_id = fields.Many2one(
         'mrp.routing', 'Parent Routing',
-        index=True, ondelete='cascade',
-        help="Routings indicates all the Work Centers used, for how long and/or cycles."
-             "If Routings is set then,the third tab of a production order (Work Centers) will be automatically pre-completed.")
+        index=True, ondelete='cascade', required=True,
+        help="The routing contains all the Work Centers used and for how long. This will create work orders afterwards"
+        "which alters the execution of the manufacturing order. ")
     note = fields.Text('Description')
     company_id = fields.Many2one(
-        'res.company', 'Company', related='routing_id.company_id',
-        readonly=True, store=True)
+        'res.company', 'Company',
+        readonly=True, related='routing_id.company_id', store=True)
+    worksheet = fields.Binary('worksheet')
+    time_mode = fields.Selection([
+        ('auto', 'Compute based on real time'),
+        ('manual', 'Set duration manually')], string='Duration Computation',
+        default='auto')
+    time_mode_batch = fields.Integer('Based on', default=10)
+    time_cycle_manual = fields.Float(
+        'Manual Duration', default=60,
+        help="Time in minutes. Is the time used in manual mode, or the first time supposed in real time when there are not any work orders yet.")
+    time_cycle = fields.Float('Duration', compute="_compute_time_cycle")
+    workorder_count = fields.Integer("# Work Orders", compute="_compute_workorder_count")
+    batch = fields.Selection([
+        ('no',  'Once all products are processed'),
+        ('yes', 'Once a minimum number of products is processed')], string='Next Operation',
+        default='no', required=True)
+    batch_size = fields.Float('Quantity to Process', default=1.0)
+    workorder_ids = fields.One2many('mrp.workorder', 'operation_id', string="Work Orders")
+
+    @api.multi
+    @api.depends('time_cycle_manual', 'time_mode', 'workorder_ids')
+    def _compute_time_cycle(self):
+        manual_ops = self.filtered(lambda operation: operation.time_mode == 'manual')
+        for operation in manual_ops:
+            operation.time_cycle = operation.time_cycle_manual
+        for operation in self - manual_ops:
+            data = self.env['mrp.workorder'].read_group([
+                ('operation_id', '=', operation.id),
+                ('state', '=', 'done')], ['operation_id', 'duration', 'qty_produced'], ['operation_id'],
+                limit=operation.time_mode_batch)
+            count_data = dict((item['operation_id'][0], (item['duration'], item['qty_produced'])) for item in data)
+            if count_data.get(operation.id) and count_data[operation.id][1]:
+                operation.time_cycle = count_data[operation.id][0] / count_data[operation.id][1]
+            else:
+                operation.time_cycle = operation.time_cycle_manual
+
+    @api.multi
+    def _compute_workorder_count(self):
+        data = self.env['mrp.workorder'].read_group([
+            ('operation_id', 'in', self.ids),
+            ('state', '=', 'done')], ['operation_id'], ['operation_id'])
+        count_data = dict((item['operation_id'][0], item['operation_id_count']) for item in data)
+        for operation in self:
+            operation.workorder_count = count_data.get(operation.id, 0)

--- a/None
+++ b/addons/mrp/models/mrp_unbuild.py
@@ -0,0 +1,174 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from odoo import api, fields, models, _
+from odoo.exceptions import UserError
+
+
+class MrpUnbuild(models.Model):
+    _name = "mrp.unbuild"
+    _description = "Unbuild Order"
+    _inherit = ['mail.thread']
+    _order = 'id desc'
+
+    def _get_default_location_id(self):
+        return self.env.ref('stock.stock_location_stock', raise_if_not_found=False)
+
+    def _get_default_location_dest_id(self):
+        return self.env.ref('stock.stock_location_stock', raise_if_not_found=False)
+
+    name = fields.Char('Reference', copy=False, readonly=True, default=lambda x: _('New'))
+    product_id = fields.Many2one(
+        'product.product', 'Product',
+        required=True, states={'done': [('readonly', True)]})
+    product_qty = fields.Float(
+        'Quantity',
+        required=True, states={'done': [('readonly', True)]})
+    product_uom_id = fields.Many2one(
+        'product.uom', 'Unit of Measure',
+        required=True, states={'done': [('readonly', True)]})
+    bom_id = fields.Many2one(
+        'mrp.bom', 'Bill of Material',
+        domain=[('product_tmpl_id', '=', 'product_id.product_tmpl_id')], #should be more specific
+        required=True, states={'done': [('readonly', True)]})  # Add domain
+    mo_id = fields.Many2one(
+        'mrp.production', 'Manufacturing Order',
+        domain="[('product_id', '=', product_id), ('state', 'in', ['done', 'cancel'])]",
+        states={'done': [('readonly', True)]})
+    lot_id = fields.Many2one(
+        'stock.production.lot', 'Lot',
+        domain="[('product_id', '=', product_id)]",
+        states={'done': [('readonly', True)]})
+    location_id = fields.Many2one(
+        'stock.location', 'Location',
+        default=_get_default_location_id,
+        required=True, states={'done': [('readonly', True)]})
+    location_dest_id = fields.Many2one(
+        'stock.location', 'Destination Location',
+        default=_get_default_location_dest_id,
+        required=True, states={'done': [('readonly', True)]})
+    consume_line_ids = fields.One2many(
+        'stock.move', 'consume_unbuild_id', readonly=True,
+        help='')  # TDE: some string / help ?
+    produce_line_ids = fields.One2many(
+        'stock.move', 'unbuild_id', readonly=True,
+        help='')  # TDE: some string / help ?
+    state = fields.Selection([
+        ('draft', 'Draft'),
+        ('done', 'Done')], string='Status', default='draft', index=True)
+
+    @api.onchange('mo_id')
+    def onchange_mo_id(self):
+        if self.mo_id:
+            self.product_id = self.mo_id.product_id.id
+            self.product_qty = self.mo_id.product_qty
+
+    @api.onchange('product_id')
+    def onchange_product_id(self):
+        if self.product_id:
+            self.bom_id = self.env['mrp.bom']._bom_find(product=self.product_id)
+            self.product_uom_id = self.product_id.uom_id.id
+
+    @api.constrains('product_qty')
+    def _check_qty(self):
+        if self.product_qty <= 0:
+            raise ValueError(_('Unbuild Order product quantity has to be strictly positive.'))
+
+    @api.model
+    def create(self, vals):
+        if not vals.get('name'):
+            vals['name'] = self.env['ir.sequence'].next_by_code('mrp.unbuild') or _('New')
+        unbuild = super(MrpUnbuild, self).create(vals)
+        return unbuild
+
+    @api.multi
+    def action_unbuild(self):
+        self.ensure_one()
+        if self.product_id.tracking != 'none' and not self.lot_id.id:
+            raise UserError(_('Should have a lot for the finished product'))
+
+        consume_move = self._generate_consume_moves()[0]
+        produce_moves = self._generate_produce_moves()
+
+        # Search quants that passed production order
+        qty = self.product_qty  # Convert to qty on product UoM
+        if self.mo_id:
+            finished_moves = self.mo_id.move_finished_ids.filtered(lambda move: move.product_id == self.mo_id.product_id)
+            domain = [('qty', '>', 0), ('history_ids', 'in', finished_moves.ids)]
+        else:
+            domain = [('qty', '>', 0)]
+        quants = self.env['stock.quant'].quants_get_preferred_domain(
+            qty, consume_move,
+            domain=domain,
+            preferred_domain_list=[],
+            lot_id=self.lot_id.id)
+        self.env['stock.quant'].quants_reserve(quants, consume_move)
+
+        if consume_move.has_tracking != 'none':
+            self.env['stock.move.lots'].create({
+                'move_id': consume_move.id,
+                'lot_id': self.lot_id.id,
+                'quantity_done': consume_move.product_uom_qty,
+                'quantity': consume_move.product_uom_qty})
+        else:
+            consume_move.quantity_done = consume_move.product_uom_qty
+        consume_move.move_validate()
+        original_quants = consume_move.quant_ids.mapped('consumed_quant_ids')
+
+        for produce_move in produce_moves:
+            if produce_move.has_tracking != 'none':
+                original = original_quants.filtered(lambda quant: quant.product_id == produce_move.product_id)
+                self.env['stock.move.lots'].create({
+                    'move_id': produce_move.id,
+                    'lot_id': original.lot_id.id,
+                    'quantity_done': produce_move.product_uom_qty,
+                    'quantity': produce_move.product_uom_qty
+                })
+            else:
+                produce_move.quantity_done = produce_move.product_uom_qty
+        produce_moves.move_validate()
+        produced_quant_ids = produce_moves.mapped('quant_ids').filtered(lambda quant: quant.qty > 0)
+        consume_move.quant_ids.write({'produced_quant_ids': [(6, 0, produced_quant_ids.ids)]})
+
+        self.write({'state': 'done'})
+
+    def _generate_consume_moves(self):
+        moves = self.env['stock.move']
+        for unbuild in self:
+            move = self.env['stock.move'].create({
+                'name': unbuild.name,
+                'date': unbuild.create_date,
+                'product_id': unbuild.product_id.id,
+                'product_uom': unbuild.product_uom_id.id,
+                'product_uom_qty': unbuild.product_qty,
+                'location_id': unbuild.location_id.id,
+                'location_dest_id': unbuild.product_id.property_stock_production.id,
+                'origin': unbuild.name,
+                'consume_unbuild_id': unbuild.id,
+            })
+            move.action_confirm()
+            moves += move
+        return moves
+
+    def _generate_produce_moves(self):
+        moves = self.env['stock.move']
+        for unbuild in self:
+            factor = self.env['product.uom']._compute_qty(unbuild.product_uom_id.id, unbuild.product_qty, unbuild.bom_id.product_uom_id.id)
+            boms, lines = unbuild.bom_id.explode(unbuild.product_id, factor / unbuild.bom_id.product_qty, picking_type=unbuild.bom_id.picking_type_id)
+            for line, line_data in lines:
+                moves += unbuild._generate_move_from_bom_line(line, line_data['qty'])
+        return moves
+
+    def _generate_move_from_bom_line(self, bom_line, quantity):
+        return self.env['stock.move'].create({
+            'name': self.name,
+            'date': self.create_date,
+            'bom_line_id': bom_line.id,
+            'product_id': bom_line.product_id.id,
+            'product_uom_qty': quantity,
+            'product_uom': bom_line.product_uom_id.id,
+            'procure_method': 'make_to_stock',
+            'location_dest_id': self.location_dest_id.id,
+            'location_id': self.product_id.property_stock_production.id,
+            'unbuild_id': self.id,
+        })

--- a/addons/mrp/models/mrp_workcenter.py
+++ b/addons/mrp/models/mrp_workcenter.py
@@ -1,62 +1,214 @@
 # -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
-from odoo import api, exceptions, fields, models, _
+from dateutil import relativedelta
+import datetime
 
-# ----------------------------------------------------------
-# Work Centers
-# ----------------------------------------------------------
-# capacity_hour : capacity per hour. default: 1.0.
-#          Eg: If 5 concurrent operations at one time: capacity = 5 (because 5 employees)
-# unit_per_cycle : how many units are produced for one cycle
+from odoo import api, exceptions, fields, models, _
 
 
-class WorkCenter(models.Model):
+class MrpWorkcenter(models.Model):
     _name = 'mrp.workcenter'
     _description = 'Work Center'
     _inherits = {'resource.resource': 'resource_id'}
+    _order = "sequence, id"
 
-    active = fields.Boolean('Active', default=True)
     note = fields.Text(
         'Description',
-        help="Description of the Work Center. Explain here what's a cycle according to this Work Center.")
-    capacity_per_cycle = fields.Float(
-        'Capacity per Cycle', default=1.0,
-        help="Number of operations this Work Center can do in parallel. If this Work "
-             "Center represents a team of 5 workers, the capacity per cycle is 5.")
-    time_cycle = fields.Float(
-        'Time for 1 cycle (hour)', help="Time in hours for doing one cycle.")
-    time_start = fields.Float(
-        'Time before prod.', help="Time in hours for the setup.")
-    time_stop = fields.Float(
-        'Time after prod.', help="Time in hours for the cleaning.")
-    costs_hour = fields.Float(
-        'Cost per hour', help="Specify Cost of Work Center per hour.")
-    costs_hour_account_id = fields.Many2one(
-        'account.analytic.account', 'Hour Account',
-        help="Fill this only if you want automatic analytic accounting entries on production orders.")
-    costs_cycle = fields.Float(
-        'Cost per cycle', help="Specify Cost of Work Center per cycle.")
-    costs_cycle_account_id = fields.Many2one(
-        'account.analytic.account', 'Cycle Account',
-        help="Fill this only if you want automatic analytic accounting entries on production orders.")
-    costs_general_account_id = fields.Many2one(
-        'account.account', 'General Account',
-        domain=[('deprecated', '=', False)])
-    resource_id = fields.Many2one(
-        'resource.resource', 'Resource',
-        ondelete='cascade', required=True)
-    product_id = fields.Many2one(
-        'product.product', 'Work Center Product',
-        help="Fill this product to easily track your production costs in the analytic accounting.")
+        help="Description of the Work Center.")
+    capacity = fields.Float(
+        'Capacity', default=1.0, oldname='capacity_per_cycle',
+        help="Number of pieces that can be produced in parallel.")
+    sequence = fields.Integer(
+        'Sequence', default=1, required=True,
+        help="Gives the sequence order when displaying a list of work centers.")
+    color = fields.Integer('Color')
+    time_start = fields.Float('Time before prod.', help="Time in minutes for the setup.")
+    time_stop = fields.Float('Time after prod.', help="Time in minutes for the cleaning.")
+    resource_id = fields.Many2one('resource.resource', 'Resource', ondelete='cascade', required=True)
+    routing_line_ids = fields.One2many('mrp.routing.workcenter', 'workcenter_id', "Routing Lines")
+
+    order_ids = fields.One2many('mrp.workorder', 'workcenter_id', "Orders")
+    workorder_count = fields.Integer('# Work Orders', compute='_compute_workorder_count')
+    workorder_ready_count = fields.Integer('# Read Work Orders', compute='_compute_workorder_ready_count')
+    workorder_progress_count = fields.Integer('Total Running Orders', compute='_compute_workorder_progress_count')
+    workorder_pending_count = fields.Integer('Total Running Orders', compute='_compute_workorder_pending_count')
+    workorder_late_count = fields.Integer('Total Late Orders', compute='_compute_workorder_late_count')
+
+    time_ids = fields.One2many('mrp.workcenter.productivity', 'workcenter_id', 'Time Logs')
+    working_state = fields.Selection([
+        ('normal', 'Normal'),
+        ('blocked', 'Blocked'),
+        ('done', 'In Progress')], 'Status', compute="_compute_working_state", store=True)
+    blocked_time = fields.Float(
+        'Blocked Time', compute='_compute_blocked_time',
+        help='Blocked hours over the last month')
+    productive_time = fields.Float(
+        'Productive Time', compute='_compute_productive_time',
+        help='Productive hours over the last month')
+    oee = fields.Float(compute='_compute_oee', help='Overall Equipment Efficiency, based on the last month')
+    oee_target = fields.Float(string='OEE Target', help="OEE Target in percentage", default=90)
+    performance = fields.Integer('Performance', compute='_compute_performance', help='Performance over the last month')
+
+    @api.depends('order_ids.workcenter_id', 'order_ids.state')
+    def _compute_workorder_count(self):
+        data = self.env['mrp.workorder'].read_group([('workcenter_id', 'in', self.ids), ('state', 'not in', ('done', 'cancel'))], ['workcenter_id'], ['workcenter_id'])
+        count_data = dict((item['workcenter_id'][0], item['workcenter_id_count']) for item in data)
+        for workcenter in self:
+            workcenter.workorder_count = count_data.get(workcenter.id, 0)
+
+    @api.depends('order_ids.workcenter_id', 'order_ids.state')
+    def _compute_workorder_ready_count(self):
+        data = self.env['mrp.workorder'].read_group([('workcenter_id', 'in', self.ids), ('state', '=', 'ready')], ['workcenter_id'], ['workcenter_id'])
+        count_data = dict((item['workcenter_id'][0], item['workcenter_id_count']) for item in data)
+        for workcenter in self:
+            workcenter.workorder_ready_count = count_data.get(workcenter.id, 0)
+
+    @api.depends('order_ids.workcenter_id', 'order_ids.state')
+    def _compute_workorder_progress_count(self):
+        data = self.env['mrp.workorder'].read_group([('workcenter_id', 'in', self.ids), ('state', '=', 'progress')], ['workcenter_id'], ['workcenter_id'])
+        count_data = dict((item['workcenter_id'][0], item['workcenter_id_count']) for item in data)
+        for workcenter in self:
+            workcenter.workorder_progress_count = count_data.get(workcenter.id, 0)
+
+    @api.depends('order_ids.workcenter_id', 'order_ids.state')
+    def _compute_workorder_pending_count(self):
+        data = self.env['mrp.workorder'].read_group([('workcenter_id', 'in', self.ids), ('state', '=', 'pending')], ['workcenter_id'], ['workcenter_id'])
+        count_data = dict((item['workcenter_id'][0], item['workcenter_id_count']) for item in data)
+        for workcenter in self:
+            workcenter.workorder_pending_count = count_data.get(workcenter.id, 0)
+
+    @api.depends('order_ids.workcenter_id', 'order_ids.state', 'order_ids.date_planned_start')
+    def _compute_workorder_late_count(self):
+        data = self.env['mrp.workorder'].read_group([('workcenter_id', 'in', self.ids), ('state', 'in', ('pending', 'ready')), ('date_planned_start', '<', datetime.datetime.now().strftime('%Y-%m-%d'))], ['workcenter_id'], ['workcenter_id'])
+        count_data = dict((item['workcenter_id'][0], item['workcenter_id_count']) for item in data)
+        for workcenter in self:
+            workcenter.workorder_late_count = count_data.get(workcenter.id, 0)
+
+    @api.multi
+    @api.depends('time_ids.date_end', 'time_ids.loss_type')
+    def _compute_working_state(self):
+        for workcenter in self:
+            time_log = self.env['mrp.workcenter.productivity'].search([('workcenter_id', '=', workcenter.id)], limit=1)
+            if not time_log or time_log.date_end:
+                workcenter.working_state = 'normal'
+            elif time_log.loss_type in ('productive', 'performance'):
+                workcenter.working_state = 'done'
+            else:
+                workcenter.working_state = 'blocked'
+
+    @api.multi
+    def _compute_blocked_time(self):
+        # TDE FIXME: productivity loss type should be only losses, probably count other time logs differently ??
+        data = self.env['mrp.workcenter.productivity'].read_group([
+            ('date_start', '>=', fields.Datetime.to_string(datetime.datetime.now() - relativedelta.relativedelta(months=1))),
+            ('workcenter_id', 'in', self.ids),
+            ('date_end', '!=', False),
+            ('loss_type', '!=', 'productive')],
+            ['duration', 'workcenter_id'], ['workcenter_id'], lazy=False)
+        count_data = dict((item['workcenter_id'][0], item['duration']) for item in data)
+        for workcenter in self:
+            workcenter.blocked_time = count_data.get(workcenter.id, 0.0)
+
+    @api.multi
+    def _compute_productive_time(self):
+        # TDE FIXME: productivity loss type should be only losses, probably count other time logs differently
+        data = self.env['mrp.workcenter.productivity'].read_group([
+            ('date_start', '>=', fields.Datetime.to_string(datetime.datetime.now() - relativedelta.relativedelta(months=1))),
+            ('workcenter_id', 'in', self.ids),
+            ('date_end', '!=', False),
+            ('loss_type', '=', 'productive')],
+            ['duration', 'workcenter_id'], ['workcenter_id'], lazy=False)
+        count_data = dict((item['workcenter_id'][0], item['duration']) for item in data)
+        for workcenter in self:
+            workcenter.productive_time = count_data.get(workcenter.id, 0.0)
+
+    @api.depends('blocked_time', 'productive_time')
+    @api.one
+    def _compute_oee(self):
+        if self.productive_time:
+            self.oee = round(self.productive_time * 100.0 / (self.productive_time + self.blocked_time), 2)
+        else:
+            self.oee = 0.0
+
+    @api.multi
+    def _compute_performance(self):
+        wo_data = self.env['mrp.workorder'].read_group([
+            ('date_start', '>=', fields.Datetime.to_string(datetime.datetime.now() - relativedelta.relativedelta(months=1))),
+            ('workcenter_id', 'in', self.ids),
+            ('state', '=', 'done')], ['duration_expected', 'workcenter_id', 'duration'], ['workcenter_id'], lazy=False)
+        duration_expected = dict((data['workcenter_id'][0], data['duration_expected']) for data in wo_data)
+        duration = dict((data['workcenter_id'][0], data['duration']) for data in wo_data)
+        for workcenter in self:
+            if duration.get(workcenter.id):
+                workcenter.performance = 100 * duration_expected.get(workcenter.id, 0.0) / duration[workcenter.id]
+            else:
+                workcenter.performance = 0.0
+
+    @api.multi
+    @api.constrains('capacity')
+    def _check_capacity(self):
+        if any(workcenter.capacity <= 0.0 for workcenter in self):
+            raise exceptions.UserError(_('The capacity must be strictly positive.'))
+
+    @api.multi
+    def unblock(self):
+        self.ensure_one()
+        if self.working_state != 'blocked':
+            raise exceptions.UserError(_("It has been unblocked already. "))
+        times = self.env['mrp.workcenter.productivity'].search([('workcenter_id', '=', self.id), ('date_end', '=', False)])
+        times.write({'date_end': fields.Datetime.now()})
+        return {'type': 'ir.actions.client', 'tag': 'reload'}
+
+
+class MrpWorkcenterProductivityLoss(models.Model):
+    _name = "mrp.workcenter.productivity.loss"
+    _description = "TPM Big Losses"
+    _order = "sequence, id"
+
+    name = fields.Char('Reason', required=True)
+    sequence = fields.Integer('Sequence', default=1)
+    manual = fields.Boolean('Is a Blocking Reason', default=True)
+    loss_type = fields.Selection([
+        ('availability', 'Availability'),
+        ('performance', 'Performance'),
+        ('quality', 'Quality'),
+        ('productive', 'Productive')], "Effectiveness Category",
+        default='availability', required=True)
+
+
+class MrpWorkcenterProductivity(models.Model):
+    _name = "mrp.workcenter.productivity"
+    _description = "Workcenter Productivity Log"
+    _order = "id desc"
+    _rec_name = "loss_id"
+
+    workcenter_id = fields.Many2one('mrp.workcenter', "Work Center", required=True)
+    workorder_id = fields.Many2one('mrp.workorder', 'Work Order')
+    user_id = fields.Many2one(
+        'res.users', "User",
+        default=lambda self: self.env.uid)
+    loss_id = fields.Many2one(
+        'mrp.workcenter.productivity.loss', "Loss Reason",
+        ondelete='restrict', required=True)
+    loss_type = fields.Selection(
+        "Effectiveness", related='loss_id.loss_type', store=True)
+    description = fields.Text('Description')
+    date_start = fields.Datetime('Start Date', default=fields.Datetime.now(), required=True)
+    date_end = fields.Datetime('End Date')
+    duration = fields.Float('Duration', compute='_compute_duration', store=True)
+
+    @api.depends('date_end', 'date_start')
+    def _compute_duration(self):
+        for blocktime in self:
+            if blocktime.date_end:
+                diff = fields.Datetime.from_string(blocktime.date_end) - fields.Datetime.from_string(blocktime.date_start)
+                blocktime.duration = round(diff.total_seconds() / 60.0, 2)
+            else:
+                blocktime.duration = 0.0
 
     @api.multi
-    @api.constrains('capacity_per_cycle')
-    def _check_capacity_per_cycle(self):
-        if any(workcenter.capacity_per_cycle <= 0.0 for workcenter in self):
-            raise exceptions.UserError(_('The capacity per cycle must be strictly positive.'))
-
-    @api.onchange('product_id')
-    def on_change_product_id(self):
-        if self.product_id:
-            self.costs_hour = self.product_id.standard_price
+    def button_block(self):
+        self.ensure_one()
+        self.workcenter_id.order_ids.end_all()
+        return {'type': 'ir.actions.client', 'tag': 'reload'}

--- a/None
+++ b/addons/mrp/models/mrp_workorder.py
@@ -0,0 +1,443 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from datetime import datetime
+from dateutil.relativedelta import relativedelta
+
+from odoo import api, fields, models, _
+from odoo.exceptions import UserError
+from odoo.tools import float_compare
+from odoo.addons import decimal_precision as dp
+
+
+class MrpWorkorder(models.Model):
+    _name = 'mrp.workorder'
+    _description = 'Work Order'
+    _inherit = ['mail.thread']
+
+    name = fields.Char(
+        'Work Order', required=True,
+        states={'done': [('readonly', True)], 'cancel': [('readonly', True)]})
+
+    workcenter_id = fields.Many2one(
+        'mrp.workcenter', 'Work Center', required=True,
+        states={'done': [('readonly', True)], 'cancel': [('readonly', True)]})
+    working_state = fields.Selection(
+        'Workcenter Status', related='workcenter_id.working_state',
+        help='Technical: used in views only')
+
+    production_id = fields.Many2one(
+        'mrp.production', 'Manufacturing Order',
+        index=True, ondelete='cascade', required=True, track_visibility='onchange',
+        states={'done': [('readonly', True)], 'cancel': [('readonly', True)]})
+    product_id = fields.Many2one(
+        'product.product', 'Product',
+        related='production_id.product_id', readonly=True,
+        help='Technical: used in views only.')
+    product_uom_id = fields.Many2one(
+        'product.uom', 'Unit of Measure',
+        related='production_id.product_uom_id', readonly=True,
+        help='Technical: used in views only.')
+    production_availability = fields.Selection(
+        'Stock Availability', readonly=True,
+        related='production_id.availability', store=True,
+        help='Technical: used in views and domains only.')
+    production_state = fields.Selection(
+        'Production State', readonly=True,
+        related='production_id.state',
+        help='Technical: used in views only.')
+    product_tracking = fields.Selection(
+        'Product Tracking', related='production_id.product_id.tracking',
+        help='Technical: used in views only.')
+    qty_production = fields.Float('Original Production Quantity', readonly=True, related='production_id.product_qty')
+    qty_produced = fields.Float(
+        'Quantity', default=0.0,
+        readonly=True,
+        digits_compute=dp.get_precision('Product Unit of Measure'),
+        help="The number of products already handled by this work order")
+    qty_producing = fields.Float(
+        'Currently Produced Quantity', default=1.0,
+        digits_compute=dp.get_precision('Product Unit of Measure'),
+        states={'done': [('readonly', True)], 'cancel': [('readonly', True)]})
+    is_produced = fields.Boolean(compute='_compute_is_produced')
+
+    state = fields.Selection([
+        ('pending', 'Pending'),
+        ('ready', 'Ready'),
+        ('progress', 'In Progress'),
+        ('done', 'Finished'),
+        ('cancel', 'Cancelled')], string='Status',
+        default='pending')
+    date_planned_start = fields.Datetime(
+        'Scheduled Date Start',
+        states={'done': [('readonly', True)], 'cancel': [('readonly', True)]})
+    date_planned_finished = fields.Datetime(
+        'Scheduled Date Finished',
+        states={'done': [('readonly', True)], 'cancel': [('readonly', True)]})
+    date_start = fields.Datetime(
+        'Effective Start Date',
+        states={'done': [('readonly', True)], 'cancel': [('readonly', True)]})
+    date_finished = fields.Datetime(
+        'Effective End Date',
+        states={'done': [('readonly', True)], 'cancel': [('readonly', True)]})
+
+    duration_expected = fields.Float(
+        'Expected Duration', digits=(16, 2),
+        states={'done': [('readonly', True)], 'cancel': [('readonly', True)]},
+        help="Expected duration (in minutes)")
+    duration = fields.Float(
+        'Real Duration', compute='_compute_duration',
+        readonly=True, store=True)
+    duration_unit = fields.Float(
+        'Duration Per Unit', compute='_compute_duration',
+        readonly=True, store=True)
+    duration_percent = fields.Integer(
+        'Duration Deviation (%)', compute='_compute_duration',
+        group_operator="avg", readonly=True, store=True)
+
+    operation_id = fields.Many2one(
+        'mrp.routing.workcenter', 'Operation')  # Should be used differently as BoM can change in the meantime
+    worksheet = fields.Binary(
+        'Worksheet', related='operation_id.worksheet', readonly=True)
+    move_raw_ids = fields.One2many(
+        'stock.move', 'workorder_id', 'Moves')
+    move_lot_ids = fields.One2many(
+        'stock.move.lots', 'workorder_id', 'Moves to Track',
+        domain=[('done_wo', '=', True)],
+        help="Inventory moves for which you must scan a lot number at this work order")
+    active_move_lot_ids = fields.One2many(
+        'stock.move.lots', 'workorder_id',
+        domain=[('done_wo', '=', False)])
+    final_lot_id = fields.Many2one(
+        'stock.production.lot', 'Current Lot', domain="[('product_id', '=', product_id)]",
+        states={'done': [('readonly', True)], 'cancel': [('readonly', True)]})
+    time_ids = fields.One2many(
+        'mrp.workcenter.productivity', 'workorder_id')
+    is_user_working = fields.Boolean(
+        'Is Current User Working', compute='_compute_is_user_working',
+        help="Technical field indicating whether the current user is working. ")
+    production_messages = fields.Html('Workorder Message', compute='_compute_production_messages')
+
+    next_work_order_id = fields.Many2one('mrp.workorder', "Next Work Order")
+    scrap_ids = fields.One2many('stock.scrap', 'workorder_id')
+    scrap_count = fields.Integer(compute='_compute_scrap_move_count', string='Scrap Move')
+    color = fields.Integer('Color', compute='_compute_color')
+    capacity = fields.Float(
+        'Capacity', default=1.0,
+        help="Number of pieces that can be produced in parallel.")
+
+    @api.one
+    @api.depends('production_id.product_qty', 'qty_produced')
+    def _compute_is_produced(self):
+        self.is_produced = self.qty_produced >= self.production_id.product_qty
+
+    @api.one
+    @api.depends('time_ids.duration', 'qty_produced')
+    def _compute_duration(self):
+        self.duration = sum(self.time_ids.mapped('duration'))
+        self.duration_unit = round(self.duration / max(self.qty_produced, 1), 2)  # rounding 2 because it is a time
+        if self.duration:
+            self.duration_percent = 100 * (self.duration_expected - self.duration) / self.duration
+        else:
+            self.duration_percent = 0
+
+    def _compute_is_user_working(self):
+        """ Checks whether the current user is working """
+        for order in self:
+            if order.time_ids.filtered(lambda x: (x.user_id.id == self.env.user.id) and (not x.date_end) and (x.loss_type in ('productive', 'performance'))):
+                order.is_user_working = True
+            else:
+                order.is_user_working = False
+
+    @api.depends('production_id', 'workcenter_id', 'production_id.bom_id')
+    def _compute_production_messages(self):
+        ProductionMessage = self.env['mrp.message']
+        for workorder in self:
+            domain = [
+                ('valid_until', '>=', fields.Date.today()),
+                '|', ('workcenter_id', '=', False), ('workcenter_id', '=', workorder.workcenter_id.id),
+                '|', '|', '|',
+                ('product_id', '=', workorder.product_id.id),
+                '&', ('product_id', '=', False), ('product_tmpl_id', '=', workorder.product_id.product_tmpl_id.id),
+                ('bom_id', '=', workorder.production_id.bom_id.id),
+                ('routing_id', '=', workorder.operation_id.routing_id.id)]
+            messages = ProductionMessage.search(domain).mapped('message')
+            workorder.production_messages = "<br/>".join(messages)
+
+    @api.multi
+    def _compute_scrap_move_count(self):
+        data = self.env['stock.scrap'].read_group([('workorder_id', 'in', self.ids)], ['workorder_id'], ['workorder_id'])
+        count_data = dict((item['workorder_id'][0], item['workorder_id_count']) for item in data)
+        for workorder in self:
+            workorder.scrap_count = count_data.get(workorder.id, 0)
+
+    @api.multi
+    @api.depends('date_planned_finished', 'production_id.date_planned_finished')
+    def _compute_color(self):
+        late_orders = self.filtered(lambda x: x.production_id.date_planned_finished and x.date_planned_finished > x.production_id.date_planned_finished)
+        for order in late_orders:
+            order.color = 4
+        for order in (self - late_orders):
+            order.color = 2
+
+    @api.onchange('qty_producing')
+    def _onchange_qty_producing(self):
+        """ Update stock.move.lot records, according to the new qty currently
+        produced. """
+        moves = self.move_raw_ids.filtered(lambda move: move.state not in ('done', 'cancel') and move.product_id.tracking != 'none' and move.product_id.id != self.production_id.product_id.id)
+        for move in moves:
+            move_lots = self.active_move_lot_ids.filtered(lambda move_lot: move_lot.move_id == move)
+            if not move_lots:
+                continue
+            new_qty = move.bom_line_id.product_qty * self.qty_producing / move.bom_line_id.bom_id.product_qty
+            if move.product_id.tracking == 'lot':
+                move_lots[0].quantity = new_qty
+            elif move.product_id.tracking == 'serial':
+                # Create extra pseudo record
+                qty_todo = new_qty - sum(move_lots.mapped('quantity'))
+                if qty_todo > 0.0:  # TDE: float compare
+                    while qty_todo > 0:
+                        self.active_move_lot_ids += self.env['stock.move.lots'].new({
+                            'move_id': move.id,
+                            'product_id': move.product_id.id,
+                            'lot_id': False,
+                            'quantity': min(1.0, qty_todo),
+                            'quantity_done': 0,
+                            'workorder_id': self.id,
+                            'done_wo': False
+                        })
+                        qty_todo -= 1
+                elif qty_todo < 0.0:
+                    qty_todo = abs(qty_todo)
+                    for move_lot in move_lots:
+                        if qty_todo <= 0:
+                            break
+                        if move_lot.quantity_done == 0 and qty_todo > move_lot.quantity:
+                            qty_todo = qty_todo - move_lot.quantity
+                            self.active_move_lot_ids -= move_lot  # Difference operator
+                        else:
+                            move_lot.quantity = move_lot.quantity - qty_todo
+                            qty_todo = 0
+
+    @api.multi
+    def write(self, values):
+        if ('date_planned_start' in values or 'date_planned_finished' in values) and any(workorder.state == 'done' for workorder in self):
+            raise UserError(_('You can not change the finished work order.'))
+        return super(MrpWorkorder, self).write(values)
+
+    def _generate_lot_ids(self):
+        """ Generate stock move lots """
+        self.ensure_one()
+        MoveLot = self.env['stock.move.lots']
+        tracked_moves = self.move_raw_ids.filtered(
+            lambda move: move.state not in ('done', 'cancel') and move.product_id.tracking != 'none' and move.product_id != self.production_id.product_id)
+        for move in tracked_moves:
+            qty = self.qty_producing / move.bom_line_id.bom_id.product_qty * move.bom_line_id.product_qty
+            if move.product_id.tracking == 'serial':
+                while float_compare(qty, 0.0, precision_rounding=move.product_uom.rounding) > 0:
+                    MoveLot.create({
+                        'move_id': move.id,
+                        'quantity': min(1, qty),
+                        'quantity_done': 0,
+                        'production_id': self.production_id.id,
+                        'workorder_id': self.id,
+                        'product_id': move.product_id.id,
+                        'done_wo': False,
+                    })
+                    qty -= 1
+            else:
+                MoveLot.create({
+                    'move_id': move.id,
+                    'quantity': qty,
+                    'quantity_done': 0,
+                    'product_id': move.product_id.id,
+                    'production_id': self.production_id.id,
+                    'workorder_id': self.id,
+                    'done_wo': False,
+                    })
+
+    @api.multi
+    def record_production(self):
+        self.ensure_one()
+        if self.qty_producing <= 0:
+            raise UserError(_('Please set the quantity you produced in the Current Qty field. It can not be 0!'))
+
+        if (self.production_id.product_id.tracking != 'none') and not self.final_lot_id:
+            raise UserError(_('You should provide a lot for the final product'))
+
+        # Update quantities done on each raw material line
+        raw_moves = self.move_raw_ids.filtered(lambda x: (x.has_tracking == 'none') and (x.state not in ('done', 'cancel')) and x.bom_line_id)
+        for move in raw_moves:
+            if move.unit_factor:
+                move.quantity_done += self.qty_producing * move.unit_factor
+
+        # Transfer quantities from temporary to final move lots or make them final
+        for move_lot in self.active_move_lot_ids:
+            # Check if move_lot already exists
+            if move_lot.quantity_done <= 0:  # rounding...
+                move_lot.unlink()
+                continue
+            if not move_lot.lot_id:
+                raise UserError(_('You should provide a lot for a component'))
+            # Search other move_lot where it could be added:
+            lots = self.move_lot_ids.filtered(lambda x: (x.lot_id.id == move_lot.lot_id.id) and (not x.lot_produced_id) and (not x.done_move))
+            if lots:
+                lots[0].quantity_done += move_lot.quantity_done
+                lots[0].lot_produced_id = self.final_lot_id.id
+                move_lot.unlink()
+            else:
+                move_lot.lot_produced_id = self.final_lot_id.id
+                move_lot.done_wo = True
+
+        # One a piece is produced, you can launch the next work order
+        if self.next_work_order_id.state == 'pending':
+            self.next_work_order_id.state = 'ready'
+        if self.next_work_order_id and self.final_lot_id and not self.next_work_order_id.final_lot_id:
+            self.next_work_order_id.final_lot_id = self.final_lot_id.id
+
+        # TODO: add filter for those that have not been done yet --> need to check as it can have different filters
+        self.move_lot_ids.filtered(lambda x: not x.done_move and not x.lot_produced_id).write({'lot_produced_id': self.final_lot_id.id,
+                                          'lot_produced_qty': self.qty_producing,})
+
+        # If last work order, then post lots used
+        # TODO: should be same as checking if for every workorder something has been done?
+        if not self.next_work_order_id:
+            production_move = self.production_id.move_finished_ids.filtered(lambda x: (x.product_id.id == self.production_id.product_id.id) and (x.state not in ('done', 'cancel')))
+            if production_move.product_id.tracking != 'none':
+                move_lot = production_move.move_lot_ids.filtered(lambda x: x.lot_id.id == self.final_lot_id.id)
+                if move_lot:
+                    move_lot.quantity += self.qty_producing
+                else:
+                    move_lot.create({'move_id': production_move.id,
+                                     'lot_id': self.final_lot_id.id,
+                                     'quantity': self.qty_producing,
+                                     'quantity_done': self.qty_producing,
+                                     'workorder_id': self.id,
+                                     })
+            else:
+                production_move.quantity_done += self.qty_producing  # TODO: UoM conversion?
+        # Update workorder quantity produced
+        self.qty_produced += self.qty_producing
+
+        # Set a qty producing
+        if self.qty_produced >= self.production_id.product_qty:
+            self.qty_producing = 0
+        elif self.production_id.product_id.tracking == 'serial':
+            self.qty_producing = 1.0
+            self._generate_lot_ids()
+        else:
+            self.qty_producing = self.production_id.product_qty - self.qty_produced
+            self._generate_lot_ids()
+
+        self.final_lot_id = False
+        if self.qty_produced >= self.production_id.product_qty:
+            self.button_finish()
+
+    @api.multi
+    def button_start(self):
+        # TDE CLEANME
+        timeline = self.env['mrp.workcenter.productivity']
+        if self.duration < self.duration_expected:
+            loss_id = self.env['mrp.workcenter.productivity.loss'].search([('loss_type','=','productive')], limit=1)
+            if not len(loss_id):
+                raise UserError(_("You need to define at least one productivity loss in the category 'Productivity'. Create one from the Manufacturing app, menu: Configuration / Productivity Losses."))
+        else:
+            loss_id = self.env['mrp.workcenter.productivity.loss'].search([('loss_type','=','performance')], limit=1)
+            if not len(loss_id):
+                raise UserError(_("You need to define at least one productivity loss in the category 'Performance'. Create one from the Manufacturing app, menu: Configuration / Productivity Losses."))
+        for workorder in self:
+            if workorder.production_id.state != 'progress':
+                workorder.production_id.state = 'progress'
+            timeline.create({
+                'workorder_id': workorder.id,
+                'workcenter_id': workorder.workcenter_id.id,
+                'description': _('Time Tracking: ')+self.env.user.name,
+                'loss_id': loss_id[0].id,
+                'date_start': datetime.now(),
+                'user_id': self.env.user.id
+            })
+        self.write({'state': 'progress',
+                    'date_start': datetime.now(),
+        })
+
+    @api.multi
+    def button_finish(self):
+        self.ensure_one()
+        self.end_all()
+        self.write({'state': 'done', 'date_finished': fields.Datetime.now()})
+        if not self.production_id.workorder_ids.filtered(lambda x: x.state not in ('done','cancel')):
+            self.production_id.post_inventory() # User should put it to done manually
+
+    @api.multi
+    def end_previous(self, doall=False):
+        """
+        @param: doall:  This will close all open time lines on the open work orders when doall = True, otherwise
+        only the one of the current user
+        """
+        # TDE CLEANME
+        timeline_obj = self.env['mrp.workcenter.productivity']
+        domain = [('workorder_id', 'in', self.ids), ('date_end', '=', False)]
+        if not doall:
+            domain.append(('user_id', '=', self.env.user.id))
+        for timeline in timeline_obj.search(domain, limit=None if doall else 1):
+            wo = timeline.workorder_id
+            if timeline.loss_type != 'productive':
+                timeline.write({'date_end': fields.Datetime.now()})
+            else:
+                maxdate = fields.Datetime.from_string(timeline.date_start) + relativedelta(minutes=wo.duration_expected - wo.duration)
+                enddate = datetime.now()
+                if maxdate > enddate:
+                    timeline.write({'date_end': enddate})
+                else:
+                    timeline.write({'date_end': maxdate})
+                    loss_id = self.env['mrp.workcenter.productivity.loss'].search([('loss_type', '=', 'performance')], limit=1)
+                    if not len(loss_id):
+                        raise UserError(_("You need to define at least one unactive productivity loss in the category 'Performance'. Create one from the Manufacturing app, menu: Configuration / Productivity Losses."))
+                    timeline.copy({'date_start': maxdate, 'date_end': enddate, 'loss_id': loss_id.id})
+
+    @api.multi
+    def end_all(self):
+        return self.end_previous(doall=True)
+
+    @api.multi
+    def button_pending(self):
+        self.end_previous()
+
+    @api.multi
+    def button_unblock(self):
+        for order in self:
+            order.workcenter_id.unblock()
+
+    @api.multi
+    def action_cancel(self):
+        self.write({'state': 'cancel'})
+
+    @api.multi
+    def button_done(self):
+        if any([x.state in ('done', 'cancel') for x in self]):
+            raise UserError(_('A Manufacturing Order is already done or cancelled!'))
+        self.end_all()
+        self.write({'state': 'done',
+                    'date_finished': datetime.now()})
+
+    @api.multi
+    def button_scrap(self):
+        self.ensure_one()
+        return {
+            'name': _('Scrap'),
+            'view_type': 'form',
+            'view_mode': 'form',
+            'res_model': 'stock.scrap',
+            'view_id': self.env.ref('stock.stock_scrap_form_view2').id,
+            'type': 'ir.actions.act_window',
+            'context': {'default_workorder_id': self.id, 'default_production_id': self.production_id.id, 'product_ids': (self.production_id.move_raw_ids.filtered(lambda x: x.state not in ('done', 'cancel')) | self.production_id.move_finished_ids.filtered(lambda x: x.state == 'done')).mapped('product_id').ids},
+            # 'context': {'product_ids': self.move_raw_ids.filtered(lambda x: x.state not in ('done', 'cancel')).mapped('product_id').ids + [self.production_id.product_id.id]},
+            'target': 'new',
+        }
+
+    @api.multi
+    def action_see_move_scrap(self):
+        self.ensure_one()
+        action = self.env.ref('stock.action_stock_scrap').read()[0]
+        action['domain'] = [('workorder_id', '=', self.id)]
+        return action

--- a/addons/mrp/models/procurement.py
+++ b/addons/mrp/models/procurement.py
@@ -1,11 +1,9 @@
 # -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
-from datetime import datetime
 from dateutil.relativedelta import relativedelta
 
 from odoo import api, fields, models, _
-from odoo.tools import DEFAULT_SERVER_DATETIME_FORMAT
 
 
 class ProcurementRule(models.Model):
@@ -19,89 +17,75 @@ class ProcurementRule(models.Model):
 class ProcurementOrder(models.Model):
     _inherit = 'procurement.order'
 
-    bom_id = fields.Many2one('mrp.bom', 'BoM', ondelete='cascade', select=True)
-    property_ids = fields.Many2many('mrp.property', 'procurement_property_rel', 'procurement_id','property_id', 'Properties')
+    bom_id = fields.Many2one('mrp.bom', 'BoM', index=True, ondelete='cascade')
     production_id = fields.Many2one('mrp.production', 'Manufacturing Order')
 
     @api.multi
     def propagate_cancels(self):
-        to_propagate = self.filtered(lambda procurement: procurement.rule_id.action == 'manufacture' and procurement.production_id).mapped('production_id')
-        if to_propagate:
-            to_propagate.action_cancel()
+        cancel_man_orders = self.filtered(lambda procurement: procurement.rule_id.action == 'manufacture' and procurement.production_id).mapped('production_id')
+        if cancel_man_orders:
+            cancel_man_orders.action_cancel()
         return super(ProcurementOrder, self).propagate_cancels()
 
     @api.multi
     def _run(self):
-        if self.rule_id and self.rule_id.action == 'manufacture':
+        self.ensure_one()
+        if self.rule_id.action == 'manufacture':
             # make a manufacturing order for the procurement
             return self.make_mo()[self.id]
         return super(ProcurementOrder, self)._run()
 
     @api.multi
     def _check(self):
-        if self.production_id and self.production_id.state == 'done':  # TOCHECK: no better method? 
-            return True
-        return super(ProcurementOrder, self)._check()
+        return self.production_id.state == 'done' or super(ProcurementOrder, self)._check()
 
     @api.multi
-    def check_bom_exists(self):
-        """ Finds the bill of material for the product from procurement order.
-        @return: True or False
-        """
-        for procurement in self:
-            # TDE FIXME: properties -> property_ids
-            bom = self.env['mrp.bom']._bom_find(product_id=procurement.product_id.id, properties=procurement.property_ids.ids)
-            if not bom:
-                return False
-        return True
+    def _get_matching_bom(self):
+        """ Finds the bill of material for the product from procurement order. """
+        if self.bom_id:
+            return self.bom_id
+        return self.env['mrp.bom'].with_context(
+            company_id=self.company_id.id, force_company=self.company_id.id
+        )._bom_find(product=self.product_id, picking_type=self.rule_id.picking_type_id)  # TDE FIXME: context bullshit
 
     def _get_date_planned(self):
-        format_date_planned = datetime.strptime(self.date_planned,
-                                                DEFAULT_SERVER_DATETIME_FORMAT)
+        format_date_planned = fields.Datetime.from_string(self.date_planned)
         date_planned = format_date_planned - relativedelta(days=self.product_id.produce_delay or 0.0)
         date_planned = date_planned - relativedelta(days=self.company_id.manufacturing_lead)
         return date_planned
 
-    def _prepare_mo_vals(self):
-        BoM = self.env['mrp.bom'].with_context(company_id=self.company_id.id)
-        if self.bom_id:
-            bom = self.bom_id
-            routing_id = self.bom_id.routing_id.id
-        else:
-            bom = BoM._bom_find(product_id=self.product_id.id,
-                                properties=self.property_ids.ids)
-            routing_id = bom.routing_id.id
+    def _prepare_mo_vals(self, bom):
         return {
             'origin': self.origin,
             'product_id': self.product_id.id,
             'product_qty': self.product_qty,
-            'product_uom': self.product_uom.id,
+            'product_uom_id': self.product_uom.id,
             'location_src_id': self.rule_id.location_src_id.id or self.location_id.id,
             'location_dest_id': self.location_id.id,
             'bom_id': bom.id,
-            'routing_id': routing_id,
-            'date_planned': self._get_date_planned().strftime('%Y-%m-%d %H:%M:%S'),  # TDE FIXME: use tools
-            'move_prod_id': self.move_dest_id.id,
+            'date_planned_start': fields.Datetime.to_string(self._get_date_planned()),
+            'date_planned_finished': self.date_planned,
+            'procurement_group_id': self.group_id.id,
+            'propagate': self.rule_id.propagate,
+            'picking_type_id': self.rule_id.picking_type_id.id or self.warehouse_id.manu_type_id.id,
             'company_id': self.company_id.id,
+            'procurement_ids': [(6, 0, [self.id])],
         }
 
     @api.multi
     def make_mo(self):
-        """ Make Manufacturing(production) order from procurement
-        @return: New created Production Orders procurement wise
-        """
+        """ Create production orders from procurements """
         res = {}
         Production = self.env['mrp.production']
         for procurement in self:
             ProductionSudo = Production.sudo().with_context(force_company=procurement.company_id.id)
-            if procurement.check_bom_exists():
+            bom = procurement._get_matching_bom()
+            if bom:
                 # create the MO as SUPERUSER because the current user may not have the rights to do it (mto product launched by a sale for example)
-                production = ProductionSudo.create(procurement._prepare_mo_vals())
+                production = ProductionSudo.create(procurement._prepare_mo_vals(bom))
                 res[procurement.id] = production.id
-                procurement.write({'production_id': production.id})
+
                 procurement.message_post(body=_("Manufacturing Order <em>%s</em> created.") % (production.name))
-                production.action_compute(properties=procurement.property_ids.ids)
-                production.signal_workflow('button_confirm')
             else:
                 res[procurement.id] = False
                 procurement.message_post(body=_("No BoM exists for this product!"))

--- a/addons/mrp/models/product.py
+++ b/addons/mrp/models/product.py
@@ -7,27 +7,26 @@ from odoo import api, fields, models
 class ProductTemplate(models.Model):
     _inherit = "product.template"
 
-    bom_ids = fields.One2many('mrp.bom', 'product_tmpl_id','Bill of Materials')
-    bom_count = fields.Integer(compute='_compute_bom_count', string='# Bill of Material')
-    mo_count = fields.Integer(compute='_compute_mo_count', string='# Manufacturing Orders')
+    bom_ids = fields.One2many('mrp.bom', 'product_tmpl_id', 'Bill of Materials')
+    bom_count = fields.Integer('# Bill of Material', compute='_compute_bom_count')
+    mo_count = fields.Integer('# Manufacturing Orders', compute='_compute_mo_count')
     produce_delay = fields.Float(
         'Manufacturing Lead Time', default=0.0,
         help="Average delay in days to produce this product. In the case of multi-level BOM, the manufacturing lead times of the components will be added.")
 
-    @api.multi
     def _compute_bom_count(self):
         read_group_res = self.env['mrp.bom'].read_group([('product_tmpl_id', 'in', self.ids)], ['product_tmpl_id'], ['product_tmpl_id'])
         mapped_data = dict([(data['product_tmpl_id'][0], data['product_tmpl_id_count']) for data in read_group_res])
         for product in self:
-            product.mo_count = mapped_data.get(product.id, 0)
+            product.bom_count = mapped_data.get(product.id, 0)
 
     @api.one
     def _compute_mo_count(self):
+        # TDE FIXME: directly use a read_group
         self.mo_count = sum(self.mapped('product_variant_ids').mapped('mo_count'))
 
     @api.multi
     def action_view_mos(self):
-        # TDE FIXME: get_products does not exists
         product_ids = self.mapped('product_variant_ids').ids
         action = self.env.ref('mrp.act_product_mrp_production').read()[0]
         if len(self) == 1 and len(product_ids) == 1:
@@ -41,9 +40,8 @@ class ProductTemplate(models.Model):
 class ProductProduct(models.Model):
     _inherit = "product.product"
 
-    mo_count = fields.Integer(compute='_compute_mo_count', string='# Manufacturing Orders')
+    mo_count = fields.Integer('# Manufacturing Orders', compute='_compute_mo_count')
 
-    @api.multi
     def _compute_mo_count(self):
         read_group_res = self.env['mrp.production'].read_group([('product_id', 'in', self.ids)], ['product_id'], ['product_id'])
         mapped_data = dict([(data['product_id'][0], data['product_id_count']) for data in read_group_res])
@@ -53,12 +51,11 @@ class ProductProduct(models.Model):
     @api.multi
     def action_view_bom(self):
         action = self.env.ref('mrp.product_open_bom').read()[0]
-        template_ids = self.mapped('producdt_tmpl_id').ids
+        template_ids = self.mapped('product_tmpl_id').ids
         # bom specific to this variant or global to template
         action['context'] = {
-            'search_default_product_tmpl_id': template_ids[0],
-            'search_default_product_id': self.ids[0],
             'default_product_tmpl_id': template_ids[0],
             'default_product_id': self.ids[0],
         }
+        action['domain'] = ['|', ('product_id', 'in', [self.ids]), '&', ('product_id', '=', False), ('product_tmpl_id', 'in', template_ids)]
         return action

--- a/addons/mrp/models/stock_move.py
+++ b/addons/mrp/models/stock_move.py
@@ -1,242 +1,307 @@
 # -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
-from odoo import api, fields, models, workflow, _
-from odoo import SUPERUSER_ID
+from odoo import api, exceptions, fields, models, _
 from odoo.tools import float_compare
-from odoo.exceptions import UserError
+from odoo.addons import decimal_precision as dp
+
+
+class StockMoveLots(models.Model):
+    _name = 'stock.move.lots'
+    _description = "Quantities to Process by lots"
+
+    move_id = fields.Many2one('stock.move', 'Move')
+    workorder_id = fields.Many2one('mrp.workorder', 'Work Order')
+    production_id = fields.Many2one('mrp.production', 'Production Order')
+    lot_id = fields.Many2one(
+        'stock.production.lot', 'Lot',
+        domain="[('product_id', '=', product_id)]")
+    lot_produced_id = fields.Many2one('stock.production.lot', 'Finished Lot')
+    lot_produced_qty = fields.Float('Quantity Finished Product', help="Informative, not used in matching")
+    quantity = fields.Float('To Do', default=1.0)
+    quantity_done = fields.Float('Done')
+    product_id = fields.Many2one(
+        'product.product', 'Product',
+        readonly=True, related="move_id.product_id", store=True)
+    done_wo = fields.Boolean('Done for Work Order', default=True, help="Technical Field which is False when temporarily filled in in work order")  # TDE FIXME: naming
+    done_move = fields.Boolean('Move Done', related='move_id.is_done', store=True)  # TDE FIXME: naming
+    plus_visible = fields.Boolean("Plus Visible", compute='_compute_plus')
+
+    def _compute_plus(self):
+        for movelot in self:
+            if movelot.move_id.product_id.tracking == 'serial':
+                movelot.plus_visible = (movelot.quantity_done <= 0.0)
+            else:
+                movelot.plus_visible = (movelot.quantity == 0.0) or (movelot.quantity_done < movelot.quantity)
+
+    @api.multi
+    def do_plus(self):
+        self.ensure_one()
+        self.quantity_done = self.quantity_done + 1
+        return self.move_id.split_move_lot()
+
+    @api.multi
+    def do_minus(self):
+        self.ensure_one()
+        self.quantity_done = self.quantity_done - 1
+        return self.move_id.split_move_lot()
 
 
 class StockMove(models.Model):
     _inherit = 'stock.move'
 
     production_id = fields.Many2one(
-        'mrp.production', 'Production Order for Produced Products',
-        copy=False, index=True)
+        'mrp.production', 'Production Order for finished products')
     raw_material_production_id = fields.Many2one(
-        'mrp.production', 'Production Order for Raw Materials',
-        index=True)
-    consumed_for = fields.Many2one(
-        'stock.move', 'Consumed for',
-        help='Technical field used to make the traceability of produced products')
-
-    # @api.multi
-    # def write(self, vals):
-    #     res = super(StockMove, self).write(vals)
-    #     if vals.get('state') == 'assigned':
-    #         orders = self.filtered(lambda move: move.raw_material_production_id.state == 'confirmed').mapped('raw_material_production_id')
-    #         orders = orders.filtered(lambda order: order.test_ready)
-    #         for order in orders:
-    #             workflow.trg_validate(self._uid, 'mrp.production', order.id, 'moves_ready', self._cr)
-    #     return res
-
-    def write(self, cr, uid, ids, vals, context=None):
-        if isinstance(ids, (int, long)):
-            ids = [ids]
-        res = super(StockMove, self).write(cr, uid, ids, vals, context=context)
-        from openerp import workflow
-        if vals.get('state') == 'assigned':
-            moves = self.browse(cr, uid, ids, context=context)
-            orders = list(set([x.raw_material_production_id.id for x in moves if x.raw_material_production_id and x.raw_material_production_id.state == 'confirmed']))
-            for order_id in orders:
-                if self.pool.get('mrp.production').test_ready(cr, uid, [order_id]):
-                    workflow.trg_validate(uid, 'mrp.production', order_id, 'moves_ready', cr)
+        'mrp.production', 'Production Order for raw materials')
+    unbuild_id = fields.Many2one(
+        'mrp.unbuild', 'Unbuild Order')
+    consume_unbuild_id = fields.Many2one(
+        'mrp.unbuild', 'Consume Unbuild Order')
+    operation_id = fields.Many2one(
+        'mrp.routing.workcenter', 'Operation To Consume')  # TDE FIXME: naming
+    workorder_id = fields.Many2one(
+        'mrp.workorder', 'Work Order To Consume')
+    has_tracking = fields.Selection(related='product_id.tracking', string='Product with Tracking')  # TDE FIXME: naming ...
+    # Quantities to process, in normalized UoMs
+    quantity_available = fields.Float(
+        'Quantity Available', compute="_qty_available",
+        digits_compute=dp.get_precision('Product Unit of Measure'))
+    quantity_done_store = fields.Float('Quantity', digits=0)
+    quantity_done = fields.Float(
+        'Quantity', compute='_qty_done_compute', inverse='_qty_done_set',
+        digits_compute=dp.get_precision('Product Unit of Measure'))
+    move_lot_ids = fields.One2many('stock.move.lots', 'move_id', string='Lots')
+    bom_line_id = fields.Many2one('mrp.bom.line', 'BoM Line')
+    unit_factor = fields.Float('Unit Factor')
+    is_done = fields.Boolean(
+        'Done', compute='_compute_is_done',
+        store=True,
+        help='Technical Field to order moves')  # TDE: what ?
+
+    @api.multi
+    def _qty_available(self):
+        for move in self:
+            # For consumables, state is available so availability = qty to do
+            if move.state == 'assigned':
+                move.quantity_available = move.product_uom_qty
+            else:
+                move.quantity_available = move.reserved_availability
+
+    @api.multi
+    @api.depends('move_lot_ids', 'move_lot_ids.quantity_done', 'quantity_done_store')
+    def _qty_done_compute(self):
+        for move in self:
+            if move.has_tracking != 'none':
+                move.quantity_done = sum(move.move_lot_ids.mapped('quantity_done'))
+            else:
+                move.quantity_done = move.quantity_done_store
+
+    @api.multi
+    def _qty_done_set(self):
+        for move in self:
+            if move.has_tracking == 'none':
+                move.quantity_done_store = move.quantity_done
+
+    @api.multi
+    @api.depends('state')
+    def _compute_is_done(self):
+        for move in self:
+            move.is_done = (move.state in ('done', 'cancel'))
+
+    @api.multi
+    def action_assign(self, no_prepare=False):
+        res = super(StockMove, self).action_assign(no_prepare=no_prepare)
+        self.check_move_lots()
         return res
 
     @api.multi
-    def get_code_from_locs(self, location_id=False, location_dest_id=False):
-        """
-        Returns the code the picking type should have.  This can easily be used
-        to check if a move is internal or not
-        move, location_id and location_dest_id are browse records
-        """
-        code = 'internal'
-        src_loc = location_id or self.location_id
-        dest_loc = location_dest_id or self.location_dest_id
-        if src_loc.usage == 'internal' and dest_loc.usage != 'internal':
-            code = 'outgoing'
-        if src_loc.usage != 'internal' and dest_loc.usage == 'internal':
-            code = 'incoming'
-        return code
+    def action_cancel(self):
+        if any(move.quantity_done for move in self):
+            raise exceptions.UserError(_('You cannot cancel a move move having already consumed material'))
+        return super(StockMove, self).action_cancel()
+
+    @api.multi
+    def check_move_lots(self):
+        moves_todo = self.filtered(lambda x: x.raw_material_production_id and x.state not in ('done', 'cancel'))
+        return moves_todo.create_lots()
 
     @api.multi
-    def check_tracking(self, ops):
-        super(StockMove, self).check_tracking(ops)
+    def create_lots(self):
+        lots = self.env['stock.move.lots']
+        uom_obj = self.env['product.uom']
         for move in self:
-            if move.raw_material_production_id and \
-                    move.product_id.tracking !='none' and \
-                    move.location_dest_id.usage == 'production' and \
-                    move.raw_material_production_id.product_id.tracking != 'none' and \
-                    not move.consumed_for:
-                raise UserError(
-                    _("Because the product %s requires it, you must assign a serial number to your raw material %s to proceed further in your production. Please use the 'Produce' button to do so.") % (
-                        move.raw_material_production_id.product_id.name, move.product_id.name))
-
-    def _action_explode(self, cr, uid, ids, context=None):
-        """ Explodes pickings.
-        @param move: Stock moves
-        @return: True
-        """
-        if context is None:
-            context = {}
-        bom_obj = self.pool.get('mrp.bom')
-        move_obj = self.pool.get('stock.move')
-        prod_obj = self.pool.get("product.product")
-        proc_obj = self.pool.get("procurement.order")
-        uom_obj = self.pool.get("product.uom")
-        to_explode_again_ids = []
-        property_ids = context.get('property_ids') or []
-        move = self.browse(cr, uid, ids[0], context=context)
-        bis = bom_obj._bom_find(cr, SUPERUSER_ID, product_id=move.product_id.id, properties=property_ids)
-        bom_point = bom_obj.browse(cr, SUPERUSER_ID, bis, context=context)
-        if bis and bom_point.type == 'phantom':
-            processed_ids = []
-            factor = uom_obj._compute_qty(cr, SUPERUSER_ID, move.product_uom.id, move.product_uom_qty, bom_point.product_uom.id) / bom_point.product_qty
-            res = bom_obj._bom_explode(cr, SUPERUSER_ID, bom_point, move.product_id, factor, property_ids, context=context)
-
-            for line in res[0]:
-                product = prod_obj.browse(cr, uid, line['product_id'], context=context)
-                if product.type in ['product', 'consu']:
-                    valdef = {
-                        'picking_id': move.picking_id.id if move.picking_id else False,
-                        'product_id': line['product_id'],
-                        'product_uom': line['product_uom'],
-                        'product_uom_qty': line['product_qty'],
-                        'state': 'draft',  #will be confirmed below
-                        'name': line['name'],
-                        'procurement_id': move.procurement_id.id,
-                        'split_from': move.id, #Needed in order to keep sale connection, but will be removed by unlink
-                        'price_unit': product.standard_price,
-                    }
-                    mid = move_obj.copy(cr, uid, move.id, default=valdef, context=context)
-                    to_explode_again_ids.append(mid)
+            unlink_move_lots = move.move_lot_ids.filtered(lambda x : (x.quantity_done == 0) and not x.workorder_id)
+            unlink_move_lots.unlink()
+            group_new_quant = {}
+            old_move_lot = {}
+            for movelot in move.move_lot_ids:
+                key = (movelot.lot_id.id or False)
+                old_move_lot.setdefault(key, []).append(movelot)
+            for quant in move.reserved_quant_ids:
+                key = (quant.lot_id.id or False)
+                quantity = uom_obj._compute_qty(move.product_id.uom_id.id, quant.qty, move.product_uom.id)
+                if group_new_quant.get(key):
+                    group_new_quant[key] += quantity
+                else:
+                    group_new_quant[key] = quantity
+            for key in group_new_quant:
+                quantity = group_new_quant[key]
+                if old_move_lot.get(key):
+                    if old_move_lot[key][0].quantity == quantity:
+                        continue
+                    else:
+                        old_move_lot[key][0].quantity = quantity
                 else:
-                    if product._need_procurement():
-                        valdef = {
-                            'name': move.rule_id and move.rule_id.name or "/",
-                            'origin': move.origin,
-                            'company_id': move.company_id and move.company_id.id or False,
-                            'date_planned': move.date,
-                            'product_id': line['product_id'],
-                            'product_qty': line['product_qty'],
-                            'product_uom': line['product_uom'],
-                            'group_id': move.group_id.id,
-                            'priority': move.priority,
-                            'partner_dest_id': move.partner_id.id,
-                            }
-                        if move.procurement_id:
-                            proc = proc_obj.copy(cr, uid, move.procurement_id.id, default=valdef, context=context)
-                        else:
-                            proc = proc_obj.create(cr, uid, valdef, context=context)
-                        proc_obj.run(cr, uid, [proc], context=context)  # could be omitted
-
-            # check if new moves needs to be exploded
-            if to_explode_again_ids:
-                for new_move in self.browse(cr, uid, to_explode_again_ids, context=context):
-                    processed_ids.extend(new_move._action_explode())
-
-            if not move.split_from and move.procurement_id:
-                # Check if procurements have been made to wait for
-                moves = move.procurement_id.move_ids
-                if len(moves) == 1:
-                    proc_obj.write(cr, uid, [move.procurement_id.id], {'state': 'done'}, context=context)
-
-            if processed_ids and move.state == 'assigned':
-                # Set the state of resulting moves according to 'assigned' as the original move is assigned
-                move_obj.write(cr, uid, list(set(processed_ids) - set([move.id])), {'state': 'assigned'}, context=context)
-
-            # delete the move with original product which is not relevant anymore
-            move_obj.unlink(cr, SUPERUSER_ID, [move.id], context=context)
-            # return list of newly created move
-            return processed_ids
-
-        return [move.id]
+                    vals = {
+                        'move_id': move.id,
+                        'product_id': move.product_id.id,
+                        'workorder_id': move.workorder_id.id,
+                        'production_id': move.raw_material_production_id.id,
+                        'quantity': quantity,
+                        'lot_id': key,
+                    }
+                    lots.create(vals)
+        return True
+
+    @api.multi
+    def move_validate(self):
+        ''' Validate moves based on a production order. '''
+        moves = self._filter_closed_moves()
+        quant_obj = self.env['stock.quant']
+        moves_todo = self.env['stock.move']
+        uom_obj = self.env['product.uom']
+        for move in moves:
+            rounding = move.product_uom.rounding
+            if float_compare(move.quantity_done, 0.0, precision_rounding=rounding) <= 0:
+                continue
+            moves_todo |= move
+            if float_compare(move.quantity_done, move.product_uom_qty, precision_rounding=rounding) > 0:
+                remaining_qty = move.quantity_done - move.product_uom_qty  # In UoM of move
+                extra_move = move.copy(default={'quantity_done': remaining_qty, 'product_uom_qty': remaining_qty, 'production_id': move.production_id.id, 
+                                                'raw_material_production_id': move.raw_material_production_id.id})
+                move.quantity_done = move.product_uom_qty
+                extra_move.action_confirm()
+                moves_todo |= extra_move
+        for move in moves_todo:
+            if float_compare(move.quantity_done, move.product_uom_qty, precision_rounding=rounding):
+                # Need to do some kind of conversion here
+                qty_split = uom_obj._compute_qty(move.product_uom.id, move.product_uom_qty - move.quantity_done, move.product_id.uom_id.id)
+                new_move = move.split(qty_split)
+                self.browse(new_move).quantity_done = 0.0
+            main_domain = [('qty', '>', 0)]
+            preferred_domain = [('reservation_id', '=', move.id)]
+            fallback_domain = [('reservation_id', '=', False)]
+            fallback_domain2 = ['&', ('reservation_id', '!=', move.id), ('reservation_id', '!=', False)]
+            preferred_domain_list = [preferred_domain] + [fallback_domain] + [fallback_domain2]
+            if move.has_tracking == 'none':
+                quants = quant_obj.quants_get_preferred_domain(move.product_qty, move, domain=main_domain, preferred_domain_list=preferred_domain_list)
+                self.env['stock.quant'].quants_move(quants, move, move.location_dest_id)
+            else:
+                for movelot in move.move_lot_ids:
+                    if float_compare(movelot.quantity_done, 0, precision_rounding=rounding) > 0:
+                        qty = uom_obj._compute_qty(move.product_uom.id, movelot.quantity_done, move.product_id.uom_id.id)
+                        quants = quant_obj.quants_get_preferred_domain(qty, move, lot_id=movelot.lot_id.id, domain=main_domain, preferred_domain_list=preferred_domain_list)
+                        self.env['stock.quant'].quants_move(quants, move, move.location_dest_id, lot_id = movelot.lot_id.id)
+            move.quants_unreserve()
+            # Next move in production order
+            if move.move_dest_id:
+                move.move_dest_id.action_assign()
+        moves_todo.write({'state': 'done', 'date': fields.Datetime.now()})
+        return moves_todo
+
+    @api.multi
+    def action_done(self):
+        production_moves = self.filtered(lambda move: (move.production_id or move.raw_material_production_id) and not move.scrapped)
+        production_moves.move_validate()
+        return super(StockMove, self-production_moves).action_done()
+
+    @api.multi
+    def split_move_lot(self):
+        ctx = dict(self.env.context)
+        self.ensure_one()
+        view = self.env.ref('mrp.view_stock_move_lots')
+        serial = (self.has_tracking == 'serial')
+        only_create = False  # Check picking type in theory
+        show_reserved = any([x for x in self.move_lot_ids if x.quantity > 0.0])
+        ctx.update({
+            'serial': serial,
+            'only_create': only_create,
+            'create_lots': True,
+            'state_done': self.is_done,
+            'show_reserved': show_reserved,
+        })
+        if ctx.get('w_production'):
+            action = self.env.ref('mrp.act_mrp_product_produce').read()[0]
+            action['context'] = ctx
+            return action
+        result = {
+            'name': _('Register Lots'),
+            'type': 'ir.actions.act_window',
+            'view_type': 'form',
+            'view_mode': 'form',
+            'res_model': 'stock.move',
+            'views': [(view.id, 'form')],
+            'view_id': view.id,
+            'target': 'new',
+            'res_id': self.id,
+            'context': ctx,
+        }
+        return result
+
+    @api.multi
+    def save(self):
+        return True
 
     @api.multi
     def action_confirm(self):
         moves = self.env['stock.move']
         for move in self:
-            # in order to explode a move, we must have a picking_type_id on that move because otherwise the move
-            # won't be assigned to a picking and it would be weird to explode a move into several if they aren't
-            # all grouped in the same picking.
-            if move.picking_type_id:
-                moves |= moves.browse(move._action_explode())
-            else:
-                moves |= move
-
+            moves |= move.action_explode()
         # we go further with the list of ids potentially changed by action_explode
         return super(StockMove, moves).action_confirm()
 
-    def action_consume(self, cr, uid, ids, product_qty, location_id=False, restrict_lot_id=False, restrict_partner_id=False,
-                       consumed_for=False, context=None):
-        """ Consumed product with specific quantity from specific source location.
-        @param product_qty: Consumed/produced product quantity (= in quantity of UoM of product)
-        @param location_id: Source location
-        @param restrict_lot_id: optionnal parameter that allows to restrict the choice of quants on this specific lot
-        @param restrict_partner_id: optionnal parameter that allows to restrict the choice of quants to this specific partner
-        @param consumed_for: optionnal parameter given to this function to make the link between raw material consumed and produced product, for a better traceability
-        @return: New lines created if not everything was consumed for this line
-        """
-        if context is None:
-            context = {}
-        res = []
-        production_obj = self.pool.get('mrp.production')
-
-        if product_qty <= 0:
-            raise UserError(_('Please provide proper quantity.'))
-        #because of the action_confirm that can create extra moves in case of phantom bom, we need to make 2 loops
-        ids2 = []
-        for move in self.browse(cr, uid, ids, context=context):
-            if move.state == 'draft':
-                ids2.extend(self.action_confirm(cr, uid, [move.id], context=context))
-            else:
-                ids2.append(move.id)
-
-        prod_orders = set()
-        for move in self.browse(cr, uid, ids2, context=context):
-            prod_orders.add(move.raw_material_production_id.id or move.production_id.id)
-            move_qty = move.product_qty
-            if move_qty <= 0:
-                raise UserError(_('Cannot consume a move with negative or zero quantity.'))
-            quantity_rest = move_qty - product_qty
-            # Compare with numbers of move uom as we want to avoid a split with 0 qty
-            quantity_rest_uom = move.product_uom_qty - self.pool.get("product.uom")._compute_qty_obj(cr, uid, move.product_id.uom_id, product_qty, move.product_uom)
-            if float_compare(quantity_rest_uom, 0, precision_rounding=move.product_uom.rounding) != 0:
-                new_mov = self.split(cr, uid, [move.id], quantity_rest, context=context)
-                if move.production_id:
-                    self.write(cr, uid, [new_mov], {'production_id': move.production_id.id}, context=context)
-                res.append(new_mov)
-            vals = {'restrict_lot_id': restrict_lot_id,
-                    'restrict_partner_id': restrict_partner_id,
-                    'consumed_for': consumed_for}
-            if location_id:
-                vals.update({'location_id': location_id})
-            self.write(cr, uid, [move.id], vals, context=context)
-        # Original moves will be the quantities consumed, so they need to be done
-        self.action_done(cr, uid, ids2, context=context)
-        if res:
-            self.action_assign(cr, uid, res, context=context)
-        if prod_orders:
-            production_obj.signal_workflow(cr, uid, list(prod_orders), 'button_produce')
-        return res
+    def action_explode(self):
+        """ Explodes pickings """
+        # in order to explode a move, we must have a picking_type_id on that move because otherwise the move
+        # won't be assigned to a picking and it would be weird to explode a move into several if they aren't
+        # all grouped in the same picking.
+        if not self.picking_type_id:
+            return self
+        bom = self.env['mrp.bom'].sudo()._bom_find(product=self.product_id)
+        if not bom or bom.type != 'phantom':
+            return self
+        phantom_moves = self.env['stock.move']
+        processed_moves = self.env['stock.move']
+        factor = self.env['product.uom']._compute_qty(self.product_uom.id, self.product_uom_qty, bom.product_uom_id.id) / bom.product_qty
+        boms, lines = bom.sudo().explode(self.product_id, factor, picking_type=bom.picking_type_id)
+        for bom_line, line_data in lines:
+            phantom_moves += self._generate_move_phantom(bom_line, line_data['qty'])
 
-    def action_scrap(self, cr, uid, ids, product_qty, location_id, restrict_lot_id=False, restrict_partner_id=False, context=None):
-        """ Move the scrap/damaged product into scrap location
-        @param product_qty: Scraped product quantity
-        @param location_id: Scrap location
-        @return: Scraped lines
-        """
-        res = []
-        production_obj = self.pool.get('mrp.production')
-        for move in self.browse(cr, uid, ids, context=context):
-            new_moves = super(StockMove, self).action_scrap(cr, uid, [move.id], product_qty, location_id,
-                                                            restrict_lot_id=restrict_lot_id,
-                                                            restrict_partner_id=restrict_partner_id, context=context)
-            #If we are not scrapping our whole move, tracking and lot references must not be removed
-            production_ids = production_obj.search(cr, uid, [('move_lines', 'in', [move.id])])
-            for prod_id in production_ids:
-                production_obj.signal_workflow(cr, uid, [prod_id], 'button_produce')
-            if move.production_id.id:
-                self.write(cr, uid, new_moves, {'production_id': move.production_id.id}, context=context)
-            res += new_moves
-        return res
+        for new_move in phantom_moves:
+            processed_moves |= new_move.action_explode()
+        if not self.split_from and self.procurement_id:
+            # Check if procurements have been made to wait for
+            moves = self.procurement_id.move_ids
+            if len(moves) == 1:
+                self.procurement_id.write({'state': 'done'})
+        if processed_moves and self.state == 'assigned':
+            # Set the state of resulting moves according to 'assigned' as the original move is assigned
+            processed_moves.write({'state': 'assigned'})
+        # delete the move with original product which is not relevant anymore
+        self.sudo().unlink()
+        return processed_moves
+
+    def _generate_move_phantom(self, bom_line, quantity):
+        if bom_line.product_id.type in ['product', 'consu']:
+            return self.copy(default={
+                'picking_id': self.picking_id.id if self.picking_id else False,
+                'product_id': bom_line.product_id.id,
+                'product_uom': bom_line.product_uom_id.id,
+                'product_uom_qty': quantity,
+                'state': 'draft',  # will be confirmed below
+                'name': self.name,
+                'procurement_id': self.procurement_id.id,
+                'split_from': self.id,  # Needed in order to keep sale connection, but will be removed by unlink
+            })
+        return self.env['stock.move']

--- a/None
+++ b/addons/mrp/models/stock_picking.py
@@ -0,0 +1,27 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from odoo import fields, models
+
+
+class StockPickingType(models.Model):
+    _inherit = 'stock.picking.type'
+
+    code = fields.Selection(selection_add=[('mrp_operation', 'Manufacturing Operation')])
+    count_mo_todo = fields.Integer(compute='_get_mo_count')
+    count_mo_waiting = fields.Integer(compute='_get_mo_count')
+    count_mo_late = fields.Integer(compute='_get_mo_count')
+
+    def _get_mo_count(self):
+        mrp_picking_types = self.filtered(lambda picking: picking.code == 'mrp_operation')
+        if not mrp_picking_types:
+            return
+
+        MrpProduction = self.env['mrp.production']
+        count_mo_waiting = MrpProduction.search_count([('availability', '=', 'waiting')])
+        count_mo_todo = MrpProduction.search_count([('state', 'in', ('confirmed', 'planned', 'progress'))])
+        count_mo_late = MrpProduction.search_count(['&', ('date_planned_start', '<', fields.Date.today()), ('state', '=', 'confirmed')])
+        for picking in mrp_picking_types:
+            picking.count_mo_waiting = count_mo_waiting
+            picking.count_mo_todo = count_mo_todo
+            picking.count_mo_late = count_mo_late

--- a/None
+++ b/addons/mrp/models/stock_quant.py
@@ -0,0 +1,13 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from odoo import fields, models
+
+
+class StockQuant(models.Model):
+    _inherit = 'stock.quant'
+
+    consumed_quant_ids = fields.Many2many(
+        'stock.quant', 'stock_quant_consume_rel', 'produce_quant_id', 'consume_quant_id')
+    produced_quant_ids = fields.Many2many(
+        'stock.quant', 'stock_quant_consume_rel', 'consume_quant_id', 'produce_quant_id')

--- a/None
+++ b/addons/mrp/models/stock_scrap.py
@@ -0,0 +1,51 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from odoo import api, fields, models
+
+
+class StockScrap(models.Model):
+    _inherit = 'stock.scrap'
+
+    production_id = fields.Many2one(
+        'mrp.production', 'Manufacturing Order',
+        states={'done': [('readonly', True)]})
+    workorder_id = fields.Many2one(
+        'mrp.workorder', 'Work Order',
+        states={'done': [('readonly', True)]},
+        help='Not to restrict or prefer quants, but informative.')
+
+    @api.onchange('workorder_id')
+    def _onchange_workorder_id(self):
+        if self.workorder_id:
+            self.location_id = self.workorder_id.production_id.location_src_id.id
+
+    @api.onchange('production_id')
+    def _onchange_production_id(self):
+        if self.production_id:
+            self.location_id = self.production_id.move_raw_ids.filtered(lambda x: x.state not in ('done', 'cancel')) and self.production_id.location_src_id.id or self.production_id.location_dest_id.id,
+
+    def _get_preferred_domain(self):
+        if self.production_id:
+            if self.product_id in self.production_id.move_raw_ids.mapped('product_id'):
+                preferred_domain = [('reservation_id', 'in', self.production_id.move_raw_ids.ids)]
+                preferred_domain2 = [('reservation_id', '=', False)]
+                preferred_domain3 = ['&', ('reservation_id', 'not in', self.production_id.move_raw_ids.ids), ('reservation_id', '!=', False)]
+                return [preferred_domain, preferred_domain2, preferred_domain3]
+            elif self.product_id in self.production_id.move_finished_ids.mapped('product_id'):
+                preferred_domain = [('history_ids', 'in', self.production_id.move_finished_ids.ids)]
+                preferred_domain2 = [('history_ids', 'not in', self.production_id.move_finished_ids.ids)]
+                return [preferred_domain, preferred_domain2]
+        return super(StockScrap, self)._get_preferred_domain()
+
+    def _prepare_move_values(self):
+        vals = super(StockScrap, self)._prepare_move_values()
+        if self.production_id:
+            if self.product_id in self.production_id.move_finished_ids.mapped('product_id'):
+                vals.update({'production_id': self.production_id.id})
+            else:
+                vals.update({'raw_material_production_id': self.production_id.id})
+        return vals
+
+    def _get_origin_moves(self):
+        return super(StockScrap, self)._get_origin_moves() or self.production_id and self.production_id.move_raw_ids.filtered(lambda x: x.product_id == self.product_id)

--- a/addons/mrp/models/stock_warehouse.py
+++ b/addons/mrp/models/stock_warehouse.py
@@ -1,7 +1,6 @@
 # -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
-
 from odoo import api, exceptions, fields, models, _
 
 
@@ -13,17 +12,14 @@ class StockWarehouse(models.Model):
         help="When products are manufactured, they can be manufactured in this warehouse.")
     manufacture_pull_id = fields.Many2one(
         'procurement.rule', 'Manufacture Rule')
+    manu_type_id = fields.Many2one(
+        'stock.picking.type', 'Manufacturing Picking Type',
+        domain=[('code', '=', 'mrp_operation')])
 
-    @api.multi
-    def write(self, vals):
-        if 'manufacture_to_resupply' in vals:
-            if vals.get("manufacture_to_resupply"):
-                for warehouse in self.filtered(lambda warehouse: not warehouse.manufacture_pull_id):
-                    manufacture_pull = warehouse._create_or_update_manufacture_pull(self.get_routes_dict())
-                    vals['manufacture_pull_id'] = manufacture_pull.id
-            else:
-                self.mapped('manufacture_pull_id').unlink()
-        return super(StockWarehouse, self).write(vals)
+    def create_sequences_and_picking_types(self):
+        res = super(StockWarehouse, self).create_sequences_and_picking_types()
+        self._create_manufacturing_picking_type()
+        return res
 
     @api.multi
     def get_routes_dict(self):
@@ -41,15 +37,42 @@ class StockWarehouse(models.Model):
         return manufacture_route_id
 
     def _get_manufacture_pull_rules_values(self, route_values):
+        if not self.manu_type_id:
+            self._create_manufacturing_picking_type()
         dummy, pull_rules_list = self._get_push_pull_rules_values(route_values, pull_values={
             'name': self._format_routename(_(' Manufacture')),
             'location_src_id': False,  # TDE FIXME
             'action': 'manufacture',
             'route_id': self._get_manufacture_route_id(),
+            'picking_type_id': self.manu_type_id.id,
             'propagate': False,
             'active': True})
         return pull_rules_list
 
+    def _create_manufacturing_picking_type(self):
+        # TDE CLEANME
+        picking_type_obj = self.env['stock.picking.type']
+        seq_obj = self.env['ir.sequence']
+        for warehouse in self:
+            #man_seq_id = seq_obj.sudo().create('name': warehouse.name + _(' Sequence Manufacturing'), 'prefix': warehouse.code + '/MANU/', 'padding')
+            wh_stock_loc = warehouse.lot_stock_id
+            seq = seq_obj.search([('code', '=', 'mrp.production')], limit=1)
+            other_pick_type = picking_type_obj.search([('warehouse_id', '=', warehouse.id)], order = 'sequence desc', limit=1)
+            color = other_pick_type and other_pick_type.color or 0
+            max_sequence = other_pick_type and other_pick_type.sequence or 0
+            manu_type = picking_type_obj.create({
+                'name': _('Manufacturing'),
+                'warehouse_id': warehouse.id,
+                'code': 'mrp_operation',
+                'use_create_lots': True,
+                'use_existing_lots': False,
+                'sequence_id': seq.id,
+                'default_location_src_id': wh_stock_loc.id,
+                'default_location_dest_id': wh_stock_loc.id,
+                'sequence': max_sequence,
+                'color': color})
+            warehouse.write({'manu_type_id': manu_type.id})
+
     def _create_or_update_manufacture_pull(self, routes_data):
         routes_data = routes_data or self.get_routes_dict()
         for warehouse in self:
@@ -70,6 +93,24 @@ class StockWarehouse(models.Model):
         res['manufacture_pull_id'] = manufacture_pull.id
         return res
 
+    @api.multi
+    def write(self, vals):
+        if 'manufacture_to_resupply' in vals:
+            if vals.get("manufacture_to_resupply"):
+                for warehouse in self.filtered(lambda warehouse: not warehouse.manufacture_pull_id):
+                    manufacture_pull = warehouse._create_or_update_manufacture_pull(self.get_routes_dict())
+                    vals['manufacture_pull_id'] = manufacture_pull.id
+                for warehouse in self:
+                    if not warehouse.manu_type_id:
+                        warehouse._create_manufacturing_picking_type()
+                    warehouse.manu_type_id.active = True
+            else:
+                for warehouse in self:
+                    if warehouse.manu_type_id:
+                        warehouse.manu_type_id.active = False
+                self.mapped('manufacture_pull_id').unlink()
+        return super(StockWarehouse, self).write(vals)
+
     @api.multi
     def _get_all_routes(self):
         routes = super(StockWarehouse, self).get_all_routes_for_wh()
