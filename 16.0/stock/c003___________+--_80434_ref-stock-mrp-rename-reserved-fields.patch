PR: https://github.com/odoo/odoo/pull/80434

From: 56e7bcf0cb88acf3d60420569ab3eea9bdb19bdb
From: William Henrotin
Date: 2021-12-07 16:20:06

Structural Changes: 6
Total Changes: 172

[REF] *{stock,mrp}*: rename reserved fields

This commit rename product_uom_qty into reserved_uom_qty and product_qty
into reserved_qty on stock move line to stop mistake them with the stock
move quantities fields.

Task: 2648449
Part-of: odoo/odoo#80434

================================= pseudo patch: =================================

--- a/addons/stock/models/stock_location.py
+++ b/addons/stock/models/stock_location.py
@@ -87,7 +87,7 @@ class Location(models.Model):
     _sql_constraints = [('barcode_company_uniq', 'unique (barcode,company_id)', 'The barcode for a location must be unique per company !'),
                         ('inventory_freq_nonneg', 'check(cyclic_inventory_frequency >= 0)', 'The inventory frequency (days) for a location must be non-negative')]
 
-    @api.depends('outgoing_move_line_ids.product_qty', 'incoming_move_line_ids.product_qty',
+    @api.depends('outgoing_move_line_ids.reserved_qty', 'incoming_move_line_ids.reserved_qty',
                  'outgoing_move_line_ids.state', 'incoming_move_line_ids.state',
                  'outgoing_move_line_ids.product_id.weight', 'outgoing_move_line_ids.product_id.weight',
                  'quant_ids.quantity', 'quant_ids.product_id.weight')
@@ -101,9 +101,9 @@ class Location(models.Model):
                 location.net_weight += quant.product_id.weight * quant.quantity
             location.forecast_weight = location.net_weight
             for line in incoming_move_lines:
-                location.forecast_weight += line.product_id.weight * line.product_qty
+                location.forecast_weight += line.product_id.weight * line.reserved_qty
             for line in outgoing_move_lines:
-                location.forecast_weight -= line.product_id.weight * line.product_qty
+                location.forecast_weight -= line.product_id.weight * line.reserved_qty
 
     @api.depends('name', 'location_id.complete_name', 'usage')
     def _compute_complete_name(self):
@@ -168,7 +168,7 @@ class Location(models.Model):
                               for f in {'usage', 'scrap_location'}))
             reserved_quantities = self.env['stock.move.line'].search_count([
                 ('location_id', 'in', modified_locations.ids),
-                ('product_qty', '>', 0),
+                ('reserved_qty', '>', 0),
             ])
             if reserved_quantities:
                 raise UserError(_(
@@ -264,7 +264,7 @@ class Location(models.Model):
                         ('product_id', '=', product.id),
                         ('location_dest_id', 'in', locations.ids),
                         ('state', 'not in', ['draft', 'done', 'cancel'])
-                    ], ['location_dest_id', 'product_id', 'product_qty:array_agg', 'qty_done:array_agg', 'product_uom_id:array_agg'], ['location_dest_id'])
+                    ], ['location_dest_id', 'product_id', 'reserved_qty:array_agg', 'qty_done:array_agg', 'product_uom_id:array_agg'], ['location_dest_id'])
                     quant_data = self.env['stock.quant'].read_group([
                         ('product_id', '=', product.id),
                         ('location_id', 'in', locations.ids),
@@ -273,7 +273,7 @@ class Location(models.Model):
                     for values in move_line_data:
                         uoms = self.env['uom.uom'].browse(values['product_uom_id'])
                         qty_done = sum(max(ml_uom._compute_quantity(float(qty), product.uom_id), float(qty_reserved))
-                                    for qty_reserved, qty, ml_uom in zip(values['product_qty'], values['qty_done'], list(uoms)))
+                                    for qty_reserved, qty, ml_uom in zip(values['reserved_qty'], values['qty_done'], list(uoms)))
                         qty_by_location[values['location_dest_id'][0]] = qty_done
                     for values in quant_data:
                         qty_by_location[values['location_id'][0]] += values['quantity']

--- a/addons/stock/models/stock_move.py
+++ b/addons/stock/models/stock_move.py
@@ -130,7 +130,7 @@ class StockMove(models.Model):
     picking_type_id = fields.Many2one('stock.picking.type', 'Operation Type', compute='_compute_picking_type_id', store=True, check_company=True)
     is_inventory = fields.Boolean('Inventory')
     move_line_ids = fields.One2many('stock.move.line', 'move_id')
-    move_line_nosuggest_ids = fields.One2many('stock.move.line', 'move_id', domain=['|', ('product_qty', '=', 0.0), ('qty_done', '!=', 0.0)])
+    move_line_nosuggest_ids = fields.One2many('stock.move.line', 'move_id', domain=['|', ('reserved_qty', '=', 0.0), ('qty_done', '!=', 0.0)])
     origin_returned_move_id = fields.Many2one(
         'stock.move', 'Origin return move', copy=False, index=True,
         help='Move that created the return move', check_company=True)
@@ -376,7 +376,7 @@ class StockMove(models.Model):
         detect errors. """
         raise UserError(_('The requested operation cannot be processed because of a programming error setting the `product_qty` field instead of the `product_uom_qty`.'))
 
-    @api.depends('move_line_ids.product_qty')
+    @api.depends('move_line_ids.reserved_qty')
     def _compute_reserved_availability(self):
         """ Fill the `availability` field on a stock move, which is the actual reserved quantity
         and is represented by the aggregated `product_qty` on the linked move lines. If the move
@@ -385,13 +385,13 @@ class StockMove(models.Model):
         if not any(self._ids):
             # onchange
             for move in self:
-                reserved_availability = sum(move.move_line_ids.mapped('product_qty'))
+                reserved_availability = sum(move.move_line_ids.mapped('reserved_qty'))
                 move.reserved_availability = move.product_id.uom_id._compute_quantity(
                     reserved_availability, move.product_uom, rounding_method='HALF-UP')
         else:
             # compute
-            result = {data['move_id'][0]: data['product_qty'] for data in
-                      self.env['stock.move.line'].read_group([('move_id', 'in', self.ids)], ['move_id', 'product_qty'], ['move_id'])}
+            result = {data['move_id'][0]: data['reserved_qty'] for data in
+                      self.env['stock.move.line'].read_group([('move_id', 'in', self.ids)], ['move_id', 'reserved_qty'], ['move_id'])}
             for move in self:
                 move.reserved_availability = move.product_id.uom_id._compute_quantity(
                     result.get(move.id, 0.0), move.product_uom, rounding_method='HALF-UP')
@@ -489,7 +489,7 @@ class StockMove(models.Model):
 
     @api.depends('move_line_ids', 'move_line_ids.lot_id', 'move_line_ids.qty_done')
     def _compute_lot_ids(self):
-        domain_nosuggest = [('move_id', 'in', self.ids), ('lot_id', '!=', False), '|', ('qty_done', '!=', 0.0), ('product_qty', '=', 0.0)]
+        domain_nosuggest = [('move_id', 'in', self.ids), ('lot_id', '!=', False), '|', ('qty_done', '!=', 0.0), ('reserved_qty', '=', 0.0)]
         domain_suggest = [('move_id', 'in', self.ids), ('lot_id', '!=', False), ('qty_done', '!=', 0.0)]
         lots_by_move_id_list = []
         for domain in [domain_nosuggest, domain_suggest]:
@@ -754,7 +754,7 @@ class StockMove(models.Model):
         ml_to_update, ml_to_unlink = self.env['stock.move.line'].browse(ml_to_update), self.env['stock.move.line'].browse(ml_to_unlink)
         moves_not_to_recompute = self.env['stock.move'].browse(moves_not_to_recompute)
 
-        ml_to_update.write({'product_uom_qty': 0})
+        ml_to_update.write({'reserved_uom_qty': 0})
         ml_to_unlink.unlink()
         # `write` on `stock.move.line` doesn't call `_recompute_state` (unlike to `unlink`),
         # so it must be called for each move where no move line has been deleted.
@@ -1293,9 +1293,9 @@ class StockMove(models.Model):
             uom_quantity = float_round(uom_quantity, precision_digits=rounding)
             uom_quantity_back_to_product_uom = self.product_uom._compute_quantity(uom_quantity, self.product_id.uom_id, rounding_method='HALF-UP')
             if float_compare(quantity, uom_quantity_back_to_product_uom, precision_digits=rounding) == 0:
-                vals = dict(vals, product_uom_qty=uom_quantity)
+                vals = dict(vals, reserved_uom_qty=uom_quantity)
             else:
-                vals = dict(vals, product_uom_qty=quantity, product_uom_id=self.product_id.uom_id.id)
+                vals = dict(vals, reserved_uom_qty=quantity, product_uom_id=self.product_id.uom_id.id)
         package = None
         if reserved_quant:
             package = reserved_quant.package_id
@@ -1366,7 +1366,7 @@ class StockMove(models.Model):
                 uom_quantity = float_round(uom_quantity, precision_digits=rounding)
                 uom_quantity_back_to_product_uom = to_update.product_uom_id._compute_quantity(uom_quantity, self.product_id.uom_id, rounding_method='HALF-UP')
             if to_update and float_compare(quantity, uom_quantity_back_to_product_uom, precision_digits=rounding) == 0:
-                to_update.with_context(bypass_reservation_update=True).product_uom_qty += uom_quantity
+                to_update.with_context(bypass_reservation_update=True).reserved_uom_qty += uom_quantity
             else:
                 if self.product_id.tracking == 'serial':
                     self.env['stock.move.line'].create([self._prepare_move_line_vals(quantity=1, reserved_quant=reserved_quant) for i in range(int(quantity))])
@@ -1388,7 +1388,7 @@ class StockMove(models.Model):
 
     def _action_assign(self):
         """ Reserve stock moves by creating their stock move lines. A stock move is
-        considered reserved once the sum of `product_qty` for all its move lines is
+        considered reserved once the sum of `reserved_qty` for all its move lines is
         equal to its `product_qty`. If it is less, the stock move is considered
         partially available.
         """
@@ -1425,7 +1425,7 @@ class StockMove(models.Model):
                     qty_done += ml.product_uom_id._compute_quantity(ml.qty_done, ml.product_id.uom_id)
                 grouped_move_lines_out[k] = qty_done
             for k, g in groupby(move_lines_out_reserved, key=_keys_out_groupby):
-                grouped_move_lines_out[k] = sum(self.env['stock.move.line'].concat(*g).mapped('product_qty'))
+                grouped_move_lines_out[k] = sum(self.env['stock.move.line'].concat(*g).mapped('reserved_qty'))
             available_move_lines = {key: grouped_move_lines_in[key] - grouped_move_lines_out.get(key, 0) for key in grouped_move_lines_in}
             # pop key if the quantity available amount to 0
             return dict((k, v) for k, v in available_move_lines.items() if v)
@@ -1472,7 +1472,7 @@ class StockMove(models.Model):
                                                             not ml.package_id and
                                                             not ml.owner_id)
                     if to_update:
-                        to_update[0].product_uom_qty += move.product_id.uom_id._compute_quantity(
+                        to_update[0].reserved_uom_qty += move.product_id.uom_id._compute_quantity(
                             missing_reserved_quantity, move.product_uom, rounding_method='HALF-UP')
                     else:
                         move_line_vals_list.append(move._prepare_move_line_vals(quantity=missing_reserved_quantity))
@@ -1509,11 +1509,11 @@ class StockMove(models.Model):
                     available_move_lines = _get_available_move_lines(move)
                     if not available_move_lines:
                         continue
-                    for move_line in move.move_line_ids.filtered(lambda m: m.product_qty):
+                    for move_line in move.move_line_ids.filtered(lambda m: m.reserved_qty):
                         if available_move_lines.get((move_line.location_id, move_line.lot_id, move_line.result_package_id, move_line.owner_id)):
-                            available_move_lines[(move_line.location_id, move_line.lot_id, move_line.result_package_id, move_line.owner_id)] -= move_line.product_qty
+                            available_move_lines[(move_line.location_id, move_line.lot_id, move_line.result_package_id, move_line.owner_id)] -= move_line.reserved_qty
                     for (location_id, lot_id, package_id, owner_id), quantity in available_move_lines.items():
-                        need = move.product_qty - sum(move.move_line_ids.mapped('product_qty'))
+                        need = move.product_qty - sum(move.move_line_ids.mapped('reserved_qty'))
                         # `quantity` is what is brought by chained done move lines. We double check
                         # here this quantity is available on the quants themselves. If not, this
                         # could be the result of an inventory adjustment that removed totally of
@@ -1788,7 +1788,7 @@ class StockMove(models.Model):
     def _set_quantity_done_prepare_vals(self, qty):
         res = []
         for ml in self.move_line_ids:
-            ml_qty = ml.product_uom_qty - ml.qty_done
+            ml_qty = ml.reserved_uom_qty - ml.qty_done
             if float_compare(ml_qty, 0, precision_rounding=ml.product_uom_id.rounding) <= 0:
                 continue
             # Convert move line qty into move uom
@@ -1812,7 +1812,7 @@ class StockMove(models.Model):
                 break
 
         for ml in self.move_line_ids:
-            if float_is_zero(ml.product_uom_qty, precision_rounding=ml.product_uom_id.rounding) and float_is_zero(ml.qty_done, precision_rounding=ml.product_uom_id.rounding):
+            if float_is_zero(ml.reserved_uom_qty, precision_rounding=ml.product_uom_id.rounding) and float_is_zero(ml.qty_done, precision_rounding=ml.product_uom_id.rounding):
                 res.append((2, ml.id))
 
         if float_compare(qty, 0.0, precision_rounding=self.product_uom.rounding) > 0:
@@ -1845,7 +1845,7 @@ class StockMove(models.Model):
             for move_line in move.move_line_ids:
                 if move.has_tracking != 'none' and not (move_line.lot_id or move_line.lot_name):
                     continue
-                move_line.qty_done = move_line.product_uom_qty
+                move_line.qty_done = move_line.reserved_uom_qty
 
     def _clear_quantities_to_zero(self):
         self.filtered(lambda m: m.state in ('partially_available', 'assigned')).move_line_ids.qty_done = 0

--- a/addons/stock/models/stock_move_line.py
+++ b/addons/stock/models/stock_move_line.py
@@ -29,10 +29,10 @@ class StockMoveLine(models.Model):
     product_id = fields.Many2one('product.product', 'Product', ondelete="cascade", check_company=True, domain="[('type', '!=', 'service'), '|', ('company_id', '=', False), ('company_id', '=', company_id)]")
     product_uom_id = fields.Many2one('uom.uom', 'Unit of Measure', required=True, domain="[('category_id', '=', product_uom_category_id)]")
     product_uom_category_id = fields.Many2one(related='product_id.uom_id.category_id')
-    product_qty = fields.Float(
+    reserved_qty = fields.Float(
         'Real Reserved Quantity', digits=0, copy=False,
-        compute='_compute_product_qty', inverse='_set_product_qty', store=True)
-    product_uom_qty = fields.Float(
+        compute='_compute_reserved_qty', inverse='_set_product_qty', store=True)
+    reserved_uom_qty = fields.Float(
         'Reserved', default=0.0, digits='Product Unit of Measure', required=True, copy=False)
     qty_done = fields.Float('Done', default=0.0, digits='Product Unit of Measure', copy=False)
     package_id = fields.Many2one(
@@ -94,17 +94,17 @@ class StockMoveLine(models.Model):
     def _search_picking_type_id(self, operator, value):
         return [('picking_id.picking_type_id', operator, value)]
 
-    @api.depends('product_id', 'product_uom_id', 'product_uom_qty')
-    def _compute_product_qty(self):
+    @api.depends('product_id', 'product_uom_id', 'reserved_uom_qty')
+    def _compute_reserved_qty(self):
         for line in self:
-            line.product_qty = line.product_uom_id._compute_quantity(line.product_uom_qty, line.product_id.uom_id, rounding_method='HALF-UP')
+            line.reserved_qty = line.product_uom_id._compute_quantity(line.reserved_uom_qty, line.product_id.uom_id, rounding_method='HALF-UP')
 
-    def _set_product_qty(self):
-        """ The meaning of product_qty field changed lately and is now a functional field computing the quantity
+    def _set_reserved_qty(self):
+        """ The meaning of reserved_qty field changed lately and is now a functional field computing the quantity
         in the default product UoM. This code has been added to raise an error if a write is made given a value
-        for `product_qty`, where the same write should set the `product_uom_qty` field instead, in order to
+        for `reserved_qty`, where the same write should set the `reserved_uom_qty` field instead, in order to
         detect errors. """
-        raise UserError(_('The requested operation cannot be processed because of a programming error setting the `product_qty` field instead of the `product_uom_qty`.'))
+        raise UserError(_('The requested operation cannot be processed because of a programming error setting the `reserved_qty` field instead of the `reserved_uom_qty`.'))
 
     @api.constrains('lot_id', 'product_id')
     def _check_lot_product(self):
@@ -116,10 +116,10 @@ class StockMoveLine(models.Model):
                     product_name=line.product_id.display_name
                 ))
 
-    @api.constrains('product_uom_qty')
+    @api.constrains('reserved_uom_qty')
     def _check_reserved_done_quantity(self):
         for move_line in self:
-            if move_line.state == 'done' and not float_is_zero(move_line.product_uom_qty, precision_digits=self.env['decimal.precision'].precision_get('Product Unit of Measure')):
+            if move_line.state == 'done' and not float_is_zero(move_line.reserved_uom_qty, precision_digits=self.env['decimal.precision'].precision_get('Product Unit of Measure')):
                 raise ValidationError(_('A done move line should never have a reserved quantity.'))
 
     @api.constrains('qty_done')
@@ -215,7 +215,7 @@ class StockMoveLine(models.Model):
     def _get_putaway_additional_qty(self):
         addtional_qty = {}
         for ml in self._origin:
-            qty = max(ml.product_uom_id._compute_quantity(ml.qty_done, ml.product_id.uom_id), ml.product_uom_qty)
+            qty = max(ml.product_uom_id._compute_quantity(ml.qty_done, ml.product_id.uom_id), ml.reserved_uom_qty)
             addtional_qty[ml.location_dest_id.id] = addtional_qty.get(ml.location_dest_id.id, 0) - qty
         return addtional_qty
 
@@ -226,7 +226,7 @@ class StockMoveLine(models.Model):
                 ON
                     stock_move_line (id, company_id, product_id, lot_id, location_id, owner_id, package_id)
                 WHERE
-                    (state IS NULL OR state NOT IN ('cancel', 'done')) AND product_qty > 0""")
+                    (state IS NULL OR state NOT IN ('cancel', 'done')) AND reserved_qty > 0""")
 
     @api.model_create_multi
     def create(self, vals_list):
@@ -334,31 +334,31 @@ class StockMoveLine(models.Model):
                     package_level.unlink()
 
         # When we try to write on a reserved move line any fields from `triggers` or directly
-        # `product_uom_qty` (the actual reserved quantity), we need to make sure the associated
+        # `reserved_uom_qty` (the actual reserved quantity), we need to make sure the associated
         # quants are correctly updated in order to not make them out of sync (i.e. the sum of the
-        # move lines `product_uom_qty` should always be equal to the sum of `reserved_quantity` on
+        # move lines `reserved_uom_qty` should always be equal to the sum of `reserved_quantity` on
         # the quants). If the new charateristics are not available on the quants, we chose to
         # reserve the maximum possible.
-        if updates or 'product_uom_qty' in vals:
+        if updates or 'reserved_uom_qty' in vals:
             for ml in self.filtered(lambda ml: ml.state in ['partially_available', 'assigned'] and ml.product_id.type == 'product'):
 
-                if 'product_uom_qty' in vals:
-                    new_product_uom_qty = ml.product_uom_id._compute_quantity(
-                        vals['product_uom_qty'], ml.product_id.uom_id, rounding_method='HALF-UP')
-                    # Make sure `product_uom_qty` is not negative.
-                    if float_compare(new_product_uom_qty, 0, precision_rounding=ml.product_id.uom_id.rounding) < 0:
+                if 'reserved_uom_qty' in vals:
+                    new_reserved_uom_qty = ml.product_uom_id._compute_quantity(
+                        vals['reserved_uom_qty'], ml.product_id.uom_id, rounding_method='HALF-UP')
+                    # Make sure `reserved_uom_qty` is not negative.
+                    if float_compare(new_reserved_uom_qty, 0, precision_rounding=ml.product_id.uom_id.rounding) < 0:
                         raise UserError(_('Reserving a negative quantity is not allowed.'))
                 else:
-                    new_product_uom_qty = ml.product_qty
+                    new_reserved_uom_qty = ml.reserved_qty
 
                 # Unreserve the old charateristics of the move line.
                 if not ml.move_id._should_bypass_reservation(ml.location_id):
                     try:
-                        Quant._update_reserved_quantity(ml.product_id, ml.location_id, -ml.product_qty, lot_id=ml.lot_id, package_id=ml.package_id, owner_id=ml.owner_id, strict=True)
+                        Quant._update_reserved_quantity(ml.product_id, ml.location_id, -ml.reserved_qty, lot_id=ml.lot_id, package_id=ml.package_id, owner_id=ml.owner_id, strict=True)
                     except UserError:
                         # If we were not able to unreserve on tracked quants, we can use untracked ones.
                         if ml.lot_id:
-                            Quant._update_reserved_quantity(ml.product_id, ml.location_id, -ml.product_qty, lot_id=False, package_id=ml.package_id, owner_id=ml.owner_id, strict=True)
+                            Quant._update_reserved_quantity(ml.product_id, ml.location_id, -ml.reserved_qty, lot_id=False, package_id=ml.package_id, owner_id=ml.owner_id, strict=True)
                         else:
                             raise
 
@@ -366,22 +366,22 @@ class StockMoveLine(models.Model):
                 if not ml.move_id._should_bypass_reservation(updates.get('location_id', ml.location_id)):
                     reserved_qty = 0
                     try:
-                        q = Quant._update_reserved_quantity(ml.product_id, updates.get('location_id', ml.location_id), new_product_uom_qty, lot_id=updates.get('lot_id', ml.lot_id),
+                        q = Quant._update_reserved_quantity(ml.product_id, updates.get('location_id', ml.location_id), new_reserved_uom_qty, lot_id=updates.get('lot_id', ml.lot_id),
                                                              package_id=updates.get('package_id', ml.package_id), owner_id=updates.get('owner_id', ml.owner_id), strict=True)
                         reserved_qty = sum([x[1] for x in q])
                     except UserError:
                         if updates.get('lot_id'):
                             # If we were not able to reserve on tracked quants, we can use untracked ones.
                             try:
-                                q = Quant._update_reserved_quantity(ml.product_id, updates.get('location_id', ml.location_id), new_product_uom_qty, lot_id=False,
+                                q = Quant._update_reserved_quantity(ml.product_id, updates.get('location_id', ml.location_id), new_reserved_uom_qty, lot_id=False,
                                                                      package_id=updates.get('package_id', ml.package_id), owner_id=updates.get('owner_id', ml.owner_id), strict=True)
                                 reserved_qty = sum([x[1] for x in q])
                             except UserError:
                                 pass
-                    if reserved_qty != new_product_uom_qty:
-                        new_product_uom_qty = ml.product_id.uom_id._compute_quantity(reserved_qty, ml.product_uom_id, rounding_method='HALF-UP')
+                    if reserved_qty != new_reserved_uom_qty:
+                        new_reserved_uom_qty = ml.product_id.uom_id._compute_quantity(reserved_qty, ml.product_uom_id, rounding_method='HALF-UP')
                         moves_to_recompute_state |= ml.move_id
-                        ml.with_context(bypass_reservation_update=True).product_uom_qty = new_product_uom_qty
+                        ml.with_context(bypass_reservation_update=True).reserved_uom_qty = new_reserved_uom_qty
 
         # When editing a done move line, the reserved availability of a potential chained move is impacted. Take care of running again `_action_assign` on the concerned moves.
         if updates or 'qty_done' in vals:
@@ -443,7 +443,7 @@ class StockMoveLine(models.Model):
         # this is what move's `action_done` will do. So, we replicate the behavior here.
         if updates or 'qty_done' in vals:
             moves = self.filtered(lambda ml: ml.move_id.state == 'done').mapped('move_id')
-            moves |= self.filtered(lambda ml: ml.move_id.state not in ('done', 'cancel') and ml.move_id.picking_id.immediate_transfer and not ml.product_uom_qty).mapped('move_id')
+            moves |= self.filtered(lambda ml: ml.move_id.state not in ('done', 'cancel') and ml.move_id.picking_id.immediate_transfer and not ml.reserved_uom_qty).mapped('move_id')
             for move in moves:
                 move.product_uom_qty = move.quantity_done
             next_moves._do_unreserve()
@@ -464,12 +464,12 @@ class StockMoveLine(models.Model):
         precision = self.env['decimal.precision'].precision_get('Product Unit of Measure')
         for ml in self:
             # Unlinking a move line should unreserve.
-            if ml.product_id.type == 'product' and not ml.move_id._should_bypass_reservation(ml.location_id) and not float_is_zero(ml.product_qty, precision_digits=precision):
+            if ml.product_id.type == 'product' and not ml.move_id._should_bypass_reservation(ml.location_id) and not float_is_zero(ml.reserved_qty, precision_digits=precision):
                 try:
-                    self.env['stock.quant']._update_reserved_quantity(ml.product_id, ml.location_id, -ml.product_qty, lot_id=ml.lot_id, package_id=ml.package_id, owner_id=ml.owner_id, strict=True)
+                    self.env['stock.quant']._update_reserved_quantity(ml.product_id, ml.location_id, -ml.reserved_qty, lot_id=ml.lot_id, package_id=ml.package_id, owner_id=ml.owner_id, strict=True)
                 except UserError:
                     if ml.lot_id:
-                        self.env['stock.quant']._update_reserved_quantity(ml.product_id, ml.location_id, -ml.product_qty, lot_id=False, package_id=ml.package_id, owner_id=ml.owner_id, strict=True)
+                        self.env['stock.quant']._update_reserved_quantity(ml.product_id, ml.location_id, -ml.reserved_qty, lot_id=False, package_id=ml.package_id, owner_id=ml.owner_id, strict=True)
                     elif not self.env.context.get(MODULE_UNINSTALL_FLAG, False):
                         raise   # pylint: disable=raise-unlink-override
         moves = self.mapped('move_id')
@@ -566,16 +566,16 @@ class StockMoveLine(models.Model):
                 rounding = ml.product_uom_id.rounding
 
                 # if this move line is force assigned, unreserve elsewhere if needed
-                if not ml.move_id._should_bypass_reservation(ml.location_id) and float_compare(ml.qty_done, ml.product_uom_qty, precision_rounding=rounding) > 0:
+                if not ml.move_id._should_bypass_reservation(ml.location_id) and float_compare(ml.qty_done, ml.reserved_uom_qty, precision_rounding=rounding) > 0:
                     qty_done_product_uom = ml.product_uom_id._compute_quantity(ml.qty_done, ml.product_id.uom_id, rounding_method='HALF-UP')
-                    extra_qty = qty_done_product_uom - ml.product_qty
+                    extra_qty = qty_done_product_uom - ml.reserved_qty
                     ml._free_reservation(ml.product_id, ml.location_id, extra_qty, lot_id=ml.lot_id, package_id=ml.package_id, owner_id=ml.owner_id, ml_ids_to_ignore=ml_ids_to_ignore)
                 # unreserve what's been reserved
-                if not ml.move_id._should_bypass_reservation(ml.location_id) and ml.product_id.type == 'product' and ml.product_qty:
+                if not ml.move_id._should_bypass_reservation(ml.location_id) and ml.product_id.type == 'product' and ml.reserved_qty:
                     try:
-                        Quant._update_reserved_quantity(ml.product_id, ml.location_id, -ml.product_qty, lot_id=ml.lot_id, package_id=ml.package_id, owner_id=ml.owner_id, strict=True)
+                        Quant._update_reserved_quantity(ml.product_id, ml.location_id, -ml.reserved_qty, lot_id=ml.lot_id, package_id=ml.package_id, owner_id=ml.owner_id, strict=True)
                     except UserError:
-                        Quant._update_reserved_quantity(ml.product_id, ml.location_id, -ml.product_qty, lot_id=False, package_id=ml.package_id, owner_id=ml.owner_id, strict=True)
+                        Quant._update_reserved_quantity(ml.product_id, ml.location_id, -ml.reserved_qty, lot_id=False, package_id=ml.package_id, owner_id=ml.owner_id, strict=True)
 
                 # move what's been actually done
                 quantity = ml.product_uom_id._compute_quantity(ml.qty_done, ml.move_id.product_id.uom_id, rounding_method='HALF-UP')
@@ -591,7 +591,7 @@ class StockMoveLine(models.Model):
             ml_ids_to_ignore.add(ml.id)
         # Reset the reserved quantity as we just moved it to the destination location.
         mls_todo.with_context(bypass_reservation_update=True).write({
-            'product_uom_qty': 0.00,
+            'reserved_uom_qty': 0.00,
             'date': fields.Datetime.now(),
         })
 
@@ -686,7 +686,7 @@ class StockMoveLine(models.Model):
                 ('location_id', '=', location_id.id),
                 ('owner_id', '=', owner_id.id if owner_id else False),
                 ('package_id', '=', package_id.id if package_id else False),
-                ('product_qty', '>', 0.0),
+                ('reserved_qty', '>', 0.0),
                 ('id', 'not in', tuple(ml_ids_to_ignore)),
             ]
 
@@ -706,11 +706,11 @@ class StockMoveLine(models.Model):
 
             rounding = self.product_uom_id.rounding
             for candidate in outdated_candidates:
-                if float_compare(candidate.product_qty, quantity, precision_rounding=rounding) <= 0:
-                    quantity -= candidate.product_qty
+                if float_compare(candidate.reserved_qty, quantity, precision_rounding=rounding) <= 0:
+                    quantity -= candidate.reserved_qty
                     if candidate.qty_done:
                         move_to_recompute_state |= candidate.move_id
-                        candidate.product_uom_qty = 0.0
+                        candidate.reserved_uom_qty = 0.0
                     else:
                         to_unlink_candidate_ids.add(candidate.id)
                     if float_is_zero(quantity, precision_rounding=rounding):
@@ -718,10 +718,10 @@ class StockMoveLine(models.Model):
                 else:
                     # split this move line and assign the new part to our extra move
                     quantity_split = float_round(
-                        candidate.product_qty - quantity,
+                        candidate.reserved_qty - quantity,
                         precision_rounding=self.product_uom_id.rounding,
                         rounding_method='UP')
-                    candidate.product_uom_qty = self.product_id.uom_id._compute_quantity(quantity_split, candidate.product_uom_id, rounding_method='HALF-UP')
+                    candidate.reserved_uom_qty = self.product_id.uom_id._compute_quantity(quantity_split, candidate.product_uom_id, rounding_method='HALF-UP')
                     move_to_recompute_state |= candidate.move_id
                     break
             self.env['stock.move.line'].browse(to_unlink_candidate_ids).unlink()

--- a/addons/stock/models/stock_package_level.py
+++ b/addons/stock/models/stock_package_level.py
@@ -74,8 +74,8 @@ class StockPackageLevel(models.Model):
                     for rec, quant in ml_update_dict.items():
                         rec.qty_done = quant
             else:
-                package_level.move_line_ids.filtered(lambda ml: ml.product_qty == 0).unlink()
-                package_level.move_line_ids.filtered(lambda ml: ml.product_qty != 0).write({'qty_done': 0})
+                package_level.move_line_ids.filtered(lambda ml: ml.reserved_qty == 0).unlink()
+                package_level.move_line_ids.filtered(lambda ml: ml.reserved_qty != 0).write({'qty_done': 0})
 
     @api.depends('move_line_ids', 'move_line_ids.package_id', 'move_line_ids.result_package_id')
     def _compute_fresh_pack(self):
@@ -95,7 +95,7 @@ class StockPackageLevel(models.Model):
             elif package_level.move_line_ids and not package_level.move_line_ids.filtered(lambda ml: ml.state == 'done'):
                 if package_level.is_fresh_package:
                     package_level.state = 'new'
-                elif package_level._check_move_lines_map_quant_package(package_level.package_id, 'product_uom_qty'):
+                elif package_level._check_move_lines_map_quant_package(package_level.package_id, 'reserved_uom_qty'):
                     package_level.state = 'assigned'
                 else:
                     package_level.state = 'confirmed'

--- a/addons/stock/models/stock_picking.py
+++ b/addons/stock/models/stock_picking.py
@@ -356,7 +356,7 @@ class Picking(models.Model):
         default=lambda self: self.env.user)
     move_line_ids = fields.One2many('stock.move.line', 'picking_id', 'Operations')
     move_line_ids_without_package = fields.One2many('stock.move.line', 'picking_id', 'Operations without package', domain=['|',('package_level_id', '=', False), ('picking_type_entire_packs', '=', False)])
-    move_line_nosuggest_ids = fields.One2many('stock.move.line', 'picking_id', domain=[('product_qty', '=', 0.0)])
+    move_line_nosuggest_ids = fields.One2many('stock.move.line', 'picking_id', domain=[('reserved_qty', '=', 0.0)])
     move_line_exist = fields.Boolean(
         'Has Pack Operations', compute='_compute_move_line_exist',
         help='Check the existence of pack operation on the picking')
@@ -883,7 +883,7 @@ class Picking(models.Model):
         return move_ids_without_package.filtered(lambda move: not move.scrap_ids)
 
     def _check_move_lines_map_quant_package(self, package):
-        return package._check_move_lines_map_quant(self.move_line_ids.filtered(lambda ml: ml.package_id == package), 'product_qty')
+        return package._check_move_lines_map_quant(self.move_line_ids.filtered(lambda ml: ml.package_id == package), 'reserved_qty')
 
     def _get_entire_pack_location_dest(self, move_line_ids):
         location_dest_ids = move_line_ids.mapped('location_dest_id')
@@ -952,7 +952,7 @@ class Picking(models.Model):
             picking_type = picking.picking_type_id
             precision_digits = self.env['decimal.precision'].precision_get('Product Unit of Measure')
             no_quantities_done = all(float_is_zero(move_line.qty_done, precision_digits=precision_digits) for move_line in picking.move_line_ids.filtered(lambda m: m.state not in ('done', 'cancel')))
-            no_reserved_quantities = all(float_is_zero(move_line.product_qty, precision_rounding=move_line.product_uom_id.rounding) for move_line in picking.move_line_ids)
+            no_reserved_quantities = all(float_is_zero(move_line.reserved_qty, precision_rounding=move_line.product_uom_id.rounding) for move_line in picking.move_line_ids)
             if no_reserved_quantities and no_quantities_done:
                 pickings_without_quantities |= picking
 
@@ -1356,28 +1356,28 @@ class Picking(models.Model):
             precision_digits = self.env['decimal.precision'].precision_get('Product Unit of Measure')
             if float_is_zero(move_line_ids[0].qty_done, precision_digits=precision_digits):
                 for line in move_line_ids:
-                    line.qty_done = line.product_uom_qty
+                    line.qty_done = line.reserved_uom_qty
 
             for ml in move_line_ids:
-                if float_compare(ml.qty_done, ml.product_uom_qty,
+                if float_compare(ml.qty_done, ml.reserved_uom_qty,
                                  precision_rounding=ml.product_uom_id.rounding) >= 0:
                     move_lines_to_pack |= ml
                 else:
                     quantity_left_todo = float_round(
-                        ml.product_uom_qty - ml.qty_done,
+                        ml.reserved_uom_qty - ml.qty_done,
                         precision_rounding=ml.product_uom_id.rounding,
                         rounding_method='UP')
                     done_to_keep = ml.qty_done
                     new_move_line = ml.copy(
-                        default={'product_uom_qty': 0, 'qty_done': ml.qty_done})
-                    vals = {'product_uom_qty': quantity_left_todo, 'qty_done': 0.0}
+                        default={'reserved_uom_qty': 0, 'qty_done': ml.qty_done})
+                    vals = {'reserved_uom_qty': quantity_left_todo, 'qty_done': 0.0}
                     if pick.picking_type_id.code == 'incoming':
                         if ml.lot_id:
                             vals['lot_id'] = False
                         if ml.lot_name:
                             vals['lot_name'] = False
                     ml.write(vals)
-                    new_move_line.write({'product_uom_qty': done_to_keep})
+                    new_move_line.write({'reserved_uom_qty': done_to_keep})
                     move_lines_to_pack |= new_move_line
             if not package.package_type_id:
                 package_type = move_lines_to_pack.move_id.product_packaging_id.package_type_id
@@ -1387,7 +1387,7 @@ class Picking(models.Model):
                 default_dest_location = move_lines_to_pack._get_default_dest_location()
                 move_lines_to_pack.location_dest_id = default_dest_location._get_putaway_strategy(
                     product=move_lines_to_pack.product_id,
-                    quantity=move_lines_to_pack.product_uom_qty,
+                    quantity=move_lines_to_pack.reserved_uom_qty,
                     package=package)
             move_lines_to_pack.write({
                 'result_package_id': package.id,
@@ -1419,7 +1419,7 @@ class Picking(models.Model):
                 and not ml.result_package_id
             )
             if not move_line_ids:
-                move_line_ids = picking_move_lines.filtered(lambda ml: float_compare(ml.product_uom_qty, 0.0,
+                move_line_ids = picking_move_lines.filtered(lambda ml: float_compare(ml.reserved_uom_qty, 0.0,
                                      precision_rounding=ml.product_uom_id.rounding) > 0 and float_compare(ml.qty_done, 0.0,
                                      precision_rounding=ml.product_uom_id.rounding) == 0)
             if move_line_ids:

--- a/addons/stock/models/stock_quant.py
+++ b/addons/stock/models/stock_quant.py
@@ -1011,7 +1011,7 @@ class QuantPackage(models.Model):
             move_line_to_modify = self.env['stock.move.line'].search([
                 ('package_id', '=', package.id),
                 ('state', 'in', ('assigned', 'partially_available')),
-                ('product_qty', '!=', 0),
+                ('reserved_qty', '!=', 0),
             ])
             move_line_to_modify.write({'package_id': False})
             package.mapped('quant_ids').sudo().write({'package_id': False})
