PR: https://github.com/odoo/odoo/pull/

From: 43a708735431b58444dae11b27f776a59d148c93
From: Antoine Prieels
Date: 2019-01-14 13:49:01

Structural Changes: 3
Total Changes: 75

[MOV] mrp: Move code from mrp_workorder

Move code that fills in date start and date end on the Work Orders and that does the unplan from Enterprise

Linked to odoo/enterprise#3420
TaskID: 1889399

================================= pseudo patch: =================================

--- a/addons/mrp/models/mrp_production.py
+++ b/addons/mrp/models/mrp_production.py
@@ -2,11 +2,14 @@
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
 from collections import defaultdict
+from datetime import datetime
+from dateutil.relativedelta import relativedelta
+import math
 
 from odoo import api, fields, models, _
 from odoo.addons import decimal_precision as dp
 from odoo.exceptions import UserError
-from odoo.tools import float_compare, float_round
+from odoo.tools import float_compare, float_round, DEFAULT_SERVER_DATETIME_FORMAT
 
 class MrpProduction(models.Model):
     """ Manufacturing Orders """
@@ -86,6 +89,14 @@ class MrpProduction(models.Model):
         'Deadline End', copy=False, default=fields.Datetime.now,
         index=True,
         states={'draft': [('readonly', False)]})
+    date_planned_start_wo = fields.Datetime(
+        'Scheduled Start Date', compute='_compute_date_planned',
+        copy=False, store=True,
+        states={'done': [('readonly', True)], 'cancel': [('readonly', True)]})
+    date_planned_finished_wo = fields.Datetime(
+        'Scheduled End Date', compute='_compute_date_planned',
+        copy=False, store=True,
+        states={'done': [('readonly', True)], 'cancel': [('readonly', True)]})
     date_start = fields.Datetime('Start Date', copy=False, index=True, readonly=True)
     date_finished = fields.Datetime('End Date', copy=False, index=True, readonly=True)
     bom_id = fields.Many2one(
@@ -344,6 +355,18 @@ class MrpProduction(models.Model):
         for production in self:
             production.scrap_count = count_data.get(production.id, 0)
 
+    @api.multi
+    @api.depends('workorder_ids.date_planned_start', 'workorder_ids.date_planned_finished')
+    def _compute_date_planned(self):
+        for order in self:
+            date_planned_start_wo = date_planned_finished_wo = False
+            if order.workorder_ids:
+                start_dates = order.workorder_ids.filtered(lambda r: r.date_planned_start is not False).sorted(key=lambda r: r.date_planned_start)
+                date_planned_start_wo = start_dates[0].date_planned_start if start_dates else False
+                finished_dates = order.workorder_ids.filtered(lambda r: r.date_planned_finished is not False).sorted(key=lambda r: r.date_planned_finished)
+                date_planned_finished_wo = finished_dates[-1].date_planned_finished if finished_dates else False
+            order.date_planned_start_wo = date_planned_start_wo
+            order.date_planned_finished_wo = date_planned_finished_wo
 
     _sql_constraints = [
         ('name_uniq', 'unique(name, company_id)', 'Reference must be unique per Company!'),
@@ -588,8 +611,58 @@ class MrpProduction(models.Model):
             quantity = order.product_uom_id._compute_quantity(order.product_qty, order.bom_id.product_uom_id) / order.bom_id.product_qty
             boms, lines = order.bom_id.explode(order.product_id, quantity, picking_type=order.bom_id.picking_type_id)
             order._generate_workorders(boms)
+        self.plan_workorders()
         return True
 
+    def _get_start_date(self):
+        return datetime.now()
+
+    def plan_workorders(self):
+        WorkOrder = self.env['mrp.workorder']
+        ProductUom = self.env['uom.uom']
+        for order in self.filtered(lambda x: x.state == 'planned'):
+            order.workorder_ids.write({'date_planned_start': False, 'date_planned_finished': False})
+
+        # Schedule all work orders (new ones and those already created)
+        for order in self:
+            start_date = order._get_start_date()
+            from_date_set = False
+            for workorder in order.workorder_ids:
+                workcenter = workorder.workcenter_id
+                wos = WorkOrder.search([('workcenter_id', '=', workcenter.id), ('date_planned_finished', '<>', False),
+                                        ('state', 'in', ('ready', 'pending', 'progress')),
+                                        ('date_planned_finished', '>=', start_date.strftime(DEFAULT_SERVER_DATETIME_FORMAT))], order='date_planned_start')
+                from_date = start_date
+                to_date = workcenter.resource_calendar_id.attendance_ids and workcenter.resource_calendar_id.plan_hours(workorder.duration_expected / 60.0, from_date, compute_leaves=True, resource=workcenter.resource_id)
+                if to_date:
+                    if not from_date_set:
+                        # planning 0 hours gives the start of the next attendance
+                        from_date = workcenter.resource_calendar_id.plan_hours(0, from_date, compute_leaves=True, resource=workcenter.resource_id)
+                        from_date_set = True
+                else:
+                    to_date = from_date + relativedelta(minutes=workorder.duration_expected)
+                # Check interval
+                for wo in wos:
+                    if from_date < fields.Datetime.from_string(wo.date_planned_finished) and (to_date > fields.Datetime.from_string(wo.date_planned_start)):
+                        from_date = fields.Datetime.from_string(wo.date_planned_finished)
+                        to_date = workcenter.resource_calendar_id.attendance_ids and workcenter.resource_calendar_id.plan_hours(workorder.duration_expected / 60.0, from_date, compute_leaves=True, resource=workcenter.resource_id)
+                        if not to_date:
+                            to_date = from_date + relativedelta(minutes=workorder.duration_expected)
+                workorder.write({'date_planned_start': from_date, 'date_planned_finished': to_date})
+
+                if (workorder.operation_id.batch == 'no') or (workorder.operation_id.batch_size >= workorder.qty_production):
+                    start_date = to_date
+                else:
+                    qty = min(workorder.operation_id.batch_size, workorder.qty_production)
+                    cycle_number = math.ceil(qty / workorder.production_id.product_qty / workcenter.capacity)
+                    duration = workcenter.time_start + cycle_number * workorder.operation_id.time_cycle * 100.0 / workcenter.time_efficiency
+                    to_date = workcenter.resource_calendar_id.attendance_ids and workcenter.resource_calendar_id.plan_hours(duration / 60.0, from_date, compute_leaves=True, resource=workcenter.resource_id)
+                    if not to_date:
+                        start_date = from_date + relativedelta(minutes=duration)
+
+    def button_unplan(self):
+        self.mapped('workorder_ids').write({'date_planned_start': False, 'date_planned_finished': False})
+
     @api.multi
     def _generate_workorders(self, exploded_boms):
         workorders = self.env['mrp.workorder']
