PR: https://github.com/odoo/odoo/pull/

From: 75995f5965b36b07dcce67375fd0031b32b766ef
From: jem-odoo
Date: 2018-01-29 16:16:27

Structural Changes: 5
Total Changes: 26

[IMP] sale,sale_*: correct use of expense_policy

A product can be sell or expense, but for some cases the product
configuration make both flow incompatible. Indeed, when expensing
the delivered qty was computed based on the AAL total amount, and
manually editable.
Before the delivered qty refactoring, reexpensing erased the manual
value.

This came from the fact product expense policy is wrongly used: the
delivered qty of expensable product is not manually editable, which
is a problem for milestones (and other consumable product when stock is
no installed).
The new refactoring of deli qty API force the expense line to be
completely
readonly, but the problem is not completely solved; we still can't sell
properly a expensable product.

To do so, the SO line must be flag as coming from an expense or vendor
bill, and the reinvoice product policy should only be used to calculate
the price of new SO line.

This commit:
1) reinforces the readonly caracter of expense SO line, by making the
expense policy independent of the computation method for delivered qty
on SOL.
2) prevents generate picking when updating ordered quantity on a expense
SOL with a stockable product.
3) allows service to sell a task with zero hours as ordered quantity.
(it still prevents task/project creation for expense SOL).
4) does not increment anymore an existing line when expensing product
at sales price and invoicing at 'delivered qty'. The only line to be
incremented will be the expense line (and not the native SOL).

================================= pseudo patch: =================================

--- a/addons/sale_timesheet/models/project.py
+++ b/addons/sale_timesheet/models/project.py
@@ -8,7 +8,7 @@ from odoo.exceptions import ValidationError
 class Project(models.Model):
     _inherit = 'project.project'
 
-    sale_line_id = fields.Many2one('sale.order.line', 'Sales Order Line', readonly=True, help="Sale order line from which the project has been created. Used for tracability.")
+    sale_line_id = fields.Many2one('sale.order.line', 'Sales Order Line', domain=[('is_expense', '=', False)], readonly=True, help="Sale order line from which the project has been created. Used for tracability.")
 
     @api.multi
     def action_view_timesheet(self):
@@ -56,7 +56,15 @@ class Project(models.Model):
 class ProjectTask(models.Model):
     _inherit = "project.task"
 
-    sale_line_id = fields.Many2one('sale.order.line', 'Sales Order Item', domain="[('is_service', '=', True), ('order_partner_id', '=', partner_id)]")
+    sale_line_id = fields.Many2one('sale.order.line', 'Sales Order Item', domain="[('is_service', '=', True), ('order_partner_id', '=', partner_id), ('is_expense', '=', False)]")
+
+    @api.multi
+    @api.constrains('sale_line_id')
+    def _check_sale_line_type(self):
+        for task in self:
+            if task.sale_line_id:
+                if not task.sale_line_id.is_service or task.sale_line_id.is_expense:
+                    raise ValidationError(_("The Sales order line should be one selling a service, and no coming from expense."))
 
     @api.model
     def create(self, values):

--- a/addons/sale_timesheet/models/sale_order.py
+++ b/addons/sale_timesheet/models/sale_order.py
@@ -139,6 +139,7 @@ class SaleOrderLine(models.Model):
     qty_delivered_method = fields.Selection(selection_add=[('timesheet', 'Timesheets')])
     task_id = fields.Many2one('project.task', 'Task', help="Task generated by the sales order item")
     is_service = fields.Boolean("Is a Service", compute='_compute_is_service', store=True, help="Sales Order item should generate a task and/or a project, depending on the product settings.")
+    analytic_line_ids = fields.One2many(domain=[('project_id', '=', False)])  # only analytic lines, not timesheets (since this field determine if SO line came from expense)
 
     @api.multi
     @api.depends('product_id.type', 'product_id.service_type')
@@ -146,11 +147,8 @@ class SaleOrderLine(models.Model):
         """ Sale Timesheet module compute delivered qty for product [('type', 'in', ['service']), ('service_type', '=', 'timesheet')] """
         super(SaleOrderLine, self)._compute_qty_delivered_method()
         for line in self:
-            if line.product_id.type == 'service' and line.product_id.service_type == 'timesheet':
-                if line.product_id.expense_policy == 'no':
-                    line.qty_delivered_method = 'timesheet'
-                else:
-                    line.qty_delivered_method = 'analytic'
+            if not line.is_expense and line.product_id.type == 'service' and line.product_id.service_type == 'timesheet':
+                line.qty_delivered_method = 'timesheet'
 
     @api.multi
     @api.depends('analytic_line_ids.project_id')
@@ -185,9 +183,9 @@ class SaleOrderLine(models.Model):
     @api.model
     def create(self, values):
         line = super(SaleOrderLine, self).create(values)
-        precision = self.env['decimal.precision'].precision_get('Product Unit of Measure')
-        # check ordered quantity to avoid create project/task when expensing service products
-        if line.state == 'sale' and not float_is_zero(line.product_uom_qty, precision_digits=precision):
+        # Do not generate task/project when expense SO line, but allow
+        # generate task with hours=0.
+        if line.state == 'sale' and not line.is_expense:
             line._timesheet_service_generation()
         return line
 
