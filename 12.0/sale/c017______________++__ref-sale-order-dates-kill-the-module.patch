PR: https://github.com/odoo/odoo/pull/

From: 867e47927dc9e38f397f8abc4dc5e295784331b4
From: jem-odoo
Date: 2018-08-10 14:30:19

Structural Changes: 6
Total Changes: 42

[REF] sale_order_dates: kill the module

This commit dissolves module into sale and sale_stock. Indeed
some fields will be needed for services in next development.
- module is replace by a group in sale
- `commitment_date` and `expected_date` are moved into sale
directly, because they are meaningful for purchasing services
- `expected_date` implementation change when sale_stock is
installed, as the picking_policy of the SO determine if the
min or max dates should be chosen.
- `effective_date` is moved to sale_stock
- tests are moved into sale_stock, and tagged to be executed
after install (post install) otherwise it fails (since
sale_order_dates was a leaf module, it makes sense).

From a functionnal point of view, nothing should have changed,
except that user can see `commitment_date` and `expected_date`
even if sale_stock is not installed, by activating a group.

Task #39340

================================= pseudo patch: =================================

--- a/addons/sale/models/res_config_settings.py
+++ b/addons/sale/models/res_config_settings.py
@@ -34,6 +34,7 @@ class ResConfigSettings(models.TransientModel):
         ], string="Pricelists", config_parameter='sale.sale_pricelist_setting')
     group_proforma_sales = fields.Boolean(string="Pro-Forma Invoice", implied_group='sale.group_proforma_sales',
         help="Allows you to send pro-forma invoice.")
+    group_sale_order_dates = fields.Boolean("Delivery Date", implied_group='sale.group_sale_order_dates')
     default_invoice_policy = fields.Selection([
         ('order', 'Invoice what is ordered'),
         ('delivery', 'Invoice what is delivered')

--- a/addons/sale/models/res_users.py
+++ b/addons/sale/models/res_users.py
@@ -26,3 +26,8 @@ class ResUsers(models.Model):
         "Pro-forma Invoices",
         compute='_compute_groups_id', inverse='_inverse_groups_id',
         group_xml_id='sale.group_proforma_sales')
+
+    has_group_sale_order_dates = fields.Boolean(
+        "Sale Order Dates",
+        compute='_compute_groups_id', inverse='_inverse_groups_id',
+        group_xml_id='sale.group_sale_order_dates')

--- a/addons/sale/models/sale.py
+++ b/addons/sale/models/sale.py
@@ -3,7 +3,7 @@
 
 import uuid
 
-from datetime import datetime
+from datetime import datetime, timedelta
 
 from odoo import api, fields, models, _
 from odoo.exceptions import UserError, AccessError
@@ -157,6 +157,14 @@ class SaleOrder(models.Model):
     signature = fields.Binary('Signature', help='Signature received through the portal.', copy=False, attachment=True)
     signed_by = fields.Char('Signed by', help='Name of the person that signed the SO.', copy=False)
 
+    commitment_date = fields.Datetime('Commitment Date',
+        states={'draft': [('readonly', False)], 'sent': [('readonly', False)]},
+        copy=False, oldname='requested_date', readonly=True,
+        help="This is the delivery date promised to the customer. If set, the delivery order "
+             "will be scheduled based on this date rather than product lead times.")
+    expected_date = fields.Datetime("Expected Date", compute='_compute_expected_date', store=False, oldname='commitment_date',  # Note: can not be stored since depends on today()
+        help="Delivery date you can promise to the customer, computed from product lead times and from the shipping policy of the order.")
+
     def _compute_access_url(self):
         super(SaleOrder, self)._compute_access_url()
         for order in self:
@@ -170,6 +178,21 @@ class SaleOrder(models.Model):
             else:
                 order.is_expired = False
 
+    @api.multi
+    @api.depends('order_line.customer_lead', 'confirmation_date', 'order_line.state')
+    def _compute_expected_date(self):
+        """ For service and consumable, we only take the min dates. This method is extended in sale_stock to
+            take the picking_policy of SO into account.
+        """
+        for order in self:
+            dates_list = []
+            confirm_date = fields.Datetime.from_string(order.confirmation_date if order.state == 'sale' else fields.Datetime.now())
+            for line in order.order_line.filtered(lambda x: x.state != 'cancel' and not x._is_delivery()):
+                dt = confirm_date + timedelta(days=line.customer_lead or 0.0)
+                dates_list.append(dt)
+            if dates_list:
+                order.expected_date = fields.Datetime.to_string(min(dates_list))
+
     @api.model
     def _get_customer_lead(self, product_tmpl_id):
         return False
@@ -263,6 +286,17 @@ class SaleOrder(models.Model):
         if warning:
             return {'warning': warning}
 
+    @api.onchange('commitment_date')
+    def _onchange_commitment_date(self):
+        """ Warn if the commitment dates is sooner than the expected date """
+        if (self.commitment_date and self.expected_date and self.commitment_date < self.expected_date):
+            return {
+                'warning': {
+                    'title': _('Requested date is too soon.'),
+                    'message': _("The date requested by the customer is sooner than the commitment date. You may be unable to honor the customer's request.")
+                }
+            }
+
     @api.model
     def create(self, vals):
         if vals.get('name', _('New')) == _('New'):
