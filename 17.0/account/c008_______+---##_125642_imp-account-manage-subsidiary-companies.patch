PR: https://github.com/odoo/odoo/pull/125642

From: 0479b2b59466ae1d6d74165345aa3a7dc5de24ed
From: william-andre
Date: 2023-07-20 09:49:06

Breaking data model changes score: 9.200000000000003, change matches:
-    company_id = fields.Many2one('res.company', string='Company', required=True, readonly=True,
+    company_id = fields.Many2one('res.company', string='Company', required=True, readonly=False,
-    allowed_journal_ids = fields.Many2many('account.journal', string="Allowed Journals", help="Define in which journals this account can be used. If empty, can be used in all journals.")
+    allowed_journal_ids = fields.Many2many(
-    profit_account_id = fields.Many2one('account.account', string='Profit Account', company_dependent=True, domain="[('deprecated', '=', False), ('company_id', '=', current_company_id)]")
-    loss_account_id = fields.Many2one('account.account', string='Loss Account', company_dependent=True, domain="[('deprecated', '=', False), ('company_id', '=', current_company_id)]")
+    profit_account_id = fields.Many2one(
+    loss_account_id = fields.Many2one(
-    excluded_journal_ids = fields.Many2many('account.journal', string="Excluded Journals", domain="[('company_id', '=', company_id)]",
+    excluded_journal_ids = fields.Many2many('account.journal', string="Excluded Journals",
-    journal_id = fields.Many2one(comodel_name='account.journal', ondelete="cascade")
+    journal_id = fields.Many2one(
+    company_id = fields.Many2one(related='model_id.company_id')
-    automatic_entry_default_journal_id = fields.Many2one('account.journal', help="Journal used by default for moving the period of an entry", domain="[('type', '=', 'general')]")
+    automatic_entry_default_journal_id = fields.Many2one(
-    sale_tax_id = fields.Many2one('account.tax', string="Default Sale Tax", related='company_id.account_sale_tax_id', readonly=False)
-    purchase_tax_id = fields.Many2one('account.tax', string="Default Purchase Tax", related='company_id.account_purchase_tax_id', readonly=False)
+    sale_tax_id = fields.Many2one(
+    purchase_tax_id = fields.Many2one(
-    tax_cash_basis_journal_id = fields.Many2one('account.journal', related='company_id.tax_cash_basis_journal_id', string="Tax Cash Basis Journal", readonly=False)
+    tax_cash_basis_journal_id = fields.Many2one(

Total Changes: 746

[IMP] account,*: manage subsidiary companies

Allow sharing records between company
* accounts
* taxes
* fiscal positions
* products
* ...and some related models

These records can be read and used in children companies.

This can be used to
* have different branding for different businesses
* allow more complex security rules
* consolidate branches differently
* manage different tax reports with different tax ids in the same
  country

task-3371677

closes odoo/odoo#125642

Related: odoo/enterprise#43215
Signed-off-by: Quentin De Paoli <qdp@odoo.com>

================================= pseudo patch: =================================

--- a/addons/account/models/account_account.py
+++ b/addons/account/models/account_account.py
@@ -16,6 +16,7 @@ class AccountAccount(models.Model):
     _description = "Account"
     _order = "code, company_id"
     _check_company_auto = True
+    _check_company_domain = models.check_company_domain_parent_of
 
     @api.constrains('account_type', 'reconcile')
     def _check_reconcile(self):
@@ -92,13 +93,18 @@ class AccountAccount(models.Model):
         check_company=True,
         context={'append_type_to_tax_name': True})
     note = fields.Text('Internal Notes', tracking=True)
-    company_id = fields.Many2one('res.company', string='Company', required=True, readonly=True,
+    company_id = fields.Many2one('res.company', string='Company', required=True, readonly=False,
         default=lambda self: self.env.company)
     tag_ids = fields.Many2many('account.account.tag', 'account_account_account_tag', string='Tags', help="Optional tags you may want to assign for custom reporting", ondelete='restrict')
     group_id = fields.Many2one('account.group', compute='_compute_account_group', store=True, readonly=True,
                                help="Account prefixes can determine account groups.")
     root_id = fields.Many2one('account.root', compute='_compute_account_root', store=True, precompute=True)
-    allowed_journal_ids = fields.Many2many('account.journal', string="Allowed Journals", help="Define in which journals this account can be used. If empty, can be used in all journals.")
+    allowed_journal_ids = fields.Many2many(
+        'account.journal',
+        string="Allowed Journals",
+        help="Define in which journals this account can be used. If empty, can be used in all journals.",
+        check_company=True,
+    )
     opening_debit = fields.Monetary(string="Opening Debit", compute='_compute_opening_debit_credit', inverse='_set_opening_debit')
     opening_credit = fields.Monetary(string="Opening Credit", compute='_compute_opening_debit_credit', inverse='_set_opening_credit')
     opening_balance = fields.Monetary(string="Opening Balance", compute='_compute_opening_debit_credit', inverse='_set_opening_balance')
@@ -106,14 +112,25 @@ class AccountAccount(models.Model):
     current_balance = fields.Float(compute='_compute_current_balance')
     related_taxes_amount = fields.Integer(compute='_compute_related_taxes_amount')
 
-    _sql_constraints = [
-        ('code_company_uniq', 'unique (code,company_id)', 'The code of the account must be unique per company!')
-    ]
-
     non_trade = fields.Boolean(default=False,
                                help="If set, this account will belong to Non Trade Receivable/Payable in reports and filters.\n"
                                     "If not, this account will belong to Trade Receivable/Payable in reports and filters.")
 
+    @api.constrains('company_id', 'code')
+    def _constrains_code(self):
+        domains = []
+        for record in self:
+            domains.append([
+                ('company_id', 'child_of', record.company_id.root_id.id),
+                ('code', '=', record.code),
+                ('id', '!=', record.id),
+            ])
+        if duplicates := self.search(expression.OR(domains)):
+            raise ValidationError(
+                _("The code of the account must be unique per company!")
+                + "\n" + "\n".join(f"- {duplicate.code} in {duplicate.company_id.name}" for duplicate in duplicates)
+            )
+
     @api.constrains('reconcile', 'internal_group', 'tax_ids')
     def _constrains_reconcile(self):
         for record in self:
@@ -213,20 +230,12 @@ class AccountAccount(models.Model):
 
     @api.constrains('company_id')
     def _check_company_consistency(self):
-        if not self:
-            return
-
-        self.env['account.move.line'].flush_model(['account_id', 'company_id'])
-        self.flush_recordset(['company_id'])
-        self._cr.execute('''
-            SELECT line.id
-            FROM account_move_line line
-            JOIN account_account account ON account.id = line.account_id
-            WHERE line.account_id IN %s
-            AND line.company_id != account.company_id
-        ''', [tuple(self.ids)])
-        if self._cr.fetchone():
-            raise UserError(_("You can't change the company of your account since there are some journal items linked to it."))
+        for company, accounts in tools.groupby(self, lambda account: account.company_id):
+            if self.env['account.move.line'].search([
+                ('account_id', 'in', [account.id for account in accounts]),
+                '!', ('company_id', 'child_of', company.id)
+            ], limit=1):
+                raise UserError(_("You can't change the company of your account since there are some journal items linked to it."))
 
     @api.constrains('account_type')
     def _check_account_type_sales_purchase_journal(self):
@@ -347,7 +356,7 @@ class AccountAccount(models.Model):
             new_code = str(prefix.ljust(digits - 1, '0')) + str(num)
             if new_code in (cache or []):
                 continue
-            rec = self.search([('code', '=', new_code), ('company_id', '=', company.id)], limit=1)
+            rec = self.search([('code', '=', new_code), ('company_id', 'child_of', company.root_id.id)], limit=1)
             if not rec:
                 return new_code
         raise UserError(_('Cannot generate an unused account code.'))
@@ -531,28 +540,31 @@ class AccountAccount(models.Model):
         :param limit: the maximum number of accounts to retrieve
         :returns: List of account ids, ordered by frequency (from most to least frequent)
         """
-        join = "INNER JOIN" if filter_never_user_accounts else "LEFT JOIN"
-        limit = f"LIMIT {limit:d}" if limit else ""
-        where_internal_group = ""
+        domain = [
+            *self.env['account.move.line']._check_company_domain(company_id),
+            ('partner_id', '=', partner_id),
+            ('account_id.deprecated', '=', False),
+            ('date', '>=', fields.Date.add(fields.Date.today(), days=-365 * 2)),
+        ]
         if move_type in self.env['account.move'].get_inbound_types(include_receipts=True):
-            where_internal_group = "AND account.internal_group = 'income'"
+            domain.append(('account_id.internal_group', '=', 'income'))
         elif move_type in self.env['account.move'].get_outbound_types(include_receipts=True):
-            where_internal_group = "AND account.internal_group = 'expense'"
+            domain.append(('account_id.internal_group', '=', 'expense'))
+
+        query = self.env['account.move.line']._where_calc(domain)
+        if not filter_never_user_accounts:
+            _kind, rhs_table, condition, condition_params = query._joins['account_move_line__account_id']
+            query._joins['account_move_line__account_id'] = ("RIGHT JOIN", rhs_table, condition, condition_params)
+
+        from_clause, where_clause, params = query.get_sql()
         self._cr.execute(f"""
-            SELECT account.id
-              FROM account_account account
-            {join} account_move_line aml
-                ON aml.account_id  = account.id
-                AND aml.partner_id = %s
-                AND account.deprecated = FALSE
-                AND account.company_id = aml.company_id
-                AND aml.date >= now() - interval '2 years'
-              WHERE account.company_id = %s
-                   {where_internal_group}
-            GROUP BY account.id
-            ORDER BY COUNT(aml.id) DESC, account.code
-                   {limit}
-        """, [partner_id, company_id])
+            SELECT account_move_line__account_id.id
+              FROM {from_clause}
+             WHERE {where_clause}
+          GROUP BY account_move_line__account_id.id
+          ORDER BY COUNT(account_move_line.id) DESC, account_move_line__account_id.code
+                   {f"LIMIT {limit:d}" if limit else ""}
+        """, params)
         return [r[0] for r in self._cr.fetchall()]
 
     @api.model
@@ -610,8 +622,10 @@ class AccountAccount(models.Model):
         try:
             default['code'] = (str(int(self.code) + 10) or '').zfill(len(self.code))
             default.setdefault('name', _("%s (copy)") % (self.name or ''))
-            while self.env['account.account'].search([('code', '=', default['code']),
-                                                      ('company_id', '=', default.get('company_id', False) or self.company_id.id)], limit=1):
+            while self.env['account.account'].search([
+                *self.env['account.account']._check_company_domain(default.get('company_id', False) or self.company_id),
+                ('code', '=', default['code']),
+            ], limit=1):
                 default['code'] = (str(int(default['code']) + 10) or '')
                 default['name'] = _("%s (copy)") % (self.name or '')
         except ValueError:
@@ -715,12 +729,6 @@ class AccountAccount(models.Model):
         return super().create(vals_list)
 
     def write(self, vals):
-        # Do not allow changing the company_id when account_move_line already exist
-        if vals.get('company_id', False):
-            move_lines = self.env['account.move.line'].search([('account_id', 'in', self.ids)], limit=1)
-            for account in self:
-                if (account.company_id.id != vals['company_id']) and move_lines:
-                    raise UserError(_('You cannot change the owner company of an account that already contains journal items.'))
         if 'reconcile' in vals:
             if vals['reconcile']:
                 self.filtered(lambda r: not r.reconcile)._toggle_reconcile_to_true()
@@ -799,8 +807,10 @@ class AccountGroup(models.Model):
     _description = 'Account Group'
     _parent_store = True
     _order = 'code_prefix_start'
+    _check_company_auto = True
+    _check_company_domain = models.check_company_domain_parent_of
 
-    parent_id = fields.Many2one('account.group', index=True, ondelete='cascade', readonly=True)
+    parent_id = fields.Many2one('account.group', index=True, ondelete='cascade', readonly=True, check_company=True)
     parent_path = fields.Char(index=True, unaccent=False)
     name = fields.Char(required=True, translate=True)
     code_prefix_start = fields.Char(compute='_compute_code_prefix_start', readonly=False, store=True, precompute=True)
@@ -906,7 +916,7 @@ class AccountGroup(models.Model):
         """
         if self.env.context.get('delay_account_group_sync'):
             return
-        company_ids = account_ids.company_id.ids if account_ids else self.company_id.ids
+        company_ids = account_ids.company_id.root_id.ids if account_ids else self.company_id.ids
         account_ids = account_ids.ids if account_ids else []
         if not company_ids and not account_ids:
             return
@@ -925,10 +935,11 @@ class AccountGroup(models.Model):
                         account.id AS account_id,
                         agroup.id AS group_id
                    FROM account_account account
+                   JOIN res_company account_company ON account_company.id = account.company_id
               LEFT JOIN account_group agroup
                      ON agroup.code_prefix_start <= LEFT(account.code, char_length(agroup.code_prefix_start))
                     AND agroup.code_prefix_end >= LEFT(account.code, char_length(agroup.code_prefix_end))
-                    AND agroup.company_id = account.company_id
+                    AND agroup.company_id = split_part(account_company.parent_path, '/', 1)::int
                   WHERE account.company_id IN %s {account_where_clause}
                ORDER BY account.id, char_length(agroup.code_prefix_start) DESC, agroup.id
             )

--- a/addons/account/models/account_analytic_distribution_model.py
+++ b/addons/account/models/account_analytic_distribution_model.py
@@ -14,6 +14,7 @@ class AccountAnalyticDistributionModel(models.Model):
         'product.product',
         string='Product',
         ondelete='cascade',
+        check_company=True,
         help="Select a product for which the analytic distribution will be used (e.g. create new customer invoice or Sales order if we select this product, it will automatically take this as an analytic account)",
     )
     product_categ_id = fields.Many2one(

--- a/addons/account/models/account_analytic_line.py
+++ b/addons/account/models/account_analytic_line.py
@@ -16,7 +16,8 @@ class AccountAnalyticLine(models.Model):
         'account.account',
         string='Financial Account',
         ondelete='restrict',
-        domain="[('deprecated', '=', False), ('company_id', '=', company_id)]",
+        domain="[('deprecated', '=', False)]",
+        check_company=True,
         compute='_compute_general_account_id', store=True, readonly=False
     )
     journal_id = fields.Many2one(

--- a/addons/account/models/account_bank_statement_line.py
+++ b/addons/account/models/account_bank_statement_line.py
@@ -453,7 +453,7 @@ class AccountBankStatementLine(models.Model):
             # Base domain.
             ('display_type', 'not in', ('line_section', 'line_note')),
             ('parent_state', '=', 'posted'),
-            ('company_id', '=', self.company_id.id),
+            ('company_id', 'child_of', self.company_id.root_id.id),
             # Reconciliation domain.
             ('reconciled', '=', False),
             ('account_id.reconcile', '=', True),
@@ -469,8 +469,8 @@ class AccountBankStatementLine(models.Model):
     def _get_default_journal(self):
         journal_type = self.env.context.get('journal_type', 'bank')
         return self.env['account.journal'].search([
+                *self.env['account.journal']._check_company_domain(self.env.company),
                 ('type', '=', journal_type),
-                ('company_id', '=', self.env.company.id)
             ], limit=1)
 
     @api.model

--- a/addons/account/models/account_cash_rounding.py
+++ b/addons/account/models/account_cash_rounding.py
@@ -14,6 +14,7 @@ class AccountCashRounding(models.Model):
     """
     _name = 'account.cash.rounding'
     _description = 'Account Cash Rounding'
+    _check_company_auto = True
 
     name = fields.Char(string='Name', translate=True, required=True)
     rounding = fields.Float(string='Rounding Precision', required=True, default=0.01,
@@ -21,8 +22,18 @@ class AccountCashRounding(models.Model):
     strategy = fields.Selection([('biggest_tax', 'Modify tax amount'), ('add_invoice_line', 'Add a rounding line')],
         string='Rounding Strategy', default='add_invoice_line', required=True,
         help='Specify which way will be used to round the invoice amount to the rounding precision')
-    profit_account_id = fields.Many2one('account.account', string='Profit Account', company_dependent=True, domain="[('deprecated', '=', False), ('company_id', '=', current_company_id)]")
-    loss_account_id = fields.Many2one('account.account', string='Loss Account', company_dependent=True, domain="[('deprecated', '=', False), ('company_id', '=', current_company_id)]")
+    profit_account_id = fields.Many2one(
+        'account.account',
+        string='Profit Account',
+        company_dependent=True,
+        domain="[('deprecated', '=', False)]",
+    )
+    loss_account_id = fields.Many2one(
+        'account.account',
+        string='Loss Account',
+        company_dependent=True,
+        domain="[('deprecated', '=', False)]",
+    )
     rounding_method = fields.Selection(string='Rounding Method', required=True,
         selection=[('UP', 'UP'), ('DOWN', 'DOWN'), ('HALF-UP', 'HALF-UP')],
         default='HALF-UP', help='The tie-breaking rule used for float rounding operations')

--- a/addons/account/models/account_journal.py
+++ b/addons/account/models/account_journal.py
@@ -2,7 +2,7 @@
 from odoo import api, Command, fields, models, _
 from odoo.exceptions import UserError, ValidationError
 from odoo.addons.base.models.res_bank import sanitize_account_number
-from odoo.tools import remove_accents
+from odoo.tools import remove_accents, groupby
 from collections import defaultdict
 import logging
 import re
@@ -21,10 +21,11 @@ class AccountJournalGroup(models.Model):
     _name = 'account.journal.group'
     _description = "Account Journal Group"
     _check_company_auto = True
+    _check_company_domain = models.check_company_domain_parent_of
 
     name = fields.Char("Journal Group", required=True, translate=True)
     company_id = fields.Many2one('res.company', required=True, default=lambda self: self.env.company)
-    excluded_journal_ids = fields.Many2many('account.journal', string="Excluded Journals", domain="[('company_id', '=', company_id)]",
+    excluded_journal_ids = fields.Many2many('account.journal', string="Excluded Journals",
         check_company=True)
     sequence = fields.Integer(default=10)
 
@@ -38,6 +39,7 @@ class AccountJournal(models.Model):
     _order = 'sequence, type, code'
     _inherit = ['mail.thread', 'mail.activity.mixin', 'portal.mixin']
     _check_company_auto = True
+    _check_company_domain = models.check_company_domain_parent_of
     _rec_names_search = ['name', 'code']
 
     def _default_inbound_payment_methods(self):
@@ -86,20 +88,20 @@ class AccountJournal(models.Model):
         "Select 'General' for miscellaneous operations journals.")
     account_control_ids = fields.Many2many('account.account', 'journal_account_control_rel', 'journal_id', 'account_id', string='Allowed accounts',
         check_company=True,
-        domain="[('deprecated', '=', False), ('company_id', '=', company_id), ('account_type', '!=', 'off_balance')]")
+        domain="[('deprecated', '=', False), ('account_type', '!=', 'off_balance')]")
     default_account_type = fields.Char(string='Default Account Type', compute="_compute_default_account_type")
     default_account_id = fields.Many2one(
         comodel_name='account.account', check_company=True, copy=False, ondelete='restrict',
         string='Default Account',
-        domain="[('deprecated', '=', False), ('company_id', '=', company_id),"
+        domain="[('deprecated', '=', False),"
                "('account_type', '=', default_account_type), ('account_type', 'not in', ('asset_receivable', 'liability_payable'))]")
     suspense_account_id = fields.Many2one(
         comodel_name='account.account', check_company=True, ondelete='restrict', readonly=False, store=True,
         compute='_compute_suspense_account_id',
         help="Bank statements transactions will be posted on the suspense account until the final reconciliation "
              "allowing finding the right account.", string='Suspense Account',
-        domain="[('deprecated', '=', False), ('company_id', '=', company_id), \
-                ('account_type', '=', 'asset_current')]")
+        domain="[('deprecated', '=', False), ('account_type', '=', 'asset_current')]",
+    )
     restrict_mode_hash_table = fields.Boolean(string="Lock Posted Entries with Hash",
         help="If ticked, the accounting entry or invoice receives a hash as soon as it is posted and cannot be modified anymore.")
     sequence = fields.Integer(help='Used to order Journals in the dashboard view', default=10)
@@ -158,13 +160,13 @@ class AccountJournal(models.Model):
         comodel_name='account.account', check_company=True,
         help="Used to register a profit when the ending balance of a cash register differs from what the system computes",
         string='Profit Account',
-        domain="[('deprecated', '=', False), ('company_id', '=', company_id), \
+        domain="[('deprecated', '=', False), \
                 ('account_type', 'in', ('income', 'income_other'))]")
     loss_account_id = fields.Many2one(
         comodel_name='account.account', check_company=True,
         help="Used to register a loss when the ending balance of a cash register differs from what the system computes",
         string='Loss Account',
-        domain="[('deprecated', '=', False), ('company_id', '=', company_id), \
+        domain="[('deprecated', '=', False), \
                 ('account_type', '=', 'expense')]")
 
     # Bank journals fields
@@ -173,7 +175,7 @@ class AccountJournal(models.Model):
         string="Bank Account",
         ondelete='restrict', copy=False,
         check_company=True,
-        domain="[('partner_id','=', company_partner_id), '|', ('company_id', '=', False), ('company_id', '=', company_id)]")
+        domain="[('partner_id','=', company_partner_id)]")
     bank_statements_source = fields.Selection(selection=_get_bank_statements_available_sources, string='Bank Feeds', default='undefined', help="Defines how the bank statements will be registered")
     bank_acc_number = fields.Char(related='bank_account_id.acc_number', readonly=False)
     bank_id = fields.Many2one('res.bank', related='bank_account_id.bank_id', readonly=False)
@@ -191,7 +193,6 @@ class AccountJournal(models.Model):
     alias_name = fields.Char('Alias Name', copy=False, compute='_compute_alias_name', inverse='_inverse_type', help="It creates draft invoices and bills by sending an email.")
 
     journal_group_ids = fields.Many2many('account.journal.group',
-        domain="[('company_id', '=', company_id)]",
         check_company=True,
         string="Journal Groups")
 
@@ -432,20 +433,12 @@ class AccountJournal(models.Model):
 
     @api.constrains('company_id')
     def _check_company_consistency(self):
-        if not self:
-            return
-
-        self.env['account.move'].flush_model(['company_id', 'journal_id'])
-        self.flush_recordset(['company_id'])
-        self._cr.execute('''
-            SELECT move.id
-            FROM account_move move
-            JOIN account_journal journal ON journal.id = move.journal_id
-            WHERE move.journal_id IN %s
-            AND move.company_id != journal.company_id
-        ''', [tuple(self.ids)])
-        if self._cr.fetchone():
-            raise UserError(_("You can't change the company of your journal since there are some journal entries linked to it."))
+        for company, journals in groupby(self, lambda journal: journal.company_id):
+            if self.env['account.move'].search([
+                ('journal_id', 'in', [journal.id for journal in journals]),
+                '!', ('company_id', 'child_of', company.id)
+            ], limit=1):
+                raise UserError(_("You can't change the company of your journal since there are some journal entries linked to it."))
 
     @api.constrains('type', 'default_account_id')
     def _check_type_default_account_id_type(self):
@@ -529,7 +522,10 @@ class AccountJournal(models.Model):
         default = dict(default or {})
 
         # Find a unique code for the copied journal
-        read_codes = self.env['account.journal'].with_context(active_test=False).search_read([('company_id', '=', self.company_id.id)], ['code'])
+        read_codes = self.env['account.journal'].with_context(active_test=False).search_read(
+            self.env['account.journal']._check_company_domain(self.company_id),
+            ['code'],
+        )
         all_journal_codes = {code_data['code'] for code_data in read_codes}
 
         copy_code = self.code
@@ -556,8 +552,6 @@ class AccountJournal(models.Model):
         for journal in self:
             company = journal.company_id
             if ('company_id' in vals and journal.company_id.id != vals['company_id']):
-                if self.env['account.move'].search([('journal_id', '=', journal.id)], limit=1):
-                    raise UserError(_('This journal already contains items, therefore you cannot modify its company.'))
                 company = self.env['res.company'].browse(vals['company_id'])
                 if journal.bank_account_id.company_id and journal.bank_account_id.company_id != company:
                     journal.bank_account_id.write({
@@ -598,8 +592,8 @@ class AccountJournal(models.Model):
     def get_next_bank_cash_default_code(self, journal_type, company, cache=None):
         journal_code_base = (journal_type == 'cash' and 'CSH' or 'BNK')
         existing_codes = set(self.env['account.journal'].with_context(active_test=False).search([
+            *self.env['account.journal']._check_company_domain(company),
             ('code', 'like', journal_code_base + '%'),
-            ('company_id', '=', company.id),
         ]).mapped('code') + (cache or []))
         for num in range(1, 100):
             # journal_code has a maximal size of 5, hence we can enforce the boundary num < 100
@@ -634,7 +628,10 @@ class AccountJournal(models.Model):
         vals['company_id'] = company.id
 
         # Don't get the digits on 'chart_template' since the chart template could be a custom one.
-        random_account = self.env['account.account'].search([('company_id', '=', company.id)], limit=1)
+        random_account = self.env['account.account'].search(
+            self.env['account.account']._check_company_domain(company),
+            limit=1,
+        )
         digits = len(random_account.code) if random_account else 6
 
         if journal_type in ('bank', 'cash'):
@@ -729,7 +726,8 @@ class AccountJournal(models.Model):
             else:
                 raise UserError(_("The journal in which to upload the invoice is not specified. "))
             self = self.env['account.journal'].search([
-                ('company_id', '=', self.env.company.id), ('type', '=', journal_type)
+                *self.env['account.journal']._check_company_domain(self.env.company),
+                ('type', '=', journal_type),
             ], limit=1)
 
         attachments = self.env['ir.attachment'].browse(attachment_ids)

--- a/addons/account/models/account_journal_dashboard.py
+++ b/addons/account/models/account_journal_dashboard.py
@@ -78,8 +78,14 @@ class account_journal(models.Model):
               JOIN mail_activity activity ON activity.res_id = move.id AND activity.res_model = 'account.move'
          LEFT JOIN mail_activity_type act_type ON activity.activity_type_id = act_type.id
              WHERE move.journal_id = ANY(%(ids)s)
+               AND move.company_id = ANY(%(company_ids)s)
         """
-        self.env.cr.execute(sql_query, {'ids': self.ids, 'today': today, 'lang': lang})
+        self.env.cr.execute(sql_query, {
+            'ids': self.ids,
+            'company_ids': self.env.companies.ids,
+            'today': today,
+            'lang': lang,
+        })
         for activity in self.env.cr.dictfetchall():
             act = {
                 'id': activity['id'],
@@ -335,14 +341,15 @@ class account_journal(models.Model):
             SELECT journal.id, statement.id
               FROM account_journal journal
          LEFT JOIN LATERAL (
-                      SELECT id
+                      SELECT id, company_id
                         FROM account_bank_statement
                        WHERE journal_id = journal.id
                     ORDER BY first_line_index DESC
                        LIMIT 1
                    ) statement ON TRUE
              WHERE journal.id = ANY(%s)
-        """, [self.ids])
+               AND statement.company_id = ANY(%s)
+        """, [self.ids, self.env.companies.ids])
         last_statements = {journal_id: statement_id for journal_id, statement_id in self.env.cr.fetchall()}
         self.env['account.bank.statement'].browse(i for i in last_statements.values() if i).mapped('balance_end_real')  # prefetch
 
@@ -463,6 +470,7 @@ class account_journal(models.Model):
 
     def _get_open_bills_to_pay_query(self):
         return self.env['account.move']._where_calc([
+            *self.env['account.move']._check_company_domain(self.env.companies),
             ('journal_id', 'in', self.ids),
             ('state', '=', 'posted'),
             ('payment_state', 'in', ('not_paid', 'partial')),
@@ -471,6 +479,7 @@ class account_journal(models.Model):
 
     def _get_draft_bills_query(self):
         return self.env['account.move']._where_calc([
+            *self.env['account.move']._check_company_domain(self.env.companies),
             ('journal_id', 'in', self.ids),
             ('state', '=', 'draft'),
             ('payment_state', 'in', ('not_paid', 'partial')),
@@ -479,6 +488,7 @@ class account_journal(models.Model):
 
     def _get_late_bills_query(self):
         return self.env['account.move']._where_calc([
+            *self.env['account.move']._check_company_domain(self.env.companies),
             ('journal_id', 'in', self.ids),
             ('invoice_date_due', '<', fields.Date.context_today(self)),
             ('state', '=', 'posted'),

--- a/addons/account/models/account_move.py
+++ b/addons/account/models/account_move.py
@@ -329,7 +329,7 @@ class AccountMove(models.Model):
         comodel_name='res.partner',
         string='Delivery Address',
         compute='_compute_partner_shipping_id', store=True, readonly=False, precompute=True,
-        domain="['|', ('company_id', '=', False), ('company_id', '=', company_id)]",
+        check_company=True,
         help="The delivery address will be used in the computation of the fiscal position.",
     )
     partner_bank_id = fields.Many2one(
@@ -349,7 +349,6 @@ class AccountMove(models.Model):
         check_company=True,
         compute='_compute_fiscal_position_id', store=True, readonly=False, precompute=True,
         states={'posted': [('readonly', True)], 'cancel': [('readonly', True)]},
-        domain="[('company_id', '=', company_id)]",
         ondelete="restrict",
         help="Fiscal positions are used to adapt taxes and accounts for particular "
              "customers or sales orders/invoices. The default value comes from the customer.",
@@ -678,9 +677,8 @@ class AccountMove(models.Model):
     @api.depends('journal_id')
     def _compute_company_id(self):
         for move in self:
-            company_id = move.journal_id.company_id or self.env.company
-            if company_id != move.company_id:
-                move.company_id = company_id
+            if move.journal_id.company_id not in move.company_id.parent_ids:
+                move.company_id = (move.journal_id.company_id or self.env.company)._accessible_branches()[:1]
 
     @api.depends('move_type')
     def _compute_journal_id(self):
@@ -705,15 +703,18 @@ class AccountMove(models.Model):
             return self.statement_line_ids.statement_id.journal_id[:1]
 
         journal_types = self._get_valid_journal_types()
-        company_id = (self.company_id or self.env.company).id
-        domain = [('company_id', '=', company_id), ('type', 'in', journal_types)]
+        company = self.company_id or self.env.company
+        domain = [
+            *self.env['account.journal']._check_company_domain(company),
+            ('type', 'in', journal_types),
+        ]
 
         journal = None
         # the currency is not a hard dependence, it triggers via manual add_to_compute
         # avoid computing the currency before all it's dependences are set (like the journal...)
         if self.env.cache.contains(self, self._fields['currency_id']):
             currency_id = self.currency_id.id or self._context.get('default_currency_id')
-            if currency_id and currency_id != self.company_id.currency_id.id:
+            if currency_id and currency_id != company.currency_id.id:
                 currency_domain = domain + [('currency_id', '=', currency_id)]
                 journal = self.env['account.journal'].search(currency_domain, limit=1)
 
@@ -721,8 +722,6 @@ class AccountMove(models.Model):
             journal = self.env['account.journal'].search(domain, limit=1)
 
         if not journal:
-            company = self.env['res.company'].browse(company_id)
-
             error_msg = _(
                 "No journal could be found in company %(company_name)s for any of those types: %(journal_types)s",
                 company_name=company.display_name,
@@ -741,9 +740,11 @@ class AccountMove(models.Model):
     def _compute_suitable_journal_ids(self):
         for m in self:
             journal_type = m.invoice_filter_type_domain or 'general'
-            company_id = m.company_id.id or self.env.company.id
-            domain = [('company_id', '=', company_id), ('type', '=', journal_type)]
-            m.suitable_journal_ids = self.env['account.journal'].search(domain)
+            company = m.company_id or self.env.company
+            m.suitable_journal_ids = self.env['account.journal'].search([
+                *self.env['account.journal']._check_company_domain(company),
+                ('type', '=', journal_type),
+            ])
 
     @api.depends('posted_before', 'state', 'journal_id', 'date', 'move_type', 'payment_id')
     def _compute_name(self):
@@ -1176,7 +1177,7 @@ class AccountMove(models.Model):
 
             if move.state == 'posted' and move.is_invoice(include_receipts=True):
                 reconciled_vals = []
-                reconciled_partials = move._get_all_reconciled_invoice_partials()
+                reconciled_partials = move.sudo()._get_all_reconciled_invoice_partials()
                 for reconciled_partial in reconciled_partials:
                     counterpart_line = reconciled_partial['aml']
                     if counterpart_line.move_id.ref:
@@ -1654,7 +1655,7 @@ class AccountMove(models.Model):
     @api.onchange('company_id')
     def _inverse_company_id(self):
         self._conditional_add_to_compute('journal_id', lambda m: (
-            m.journal_id.company_id != m.company_id
+            not m.journal_id.filtered_domain(self.env['account.journal']._check_company_domain(m.company_id))
         ))
 
     @api.onchange('currency_id')
@@ -2621,9 +2622,9 @@ class AccountMove(models.Model):
                 domain += [('move_type', 'in' if self.move_type in refund_types else 'not in', refund_types)]
             if self.journal_id.payment_sequence:
                 domain += [('payment_id', '!=' if self.payment_id else '=', False)]
-            reference_move_name = self.search(domain + [('date', '<=', self.date)], order='date desc', limit=1).name
+            reference_move_name = self.sudo().search(domain + [('date', '<=', self.date)], order='date desc', limit=1).name
             if not reference_move_name:
-                reference_move_name = self.search(domain, order='date asc', limit=1).name
+                reference_move_name = self.sudo().search(domain, order='date asc', limit=1).name
             sequence_number_reset = self._deduce_sequence_number_reset(reference_move_name)
             if sequence_number_reset == 'year':
                 where_string += " AND date_trunc('year', date::timestamp without time zone) = date_trunc('year', %(date)s) "
@@ -2732,38 +2733,37 @@ class AccountMove(models.Model):
         """
         if not partner_id:
             return 0, False, False
-        where_internal_group = ""
+        domain = [
+            *self.env['account.move.line']._check_company_domain(company_id),
+            ('partner_id', '=', partner_id),
+            ('account_id.deprecated', '=', False),
+            ('date', '>=', date.today() - timedelta(days=365 * 2)),
+        ]
         if move_type in self.env['account.move'].get_inbound_types(include_receipts=True):
-            where_internal_group = "AND account.internal_group = 'income'"
+            domain.append(('account_id.internal_group', '=', 'income'))
         elif move_type in self.env['account.move'].get_outbound_types(include_receipts=True):
-            where_internal_group = "AND account.internal_group = 'expense'"
+            domain.append(('account_id.internal_group', '=', 'expense'))
+
+        query = self.env['account.move.line']._where_calc(domain)
+        from_clause, where_clause, params = query.get_sql()
         self._cr.execute(f"""
-            SELECT
-               COUNT(foo.id), foo.account_id, foo.taxes
-            FROM
-               (
-               SELECT
-                   account.id AS account_id,
-                   account.code,
-                   aml.id,
-                   ARRAY_AGG(tax_rel.account_tax_id) AS taxes
-               FROM account_account account
-                LEFT JOIN account_move_line aml
-                  ON (account.id = aml.account_id
-                   AND aml.partner_id = %s
-                   AND aml.date >= now() - interval '2 years')
-                LEFT JOIN account_move_line_account_tax_rel tax_rel ON (aml.id = tax_rel.account_move_line_id)
-               WHERE
-                   account.company_id = %s
-                   AND account.deprecated = FALSE
-                      {where_internal_group}
-               GROUP BY account.id, account.code, aml.id
-               ) AS foo
-            GROUP BY foo.account_id, foo.code, foo.taxes
-            ORDER BY COUNT(foo.id) DESC, foo.code
-            LIMIT 1
-        """, [partner_id, company_id])
-        return self._cr.fetchone()
+            SELECT COUNT(foo.id), foo.account_id, foo.taxes
+              FROM (
+                         SELECT account_move_line__account_id.id AS account_id,
+                                account_move_line__account_id.code,
+                                account_move_line.id,
+                                ARRAY_AGG(tax_rel.account_tax_id) AS taxes
+                           FROM {from_clause}
+                      LEFT JOIN account_move_line_account_tax_rel tax_rel ON account_move_line.id = tax_rel.account_move_line_id
+                          WHERE {where_clause}
+                       GROUP BY account_move_line__account_id.id,
+                                account_move_line.id
+                   ) AS foo
+          GROUP BY foo.account_id, foo.code, foo.taxes
+          ORDER BY COUNT(foo.id) DESC, foo.code
+             LIMIT 1
+        """, params)
+        return self._cr.fetchone() or (0, False, False)
 
     def _get_quick_edit_suggestions(self):
         """

--- a/addons/account/models/account_move_line.py
+++ b/addons/account/models/account_move_line.py
@@ -84,7 +84,7 @@ class AccountMoveLine(models.Model):
         index=True,
         auto_join=True,
         ondelete="cascade",
-        domain="[('deprecated', '=', False), ('company_id', '=', company_id), ('account_type', '!=', 'off_balance')]",
+        domain="[('deprecated', '=', False), ('account_type', '!=', 'off_balance')]",
         check_company=True,
         tracking=True,
     )
@@ -178,6 +178,7 @@ class AccountMoveLine(models.Model):
         comodel_name='account.tax',
         string="Originator Group of Taxes",
         index='btree_not_null',
+        check_company=True,
     )
     tax_line_id = fields.Many2one(
         comodel_name='account.tax',
@@ -295,6 +296,7 @@ class AccountMoveLine(models.Model):
         string='Product',
         inverse='_inverse_product_id',
         ondelete='restrict',
+        check_company=True,
     )
     product_uom_id = fields.Many2one(
         comodel_name='uom.uom',
@@ -850,17 +852,18 @@ class AccountMoveLine(models.Model):
     def _get_computed_taxes(self):
         self.ensure_one()
 
+        company_domain = self.env['account.tax']._check_company_domain(self.move_id.company_id)
         if self.move_id.is_sale_document(include_receipts=True):
             # Out invoice.
             if self.product_id.taxes_id:
-                tax_ids = self.product_id.taxes_id.filtered(lambda tax: tax.company_id == self.move_id.company_id)
+                tax_ids = self.product_id.taxes_id.filtered_domain(company_domain)
             else:
                 tax_ids = self.account_id.tax_ids.filtered(lambda tax: tax.type_tax_use == 'sale')
 
         elif self.move_id.is_purchase_document(include_receipts=True):
             # In invoice.
             if self.product_id.supplier_taxes_id:
-                tax_ids = self.product_id.supplier_taxes_id.filtered(lambda tax: tax.company_id == self.move_id.company_id)
+                tax_ids = self.product_id.supplier_taxes_id.filtered_domain(company_domain)
             else:
                 tax_ids = self.account_id.tax_ids.filtered(lambda tax: tax.type_tax_use == 'purchase')
 
@@ -868,7 +871,7 @@ class AccountMoveLine(models.Model):
             tax_ids = self.account_id.tax_ids
 
         if self.company_id and tax_ids:
-            tax_ids = tax_ids.filtered(lambda tax: tax.company_id == self.company_id)
+            tax_ids = tax_ids.filtered_domain(company_domain)
 
         if tax_ids and self.move_id.fiscal_position_id:
             tax_ids = self.move_id.fiscal_position_id.map_tax(tax_ids)
@@ -1192,10 +1195,10 @@ class AccountMoveLine(models.Model):
     def _check_tax_lock_date(self):
         for line in self.filtered(lambda l: l.move_id.state == 'posted'):
             move = line.move_id
-            if move.company_id.tax_lock_date and move.date <= move.company_id.tax_lock_date and line._affect_tax_report():
+            if move.company_id.max_tax_lock_date and move.date <= move.company_id.max_tax_lock_date and line._affect_tax_report():
                 raise UserError(_("The operation is refused as it would impact an already issued tax statement. "
                                   "Please change the journal entry date or the tax lock date set in the settings (%s) to proceed.")
-                                % format_date(self.env, move.company_id.tax_lock_date))
+                                % format_date(self.env, move.company_id.max_tax_lock_date))
 
     def _check_reconciliation(self):
         for line in self:
@@ -2026,7 +2029,7 @@ class AccountMoveLine(models.Model):
                 "Entries are not from the same account: %s",
                 ", ".join(accounts.mapped('display_name')),
             ))
-        if len(self.company_id) > 1:
+        if len(self.company_id.root_id) > 1:
             raise UserError(_(
                 "Entries don't belong to the same company: %s",
                 ", ".join(self.company_id.mapped('display_name')),
@@ -2417,7 +2420,10 @@ class AccountMoveLine(models.Model):
             * to_reconcile: A list of tuple <move_line, sequence> in order to perform the reconciliation after the move
                             creation.
         """
-        company = self.company_id or company
+        company = (
+            (self.move_id.filtered(lambda m: m.is_invoice(True)) or self.move_id).company_id
+            or company
+        )[:1]
         if not company:
             return
 

--- a/addons/account/models/account_partial_reconcile.py
+++ b/addons/account/models/account_partial_reconcile.py
@@ -54,7 +54,7 @@ class AccountPartialReconcile(models.Model):
     company_id = fields.Many2one(
         comodel_name='res.company',
         string="Company", store=True, readonly=False,
-        related='debit_move_id.company_id')
+        compute='_compute_company_id')
     max_date = fields.Date(
         string="Max Date of Matched Lines", store=True,
         compute='_compute_max_date')
@@ -82,6 +82,15 @@ class AccountPartialReconcile(models.Model):
                 partial.credit_move_id.date
             )
 
+    @api.depends('debit_move_id', 'credit_move_id')
+    def _compute_company_id(self):
+        for partial in self:
+            # Potential exchange diff and caba entries should be created on the invoice side if any
+            if partial.debit_move_id.move_id.is_invoice(True):
+                partial.company_id = partial.debit_move_id.company_id
+            else:
+                partial.company_id = partial.credit_move_id.company_id
+
     # -------------------------------------------------------------------------
     # LOW-LEVEL METHODS
     # -------------------------------------------------------------------------

--- a/addons/account/models/account_payment.py
+++ b/addons/account/models/account_payment.py
@@ -105,12 +105,12 @@ class AccountPayment(models.Model):
         string='Destination Account',
         store=True, readonly=False,
         compute='_compute_destination_account_id',
-        domain="[('account_type', 'in', ('asset_receivable', 'liability_payable')), ('company_id', '=', company_id)]",
+        domain="[('account_type', 'in', ('asset_receivable', 'liability_payable'))]",
         check_company=True)
     destination_journal_id = fields.Many2one(
         comodel_name='account.journal',
         string='Destination Journal',
-        domain="[('type', 'in', ('bank','cash')), ('company_id', '=', company_id), ('id', '!=', journal_id)]",
+        domain="[('type', 'in', ('bank','cash')), ('id', '!=', journal_id)]",
         check_company=True,
     )
 
@@ -458,7 +458,8 @@ class AccountPayment(models.Model):
         Get all journals having at least one payment method for inbound/outbound depending on the payment_type.
         """
         journals = self.env['account.journal'].search([
-            ('company_id', 'in', self.company_id.ids), ('type', 'in', ('bank', 'cash'))
+            *self.env['account.journal']._check_company_domain(self.company_id),
+            ('type', 'in', ('bank', 'cash')),
         ])
         for pay in self:
             if pay.payment_type == 'inbound':
@@ -514,7 +515,7 @@ class AccountPayment(models.Model):
                     pay.destination_account_id = pay.partner_id.with_company(pay.company_id).property_account_receivable_id
                 else:
                     pay.destination_account_id = self.env['account.account'].search([
-                        ('company_id', '=', pay.company_id.id),
+                        *self.env['account.account']._check_company_domain(pay.company_id),
                         ('account_type', '=', 'asset_receivable'),
                         ('deprecated', '=', False),
                     ], limit=1)
@@ -524,7 +525,7 @@ class AccountPayment(models.Model):
                     pay.destination_account_id = pay.partner_id.with_company(pay.company_id).property_account_payable_id
                 else:
                     pay.destination_account_id = self.env['account.account'].search([
-                        ('company_id', '=', pay.company_id.id),
+                        *self.env['account.account']._check_company_domain(pay.company_id),
                         ('account_type', '=', 'liability_payable'),
                         ('deprecated', '=', False),
                     ], limit=1)

--- a/addons/account/models/account_payment_method.py
+++ b/addons/account/models/account_payment_method.py
@@ -108,10 +108,13 @@ class AccountPaymentMethodLine(models.Model):
         copy=False,
         ondelete='restrict',
         domain="[('deprecated', '=', False), "
-                "('company_id', '=', company_id), "
                 "'|', ('account_type', 'in', ('asset_current', 'liability_current')), ('id', '=', parent.default_account_id)]"
     )
-    journal_id = fields.Many2one(comodel_name='account.journal', ondelete="cascade")
+    journal_id = fields.Many2one(
+        comodel_name='account.journal',
+        ondelete="cascade",
+        check_company=True,
+    )
 
     # == Display purpose fields ==
     code = fields.Char(related='payment_method_id.code')

--- a/addons/account/models/account_reconcile_model.py
+++ b/addons/account/models/account_reconcile_model.py
@@ -11,9 +11,11 @@ from dateutil.relativedelta import relativedelta
 class AccountReconcileModelPartnerMapping(models.Model):
     _name = 'account.reconcile.model.partner.mapping'
     _description = 'Partner mapping for reconciliation models'
+    _check_company_auto = True
 
     model_id = fields.Many2one(comodel_name='account.reconcile.model', readonly=True, required=True, ondelete='cascade')
-    partner_id = fields.Many2one(comodel_name='res.partner', string="Partner", required=True, ondelete='cascade')
+    company_id = fields.Many2one(related='model_id.company_id')
+    partner_id = fields.Many2one(comodel_name='res.partner', string="Partner", required=True, ondelete='cascade', check_company=True)
     payment_ref_regex = fields.Char(string="Find Text in Label")
     narration_regex = fields.Char(string="Find Text in Notes")
 
@@ -48,12 +50,12 @@ class AccountReconcileModelLine(models.Model):
     company_id = fields.Many2one(related='model_id.company_id', store=True)
     sequence = fields.Integer(required=True, default=10)
     account_id = fields.Many2one('account.account', string='Account', ondelete='cascade',
-        domain="[('deprecated', '=', False), ('company_id', '=', company_id), ('account_type', '!=', 'off_balance')]",
+        domain="[('deprecated', '=', False), ('account_type', '!=', 'off_balance')]",
         required=True, check_company=True)
 
     # This field is ignored in a bank statement reconciliation.
     journal_id = fields.Many2one('account.journal', string='Journal', ondelete='cascade',
-        domain="[('type', '=', 'general'), ('company_id', '=', company_id)]", check_company=True)
+        domain="[('type', '=', 'general')]", check_company=True)
     label = fields.Char(string='Journal Item Label')
     amount_type = fields.Selection([
         ('fixed', 'Fixed'),
@@ -169,7 +171,7 @@ class AccountReconcileModel(models.Model):
         tracking=True,
     )
     match_journal_ids = fields.Many2many('account.journal', string='Journals Availability',
-        domain="[('type', 'in', ('bank', 'cash')), ('company_id', '=', company_id)]",
+        domain="[('type', 'in', ('bank', 'cash'))]",
         check_company=True,
         help='The reconciliation model will only be available from the selected journals.')
     match_nature = fields.Selection(selection=[

--- a/addons/account/models/account_report.py
+++ b/addons/account/models/account_report.py
@@ -773,7 +773,7 @@ class AccountReportExternalValue(models.Model):
     foreign_vat_fiscal_position_id = fields.Many2one(
         string="Fiscal position",
         comodel_name='account.fiscal.position',
-        domain="[('company_id', '=', company_id), ('country_id', '=', report_country_id), ('foreign_vat', '!=', False)]",
+        domain="[('country_id', '=', report_country_id), ('foreign_vat', '!=', False)]",
         check_company=True,
         help="The foreign fiscal position for which this external value is made.",
     )

--- a/addons/account/models/account_tax.py
+++ b/addons/account/models/account_tax.py
@@ -4,7 +4,7 @@ from odoo.osv import expression
 from odoo.tools.float_utils import float_round
 from odoo.exceptions import UserError, ValidationError
 from odoo.tools.misc import formatLang
-from odoo.tools import frozendict
+from odoo.tools import frozendict, groupby
 
 from collections import defaultdict
 import math
@@ -22,6 +22,8 @@ class AccountTaxGroup(models.Model):
     _name = 'account.tax.group'
     _description = 'Tax Group'
     _order = 'sequence asc'
+    _check_company_auto = True
+    _check_company_domain = models.check_company_domain_parent_of
 
     name = fields.Char(required=True, translate=True)
     sequence = fields.Integer(default=10)
@@ -68,7 +70,7 @@ class AccountTaxGroup(models.Model):
                  of these countries, in this company
         """
         return bool(self.env['account.tax'].search([
-            ('company_id', '=', company.id),
+            *self.env['account.tax']._check_company_domain(company),
             ('country_id', 'in', countries.ids),
             '|',
             ('tax_group_id.tax_payable_account_id', '=', False),
@@ -82,6 +84,7 @@ class AccountTax(models.Model):
     _order = 'sequence,id'
     _check_company_auto = True
     _rec_names_search = ['name', 'description', 'invoice_label']
+    _check_company_domain = models.check_company_domain_parent_of
 
     name = fields.Char(string='Tax Name', required=True, translate=True)
     name_searchable = fields.Char(store=False, search='_search_name',
@@ -139,7 +142,7 @@ class AccountTax(models.Model):
         "Based on Payment: the tax is due as soon as the payment of the invoice is received.")
     cash_basis_transition_account_id = fields.Many2one(string="Cash Basis Transition Account",
         check_company=True,
-        domain="[('deprecated', '=', False), ('company_id', '=', company_id)]",
+        domain="[('deprecated', '=', False)]",
         comodel_name='account.account',
         help="Account used to transition the tax amount for cash basis taxes. It will contain the tax amount as long as the original invoice has not been reconciled ; at reconciliation, this amount cancelled on this account and put on the regular tax account.")
     invoice_repartition_line_ids = fields.One2many(
@@ -172,9 +175,23 @@ class AccountTax(models.Model):
     )
     country_code = fields.Char(related='country_id.code', readonly=True)
 
-    _sql_constraints = [
-        ('name_company_uniq', 'unique(name, company_id, type_tax_use, tax_scope)', 'Tax names must be unique!'),
-    ]
+    @api.constrains('company_id', 'name', 'type_tax_use', 'tax_scope')
+    def _constrains_name(self):
+        domains = []
+        for record in self:
+            if record.type_tax_use != 'none':
+                domains.append([
+                    ('company_id', 'child_of', record.company_id.root_id.id),
+                    ('name', '=', record.name),
+                    ('type_tax_use', '=', record.type_tax_use),
+                    ('tax_scope', '=', record.tax_scope),
+                    ('id', '!=', record.id),
+                ])
+        if duplicates := self.search(expression.OR(domains)):
+            raise ValidationError(
+                _("Tax names must be unique!")
+                + "\n" + "\n".join(f"- {duplicate.name} in {duplicate.company_id.name}" for duplicate in duplicates)
+            )
 
     @api.constrains('tax_group_id')
     def validate_tax_group_id(self):
@@ -199,10 +216,10 @@ class AccountTax(models.Model):
                 by_country_company[(tax.country_id, tax.company_id)] += tax
         for (country, company), taxes in by_country_company.items():
             taxes.tax_group_id = self.env['account.tax.group'].search([
-                ('company_id', '=', company.id),
+                *self.env['account.tax.group']._check_company_domain(company),
                 ('country_id', '=', country.id),
             ], limit=1) or self.env['account.tax.group'].search([
-                ('company_id', '=', company.id),
+                *self.env['account.tax.group']._check_company_domain(company),
                 ('country_id', '=', False),
             ], limit=1)
 
@@ -308,29 +325,14 @@ class AccountTax(models.Model):
 
     @api.constrains('company_id')
     def _check_company_consistency(self):
-        if not self:
-            return
-
-        self.env['account.move.line'].flush_model(['company_id', 'tax_line_id'])
-        self.flush_recordset(['company_id'])
-        self._cr.execute('''
-            SELECT line.id
-            FROM account_move_line line
-            JOIN account_tax tax ON tax.id = line.tax_line_id
-            WHERE line.tax_line_id IN %s
-            AND line.company_id != tax.company_id
-
-            UNION ALL
-
-            SELECT line.id
-            FROM account_move_line_account_tax_rel tax_rel
-            JOIN account_tax tax ON tax.id = tax_rel.account_tax_id
-            JOIN account_move_line line ON line.id = tax_rel.account_move_line_id
-            WHERE tax_rel.account_tax_id IN %s
-            AND line.company_id != tax.company_id
-        ''', [tuple(self.ids)] * 2)
-        if self._cr.fetchone():
-            raise UserError(_("You can't change the company of your tax since there are some journal items linked to it."))
+        for company, taxes in groupby(self, lambda tax: tax.company_id):
+            if self.env['account.move.line'].search([
+                '|',
+                ('tax_line_id', 'in', [tax.id for tax in taxes]),
+                ('tax_ids', 'in', [tax.id for tax in taxes]),
+                '!', ('company_id', 'child_of', company.id)
+            ], limit=1):
+                raise UserError(_("You can't change the company of your tax since there are some journal items linked to it."))
 
     def _sanitize_vals(self, vals):
         """Normalize the create/write values."""
@@ -522,7 +524,7 @@ class AccountTax(models.Model):
         if not self:
             company = self.env.company
         else:
-            company = self[0].company_id
+            company = self[0].company_id._accessible_branches()[:1]
 
         # 1) Flatten the taxes.
         taxes, groups_map = self.flatten_taxes_hierarchy(create_map=True)
@@ -1341,6 +1343,7 @@ class AccountTaxRepartitionLine(models.Model):
     _description = "Tax Repartition Line"
     _order = 'sequence, repartition_type, id'
     _check_company_auto = True
+    _check_company_domain = models.check_company_domain_parent_of
 
     factor_percent = fields.Float(
         string="%",
@@ -1353,7 +1356,7 @@ class AccountTaxRepartitionLine(models.Model):
     document_type = fields.Selection(string="Related to", selection=[('invoice', 'Invoice'), ('refund', 'Refund')], required=True)
     account_id = fields.Many2one(string="Account",
         comodel_name='account.account',
-        domain="[('deprecated', '=', False), ('company_id', '=', company_id), ('account_type', 'not in', ('asset_receivable', 'liability_payable'))]",
+        domain="[('deprecated', '=', False), ('account_type', 'not in', ('asset_receivable', 'liability_payable'))]",
         check_company=True,
         help="Account on which to post the tax amount")
     tag_ids = fields.Many2many(string="Tax Grids", comodel_name='account.account.tag', domain=[('applicability', '=', 'taxes')], copy=True, ondelete='restrict')

--- a/addons/account/models/chart_template.py
+++ b/addons/account/models/chart_template.py
@@ -174,10 +174,15 @@ class AccountChartTemplate(models.AbstractModel):
 
         if not reload_template:
             for model in ('account.move',) + TEMPLATE_MODELS[::-1]:
-                self.env[model].sudo().search([('company_id', '=', company.id)]).with_context({MODULE_UNINSTALL_FLAG: True}).unlink()
+                if not company.parent_id:
+                    self.env[model].sudo().search([('company_id', 'child_of', company.id)]).with_context({MODULE_UNINSTALL_FLAG: True}).unlink()
 
         data = self._get_chart_template_data(template_code)
         template_data = data.pop('template_data')
+        if company.parent_id:
+            data = {
+                'res.company': data['res.company'],
+            }
 
         if reload_template:
             self._pre_reload_data(company, template_data, data)
@@ -201,6 +206,8 @@ class AccountChartTemplate(models.AbstractModel):
             except Exception:
                 # Do not rollback installation of CoA if demo data failed
                 _logger.exception('Error while loading accounting demo data')
+        for subsidiary in company.child_ids:
+            self._load(template_code, subsidiary, install_demo)
 
     def _pre_reload_data(self, company, template_data, data):
         """Pre-process the data in case of reloading the chart of accounts.
@@ -221,15 +228,15 @@ class AccountChartTemplate(models.AbstractModel):
             else:
                 if 'code' in journal_data:
                     journal = self.env['account.journal'].with_context(active_test=False).search([
+                        *self.env['account.journal']._check_company_domain(company),
                         ('code', '=', journal_data['code']),
-                        ('company_id', '=', company.id),
                     ])
                 # Try to match by journal name to avoid conflict in the unique constraint on the mail alias
                 if not journal and 'name' in journal_data and 'type' in journal_data:
                     journal = self.env['account.journal'].with_context(active_test=False).search([
+                        *self.env['account.journal']._check_company_domain(company),
                         ('type', '=', journal_data['type']),
                         ('name', '=', journal_data['name']),
-                        ('company_id', '=', company.id),
                     ], limit=1)
                 if journal:
                     del data['account.journal'][xmlid]
@@ -239,11 +246,13 @@ class AccountChartTemplate(models.AbstractModel):
                         'noupdate': True,
                     }])
 
-        account_group_count = self.env['account.group'].search_count([('company_id', '=', company.id)])
+        account_group_count = self.env['account.group'].search_count([])
         if account_group_count:
             data.pop('account.group', None)
 
-        current_taxes = self.env['account.tax'].search([('company_id', '=', company.id)])
+        current_taxes = self.env['account.tax'].search([
+            *self.env['account.tax']._check_company_domain(company),
+        ])
         unique_tax_name_key = lambda t: (t.name, t.type_tax_use, t.tax_scope, t.company_id)
         unique_tax_name_keys = set(current_taxes.mapped(unique_tax_name_key))
         xmlid2tax = {
@@ -314,8 +323,8 @@ class AccountChartTemplate(models.AbstractModel):
                     account = self.ref(xmlid, raise_if_not_found=False)
                     if not account or (account and account.code != values['code']):
                         existing_account = self.env['account.account'].search([
+                            *self.env['account.account']._check_company_domain(company),
                             ('code', '=', values['code']),
-                            ('company_id', '=', company.id),
                         ])
                         if existing_account:
                             self.env['ir.model.data']._update_xmlids([{
@@ -525,12 +534,14 @@ class AccountChartTemplate(models.AbstractModel):
         # Set default Purchase and Sale taxes on the company
         if not company.account_sale_tax_id:
             company.account_sale_tax_id = self.env['account.tax'].search([
-                ('type_tax_use', 'in', ('sale', 'all')), ('company_id', '=', company.id)], limit=1).id
+                *self.env['account.tax']._check_company_domain(company),
+                ('type_tax_use', 'in', ('sale', 'all'))], limit=1).id
         if not company.account_purchase_tax_id:
             company.account_purchase_tax_id = self.env['account.tax'].search([
-                ('type_tax_use', 'in', ('purchase', 'all')), ('company_id', '=', company.id)], limit=1).id
+                *self.env['account.tax']._check_company_domain(company),
+                ('type_tax_use', 'in', ('purchase', 'all'))], limit=1).id
         # Display caba fields if there are caba taxes
-        if self.env['account.tax'].search([('tax_exigibility', '=', 'on_payment')]):
+        if not company.parent_id and self.env['account.tax'].search([('tax_exigibility', '=', 'on_payment')]):
             company.tax_exigibility = True
 
         for field, model in {
@@ -633,10 +644,13 @@ class AccountChartTemplate(models.AbstractModel):
         for fname in list(accounts_data):
             if company[fname]:
                 del accounts_data[fname]
-
-        accounts = self.env['account.account'].create(accounts_data.values())
-        for company_attr_name, account in zip(accounts_data.keys(), accounts):
-            company[company_attr_name] = account
+        if company.parent_id:
+            for company_attr_name in accounts_data:
+                company[company_attr_name] = company.parent_ids[0][company_attr_name]
+        else:
+            accounts = self.env['account.account'].create(accounts_data.values())
+            for company_attr_name, account in zip(accounts_data.keys(), accounts):
+                company[company_attr_name] = account
 
     @api.model
     def _instantiate_foreign_taxes(self, country, company):
@@ -655,8 +669,8 @@ class AccountChartTemplate(models.AbstractModel):
         # - Creates tax group and taxes with their ir.model.data
 
         taxes_in_country = self.env['account.tax'].search([
+            *self.env['account.tax']._check_company_domain(company),
             ('country_id', '=', country.id),
-            ('company_id', '=', company.id)
         ])
         if taxes_in_country:
             return
@@ -693,6 +707,7 @@ class AccountChartTemplate(models.AbstractModel):
                 if account_template_xml_id in existing_accounts:
                     continue
                 local_tax_group = self.env["account.tax.group"].search([
+                    *self.env['account.tax.group']._check_company_domain(company),
                     ('country_id', '=', company.account_fiscal_country_id.id),
                     (field, '!=', False),
                 ], limit=1)
@@ -710,7 +725,7 @@ class AccountChartTemplate(models.AbstractModel):
 
                     sign_comparator = '<' if float(foreign_tax_rep_line.get('factor_percent', 100)) < 0 else '>'
                     minimal_domain = [
-                        ('company_id', '=', company.id),
+                        *self.env['account.tax.repartition.line']._check_company_domain(company),
                         ('account_id', '!=', False),
                         ('factor_percent', sign_comparator, 0),
                     ]
@@ -735,6 +750,7 @@ class AccountChartTemplate(models.AbstractModel):
 
         # Try to create cash basis account if not mapped
         local_cash_basis_tax = self.env["account.tax"].search([
+            *self.env['account.tax']._check_company_domain(company),
             ('country_id', '=', company.account_fiscal_country_id.id),
             ('cash_basis_transition_account_id', '!=', False)
         ], limit=1)
@@ -900,7 +916,12 @@ class AccountChartTemplate(models.AbstractModel):
     # --------------------------------------------------------------------------------
 
     def ref(self, xmlid, raise_if_not_found=True):
-        return self.env.ref(f"account.{self.env.company.id}_{xmlid}" if xmlid and '.' not in xmlid else xmlid, raise_if_not_found)
+        if '.' in xmlid:
+            return self.env.ref(xmlid, raise_if_not_found)
+        return (
+            self.env.ref(f"account.{self.env.company.id}_{xmlid}", raise_if_not_found=False)
+            or self.env.ref(f"account.{self.env.company.parent_ids[0].id}_{xmlid}", raise_if_not_found)
+        )
 
     def _get_parent_template(self, code):
         parents = []

--- a/addons/account/models/company.py
+++ b/addons/account/models/company.py
@@ -47,22 +47,24 @@ class ResCompany(models.Model):
         string="Tax Return Lock Date",
         tracking=True,
         help="No users can edit journal entries related to a tax prior and inclusive of this date.")
+    max_tax_lock_date = fields.Date(compute='_compute_max_tax_lock_date', recursive=True)  # TODO maybe store
     transfer_account_id = fields.Many2one('account.account',
+        check_company=True,
         domain="[('reconcile', '=', True), ('account_type', '=', 'asset_current'), ('deprecated', '=', False)]", string="Inter-Banks Transfer Account", help="Intermediary account used when moving money from a liqity account to another")
     expects_chart_of_accounts = fields.Boolean(string='Expects a Chart of Accounts', default=True)
     chart_template = fields.Selection(selection='_chart_template_selection')
     bank_account_code_prefix = fields.Char(string='Prefix of the bank accounts')
     cash_account_code_prefix = fields.Char(string='Prefix of the cash accounts')
-    default_cash_difference_income_account_id = fields.Many2one('account.account', string="Cash Difference Income")
-    default_cash_difference_expense_account_id = fields.Many2one('account.account', string="Cash Difference Expense")
-    account_journal_suspense_account_id = fields.Many2one('account.account', string='Journal Suspense Account')
-    account_journal_payment_debit_account_id = fields.Many2one('account.account', string='Journal Outstanding Receipts')
-    account_journal_payment_credit_account_id = fields.Many2one('account.account', string='Journal Outstanding Payments')
-    account_journal_early_pay_discount_gain_account_id = fields.Many2one(comodel_name='account.account', string='Cash Discount Write-Off Gain Account')
-    account_journal_early_pay_discount_loss_account_id = fields.Many2one(comodel_name='account.account', string='Cash Discount Write-Off Loss Account')
+    default_cash_difference_income_account_id = fields.Many2one('account.account', string="Cash Difference Income", check_company=True)
+    default_cash_difference_expense_account_id = fields.Many2one('account.account', string="Cash Difference Expense", check_company=True)
+    account_journal_suspense_account_id = fields.Many2one('account.account', string='Journal Suspense Account', check_company=True)
+    account_journal_payment_debit_account_id = fields.Many2one('account.account', string='Journal Outstanding Receipts', check_company=True)
+    account_journal_payment_credit_account_id = fields.Many2one('account.account', string='Journal Outstanding Payments', check_company=True)
+    account_journal_early_pay_discount_gain_account_id = fields.Many2one(comodel_name='account.account', string='Cash Discount Write-Off Gain Account', check_company=True)
+    account_journal_early_pay_discount_loss_account_id = fields.Many2one(comodel_name='account.account', string='Cash Discount Write-Off Loss Account', check_company=True)
     transfer_account_code_prefix = fields.Char(string='Prefix of the transfer accounts')
-    account_sale_tax_id = fields.Many2one('account.tax', string="Default Sale Tax")
-    account_purchase_tax_id = fields.Many2one('account.tax', string="Default Purchase Tax")
+    account_sale_tax_id = fields.Many2one('account.tax', string="Default Sale Tax", check_company=True)
+    account_purchase_tax_id = fields.Many2one('account.tax', string="Default Purchase Tax", check_company=True)
     tax_calculation_rounding_method = fields.Selection([
         ('round_per_line', 'Round per Line'),
         ('round_globally', 'Round Globally'),
@@ -71,12 +73,14 @@ class ResCompany(models.Model):
     income_currency_exchange_account_id = fields.Many2one(
         comodel_name='account.account',
         string="Gain Exchange Rate Account",
-        domain="[('deprecated', '=', False), ('company_id', '=', id), \
+        check_company=True,
+        domain="[('deprecated', '=', False),\
                 ('account_type', 'in', ('income', 'income_other'))]")
     expense_currency_exchange_account_id = fields.Many2one(
         comodel_name='account.account',
         string="Loss Exchange Rate Account",
-        domain="[('deprecated', '=', False), ('company_id', '=', id), \
+        check_company=True,
+        domain="[('deprecated', '=', False), \
                 ('account_type', '=', 'expense')]")
     anglo_saxon_accounting = fields.Boolean(string="Use anglo-saxon accounting")
     bank_journal_ids = fields.One2many('account.journal', 'company_id', domain=[('type', '=', 'bank')], string='Bank Journals')
@@ -104,16 +108,23 @@ class ResCompany(models.Model):
                                      compute='_compute_invoice_terms_html', store=True, readonly=False)
 
     # Needed in the Point of Sale
-    account_default_pos_receivable_account_id = fields.Many2one('account.account', string="Default PoS Receivable Account")
+    account_default_pos_receivable_account_id = fields.Many2one('account.account', string="Default PoS Receivable Account", check_company=True)
 
     # Accrual Accounting
     expense_accrual_account_id = fields.Many2one('account.account',
         help="Account used to move the period of an expense",
-        domain="[('internal_group', '=', 'liability'), ('account_type', 'not in', ('asset_receivable', 'liability_payable')), ('company_id', '=', id)]")
+        check_company=True,
+        domain="[('internal_group', '=', 'liability'), ('account_type', 'not in', ('asset_receivable', 'liability_payable'))]")
     revenue_accrual_account_id = fields.Many2one('account.account',
         help="Account used to move the period of a revenue",
-        domain="[('internal_group', '=', 'asset'), ('account_type', 'not in', ('asset_receivable', 'liability_payable')), ('company_id', '=', id)]")
-    automatic_entry_default_journal_id = fields.Many2one('account.journal', help="Journal used by default for moving the period of an entry", domain="[('type', '=', 'general')]")
+        check_company=True,
+        domain="[('internal_group', '=', 'asset'), ('account_type', 'not in', ('asset_receivable', 'liability_payable'))]")
+    automatic_entry_default_journal_id = fields.Many2one(
+        'account.journal',
+        domain="[('type', '=', 'general')]",
+        check_company=True,
+        help="Journal used by default for moving the period of an entry",
+    )
 
     # Technical field to hide country specific fields in company form view
     country_code = fields.Char(related='country_id.code', depends=['country_id'])
@@ -138,9 +149,11 @@ class ResCompany(models.Model):
     tax_exigibility = fields.Boolean(string='Use Cash Basis')
     tax_cash_basis_journal_id = fields.Many2one(
         comodel_name='account.journal',
+        check_company=True,
         string="Cash Basis Journal")
     account_cash_basis_base_account_id = fields.Many2one(
         comodel_name='account.account',
+        check_company=True,
         domain=[('deprecated', '=', False)],
         string="Base Tax Received Account",
         help="Account that will be set on lines created in cash basis journal entry and used to keep track of the "
@@ -166,6 +179,14 @@ class ResCompany(models.Model):
             ('out_and_in_invoices', 'Customer Invoices and Vendor Bills')],
         string="Quick encoding")
 
+    def _get_company_root_delegated_field_names(self):
+        return super()._get_company_root_delegated_field_names() + [
+            'fiscalyear_last_day',
+            'fiscalyear_last_month',
+            'account_storno',
+            'tax_exigibility',
+        ]
+
     @api.constrains('account_opening_move_id', 'fiscalyear_last_day', 'fiscalyear_last_month')
     def _check_fiscalyear_last_day(self):
         # if the user explicitly chooses the 29th of February we allow it:
@@ -188,7 +209,10 @@ class ResCompany(models.Model):
         company_to_foreign_vat_country = {
             company.id: country_ids
             for company, country_ids in self.env['account.fiscal.position']._read_group(
-                domain=[('company_id', 'in', self.ids), ('foreign_vat', '!=', False)],
+                domain=[
+                    *self.env['account.fiscal.position']._check_company_domain(self),
+                    ('foreign_vat', '!=', False),
+                ],
                 groupby=['company_id'],
                 aggregates=['country_id:array_agg'],
             )
@@ -205,7 +229,14 @@ class ResCompany(models.Model):
     @api.depends('account_fiscal_country_id')
     def _compute_account_enabled_tax_country_ids(self):
         for record in self:
-            foreign_vat_fpos = self.env['account.fiscal.position'].search([('company_id', '=', record.id), ('foreign_vat', '!=', False)])
+            if record not in self.env.user.company_ids:
+                # can have access to the company form without having access to its content (see base.res_company_rule_erp_manager)
+                record.account_enabled_tax_country_ids = False
+                continue
+            foreign_vat_fpos = self.env['account.fiscal.position'].search([
+                *self.env['account.fiscal.position']._check_company_domain(record),
+                ('foreign_vat', '!=', False)
+            ])
             record.account_enabled_tax_country_ids = foreign_vat_fpos.country_id + record.account_fiscal_country_id
 
     @api.depends('terms_type')
@@ -217,6 +248,25 @@ class ResCompany(models.Model):
             if html:
                 company.invoice_terms_html = html
 
+    @api.depends('parent_id.max_tax_lock_date')
+    def _compute_max_tax_lock_date(self):
+        for company in self:
+            company.max_tax_lock_date = max(company.tax_lock_date or date.min, company.parent_id.max_tax_lock_date or date.min)
+
+    @api.model_create_multi
+    def create(self, vals_list):
+        companies = super().create(vals_list)
+        for company in companies:
+            if root_template := company.parent_ids[0].chart_template:
+                def try_loading(company=company):
+                    self.env['account.chart.template']._load(
+                        root_template,
+                        company,
+                        install_demo=False,
+                    )
+                self.env.cr.precommit.add(try_loading)
+        return companies
+
     def get_new_account_code(self, current_code, old_prefix, new_prefix):
         digits = len(current_code)
         return new_prefix + current_code.replace(old_prefix, '', 1).lstrip('0').rjust(digits-len(new_prefix), '0')
@@ -225,9 +275,9 @@ class ResCompany(models.Model):
         if not old_code:
             return
         accounts = self.env['account.account'].search([
+            *self.env['account.account']._check_company_domain(self),
             ('code', '=like', old_code + '%'),
             ('account_type', 'in', ('asset_cash', 'liability_credit_card')),
-            ('company_id', '=', self.id)
         ], order='code asc')
         for account in accounts:
             account.write({'code': self.get_new_account_code(account.code, old_code, new_code)})
@@ -262,7 +312,7 @@ class ResCompany(models.Model):
         if values.get('fiscalyear_lock_date'):
 
             draft_entries = self.env['account.move'].search([
-                ('company_id', 'in', self.ids),
+                ('company_id', 'child_of', self.ids),
                 ('state', '=', 'draft'),
                 ('date', '<=', values['fiscalyear_lock_date'])])
             if draft_entries:
@@ -279,7 +329,7 @@ class ResCompany(models.Model):
                 raise RedirectWarning(error_msg, action_error, _('Show unposted entries'))
 
             unreconciled_statement_lines = self.env['account.bank.statement.line'].search([
-                ('company_id', 'in', self.ids),
+                ('company_id', 'child_of', self.ids),
                 ('is_reconciled', '=', False),
                 ('date', '<=', values['fiscalyear_lock_date']),
                 ('move_id.state', 'in', ('draft', 'posted')),
@@ -292,12 +342,11 @@ class ResCompany(models.Model):
 
     def _get_user_fiscal_lock_date(self):
         """Get the fiscal lock date for this company depending on the user"""
-        if not self:
-            return date.min
-        self.ensure_one()
         lock_date = max(self.period_lock_date or date.min, self.fiscalyear_lock_date or date.min)
         if self.user_has_groups('account.group_account_manager'):
             lock_date = self.fiscalyear_lock_date or date.min
+        if self.parent_id:
+            lock_date = max(lock_date, self.parent_id._get_user_fiscal_lock_date())
         return lock_date
 
     def _get_violated_lock_dates(self, accounting_date, has_tax):
@@ -311,7 +360,7 @@ class ResCompany(models.Model):
         user_lock_date = self._get_user_fiscal_lock_date()
         if accounting_date and user_lock_date and accounting_date <= user_lock_date:
             locks.append((user_lock_date, _('user')))
-        tax_lock_date = self.tax_lock_date
+        tax_lock_date = self.max_tax_lock_date
         if accounting_date and tax_lock_date and has_tax and accounting_date <= tax_lock_date:
             locks.append((tax_lock_date, _('tax')))
         locks.sort()
@@ -359,7 +408,10 @@ class ResCompany(models.Model):
         """
         self.ensure_one()
         if not self.account_opening_move_id:
-            default_journal = self.env['account.journal'].search([('type', '=', 'general'), ('company_id', '=', self.id)], limit=1)
+            default_journal = self.env['account.journal'].search([
+                *self.env['account.journal']._check_company_domain(self),
+                ('type', '=', 'general')
+            ], limit=1)
 
             if not default_journal:
                 raise UserError(_("Please install a chart of accounts or create a miscellaneous journal before proceeding."))
@@ -382,14 +434,19 @@ class ResCompany(models.Model):
         if none has yet been defined.
         """
         unaffected_earnings_type = "equity_unaffected"
-        account = self.env['account.account'].search([('company_id', '=', self.id),
-                                                      ('account_type', '=', unaffected_earnings_type)])
+        account = self.env['account.account'].search([
+            *self.env['account.account']._check_company_domain(self),
+            ('account_type', '=', unaffected_earnings_type),
+        ])
         if account:
             return account[0]
         # Do not assume '999999' doesn't exist since the user might have created such an account
         # manually.
         code = 999999
-        while self.env['account.account'].search([('code', '=', str(code)), ('company_id', '=', self.id)]):
+        while self.env['account.account'].search([
+            *self.env['account.account']._check_company_domain(self),
+            ('code', '=', str(code)),
+        ]):
             code -= 1
         return self.env['account.account'].create({
                 'code': str(code),
@@ -454,7 +511,7 @@ class ResCompany(models.Model):
         self.env['onboarding.onboarding.step'].action_validate_step('account.onboarding_onboarding_step_sales_tax')
 
     def get_chart_of_accounts_or_fail(self):
-        account = self.env['account.account'].search([('company_id', '=', self.id)], limit=1)
+        account = self.env['account.account'].search(self.env['account.account']._check_company_domain(self), limit=1)
         if len(account) == 0:
             action = self.env.ref('account.action_account_config')
             msg = _(
@@ -466,7 +523,7 @@ class ResCompany(models.Model):
     def _existing_accounting(self) -> bool:
         """Return True iff some accounting entries have already been made for the current company."""
         self.ensure_one()
-        return bool(self.env['account.move.line'].search([('company_id', '=', self.id)], order="id", limit=1))
+        return bool(self.env['account.move.line'].search([('company_id', 'child_of', self.root_id.id)], limit=1))
 
     def _chart_template_selection(self):
         return self.env['account.chart.template']._select_chart_template(self.country_id)
@@ -485,7 +542,7 @@ class ResCompany(models.Model):
         def build_move_info(move):
             return(move.name, move.inalterable_hash, fields.Date.to_string(move.date))
 
-        journals = self.env['account.journal'].search([('company_id', '=', self.id)])
+        journals = self.env['account.journal'].search(self.env['account.journal']._check_company_domain(self))
         results_by_journal = {
             'results': [],
             'printing_date': format_date(self.env, fields.Date.to_string(fields.Date.context_today(self)))

--- a/addons/account/models/ir_module.py
+++ b/addons/account/models/ir_module.py
@@ -63,7 +63,12 @@ class IrModule(models.Model):
         res = super().write(vals)
         is_installed = len(self) == 1 and self.state == 'installed'
         if not was_installed and is_installed and not self.env.company.chart_template and self.account_templates:
-            self.env.registry._auto_install_template = next(iter(self.account_templates))
+            def try_loading(env):
+                env['account.chart.template'].try_loading(
+                    next(iter(self.account_templates)),
+                    env.company,
+                )
+            self.env.registry._auto_install_template = try_loading
         return res
 
     def _load_module_terms(self, modules, langs, overwrite=False):
@@ -82,10 +87,7 @@ class IrModule(models.Model):
             self.env.registry._delayed_account_translator(self.env)
             del self.env.registry._delayed_account_translator
         if hasattr(self.env.registry, '_auto_install_template'):
-            self.env['account.chart.template'].try_loading(
-                self.env.registry._auto_install_template,
-                self.env.company,
-            )
+            self.env.registry._auto_install_template(self.env)
             del self.env.registry._auto_install_template
 
     def module_uninstall(self):

--- a/addons/account/models/onboarding_onboarding_step.py
+++ b/addons/account/models/onboarding_onboarding_step.py
@@ -105,7 +105,10 @@ class OnboardingStep(models.Model):
         # Then, we open will open a custom tree view allowing to edit opening balances of the account
         view_id = self.env.ref('account.init_accounts_tree').id
         # Hide the current year earnings account as it is automatically computed
-        domain = [('account_type', '!=', 'equity_unaffected'), ('company_id', '=', company.id)]
+        domain = [
+            *self.env['account.account']._check_company_domain(company),
+            ('account_type', '!=', 'equity_unaffected'),
+        ]
         return {
             'type': 'ir.actions.act_window',
             'name': _('Chart of Accounts'),

--- a/addons/account/models/partner.py
+++ b/addons/account/models/partner.py
@@ -19,6 +19,8 @@ class AccountFiscalPosition(models.Model):
     _name = 'account.fiscal.position'
     _description = 'Fiscal Position'
     _order = 'sequence'
+    _check_company_auto = True
+    _check_company_domain = models.check_company_domain_parent_of
 
     sequence = fields.Integer()
     name = fields.Char(string='Fiscal Position', required=True, translate=True)
@@ -92,9 +94,9 @@ class AccountFiscalPosition(models.Model):
                             raise ValidationError(_("You cannot create a fiscal position with a foreign VAT within your fiscal country."))
 
                 similar_fpos_domain = [
+                    *self.env['account.fiscal.position']._check_company_domain(record.company_id),
                     ('foreign_vat', '!=', False),
                     ('country_id', '=', record.country_id.id),
-                    ('company_id', '=', record.company_id.id),
                     ('id', '!=', record.id),
                 ]
                 if record.state_ids:
@@ -174,9 +176,9 @@ class AccountFiscalPosition(models.Model):
         if not country_id:
             return False
         base_domain = [
+            *self._check_company_domain(self.env.company),
             ('auto_apply', '=', True),
             ('vat_required', '=', vat_required),
-            ('company_id', 'in', [self.env.company.id, False]),
         ]
         null_state_dom = state_domain = [('state_ids', '=', False)]
         null_zip_dom = zip_domain = [('zip_from', '=', False), ('zip_to', '=', False)]
@@ -263,6 +265,7 @@ class AccountFiscalPositionTax(models.Model):
     _description = 'Tax Mapping of Fiscal Position'
     _rec_name = 'position_id'
     _check_company_auto = True
+    _check_company_domain = models.check_company_domain_parent_of
 
     position_id = fields.Many2one('account.fiscal.position', string='Fiscal Position',
         required=True, ondelete='cascade')
@@ -282,16 +285,17 @@ class AccountFiscalPositionAccount(models.Model):
     _description = 'Accounts Mapping of Fiscal Position'
     _rec_name = 'position_id'
     _check_company_auto = True
+    _check_company_domain = models.check_company_domain_parent_of
 
     position_id = fields.Many2one('account.fiscal.position', string='Fiscal Position',
         required=True, ondelete='cascade')
     company_id = fields.Many2one('res.company', string='Company', related='position_id.company_id', store=True)
     account_src_id = fields.Many2one('account.account', string='Account on Product',
         check_company=True, required=True,
-        domain="[('deprecated', '=', False), ('company_id', '=', company_id)]")
+        domain="[('deprecated', '=', False)]")
     account_dest_id = fields.Many2one('account.account', string='Account to Use Instead',
         check_company=True, required=True,
-        domain="[('deprecated', '=', False), ('company_id', '=', company_id)]")
+        domain="[('deprecated', '=', False)]")
 
     _sql_constraints = [
         ('account_src_dest_uniq',
@@ -326,7 +330,7 @@ class ResPartner(models.Model):
     def _credit_debit_get(self):
         tables, where_clause, where_params = self.env['account.move.line']._where_calc([
             ('parent_state', '=', 'posted'),
-            ('company_id', '=', self.env.company.id)
+            ('company_id', 'child_of', self.env.company.root_id.id)
         ]).get_sql()
 
         where_params = [tuple(self.ids)] + where_params
@@ -371,17 +375,21 @@ class ResPartner(models.Model):
         sign = 1
         if account_type == 'liability_payable':
             sign = -1
-        res = self._cr.execute('''
-            SELECT partner.id
-            FROM res_partner partner
-            LEFT JOIN account_move_line aml ON aml.partner_id = partner.id
-            JOIN account_move move ON move.id = aml.move_id
-            RIGHT JOIN account_account acc ON aml.account_id = acc.id
-            WHERE acc.account_type = %s
-              AND NOT acc.deprecated AND acc.company_id = %s
-              AND move.state = 'posted'
-            GROUP BY partner.id
-            HAVING %s * COALESCE(SUM(aml.amount_residual), 0) ''' + operator + ''' %s''', (account_type, self.env.company.id, sign, operand))
+        res = self._cr.execute(f'''
+            SELECT aml.partner_id
+              FROM res_partner partner
+         LEFT JOIN account_move_line aml ON aml.partner_id = partner.id
+              JOIN account_move move ON move.id = aml.move_id
+              JOIN res_company line_company ON line_company.id = line.company_id
+        RIGHT JOIN account_account acc ON aml.account_id = acc.id
+             WHERE acc.account_type = %s
+               AND NOT acc.deprecated
+               AND SPLIT_PART(line_company.parent_path, '/', 1):int == %s
+               AND move.state = 'posted'
+          GROUP BY aml.partner_id
+            HAVING %s * COALESCE(SUM(aml.amount_residual), 0) {operator} %s''',
+            (account_type, self.env.company.root_id.id, sign, operand)
+        )
         res = self._cr.fetchall()
         if not res:
             return [('id', '=', '0')]
@@ -521,25 +529,22 @@ class ResPartner(models.Model):
     journal_item_count = fields.Integer(compute='_compute_journal_item_count', string="Journal Items")
     property_account_payable_id = fields.Many2one('account.account', company_dependent=True,
         string="Account Payable",
-        domain="[('account_type', '=', 'liability_payable'), ('deprecated', '=', False), ('company_id', '=', current_company_id)]",
+        domain="[('account_type', '=', 'liability_payable'), ('deprecated', '=', False)]",
         help="This account will be used instead of the default one as the payable account for the current partner",
         required=True)
     property_account_receivable_id = fields.Many2one('account.account', company_dependent=True,
         string="Account Receivable",
-        domain="[('account_type', '=', 'asset_receivable'), ('deprecated', '=', False), ('company_id', '=', current_company_id)]",
+        domain="[('account_type', '=', 'asset_receivable'), ('deprecated', '=', False)]",
         help="This account will be used instead of the default one as the receivable account for the current partner",
         required=True)
     property_account_position_id = fields.Many2one('account.fiscal.position', company_dependent=True,
         string="Fiscal Position",
-        domain="[('company_id', '=', current_company_id)]",
         help="The fiscal position determines the taxes/accounts used for this contact.")
     property_payment_term_id = fields.Many2one('account.payment.term', company_dependent=True,
         string='Customer Payment Terms',
-        domain="[('company_id', 'in', [current_company_id, False])]",
         help="This payment term will be used instead of the default one for sales orders and customer invoices")
     property_supplier_payment_term_id = fields.Many2one('account.payment.term', company_dependent=True,
         string='Vendor Payment Terms',
-        domain="[('company_id', 'in', [current_company_id, False])]",
         help="This payment term will be used instead of the default one for purchase orders and vendor bills")
     ref_company_ids = fields.One2many('res.company', 'partner_id',
         string='Companies that refers to partner')
@@ -849,8 +854,9 @@ class ResPartner(models.Model):
                 return None
             return self.env['res.partner'].search(domain + extra_domain, limit=1)
 
+        company = company or self.env.company
         for search_method in (search_with_vat, search_with_domain, search_with_phone_mail, search_with_name):
-            for extra_domain in ([('company_id', '=', (company or self.env.company).id)], []):
+            for extra_domain in (self.env['res.partner']._check_company_domain(company), []):
                 partner = search_method(extra_domain)
                 if partner:
                     return partner

--- a/addons/account/models/product.py
+++ b/addons/account/models/product.py
@@ -26,10 +26,14 @@ class ProductTemplate(models.Model):
     _inherit = "product.template"
 
     taxes_id = fields.Many2many('account.tax', 'product_taxes_rel', 'prod_id', 'tax_id', help="Default taxes used when selling the product.", string='Customer Taxes',
-        domain=[('type_tax_use', '=', 'sale')], default=lambda self: self.env.company.account_sale_tax_id)
+        domain=[('type_tax_use', '=', 'sale')],
+        default=lambda self: self.env.company.account_sale_tax_id or self.env.company.root_id.account_sale_tax_id,
+    )
     tax_string = fields.Char(compute='_compute_tax_string')
     supplier_taxes_id = fields.Many2many('account.tax', 'product_supplier_taxes_rel', 'prod_id', 'tax_id', string='Vendor Taxes', help='Default taxes used when buying the product.',
-        domain=[('type_tax_use', '=', 'purchase')], default=lambda self: self.env.company.account_purchase_tax_id)
+        domain=[('type_tax_use', '=', 'purchase')],
+        default=lambda self: self.env.company.account_purchase_tax_id or self.env.company.root_id.account_purchase_tax_id,
+    )
     property_account_income_id = fields.Many2one('account.account', company_dependent=True,
         string="Income Account",
         domain=ACCOUNT_DOMAIN,
@@ -229,6 +233,6 @@ class ProductProduct(models.Model):
 
         domain = expression.AND([
             expression.OR(domains),
-            [('company_id', 'in', [False, company or self.env.company.id])],
+            self.env['product.product']._check_company_domain(company),
         ])
         return self.env['product.product'].search(domain, limit=1)

--- a/addons/account/models/res_config_settings.py
+++ b/addons/account/models/res_config_settings.py
@@ -14,26 +14,39 @@ class ResConfigSettings(models.TransientModel):
         comodel_name='account.journal',
         related='company_id.currency_exchange_journal_id', readonly=False,
         string="Currency Exchange Journal",
-        domain="[('company_id', '=', company_id), ('type', '=', 'general')]",
+        check_company=True,
+        domain="[('type', '=', 'general')]",
         help='The accounting journal where automatic exchange differences will be registered')
     income_currency_exchange_account_id = fields.Many2one(
         comodel_name="account.account",
         related="company_id.income_currency_exchange_account_id",
         string="Gain Exchange Rate Account",
         readonly=False,
-        domain="[('deprecated', '=', False), ('company_id', '=', company_id),\
-                ('account_type', 'in', ('income', 'income_other'))]")
+        check_company=True,
+        domain="[('deprecated', '=', False), ('account_type', 'in', ('income', 'income_other'))]")
     expense_currency_exchange_account_id = fields.Many2one(
         comodel_name="account.account",
         related="company_id.expense_currency_exchange_account_id",
         string="Loss Exchange Rate Account",
         readonly=False,
-        domain="[('deprecated', '=', False), ('company_id', '=', company_id),\
-                ('account_type', '=', 'expense')]")
+        check_company=True,
+        domain="[('deprecated', '=', False), ('account_type', '=', 'expense')]")
     has_chart_of_accounts = fields.Boolean(compute='_compute_has_chart_of_accounts', string='Company has a chart of accounts')
     chart_template = fields.Selection(selection=lambda self: self.env.company._chart_template_selection(), default=lambda self: self.env.company.chart_template)
-    sale_tax_id = fields.Many2one('account.tax', string="Default Sale Tax", related='company_id.account_sale_tax_id', readonly=False)
-    purchase_tax_id = fields.Many2one('account.tax', string="Default Purchase Tax", related='company_id.account_purchase_tax_id', readonly=False)
+    sale_tax_id = fields.Many2one(
+        'account.tax',
+        string="Default Sale Tax",
+        related='company_id.account_sale_tax_id',
+        readonly=False,
+        check_company=True,
+    )
+    purchase_tax_id = fields.Many2one(
+        'account.tax',
+        string="Default Purchase Tax",
+        related='company_id.account_purchase_tax_id',
+        readonly=False,
+        check_company=True,
+    )
     tax_calculation_rounding_method = fields.Selection(
         related='company_id.tax_calculation_rounding_method', string='Tax calculation rounding method', readonly=False)
     account_journal_suspense_account_id = fields.Many2one(
@@ -41,7 +54,8 @@ class ResConfigSettings(models.TransientModel):
         string='Bank Suspense',
         readonly=False,
         related='company_id.account_journal_suspense_account_id',
-        domain="[('deprecated', '=', False), ('company_id', '=', company_id), ('account_type', 'in', ('asset_current', 'liability_current'))]",
+        check_company=True,
+        domain="[('deprecated', '=', False), ('account_type', 'in', ('asset_current', 'liability_current'))]",
         help='Bank Transactions are posted immediately after import or synchronization. '
              'Their counterparty is the bank suspense account.\n'
              'Reconciliation replaces the latter by the definitive account(s).')
@@ -49,8 +63,9 @@ class ResConfigSettings(models.TransientModel):
         comodel_name='account.account',
         string='Outstanding Receipts',
         readonly=False,
+        check_company=True,
         related='company_id.account_journal_payment_debit_account_id',
-        domain="[('deprecated', '=', False), ('company_id', '=', company_id), ('account_type', '=', 'asset_current')]",
+        domain="[('deprecated', '=', False), ('account_type', '=', 'asset_current')]",
         help='Incoming payments are posted on an Outstanding Receipts Account. '
              'In the bank reconciliation widget, they appear as blue lines.\n'
              'Bank transactions are then reconciled on the Outstanding Receipts Accounts rather than the Receivable '
@@ -59,13 +74,15 @@ class ResConfigSettings(models.TransientModel):
         comodel_name='account.account',
         string='Outstanding Payments',
         readonly=False,
+        check_company=True,
         related='company_id.account_journal_payment_credit_account_id',
-        domain="[('deprecated', '=', False), ('company_id', '=', company_id), ('account_type', '=', 'asset_current')]",
+        domain="[('deprecated', '=', False), ('account_type', '=', 'asset_current')]",
         help='Outgoing Payments are posted on an Outstanding Payments Account. '
              'In the bank reconciliation widget, they appear as blue lines.\n'
              'Bank transactions are then reconciled on the Outstanding Payments Account rather the Payable Account.')
     transfer_account_id = fields.Many2one('account.account', string="Internal Transfer",
         related='company_id.transfer_account_id', readonly=False,
+        check_company=True,
         domain=[
             ('reconcile', '=', True),
             ('account_type', '=', 'asset_current'),
@@ -100,11 +117,18 @@ class ResConfigSettings(models.TransientModel):
     module_account_invoice_extract = fields.Boolean(string="Document Digitization")
     module_snailmail_account = fields.Boolean(string="Snailmail")
     tax_exigibility = fields.Boolean(string='Cash Basis', related='company_id.tax_exigibility', readonly=False)
-    tax_cash_basis_journal_id = fields.Many2one('account.journal', related='company_id.tax_cash_basis_journal_id', string="Tax Cash Basis Journal", readonly=False)
+    tax_cash_basis_journal_id = fields.Many2one(
+        'account.journal',
+        string="Tax Cash Basis Journal",
+        related='company_id.tax_cash_basis_journal_id',
+        readonly=False,
+        check_company=True,
+    )
     account_cash_basis_base_account_id = fields.Many2one(
         comodel_name='account.account',
         string="Base Tax Received Account",
         readonly=False,
+        check_company=True,
         related='company_id.account_cash_basis_base_account_id',
         domain=[('deprecated', '=', False)])
     account_fiscal_country_id = fields.Many2one(string="Fiscal Country Code", related="company_id.account_fiscal_country_id", readonly=False, store=False)
@@ -154,15 +178,17 @@ class ResConfigSettings(models.TransientModel):
         help='Account for the difference amount after the expense discount has been granted',
         readonly=False,
         related='company_id.account_journal_early_pay_discount_loss_account_id',
-        domain="[('deprecated', '=', False), ('company_id', '=', company_id), ('account_type', 'in', ('expense', 'income', 'income_other'))]",
+        check_company=True,
+        domain="[('deprecated', '=', False), ('account_type', 'in', ('expense', 'income', 'income_other'))]",
     )
     account_journal_early_pay_discount_gain_account_id = fields.Many2one(
         comodel_name='account.account',
         string='Cash Discount Gain',
         help='Account for the difference amount after the income discount has been granted',
         readonly=False,
+        check_company=True,
         related='company_id.account_journal_early_pay_discount_gain_account_id',
-        domain="[('deprecated', '=', False), ('company_id', '=', company_id), ('account_type', 'in', ('income', 'income_other', 'expense'))]",
+        domain="[('deprecated', '=', False), ('account_type', 'in', ('income', 'income_other', 'expense'))]",
     )
 
     def set_values(self):
@@ -208,7 +234,8 @@ class ResConfigSettings(models.TransientModel):
     def _onchange_tax_exigibility(self):
         res = {}
         tax = self.env['account.tax'].search([
-            ('company_id', '=', self.env.company.id), ('tax_exigibility', '=', 'on_payment')
+            *self.env['account.tax']._check_company_domain(self.env.company),
+            ('tax_exigibility', '=', 'on_payment'),
         ], limit=1)
         if not self.tax_exigibility and tax:
             self.tax_exigibility = True

--- a/addons/account/models/res_partner_bank.py
+++ b/addons/account/models/res_partner_bank.py
@@ -16,6 +16,7 @@ class ResPartnerBank(models.Model):
 
     journal_id = fields.One2many(
         'account.journal', 'bank_account_id', domain=[('type', '=', 'bank')], string='Account Journal', readonly=True,
+        check_company=True,
         help="The accounting journal corresponding to this bank account.")
     has_iban_warning = fields.Boolean(
         compute='_compute_display_account_warning',

--- a/addons/account/models/template_generic_coa.py
+++ b/addons/account/models/template_generic_coa.py
@@ -12,8 +12,6 @@ class AccountChartTemplate(models.AbstractModel):
 
         :return: all the values that are not stored but are used to instancieate
                  the chart of accounts. Common keys are:
-                 * anglo_saxon_accounting
-                 * transfer_account_code_prefix
                  * property_*
                  * code_digits
         :rtype: dict
@@ -21,9 +19,6 @@ class AccountChartTemplate(models.AbstractModel):
         return {
             'name': "Generic Chart Template",
             'country': None,
-            'anglo_saxon_accounting': True,
-            'transfer_account_code_prefix': '1017',
-            'default_pos_receivable_account_id': 'pos_receivable',
             'property_account_receivable_id': 'receivable',
             'property_account_payable_id': 'payable',
             'property_account_expense_id': 'expense',
@@ -46,9 +41,11 @@ class AccountChartTemplate(models.AbstractModel):
         """
         return {
             self.env.company.id: {
+                'anglo_saxon_accounting': True,
                 'account_fiscal_country_id': 'base.us',
                 'bank_account_code_prefix': '1014',
                 'cash_account_code_prefix': '1015',
+                'transfer_account_code_prefix': '1017',
                 'account_default_pos_receivable_account_id': 'pos_receivable',
                 'income_currency_exchange_account_id': 'income_currency_exchange',
                 'expense_currency_exchange_account_id': 'expense_currency_exchange',
