PR: https://github.com/odoo/odoo/pull/75496

From: 80d74e7ee0eab83dc5100e0776df09d04b882fec
From: Louis Wicket (wil)
Date: 2021-09-02 00:43:34

Structural Changes: 4
Total Changes: 225

[IMP] mail, web, *: add support for guest users

* = crm_livechat, hr, hr_holidays, im_livechat, mail_bot, purchase, sms,
    snailmail, survey, test_discuss_full, test_mail, web_editor, website,
    website_livechat

 - Create new model `mail.guest` for guests.
 - Rewrite some RPCs to target routes rather than model methods so that
   guests are able to use them.
 - Patch JS and python models to support guests.
 - Create a stand-alone page and boot the channel in it.

task-2494829

closes odoo/odoo#75496

Related: odoo/enterprise#20417
Signed-off-by: SÃ©bastien Theys (seb) <seb@odoo.com>

================================= pseudo patch: =================================

--- a/addons/mail/models/__init__.py
+++ b/addons/mail/models/__init__.py
@@ -29,6 +29,7 @@ from . import mail_template
 # discuss
 from . import mail_channel_partner
 from . import mail_channel
+from . import mail_guest
 from . import mail_shortcode
 from . import res_users_settings
 

--- a/addons/mail/models/ir_http.py
+++ b/addons/mail/models/ir_http.py
@@ -1,7 +1,9 @@
 # -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
+import odoo
 from odoo import models
+from odoo.addons.web.controllers.main import HomeStaticTemplateHelpers
 from odoo.http import request
 
 
@@ -13,4 +15,17 @@ class IrHttp(models.AbstractModel):
         result = super(IrHttp, self).session_info()
         if self.env.user.has_group('base.group_user'):
             result['notification_type'] = user.notification_type
+        assets_discuss_public_hash = HomeStaticTemplateHelpers.get_qweb_templates_checksum(debug=request.session.debug, bundle='mail.assets_discuss_public')
+        result['cache_hashes']['assets_discuss_public'] = assets_discuss_public_hash
+        guest = self.env.context.get('guest')
+        if guest:
+            user_context = {'lang': guest.lang}
+            mods = odoo.conf.server_wide_modules or []
+            lang = user_context.get("lang")
+            translation_hash = request.env['ir.translation'].sudo().get_web_translations_hash(mods, lang)
+            result['cache_hashes']['translations'] = translation_hash
+            result.update({
+                'name': guest.name,
+                'user_context': user_context,
+            })
         return result

--- a/addons/mail/models/mail_channel.py
+++ b/addons/mail/models/mail_channel.py
@@ -4,7 +4,7 @@
 import base64
 import logging
 from hashlib import sha512
-from uuid import uuid4
+from secrets import choice
 
 from odoo import _, api, fields, models, tools, Command
 from odoo.addons.base.models.avatar_mixin import get_hsl_from_seed
@@ -42,6 +42,12 @@ class Channel(models.Model):
             res['alias_contact'] = 'everyone' if res.get('public', 'private') == 'public' else 'followers'
         return res
 
+    @api.model
+    def _generate_random_token(self):
+        # Built to be shared on invitation link. It uses non-ambiguous characters and it is of a
+        # reasonable length: enough to avoid brute force, but short enough to be shareable easily.
+        return ''.join(choice('abcdefghijkmnopqrstuvwxyzABCDEFGHIJKLMNPQRSTUVWXYZ23456789') for _i in range(10))
+
     # description
     name = fields.Char('Name', required=True, translate=True)
     active = fields.Boolean(default=True, help="Set active to false to hide the channel without removing it.")
@@ -63,13 +69,14 @@ class Channel(models.Model):
         'mail.channel.partner', 'channel_id', string='Last Seen',
         groups='base.group_user')
     is_member = fields.Boolean('Is Member', compute='_compute_is_member', compute_sudo=True)
+    member_count = fields.Integer(string="Member Count", compute='_compute_member_count', help="Excluding guests from count.")
     group_ids = fields.Many2many(
         'res.groups', string='Auto Subscription',
         help="Members of those groups will automatically added as followers. "
              "Note that they will be able to manage their subscription manually "
              "if necessary.")
     # access
-    uuid = fields.Char('UUID', size=50, index=True, default=lambda self: str(uuid4()), copy=False)
+    uuid = fields.Char('UUID', size=50, index=True, default=_generate_random_token, copy=False)
     public = fields.Selection([
         ('public', 'Everyone'),
         ('private', 'Invited people only'),
@@ -136,6 +143,11 @@ class Channel(models.Model):
         for channel in self:
             channel.is_member = self.env.user.partner_id in channel.channel_partner_ids
 
+    @api.depends('channel_partner_ids')
+    def _compute_member_count(self):
+        for channel in self:
+            channel.member_count = len(channel.with_context(active_test=False).channel_partner_ids)
+
     # ONCHANGE
 
     @api.onchange('public')
@@ -269,17 +281,18 @@ class Channel(models.Model):
             'type': 'mail.channel_update',
             'payload': {
                 'id': self.id,
-                'memberCount': len(self.channel_partner_ids),
+                'memberCount': self.member_count,
                 'members': [('insert-and-unlink', {'id': partner.id})],
             },
         })
         return result
 
-    def add_members(self, partner_ids):
-        """ Adds the given partner_ids as member of self channels. """
+    def add_members(self, partner_ids=None, guest_ids=None):
+        """ Adds the given partner_ids and guest_ids as member of self channels. """
         self.check_access_rights('write')
         self.check_access_rule('write')
-        partners = self.env['res.partner'].browse(partner_ids)
+        partners = self.env['res.partner'].browse(partner_ids or [])
+        guests = self.env['mail.guest'].browse(guest_ids or [])
         members_to_create = []
         for channel in self:
             if channel.public == 'groups':
@@ -291,13 +304,18 @@ class Channel(models.Model):
                         group_name=channel.group_public_id.name,
                         partner_names=', '.join(partner.name for partner in invalid_partners)
                     ))
-            existing_partners = self.env['res.partner'].search([('id', 'in', partner_ids), ('channel_ids', 'in', channel.id)])
+            existing_partners = self.env['res.partner'].search([('id', 'in', partners.ids), ('channel_ids', 'in', channel.id)])
             members_to_create += [{
                 'partner_id': partner.id,
                 'channel_id': channel.id,
             } for partner in partners - existing_partners]
+            existing_guests = self.env['mail.guest'].search([('id', 'in', guests.ids), ('channel_ids', 'in', channel.id)])
+            members_to_create += [{
+                'guest_id': partner.id,
+                'channel_id': channel.id,
+            } for partner in guests - existing_guests]
         new_members = self.env['mail.channel.partner'].sudo().create(members_to_create)
-        for channel_partner in new_members:
+        for channel_partner in new_members.filtered(lambda channel_partner: channel_partner.partner_id):
             user = channel_partner.partner_id.user_ids[0] if channel_partner.partner_id.user_ids else self.env['res.users']
             # notify invited members through the bus
             if user:
@@ -322,7 +340,7 @@ class Channel(models.Model):
                 'type': 'mail.channel_update',
                 'payload': {
                     'id': channel_partner.channel_id.id,
-                    'memberCount': len(channel_partner.channel_id.channel_partner_ids),
+                    'memberCount': channel_partner.channel_id.member_count,
                     'members': [('insert', {
                         'id': channel_partner.partner_id.id,
                         'im_status': channel_partner.partner_id.im_status,
@@ -421,7 +439,7 @@ class Channel(models.Model):
                        AND partner.id = ANY(%s) AND partner.id != ANY(%s)"""
             self.env.cr.execute(
                 sql_query,
-                (email_from, list(pids), [author_id] if author_id else [], )
+                (email_from or '', list(pids), [author_id] if author_id else [], )
             )
             for partner_id, partner_share, notif in self._cr.fetchall():
                 # ocn_client: will add partners to recipient recipient_data. more ocn notifications. We neeed to filter them maybe
@@ -597,12 +615,11 @@ class Channel(models.Model):
             }
             if extra_info:
                 info['info'] = extra_info
-
             # add last message preview (only used in mobile)
             info['last_message_id'] = channel_last_message_ids.get(channel.id, False)
             # listeners of the channel
             channel_partners = channel.channel_last_seen_partner_ids
-            info['memberCount'] = len(channel_partners)
+            info['memberCount'] = channel.member_count
             # find the channel partner state, if logged user
             if self.env.user and self.env.user.partner_id:
                 info['message_needaction_counter'] = channel.message_needaction_counter
@@ -632,7 +649,7 @@ class Channel(models.Model):
             channel_infos.append(info)
         return channel_infos
 
-    def channel_fetch_message(self, last_id=False, limit=20):
+    def _channel_fetch_message(self, last_id=False, limit=20):
         """ Return message values of the current channel.
             :param last_id : last message id to start the research
             :param limit : maximum number of messages to fetch
@@ -643,7 +660,7 @@ class Channel(models.Model):
         domain = ["&", ("model", "=", "mail.channel"), ("res_id", "in", self.ids)]
         if last_id:
             domain.append(("id", "<", last_id))
-        return self.env['mail.message'].message_fetch(domain=domain, limit=limit)
+        return self.env['mail.message']._message_fetch(domain=domain, limit=limit)
 
     # User methods
     @api.model
@@ -759,7 +776,7 @@ class Channel(models.Model):
         if channel_partners:
             channel_partners.write({'is_pinned': pinned})
 
-    def channel_seen(self, last_message_id=None):
+    def _channel_seen(self, last_message_id=None):
         """
         Mark channel as seen by updating seen message id of the current logged partner
         :param last_message_id: the id of the message to be marked as seen, last message of the
@@ -773,9 +790,7 @@ class Channel(models.Model):
         last_message = self.env['mail.message'].search(domain, order="id DESC", limit=1)
         if not last_message:
             return
-
         self._set_last_seen_message(last_message)
-
         data = {
             'info': 'channel_seen',
             'last_message_id': last_message.id,
@@ -801,6 +816,7 @@ class Channel(models.Model):
                 [('seen_message_id', '<', last_message.id)]
             ])
         ])
+        channel_partner_domain = expression.AND([channel_partner_domain, [('partner_id', '=', self.env.user.partner_id.id)]])
         channel_partner = self.env['mail.channel.partner'].search(channel_partner_domain)
         channel_partner.write({
             'fetched_message_id': last_message.id,

--- a/addons/mail/models/mail_channel_partner.py
+++ b/addons/mail/models/mail_channel_partner.py
@@ -1,6 +1,8 @@
 # -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
+from werkzeug.exceptions import NotFound
+
 from odoo import api, fields, models, _
 from odoo.exceptions import AccessError
 
@@ -12,10 +14,11 @@ class ChannelPartner(models.Model):
     _rec_name = 'partner_id'
 
     # identity
-    partner_id = fields.Many2one('res.partner', string='Recipient', ondelete='cascade', required=True)
+    partner_id = fields.Many2one('res.partner', string='Recipient', ondelete='cascade', readonly=True, index=True)
+    guest_id = fields.Many2one(string="Guest", comodel_name='mail.guest', ondelete='cascade', readonly=True, index=True)
     partner_email = fields.Char('Email', related='partner_id.email', readonly=False)
     # channel
-    channel_id = fields.Many2one('mail.channel', string='Channel', ondelete='cascade', required=True)
+    channel_id = fields.Many2one('mail.channel', string='Channel', ondelete='cascade', readonly=True, required=True)
     # state
     custom_channel_name = fields.Char('Custom channel name')
     fetched_message_id = fields.Many2one('mail.message', string='Last Fetched')
@@ -25,6 +28,14 @@ class ChannelPartner(models.Model):
     is_pinned = fields.Boolean("Is pinned on the interface", default=True)
     last_interest_dt = fields.Datetime("Last Interest", default=fields.Datetime.now, help="Contains the date and time of the last interesting event that happened in this channel for this partner. This includes: creating, joining, pinning, and new message posted.")
 
+    def init(self):
+        self.env.cr.execute("CREATE UNIQUE INDEX IF NOT EXISTS mail_channel_partner_partner_unique ON %s (channel_id, partner_id) WHERE partner_id IS NOT NULL" % self._table)
+        self.env.cr.execute("CREATE UNIQUE INDEX IF NOT EXISTS mail_channel_partner_guest_unique ON %s (channel_id, guest_id) WHERE guest_id IS NOT NULL" % self._table)
+
+    _sql_constraints = [
+        ("partner_or_guest_exists", "CHECK((partner_id IS NOT NULL AND guest_id IS NULL) OR (partner_id IS NULL AND guest_id IS NOT NULL))", "A channel member must be a partner or a guest."),
+    ]
+
     @api.model_create_multi
     def create(self, vals_list):
         """Similar access rule as the access rule of the mail channel.
@@ -42,7 +53,35 @@ class ChannelPartner(models.Model):
         return super(ChannelPartner, self).create(vals_list)
 
     def write(self, vals):
-        if not self.env.is_admin():
-            if {'channel_id', 'partner_id', 'partner_email'} & set(vals):
-                raise AccessError(_('You can not write on this field'))
+        for channel_partner in self:
+            for field_name in {'channel_id', 'partner_id', 'guest_id'}:
+                if field_name in vals and vals[field_name] != channel_partner[field_name].id:
+                    raise AccessError(_('You can not write on %(field_name)s.', field_name=field_name))
         return super(ChannelPartner, self).write(vals)
+
+    @api.model
+    def _get_as_sudo_from_request_or_raise(self, request, channel_id):
+        channel_partner = self._get_as_sudo_from_request(request=request, channel_id=channel_id)
+        if not channel_partner:
+            raise NotFound()
+        return channel_partner
+
+    @api.model
+    def _get_as_sudo_from_request(self, request, channel_id):
+        """ Seeks a channel partner matching the provided `channel_id` and the
+        current user or guest.
+
+        :param channel_id: The id of the channel of which the user/guest is
+            expected to be member.
+        :type channel_id: int
+        :return: A record set containing the channel partner if found, or an
+            empty record set otherwise. In case of guest, the record is returned
+            with the 'guest' record in the context.
+        :rtype: mail.channel.partner
+        """
+        if request.session.uid:
+            return self.env['mail.channel.partner'].sudo().search([('channel_id', '=', channel_id), ('partner_id', '=', self.env.user.partner_id.id)], limit=1)
+        guest = self.env['mail.guest']._get_guest_from_request(request)
+        if guest:
+            return guest.env['mail.channel.partner'].sudo().search([('channel_id', '=', channel_id), ('guest_id', '=', guest.id)], limit=1)
+        return self.env['mail.channel.partner']

--- a/None
+++ b/addons/mail/models/mail_guest.py
@@ -0,0 +1,80 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+import pytz
+import uuid
+
+from odoo.tools import consteq
+from odoo import api, fields, models
+from odoo.addons.base.models.res_partner import _tz_get
+
+
+class MailGuest(models.Model):
+    _name = 'mail.guest'
+    _description = "Guest"
+    _inherit = ['avatar.mixin']
+    _avatar_name_field = "name"
+
+    @api.model
+    def _lang_get(self):
+        return self.env['res.lang'].get_installed()
+
+    name = fields.Char(string="Name", required=True)
+    access_token = fields.Char(string="Access Token", default=lambda self: str(uuid.uuid4()), groups='base.group_system', required=True, readonly=True, copy=False)
+    country_id = fields.Many2one(string="Country", comodel_name='res.country')
+    lang = fields.Selection(string="Language", selection=_lang_get)
+    timezone = fields.Selection(string="Timezone", selection=_tz_get)
+    channel_ids = fields.Many2many(string="Channels", comodel_name='mail.channel', relation='mail_channel_partner', column1='guest_id', column2='channel_id', copy=False)
+
+    def _get_guest_from_request(self, request):
+        guest_id = request.httprequest.cookies.get('mail.guest_id')
+        guest_access_token = request.httprequest.cookies.get('mail.guest_access_token')
+        if not guest_id or not guest_access_token:
+            return self.env['mail.guest']
+        guest = self.env['mail.guest'].browse(int(guest_id)).sudo().exists()
+        if not guest or not guest.access_token or not consteq(guest.access_token, guest_access_token):
+            return self.env['mail.guest']
+        if not guest.timezone:
+            timezone = self._get_timezone_from_request(request)
+            if timezone:
+                guest._update_timezone(timezone)
+        return guest.sudo(False).with_context(guest=guest)
+
+    def _get_timezone_from_request(self, request):
+        timezone = request.httprequest.cookies.get('tz')
+        return timezone if timezone in pytz.all_timezones else False
+
+    def _update_timezone(self, timezone):
+        query = """
+            UPDATE mail_guest
+            SET timezone = %s
+            WHERE id IN (
+                SELECT id FROM mail_guest WHERE id = %s
+                FOR NO KEY UPDATE SKIP LOCKED
+            )
+        """
+        self.env.cr.execute(query, (timezone, self.id))
+
+    def _init_messaging(self):
+        self.ensure_one()
+        partner_root = self.env.ref('base.partner_root')
+        return {
+            'channels': self.channel_ids.channel_info(),
+            'currentGuest': {
+                'id': self.id,
+                'name': self.name,
+            },
+            'current_partner': False,
+            'current_user_id': False,
+            'current_user_settings': False,
+            'mail_failures': [],
+            'menu_id': False,
+            'needaction_inbox_counter': False,
+            'partner_root': {
+                'id': partner_root.id,
+                'name': partner_root.name,
+            },
+            'public_partners': [],
+            'shortcodes': [],
+            'starred_counter': False,
+        }

--- a/addons/mail/models/mail_message.py
+++ b/addons/mail/models/mail_message.py
@@ -124,6 +124,7 @@ class Message(models.Model):
         'res.partner', 'Author', index=True, ondelete='set null',
         help="Author of the message. If not set, email_from may hold an email address that did not match any partner.")
     author_avatar = fields.Binary("Author's avatar", related='author_id.avatar_128', depends=['author_id'], readonly=False)
+    author_guest_id = fields.Many2one(string="Guest", comodel_name='mail.guest')
     # recipients: include inactive partners (they may have been archived after
     # the message was sent, but they should remain visible in the relation)
     partner_ids = fields.Many2many('res.partner', string='Recipients', context={'active_test': False})
@@ -790,8 +791,14 @@ class Message(models.Model):
             else:
                 record_name = False
 
+            if message_sudo.author_guest_id:
+                vals['guestAuthor'] = [('insert', {
+                    'id': message_sudo.author_guest_id.id,
+                    'name': message_sudo.author_guest_id.name,
+                })]
+            else:
+                vals['author_id'] = author
             vals.update({
-                'author_id': author,
                 'notifications': message_sudo.notification_ids._filtered_for_web_client()._notification_format(),
                 'attachment_ids': attachments_formatted,
                 'tracking_value_ids': tracking_value_ids,
@@ -801,12 +808,18 @@ class Message(models.Model):
         return vals_list
 
     @api.model
-    def message_fetch(self, domain, limit=20):
+    def _message_fetch(self, domain, max_id=None, min_id=None, limit=30):
         """ Get a limited amount of formatted messages with provided domain.
             :param domain: the domain to filter messages;
+            :param min_id: messages must be more recent than this id
+            :param max_id: message must be less recent than this id
             :param limit: the maximum amount of messages to get;
             :returns list(dict).
         """
+        if max_id:
+            domain = expression.AND([domain, [('id', '<', max_id)]])
+        if min_id:
+            domain = expression.AND([domain, [('id', '>', min_id)]])
         return self.search(domain, limit=limit).message_format()
 
     def message_format(self):

--- a/addons/mail/models/mail_thread.py
+++ b/addons/mail/models/mail_thread.py
@@ -13,7 +13,6 @@ import lxml
 import logging
 import pytz
 import re
-import socket
 import time
 import threading
 
@@ -28,7 +27,6 @@ from odoo import _, api, exceptions, fields, models, tools, registry, SUPERUSER_
 from odoo.exceptions import MissingError
 from odoo.osv import expression
 
-from odoo.tools import ustr
 from odoo.tools.misc import clean_context, split_every
 
 _logger = logging.getLogger(__name__)
@@ -1804,7 +1802,12 @@ class MailThread(models.AbstractModel):
         record_name = record_name or self.display_name
 
         # Find the message's author
-        author_id, email_from = self._message_compute_author(author_id, email_from, raise_exception=True)
+        if 'guest' in self.env.context:
+            author_guest_id = self.env.context['guest'].id
+            author_id, email_from = False, False
+        else:
+            author_guest_id = False
+            author_id, email_from = self._message_compute_author(author_id, email_from, raise_exception=True)
 
         if subtype_xmlid:
             subtype_id = self.env['ir.model.data']._xmlid_to_res_id(subtype_xmlid)
@@ -1836,6 +1839,7 @@ class MailThread(models.AbstractModel):
         values = dict(msg_kwargs)
         values.update({
             'author_id': author_id,
+            'author_guest_id': author_guest_id,
             'email_from': email_from,
             'model': self._name,
             'res_id': self.id,

--- a/addons/mail/models/res_partner.py
+++ b/addons/mail/models/res_partner.py
@@ -116,6 +116,8 @@ class Partner(models.Model):
                 "user_id": main_user.id,
                 "is_internal_user": not partner.partner_share,
             }
+            if 'guest' in self.env.context:
+                partners_format[partner].pop('email')
         return partners_format
 
     def _message_fetch_failed(self):

--- a/addons/mail/models/res_users.py
+++ b/addons/mail/models/res_users.py
@@ -94,6 +94,7 @@ class Users(models.Model):
         partner_root = self.env.ref('base.partner_root')
         values = {
             'channels': self.partner_id._get_channels_as_member().channel_info(),
+            'currentGuest': False,
             'current_partner': self.partner_id.mail_partner_format().get(self.partner_id),
             'current_user_id': self.id,
             'current_user_settings': self.env['res.users.settings']._find_or_create_for_user(self)._res_users_settings_format(),
