PR: https://github.com/odoo/odoo/pull/

From: beaa30a3d1843de43a45f419bfbc1bfa7613a920
From: Laurent Smet
Date: 2019-06-28 11:52:55

Breaking data model changes score: 163.00000000000017, change matches:
-    group_invoice_lines = fields.Boolean(string='Group Invoice Lines',
-    _inherit = ['portal.mixin', 'mail.thread', 'mail.activity.mixin']
-    name = fields.Char(string='Reference/Description', index=True,
-    origin = fields.Char(string='Source Document',
-    type = fields.Selection([
-    refund_invoice_id = fields.Many2one('account.invoice', string="Invoice for which this invoice is the credit note")
-    number = fields.Char(related='move_id.name', store=True, readonly=True, copy=False)
-    move_name = fields.Char(string='Journal Entry Name', readonly=False,
-    reference = fields.Char(string='Payment Ref.', copy=False, readonly=True, states={'draft': [('readonly', False)]},
-    comment = fields.Text('Additional Information', readonly=True, states={'draft': [('readonly', False)]}, default=_default_comment)
-    state = fields.Selection([
-    sent = fields.Boolean(readonly=True, default=False, copy=False,
-    date_invoice = fields.Date(string='Invoice Date',
-    date_due = fields.Date(string='Due Date',
-    partner_id = fields.Many2one('res.partner', string='Partner', change_default=True,
-    vendor_bill_id = fields.Many2one('account.invoice', string='Vendor Bill',
-    payment_term_id = fields.Many2one('account.payment.term', string='Payment Terms', oldname='payment_term',
-    date = fields.Date(string='Accounting Date',
-    account_id = fields.Many2one('account.account', string='Account',
-    invoice_line_ids = fields.One2many('account.invoice.line', 'invoice_id', string='Invoice Lines', oldname='invoice_line',
-    tax_line_ids = fields.One2many('account.invoice.tax', 'invoice_id', string='Tax Lines', oldname='tax_line',
-    refund_invoice_ids = fields.One2many('account.invoice', 'refund_invoice_id', string='Refund Invoices', readonly=True)
-    move_id = fields.Many2one('account.move', string='Journal Entry',
-    amount_by_group = fields.Binary(string="Tax amount by group", compute='_amount_by_group', help="type: [(name, amount, base, formated amount, formated base)]")
-    amount_untaxed = fields.Monetary(string='Untaxed Amount',
-    amount_untaxed_signed = fields.Monetary(string='Untaxed Amount in Company Currency', currency_field='company_currency_id',
-    amount_untaxed_invoice_signed = fields.Monetary(string='Untaxed Amount in Invoice Currency', currency_field='currency_id',
-    amount_tax = fields.Monetary(string='Tax',
-    amount_tax_signed = fields.Monetary(string='Tax in Invoice Currency', currency_field='currency_id',
-    amount_total = fields.Monetary(string='Total',
-    amount_total_signed = fields.Monetary(string='Total in Invoice Currency', currency_field='currency_id',
-    amount_total_company_signed = fields.Monetary(string='Total in Company Currency', currency_field='company_currency_id',
-    currency_id = fields.Many2one('res.currency', string='Currency',
-    company_currency_id = fields.Many2one('res.currency', related='company_id.currency_id', string="Company Currency", readonly=True)
-    journal_id = fields.Many2one('account.journal', string='Journal',
-    company_id = fields.Many2one('res.company', string='Company', change_default=True,
-    reconciled = fields.Boolean(string='Paid/Reconciled', store=True, readonly=True, compute='_compute_residual',
-    partner_bank_id = fields.Many2one('res.partner.bank', string='Bank Account',
-    residual = fields.Monetary(string='Amount Due',
-    residual_signed = fields.Monetary(string='Amount Due in Invoice Currency', currency_field='currency_id',
-    residual_company_signed = fields.Monetary(string='Amount Due in Company Currency', currency_field='company_currency_id',
-    payment_ids = fields.Many2many('account.payment', 'account_invoice_payment_rel', 'invoice_id', 'payment_id', string="Payments", copy=False, readonly=True)
-    payment_move_line_ids = fields.Many2many('account.move.line', string='Payment Move Lines', compute='_compute_payments', store=True)
-    user_id = fields.Many2one('res.users', string='Salesperson', tracking=True,
-    fiscal_position_id = fields.Many2one('account.fiscal.position', string='Fiscal Position', oldname='fiscal_position',
-    commercial_partner_id = fields.Many2one('res.partner', string='Commercial Entity', compute_sudo=True,
-    edition_mode_available = fields.Boolean(compute='_get_edition_mode_available', groups='account.group_account_invoice')
-    outstanding_credits_debits_widget = fields.Text(compute='_get_outstanding_info_JSON', groups="account.group_account_invoice")
-    payments_widget = fields.Text(compute='_get_payment_info_JSON', groups="account.group_account_invoice")
-    has_outstanding = fields.Boolean(compute='_get_outstanding_info_JSON', groups="account.group_account_invoice")
-    cash_rounding_id = fields.Many2one('account.cash.rounding', string='Cash Rounding Method',
-    sequence_number_next = fields.Char(string='Next Number', compute="_get_sequence_number_next", inverse="_set_sequence_next")
-    sequence_number_next_prefix = fields.Char(string='Next Number Prefix', compute="_get_sequence_prefix")
-    incoterm_id = fields.Many2one('account.incoterms', string='Incoterm',
-    source_email = fields.Char(string='Source Email', tracking=True)
-    vendor_display_name = fields.Char(compute='_get_vendor_display_info', store=True)
-    invoice_icon = fields.Char(compute='_get_vendor_display_info', store=False)
-    name = fields.Text(string='Description', required=True)
-    origin = fields.Char(string='Source Document',
-    sequence = fields.Integer(default=10,
-    invoice_id = fields.Many2one('account.invoice', string='Invoice Reference',
-    invoice_type = fields.Selection(related='invoice_id.type', readonly=True)
-    uom_id = fields.Many2one('uom.uom', string='Unit of Measure',
-    product_id = fields.Many2one('product.product', string='Product',
-    account_id = fields.Many2one('account.account', string='Account', domain=[('deprecated', '=', False)],
-    price_subtotal = fields.Monetary(string='Amount (without Taxes)',
-    price_total = fields.Monetary(string='Amount (with Taxes)',
-    price_subtotal_signed = fields.Monetary(string='Amount Signed', currency_field='company_currency_id',
-    price_tax = fields.Monetary(string='Tax Amount', compute='_get_price_tax', store=False)
-    quantity = fields.Float(string='Quantity', digits=dp.get_precision('Product Unit of Measure'),
-    discount = fields.Float(string='Discount (%)', digits=dp.get_precision('Discount'),
-    invoice_line_tax_ids = fields.Many2many('account.tax',
-    account_analytic_id = fields.Many2one('account.analytic.account',
-    company_id = fields.Many2one('res.company', string='Company',
-    partner_id = fields.Many2one('res.partner', string='Partner',
-    currency_id = fields.Many2one('res.currency', related='invoice_id.currency_id', store=True, related_sudo=False, readonly=False)
-    company_currency_id = fields.Many2one('res.currency', related='invoice_id.company_currency_id', readonly=True, related_sudo=False)
-    display_type = fields.Selection([
-    invoice_id = fields.Many2one('account.invoice', string='Invoice', ondelete='cascade', index=True)
-    tax_id = fields.Many2one('account.tax', string='Tax', ondelete='restrict')
-    tax_repartition_line_id = fields.Many2one(string="Originating Repartition Line", comodel_name='account.tax.repartition.line')
-    account_id = fields.Many2one('account.account', string='Tax Account', required=True, domain=[('deprecated', '=', False)])
-    account_analytic_id = fields.Many2one('account.analytic.account', string='Analytic account')
-    analytic_tag_ids = fields.Many2many('account.analytic.tag', string='Analytic Tags')
-    amount = fields.Monetary('Tax Amount')
-    amount_rounding = fields.Monetary('Amount Delta')
-    amount_total = fields.Monetary(string="Amount Total", compute='_compute_amount_total')
-    manual = fields.Boolean(default=True)
-    currency_id = fields.Many2one('res.currency', related='invoice_id.currency_id', store=True, readonly=True)
-    base = fields.Monetary(string='Base')
-    tag_ids = fields.Many2many(string="Tags", comodel_name='account.account.tag', help="The taxes that will be applied on the move line generated for this tax entry")
-    _inherit = ['mail.thread', 'mail.activity.mixin']
+    date = fields.Date(string='Date', required=True, index=True, readonly=True,
+    state = fields.Selection(selection=[
+    type = fields.Selection(selection=[
+    journal_id = fields.Many2one('account.journal', string='Journal', required=True, readonly=True,
+    company_id = fields.Many2one(string='Company', store=True, readonly=True,
+    company_currency_id = fields.Many2one(string='Company Currency', readonly=True,
+    currency_id = fields.Many2one('res.currency', store=True, readonly=True, tracking=True, required=True,
+    line_ids = fields.One2many('account.move.line', 'move_id', string='Journal Items', copy=True, readonly=True,
+    partner_id = fields.Many2one('res.partner', readonly=True, tracking=True,
+    commercial_partner_id = fields.Many2one('res.partner', string='Commercial Entity', store=True, readonly=True,
+    amount_untaxed = fields.Monetary(string='Untaxed Amount', store=True, readonly=True, tracking=True,
+    amount_tax = fields.Monetary(string='Tax', store=True, readonly=True,
+    amount_total = fields.Monetary(string='Total', store=True, readonly=True,
+    amount_untaxed_signed = fields.Monetary(string='Untaxed Amount Signed', store=True, readonly=True,
+    amount_tax_signed = fields.Monetary(string='Tax Signed', store=True, readonly=True,
+    amount_total_signed = fields.Monetary(string='Total Signed', store=True, readonly=True,
+    amount_by_group = fields.Binary(string="Tax amount by group",
+    fiscal_position_id = fields.Many2one('account.fiscal.position', string='Fiscal Position', readonly=True,
+    invoice_line_ids = fields.One2many('account.move.line', 'move_id', string='Invoice lines',
-    ref = fields.Char(string='Reference', copy=False)
-    date = fields.Date(required=True, states={'posted': [('readonly', True)]}, index=True, default=fields.Date.context_today)
-    journal_id = fields.Many2one('account.journal', string='Journal', required=True, states={'posted': [('readonly', True)]}, default=_get_default_journal)
-    state = fields.Selection([('draft', 'Unposted'), ('posted', 'Posted')], string='Status',
-    line_ids = fields.One2many('account.move.line', 'move_id', string='Journal Items',
-    partner_id = fields.Many2one('res.partner', compute='_compute_partner_id', string="Partner", store=True, readonly=True)
-    amount = fields.Monetary(compute='_amount_compute', inverse="_set_amount", store=True)
-    currency_id = fields.Many2one('res.currency', compute='_amount_compute', store=True, string="Currency")
-    narration = fields.Text(string='Internal Note')
-    company_id = fields.Many2one('res.company', related='journal_id.company_id', string='Company', store=True, readonly=True)
-    matched_percentage = fields.Float('Percentage Matched', compute='_compute_matched_percentage', digits=0, store=True, readonly=True, help="Technical field used in cash basis method")
-    reconcile_model_id = fields.Many2many('account.reconcile.model', compute='_compute_reconcile_model', search='_search_reconcile_model', string="Reconciliation Model", readonly=True)
-    dummy_account_id = fields.Many2one('account.account', related='line_ids.account_id', string='Account', store=False, readonly=True)
-    tax_cash_basis_rec_id = fields.Many2one(
-    auto_post = fields.Boolean(string='Post Automatically', default=False, help='If this checkbox is ticked, this entry will be automatically posted at its date.')
-    reverse_entry_id = fields.Many2one('account.move', String="Reverse entry", store=True, readonly=True)
-    to_check = fields.Boolean(string='To Check', default=False, help='If this checkbox is ticked, it means that the user was not sure of all the related informations at the time of the creation of the move and that the move needs to be checked again.')
-    tax_type_domain = fields.Char(store=False, help='Technical field used to have a dynamic taxes domain on the form view.')
+    move_id = fields.Many2one('account.move', string='Journal Entry',
+    move_name = fields.Char(string='Number', related='move_id.name', store=True, index=True)
+    date = fields.Date(related='move_id.date', store=True, readonly=True, index=True, copy=False)
+    ref = fields.Char(related='move_id.ref', store=True, copy=False, index=True, readonly=False)
+    journal_id = fields.Many2one(related='move_id.journal_id', store=True, readonly=False, index=True, copy=False)
+    company_currency_id = fields.Many2one(related='company_id.currency_id', string='Company Currency',
+    account_id = fields.Many2one('account.account', string='Account',
+    quantity = fields.Float(string='Quantity',
+    discount = fields.Float(string='Discount (%)', digits=dp.get_precision('Discount'), default=0.0)
+    price_subtotal = fields.Monetary(string='Subtotal', store=True, readonly=True,
+    price_total = fields.Monetary(string='Total', store=True, readonly=True,
+    reconciled = fields.Boolean(compute='_amount_residual', store=True)
+    currency_id = fields.Many2one('res.currency', string='Currency')
+    partner_id = fields.Many2one('res.partner', string='Partner', ondelete='restrict')
+    product_id = fields.Many2one('product.product', string='Product')
+    tax_repartition_line_id = fields.Many2one(comodel_name='account.tax.repartition.line',
+    tag_ids = fields.Many2many(string="Tags", comodel_name='account.account.tag', ondelete='restrict',
+    matched_debit_ids = fields.One2many('account.partial.reconcile', 'credit_move_id', String='Matched Debits',
+    matched_credit_ids = fields.One2many('account.partial.reconcile', 'debit_move_id', String='Matched Credits',
+    analytic_line_ids = fields.One2many('account.analytic.line', 'move_id', string='Analytic lines')
+    display_type = fields.Selection([
-    name = fields.Char(string="Label")
-    move_name = fields.Char(string='Number', related='move_id.name', store=True, index=True)
-    quantity = fields.Float(digits=dp.get_precision('Product Unit of Measure'),
-    product_uom_id = fields.Many2one('uom.uom', string='Unit of Measure')
-    product_id = fields.Many2one('product.product', string='Product')
-    debit = fields.Monetary(default=0.0, currency_field='company_currency_id')
-    credit = fields.Monetary(default=0.0, currency_field='company_currency_id')
-    balance = fields.Monetary(compute='_store_balance', store=True, currency_field='company_currency_id',
-    amount_currency = fields.Monetary(default=0.0, help="The amount expressed in an optional other currency if it is a multi-currency entry.")
-    company_currency_id = fields.Many2one('res.currency', related='company_id.currency_id', string="Company Currency", readonly=True,
-    currency_id = fields.Many2one('res.currency', string='Currency', default=_get_currency,
-    amount_residual = fields.Monetary(compute='_amount_residual', string='Residual Amount', store=True, currency_field='company_currency_id',
-    amount_residual_currency = fields.Monetary(compute='_amount_residual', string='Residual Amount in Currency', store=True,
-    tax_base_amount = fields.Monetary(string="Base Amount", currency_field='company_currency_id')
-    account_id = fields.Many2one('account.account', string='Account', required=True, index=True,
-    move_id = fields.Many2one('account.move', string='Journal Entry', ondelete="cascade",
-    narration = fields.Text(related='move_id.narration', string='Narration', readonly=False)
-    ref = fields.Char(related='move_id.ref', string='Reference', store=True, copy=False, index=True, readonly=False)
-    payment_id = fields.Many2one('account.payment', string="Originator Payment", help="Payment that created this entry", copy=False)
-    statement_line_id = fields.Many2one('account.bank.statement.line', index=True, string='Bank statement line reconciled with this entry', copy=False, readonly=True)
-    statement_id = fields.Many2one('account.bank.statement', related='statement_line_id.statement_id', string='Statement', store=True,
-    reconciled = fields.Boolean(compute='_amount_residual', store=True)
-    reconcile_model_id = fields.Many2one('account.reconcile.model', string="Reconciliation Model", copy=False)
-    full_reconcile_id = fields.Many2one('account.full.reconcile', string="Matching Number", copy=False, index=True)
-    matched_debit_ids = fields.One2many('account.partial.reconcile', 'credit_move_id', String='Matched Debits',
-    matched_credit_ids = fields.One2many('account.partial.reconcile', 'debit_move_id', String='Matched Credits',
-    journal_id = fields.Many2one('account.journal', related='move_id.journal_id', string='Journal', readonly=False,
-    blocked = fields.Boolean(string='No Follow-up', default=False,
-    date_maturity = fields.Date(string='Due date', index=True, required=True, copy=False,
-    date = fields.Date(related='move_id.date', string='Date', index=True, store=True, copy=False, readonly=False)
-    analytic_line_ids = fields.One2many('account.analytic.line', 'move_id', string='Analytic lines', oldname="analytic_lines")
-    tax_ids = fields.Many2many('account.tax', string='Taxes', domain=['|', ('active', '=', False), ('active', '=', True)])
-    tax_line_id = fields.Many2one('account.tax', string='Originator tax', ondelete='restrict', compute='_compute_tax_line_id', store=True)
-    tax_repartition_line_id = fields.Many2one(comodel_name='account.tax.repartition.line', string="Originator Tax Repartition Line", ondelete='restrict', help="Tax repartition line that caused the creation of this move line, if any")
-    analytic_account_id = fields.Many2one('account.analytic.account', string='Analytic Account', index=True)
-    analytic_tag_ids = fields.Many2many('account.analytic.tag', string='Analytic Tags')
-    company_id = fields.Many2one('res.company', related='account_id.company_id', string='Company', store=True, readonly=True)
-    invoice_id = fields.Many2one('account.invoice', oldname="invoice")
-    partner_id = fields.Many2one('res.partner', string='Partner', ondelete='restrict')
-    tax_exigible = fields.Boolean(string='Appears in VAT report', default=True,
-    parent_state = fields.Char(compute="_compute_parent_state", help="State of the parent account.move")
-    recompute_tax_line = fields.Boolean(store=False, help="Technical field used to know if the tax_ids field has been modified in the UI.")
-    tax_line_grouping_key = fields.Char(store=False, string='Old Taxes', help="Technical field used to store the old values of fields used to compute tax lines (in account.move form view) between the moment the user changed it and the moment the ORM reflects that change in its one2many")
-    tag_ids = fields.Many2many(string="Tags", comodel_name='account.account.tag', ondelete='restrict', help="Tags assigned to this line by the tax creating it, if any. It determines its impact on financial reports.")
-    tax_audit = fields.Char(string="Tax Audit String", compute="_compute_tax_audit", store=True, help="Computed field, listing the tax grids impacted by this line, and the amount it applies to each of them.")
-    invoice_ids = fields.Many2many('account.invoice', 'account_invoice_payment_rel', 'payment_id', 'invoice_id', string="Invoices", copy=False, readonly=True,
+    invoice_ids = fields.Many2many('account.move', 'account_invoice_payment_rel', 'payment_id', 'invoice_id', string="Invoices", copy=False, readonly=True,
-    _inherit = "product.product"

Total Changes: 6699

[IMP/REF] accounting-pocalypse yeaaahh

This commit merges the following models
 * account.invoice and account.move
 * account.invoice.line and account.move.line
 * account.voucher and account.move
 * account.voucher.line and account.move.line

It was the opportunity for a big cleanup of the code, so it also restructures the whole account module, its different models/fields, the tests etc. for a better world and a better code readability.

==== Rationale ====
The rationale of this huge change is that we want journal entries / invoices to be easily edited, and changes reflected in the other model. It's a HUGE feature and very strategic for the fiduciary companies. For example, changing the account of a journal entry needs to be automatically reflected on the related invoice.

The same reasoning applies to sale/purchase vouchers.

==== Changes made in features =====
When creating an invoice, you are now creating a journal entry directly.
--> The object account.invoice no longer exists.
In the same fashion when creating an invoice line, you're now adding journal items directly in the journal entry representing the invoice. If this invoice line has some tax, it may create additional journal items as well.
--> The models account.invoice.line & account.invoice.tax no longer exist

Identically, when creating a sale/purchase receipt with its lines, you are now creating a journal entry directly and there's no more usability difference between encoding a receipt or an invoice.
--> The object account.voucher no longer exists.
--> The object account.voucher.line no longer exists.
--> The whole account_voucher module no longer exists.

Positive side-effects coming from these changes are
* draft invoices/bills/sale or purchase receipts now create a draft accounting entry. Validate these objects now simply post its journal entry. That means that draft invoices/bills/sale or purchase receipt can straightforwardly be included in reporting or budgets.
* opening a journal entry in form view will now always open the correct view: if it's a sale/purchase journal entry we will have a customer invoice/vendor bill view or a sale/purchase receipt view, whatever the menu we're coming from.
* code & business logic simplification. It is also condensed in a single place instead of being partially duplicated on invoices, vouchers and journal entries.

There should be no feature loss, except the one allowing to group multiple journal items together based on the same product during the invoice validation.

==== Changes made in models =====
* account.invoice: model removed. Instead, now use account.move with following mapping

field (account.invoice) 		field (account.move)
-----------------------			--------------------
name 					invoice_payment_ref
number 					name
reference 				ref
comment 				narration
user_id 				invoice_user_id
amount_					total_company_signed amount_total_signed
residual 				amount_residual
state 					state + invoice_payment_state 		/!\ selection changed
date_invoice 				invoice_date
date_due 				invoice_date_due
sent 					invoice_sent
origin 					invoice_origin
payment_term_id 			invoice_payment_term_id
partner_bank_id 			invoice_partner_bank_id
incoterm_id 				invoice_incoterm_id
vendor_bill_id 				invoice_vendor_bill_id
source_email 				invoice_source_email
vendor_display_name 			invoice_vendor_display_name
invoice_icon 				invoice_vendor_icon
cash_rounding_id 			invoice_cash_rounding_id
sequence_number_next 			invoice_sequence_number_next
sequence_number_next_prefix 		invoice_sequence_number_next_prefix

'invoices' subset of account.move can be accessed by using the selection field 'type' or one of the many helpers like is_invoice()

* account.move: now has a valid state 'cancel' that has to be excluded from all business logic
* account.move: field 'amount' renamed into 'amount_total'
* account.move: field 'reverse_entry_id' renamed into 'reversed_entry_id'
* account.move.line: now has a field 'display_type' that has to be excluded from all business logic, in order to support invoice layouting
* account.invoice.line: model removed. Instead, now use account.move.line with following mapping

field (account.invoice.line) 		field (account.move.line)
----------------------------		-------------------------
invoice_id 				move_id
uom_id 					product_uom_id
invoice_line_tax_ids 			tax_ids
account_analytic_id 			analytic_account_id

'invoice lines' subset of all account.move.line from a journal entry can be accessed by using the boolean field 'exclude_from_invoice_tab'

* account.invoice.tax: model removed. Instead, now use account.move.line with following mapping

field (account.invoice.tax) 		field (account.move.line)
---------------------------		-------------------------
invoice_id 				move_id
account_analytic_id 			analytic_account_id
amount 					price_unit
base 					tax_base_amount

'tax lines' subset of all account.move.line from a journal entry can be accessed by using the relational field 'tax_line_id'

* account.invoice.confirm: model removed. Instead, now use the 'post()' function of account.move
* account.invoice.refund: model removed. Instead, now use account.move.reversal to reverse the entries with the same options as we had for invoices
* account.voucher: model removed. Instead, now use account.move of type in ['out_receipt', 'in_receipt]
* account.voucher.line: model removed. Instead, now use account.move.line

==== Changes made in functions ====
* on account.move, method _run_post_draft_to_post() renamed into _autopost_draft_entries()
* on account.move, method action_account_invoice_payment() renamed into action_invoice_register_payment()
* on account.move, method action_invoice_reconcile_to_check() renamed into action_open_matching_suspense_moves()
* on account.move, method _get_domain_edition_mode_available() renamed into _get_domain_matching_supsense_moves()
* on account.move, method _get_intrastat_country_id() renamed into _get_invoice_intrastat_country_id()
* on account.move.line, method _get_domain_for_edition_mode() renamed into _get_suspense_moves_domain()
* in account.bank.statement, contextual key 'edition_mode' renamed into 'suspense_moves_mode'

Was task 1917430

================================= pseudo patch: =================================

--- a/addons/account/models/__init__.py
+++ b/addons/account/models/__init__.py
@@ -4,10 +4,11 @@ from . import partner
 from . import account
 from . import account_reconcile_model
 from . import account_payment
-from . import account_invoice
 from . import account_payment_term
 from . import account_bank_statement
 from . import account_move
+from . import account_payment_term
+from . import account_bank_statement
 from . import chart_template
 from . import account_analytic_line
 from . import account_journal_dashboard

--- a/addons/account/models/account.py
+++ b/addons/account/models/account.py
@@ -553,8 +553,6 @@ class AccountJournal(models.Model):
         domain=[('deprecated', '=', False)], help="It acts as a default account for debit amount")
     update_posted = fields.Boolean(string='Allow Cancelling Entries',
         help="Check this box if you want to allow the cancellation the entries related to this journal or of the invoice related to this journal")
-    group_invoice_lines = fields.Boolean(string='Group Invoice Lines',
-        help="If this box is checked, the system will try to group the accounting lines when generating them from invoices.")
     sequence_id = fields.Many2one('ir.sequence', string='Entry Sequence',
         help="This field contains the information related to the numbering of the journal entries of this journal.", required=True, copy=False)
     refund_sequence_id = fields.Many2one('ir.sequence', string='Credit Note Entry Sequence',
@@ -738,7 +736,7 @@ class AccountJournal(models.Model):
         if self.alias_id:
             self.alias_id.write(alias_values)
         else:
-            self.alias_id = self.env['mail.alias'].with_context(alias_model_name='account.invoice',
+            self.alias_id = self.env['mail.alias'].with_context(alias_model_name='account.move',
                 alias_parent_model_name='account.journal').create(alias_values)
 
         if vals.get('alias_name'):
@@ -1179,17 +1177,6 @@ class AccountTax(models.Model):
         if self.price_include:
             self.include_base_amount = True
 
-    def get_grouping_key(self, invoice_tax_val):
-        """ Returns a string that will be used to group account.invoice.tax sharing the same properties"""
-        self.ensure_one()
-        return str(invoice_tax_val['tax_id']) + '-' + \
-               str(invoice_tax_val.get('tax_repartition_line_id')) + '-' + \
-               str(invoice_tax_val['account_id']) + '-' + \
-               str(invoice_tax_val['account_analytic_id']) + '-' + \
-               str(invoice_tax_val.get('analytic_tag_ids', [])) + '-' + \
-               str(invoice_tax_val.get('tax_ids') or []) + '-' + \
-               str(invoice_tax_val.get('tag_ids') or [])
-
     def _compute_amount(self, base_amount, price_unit, quantity=1.0, product=None, partner=None):
         """ Returns the amount of a single tax. base_amount is the actual amount on which the tax is applied, which is
             price_unit * quantity eventually affected by previous taxes (if tax is include_base_amount XOR price_include)
@@ -1210,7 +1197,7 @@ class AccountTax(models.Model):
             else:
                 return quantity * self.amount
 
-        price_include = self._context['force_price_include'] if 'force_price_include' in self._context else self.price_include
+        price_include = self._context.get('force_price_include', self.price_include)
 
         # base * (1 + tax_amount) = new_base
         if self.amount_type == 'percent' and not price_include:
@@ -1254,12 +1241,15 @@ class AccountTax(models.Model):
         return rep_lines.filtered(lambda x: x.repartition_type == repartition_type).mapped('tag_ids')
 
     @api.multi
-    def compute_all(self, price_unit, currency=None, quantity=1.0, product=None, partner=None, is_refund=False):
+    def compute_all(self, price_unit, currency=None, quantity=1.0, product=None, partner=None, is_refund=False, handle_price_include=True):
         """ Returns all information required to apply taxes (in self + their children in case of a tax group).
             We consider the sequence of the parent for group of taxes.
                 Eg. considering letters as taxes and alphabetic order as sequence :
                 [G, B([A, D, F]), E, C] will be computed as [A, D, F, C, E, G]
 
+            'handle_price_include' is used when we need to ignore all tax included in price. If False, it means the
+            amount passed to this method will be considered as the base of all computations.
+
         RETURN: {
             'total_excluded': 0.0,    # Total without taxes
             'total_included': 0.0,    # Total with taxes
@@ -1362,28 +1352,29 @@ class AccountTax(models.Model):
         incl_fixed_amount = incl_percent_amount = incl_division_amount = 0
         # Store the tax amounts we compute while searching for the total_excluded
         cached_tax_amounts = {}
-        for tax in reversed(taxes):
-            if tax.include_base_amount:
-                base = recompute_base(base, incl_fixed_amount, incl_percent_amount, incl_division_amount)
-                incl_fixed_amount = incl_percent_amount = incl_division_amount = 0
-                store_included_tax_total = True
-            if tax.price_include:
-                if tax.amount_type == 'percent':
-                    incl_percent_amount += tax.amount
-                elif tax.amount_type == 'division':
-                    incl_division_amount += tax.amount
-                elif tax.amount_type == 'fixed':
-                    incl_fixed_amount += quantity * tax.amount
-                else:
-                    # tax.amount_type == other (python)
-                    tax_amount = tax._compute_amount(base, price_unit, quantity, product, partner)
-                    incl_fixed_amount += tax_amount
-                    # Avoid unecessary re-computation
-                    cached_tax_amounts[i] = tax_amount
-                if store_included_tax_total:
-                    total_included_checkpoints[i] = base
-                    store_included_tax_total = False
-            i -= 1
+        if handle_price_include:
+            for tax in reversed(taxes):
+                if tax.include_base_amount:
+                    base = recompute_base(base, incl_fixed_amount, incl_percent_amount, incl_division_amount)
+                    incl_fixed_amount = incl_percent_amount = incl_division_amount = 0
+                    store_included_tax_total = True
+                if tax.price_include:
+                    if tax.amount_type == 'percent':
+                        incl_percent_amount += tax.amount
+                    elif tax.amount_type == 'division':
+                        incl_division_amount += tax.amount
+                    elif tax.amount_type == 'fixed':
+                        incl_fixed_amount += quantity * tax.amount
+                    else:
+                        # tax.amount_type == other (python)
+                        tax_amount = tax._compute_amount(base, price_unit, quantity, product, partner)
+                        incl_fixed_amount += tax_amount
+                        # Avoid unecessary re-computation
+                        cached_tax_amounts[i] = tax_amount
+                    if store_included_tax_total:
+                        total_included_checkpoints[i] = base
+                        store_included_tax_total = False
+                i -= 1
 
         total_excluded = recompute_base(base, incl_fixed_amount, incl_percent_amount, incl_division_amount)
 
@@ -1438,8 +1429,8 @@ class AccountTax(models.Model):
                     'price_include': tax.price_include,
                     'tax_exigibility': tax.tax_exigibility,
                     'tax_repartition_line_id': repartition_line.id,
-                    'tag_ids': [(6, False, (repartition_line.tag_ids + subsequent_tags).ids)],
-                    'tax_ids': [(6, False, subsequent_taxes.ids)]
+                    'tag_ids': (repartition_line.tag_ids + subsequent_tags).ids,
+                    'tax_ids': subsequent_taxes.ids,
                 })
 
                 total_amount += line_amount

--- a/addons/account/models/account_bank_statement.py
+++ b/addons/account/models/account_bank_statement.py
@@ -397,6 +397,7 @@ class AccountBankStatementLine(models.Model):
             aml_to_cancel.remove_move_reconcile()
             moves_to_cancel = aml_to_cancel.mapped('move_id')
             moves_to_cancel.button_cancel()
+            moves_to_cancel.button_draft()
             moves_to_cancel.unlink()
         if payment_to_cancel:
             payment_to_cancel.unlink()
@@ -434,7 +435,9 @@ class AccountBankStatementLine(models.Model):
         if self.ref:
             ref = move_ref + ' - ' + self.ref if move_ref else self.ref
         data = {
+            'type': 'entry',
             'journal_id': self.statement_id.journal_id.id,
+            'currency_id': self.statement_id.currency_id.id,
             'date': self.statement_id.accounting_date or self.date,
             'ref': ref,
         }
@@ -624,7 +627,7 @@ class AccountBankStatementLine(models.Model):
         """
         payable_account_type = self.env.ref('account.data_account_type_payable')
         receivable_account_type = self.env.ref('account.data_account_type_receivable')
-        edition_mode = self._context.get('edition_mode')
+        suspense_moves_mode = self._context.get('suspense_moves_mode')
         counterpart_aml_dicts = counterpart_aml_dicts or []
         payment_aml_rec = payment_aml_rec or self.env['account.move.line']
         new_aml_dicts = new_aml_dicts or []
@@ -641,7 +644,7 @@ class AccountBankStatementLine(models.Model):
         if any(rec.statement_id for rec in payment_aml_rec):
             raise UserError(_('A selected move line was already reconciled.'))
         for aml_dict in counterpart_aml_dicts:
-            if aml_dict['move_line'].reconciled and not edition_mode:
+            if aml_dict['move_line'].reconciled and not suspense_moves_mode:
                 raise UserError(_('A selected move line was already reconciled.'))
             if isinstance(aml_dict['move_line'], int):
                 aml_dict['move_line'] = aml_obj.browse(aml_dict['move_line'])
@@ -655,7 +658,7 @@ class AccountBankStatementLine(models.Model):
             user_type_id = self.env['account.account'].browse(aml_dict.get('account_id')).user_type_id
             if user_type_id in [payable_account_type, receivable_account_type] and user_type_id not in account_types:
                 account_types |= user_type_id
-        if edition_mode:
+        if suspense_moves_mode:
             if any(not line.journal_entry_ids for line in self):
                 raise UserError(_('Some selected statement line were not already reconciled with an account move.'))
         else:
@@ -688,9 +691,9 @@ class AccountBankStatementLine(models.Model):
             # Create the move
             self.sequence = self.statement_id.line_ids.ids.index(self.id) + 1
             move_vals = self._prepare_reconciliation_move(self.statement_id.name)
-            if edition_mode:
+            if suspense_moves_mode:
                 self.button_cancel_reconciliation()
-            move = self.env['account.move'].create(move_vals)
+            move = self.env['account.move'].with_context(default_journal_id=move_vals['journal_id']).create(move_vals)
             counterpart_moves = (counterpart_moves | move)
 
             # Create The payment
@@ -732,7 +735,7 @@ class AccountBankStatementLine(models.Model):
 
                 (new_aml | counterpart_move_line).reconcile()
 
-                self._check_invoice_state(counterpart_move_line.invoice_id)
+                self._check_invoice_state(counterpart_move_line.move_id)
 
             # Balance the move
             st_line_amount = -sum([x.balance for x in move.line_ids])
@@ -758,7 +761,7 @@ class AccountBankStatementLine(models.Model):
                 })
             self.bank_account_id = bank_account
 
-        counterpart_moves.assert_balanced()
+        counterpart_moves._check_balanced()
         return counterpart_moves
 
     @api.multi
@@ -792,5 +795,4 @@ class AccountBankStatementLine(models.Model):
             aml_dict['currency_id'] = statement_currency.id
 
     def _check_invoice_state(self, invoice):
-        if invoice.state == 'in_payment' and all([payment.state == 'reconciled' for payment in invoice.mapped('payment_move_line_ids.payment_id')]):
-           invoice.write({'state': 'paid'})
+        invoice._compute_amount()

--- a/addons/account/models/account_invoice.py
+++ b/None
@@ -1,2131 +0,0 @@
-# -*- coding: utf-8 -*-
-
-from collections import OrderedDict
-import json
-import re
-import uuid
-from functools import partial
-from stdnum.iso7064 import mod_97_10
-from itertools import zip_longest
-
-from lxml import etree
-
-from odoo import api, exceptions, fields, models, _
-from odoo.tools import email_re, email_split, email_escape_char, float_is_zero, float_compare, \
-    pycompat, date_utils
-from odoo.tools.misc import formatLang
-
-from odoo.exceptions import UserError, RedirectWarning, ValidationError, Warning
-
-from odoo.addons import decimal_precision as dp
-import logging
-
-_logger = logging.getLogger(__name__)
-
-# mapping invoice type to journal type
-TYPE2JOURNAL = {
-    'out_invoice': 'sale',
-    'in_invoice': 'purchase',
-    'out_refund': 'sale',
-    'in_refund': 'purchase',
-}
-
-# mapping invoice type to refund type
-TYPE2REFUND = {
-    'out_invoice': 'out_refund',        # Customer Invoice
-    'in_invoice': 'in_refund',          # Vendor Bill
-    'out_refund': 'out_invoice',        # Customer Credit Note
-    'in_refund': 'in_invoice',          # Vendor Credit Note
-}
-
-MAGIC_COLUMNS = ('id', 'create_uid', 'create_date', 'write_uid', 'write_date')
-
-
-class AccountInvoice(models.Model):
-    _name = "account.invoice"
-    _inherit = ['portal.mixin', 'mail.thread', 'mail.activity.mixin']
-    _description = "Invoice"
-    _order = "date_invoice desc, number desc, id desc"
-
-
-    def _get_default_incoterm(self):
-        return self.env.company.incoterm_id
-
-    @api.one
-    @api.depends('invoice_line_ids.price_subtotal', 'tax_line_ids.amount', 'tax_line_ids.amount_rounding',
-                 'currency_id', 'company_id', 'date_invoice', 'type')
-    def _compute_amount(self):
-        round_curr = self.currency_id.round
-        self.amount_untaxed = sum(line.price_subtotal for line in self.invoice_line_ids)
-        self.amount_tax = sum(round_curr(line.amount_total) for line in self.tax_line_ids)
-        self.amount_total = self.amount_untaxed + self.amount_tax
-        amount_total_company_signed = self.amount_total
-        amount_untaxed_signed = self.amount_untaxed
-        if self.currency_id and self.company_id and self.currency_id != self.company_id.currency_id:
-            currency_id = self.currency_id
-            amount_total_company_signed = currency_id._convert(self.amount_total, self.company_id.currency_id, self.company_id, self.date_invoice or fields.Date.today())
-            amount_untaxed_signed = currency_id._convert(self.amount_untaxed, self.company_id.currency_id, self.company_id, self.date_invoice or fields.Date.today())
-        sign = self.type in ['in_refund', 'out_refund'] and -1 or 1
-        self.amount_total_company_signed = amount_total_company_signed * sign
-        self.amount_total_signed = self.amount_total * sign
-        self.amount_untaxed_signed = amount_untaxed_signed * sign
-
-    def _compute_sign_taxes(self):
-        for invoice in self:
-            sign = invoice.type in ['in_refund', 'out_refund'] and -1 or 1
-            invoice.amount_untaxed_invoice_signed = invoice.amount_untaxed * sign
-            invoice.amount_tax_signed = invoice.amount_tax * sign
-
-    @api.onchange('amount_total')
-    def _onchange_amount_total(self):
-        for inv in self:
-            if float_compare(inv.amount_total, 0.0, precision_rounding=inv.currency_id.rounding) == -1:
-                raise Warning(_('You cannot validate an invoice with a negative total amount. You should create a credit note instead.'))
-
-    @api.model
-    def _default_journal(self):
-        if self._context.get('default_journal_id', False):
-            return self.env['account.journal'].browse(self._context.get('default_journal_id'))
-        inv_type = self._context.get('type', 'out_invoice')
-        inv_types = inv_type if isinstance(inv_type, list) else [inv_type]
-        company_id = self._context.get('company_id', self.env.company.id)
-        domain = [
-            ('type', 'in', [TYPE2JOURNAL[ty] for ty in inv_types if ty in TYPE2JOURNAL]),
-            ('company_id', '=', company_id),
-        ]
-        company_currency_id = self.env['res.company'].browse(company_id).currency_id.id
-        currency_id = self._context.get('default_currency_id') or company_currency_id
-        currency_clause = [('currency_id', '=', currency_id)]
-        if currency_id == company_currency_id:
-            currency_clause = ['|', ('currency_id', '=', False)] + currency_clause
-        return (
-            self.env['account.journal'].search(domain + currency_clause, limit=1)
-            or self.env['account.journal'].search(domain, limit=1)
-        )
-
-    @api.model
-    def _default_currency(self):
-        journal = self._default_journal()
-        return journal.currency_id or journal.company_id.currency_id or self.env.company.currency_id
-
-    def _default_comment(self):
-        invoice_type = self.env.context.get('type', 'out_invoice')
-        if invoice_type == 'out_invoice' and self.env['ir.config_parameter'].sudo().get_param('account.use_invoice_terms'):
-            return self.env.company.invoice_terms
-
-    def _get_aml_for_amount_residual(self):
-        """ Get the aml to consider to compute the amount residual of invoices """
-        self.ensure_one()
-        return self.sudo().move_id.line_ids.filtered(lambda l: l.account_id == self.account_id)
-
-    @api.one
-    @api.depends(
-        'state', 'currency_id', 'invoice_line_ids.price_subtotal',
-        'move_id.line_ids.amount_residual',
-        'move_id.line_ids.currency_id')
-    def _compute_residual(self):
-        residual = 0.0
-        residual_company_signed = 0.0
-        sign = self.type in ['in_refund', 'out_refund'] and -1 or 1
-        for line in self._get_aml_for_amount_residual():
-            residual_company_signed += line.amount_residual
-            if line.currency_id == self.currency_id:
-                residual += line.amount_residual_currency if line.currency_id else line.amount_residual
-            else:
-                from_currency = line.currency_id or line.company_id.currency_id
-                residual += from_currency._convert(line.amount_residual, self.currency_id, line.company_id, line.date or fields.Date.today())
-        self.residual_company_signed = abs(residual_company_signed) * sign
-        self.residual_signed = abs(residual) * sign
-        self.residual = abs(residual)
-        digits_rounding_precision = self.currency_id.rounding
-        if self.move_id and float_is_zero(self.residual, precision_rounding=digits_rounding_precision):
-            self.reconciled = True
-        else:
-            self.reconciled = False
-
-    @api.multi
-    def _get_domain_edition_mode_available(self):
-        self.ensure_one()
-        domain = self.env['account.move.line']._get_domain_for_edition_mode()
-        domain += ['|',('move_id.partner_id', '=?', self.partner_id.id),('move_id.partner_id', '=', False)]
-        if self.type in ('out_invoice', 'in_refund'):
-            domain.append(('balance', '=', -self.residual))
-        else:
-            domain.append(('balance', '=', self.residual))
-        return domain
-
-    @api.multi
-    def _get_edition_mode_available(self):
-        for r in self:
-            domain = r._get_domain_edition_mode_available()
-            domain2 = [('state', '=', 'open'),('residual', '=', r.residual),('type', '=', r.type)]
-            r.edition_mode_available = (0 < self.env['account.move.line'].search_count(domain) < 5) and self.env['account.invoice'].search_count(domain2) < 5 and r.state == 'open'
-
-    @api.one
-    def _get_outstanding_info_JSON(self):
-        self.outstanding_credits_debits_widget = json.dumps(False)
-        if self.state == 'open':
-            domain = [('account_id', '=', self.account_id.id),
-                      ('partner_id', '=', self.env['res.partner']._find_accounting_partner(self.partner_id).id),
-                      ('reconciled', '=', False),
-                      '|',
-                        '&', ('amount_residual_currency', '!=', 0.0), ('currency_id','!=', None),
-                        '&', ('amount_residual_currency', '=', 0.0), '&', ('currency_id','=', None), ('amount_residual', '!=', 0.0)]
-            if self.type in ('out_invoice', 'in_refund'):
-                domain.extend([('credit', '>', 0), ('debit', '=', 0)])
-                type_payment = _('Outstanding credits')
-            else:
-                domain.extend([('credit', '=', 0), ('debit', '>', 0)])
-                type_payment = _('Outstanding debits')
-            info = {'title': '', 'outstanding': True, 'content': [], 'invoice_id': self.id}
-            lines = self.env['account.move.line'].search(domain)
-            currency_id = self.currency_id
-            if len(lines) != 0:
-                for line in lines:
-                    # get the outstanding residual value in invoice currency
-                    if line.currency_id and line.currency_id == self.currency_id:
-                        amount_to_show = abs(line.amount_residual_currency)
-                    else:
-                        currency = line.company_id.currency_id
-                        amount_to_show = currency._convert(abs(line.amount_residual), self.currency_id, self.company_id, line.date or fields.Date.today())
-                    if float_is_zero(amount_to_show, precision_rounding=self.currency_id.rounding):
-                        continue
-                    if line.ref :
-                        title = '%s : %s' % (line.move_id.name, line.ref)
-                    else:
-                        title = line.move_id.name
-                    info['content'].append({
-                        'journal_name': line.ref or line.move_id.name,
-                        'title': title,
-                        'amount': amount_to_show,
-                        'currency': currency_id.symbol,
-                        'id': line.id,
-                        'position': currency_id.position,
-                        'digits': [69, self.currency_id.decimal_places],
-                    })
-                info['title'] = type_payment
-                self.outstanding_credits_debits_widget = json.dumps(info)
-                self.has_outstanding = True
-
-    @api.model
-    def _get_payments_vals(self):
-        if not self.payment_move_line_ids:
-            return []
-        payment_vals = []
-        currency_id = self.currency_id
-        for payment in self.payment_move_line_ids:
-            payment_currency_id = False
-            if self.type in ('out_invoice', 'in_refund'):
-                amount = sum([p.amount for p in payment.matched_debit_ids if p.debit_move_id in self.move_id.line_ids])
-                amount_currency = sum(
-                    [p.amount_currency for p in payment.matched_debit_ids if p.debit_move_id in self.move_id.line_ids])
-                if payment.matched_debit_ids:
-                    payment_currency_id = all([p.currency_id == payment.matched_debit_ids[0].currency_id for p in
-                                               payment.matched_debit_ids]) and payment.matched_debit_ids[
-                                              0].currency_id or False
-            elif self.type in ('in_invoice', 'out_refund'):
-                amount = sum(
-                    [p.amount for p in payment.matched_credit_ids if p.credit_move_id in self.move_id.line_ids])
-                amount_currency = sum([p.amount_currency for p in payment.matched_credit_ids if
-                                       p.credit_move_id in self.move_id.line_ids])
-                if payment.matched_credit_ids:
-                    payment_currency_id = all([p.currency_id == payment.matched_credit_ids[0].currency_id for p in
-                                               payment.matched_credit_ids]) and payment.matched_credit_ids[
-                                              0].currency_id or False
-            # get the payment value in invoice currency
-            if payment_currency_id and payment_currency_id == self.currency_id:
-                amount_to_show = amount_currency
-            else:
-                currency = payment.company_id.currency_id
-                amount_to_show = currency._convert(amount, self.currency_id, payment.company_id, self.date or fields.Date.today())
-            if float_is_zero(amount_to_show, precision_rounding=self.currency_id.rounding):
-                continue
-            payment_ref = payment.move_id.name
-            if payment.move_id.ref:
-                payment_ref += ' (' + payment.move_id.ref + ')'
-            payment_vals.append({
-                'name': payment.name,
-                'journal_name': payment.journal_id.name,
-                'amount': amount_to_show,
-                'currency': currency_id.symbol,
-                'digits': [69, currency_id.decimal_places],
-                'position': currency_id.position,
-                'date': payment.date,
-                'payment_id': payment.id,
-                'account_payment_id': payment.payment_id.id,
-                'invoice_id': payment.invoice_id.id,
-                'move_id': payment.move_id.id,
-                'ref': payment_ref,
-            })
-        return payment_vals
-
-    @api.one
-    @api.depends('payment_move_line_ids.amount_residual')
-    def _get_payment_info_JSON(self):
-        self.payments_widget = json.dumps(False)
-        if self.payment_move_line_ids:
-            info = {'title': _('Less Payment'), 'outstanding': False, 'content': self._get_payments_vals()}
-            self.payments_widget = json.dumps(info, default=date_utils.json_default)
-
-    @api.one
-    @api.depends('move_id.line_ids.amount_residual')
-    def _compute_payments(self):
-        payment_lines = set()
-        for line in self.move_id.line_ids.filtered(lambda l: l.account_id.id == self.account_id.id):
-            payment_lines.update(line.mapped('matched_credit_ids.credit_move_id.id'))
-            payment_lines.update(line.mapped('matched_debit_ids.debit_move_id.id'))
-        self.payment_move_line_ids = self.env['account.move.line'].browse(list(payment_lines)).sorted()
-
-    name = fields.Char(string='Reference/Description', index=True,
-        readonly=True, states={'draft': [('readonly', False)]}, copy=False, help='The name that will be used on account move lines')
-
-    origin = fields.Char(string='Source Document',
-        help="Reference of the document that produced this invoice.",
-        readonly=True, states={'draft': [('readonly', False)]})
-    type = fields.Selection([
-            ('out_invoice','Customer Invoice'),
-            ('in_invoice','Vendor Bill'),
-            ('out_refund','Customer Credit Note'),
-            ('in_refund','Vendor Credit Note'),
-        ], readonly=True, states={'draft': [('readonly', False)]}, index=True, change_default=True,
-        default=lambda self: self._context.get('type', 'out_invoice'),
-        tracking=True)
-
-    refund_invoice_id = fields.Many2one('account.invoice', string="Invoice for which this invoice is the credit note")
-    number = fields.Char(related='move_id.name', store=True, readonly=True, copy=False)
-    move_name = fields.Char(string='Journal Entry Name', readonly=False,
-        default=False, copy=False,
-        help="Technical field holding the number given to the invoice, automatically set when the invoice is validated then stored to set the same number again if the invoice is cancelled, set to draft and re-validated.")
-    reference = fields.Char(string='Payment Ref.', copy=False, readonly=True, states={'draft': [('readonly', False)]},
-        help='Automatically generated once the invoice is confirmed. You can also write a free communication.')
-    comment = fields.Text('Additional Information', readonly=True, states={'draft': [('readonly', False)]}, default=_default_comment)
-
-    state = fields.Selection([
-            ('draft','Draft'),
-            ('open', 'Open'),
-            ('in_payment', 'In Payment'),
-            ('paid', 'Paid'),
-            ('cancel', 'Cancelled'),
-        ], string='Status', index=True, readonly=True, default='draft',
-        tracking=True, copy=False,
-        help=" * The 'Draft' status is used when a user is encoding a new and unconfirmed Invoice.\n"
-             " * The 'Open' status is used when user creates invoice, an invoice number is generated. It stays in the open status till the user pays the invoice.\n"
-             " * The 'In Payment' status is used when payments have been registered for the entirety of the invoice in a journal configured to post entries at bank reconciliation only, and some of them haven't been reconciled with a bank statement line yet.\n"
-             " * The 'Paid' status is set automatically when the invoice is paid. Its related journal entries may or may not be reconciled.\n"
-             " * The 'Cancelled' status is used when user cancel invoice.")
-    sent = fields.Boolean(readonly=True, default=False, copy=False,
-        help="It indicates that the invoice has been sent.")
-    date_invoice = fields.Date(string='Invoice Date',
-        readonly=True, states={'draft': [('readonly', False)]}, index=True,
-        help="Keep empty to use the current date", copy=False)
-    date_due = fields.Date(string='Due Date',
-        readonly=True, states={'draft': [('readonly', False)]}, index=True, copy=False,
-        help="If you use payment terms, the due date will be computed automatically at the generation "
-             "of accounting entries. The Payment terms may compute several due dates, for example 50% "
-             "now and 50% in one month, but if you want to force a due date, make sure that the payment "
-             "term is not set on the invoice. If you keep the Payment terms and the due date empty, it "
-             "means direct payment.")
-    partner_id = fields.Many2one('res.partner', string='Partner', change_default=True,
-        readonly=True, states={'draft': [('readonly', False)]},
-        tracking=True, help="You can find a contact by its Name, TIN, Email or Internal Reference.")
-    vendor_bill_id = fields.Many2one('account.invoice', string='Vendor Bill',
-        help="Auto-complete from a past bill.")
-    payment_term_id = fields.Many2one('account.payment.term', string='Payment Terms', oldname='payment_term',
-        readonly=True, states={'draft': [('readonly', False)]},
-        help="If you use payment terms, the due date will be computed automatically at the generation "
-             "of accounting entries. If you keep the payment terms and the due date empty, it means direct payment. "
-             "The payment terms may compute several due dates, for example 50% now, 50% in one month.")
-    date = fields.Date(string='Accounting Date',
-        copy=False,
-        help="Keep empty to use the invoice date.",
-        readonly=True, states={'draft': [('readonly', False)]})
-
-    account_id = fields.Many2one('account.account', string='Account',
-        readonly=True, states={'draft': [('readonly', False)]},
-        domain=[('deprecated', '=', False)], help="The partner account used for this invoice.")
-    invoice_line_ids = fields.One2many('account.invoice.line', 'invoice_id', string='Invoice Lines', oldname='invoice_line',
-        readonly=True, states={'draft': [('readonly', False)]}, copy=True)
-    tax_line_ids = fields.One2many('account.invoice.tax', 'invoice_id', string='Tax Lines', oldname='tax_line',
-        readonly=True, states={'draft': [('readonly', False)]}, copy=True)
-    refund_invoice_ids = fields.One2many('account.invoice', 'refund_invoice_id', string='Refund Invoices', readonly=True)
-    move_id = fields.Many2one('account.move', string='Journal Entry',
-        readonly=True, index=True, ondelete='restrict', copy=False,
-        help="Link to the automatically generated Journal Items.")
-
-    amount_by_group = fields.Binary(string="Tax amount by group", compute='_amount_by_group', help="type: [(name, amount, base, formated amount, formated base)]")
-    amount_untaxed = fields.Monetary(string='Untaxed Amount',
-        store=True, readonly=True, compute='_compute_amount', tracking=True)
-    amount_untaxed_signed = fields.Monetary(string='Untaxed Amount in Company Currency', currency_field='company_currency_id',
-        store=True, readonly=True, compute='_compute_amount')
-    amount_untaxed_invoice_signed = fields.Monetary(string='Untaxed Amount in Invoice Currency', currency_field='currency_id',
-        readonly=True, compute='_compute_sign_taxes')
-    amount_tax = fields.Monetary(string='Tax',
-        store=True, readonly=True, compute='_compute_amount')
-    amount_tax_signed = fields.Monetary(string='Tax in Invoice Currency', currency_field='currency_id',
-        readonly=True, compute='_compute_sign_taxes')
-    amount_total = fields.Monetary(string='Total',
-        store=True, readonly=True, compute='_compute_amount')
-    amount_total_signed = fields.Monetary(string='Total in Invoice Currency', currency_field='currency_id',
-        store=True, readonly=True, compute='_compute_amount',
-        help="Total amount in the currency of the invoice, negative for credit notes.")
-    amount_total_company_signed = fields.Monetary(string='Total in Company Currency', currency_field='company_currency_id',
-        store=True, readonly=True, compute='_compute_amount',
-        help="Total amount in the currency of the company, negative for credit notes.")
-    currency_id = fields.Many2one('res.currency', string='Currency',
-        required=True, readonly=True, states={'draft': [('readonly', False)]},
-        default=_default_currency, tracking=True)
-    company_currency_id = fields.Many2one('res.currency', related='company_id.currency_id', string="Company Currency", readonly=True)
-    journal_id = fields.Many2one('account.journal', string='Journal',
-        required=True, readonly=True, states={'draft': [('readonly', False)]},
-        default=_default_journal,
-        domain="[('type', 'in', {'out_invoice': ['sale'], 'out_refund': ['sale'], 'in_refund': ['purchase'], 'in_invoice': ['purchase']}.get(type, [])), ('company_id', '=', company_id)]")
-    company_id = fields.Many2one('res.company', string='Company', change_default=True,
-        required=True, readonly=True, states={'draft': [('readonly', False)]},
-        default=lambda self: self.env.company)
-
-    reconciled = fields.Boolean(string='Paid/Reconciled', store=True, readonly=True, compute='_compute_residual',
-        help="It indicates that the invoice has been paid and the journal entry of the invoice has been reconciled with one or several journal entries of payment.")
-    partner_bank_id = fields.Many2one('res.partner.bank', string='Bank Account',
-        help='Bank Account Number to which the invoice will be paid. A Company bank account if this is a Customer Invoice or Vendor Credit Note, otherwise a Partner bank account number.',
-        readonly=True, states={'draft': [('readonly', False)]}) #Default value computed in default_get for out_invoices
-
-    residual = fields.Monetary(string='Amount Due',
-        compute='_compute_residual', store=True, help="Remaining amount due.")
-    residual_signed = fields.Monetary(string='Amount Due in Invoice Currency', currency_field='currency_id',
-        compute='_compute_residual', store=True, help="Remaining amount due in the currency of the invoice.")
-    residual_company_signed = fields.Monetary(string='Amount Due in Company Currency', currency_field='company_currency_id',
-        compute='_compute_residual', store=True, help="Remaining amount due in the currency of the company.")
-    payment_ids = fields.Many2many('account.payment', 'account_invoice_payment_rel', 'invoice_id', 'payment_id', string="Payments", copy=False, readonly=True)
-    payment_move_line_ids = fields.Many2many('account.move.line', string='Payment Move Lines', compute='_compute_payments', store=True)
-    user_id = fields.Many2one('res.users', string='Salesperson', tracking=True,
-        readonly=True, states={'draft': [('readonly', False)]},
-        default=lambda self: self.env.user, copy=False)
-    fiscal_position_id = fields.Many2one('account.fiscal.position', string='Fiscal Position', oldname='fiscal_position',
-        readonly=True, states={'draft': [('readonly', False)]},
-        help="""Fiscal positions are used to adapt taxes and accounts for particular customers or sales orders/invoices.
-            The default value comes from the customer.""")
-    commercial_partner_id = fields.Many2one('res.partner', string='Commercial Entity', compute_sudo=True,
-        related='partner_id.commercial_partner_id', store=True, readonly=True,
-        help="The commercial entity that will be used on Journal Entries for this invoice")
-
-    edition_mode_available = fields.Boolean(compute='_get_edition_mode_available', groups='account.group_account_invoice')
-    outstanding_credits_debits_widget = fields.Text(compute='_get_outstanding_info_JSON', groups="account.group_account_invoice")
-    payments_widget = fields.Text(compute='_get_payment_info_JSON', groups="account.group_account_invoice")
-    has_outstanding = fields.Boolean(compute='_get_outstanding_info_JSON', groups="account.group_account_invoice")
-    cash_rounding_id = fields.Many2one('account.cash.rounding', string='Cash Rounding Method',
-        readonly=True, states={'draft': [('readonly', False)]},
-        help='Defines the smallest coinage of the currency that can be used to pay by cash.')
-
-    #fields use to set the sequence, on the first invoice of the journal
-    sequence_number_next = fields.Char(string='Next Number', compute="_get_sequence_number_next", inverse="_set_sequence_next")
-    sequence_number_next_prefix = fields.Char(string='Next Number Prefix', compute="_get_sequence_prefix")
-    incoterm_id = fields.Many2one('account.incoterms', string='Incoterm',
-        default=_get_default_incoterm,
-        help='International Commercial Terms are a series of predefined commercial terms used in international transactions.')
-
-    #fields related to vendor bills automated creation by email
-    source_email = fields.Char(string='Source Email', tracking=True)
-    vendor_display_name = fields.Char(compute='_get_vendor_display_info', store=True)  # store=True to enable sorting on that column
-    invoice_icon = fields.Char(compute='_get_vendor_display_info', store=False)
-
-    _sql_constraints = [
-        ('number_uniq', 'unique(number, company_id, journal_id, type)', 'Invoice Number must be unique per Company!'),
-    ]
-
-    @api.depends('partner_id', 'source_email')
-    def _get_vendor_display_info(self):
-        for invoice in self:
-            vendor_display_name = invoice.partner_id.name
-            invoice.invoice_icon = ''
-            if not vendor_display_name:
-                if invoice.source_email:
-                    vendor_display_name = _('From: ') + invoice.source_email
-                    invoice.invoice_icon = '@'
-                else:
-                    vendor_display_name = ('Created by: ') + invoice.create_uid.name
-                    invoice.invoice_icon = '#'
-            invoice.vendor_display_name = vendor_display_name
-
-    def _get_reference_euro_invoice(self):
-        """ This computes the reference based on the RF Creditor Reference.
-            The data of the reference is the database id number of the invoice.
-            For instance, if an invoice is issued with id 43, the check number
-            is 07 so the reference will be 'RF07 43'.
-        """
-        self.ensure_one()
-        base = self.id
-        check_digits = mod_97_10.calc_check_digits('{}RF'.format(base))
-        reference = 'RF{} {}'.format(check_digits, " ".join(["".join(x) for x in zip_longest(*[iter(str(base))]*4, fillvalue="")]))
-        return reference
-
-    def _get_reference_euro_partner(self):
-        """ This computes the reference based on the RF Creditor Reference.
-            The data of the reference is the user defined reference of the
-            partner or the database id number of the parter.
-            For instance, if an invoice is issued for the partner with internal
-            reference 'food buyer 654', the digits will be extracted and used as
-            the data. This will lead to a check number equal to 00 and the
-            reference will be 'RF00 654'.
-            If no reference is set for the partner, its id in the database will
-            be used.
-        """
-        self.ensure_one()
-        partner_ref = self.partner_id.ref
-        partner_ref_nr = re.sub('\D', '', partner_ref or '')[-21:] or str(self.partner_id.id)[-21:]
-        partner_ref_nr = partner_ref_nr[-21:]
-        check_digits = mod_97_10.calc_check_digits('{}RF'.format(partner_ref_nr))
-        reference = 'RF{} {}'.format(check_digits, " ".join(["".join(x) for x in zip_longest(*[iter(partner_ref_nr)]*4, fillvalue="")]))
-        return reference
-
-    def _get_reference_odoo_invoice(self):
-        """ This computes the reference based on the Odoo format.
-            We simply return the number of the invoice, defined on the journal
-            sequence.
-        """
-        self.ensure_one()
-        return self.number
-
-    def _get_reference_odoo_partner(self):
-        """ This computes the reference based on the Odoo format.
-            The data used is the reference set on the partner or its database
-            id otherwise. For instance if the reference of the customer is
-            'dumb customer 97', the reference will be 'CUST/dumb customer 97'.
-        """
-        ref = self.partner_id.ref or str(self.partner_id.id)
-        prefix = _('CUST')
-        return '%s/%s' % (prefix, ref)
-
-    @api.multi
-    def _get_computed_reference(self):
-        self.ensure_one()
-        if self.journal_id.invoice_reference_type == 'none':
-            return ''
-        else:
-            ref_function = getattr(self, '_get_reference_{}_{}'.format(self.journal_id.invoice_reference_model, self.journal_id.invoice_reference_type))
-            if ref_function:
-                return ref_function()
-            else:
-                raise UserError(_('The combination of reference model and reference type on the journal is not implemented'))
-
-    # Load all Vendor Bill lines
-    @api.onchange('vendor_bill_id')
-    def _onchange_vendor_bill(self):
-        if not self.vendor_bill_id:
-            return {}
-        self.currency_id = self.vendor_bill_id.currency_id
-        new_lines = self.env['account.invoice.line']
-        for line in self.vendor_bill_id.invoice_line_ids:
-            new_lines += new_lines.new(line._prepare_invoice_line())
-        self.invoice_line_ids += new_lines
-        self.payment_term_id = self.vendor_bill_id.payment_term_id
-        self.vendor_bill_id = False
-        return {}
-
-    def _get_seq_number_next_stuff(self):
-        self.ensure_one()
-        journal_sequence = self.journal_id.sequence_id
-        if self.journal_id.refund_sequence:
-            domain = [('type', '=', self.type)]
-            journal_sequence = self.type in ['in_refund', 'out_refund'] and self.journal_id.refund_sequence_id or self.journal_id.sequence_id
-        elif self.type in ['in_invoice', 'in_refund']:
-            domain = [('type', 'in', ['in_invoice', 'in_refund'])]
-        else:
-            domain = [('type', 'in', ['out_invoice', 'out_refund'])]
-        if self.id:
-            domain += [('id', '<>', self.id)]
-        domain += [('journal_id', '=', self.journal_id.id), ('state', 'not in', ['draft', 'cancel'])]
-        return journal_sequence, domain
-
-    def _compute_access_url(self):
-        super(AccountInvoice, self)._compute_access_url()
-        for invoice in self:
-            invoice.access_url = '/my/invoices/%s' % (invoice.id)
-
-    @api.depends('state', 'journal_id', 'date_invoice')
-    def _get_sequence_prefix(self):
-        """ computes the prefix of the number that will be assigned to the first invoice/bill/refund of a journal, in order to
-        let the user manually change it.
-        """
-        if not self.env.user._is_system():
-            for invoice in self:
-                invoice.sequence_number_next_prefix = False
-                invoice.sequence_number_next = ''
-            return
-        for invoice in self:
-            journal_sequence, domain = invoice._get_seq_number_next_stuff()
-            if (invoice.state == 'draft') and not self.search(domain, limit=1):
-                prefix, dummy = journal_sequence.with_context(ir_sequence_date=invoice.date_invoice,
-                                                              ir_sequence_date_range=invoice.date_invoice)._get_prefix_suffix()
-                invoice.sequence_number_next_prefix = prefix
-            else:
-                invoice.sequence_number_next_prefix = False
-
-    @api.depends('state', 'journal_id')
-    def _get_sequence_number_next(self):
-        """ computes the number that will be assigned to the first invoice/bill/refund of a journal, in order to
-        let the user manually change it.
-        """
-        for invoice in self:
-            journal_sequence, domain = invoice._get_seq_number_next_stuff()
-            if (invoice.state == 'draft') and not self.search(domain, limit=1):
-                number_next = journal_sequence._get_current_sequence().number_next_actual
-                invoice.sequence_number_next = '%%0%sd' % journal_sequence.padding % number_next
-            else:
-                invoice.sequence_number_next = ''
-
-    @api.multi
-    def _set_sequence_next(self):
-        ''' Set the number_next on the sequence related to the invoice/bill/refund'''
-        self.ensure_one()
-        journal_sequence, domain = self._get_seq_number_next_stuff()
-        if not self.env.user._is_admin() or not self.sequence_number_next or self.search_count(domain):
-            return
-        nxt = re.sub("[^0-9]", '', self.sequence_number_next)
-        result = re.match("(0*)([0-9]+)", nxt)
-        if result and journal_sequence:
-            # use _get_current_sequence to manage the date range sequences
-            sequence = journal_sequence._get_current_sequence()
-            sequence.number_next = int(result.group(2))
-
-    @api.multi
-    def _get_report_base_filename(self):
-        self.ensure_one()
-        return  self.type == 'out_invoice' and self.state == 'draft' and _('Draft Invoice') or \
-                self.type == 'out_invoice' and self.state in ('open','in_payment','paid') and _('Invoice - %s') % (self.number) or \
-                self.type == 'out_refund' and self.state == 'draft' and _('Credit Note') or \
-                self.type == 'out_refund' and _('Credit Note - %s') % (self.number) or \
-                self.type == 'in_invoice' and self.state == 'draft' and _('Vendor Bill') or \
-                self.type == 'in_invoice' and self.state in ('open','in_payment','paid') and _('Vendor Bill - %s') % (self.number) or \
-                self.type == 'in_refund' and self.state == 'draft' and _('Vendor Credit Note') or \
-                self.type == 'in_refund' and _('Vendor Credit Note - %s') % (self.number)
-
-    @api.model
-    def create(self, vals):
-        if not vals.get('journal_id') and vals.get('type'):
-            vals['journal_id'] = self.with_context(type=vals.get('type'))._default_journal().id
-
-        onchanges = self._get_onchange_create()
-        for onchange_method, changed_fields in onchanges.items():
-            if any(f not in vals for f in changed_fields):
-                invoice = self.new(vals)
-                getattr(invoice, onchange_method)()
-                for field in changed_fields:
-                    if field not in vals and invoice[field]:
-                        vals[field] = invoice._fields[field].convert_to_write(invoice[field], invoice)
-
-        invoice = super(AccountInvoice, self).create(vals)
-
-        if any(line.invoice_line_tax_ids for line in invoice.invoice_line_ids) and not invoice.tax_line_ids:
-            invoice.compute_taxes()
-
-        return invoice
-
-    @api.constrains('partner_id', 'partner_bank_id')
-    def validate_partner_bank_id(self):
-        for record in self:
-            if record.partner_bank_id:
-                if record.type in ('in_invoice', 'out_refund') and record.partner_bank_id.partner_id != record.partner_id.commercial_partner_id:
-                    raise ValidationError(_("Commercial partner and vendor account owners must be identical."))
-                elif record.type in ('out_invoice', 'in_refund') and not record.company_id in record.partner_bank_id.partner_id.ref_company_ids:
-                    raise ValidationError(_("The account selected for payment does not belong to the same company as this invoice."))
-
-    @api.multi
-    def _write(self, vals):
-        pre_not_reconciled = self.filtered(lambda invoice: not invoice.reconciled)
-        pre_reconciled = self - pre_not_reconciled
-        res = super(AccountInvoice, self)._write(vals)
-        reconciled = self.filtered(lambda invoice: invoice.reconciled)
-        not_reconciled = self - reconciled
-        (reconciled & pre_reconciled).filtered(lambda invoice: invoice.state == 'open').action_invoice_paid()
-        (not_reconciled & pre_not_reconciled).filtered(lambda invoice: invoice.state in ('in_payment', 'paid')).action_invoice_re_open()
-        return res
-
-    @api.model
-    def default_get(self,default_fields):
-        """ Compute default partner_bank_id field for 'out_invoice' type,
-        using the default values computed for the other fields.
-        """
-        res = super(AccountInvoice, self).default_get(default_fields)
-
-        if res.get('type', False) not in ('out_invoice', 'in_refund') or not 'company_id' in res:
-            return res
-
-        partner_bank_result = self._get_partner_bank_id(res['company_id'])
-        if partner_bank_result:
-            res['partner_bank_id'] = partner_bank_result.id
-        return res
-
-    def _get_partner_bank_id(self, company_id):
-        company = self.env['res.company'].browse(company_id)
-        if company.partner_id:
-            return self.env['res.partner.bank'].search([('partner_id', '=', company.partner_id.id)], limit=1)
-
-    @api.model
-    def fields_view_get(self, view_id=None, view_type='form', toolbar=False, submenu=False):
-        def get_view_id(xid, name):
-            try:
-                return self.env.ref('account.' + xid)
-            except ValueError:
-                view = self.env['ir.ui.view'].search([('name', '=', name)], limit=1)
-                if not view:
-                    return False
-                return view.id
-
-        context = self._context
-        supplier_form_view_id = get_view_id('invoice_supplier_form', 'account.invoice.supplier.form').id
-        if context.get('active_model') == 'res.partner' and context.get('active_ids'):
-            partner = self.env['res.partner'].browse(context['active_ids'])[0]
-            if not view_type:
-                view_id = get_view_id('invoice_tree', 'account.invoice.tree')
-                view_type = 'tree'
-            elif view_type == 'form':
-                if partner.supplier and not partner.customer:
-                    view_id = supplier_form_view_id
-                elif partner.customer and not partner.supplier:
-                    view_id = get_view_id('invoice_form', 'account.invoice.form').id
-
-        return super(AccountInvoice, self).fields_view_get(view_id=view_id, view_type=view_type, toolbar=toolbar, submenu=submenu)
-
-    @api.multi
-    def invoice_print(self):
-        """ Print the invoice and mark it as sent, so that we can see more
-            easily the next step of the workflow
-        """
-        self.filtered(lambda inv: not inv.sent).write({'sent': True})
-        if self.user_has_groups('account.group_account_invoice'):
-            return self.env.ref('account.account_invoices').report_action(self)
-        else:
-            return self.env.ref('account.account_invoices_without_payment').report_action(self)
-
-    @api.multi
-    def action_reconcile_to_check(self):
-        self.ensure_one()
-        domain = self._get_domain_edition_mode_available()
-        ids = self.env['account.move.line'].search(domain).mapped('statement_line_id').ids
-        action_context = {'show_mode_selector': False, 'company_ids': self.mapped('company_id').ids}
-        action_context.update({'edition_mode': True})
-        action_context.update({'statement_line_ids': ids})
-        action_context.update({'partner_id': self.partner_id.id})
-        action_context.update({'partner_name': self.partner_id.name})
-        return {
-            'type': 'ir.actions.client',
-            'tag': 'bank_statement_reconciliation_view',
-            'context': action_context,
-        }
-
-    @api.multi
-    def action_invoice_sent(self):
-        """ Open a window to compose an email, with the edi invoice template
-            message loaded by default
-        """
-        self.ensure_one()
-        template = self.env.ref('account.email_template_edi_invoice', False)
-        compose_form = self.env.ref('account.account_invoice_send_wizard_form', False)
-        ctx = dict(
-            default_model='account.invoice',
-            default_res_id=self.id,
-            default_use_template=bool(template),
-            default_template_id=template and template.id or False,
-            default_composition_mode='comment',
-            mark_invoice_as_sent=True,
-            custom_layout="mail.mail_notification_paynow",
-            force_email=True
-        )
-        return {
-            'name': _('Send Invoice'),
-            'type': 'ir.actions.act_window',
-            'view_type': 'form',
-            'view_mode': 'form',
-            'res_model': 'account.invoice.send',
-            'views': [(compose_form.id, 'form')],
-            'view_id': compose_form.id,
-            'target': 'new',
-            'context': ctx,
-        }
-
-    @api.multi
-    @api.returns('mail.message', lambda value: value.id)
-    def message_post(self, **kwargs):
-        if self.env.context.get('mark_invoice_as_sent'):
-            self.filtered(lambda inv: not inv.sent).write({'sent': True})
-            self.env.company.set_onboarding_step_done('account_onboarding_sample_invoice_state')
-        return super(AccountInvoice, self.with_context(mail_post_autofollow=True)).message_post(**kwargs)
-
-    @api.model
-    def message_new(self, msg_dict, custom_values=None):
-        """ Overrides mail_thread message_new(), called by the mailgateway through message_process,
-            to complete values for vendor bills created by mails.
-        """
-        # Split `From` and `CC` email address from received email to look for related partners to subscribe on the invoice
-        subscribed_emails = email_split((msg_dict.get('from') or '') + ',' + (msg_dict.get('cc') or ''))
-        seen_partner_ids = [partner.id for partner in self.env['mail.thread']._mail_find_partner_from_emails(subscribed_emails, records=self) if partner]
-
-        # Detection of the partner_id of the invoice:
-        # 1) check if the email_from correspond to a supplier
-        email_from = msg_dict.get('from') or ''
-        email_from = email_escape_char(email_split(email_from)[0])
-        partners = self.env['mail.thread'].sudo()._mail_search_on_partner(email_from, extra_domain=[('supplier', '=', True)]).id
-        partner_id = partners.ids[0] if partners else False
-
-        # 2) otherwise, if the email sender is from odoo internal users then it is likely that the vendor sent the bill
-        # by mail to the internal user who, inturn, forwarded that email to the alias to automatically generate the bill
-        # on behalf of the vendor.
-        if not partner_id:
-            user_partners = self.env['mail.thread'].sudo()._mail_search_on_user(email_from).id
-            user_partner_id = user_partners.ids[0] if user_partners else False
-            if user_partner_id and user_partner_id in self.env.ref('base.group_user').users.mapped('partner_id').ids:
-                # In this case, we will look for the vendor's email address in email's body and assume if will come first
-                email_addresses = email_re.findall(msg_dict.get('body'))
-                if email_addresses:
-                    partner_ids = [partner.id for partner in self.env['mail.thread']._mail_find_partner_from_emails([email_addresses[0]], records=self, force_create=False) if partner]
-                    partner_id = partner_ids and partner_ids[0]
-            # otherwise, there's no fallback on the partner_id found for the regular author of the mail.message as we want
-            # the partner_id to stay empty
-
-        # If the partner_id can be found, subscribe it to the bill, otherwise it's left empty to be manually filled
-        if partner_id:
-            seen_partner_ids.append(partner_id)
-
-        # Find the right purchase journal based on the "TO" email address
-        destination_emails = email_split((msg_dict.get('to') or '') + ',' + (msg_dict.get('cc') or ''))
-        alias_names = [mail_to.split('@')[0] for mail_to in destination_emails]
-        journal = self.env['account.journal'].search([
-            ('type', '=', 'purchase'), ('alias_name', 'in', alias_names)
-        ], limit=1)
-
-        # Create the message and the bill.
-        values = dict(custom_values or {}, partner_id=partner_id, source_email=email_from)
-        if journal:
-            values['journal_id'] = journal.id
-        # Passing `type` in context so that _default_journal(...) can correctly set journal for new vendor bill
-        invoice = super(AccountInvoice, self.with_context(type=values.get('type'))).message_new(msg_dict, values)
-
-        # Subscribe internal users on the newly created bill
-        partners = self.env['res.partner'].browse(seen_partner_ids)
-        is_internal = lambda p: (p.user_ids and
-                                 all(p.user_ids.mapped(lambda u: u.has_group('base.group_user'))))
-        partners_to_subscribe = partners.filtered(is_internal)
-        if partners_to_subscribe:
-            invoice.message_subscribe([p.id for p in partners_to_subscribe])
-        return invoice
-
-    @api.model
-    def complete_empty_list_help(self):
-        # add help message about email alias in vendor bills empty lists
-        Journal = self.env['account.journal']
-        journals = Journal.browse(self._context.get('default_journal_id')) or Journal.search([('type', '=', 'purchase')])
-
-        if journals:
-            links = ''
-            alias_count = 0
-            for journal in journals.filtered(lambda j: j.alias_domain and j.alias_id.alias_name):
-                email = format(journal.alias_id.alias_name) + "@" + format(journal.alias_domain)
-                links += "<a id='o_mail_test' href='mailto:{}'>{}</a>".format(email, email) + ", "
-                alias_count += 1
-            if links and alias_count == 1:
-                help_message = _('Or share the email %s to your vendors: bills will be created automatically upon mail reception.') % (links[:-2])
-            elif links:
-                help_message = _('Or share the emails %s to your vendors: bills will be created automatically upon mail reception.') % (links[:-2])
-            else:
-                help_message = _('''Or set an <a data-oe-id=%s data-oe-model="account.journal" href=#id=%s&model=account.journal>email alias</a> '''
-                                              '''to allow draft vendor bills to be created upon reception of an email.''') % (journals[0].id, journals[0].id)
-        else:
-            help_message = _('<p>You can control the invoice from your vendor based on what you purchased or received.</p>')
-        return help_message
-
-    @api.multi
-    def compute_taxes(self):
-        """Function used in other module to compute the taxes on a fresh invoice created (onchanges did not applied)"""
-        account_invoice_tax = self.env['account.invoice.tax']
-        ctx = dict(self._context)
-        for invoice in self:
-            # Delete non-manual tax lines
-            self._cr.execute("DELETE FROM account_invoice_tax WHERE invoice_id=%s AND manual is False", (invoice.id,))
-            if self._cr.rowcount:
-                self.invalidate_cache()
-
-            # Generate one tax line per tax, however many invoice lines it's applied to
-            tax_grouped = invoice.get_taxes_values()
-
-            # Create new tax lines
-            for tax in tax_grouped.values():
-                account_invoice_tax.create(tax)
-
-        # dummy write on self to trigger recomputations
-        return self.with_context(ctx).write({'invoice_line_ids': []})
-
-    @api.multi
-    def unlink(self):
-        for invoice in self:
-            if invoice.state not in ('draft', 'cancel'):
-                raise UserError(_('You cannot delete an invoice which is not draft or cancelled. You should create a credit note instead.'))
-            elif invoice.move_name:
-                raise UserError(_('You cannot delete an invoice after it has been validated (and received a number). You can set it back to "Draft" state and modify its content, then re-confirm it.'))
-        return super(AccountInvoice, self).unlink()
-
-    @api.onchange('invoice_line_ids')
-    def _onchange_invoice_line_ids(self):
-        taxes_grouped = self.get_taxes_values()
-        tax_lines = self.tax_line_ids.filtered('manual')
-        for tax in taxes_grouped.values():
-            # ATTENTION: due to this, fields in tax have to be in the view (possibly invisible), as they won't be saved otherwise (when hitting "save")
-            tax_lines += tax_lines.new(tax)
-        self.tax_line_ids = tax_lines
-        return
-
-    @api.onchange('partner_id', 'company_id')
-    def _onchange_partner_id(self):
-        account_id = False
-        payment_term_id = False
-        fiscal_position = False
-        bank_id = False
-        warning = {}
-        domain = {}
-        company_id = self.company_id.id
-        p = self.partner_id if not company_id else self.partner_id.with_context(force_company=company_id)
-        type = self.type or self.env.context.get('type', 'out_invoice')
-        if p:
-            rec_account = p.property_account_receivable_id
-            pay_account = p.property_account_payable_id
-            if not rec_account and not pay_account:
-                action = self.env.ref('account.action_account_config')
-                msg = _('Cannot find a chart of accounts for this company, You should configure it. \nPlease go to Account Configuration.')
-                raise RedirectWarning(msg, action.id, _('Go to the configuration panel'))
-
-            if type in ('in_invoice', 'in_refund'):
-                account_id = pay_account.id
-                payment_term_id = p.property_supplier_payment_term_id.id
-            else:
-                account_id = rec_account.id
-                payment_term_id = p.property_payment_term_id.id
-
-            delivery_partner_id = self.get_delivery_partner_id()
-            fiscal_position = self.env['account.fiscal.position'].get_fiscal_position(self.partner_id.id, delivery_id=delivery_partner_id)
-
-            # If partner has no warning, check its company
-            if p.invoice_warn == 'no-message' and p.parent_id:
-                p = p.parent_id
-            if p.invoice_warn and p.invoice_warn != 'no-message':
-                # Block if partner only has warning but parent company is blocked
-                if p.invoice_warn != 'block' and p.parent_id and p.parent_id.invoice_warn == 'block':
-                    p = p.parent_id
-                warning = {
-                    'title': _("Warning for %s") % p.name,
-                    'message': p.invoice_warn_msg
-                    }
-                if p.invoice_warn == 'block':
-                    self.partner_id = False
-
-        self.account_id = account_id
-        self.payment_term_id = payment_term_id
-        self.date_due = False
-        self.fiscal_position_id = fiscal_position
-
-        if type in ('in_invoice', 'out_refund'):
-            bank_ids = p.commercial_partner_id.bank_ids
-            bank_id = bank_ids[0].id if bank_ids else False
-            self.partner_bank_id = bank_id
-            domain = {'partner_bank_id': [('id', 'in', bank_ids.ids)]}
-        elif type == 'out_invoice':
-            domain = {'partner_bank_id': [('partner_id.ref_company_ids', 'in', [self.company_id.id])]}
-
-        res = {}
-        if warning:
-            res['warning'] = warning
-        if domain:
-            res['domain'] = domain
-        return res
-
-    @api.multi
-    def get_delivery_partner_id(self):
-        self.ensure_one()
-        return self.partner_id.address_get(['delivery'])['delivery']
-
-    @api.onchange('journal_id')
-    def _onchange_journal_id(self):
-        if self.journal_id and not self._context.get('default_currency_id'):
-            self.currency_id = self.journal_id.currency_id.id or self.journal_id.company_id.currency_id.id
-
-    @api.onchange('payment_term_id', 'date_invoice')
-    def _onchange_payment_term_date_invoice(self):
-        date_invoice = self.date_invoice
-        if not date_invoice:
-            date_invoice = fields.Date.context_today(self)
-        if self.payment_term_id:
-            pterm = self.payment_term_id
-            pterm_list = pterm.with_context(currency_id=self.company_id.currency_id.id).compute(value=1, date_ref=date_invoice)
-            self.date_due = max(line[0] for line in pterm_list)
-        elif self.date_due and (date_invoice > self.date_due):
-            self.date_due = date_invoice
-
-    @api.onchange('cash_rounding_id', 'invoice_line_ids', 'tax_line_ids')
-    def _onchange_cash_rounding(self):
-        # Drop previous cash rounding lines
-        lines_to_remove = self.invoice_line_ids.filtered(lambda l: l.is_rounding_line)
-        if lines_to_remove:
-            self.invoice_line_ids -= lines_to_remove
-
-        # Clear previous rounded amounts
-        for tax_line in self.tax_line_ids:
-            if tax_line.amount_rounding != 0.0:
-                tax_line.amount_rounding = 0.0
-
-        if self.cash_rounding_id and self.type in ('out_invoice', 'out_refund'):
-            rounding_amount = self.cash_rounding_id.compute_difference(self.currency_id, self.amount_total)
-            if not self.currency_id.is_zero(rounding_amount):
-                if self.cash_rounding_id.strategy == 'biggest_tax':
-                    # Search for the biggest tax line and add the rounding amount to it.
-                    # If no tax found, an error will be raised by the _check_cash_rounding method.
-                    if not self.tax_line_ids:
-                        return
-                    biggest_tax_line = None
-                    for tax_line in self.tax_line_ids:
-                        if not biggest_tax_line or tax_line.amount > biggest_tax_line.amount:
-                            biggest_tax_line = tax_line
-                    biggest_tax_line.amount_rounding += rounding_amount
-                elif self.cash_rounding_id.strategy == 'add_invoice_line':
-                    # Create a new invoice line to perform the rounding
-                    rounding_line = self.env['account.invoice.line'].new({
-                        'name': self.cash_rounding_id.name,
-                        'invoice_id': self.id,
-                        'account_id': self.cash_rounding_id.account_id.id,
-                        'price_unit': rounding_amount,
-                        'quantity': 1,
-                        'is_rounding_line': True,
-                        'sequence': 9999  # always last line
-                    })
-
-                    # To be able to call this onchange manually from the tests,
-                    # ensure the inverse field is updated on account.invoice.
-                    if not rounding_line in self.invoice_line_ids:
-                        self.invoice_line_ids += rounding_line
-
-    @api.multi
-    def action_invoice_draft(self):
-        if self.filtered(lambda inv: inv.state != 'cancel'):
-            raise UserError(_("Invoice must be cancelled in order to reset it to draft."))
-        # go from canceled state to draft state
-        self.write({'state': 'draft', 'date': False})
-        # Delete former printed invoice
-        try:
-            report_invoice = self.env['ir.actions.report']._get_report_from_name('account.report_invoice')
-        except IndexError:
-            report_invoice = False
-        if report_invoice and report_invoice.attachment:
-            for invoice in self:
-                with invoice.env.do_in_draft():
-                    invoice.number, invoice.state = invoice.move_name, 'open'
-                    attachment = self.env.ref('account.account_invoices').retrieve_attachment(invoice)
-                if attachment:
-                    attachment.unlink()
-        return True
-
-    @api.multi
-    def action_invoice_open(self):
-        # lots of duplicate calls to action_invoice_open, so we remove those already open
-        to_open_invoices = self.filtered(lambda inv: inv.state != 'open')
-        if to_open_invoices.filtered(lambda inv: not inv.partner_id):
-            raise UserError(_("The field Vendor/Customer is required, please complete it to validate the Vendor Bill/Customer Invoice."))
-        if to_open_invoices.filtered(lambda inv: inv.state != 'draft'):
-            raise UserError(_("Invoice must be in draft state in order to validate it."))
-        if to_open_invoices.filtered(lambda inv: float_compare(inv.amount_total, 0.0, precision_rounding=inv.currency_id.rounding) == -1):
-            raise UserError(_("You cannot validate an invoice with a negative total amount. You should create a credit note instead."))
-        if to_open_invoices.filtered(lambda inv: not inv.account_id):
-            raise UserError(_('No account was found to create the invoice, be sure you have installed a chart of account.'))
-        to_open_invoices.action_date_assign()
-        to_open_invoices._set_name_and_date_invoice()
-        res = to_open_invoices.action_move_create()
-        to_open_invoices.invoice_validate()
-        return res
-
-    @api.multi
-    def action_invoice_paid(self):
-        # lots of duplicate calls to action_invoice_paid, so we remove those already paid
-        to_pay_invoices = self.filtered(lambda inv: inv.state != 'paid')
-        if to_pay_invoices.filtered(lambda inv: inv.state not in ('open', 'in_payment')):
-            raise UserError(_('Invoice must be validated in order to set it to register payment.'))
-        if to_pay_invoices.filtered(lambda inv: not inv.reconciled):
-            raise UserError(_('You cannot pay an invoice which is partially paid. You need to reconcile payment entries first.'))
-
-        for invoice in to_pay_invoices:
-            if any([move.journal_id.post_at_bank_rec and move.state == 'draft' for move in invoice.payment_move_line_ids.mapped('move_id')]):
-                invoice.write({'state': 'in_payment'})
-            else:
-                invoice.write({'state': 'paid'})
-
-    @api.multi
-    def action_invoice_re_open(self):
-        if self.filtered(lambda inv: inv.state not in ('in_payment', 'paid')):
-            raise UserError(_('Invoice must be paid in order to set it to register payment.'))
-        return self.write({'state': 'open'})
-
-    @api.multi
-    def action_register_payment(self):
-        return self.env['account.payment'].with_context(active_ids=self.ids, active_model='account.invoice', active_id=self.id).action_register_payment()
-
-    @api.multi
-    def action_invoice_cancel(self):
-        return self.filtered(lambda inv: inv.state != 'cancel').action_cancel()
-
-    @api.multi
-    def _notify_get_groups(self):
-        """ Give access button to users and portal customer as portal is integrated
-        in account. Customer and portal group have probably no right to see
-        the document so they don't have the access button. """
-        groups = super(AccountInvoice, self)._notify_get_groups()
-
-        if self.state not in ('draft', 'cancel'):
-            for group_name, group_method, group_data in groups:
-                if group_name not in ('customer', 'portal'):
-                    group_data['has_button_access'] = True
-
-        return groups
-
-    @api.multi
-    def get_formview_id(self, access_uid=None):
-        """ Update form view id of action to open the invoice """
-        if self.type in ('in_invoice', 'in_refund'):
-            return self.env.ref('account.invoice_supplier_form').id
-        else:
-            return self.env.ref('account.invoice_form').id
-
-    def _prepare_tax_line_vals(self, line, tax):
-        ''' Prepare values to create an account.invoice.tax line.
-        :param line:    An account.invoice.line record.
-        :param tax:     Tax values outputted by compute_all() in account.tax.
-        :param taxes:   A list of account.tax ids affecting the tax base amount.
-        :return:        The account.invoice.tax values to create a new record.
-        '''
-        vals = {
-            'invoice_id': self.id,
-            'name': tax['name'],
-            'tax_id': tax['id'],
-            'amount': tax['amount'],
-            'base': tax['base'],
-            'manual': False,
-            'sequence': tax['sequence'],
-            'account_analytic_id': tax['analytic'] and line.account_analytic_id.id or False,
-            'account_id': tax['account_id'] or line.account_id.id,
-            'analytic_tag_ids': tax['analytic'] and line.analytic_tag_ids.ids or False,
-            'tax_repartition_line_id': tax.get('tax_repartition_line_id'), # For base amount, we let this field empty
-            'tag_ids': tax['tag_ids'],
-            'tax_ids': tax['tax_ids'],
-        }
-
-        # If the taxes generate moves on the same financial account as the invoice line,
-        # propagate the analytic account from the invoice line to the tax line.
-        # This is necessary in situations were (part of) the taxes cannot be reclaimed,
-        # to ensure the tax move is allocated to the proper analytic account.
-        if not vals.get('account_analytic_id') and line.account_analytic_id and vals['account_id'] == line.account_id.id:
-            vals['account_analytic_id'] = line.account_analytic_id.id
-        return vals
-
-    @api.multi
-    def get_taxes_values(self, tax_group_fields=False):
-        def is_tax_affecting_base_amount(tax):
-            return (tax.amount_type not in ('group', 'division') and tax.include_base_amount and tax.price_include)\
-                   or (tax.amount_type == 'division' and tax.include_base_amount and not tax.price_include)
-        # Avoid redundant browsing.
-        tax_map = dict((t.id, t) for t in self.invoice_line_ids.invoice_line_tax_ids._origin)
-        default_tax_group_fields = set(['amount', 'base'])
-        if tax_group_fields:
-            default_tax_group_fields |= set(tax_group_fields)
-        tax_grouped = {}
-        round_curr = self.currency_id.round
-        for line in self.invoice_line_ids:
-            if not line.account_id:
-                continue
-
-            price_unit = line.price_unit * (1 - (line.discount or 0.0) / 100.0)
-            taxes = line.invoice_line_tax_ids._origin.compute_all(price_unit, self.currency_id, line.quantity, line.product_id, self.partner_id, is_refund=self.type in ('in_refund', 'out_refund'))['taxes']
-
-            for tax_vals in taxes:
-                # Retrieve the tax record (not in tax_vals when dealing with group of taxes).
-                if tax_map.get(tax_vals['id']):
-                    tax = tax_map[tax_vals['id']]
-                else:
-                    tax = tax_map[tax_vals['id']] = self.env['account.tax'].browse(tax_vals['id'])
-
-                val = self._prepare_tax_line_vals(line, tax_vals)
-                key = tax.get_grouping_key(val)
-
-                if key not in tax_grouped:
-                    tax_grouped[key] = val
-                    tax_grouped[key]['base'] = round_curr(val['base'])
-                else:
-                    for field in default_tax_group_fields:
-                        tax_grouped[key][field] += round_curr(val.get(field)) or 0
-
-        return tax_grouped
-
-    @api.multi
-    def _get_aml_for_register_payment(self):
-        """ Get the aml to consider to reconcile in register payment """
-        self.ensure_one()
-        return self.move_id.line_ids.filtered(lambda r: not r.reconciled and r.account_id.internal_type in ('payable', 'receivable'))
-
-    @api.multi
-    def register_payment(self, payment_line, writeoff_acc_id=False, writeoff_journal_id=False):
-        """ Reconcile payable/receivable lines from the invoice with payment_line """
-        line_to_reconcile = self.env['account.move.line']
-        for inv in self:
-            line_to_reconcile += inv._get_aml_for_register_payment()
-        return (line_to_reconcile + payment_line).reconcile(writeoff_acc_id, writeoff_journal_id)
-
-    @api.multi
-    def assign_outstanding_credit(self, credit_aml_id):
-        self.ensure_one()
-        credit_aml = self.env['account.move.line'].browse(credit_aml_id)
-        if not credit_aml.currency_id and self.currency_id != self.company_id.currency_id:
-            amount_currency = self.company_id.currency_id._convert(credit_aml.balance, self.currency_id, self.company_id, credit_aml.date or fields.Date.today())
-            credit_aml.with_context(allow_amount_currency=True, check_move_validity=False).write({
-                'amount_currency': amount_currency,
-                'currency_id': self.currency_id.id})
-        if credit_aml.payment_id:
-            credit_aml.payment_id.write({'invoice_ids': [(4, self.id, None)]})
-        return self.register_payment(credit_aml)
-
-    @api.multi
-    def action_date_assign(self):
-        for inv in self:
-            # Here the onchange will automatically write to the database
-            inv._onchange_payment_term_date_invoice()
-        return True
-
-    @api.multi
-    def finalize_invoice_move_lines(self, move_lines):
-        """ finalize_invoice_move_lines(move_lines) -> move_lines
-
-            Hook method to be overridden in additional modules to verify and
-            possibly alter the move lines to be created by an invoice, for
-            special cases.
-            :param move_lines: list of dictionaries with the account.move.lines (as for create())
-            :return: the (possibly updated) final move_lines to create for this invoice
-        """
-        return move_lines
-
-    @api.multi
-    def compute_invoice_totals(self, company_currency, invoice_move_lines):
-        total = 0
-        total_currency = 0
-        for line in invoice_move_lines:
-            if self.currency_id != company_currency:
-                currency = self.currency_id
-                date = self._get_currency_rate_date() or fields.Date.context_today(self)
-                if not (line.get('currency_id') and line.get('amount_currency')):
-                    line['currency_id'] = currency.id
-                    line['amount_currency'] = currency.round(line['price'])
-                    line['price'] = currency._convert(line['price'], company_currency, self.company_id, date)
-            else:
-                line['currency_id'] = False
-                line['amount_currency'] = False
-                line['price'] = self.currency_id.round(line['price'])
-            if self.type in ('out_invoice', 'in_refund'):
-                total += line['price']
-                total_currency += line['amount_currency'] or line['price']
-                line['price'] = - line['price']
-            else:
-                total -= line['price']
-                total_currency -= line['amount_currency'] or line['price']
-        return total, total_currency, invoice_move_lines
-
-    @api.model
-    def invoice_line_move_line_get(self):
-        res = []
-        for line in self.invoice_line_ids:
-            if not line.account_id:
-                continue
-            if line.quantity==0:
-                continue
-
-            taxes_to_flatten = line.invoice_line_tax_ids
-            flattened_taxes = self.env['account.tax']
-            while taxes_to_flatten:
-                tax = taxes_to_flatten[0]
-                taxes_to_flatten -= tax
-                flattened_taxes += tax
-                taxes_to_flatten += tax.children_tax_ids
-
-            analytic_tag_ids = [(4, analytic_tag.id, None) for analytic_tag in line.analytic_tag_ids]
-
-            tax_repartition_field_name = 'invoice_repartition_line_ids' if line.invoice_type in ('in_invoice', 'out_invoice') else 'refund_repartition_line_ids'
-            tag_ids = flattened_taxes.mapped(tax_repartition_field_name).filtered(lambda x: x.repartition_type == 'base').mapped('tag_ids.id')
-            move_line_dict = {
-                'invl_id': line.id,
-                'type': 'src',
-                'name': line.name,
-                'price_unit': line.price_unit,
-                'quantity': line.quantity,
-                'price': line.price_subtotal,
-                'account_id': line.account_id.id,
-                'product_id': line.product_id.id,
-                'uom_id': line.uom_id.id,
-                'account_analytic_id': line.account_analytic_id.id,
-                'analytic_tag_ids': analytic_tag_ids,
-                'tax_ids': [(6, 0, flattened_taxes.ids)],
-                'invoice_id': self.id,
-                'tag_ids': [(6, 0, tag_ids)],
-            }
-            res.append(move_line_dict)
-        return res
-
-    def tax_line_move_line_get(self):
-        self.ensure_one()
-        res = []
-        # loop the invoice.tax.line in reversal sequence
-        for tax_line in sorted(self.tax_line_ids, key=lambda x: -x.sequence):
-            if tax_line.amount_total:
-                analytic_tag_ids = [(4, analytic_tag.id, None) for analytic_tag in tax_line.analytic_tag_ids]
-                res.append({
-                    'invoice_tax_line_id': tax_line.id,
-                    'tax_line_id': tax_line.tax_id.id,
-                    'type': 'tax',
-                    'name': tax_line.name,
-                    'price_unit': tax_line.amount_total,
-                    'quantity': 1,
-                    'price': tax_line.amount_total,
-                    'account_id': tax_line.account_id.id,
-                    'account_analytic_id': tax_line.account_analytic_id.id,
-                    'analytic_tag_ids': analytic_tag_ids,
-                    'invoice_id': self.id,
-                    'tax_ids': tax_line.tax_ids and [(6, 0, tax_line.tax_ids.ids)] or False, # We don't pass an empty recordset here, as it would reset the tax_exibility of the line, due to the condition in account.move.line's create
-                    'tax_repartition_line_id': tax_line.tax_repartition_line_id.id,
-                    'tag_ids': [(6, 0, tax_line.tag_ids.ids)],
-                    'tax_base_amount': tax_line.base,
-                })
-        return res
-
-    def inv_line_characteristic_hashcode(self, invoice_line):
-        """Overridable hashcode generation for invoice lines. Lines having the same hashcode
-        will be grouped together if the journal has the 'group line' option. Of course a module
-        can add fields to invoice lines that would need to be tested too before merging lines
-        or not."""
-        return "%s-%s-%s-%s-%s-%s-%s" % (
-            invoice_line['account_id'],
-            invoice_line.get('tax_ids', 'False'),
-            invoice_line.get('tax_line_id', 'False'),
-            invoice_line.get('product_id', 'False'),
-            invoice_line.get('analytic_account_id', 'False'),
-            invoice_line.get('date_maturity', 'False'),
-            invoice_line.get('analytic_tag_ids', 'False'),
-        )
-
-    def group_lines(self, iml, line):
-        """Merge account move lines (and hence analytic lines) if invoice line hashcodes are equals"""
-        if self.journal_id.group_invoice_lines:
-            line2 = {}
-            for x, y, l in line:
-                tmp = self.inv_line_characteristic_hashcode(l)
-                if tmp in line2:
-                    am = line2[tmp]['debit'] - line2[tmp]['credit'] + (l['debit'] - l['credit'])
-                    line2[tmp]['debit'] = (am > 0) and am or 0.0
-                    line2[tmp]['credit'] = (am < 0) and -am or 0.0
-                    line2[tmp]['amount_currency'] += l['amount_currency']
-                    line2[tmp]['analytic_line_ids'] += l['analytic_line_ids']
-                    qty = l.get('quantity')
-                    if qty:
-                        line2[tmp]['quantity'] = line2[tmp].get('quantity', 0.0) + qty
-                else:
-                    line2[tmp] = l
-            line = []
-            for key, val in line2.items():
-                line.append((0, 0, val))
-        return line
-
-    @api.multi
-    def action_move_create(self):
-        """ Creates invoice related analytics and financial move lines """
-        account_move = self.env['account.move']
-
-        for inv in self:
-            if not inv.journal_id.sequence_id:
-                raise UserError(_('Please define sequence on the journal related to this invoice.'))
-            if not inv.invoice_line_ids.filtered(lambda line: line.account_id):
-                raise UserError(_('Please add at least one invoice line.'))
-            if inv.move_id:
-                continue
-            company_currency = inv.company_id.currency_id
-
-            # create move lines (one per invoice line + eventual taxes and analytic lines)
-            iml = inv.invoice_line_move_line_get()
-            iml += inv.tax_line_move_line_get()
-
-            diff_currency = inv.currency_id != company_currency
-            # create one move line for the total and possibly adjust the other lines amount
-            total, total_currency, iml = inv.compute_invoice_totals(company_currency, iml)
-
-            name = inv.name or ''
-            if inv.payment_term_id:
-                totlines = inv.payment_term_id.with_context(currency_id=company_currency.id).compute(total, inv.date_invoice)
-                res_amount_currency = total_currency
-                for i, t in enumerate(totlines):
-                    if inv.currency_id != company_currency:
-                        amount_currency = company_currency._convert(t[1], inv.currency_id, inv.company_id, inv._get_currency_rate_date() or fields.Date.today())
-                    else:
-                        amount_currency = False
-
-                    # last line: add the diff
-                    res_amount_currency -= amount_currency or 0
-                    if i + 1 == len(totlines):
-                        amount_currency += res_amount_currency
-
-                    iml.append({
-                        'type': 'dest',
-                        'name': name,
-                        'price': t[1],
-                        'account_id': inv.account_id.id,
-                        'date_maturity': t[0],
-                        'amount_currency': diff_currency and amount_currency,
-                        'currency_id': diff_currency and inv.currency_id.id,
-                        'invoice_id': inv.id
-                    })
-            else:
-                iml.append({
-                    'type': 'dest',
-                    'name': name,
-                    'price': total,
-                    'account_id': inv.account_id.id,
-                    'date_maturity': inv.date_due,
-                    'amount_currency': diff_currency and total_currency,
-                    'currency_id': diff_currency and inv.currency_id.id,
-                    'invoice_id': inv.id
-                })
-            part = self.env['res.partner']._find_accounting_partner(inv.partner_id)
-            line = [(0, 0, self.line_get_convert(l, part.id)) for l in iml]
-            line = inv.group_lines(iml, line)
-
-            line = inv.finalize_invoice_move_lines(line)
-
-            date = inv.date or inv.date_invoice
-            move_ref = inv.reference
-            if inv.origin:
-                if move_ref:
-                    move_ref += ' (%s)' % inv.origin
-                else:
-                    move_ref = inv.origin
-            move_vals = {
-                'ref': move_ref,
-                'line_ids': line,
-                'journal_id': inv.journal_id.id,
-                'date': date,
-                'narration': inv.comment,
-                'name': inv.number,
-            }
-            move = account_move.create(move_vals)
-            move.post()
-            # make the invoice point to that move
-            vals = {
-                'move_id': move.id,
-                'date': date,
-                'move_name': move.name,
-            }
-            inv.write(vals)
-        return True
-
-    @api.constrains('cash_rounding_id', 'tax_line_ids')
-    def _check_cash_rounding(self):
-        for inv in self:
-            if inv.cash_rounding_id:
-                rounding_amount = inv.cash_rounding_id.compute_difference(inv.currency_id, inv.amount_total)
-                if rounding_amount != 0.0:
-                    raise UserError(_('The cash rounding cannot be computed because the difference must '
-                                      'be added on the biggest tax found and no tax are specified.\n'
-                                      'Please set up a tax or change the cash rounding method.'))
-
-    @api.multi
-    def _check_duplicate_supplier_reference(self):
-        for invoice in self:
-            # refuse to validate a vendor bill/credit note if there already exists one with the same reference for the same partner,
-            # because it's probably a double encoding of the same bill/credit note
-            if invoice.type in ('in_invoice', 'in_refund') and invoice.reference:
-                if self.search([('type', '=', invoice.type), ('reference', '=', invoice.reference), ('company_id', '=', invoice.company_id.id), ('commercial_partner_id', '=', invoice.commercial_partner_id.id), ('id', '!=', invoice.id)]):
-                    raise UserError(_("Duplicated vendor reference detected. You probably encoded twice the same vendor bill/credit note."))
-
-    @api.multi
-    def invoice_validate(self):
-        for invoice in self.filtered(lambda invoice: invoice.partner_id not in invoice.message_partner_ids):
-            invoice.message_subscribe([invoice.partner_id.id])
-
-        for invoice in self:
-            vals = {'state': 'open'}
-            if not invoice.date_due:
-                vals['date_due'] = vals.get('date_invoice', invoice.date_invoice)
-
-
-            # Auto-compute reference, if not already existing and if configured on company
-            if not invoice.reference and invoice.type == 'out_invoice':
-                vals['reference'] = invoice._get_computed_reference()
-
-            invoice.write(vals)
-
-        self._check_duplicate_supplier_reference()
-        return True
-
-    @api.model
-    def line_get_convert(self, line, part):
-        return self.env['product.product']._convert_prepared_anglosaxon_line(line, part)
-
-    @api.multi
-    def action_cancel(self):
-        moves = self.env['account.move']
-        for inv in self:
-            if inv.move_id:
-                moves += inv.move_id
-            #unreconcile all journal items of the invoice, since the cancellation will unlink them anyway
-            inv.move_id.line_ids.filtered(lambda x: x.account_id.reconcile).remove_move_reconcile()
-
-        # First, set the invoices as cancelled and detach the move ids
-        self.write({'state': 'cancel', 'move_id': False})
-        if moves:
-            # second, invalidate the move(s)
-            moves.button_cancel()
-            # delete the move this invoice was pointing to
-            # Note that the corresponding move_lines and move_reconciles
-            # will be automatically deleted too
-            moves.unlink()
-        return True
-
-    ###################
-
-    @api.multi
-    def name_get(self):
-        TYPES = {
-            'out_invoice': _('Invoice'),
-            'in_invoice': _('Vendor Bill'),
-            'out_refund': _('Credit Note'),
-            'in_refund': _('Vendor Credit note'),
-        }
-        result = []
-        for inv in self:
-            result.append((inv.id, "%s %s" % (inv.number or TYPES[inv.type], inv.name or '')))
-        return result
-
-    @api.model
-    def _name_search(self, name, args=None, operator='ilike', limit=100, name_get_uid=None):
-        args = args or []
-        invoice_ids = []
-        if name:
-            invoice_ids = self._search([('number', '=', name)] + args, limit=limit, access_rights_uid=name_get_uid)
-        if not invoice_ids:
-            invoice_ids = self._search([('name', operator, name)] + args, limit=limit, access_rights_uid=name_get_uid)
-        return self.browse(invoice_ids).name_get()
-
-    @api.model
-    def _refund_cleanup_lines(self, lines):
-        """ Convert records to dict of values suitable for one2many line creation
-
-            :param recordset lines: records to convert
-            :return: list of command tuple for one2many line creation [(0, 0, dict of valueis), ...]
-        """
-        result = []
-        for line in lines:
-            values = {}
-            for name, field in line._fields.items():
-                if name in MAGIC_COLUMNS:
-                    continue
-                elif field.type == 'many2one':
-                    values[name] = line[name].id
-                elif field.type not in ['many2many', 'one2many']:
-                    values[name] = line[name]
-                elif name == 'invoice_line_tax_ids':
-                    values[name] = [(6, 0, line[name].ids)]
-                elif name == 'analytic_tag_ids':
-                    values[name] = [(6, 0, line[name].ids)]
-            result.append((0, 0, values))
-        return result
-
-    def _get_refund_common_fields(self):
-        return ['partner_id', 'payment_term_id', 'account_id', 'currency_id', 'journal_id']
-
-    @api.model
-    def _get_refund_prepare_fields(self):
-        return ['name', 'reference', 'comment', 'date_due']
-
-    @api.model
-    def _get_refund_modify_read_fields(self):
-        read_fields = ['type', 'number', 'invoice_line_ids', 'tax_line_ids',
-                       'date']
-        return self._get_refund_common_fields() + self._get_refund_prepare_fields() + read_fields
-
-    @api.model
-    def _get_refund_copy_fields(self):
-        copy_fields = ['company_id', 'user_id', 'fiscal_position_id']
-        return self._get_refund_common_fields() + self._get_refund_prepare_fields() + copy_fields
-
-    def _get_currency_rate_date(self):
-        return self.date or self.date_invoice
-
-    @api.model
-    def _create_refund_repartition_mapping(self, taxes):
-        """ Creates a mapping between tax and refund repartition lines of the
-        provided taxes, using the sequence of repartition lines to match them.
-        This function is used in order to fix account.invoice.tax objects generated
-        for refunds when tax amounts have been modified manually.
-
-        :return: A dictionnary, with invoice repartition line ids as keys, and refund
-        repartition lines as values
-        """
-        rslt = {}
-        for tax in taxes:
-            index = 0
-            while(index < len(tax.invoice_repartition_line_ids)):
-                # _validate_repartition_lines constraint on taxes ensure invoice and refund repartition are equal, and in the same order
-                inv_rep_ln = tax.invoice_repartition_line_ids[index]
-                ref_rep_ln = tax.refund_repartition_line_ids[index]
-                if inv_rep_ln.repartition_type == 'tax':
-                    rslt[inv_rep_ln.id] = ref_rep_ln
-                index += 1
-
-        return rslt
-
-    @api.model
-    def _prepare_refund(self, invoice, date_invoice=None, date=None, description=None, journal_id=None):
-        """ Prepare the dict of values to create the new credit note from the invoice.
-            This method may be overridden to implement custom
-            credit note generation (making sure to call super() to establish
-            a clean extension chain).
-
-            :param record invoice: invoice as credit note
-            :param string date_invoice: credit note creation date from the wizard
-            :param integer date: force date from the wizard
-            :param string description: description of the credit note from the wizard
-            :param integer journal_id: account.journal from the wizard
-            :return: dict of value to create() the credit note
-        """
-        values = {}
-        for field in self._get_refund_copy_fields():
-            if invoice._fields[field].type == 'many2one':
-                values[field] = invoice[field].id
-            else:
-                values[field] = invoice[field] or False
-
-        values['invoice_line_ids'] = self._refund_cleanup_lines(invoice.invoice_line_ids)
-
-        if journal_id:
-            journal = self.env['account.journal'].browse(journal_id)
-        elif invoice['type'] == 'in_invoice':
-            journal = self.env['account.journal'].search([('type', '=', 'purchase')], limit=1)
-        else:
-            journal = self.env['account.journal'].search([('type', '=', 'sale')], limit=1)
-        values['journal_id'] = journal.id
-
-        values['type'] = TYPE2REFUND[invoice['type']]
-        values['date_invoice'] = date_invoice or fields.Date.context_today(invoice)
-        values['state'] = 'draft'
-        values['number'] = False
-        values['origin'] = invoice.number
-        values['payment_term_id'] = False
-        values['refund_invoice_id'] = invoice.id
-
-        if values['type'] == 'in_refund':
-            partner_bank_result = self._get_partner_bank_id(values['company_id'])
-            if partner_bank_result:
-                values['partner_bank_id'] = partner_bank_result.id
-
-        if date:
-            values['date'] = date
-        if description:
-            values['name'] = description
-
-        # Treat refund tax lines.
-        # We copy them from the invoice and replace their account_id and
-        # tag_ids based on the refund repartition of the corresponding taxes.
-        tax_rep_ln_mapping = {}
-        for invoice_tax_entry in invoice.tax_line_ids:
-            if not invoice_tax_entry.tax_repartition_line_id.id in tax_rep_ln_mapping:
-                tax_rep_ln_mapping[invoice_tax_entry.tax_id.id] = self._create_refund_repartition_mapping(invoice_tax_entry.tax_id)
-
-        tax_line_vals = []
-        for invoice_tax_entry in invoice.tax_line_ids:
-            ref_rep_ln = tax_rep_ln_mapping[invoice_tax_entry.tax_id.id][invoice_tax_entry.tax_repartition_line_id.id]
-            tax_line_vals.append({
-                'name': invoice_tax_entry.name,
-                'tax_id': invoice_tax_entry.tax_id.id,
-                'tax_repartition_line_id': ref_rep_ln.id,
-                'account_id': ref_rep_ln.account_id.id or invoice_tax_entry.account_id.id, # If the refund repartition line has no account set, we use the one from the original invoice
-                'account_analytic_id': invoice_tax_entry.account_analytic_id.id,
-                'analytic_tag_ids': [(6, 0, invoice_tax_entry.analytic_tag_ids.ids)],
-                'amount': invoice_tax_entry.amount,
-                'amount_rounding': invoice_tax_entry.amount_rounding,
-                'manual': invoice_tax_entry.manual,
-                'sequence': invoice_tax_entry.sequence,
-                'base': invoice_tax_entry.base,
-                'tax_ids': [(6, 0, invoice_tax_entry.tax_ids.ids)],
-                'tag_ids': [(6, 0, ref_rep_ln.tag_ids.ids)],
-            })
-        values['tax_line_ids'] = [(0, 0, tax_line_val) for tax_line_val in tax_line_vals]
-
-        return values
-
-    @api.multi
-    @api.returns('self')
-    def refund(self, date_invoice=None, date=None, description=None, journal_id=None):
-        new_invoices = self.browse()
-        for invoice in self:
-            # create the new invoice
-            values = self._prepare_refund(invoice, date_invoice=date_invoice, date=date,
-                                    description=description, journal_id=journal_id)
-            refund_invoice = self.create(values)
-            if invoice.type == 'out_invoice':
-                message = _("This customer invoice credit note has been created from: <a href=# data-oe-model=account.invoice data-oe-id=%d>%s</a><br>Reason: %s") % (invoice.id, invoice.number, description)
-            else:
-                message = _("This vendor bill credit note has been created from: <a href=# data-oe-model=account.invoice data-oe-id=%d>%s</a><br>Reason: %s") % (invoice.id, invoice.number, description)
-
-            refund_invoice.message_post(body=message)
-            new_invoices += refund_invoice
-        return new_invoices
-
-    def _prepare_payment_vals(self, pay_journal, pay_amount=None, date=None, writeoff_acc=None, communication=None):
-        payment_type = self.type in ('out_invoice', 'in_refund') and 'inbound' or 'outbound'
-        if payment_type == 'inbound':
-            payment_method = self.env.ref('account.account_payment_method_manual_in')
-            journal_payment_methods = pay_journal.inbound_payment_method_ids
-        else:
-            payment_method = self.env.ref('account.account_payment_method_manual_out')
-            journal_payment_methods = pay_journal.outbound_payment_method_ids
-
-        if not communication:
-            communication = self.type in ('in_invoice', 'in_refund') and self.reference or self.number
-            if self.origin:
-                communication = '%s (%s)' % (communication, self.origin)
-
-        payment_vals = {
-            'invoice_ids': [(6, 0, self.ids)],
-            'amount': pay_amount or self.residual,
-            'payment_date': date or fields.Date.context_today(self),
-            'communication': communication,
-            'partner_id': self.partner_id.id,
-            'partner_type': self.type in ('out_invoice', 'out_refund') and 'customer' or 'supplier',
-            'journal_id': pay_journal.id,
-            'payment_type': payment_type,
-            'payment_method_id': payment_method.id,
-            'payment_difference_handling': writeoff_acc and 'reconcile' or 'open',
-            'writeoff_account_id': writeoff_acc and writeoff_acc.id or False,
-        }
-        return payment_vals
-
-    @api.multi
-    def pay_and_reconcile(self, pay_journal, pay_amount=None, date=None, writeoff_acc=None):
-        """ Create and post an account.payment for the invoice self, which creates a journal entry that reconciles the invoice.
-
-            :param pay_journal: journal in which the payment entry will be created
-            :param pay_amount: amount of the payment to register, defaults to the residual of the invoice
-            :param date: payment date, defaults to fields.Date.context_today(self)
-            :param writeoff_acc: account in which to create a writeoff if pay_amount < self.residual, so that the invoice is fully paid
-        """
-        if isinstance(pay_journal, int):
-            pay_journal = self.env['account.journal'].browse([pay_journal])
-        assert len(self) == 1, "Can only pay one invoice at a time."
-
-        payment_vals = self._prepare_payment_vals(pay_journal, pay_amount=pay_amount, date=date, writeoff_acc=writeoff_acc)
-        payment = self.env['account.payment'].create(payment_vals)
-        payment.post()
-
-        return True
-
-    @api.multi
-    def _creation_subtype(self):
-        if self.type in ('out_invoice', 'out_refund'):
-            return self.env.ref('account.mt_invoice_created')
-        return super(AccountInvoice, self)._creation_subtype()
-
-    @api.multi
-    def _track_subtype(self, init_values):
-        self.ensure_one()
-        if 'state' in init_values and self.state == 'paid' and self.type in ('out_invoice', 'out_refund'):
-            return self.env.ref('account.mt_invoice_paid')
-        elif 'state' in init_values and self.state == 'open' and self.type in ('out_invoice', 'out_refund'):
-            return self.env.ref('account.mt_invoice_validated')
-        return super(AccountInvoice, self)._track_subtype(init_values)
-
-    def _amount_by_group(self):
-        for invoice in self:
-            currency = invoice.currency_id or invoice.company_id.currency_id
-            fmt = partial(formatLang, invoice.with_context(lang=invoice.partner_id.lang).env, currency_obj=currency)
-            res = {}
-            for line in invoice.tax_line_ids:
-                tax = line.tax_id
-                group_key = (tax.tax_group_id, tax.amount_type, tax.amount)
-                res.setdefault(group_key, {'base': 0.0, 'amount': 0.0})
-                res[group_key]['amount'] += line.amount_total
-                res[group_key]['base'] += line.base
-            res = sorted(res.items(), key=lambda l: l[0][0].sequence)
-            invoice.amount_by_group = [(
-                r[0][0].name, r[1]['amount'], r[1]['base'],
-                fmt(r[1]['amount']), fmt(r[1]['base']),
-                len(res),
-            ) for r in res]
-
-    @api.multi
-    def preview_invoice(self):
-        self.ensure_one()
-        return {
-            'type': 'ir.actions.act_url',
-            'target': 'self',
-            'url': self.get_portal_url(),
-        }
-
-    def _get_intrastat_country_id(self):
-        return self.partner_id.country_id.id
-
-    def _get_onchange_create(self):
-        return OrderedDict([
-            ('_onchange_partner_id', ['account_id', 'payment_term_id', 'fiscal_position_id', 'partner_bank_id']),
-            ('_onchange_journal_id', ['currency_id']),
-        ])
-
-    def _set_name_and_date_invoice(self):
-        for invoice in self:
-            if (invoice.move_name and invoice.move_name != '/'):
-                new_name = invoice.move_name
-            else:
-                new_name = False
-                journal = invoice.journal_id
-                if journal.sequence_id:
-                    # If invoice is actually refund and journal has a refund_sequence then use that one or use the regular one
-                    sequence = journal.sequence_id
-                    if invoice.type in ['out_refund', 'in_refund'] and journal.refund_sequence:
-                        if not journal.refund_sequence_id:
-                            raise UserError(_('Please define a sequence for the credit notes'))
-                        sequence = journal.refund_sequence_id
-
-                    new_name = sequence.with_context(ir_sequence_date=invoice.date or invoice.date_invoice).next_by_id()
-                else:
-                    raise UserError(_('Please define a sequence on the journal.'))
-            #give the invoice its number directly as it's needed in _get_computed_reference()
-            invoice.number = new_name
-            if not invoice.date_invoice:
-                invoice.date_invoice = fields.Date.context_today(self)
-
-
-class AccountInvoiceLine(models.Model):
-    _name = "account.invoice.line"
-    _description = "Invoice Line"
-    _order = "invoice_id,sequence,id"
-
-    @api.one
-    @api.depends('price_unit', 'discount', 'invoice_line_tax_ids', 'quantity',
-        'product_id', 'invoice_id.partner_id', 'invoice_id.currency_id', 'invoice_id.company_id',
-        'invoice_id.date_invoice', 'invoice_id.date')
-    def _compute_price(self):
-        currency = self.invoice_id and self.invoice_id.currency_id or None
-        price = self.price_unit * (1 - (self.discount or 0.0) / 100.0)
-        taxes = False
-        if self.invoice_line_tax_ids:
-            taxes = self.invoice_line_tax_ids.compute_all(price, currency, self.quantity, product=self.product_id, partner=self.invoice_id.partner_id, is_refund=self.invoice_id.type in ('in_refund', 'out_refund'))
-        self.price_subtotal = price_subtotal_signed = taxes['total_excluded'] if taxes else self.quantity * price
-        self.price_total = taxes['total_included'] if taxes else self.price_subtotal
-        if self.invoice_id.currency_id and self.invoice_id.currency_id != self.invoice_id.company_id.currency_id:
-            currency = self.invoice_id.currency_id
-            date = self.invoice_id._get_currency_rate_date()
-            price_subtotal_signed = currency._convert(price_subtotal_signed, self.invoice_id.company_id.currency_id, self.company_id or self.env.company, date or fields.Date.today())
-        sign = self.invoice_id.type in ['in_refund', 'out_refund'] and -1 or 1
-        self.price_subtotal_signed = price_subtotal_signed * sign
-
-    @api.model
-    def _default_account(self):
-        if self._context.get('journal_id'):
-            journal = self.env['account.journal'].browse(self._context.get('journal_id'))
-            if self._context.get('type') in ('out_invoice', 'in_refund'):
-                return journal.default_credit_account_id.id
-            return journal.default_debit_account_id.id
-
-    def _get_price_tax(self):
-        for l in self:
-            l.price_tax = l.price_total - l.price_subtotal
-
-    name = fields.Text(string='Description', required=True)
-    origin = fields.Char(string='Source Document',
-        help="Reference of the document that produced this invoice.")
-    sequence = fields.Integer(default=10,
-        help="Gives the sequence of this line when displaying the invoice.")
-    invoice_id = fields.Many2one('account.invoice', string='Invoice Reference',
-        ondelete='cascade', index=True)
-    invoice_type = fields.Selection(related='invoice_id.type', readonly=True)
-    uom_id = fields.Many2one('uom.uom', string='Unit of Measure',
-        ondelete='set null', index=True, oldname='uos_id')
-    product_id = fields.Many2one('product.product', string='Product',
-        ondelete='restrict', index=True)
-    account_id = fields.Many2one('account.account', string='Account', domain=[('deprecated', '=', False)],
-        default=_default_account,
-        help="The income or expense account related to the selected product.")
-    price_unit = fields.Float(string='Unit Price', required=True, digits=dp.get_precision('Product Price'))
-    price_subtotal = fields.Monetary(string='Amount (without Taxes)',
-        store=True, readonly=True, compute='_compute_price', help="Total amount without taxes")
-    price_total = fields.Monetary(string='Amount (with Taxes)',
-        store=True, readonly=True, compute='_compute_price', help="Total amount with taxes")
-    price_subtotal_signed = fields.Monetary(string='Amount Signed', currency_field='company_currency_id',
-        store=True, readonly=True, compute='_compute_price',
-        help="Total amount in the currency of the company, negative for credit note.")
-    price_tax = fields.Monetary(string='Tax Amount', compute='_get_price_tax', store=False)
-    quantity = fields.Float(string='Quantity', digits=dp.get_precision('Product Unit of Measure'),
-        required=True, default=1)
-    discount = fields.Float(string='Discount (%)', digits=dp.get_precision('Discount'),
-        default=0.0)
-    invoice_line_tax_ids = fields.Many2many('account.tax',
-        'account_invoice_line_tax', 'invoice_line_id', 'tax_id',
-        string='Taxes', domain=[('type_tax_use','!=','none'), '|', ('active', '=', False), ('active', '=', True)], oldname='invoice_line_tax_id')
-    account_analytic_id = fields.Many2one('account.analytic.account',
-        string='Analytic Account')
-    analytic_tag_ids = fields.Many2many('account.analytic.tag', string='Analytic Tags')
-    company_id = fields.Many2one('res.company', string='Company',
-        related='invoice_id.company_id', store=True, readonly=True, related_sudo=False)
-    partner_id = fields.Many2one('res.partner', string='Partner',
-        related='invoice_id.partner_id', store=True, readonly=True, related_sudo=False)
-    currency_id = fields.Many2one('res.currency', related='invoice_id.currency_id', store=True, related_sudo=False, readonly=False)
-    company_currency_id = fields.Many2one('res.currency', related='invoice_id.company_currency_id', readonly=True, related_sudo=False)
-    is_rounding_line = fields.Boolean(string='Rounding Line', help='Is a rounding line in case of cash rounding.')
-
-    display_type = fields.Selection([
-        ('line_section', "Section"),
-        ('line_note', "Note")], default=False, help="Technical field for UX purpose.")
-
-    @api.model
-    def fields_view_get(self, view_id=None, view_type='form', toolbar=False, submenu=False):
-        res = super(AccountInvoiceLine, self).fields_view_get(
-            view_id=view_id, view_type=view_type, toolbar=toolbar, submenu=submenu)
-        if self._context.get('type'):
-            doc = etree.XML(res['arch'])
-            for node in doc.xpath("//field[@name='product_id']"):
-                if self._context['type'] in ('in_invoice', 'in_refund'):
-                    # Hack to fix the stable version 8.0 -> saas-12
-                    # purchase_ok will be moved from purchase to product in master #13271
-                    if 'purchase_ok' in self.env['product.template']._fields:
-                        node.set('domain', "[('purchase_ok', '=', True)]")
-                else:
-                    node.set('domain', "[('sale_ok', '=', True)]")
-            res['arch'] = etree.tostring(doc, encoding='unicode')
-        return res
-
-    @api.v8
-    def get_invoice_line_account(self, type, product, fpos, company):
-        accounts = product.product_tmpl_id.get_product_accounts(fpos)
-        if type in ('out_invoice', 'out_refund'):
-            return accounts['income']
-        return accounts['expense']
-
-    def _set_currency(self):
-        company = self.invoice_id.company_id
-        currency = self.invoice_id.currency_id
-        if company and currency:
-            if company.currency_id != currency:
-                self.price_unit = self.price_unit * currency.with_context(dict(self._context or {}, date=self.invoice_id.date_invoice)).rate
-
-    def _set_taxes(self):
-        """ Used in on_change to set taxes and price"""
-        self.ensure_one()
-
-        # Keep only taxes of the company
-        company_id = self.company_id or self.env.company
-
-        if self.invoice_id.type in ('out_invoice', 'out_refund'):
-            taxes = self.product_id.taxes_id.filtered(lambda r: r.company_id == company_id) or self.account_id.tax_ids or self.invoice_id.company_id.account_sale_tax_id
-        else:
-            taxes = self.product_id.supplier_taxes_id.filtered(lambda r: r.company_id == company_id) or self.account_id.tax_ids or self.invoice_id.company_id.account_purchase_tax_id
-
-        self.invoice_line_tax_ids = fp_taxes = self.invoice_id.fiscal_position_id.map_tax(taxes, self.product_id, self.invoice_id.partner_id)
-
-        fix_price = self.env['account.tax']._fix_tax_included_price
-        if self.invoice_id.type in ('in_invoice', 'in_refund'):
-            prec = self.env['decimal.precision'].precision_get('Product Price')
-            if not self.price_unit or float_compare(self.price_unit, self.product_id.standard_price, precision_digits=prec) == 0:
-                self.price_unit = fix_price(self.product_id.standard_price, taxes, fp_taxes)
-                self._set_currency()
-        else:
-            self.price_unit = fix_price(self.product_id.lst_price, taxes, fp_taxes)
-            self._set_currency()
-
-    @api.onchange('product_id')
-    def _onchange_product_id(self):
-        domain = {}
-        if not self.invoice_id:
-            return
-
-        part = self.invoice_id.partner_id
-        fpos = self.invoice_id.fiscal_position_id
-        company = self.invoice_id.company_id
-        currency = self.invoice_id.currency_id
-        type = self.invoice_id.type
-
-        if not part:
-            warning = {
-                    'title': _('Warning!'),
-                    'message': _('You must first select a partner.'),
-                }
-            return {'warning': warning}
-
-        if not self.product_id:
-            if type not in ('in_invoice', 'in_refund'):
-                self.price_unit = 0.0
-            domain['uom_id'] = []
-        else:
-            self_lang = self
-            if part.lang:
-                self_lang = self.with_context(lang=part.lang)
-
-            product = self_lang.product_id
-            account = self.get_invoice_line_account(type, product, fpos, company)
-            if account:
-                self.account_id = account.id
-            self._set_taxes()
-
-            product_name = self_lang._get_invoice_line_name_from_product()
-            if product_name != None:
-                self.name = product_name
-
-            if not self.uom_id or product.uom_id.category_id.id != self.uom_id.category_id.id:
-                self.uom_id = product.uom_id.id
-            domain['uom_id'] = [('category_id', '=', product.uom_id.category_id.id)]
-
-            if company and currency:
-
-                if self.uom_id and self.uom_id.id != product.uom_id.id:
-                    self.price_unit = product.uom_id._compute_price(self.price_unit, self.uom_id)
-        return {'domain': domain}
-
-    def _get_invoice_line_name_from_product(self):
-        """ Returns the automatic name to give to the invoice line depending on
-        the product it is linked to.
-        """
-        self.ensure_one()
-        if not self.product_id:
-            return ''
-        invoice_type = self.invoice_id.type
-        rslt = self.product_id.partner_ref
-        if invoice_type in ('in_invoice', 'in_refund'):
-            if self.product_id.description_purchase:
-                rslt += '\n' + self.product_id.description_purchase
-        else:
-            if self.product_id.description_sale:
-                rslt += '\n' + self.product_id.description_sale
-
-        return rslt
-
-    @api.onchange('account_id')
-    def _onchange_account_id(self):
-        if not self.account_id:
-            return
-        if not self.product_id:
-            fpos = self.invoice_id.fiscal_position_id
-            default_tax = self.invoice_id.type in ('out_invoice', 'out_refund') and self.invoice_id.company_id.account_sale_tax_id or self.invoice_id.company_id.account_purchase_tax_id
-            self.invoice_line_tax_ids = fpos.map_tax(self.account_id.tax_ids or default_tax, partner=self.partner_id)
-        elif not self.price_unit:
-            self._set_taxes()
-
-
-    @api.onchange('uom_id')
-    def _onchange_uom_id(self):
-        warning = {}
-        result = {}
-        if not self.uom_id:
-            self.price_unit = 0.0
-
-        if self.product_id and self.uom_id:
-            if self.invoice_id.type in ('in_invoice', 'in_refund'):
-                price_unit = self.product_id.standard_price
-            else:
-                price_unit = self.product_id.lst_price
-            self.price_unit = self.product_id.uom_id._compute_price(price_unit, self.uom_id)
-            self._set_currency()
-
-            if self.product_id.uom_id.category_id.id != self.uom_id.category_id.id:
-                warning = {
-                    'title': _('Warning!'),
-                    'message': _('The selected unit of measure has to be in the same category as the product unit of measure.'),
-                }
-                self.uom_id = self.product_id.uom_id.id
-        if warning:
-            result['warning'] = warning
-        return result
-
-    def _set_additional_fields(self):
-        """ Some modules, such as Purchase, provide a feature to add automatically pre-filled
-            invoice lines. However, these modules might not be aware of extra fields which are
-            added by extensions of the accounting module.
-            This method is intended to be overridden by these extensions, so that any new field can
-            easily be auto-filled as well.
-        """
-        pass
-
-    @api.multi
-    def unlink(self):
-        if self.filtered(lambda r: r.invoice_id and r.invoice_id.state != 'draft'):
-            raise UserError(_('You can only delete an invoice line if the invoice is in draft state.'))
-        return super(AccountInvoiceLine, self).unlink()
-
-    def _prepare_invoice_line(self):
-        data = {
-            'name': self.name,
-            'origin': self.origin,
-            'uom_id': self.uom_id.id,
-            'product_id': self.product_id.id,
-            'account_id': self.account_id.id,
-            'price_unit': self.price_unit,
-            'quantity': self.quantity,
-            'discount': self.discount,
-            'account_analytic_id': self.account_analytic_id.id,
-            'analytic_tag_ids': self.analytic_tag_ids.ids,
-            'invoice_line_tax_ids': self.invoice_line_tax_ids.ids
-        }
-        return data
-
-    @api.model_create_multi
-    def create(self, vals_list):
-        for vals in vals_list:
-            if vals.get('display_type', self.default_get(['display_type'])['display_type']):
-                vals.update(price_unit=0, account_id=False, quantity=0)
-        return super(AccountInvoiceLine, self).create(vals_list)
-
-    @api.multi
-    def write(self, values):
-        if 'display_type' in values and self.filtered(lambda line: line.display_type != values.get('display_type')):
-            raise UserError("You cannot change the type of an invoice line. Instead you should delete the current line and create a new line of the proper type.")
-        return super(AccountInvoiceLine, self).write(values)
-
-    _sql_constraints = [
-        ('accountable_required_fields',
-            "CHECK(display_type IS NOT NULL OR account_id IS NOT NULL)",
-            "Missing required account on accountable invoice line."),
-
-        ('non_accountable_fields_null',
-            "CHECK(display_type IS NULL OR (price_unit = 0 AND account_id IS NULL and quantity = 0))",
-            "Forbidden unit price, account and quantity on non-accountable invoice line"),
-    ]
-
-
-class AccountInvoiceTax(models.Model):
-    _name = "account.invoice.tax"
-    _description = "Invoice Tax"
-    _order = 'sequence, id desc'
-
-    def _prepare_invoice_tax_val(self):
-        self.ensure_one()
-        return {
-            'tax_id': self.tax_id.id,
-            'account_id': self.account_id.id,
-            'account_analytic_id': self.account_analytic_id.id,
-            'analytic_tag_ids': self.analytic_tag_ids.ids or False,
-        }
-
-    invoice_id = fields.Many2one('account.invoice', string='Invoice', ondelete='cascade', index=True)
-    name = fields.Char(string='Tax Description', required=True)
-    tax_id = fields.Many2one('account.tax', string='Tax', ondelete='restrict')
-    tax_repartition_line_id = fields.Many2one(string="Originating Repartition Line", comodel_name='account.tax.repartition.line')
-    account_id = fields.Many2one('account.account', string='Tax Account', required=True, domain=[('deprecated', '=', False)])
-    account_analytic_id = fields.Many2one('account.analytic.account', string='Analytic account')
-    analytic_tag_ids = fields.Many2many('account.analytic.tag', string='Analytic Tags')
-    amount = fields.Monetary('Tax Amount')
-    amount_rounding = fields.Monetary('Amount Delta')
-    amount_total = fields.Monetary(string="Amount Total", compute='_compute_amount_total')
-    manual = fields.Boolean(default=True)
-    sequence = fields.Integer(help="Gives the sequence order when displaying a list of invoice tax.")
-    company_id = fields.Many2one('res.company', string='Company', related='account_id.company_id', store=True, readonly=True)
-    currency_id = fields.Many2one('res.currency', related='invoice_id.currency_id', store=True, readonly=True)
-    base = fields.Monetary(string='Base')
-    tax_ids = fields.Many2many('account.tax', string='Affecting Base Taxes', help='Taxes whose base amount needs has to be affected by this tax line.')
-    tag_ids = fields.Many2many(string="Tags", comodel_name='account.account.tag', help="The taxes that will be applied on the move line generated for this tax entry")
-
-    @api.depends('amount', 'amount_rounding')
-    def _compute_amount_total(self):
-        for tax_line in self:
-            tax_line.amount_total = tax_line.amount + tax_line.amount_rounding

--- a/addons/account/models/account_journal_dashboard.py
+++ b/addons/account/models/account_journal_dashboard.py
@@ -9,6 +9,9 @@ from odoo.tools import DEFAULT_SERVER_DATE_FORMAT as DF, safe_eval
 from odoo.tools.misc import formatLang, format_date as odoo_format_date
 import random
 
+import ast
+
+
 class account_journal(models.Model):
     _inherit = "account.journal"
 
@@ -157,12 +160,12 @@ class account_journal(models.Model):
         start_date = (first_day_of_week + timedelta(days=-7))
         for i in range(0,6):
             if i == 0:
-                query += "("+select_sql_clause+" and date_due < '"+start_date.strftime(DF)+"')"
+                query += "("+select_sql_clause+" and invoice_date_due < '"+start_date.strftime(DF)+"')"
             elif i == 5:
-                query += " UNION ALL ("+select_sql_clause+" and date_due >= '"+start_date.strftime(DF)+"')"
+                query += " UNION ALL ("+select_sql_clause+" and invoice_date_due >= '"+start_date.strftime(DF)+"')"
             else:
                 next_date = start_date + timedelta(days=7)
-                query += " UNION ALL ("+select_sql_clause+" and date_due >= '"+start_date.strftime(DF)+"' and date_due < '"+next_date.strftime(DF)+"')"
+                query += " UNION ALL ("+select_sql_clause+" and invoice_date_due >= '"+start_date.strftime(DF)+"' and invoice_date_due < '"+next_date.strftime(DF)+"')"
                 start_date = next_date
 
         self.env.cr.execute(query, query_args)
@@ -190,9 +193,17 @@ class account_journal(models.Model):
         the bar graph's data as its first element, and the arguments dictionary
         for it as its second.
         """
-        return ("""SELECT sum(residual_company_signed) as total, min(date_due) as aggr_date
-               FROM account_invoice
-               WHERE journal_id = %(journal_id)s and state = 'open'""", {'journal_id':self.id})
+        return ('''
+            SELECT 
+                SUM((CASE WHEN move.type IN ('out_refund', 'in_refund') THEN -1 else 1 END) * line.amount_residual) AS total,
+                MIN(invoice_date_due) AS aggr_date
+            FROM account_move_line line
+            JOIN account_move move ON move.id = line.move_id
+            WHERE move.journal_id = %(journal_id)s
+            AND move.state = 'posted'
+            AND move.invoice_payment_state = 'not_paid'
+            AND move.type IN ('out_invoice', 'out_refund', 'in_invoice', 'in_refund', 'out_receipt', 'in_receipt')
+        ''', {'journal_id': self.id})
 
     @api.multi
     def get_journal_dashboard_datas(self):
@@ -241,7 +252,20 @@ class account_journal(models.Model):
             query_results_drafts = self.env.cr.dictfetchall()
 
             today = fields.Date.today()
-            query = """SELECT residual_signed as amount_total, currency_id AS currency, type, date_invoice, company_id FROM account_invoice WHERE journal_id = %s AND date <= %s AND state = 'open';"""
+            query = '''
+                SELECT 
+                    (CASE WHEN type IN ('out_refund', 'in_refund') THEN -1 ELSE 1 END) * amount_residual AS amount_total, 
+                    currency_id AS currency,
+                    type, 
+                    invoice_date, 
+                    company_id
+                FROM account_move move
+                WHERE journal_id = %s 
+                AND date <= %s 
+                AND state = 'posted'
+                AND invoice_payment_state = 'not_paid'
+                AND type IN ('out_invoice', 'out_refund', 'in_invoice', 'in_refund', 'out_receipt', 'in_receipt');
+            '''
             self.env.cr.execute(query, (self.id, today))
             late_query_results = self.env.cr.dictfetchall()
             curr_cache = {}
@@ -282,9 +306,19 @@ class account_journal(models.Model):
         data as its first element, and the arguments dictionary to use to run
         it as its second.
         """
-        return ("""SELECT state, residual_signed as amount_total, currency_id AS currency, type, date_invoice, company_id
-                  FROM account_invoice
-                  WHERE journal_id = %(journal_id)s AND state = 'open';""", {'journal_id':self.id})
+        return ('''
+            SELECT 
+                (CASE WHEN move.type IN ('out_refund', 'in_refund') THEN -1 ELSE 1 END) * move.amount_residual AS amount_total, 
+                move.currency_id AS currency, 
+                move.type, 
+                move.invoice_date, 
+                move.company_id
+            FROM account_move move
+            WHERE move.journal_id = %(journal_id)s 
+            AND move.state = 'posted'
+            AND move.invoice_payment_state = 'not_paid'
+            AND move.type IN ('out_invoice', 'out_refund', 'in_invoice', 'in_refund', 'out_receipt', 'in_receipt');
+        ''', {'journal_id': self.id})
 
     def _get_draft_bills_query(self):
         """
@@ -292,18 +326,19 @@ class account_journal(models.Model):
         gather the bills in draft state data, and the arguments
         dictionary to use to run it as its second.
         """
-        # there is no account_move_lines for draft invoices, so no relevant residual_signed value
-        return ("""SELECT state,
-                    (CASE WHEN inv.type in ('out_invoice', 'in_invoice')
-                        THEN inv.amount_total
-                        ELSE (-1 * inv.amount_total)
-                    END) AS amount_total,
-                    inv.currency_id AS currency,
-                    inv.type,
-                    inv.date_invoice,
-                    inv.company_id
-                  FROM account_invoice inv
-                  WHERE journal_id = %(journal_id)s AND state = 'draft';""", {'journal_id':self.id})
+        return ('''
+            SELECT 
+                (CASE WHEN move.type IN ('out_refund', 'in_refund') THEN -1 ELSE 1 END) * move.amount_total AS amount_total, 
+                move.currency_id AS currency, 
+                move.type, 
+                move.invoice_date, 
+                move.company_id
+            FROM account_move move
+            WHERE move.journal_id = %(journal_id)s 
+            AND move.state = 'draft'
+            AND move.invoice_payment_state = 'not_paid'
+            AND move.type IN ('out_invoice', 'out_refund', 'in_invoice', 'in_refund', 'out_receipt', 'in_receipt');
+        ''', {'journal_id': self.id})
 
     def _count_results_and_sum_amounts(self, results_dict, target_currency, curr_cache=None):
         """ Loops on a query result to count the total number of invoices and sum
@@ -320,7 +355,7 @@ class account_journal(models.Model):
             cur = self.env['res.currency'].browse(result.get('currency'))
             company = self.env['res.company'].browse(result.get('company_id')) or self.env.company
             rslt_count += 1
-            date = result.get('date_invoice') or fields.Date.today()
+            date = result.get('invoice_date') or fields.Date.today()
 
             amount = result.get('amount_total', 0) or 0
             if cur != target_currency:
@@ -336,28 +371,21 @@ class account_journal(models.Model):
     @api.multi
     def action_create_new(self):
         ctx = self._context.copy()
-        model = 'account.invoice'
+        ctx['default_journal_id'] = self.id
         if self.type == 'sale':
-            ctx.update({'journal_type': self.type, 'default_type': 'out_invoice', 'type': 'out_invoice', 'default_journal_id': self.id})
-            if ctx.get('refund'):
-                ctx.update({'default_type':'out_refund', 'type':'out_refund'})
-            view_id = self.env.ref('account.invoice_form').id
+            ctx['default_type'] = 'out_refund' if ctx.get('refund') else 'out_invoice'
         elif self.type == 'purchase':
-            ctx.update({'journal_type': self.type, 'default_type': 'in_invoice', 'type': 'in_invoice', 'default_journal_id': self.id})
-            if ctx.get('refund'):
-                ctx.update({'default_type': 'in_refund', 'type': 'in_refund'})
-            view_id = self.env.ref('account.invoice_supplier_form').id
+            ctx['default_type'] = 'in_refund' if ctx.get('refund') else 'in_invoice'
         else:
-            ctx.update({'default_journal_id': self.id, 'view_no_maturity': True})
-            view_id = self.env.ref('account.view_move_form').id
-            model = 'account.move'
+            ctx['default_type'] = 'entry'
+            ctx['view_no_maturity'] = True
         return {
             'name': _('Create invoice/bill'),
             'type': 'ir.actions.act_window',
             'view_type': 'form',
             'view_mode': 'form',
-            'res_model': model,
-            'view_id': view_id,
+            'res_model': 'account.move',
+            'view_id': self.env.ref('account.view_move_form').id,
             'context': ctx,
         }
 
@@ -402,7 +430,7 @@ class account_journal(models.Model):
         self.ensure_one()
         ids = self.to_check_ids().ids
         action_context = {'show_mode_selector': False, 'company_ids': self.mapped('company_id').ids}
-        action_context.update({'edition_mode': True})
+        action_context.update({'suspense_moves_mode': True})
         action_context.update({'statement_line_ids': ids})
         return {
             'type': 'ir.actions.client',
@@ -412,7 +440,7 @@ class account_journal(models.Model):
 
     def to_check_ids(self):
         self.ensure_one()
-        domain = self.env['account.move.line']._get_domain_for_edition_mode()
+        domain = self.env['account.move.line']._get_suspense_moves_domain()
         domain.append(('journal_id', '=', self.id))
         statement_line_ids = self.env['account.move.line'].search(domain).mapped('statement_line_id')
         return statement_line_ids
@@ -420,60 +448,42 @@ class account_journal(models.Model):
     @api.multi
     def open_action(self):
         """return action based on type for related journals"""
-        action_name = self._context.get('action_name', False)
+        action_name = self._context.get('action_name')
+
+        # Find action based on journal.
         if not action_name:
             if self.type == 'bank':
                 action_name = 'action_bank_statement_tree'
             elif self.type == 'cash':
                 action_name = 'action_view_bank_statement_tree'
             elif self.type == 'sale':
-                action_name = 'action_invoice_tree1'
-                use_domain = expression.AND(
-                    [self.env.context.get('use_domain', []), [('journal_id', '=', self.id)]]
-                )
-                self = self.with_context(use_domain=use_domain)
+                action_name = 'action_move_out_invoice_type'
             elif self.type == 'purchase':
-                action_name = 'action_vendor_bill_template'
-                use_domain = expression.AND(
-                    [self.env.context.get('use_domain', []), [('journal_id', '=', self.id)]]
-                )
-                self = self.with_context(use_domain=use_domain)
+                action_name = 'action_move_in_invoice_type'
             else:
                 action_name = 'action_move_journal_line'
 
-        _journal_invoice_type_map = {
-            ('sale', None): 'out_invoice',
-            ('purchase', None): 'in_invoice',
-            ('sale', 'refund'): 'out_refund',
-            ('purchase', 'refund'): 'in_refund',
-            ('bank', None): 'bank',
-            ('cash', None): 'cash',
-            ('general', None): 'general',
-        }
-        invoice_type = _journal_invoice_type_map[(self.type, self._context.get('invoice_type'))]
+        # Set 'account.' prefix if missing.
+        if '.' not in action_name:
+            action_name = 'account.%s' % action_name
 
-        ctx = self._context.copy()
-        ctx.pop('group_by', None)
-        ctx.update({
-            'journal_type': self.type,
+        action = self.env.ref(action_name).read()[0]
+        context = self._context.copy()
+        if 'context' in action and type(action['context']) == str:
+            context.update(ast.literal_eval(action['context']))
+        else:
+            context.update(action.get('context', {}))
+        action['context'] = context
+        action['context'].update({
             'default_journal_id': self.id,
-            'default_type': invoice_type,
-            'type': invoice_type,
             'search_default_journal_id': self.id,
         })
 
-        [action] = self.env.ref('account.%s' % action_name).read()
-        action['context'] = ctx
-        action['domain'] = self._context.get('use_domain', [])
-        account_invoice_filter = self.env.ref('account.view_account_invoice_filter', False)
-        if action_name in ['action_invoice_tree1', 'action_vendor_bill_template']:
-            action['search_view_id'] = account_invoice_filter and account_invoice_filter.id or False
-        if action_name in ['action_bank_statement_tree', 'action_view_bank_statement_tree']:
-            action['views'] = False
-            action['view_id'] = False
-        if self.type == 'purchase':
-            new_help = self.env['account.invoice'].with_context(ctx).complete_empty_list_help()
-            action.update({'help': (action.get('help') or '') + new_help})
+        if self.type == 'sale':
+            action['domain'] = [('type', 'in', ('out_invoice', 'out_refund', 'out_receipt'))]
+        elif self.type == 'purchase':
+            action['domain'] = [('type', 'in', ('in_invoice', 'in_refund', 'in_receipt'))]
+
         return action
 
     @api.multi

--- a/addons/account/models/account_move.py
+++ b/addons/account/models/account_move.py
@@ -1,349 +1,1903 @@
 # -*- coding: utf-8 -*-
 
-import time
-from datetime import date
-from collections import OrderedDict
 from odoo import api, fields, models, _
-from odoo.osv import expression
 from odoo.exceptions import RedirectWarning, UserError, ValidationError
+from odoo.tools import float_is_zero, float_compare, safe_eval, date_utils
 from odoo.tools.misc import formatLang, format_date
-from odoo.tools import float_is_zero, float_compare
-from odoo.tools.safe_eval import safe_eval
 from odoo.addons import decimal_precision as dp
-from lxml import etree
 
-#----------------------------------------------------------
-# Entries
-#----------------------------------------------------------
+from collections import OrderedDict
+from datetime import date
+from itertools import groupby
+from stdnum.iso7064 import mod_97_10
+from itertools import zip_longest
+
+import json
+import re
+import logging
+
+_logger = logging.getLogger(__name__)
+
 
 class AccountMove(models.Model):
     _name = "account.move"
+    _inherit = ['portal.mixin', 'mail.thread', 'mail.activity.mixin']
     _description = "Journal Entries"
     _order = 'date desc, name desc, id desc'
-    _inherit = ['mail.thread', 'mail.activity.mixin']
 
     @api.model
-    def default_get(self, fields):
-        rec = super(AccountMove, self).default_get(fields)
-        if not rec.get('journal_id'):
-            rec.update({'journal_id': self.env['account.journal'].search([('type', '=', 'general'), ('company_id', '=', self.env.company.id)], limit=1).id})
-        return rec
+    def _get_default_journal(self):
+        ''' Get the default journal.
+        It could either be passed through the context using the 'default_journal_id' key containing its id,
+        either be determined by the default type.
+        '''
+        move_type = self._context.get('default_type', 'entry')
+        journal_type = 'general'
+        if move_type in self.get_sale_types(include_receipts=True):
+            journal_type = 'sale'
+        elif move_type in self.get_purchase_types(include_receipts=True):
+            journal_type = 'purchase'
+
+        if self._context.get('default_journal_id'):
+            journal = self.env['account.journal'].browse(self._context['default_journal_id'])
+
+            if move_type != 'entry' and journal.type != journal_type:
+                raise UserError(_("Cannot create an invoice of type %s with a journal having %s as type.") % (move_type, journal_type))
+        else:
+            company_id = self._context.get('default_company_id', self.env.company.id)
+            domain = [('company_id', '=', company_id), ('type', '=', journal_type)]
+
+            journal = None
+            if self._context.get('default_currency_id'):
+                currency_domain = domain + [('currency_id', '=', self._context['default_currency_id'])]
+                journal = self.env['account.journal'].search(currency_domain, limit=1)
+
+            if not journal:
+                journal = self.env['account.journal'].search(domain, limit=1)
+
+            if not journal:
+                error_msg = _('Please define an accounting miscellaneous journal in your company')
+                if journal_type == 'sale':
+                    error_msg = _('Please define an accounting sale journal in your company')
+                elif journal_type == 'purchase':
+                    error_msg = _('Please define an accounting purchase journal in your company')
+                raise UserError(error_msg)
+        return journal
+
+    @api.model
+    def _get_default_currency(self):
+        ''' Get the default currency from either the journal, either the default journal's company. '''
+        journal = self._get_default_journal()
+        return journal.currency_id or journal.company_id.currency_id
+
+    @api.model
+    def _get_default_invoice_incoterm(self):
+        ''' Get the default incoterm for invoice. '''
+        return self.env.company.incoterm_id
+
+    # ==== Business fields ====
+    name = fields.Char(string='Number', required=True, readonly=True, copy=False, default='/')
+    date = fields.Date(string='Date', required=True, index=True, readonly=True,
+        states={'draft': [('readonly', False)]},
+        default=fields.Date.context_today)
+    ref = fields.Char(string='Reference', copy=False, readonly=True,
+        states={'draft': [('readonly', False)]})
+    narration = fields.Text(string='Internal Note')
+    state = fields.Selection(selection=[
+            ('draft', 'Unposted'),
+            ('posted', 'Posted'),
+            ('cancel', 'Cancelled')
+        ], string='Status', required=True, readonly=True, copy=False, tracking=True,
+        default='draft')
+    type = fields.Selection(selection=[
+            ('entry', 'Journal Entry'),
+            ('out_invoice', 'Customer Invoice'),
+            ('out_refund', 'Customer Credit Note'),
+            ('in_invoice', 'Vendor Bill'),
+            ('in_refund', 'Vendor Credit Note'),
+            ('out_receipt', 'Sales Receipt'),
+            ('in_receipt', 'Purchase Receipt'),
+        ], String='Type', required=True, store=True, index=True, readonly=True, tracking=True,
+        default="entry")
+    to_check = fields.Boolean(string='To Check', default=False,
+        help='If this checkbox is ticked, it means that the user was not sure of all the related informations at the time of the creation of the move and that the move needs to be checked again.')
+    journal_id = fields.Many2one('account.journal', string='Journal', required=True, readonly=True,
+        states={'draft': [('readonly', False)]},
+        domain=lambda self: [('company_id', '=', self.env.company.id)],
+        default=_get_default_journal)
+    company_id = fields.Many2one(string='Company', store=True, readonly=True,
+        related='journal_id.company_id')
+    company_currency_id = fields.Many2one(string='Company Currency', readonly=True,
+        related='journal_id.company_id.currency_id')
+    currency_id = fields.Many2one('res.currency', store=True, readonly=True, tracking=True, required=True,
+        states={'draft': [('readonly', False)]},
+        string='Currency',
+        default=_get_default_currency)
+    line_ids = fields.One2many('account.move.line', 'move_id', string='Journal Items', copy=True, readonly=True,
+        states={'draft': [('readonly', False)]})
+    partner_id = fields.Many2one('res.partner', readonly=True, tracking=True,
+        states={'draft': [('readonly', False)]},
+        string='Customer/Vendor')
+    commercial_partner_id = fields.Many2one('res.partner', string='Commercial Entity', store=True, readonly=True,
+        compute='_compute_commercial_partner_id')
+
+    # === Amount fields ===
+    amount_untaxed = fields.Monetary(string='Untaxed Amount', store=True, readonly=True, tracking=True,
+        compute='_compute_amount')
+    amount_tax = fields.Monetary(string='Tax', store=True, readonly=True,
+        compute='_compute_amount')
+    amount_total = fields.Monetary(string='Total', store=True, readonly=True,
+        compute='_compute_amount',
+        inverse='_inverse_amount_total')
+    amount_residual = fields.Monetary(string='Amount Due', store=True,
+        compute='_compute_amount')
+    amount_untaxed_signed = fields.Monetary(string='Untaxed Amount Signed', store=True, readonly=True,
+        compute='_compute_amount')
+    amount_tax_signed = fields.Monetary(string='Tax Signed', store=True, readonly=True,
+        compute='_compute_amount')
+    amount_total_signed = fields.Monetary(string='Total Signed', store=True, readonly=True,
+        compute='_compute_amount')
+    amount_residual_signed = fields.Monetary(string='Amount Due Signed', store=True,
+        compute='_compute_amount')
+    amount_by_group = fields.Binary(string="Tax amount by group",
+        compute='_compute_invoice_taxes_by_group',
+        help="Technical field used by web_studio to allow an easy edition of the invoice report by drag/drop of the field. Return type: [(name, amount, base, formated amount, formated base)]")
+
+    # ==== Cash basis feature fields ====
+    tax_cash_basis_rec_id = fields.Many2one(
+        'account.partial.reconcile',
+        string='Tax Cash Basis Entry of',
+        help="Technical field used to keep track of the tax cash basis reconciliation. "
+             "This is needed when cancelling the source: it will post the inverse journal entry to cancel that part too.")
+
+    # ==== Auto-post feature fields ====
+    auto_post = fields.Boolean(string='Post Automatically', default=False,
+        help='If this checkbox is ticked, this entry will be automatically posted at its date.')
+
+    # ==== Reverse feature fields ====
+    reversed_entry_id = fields.Many2one('account.move', string="Reverse entry", readonly=True, copy=False)
+
+    # =========================================================
+    # Invoice related fields
+    # =========================================================
+
+    # ==== Business fields ====
+    fiscal_position_id = fields.Many2one('account.fiscal.position', string='Fiscal Position', readonly=True,
+        states={'draft': [('readonly', False)]},
+        help="Fiscal positions are used to adapt taxes and accounts for particular customers or sales orders/invoices. "
+             "The default value comes from the customer.")
+    invoice_user_id = fields.Many2one('res.users', readonly=True, copy=False, tracking=True,
+        states={'draft': [('readonly', False)]},
+        string='Salesperson',
+        default=lambda self: self.env.user)
+    invoice_payment_state = fields.Selection(selection=[
+            ('not_paid', 'Not Paid'),
+            ('in_payment', 'In Payment'),
+            ('paid', 'paid')
+        ], string='Payment Status', store=True, readonly=True, copy=False, tracking=True,
+        compute='_compute_amount')
+    invoice_date = fields.Date(string='Invoice/Bill Date', readonly=True, index=True, copy=False,
+        states={'draft': [('readonly', False)]},
+        help="Keep empty to use the current date")
+    invoice_date_due = fields.Date(string='Due Date', readonly=True, index=True, copy=False,
+        states={'draft': [('readonly', False)]},
+        help="If you use payment terms, the due date will be computed automatically at the generation "
+             "of accounting entries. The Payment terms may compute several due dates, for example 50% "
+             "now and 50% in one month, but if you want to force a due date, make sure that the payment "
+             "term is not set on the invoice. If you keep the Payment terms and the due date empty, it "
+             "means direct payment.")
+    invoice_payment_ref = fields.Char(string='Payment Reference', index=True, copy=False, readonly=True,
+        states={'draft': [('readonly', False)]},
+        help="The payment reference to set on journal items.")
+    invoice_sent = fields.Boolean(readonly=True, default=False, copy=False,
+        help="It indicates that the invoice has been sent.")
+    invoice_origin = fields.Char(string='Origin', readonly=True, tracking=True,
+        help="The document(s) that generated the invoice.")
+    invoice_payment_term_id = fields.Many2one('account.payment.term', string='Payment Terms',
+        readonly=True, states={'draft': [('readonly', False)]},
+        help="If you use payment terms, the due date will be computed automatically at the generation "
+             "of accounting entries. If you keep the payment terms and the due date empty, it means direct payment. "
+             "The payment terms may compute several due dates, for example 50% now, 50% in one month.")
+    # /!\ invoice_line_ids is just a subset of line_ids.
+    invoice_line_ids = fields.One2many('account.move.line', 'move_id', string='Invoice lines',
+        copy=False, readonly=True,
+        domain=[('exclude_from_invoice_tab', '=', False)],
+        states={'draft': [('readonly', False)]})
+    invoice_partner_bank_id = fields.Many2one('res.partner.bank', string='Bank Account',
+        help='Bank Account Number to which the invoice will be paid. A Company bank account if this is a Customer Invoice or Vendor Credit Note, otherwise a Partner bank account number.',
+        readonly=True, states={'draft': [('readonly', False)]})
+    invoice_incoterm_id = fields.Many2one('account.incoterms', string='Incoterm',
+        default=_get_default_invoice_incoterm,
+        help='International Commercial Terms are a series of predefined commercial terms used in international transactions.')
+
+    # ==== Payment widget fields ====
+    invoice_outstanding_credits_debits_widget = fields.Text(groups="account.group_account_invoice",
+        compute='_compute_payments_widget_to_reconcile_info')
+    invoice_payments_widget = fields.Text(groups="account.group_account_invoice",
+        compute='_compute_payments_widget_reconciled_info')
+    invoice_has_outstanding = fields.Boolean(groups="account.group_account_invoice",
+        compute='_compute_payments_widget_to_reconcile_info')
+
+    # ==== Vendor bill fields ====
+    invoice_vendor_bill_id = fields.Many2one('account.move', store=False,
+        string='Vendor Bill',
+        help="Auto-complete from a past bill.")
+    invoice_source_email = fields.Char(string='Source Email', tracking=True)
+    invoice_vendor_display_name = fields.Char(compute='_compute_invoice_vendor_display_info', store=True)
+    invoice_vendor_icon = fields.Char(compute='_compute_invoice_vendor_display_info', store=False)
+
+    # ==== Cash rounding fields ====
+    invoice_cash_rounding_id = fields.Many2one('account.cash.rounding', string='Cash Rounding Method',
+        readonly=True, states={'draft': [('readonly', False)]},
+        help='Defines the smallest coinage of the currency that can be used to pay by cash.')
+
+    # ==== Fields to set the sequence, on the first invoice of the journal ====
+    invoice_sequence_number_next = fields.Char(string='Next Number',
+        compute='_compute_invoice_sequence_number_next',
+        inverse='_inverse_invoice_sequence_number_next')
+    invoice_sequence_number_next_prefix = fields.Char(string='Next Number Prefix',
+        compute="_compute_invoice_sequence_number_next")
+
+    # ==== Display purpose fields ====
+    invoice_filter_type_domain = fields.Char(compute='_compute_invoice_filter_type_domain',
+        help="Technical field used to have a dynamic domain on journal / taxes in the form view.")
+    bank_partner_id = fields.Many2one('res.partner', help='Technical field to get the domain on the bank', compute='_compute_bank_partner_id')
+    invoice_has_matching_supsense_amount = fields.Boolean(compute='_compute_has_matching_suspense_amount',
+        groups='account.group_account_invoice',
+        help="Technical field used to display an alert on invoices if there is at least a matching amount in any supsense account.")
+
+    # -------------------------------------------------------------------------
+    # ONCHANGE METHODS
+    # -------------------------------------------------------------------------
+
+    @api.onchange('invoice_date')
+    def _onchange_invoice_date(self):
+        if self.invoice_date:
+            self.invoice_date_due = self.date = self.invoice_date
+            self._onchange_currency()
+
+    @api.onchange('invoice_date_due')
+    def _onchange_invoice_date_due(self):
+        self._recompute_dynamic_lines()
+
+    @api.onchange('journal_id')
+    def _onchange_journal(self):
+        if self.journal_id and self.journal_id.currency_id:
+            new_currency = self.journal_id.currency_id
+            if new_currency != self.currency_id:
+                self.currency_id = new_currency
+                self._onchange_currency()
+
+    @api.onchange('partner_id')
+    def _onchange_partner_id(self):
+        warning = {}
+        if self.partner_id:
+            rec_account = self.partner_id.property_account_receivable_id
+            pay_account = self.partner_id.property_account_payable_id
+            if not rec_account and not pay_account:
+                action = self.env.ref('account.action_account_config')
+                msg = _('Cannot find a chart of accounts for this company, You should configure it. \nPlease go to Account Configuration.')
+                raise RedirectWarning(msg, action.id, _('Go to the configuration panel'))
+            p = self.partner_id
+            if p.invoice_warn == 'no-message' and p.parent_id:
+                p = p.parent_id
+            if p.invoice_warn and p.invoice_warn != 'no-message':
+                # Block if partner only has warning but parent company is blocked
+                if p.invoice_warn != 'block' and p.parent_id and p.parent_id.invoice_warn == 'block':
+                    p = p.parent_id
+                warning = {
+                    'title': _("Warning for %s") % p.name,
+                    'message': p.invoice_warn_msg
+                }
+                if p.invoice_warn == 'block':
+                    self.partner_id = False
+                    return {'warning': warning}
+        for line in self.line_ids:
+            line.partner_id = self.partner_id.commercial_partner_id
+        if self.is_sale_document(include_receipts=True):
+            self.invoice_payment_term_id = self.partner_id.property_payment_term_id
+        elif self.is_purchase_document(include_receipts=True):
+            self.invoice_payment_term_id = self.partner_id.property_supplier_payment_term_id
+
+        self._compute_bank_partner_id()
+        self.invoice_partner_bank_id = self.bank_partner_id.bank_ids and self.bank_partner_id.bank_ids[0]
+
+        # Find the new fiscal position.
+        delivery_partner_id = self._get_invoice_delivery_partner_id()
+        new_fiscal_position_id = self.env['account.fiscal.position'].get_fiscal_position(
+            self.partner_id.id, delivery_id=delivery_partner_id)
+        self.fiscal_position_id = self.env['account.fiscal.position'].browse(new_fiscal_position_id)
+        self._recompute_dynamic_lines()
+        if warning:
+            return {'warning': warning}
+
+    @api.onchange('date', 'currency_id')
+    def _onchange_currency(self):
+        company_currency = self.company_id.currency_id
+        has_foreign_currency = self.currency_id and self.currency_id != company_currency
+
+        for line in self.line_ids:
+            new_currency = has_foreign_currency and self.currency_id
+            line.currency_id = new_currency
+            line._onchange_currency()
+        self._recompute_dynamic_lines()
+
+    @api.onchange('invoice_payment_ref')
+    def _onchange_invoice_payment_ref(self):
+        for line in self.line_ids.filtered(lambda line: line.account_id.user_type_id.type in ('receivable', 'payable')):
+            line.name = self.invoice_payment_ref
+
+    @api.onchange('invoice_vendor_bill_id')
+    def _onchange_invoice_vendor_bill(self):
+        if self.invoice_vendor_bill_id:
+            # Copy invoice lines.
+            for line in self.invoice_vendor_bill_id.invoice_line_ids:
+                copied_vals = line.copy_data()[0]
+                copied_vals['move_id'] = self.id
+                new_line = self.env['account.move.line'].new(copied_vals)
+                new_line.recompute_tax_line = True
+
+            # Copy payment terms.
+            self.invoice_payment_term_id = self.invoice_vendor_bill_id.invoice_payment_term_id
+
+            # Copy currency.
+            if self.currency_id != self.invoice_vendor_bill_id.currency_id:
+                self.currency_id = self.invoice_vendor_bill_id.currency_id
+
+            # Reset
+            self.invoice_vendor_bill_id = False
+            self._recompute_dynamic_lines()
+
+    @api.onchange('type')
+    def _onchange_type(self):
+        ''' Onchange made to filter the partners depending of the type. '''
+        if self.is_sale_document(include_receipts=True):
+            if self.env['ir.config_parameter'].sudo().get_param('account.use_invoice_terms'):
+                self.narration = self.company_id.invoice_terms or self.env.company.invoice_terms
+            return {'domain': {'partner_id': [('customer', '=', True)]}}
+        elif self.is_purchase_document(include_receipts=True):
+            return {'domain': {'partner_id': [('supplier', '=', True)]}}
+
+    @api.onchange('invoice_line_ids')
+    def _onchange_invoice_line_ids(self):
+        current_invoice_lines = self.line_ids.filtered(lambda line: not line.exclude_from_invoice_tab)
+        others_lines = self.line_ids - current_invoice_lines
+        if others_lines and current_invoice_lines - self.invoice_line_ids:
+            others_lines[0].recompute_tax_line = True
+        self.line_ids = others_lines + self.invoice_line_ids
+        self._onchange_recompute_dynamic_lines()
+
+    @api.onchange('line_ids', 'invoice_payment_term_id', 'invoice_date_due', 'invoice_cash_rounding_id', 'invoice_vendor_bill_id')
+    def _onchange_recompute_dynamic_lines(self):
+        self._recompute_dynamic_lines()
+
+    @api.model
+    def _get_tax_grouping_key_from_tax_line(self, tax_line):
+        ''' Create the dictionary based on a tax line that will be used as key to group taxes together.
+        /!\ Must be consistent with '_get_tax_grouping_key_from_base_line'.
+        :param tax_line:    An account.move.line being a tax line (with 'tax_repartition_line_id' set then).
+        :return:            A dictionary containing all fields on which the tax will be grouped.
+        '''
+        return {
+            'tax_repartition_line_id': tax_line.tax_repartition_line_id.id,
+            'account_id': tax_line.account_id.id,
+            'currency_id': tax_line.currency_id.id,
+            'analytic_tag_ids': [(6, 0, tax_line.tax_line_id.analytic and tax_line.analytic_tag_ids.ids or [])],
+            'analytic_account_id': tax_line.tax_line_id.analytic and tax_line.analytic_account_id.id,
+            'tax_ids': [(6, 0, tax_line.tax_ids.ids)],
+            'tag_ids': [(6, 0, tax_line.tag_ids.ids)],
+        }
+
+    @api.model
+    def _get_tax_grouping_key_from_base_line(self, base_line, tax_vals):
+        ''' Create the dictionary based on a base line that will be used as key to group taxes together.
+        /!\ Must be consistent with '_get_tax_grouping_key_from_tax_line'.
+        :param base_line:   An account.move.line being a base line (that could contains something in 'tax_ids').
+        :param tax_vals:    An element of compute_all(...)['taxes'].
+        :return:            A dictionary containing all fields on which the tax will be grouped.
+        '''
+        tax_repartition_line = self.env['account.tax.repartition.line'].browse(tax_vals['tax_repartition_line_id'])
+        account = base_line._get_default_tax_account(tax_repartition_line) or base_line.account_id
+        return {
+            'tax_repartition_line_id': tax_vals['tax_repartition_line_id'],
+            'account_id': account.id,
+            'currency_id': base_line.currency_id.id,
+            'analytic_tag_ids': [(6, 0, base_line.analytic_tag_ids.ids)],
+            'analytic_account_id': base_line.analytic_account_id.id,
+            'tax_ids': [(6, 0, tax_vals['tax_ids'])],
+            'tag_ids': [(6, 0, tax_vals['tag_ids'])],
+        }
 
     @api.multi
-    @api.depends('name', 'state')
-    def name_get(self):
-        result = []
+    def _recompute_tax_lines(self):
+        ''' Compute the dynamic tax lines of the journal entry.
+
+        :param lines_map: The line_ids dispatched by type containing:
+            * base_lines: The lines having a tax_ids set.
+            * tax_lines: The lines having a tax_line_id set.
+            * terms_lines: The lines generated by the payment terms of the invoice.
+            * rounding_lines: The cash rounding lines of the invoice.
+        '''
+        self.ensure_one()
+        in_draft_mode = self != self._origin
+
+        def _serialize_tax_grouping_key(grouping_dict):
+            ''' Serialize the dictionary values to be used in the taxes_map.
+            :param grouping_dict: The values returned by '_get_tax_grouping_key_from_tax_line' or '_get_tax_grouping_key_from_base_line'.
+            :return: A string representing the values.
+            '''
+            return '-'.join(str(v) for v in grouping_dict.values())
+
+        def _compute_base_line_taxes(base_line):
+            ''' Compute taxes amounts both in company currency / foreign currency as the ratio between
+            amount_currency & balance could not be the same as the expected currency rate.
+            The 'amount_currency' value will be set on compute_all(...)['taxes'] in multi-currency.
+            :param base_line:   The account.move.line owning the taxes.
+            :return:            The result of the compute_all method.
+            '''
+            balance_taxes_res = base_line.tax_ids._origin.compute_all(
+                base_line.balance,
+                currency=base_line.company_currency_id,
+                partner=base_line.partner_id,
+                is_refund=self.type in ('out_refund', 'in_refund'),
+                handle_price_include=False,
+            )
+
+            if base_line.currency_id:
+                # Multi-currencies mode: Taxes are computed both in company's currency / foreign currency.
+                amount_currency_taxes_res = base_line.tax_ids._origin.compute_all(
+                    base_line.amount_currency,
+                    currency=base_line.currency_id,
+                    partner=base_line.partner_id,
+                    is_refund=self.type in ('out_refund', 'in_refund'),
+                    handle_price_include=False,
+                )
+                for b_tax_res, ac_tax_res in zip(balance_taxes_res['taxes'], amount_currency_taxes_res['taxes']):
+                    b_tax_res['amount_currency'] = ac_tax_res['amount']
+            return balance_taxes_res
+
+        taxes_map = {}
+
+        # ==== Add tax lines ====
+        for line in self.line_ids.filtered('tax_repartition_line_id'):
+            grouping_dict = self._get_tax_grouping_key_from_tax_line(line)
+            grouping_key = _serialize_tax_grouping_key(grouping_dict)
+            taxes_map[grouping_key] = {
+                'tax_line': line,
+                'balance': 0.0,
+                'amount_currency': 0.0,
+                'tax_base_amount': 0.0,
+                'grouping_dict': False,
+            }
+
+        # ==== Mount base lines ====
+        for line in self.line_ids.filtered(lambda line: not line.exclude_from_invoice_tab):
+            # Don't call compute_all if there is no tax.
+            if not line.tax_ids:
+                line.tag_ids = [(5, 0, 0)]
+                continue
+
+            compute_all_vals = _compute_base_line_taxes(line)
+
+            # Assign tags on base line
+            line.tag_ids = compute_all_vals['base_tags']
+
+            tax_exigible = True
+            for tax_vals in compute_all_vals['taxes']:
+                grouping_dict = self._get_tax_grouping_key_from_base_line(line, tax_vals)
+                grouping_key = _serialize_tax_grouping_key(grouping_dict)
+
+                tax_repartition_line = self.env['account.tax.repartition.line'].browse(tax_vals['tax_repartition_line_id'])
+                tax = tax_repartition_line.invoice_tax_id or tax_repartition_line.refund_tax_id
+
+                if tax.tax_exigibility == 'on_payment':
+                    tax_exigible = False
+
+                taxes_map_entry = taxes_map.setdefault(grouping_key, {
+                    'tax_line': None,
+                    'balance': 0.0,
+                    'amount_currency': 0.0,
+                    'tax_base_amount': 0.0,
+                    'grouping_dict': False,
+                })
+                taxes_map_entry['balance'] += tax_vals['amount']
+                taxes_map_entry['amount_currency'] += tax_vals.get('amount_currency', 0.0)
+                taxes_map_entry['tax_base_amount'] += tax_vals['base']
+                taxes_map_entry['grouping_dict'] = grouping_dict
+            line.tax_exigible = tax_exigible
+
+        # ==== Process taxes_map ====
+        for taxes_map_entry in taxes_map.values():
+            # Don't create tax lines with zero balance.
+            if self.currency_id.is_zero(taxes_map_entry['balance']) and self.currency_id.is_zero(taxes_map_entry['amount_currency']):
+                taxes_map_entry['grouping_dict'] = False
+
+            tax_line = taxes_map_entry['tax_line']
+            tax_base_amount = -taxes_map_entry['tax_base_amount'] if self.is_inbound() else taxes_map_entry['tax_base_amount']
+
+            if not tax_line and not taxes_map_entry['grouping_dict']:
+                continue
+            elif tax_line and not taxes_map_entry['grouping_dict']:
+                # The tax line is no longer used, drop it.
+                self.line_ids -= tax_line
+            elif tax_line:
+                tax_line.update({
+                    'amount_currency': taxes_map_entry['amount_currency'],
+                    'debit': taxes_map_entry['balance'] > 0.0 and taxes_map_entry['balance'] or 0.0,
+                    'credit': taxes_map_entry['balance'] < 0.0 and -taxes_map_entry['balance'] or 0.0,
+                    'tax_base_amount': tax_base_amount,
+                })
+            else:
+                create_method = in_draft_mode and self.env['account.move.line'].new or self.env['account.move.line'].create
+                tax_repartition_line_id = taxes_map_entry['grouping_dict']['tax_repartition_line_id']
+                tax_repartition_line = self.env['account.tax.repartition.line'].browse(tax_repartition_line_id)
+                tax = tax_repartition_line.invoice_tax_id or tax_repartition_line.refund_tax_id
+                tax_line = create_method({
+                    'name': tax.name,
+                    'move_id': self.id,
+                    'partner_id': line.partner_id.id,
+                    'company_id': line.company_id.id,
+                    'company_currency_id': line.company_currency_id.id,
+                    'quantity': 1.0,
+                    'date_maturity': False,
+                    'amount_currency': taxes_map_entry['amount_currency'],
+                    'debit': taxes_map_entry['balance'] > 0.0 and taxes_map_entry['balance'] or 0.0,
+                    'credit': taxes_map_entry['balance'] < 0.0 and -taxes_map_entry['balance'] or 0.0,
+                    'tax_base_amount': tax_base_amount,
+                    'exclude_from_invoice_tab': True,
+                    'tax_exigible': tax.tax_exigibility == 'on_invoice',
+                    **taxes_map_entry['grouping_dict'],
+                })
+
+            if in_draft_mode:
+                tax_line._onchange_amount_currency()
+                tax_line._onchange_balance()
+
+    @api.multi
+    def _recompute_cash_rounding_lines(self):
+        ''' Handle the cash rounding feature on invoices.
+
+        In some countries, the smallest coins do not exist. For example, in Switzerland, there is no coin for 0.01 CHF.
+        For this reason, if invoices are paid in cash, you have to round their total amount to the smallest coin that
+        exists in the currency. For the CHF, the smallest coin is 0.05 CHF.
+
+        There are two strategies for the rounding:
+
+        1) Add a line on the invoice for the rounding: The cash rounding line is added as a new invoice line.
+        2) Add the rounding in the biggest tax amount: The cash rounding line is added as a new tax line on the tax
+        having the biggest balance.
+        '''
+        self.ensure_one()
+        in_draft_mode = self != self._origin
+
+        def _compute_cash_rounding(self, total_balance, total_amount_currency):
+            ''' Compute the amount differences due to the cash rounding.
+            :param self:                    The current account.move record.
+            :param total_balance:           The invoice's total in company's currency.
+            :param total_amount_currency:   The invoice's total in invoice's currency.
+            :return:                        The amount differences both in company's currency & invoice's currency.
+            '''
+            if self.currency_id == self.company_id.currency_id:
+                diff_balance = self.invoice_cash_rounding_id.compute_difference(self.currency_id, total_balance)
+                diff_amount_currency = 0.0
+            else:
+                diff_amount_currency = self.invoice_cash_rounding_id.compute_difference(self.currency_id, total_amount_currency)
+                diff_balance = self.currency_id._convert(diff_amount_currency, self.company_id.currency_id, self.company_id, self.date)
+            return diff_balance, diff_amount_currency
+
+        def _apply_cash_rounding(self, diff_balance, diff_amount_currency, cash_rounding_line):
+            ''' Apply the cash rounding.
+            :param self:                    The current account.move record.
+            :param diff_balance:            The computed balance to set on the new rounding line.
+            :param diff_amount_currency:    The computed amount in invoice's currency to set on the new rounding line.
+            :param cash_rounding_line:      The existing cash rounding line.
+            :return:                        The newly created rounding line.
+            '''
+            rounding_line_vals = {
+                'debit': diff_balance > 0.0 and diff_balance or 0.0,
+                'credit': diff_balance < 0.0 and -diff_balance or 0.0,
+                'quantity': 1.0,
+                'amount_currency': diff_amount_currency,
+                'partner_id': self.partner_id.id,
+                'move_id': self.id,
+                'currency_id': self.currency_id if self.currency_id != self.company_id.currency_id else False,
+                'company_id': self.company_id.id,
+                'company_currency_id': self.company_id.currency_id.id,
+                'is_rounding_line': True,
+                'sequence': 9999,
+            }
+
+            if self.invoice_cash_rounding_id.strategy == 'biggest_tax':
+                biggest_tax_line = None
+                for tax_line in self.line_ids.filtered('tax_repartition_line_id'):
+                    if not biggest_tax_line or tax_line.price_subtotal > biggest_tax_line.price_subtotal:
+                        biggest_tax_line = tax_line
+
+                # No tax found.
+                if not biggest_tax_line:
+                    return
+
+                rounding_line_vals.update({
+                    'name': _('%s (rounding)') % biggest_tax_line.name,
+                    'account_id': biggest_tax_line.account_id.id,
+                    'tax_repartition_line_id': biggest_tax_line.tax_repartition_line_id.id,
+                    'tax_exigible': biggest_tax_line.tax_exigible,
+                    'exclude_from_invoice_tab': True,
+                })
+
+            elif self.invoice_cash_rounding_id.strategy == 'add_invoice_line':
+                rounding_line_vals.update({
+                    'name': self.invoice_cash_rounding_id.name,
+                    'account_id': self.invoice_cash_rounding_id.account_id.id,
+                })
+
+            # Create or update the cash rounding line.
+            if cash_rounding_line:
+                cash_rounding_line.update({
+                    'amount_currency': rounding_line_vals['amount_currency'],
+                    'debit': rounding_line_vals['debit'],
+                    'credit': rounding_line_vals['credit'],
+                })
+            else:
+                create_method = in_draft_mode and self.env['account.move.line'].new or self.env['account.move.line'].create
+                cash_rounding_line = create_method(rounding_line_vals)
+
+            if in_draft_mode:
+                cash_rounding_line._onchange_amount_currency()
+                cash_rounding_line._onchange_balance()
+
+        existing_cash_rounding_line = self.line_ids.filtered(lambda line: line.is_rounding_line)
+
+        # The cash rounding has been removed.
+        if not self.invoice_cash_rounding_id:
+            self.line_ids -= existing_cash_rounding_line
+            return
+
+        # The cash rounding strategy has changed.
+        if self.invoice_cash_rounding_id and existing_cash_rounding_line:
+            strategy = self.invoice_cash_rounding_id.strategy
+            old_strategy = 'biggest_tax' if existing_cash_rounding_line.tax_line_id else 'add_invoice_line'
+            if strategy != old_strategy:
+                self.line_ids -= existing_cash_rounding_line
+                existing_cash_rounding_line = self.env['account.move.line']
+
+        others_lines = self.line_ids.filtered(lambda line: line.account_id.user_type_id.type not in ('receivable', 'payable'))
+        others_lines -= existing_cash_rounding_line
+        total_balance = sum(others_lines.mapped('balance'))
+        total_amount_currency = sum(others_lines.mapped('amount_currency'))
+
+        diff_balance, diff_amount_currency = _compute_cash_rounding(self, total_balance, total_amount_currency)
+
+        # The invoice is already rounded.
+        if self.currency_id.is_zero(diff_balance) and self.currency_id.is_zero(diff_amount_currency):
+            self.line_ids -= existing_cash_rounding_line
+            return
+
+        _apply_cash_rounding(self, diff_balance, diff_amount_currency, existing_cash_rounding_line)
+
+    @api.multi
+    def _recompute_payment_terms_lines(self):
+        ''' Compute the dynamic payment term lines of the journal entry.'''
+        self.ensure_one()
+        in_draft_mode = self != self._origin
+        today = fields.Date.context_today(self)
+
+        def _get_payment_terms_computation_date(self):
+            ''' Get the date from invoice that will be used to compute the payment terms.
+            :param self:    The current account.move record.
+            :return:        A datetime.date object.
+            '''
+            if self.invoice_payment_term_id:
+                return self.invoice_date or today
+            else:
+                return self.invoice_date_due or self.invoice_date or today
+
+        def _get_payment_terms_account(self, payment_terms_lines):
+            ''' Get the account from invoice that will be set as receivable / payable account.
+            :param self:                    The current account.move record.
+            :param payment_terms_lines:     The current payment terms lines.
+            :return:                        An account.account record.
+            '''
+            if payment_terms_lines:
+                # Retrieve account from previous payment terms lines in order to allow the user to set a custom one.
+                return payment_terms_lines[0].account_id
+            elif self.partner_id:
+                # Retrieve account from partner.
+                if self.is_sale_document(include_receipts=True):
+                    return self.partner_id.property_account_receivable_id
+                else:
+                    return self.partner_id.property_account_payable_id
+            else:
+                # Search new account.
+                domain = [
+                    ('company_id', '=', self.company_id.id),
+                    ('internal_type', '=', 'receivable' if self.type in ('out_invoice', 'out_refund', 'out_receipt') else 'payable'),
+                ]
+                return self.env['account.account'].search(domain, limit=1)
+
+        def _compute_payment_terms(self, date, total_balance, total_amount_currency):
+            ''' Compute the payment terms.
+            :param self:                    The current account.move record.
+            :param date:                    The date computed by '_get_payment_terms_computation_date'.
+            :param total_balance:           The invoice's total in company's currency.
+            :param total_amount_currency:   The invoice's total in invoice's currency.
+            :return:                        A list <to_pay_company_currency, to_pay_invoice_currency, due_date>.
+            '''
+            if self.invoice_payment_term_id:
+                to_compute = self.invoice_payment_term_id.compute(total_balance, date_ref=date, currency=self.currency_id)
+                if self.currency_id != self.company_id.currency_id:
+                    # Multi-currencies.
+                    to_compute_currency = self.invoice_payment_term_id.compute(total_amount_currency, date_ref=date, currency=self.currency_id)
+                    return [(b[0], b[1], ac[1]) for b, ac in zip(to_compute, to_compute_currency)]
+                else:
+                    # Single-currency.
+                    return [(b[0], b[1], 0.0) for b in to_compute]
+            else:
+                return [(fields.Date.to_string(date), total_balance, total_amount_currency)]
+
+        def _compute_diff_payment_terms_lines(self, existing_terms_lines, account, to_compute):
+            ''' Process the result of the '_compute_payment_terms' method and creates/updates corresponding invoice lines.
+            :param self:                    The current account.move record.
+            :param existing_terms_lines:    The current payment terms lines.
+            :param account:                 The account.account record returned by '_get_payment_terms_account'.
+            :param to_compute:              The list returned by '_compute_payment_terms'.
+            '''
+            # As we try to update existing lines, sort them by due date.
+            existing_terms_lines = existing_terms_lines.sorted(lambda line: line.date_maturity or today)
+            existing_terms_lines_index = 0
+
+            # Recompute amls: update existing line or create new one for each payment term.
+            new_terms_lines = self.env['account.move.line']
+            for date_maturity, balance, amount_currency in to_compute:
+                if existing_terms_lines_index < len(existing_terms_lines):
+                    # Update existing line.
+                    candidate = existing_terms_lines[existing_terms_lines_index]
+                    existing_terms_lines_index += 1
+                    candidate.update({
+                        'date_maturity': date_maturity,
+                        'amount_currency': -amount_currency,
+                        'debit': balance < 0.0 and -balance or 0.0,
+                        'credit': balance > 0.0 and balance or 0.0,
+                    })
+                else:
+                    # Create new line.
+                    create_method = in_draft_mode and self.env['account.move.line'].new or self.env['account.move.line'].create
+                    candidate = create_method({
+                        'name': self.invoice_payment_ref or '',
+                        'debit': balance < 0.0 and -balance or 0.0,
+                        'credit': balance > 0.0 and balance or 0.0,
+                        'quantity': 1.0,
+                        'amount_currency': -amount_currency,
+                        'date_maturity': date_maturity,
+                        'move_id': self.id,
+                        'currency_id': self.currency_id.id if self.currency_id != self.company_id.currency_id else False,
+                        'account_id': account.id,
+                        'partner_id': self.commercial_partner_id.id,
+                        'exclude_from_invoice_tab': True,
+                    })
+                new_terms_lines += candidate
+                if in_draft_mode:
+                    candidate._onchange_amount_currency()
+                    candidate._onchange_balance()
+            return new_terms_lines
+
+        existing_terms_lines = self.line_ids.filtered(lambda line: line.account_id.user_type_id.type in ('receivable', 'payable'))
+        others_lines = self.line_ids.filtered(lambda line: line.account_id.user_type_id.type not in ('receivable', 'payable'))
+        total_balance = sum(others_lines.mapped('balance'))
+        total_amount_currency = sum(others_lines.mapped('amount_currency'))
+
+        if not others_lines:
+            self.line_ids -= existing_terms_lines
+            return
+
+        computation_date = _get_payment_terms_computation_date(self)
+        account = _get_payment_terms_account(self, existing_terms_lines)
+        to_compute = _compute_payment_terms(self, computation_date, total_balance, total_amount_currency)
+        new_terms_lines = _compute_diff_payment_terms_lines(self, existing_terms_lines, account, to_compute)
+
+        # Remove old terms lines that are no longer needed.
+        self.line_ids -= existing_terms_lines - new_terms_lines
+
+        if new_terms_lines:
+            self.invoice_payment_ref = new_terms_lines[-1].name or ''
+            self.invoice_date_due = new_terms_lines[-1].date_maturity
+
+    @api.multi
+    def _recompute_dynamic_lines(self, recompute_all_taxes=False):
+        ''' Recompute all lines that depend of others.
+
+        For example, tax lines depends of base lines (lines having tax_ids set). This is also the case of cash rounding
+        lines that depend of base lines or tax lines depending the cash rounding strategy. When a payment term is set,
+        this method will auto-balance the move with payment term lines.
+
+        :param recompute_all_taxes: Force the computation of taxes. If set to False, the computation will be done
+                                    or not depending of the field 'recompute_tax_line' in lines.
+        '''
+        self.ensure_one()
+
+        # Dispatch lines and pre-compute some aggregated values like taxes.
+        for line in self.line_ids:
+            if line.recompute_tax_line:
+                recompute_all_taxes = True
+                line.recompute_tax_line = False
+
+        # Compute taxes.
+        if recompute_all_taxes:
+            self._recompute_tax_lines()
+
+        if self.is_invoice(include_receipts=True):
+
+            # Compute cash rounding.
+            self._recompute_cash_rounding_lines()
+
+            # Compute payment terms.
+            self._recompute_payment_terms_lines()
+
+            # Only synchronize one2many in onchange.
+            if self != self._origin:
+                self.invoice_line_ids = self.line_ids.filtered(lambda line: not line.exclude_from_invoice_tab)
+
+    @api.multi
+    def onchange(self, values, field_name, field_onchange):
+        # OVERRIDE
+        # As the dynamic lines in this model are quite complex, we need to ensure some computations are done exactly
+        # at the beginning / at the end of the onchange mechanism. So, the onchange recursivity is disabled.
+        return super(AccountMove, self.with_context(recursive_onchanges=False)).onchange(values, field_name, field_onchange)
+
+    # -------------------------------------------------------------------------
+    # COMPUTE METHODS
+    # -------------------------------------------------------------------------
+
+    @api.depends('type')
+    def _compute_invoice_filter_type_domain(self):
         for move in self:
-            name = move.name
-            if self.env.context.get('name_groupby'):
-                name = "**{date}**, {name}       {partner}".format(date=format_date(self.env, move.date), name=move.name, partner=move.partner_id.name or "")
-            if move.state == 'draft':
-                name = '* ' + str(move.id)
-            result.append((move.id, name))
-        return result
+            if move.is_sale_document(include_receipts=True):
+                move.invoice_filter_type_domain = 'sale'
+            elif move.is_purchase_document(include_receipts=True):
+                move.invoice_filter_type_domain = 'purchase'
+            else:
+                move.invoice_filter_type_domain = False
+
+    @api.depends('partner_id')
+    def _compute_commercial_partner_id(self):
+        for move in self:
+            move.commercial_partner_id = move.partner_id.commercial_partner_id
+
+    @api.depends('commercial_partner_id')
+    def _compute_bank_partner_id(self):
+        for move in self:
+            if move.is_outbound():
+                move.bank_partner_id = move.commercial_partner_id
+            else:
+                move.bank_partner_id = move.company_id.partner_id
+
+    @api.depends(
+        'line_ids.debit',
+        'line_ids.credit',
+        'line_ids.currency_id',
+        'line_ids.amount_currency',
+        'line_ids.amount_residual',
+        'line_ids.amount_residual_currency',
+        'line_ids.payment_id.state')
+    def _compute_amount(self):
+        invoice_ids = [move.id for move in self if move.id and move.is_invoice(include_receipts=True)]
+        if invoice_ids:
+            self._cr.execute(
+                '''
+                    SELECT move.id
+                    FROM account_move move
+                    JOIN account_move_line line ON line.move_id = move.id
+                    JOIN account_partial_reconcile part ON part.debit_move_id = line.id OR part.credit_move_id = line.id
+                    JOIN account_move_line rec_line ON
+                        (rec_line.id = part.credit_move_id AND line.id = part.debit_move_id)
+                        OR
+                        (rec_line.id = part.debit_move_id AND line.id = part.credit_move_id)
+                    JOIN account_payment payment ON payment.id = rec_line.payment_id
+                    JOIN account_journal journal ON journal.id = rec_line.journal_id
+                    WHERE payment.state IN ('posted', 'sent')
+                    AND journal.post_at_bank_rec IS TRUE
+                    AND move.id IN %s
+                ''', [tuple(invoice_ids)]
+            )
+            in_payment_set = set(res[0] for res in self._cr.fetchall())
+        else:
+            in_payment_set = {}
+
+        for move in self:
+            total_untaxed = 0.0
+            total_untaxed_currency = 0.0
+            total_tax = 0.0
+            total_tax_currency = 0.0
+            total_residual = 0.0
+            total_residual_currency = 0.0
+            currencies = set()
+
+            for line in move.line_ids:
+                if line.currency_id:
+                    currencies.add(line.currency_id)
+
+                # Untaxed amount.
+                if (move.is_invoice(include_receipts=True) and not line.exclude_from_invoice_tab)\
+                or (move.type == 'entry' and line.debit and not line.tax_line_id):
+                    total_untaxed += line.balance
+                    total_untaxed_currency += line.amount_currency
+
+                # Tax amount.
+                if line.tax_line_id:
+                    total_tax += line.balance
+                    total_tax_currency += line.amount_currency
+
+                # Residual amount.
+                if move.type == 'entry' or line.account_id.user_type_id.type in ('receivable', 'payable'):
+                    total_residual += line.amount_residual
+                    total_residual_currency += line.amount_residual_currency
+
+            total = total_untaxed + total_tax
+            total_currency = total_untaxed_currency + total_tax_currency
+
+            if (move.type == 'entry' and total < 0.0) or move.is_inbound():
+                sign = -1
+            else:
+                sign = 1
+
+            move.amount_untaxed = sign * (total_untaxed_currency if len(currencies) == 1 else total_untaxed)
+            move.amount_tax = sign * (total_tax_currency if len(currencies) == 1 else total_tax)
+            move.amount_total = sign * (total_currency if len(currencies) == 1 else total)
+            move.amount_residual = -sign * (total_residual_currency if len(currencies) == 1 else total_residual)
+            move.amount_untaxed_signed = -total_untaxed
+            move.amount_tax_signed = -total_tax
+            move.amount_total_signed = -total
+            move.amount_residual_signed = total_residual
+
+            currency = len(currencies) == 1 and currencies.pop() or move.company_id.currency_id
+            is_paid = currency and currency.is_zero(move.amount_residual) or not move.amount_residual
+
+            # Compute 'invoice_payment_state'.
+            if move.state == 'posted' and is_paid:
+                if move.id in in_payment_set:
+                    move.invoice_payment_state = 'in_payment'
+                else:
+                    move.invoice_payment_state = 'paid'
+            else:
+                move.invoice_payment_state = 'not_paid'
 
     @api.multi
-    @api.depends('line_ids.debit', 'line_ids.credit', 'line_ids.amount_currency', 'line_ids.currency_id')
-    def _amount_compute(self):
+    def _inverse_amount_total(self):
         for move in self:
-            total = 0.0
-            total_currency = 0.0
-            currency_id = move.line_ids and move.line_ids[0].currency_id.id or False
-            for line in move.line_ids.filtered(lambda l: l.debit):
-                total += line.debit
-                if currency_id and line.currency_id.id == currency_id:
-                    total_currency += line.amount_currency
-                elif currency_id:
-                    currency_id = False
-
-            if currency_id and total_currency:
-                move.amount = total_currency
-                move.currency_id = currency_id
+            if len(move.line_ids) != 2 or move.type != 'entry':
+                continue
+
+            to_write = []
+
+            if move.currency_id != move.company_id.currency_id:
+                amount_currency = abs(move.amount_total)
+                balance = move.currency_id._convert(amount_currency, move.currency_id, move.company_id, move.date)
             else:
-                move.currency_id = move.company_id.currency_id or self.env.user.company_id.currency_id
-                move.amount = total
+                balance = abs(move.amount_total)
+                amount_currency = 0.0
+
+            for line in move.line_ids:
+                to_write.append((1, line.id, {
+                    'debit': line.balance > 0.0 and balance or 0.0,
+                    'credit': line.balance < 0.0 and balance or 0.0,
+                    'amount_currency': line.balance > 0.0 and amount_currency or -amount_currency,
+                }))
+
+            move.write({'line_ids': to_write})
 
     @api.multi
-    def _set_amount(self):
+    def _get_domain_matching_supsense_moves(self):
+        self.ensure_one()
+        domain = self.env['account.move.line']._get_suspense_moves_domain()
+        domain += ['|', ('partner_id', '=?', self.partner_id.id), ('partner_id', '=', False)]
+        if self.is_inbound():
+            domain.append(('balance', '=', -self.amount_residual))
+        else:
+            domain.append(('balance', '=', self.amount_residual))
+        return domain
+
+    def _compute_has_matching_suspense_amount(self):
+        for r in self:
+            res = False
+            if r.state == 'posted' and r.is_invoice() and r.invoice_payment_state == 'not_paid':
+                domain = r._get_domain_matching_supsense_moves()
+                #there are more than one but less than 5 suspense moves matching the residual amount
+                if (0 < self.env['account.move.line'].search_count(domain) < 5):
+                    domain2 = [
+                        ('invoice_payment_state', '=', 'not_paid'),
+                        ('state', '=', 'open'),
+                        ('amount_residual', '=', r.amount_residual),
+                        ('type', '=', r.type)]
+                    #there are less than 5 other open invoices of the same type with the same residual
+                    if self.env['account.move'].search_count(domain2) < 5:
+                        res = True
+            r.invoice_has_matching_supsense_amount = res
+
+    @api.depends('partner_id', 'invoice_source_email')
+    def _compute_invoice_vendor_display_info(self):
         for move in self:
-            if len(move.line_ids) == 2 and move.amount != 0:
-                amount_in_company_currency = move.amount
-                if move.currency_id and move.currency_id != move.company_id.currency_id:
-                    amount_in_company_currency = move.currency_id._convert(move.amount, move.company_id.currency_id, move.company_id, move.date)
-                    for line in move.line_ids:
-                        line.amount_currency = line.debit and move.amount or -move.amount
-                for line in move.with_context(check_move_validity=False).line_ids:
-                    line.debit = line.debit and amount_in_company_currency or 0.0
-                    line.credit = line.credit and amount_in_company_currency or 0.0
-
-    @api.depends('line_ids.debit', 'line_ids.credit', 'line_ids.matched_debit_ids.amount', 'line_ids.matched_credit_ids.amount', 'line_ids.account_id.user_type_id.type')
-    def _compute_matched_percentage(self):
-        """Compute the percentage to apply for cash basis method. This value is relevant only for moves that
-        involve journal items on receivable or payable accounts.
+            vendor_display_name = move.partner_id.name
+            move.invoice_icon = ''
+            if not vendor_display_name:
+                if move.invoice_source_email:
+                    vendor_display_name = _('From: ') + move.invoice_source_email
+                    move.invoice_vendor_icon = '@'
+                else:
+                    vendor_display_name = ('Created by: ') + move.create_uid.name
+                    move.invoice_vendor_icon = '#'
+            move.invoice_vendor_display_name = vendor_display_name
+
+    @api.depends('state', 'journal_id', 'invoice_date')
+    def _compute_invoice_sequence_number_next(self):
+        """ computes the prefix of the number that will be assigned to the first invoice/bill/refund of a journal, in order to
+        let the user manually change it.
         """
+        # Check user group.
+        system_user = self.env.user._is_system()
+        if not system_user:
+            return
+
+        # Check moves being candidates to set a custom number next.
+        moves = self.filtered(lambda move: move.is_invoice() and move.name == '/')
+        if not moves:
+            return
+
+        for key, group in groupby(moves, key=lambda move: (move.journal_id, move._get_sequence())):
+            journal, sequence = key
+            domain = [('journal_id', '=', journal.id), ('state', '=', 'posted')]
+            if not isinstance(self.id, models.NewId):
+                domain.append(('id', '!=', self.id))
+            if journal.type == 'sale':
+                domain.append(('type', 'in', ('out_invoice', 'out_refund')))
+            elif journal.type == 'purchase':
+                domain.append(('type', 'in', ('in_invoice', 'in_refund')))
+            else:
+                continue
+            if self.search_count(domain):
+                continue
+
+            for move in group:
+                prefix, dummy = sequence._get_prefix_suffix(date=move.invoice_date or fields.Date.today(), date_range=move.invoice_date)
+                number_next = sequence._get_current_sequence().number_next_actual
+                move.invoice_sequence_number_next_prefix = prefix
+                move.invoice_sequence_number_next = '%%0%sd' % sequence.padding % number_next
+
+    @api.multi
+    def _inverse_invoice_sequence_number_next(self):
+        ''' Set the number_next on the sequence related to the invoice/bill/refund'''
+        # Check user group.
+        if not self.env.user._is_admin():
+            return
+
+        # Set the next number in the sequence.
         for move in self:
-            total_amount = 0.0
-            total_reconciled = 0.0
-            for line in move.line_ids:
-                if line.account_id.user_type_id.type in ('receivable', 'payable'):
-                    amount = abs(line.debit - line.credit)
-                    total_amount += amount
-            precision_currency = move.currency_id or move.company_id.currency_id
-            if float_is_zero(total_amount, precision_rounding=precision_currency.rounding):
-                move.matched_percentage = 1.0
+            if not move.invoice_sequence_number_next:
+                continue
+            sequence = move._get_sequence()
+            nxt = re.sub("[^0-9]", '', move.invoice_sequence_number_next)
+            result = re.match("(0*)([0-9]+)", nxt)
+            if result and sequence:
+                date_sequence = sequence._get_current_sequence()
+                date_sequence.number_next_actual = int(result.group(2))
+
+    @api.multi
+    def _compute_payments_widget_to_reconcile_info(self):
+        for move in self:
+            move.invoice_outstanding_credits_debits_widget = json.dumps(False)
+
+            if move.state != 'posted' or move.invoice_payment_state != 'not_paid' or not move.is_invoice(include_receipts=True):
+                continue
+            pay_term_line_ids = move.line_ids.filtered(lambda line: line.account_id.user_type_id.type in ('receivable', 'payable'))
+
+            domain = [('account_id', 'in', pay_term_line_ids.mapped('account_id').ids),
+                      ('move_id.state', '=', 'posted'),
+                      ('partner_id', '=', move.commercial_partner_id.id),
+                      ('reconciled', '=', False), '|', ('amount_residual', '!=', 0.0),
+                      ('amount_residual_currency', '!=', 0.0)]
+
+            if move.is_inbound():
+                domain.extend([('credit', '>', 0), ('debit', '=', 0)])
+                type_payment = _('Outstanding credits')
             else:
-                for line in move.line_ids:
-                    if line.account_id.user_type_id.type in ('receivable', 'payable'):
-                        for partial_line in (line.matched_debit_ids + line.matched_credit_ids):
-                            total_reconciled += partial_line.amount
-                move.matched_percentage = total_reconciled / total_amount
+                domain.extend([('credit', '=', 0), ('debit', '>', 0)])
+                type_payment = _('Outstanding debits')
+            info = {'title': '', 'outstanding': True, 'content': [], 'move_id': move.id}
+            lines = self.env['account.move.line'].search(domain)
+            currency_id = move.currency_id
+            if len(lines) != 0:
+                for line in lines:
+                    # get the outstanding residual value in invoice currency
+                    if line.currency_id and line.currency_id == move.currency_id:
+                        amount_to_show = abs(line.amount_residual_currency)
+                    else:
+                        currency = line.company_id.currency_id
+                        amount_to_show = currency._convert(abs(line.amount_residual), move.currency_id, move.company_id,
+                                                           line.date or fields.Date.today())
+                    if float_is_zero(amount_to_show, precision_rounding=move.currency_id.rounding):
+                        continue
+                    info['content'].append({
+                        'journal_name': line.ref or line.move_id.name,
+                        'amount': amount_to_show,
+                        'currency': currency_id.symbol,
+                        'id': line.id,
+                        'position': currency_id.position,
+                        'digits': [69, move.currency_id.decimal_places],
+                    })
+                info['title'] = type_payment
+                move.invoice_outstanding_credits_debits_widget = json.dumps(info)
+                move.invoice_has_outstanding = True
 
     @api.multi
-    @api.depends('line_ids.reconcile_model_id')
-    def _compute_reconcile_model(self):
+    def _get_reconciled_info_JSON_values(self):
+        self.ensure_one()
+        foreign_currency = self.currency_id if self.currency_id != self.company_id.currency_id else False
+
+        reconciled_vals = []
+        pay_term_line_ids = self.line_ids.filtered(lambda line: line.account_id.user_type_id.type in ('receivable', 'payable'))
+        partials = pay_term_line_ids.mapped('matched_debit_ids') + pay_term_line_ids.mapped('matched_credit_ids')
+        for partial in partials:
+            counterpart_lines = partial.debit_move_id + partial.credit_move_id
+            counterpart_line = counterpart_lines.filtered(lambda line: line not in self.line_ids)
+
+            if foreign_currency and partial.currency_id == foreign_currency:
+                amount = partial.amount_currency
+            else:
+                amount = partial.company_currency_id._convert(partial.amount, self.currency_id, self.company_id, self.date)
+
+            if float_is_zero(amount, precision_rounding=self.currency_id.rounding):
+                continue
+
+            ref = counterpart_line.move_id.name
+            if counterpart_line.move_id.ref:
+                ref += ' (' + counterpart_line.move_id.ref + ')'
+
+            reconciled_vals.append({
+                'name': counterpart_line.name,
+                'journal_name': counterpart_line.journal_id.name,
+                'amount': amount,
+                'currency': self.currency_id.symbol,
+                'digits': [69, self.currency_id.decimal_places],
+                'position': self.currency_id.position,
+                'date': counterpart_line.date,
+                'payment_id': counterpart_line.id,
+                'account_payment_id': counterpart_line.payment_id.id,
+                'move_id': counterpart_line.move_id.id,
+                'ref': ref,
+            })
+        return reconciled_vals
+
+    @api.depends('type', 'line_ids.amount_residual')
+    def _compute_payments_widget_reconciled_info(self):
         for move in self:
-            move.reconcile_model_id = move.line_ids.mapped('reconcile_model_id')
+            if move.state != 'posted' or not move.is_invoice(include_receipts=True):
+                continue
+            reconciled_vals = move._get_reconciled_info_JSON_values()
+            if reconciled_vals:
+                info = {
+                    'title': _('Less Payment'),
+                    'outstanding': False,
+                    'content': reconciled_vals,
+                }
+                move.invoice_payments_widget = json.dumps(info, default=date_utils.json_default)
+            else:
+                move.invoice_payments_widget = json.dumps(False)
+
+    @api.depends('line_ids.price_subtotal', 'line_ids.tax_base_amount', 'line_ids.tax_line_id', 'partner_id', 'currency_id')
+    def _compute_invoice_taxes_by_group(self):
+        ''' Helper to get the taxes grouped according their account.tax.group.
+        This method is only used when printing the invoice.
+        '''
+        for move in self:
+            lang_env = move.with_context(lang=move.partner_id.lang).env
+            tax_lines = move.line_ids.filtered(lambda line: line.tax_line_id)
+            res = {}
+            for line in tax_lines:
+                res.setdefault(line.tax_line_id.tax_group_id, {'base': 0.0, 'amount': 0.0})
+                res[line.tax_line_id.tax_group_id]['amount'] += line.price_subtotal
+                res[line.tax_line_id.tax_group_id]['base'] += line.tax_base_amount
+            res = sorted(res.items(), key=lambda l: l[0].sequence)
+            move.amount_by_group = [(
+                group.name, amounts['amount'],
+                amounts['base'],
+                formatLang(lang_env, amounts['amount'], currency_obj=move.currency_id),
+                formatLang(lang_env, amounts['base'], currency_obj=move.currency_id),
+                len(res),
+            ) for group, amounts in res]
+
+    # -------------------------------------------------------------------------
+    # CONSTRAINS METHODS
+    # -------------------------------------------------------------------------
+
+    @api.constrains('line_ids', 'journal_id')
+    def _validate_move_modification(self):
+        if 'posted' in self.mapped('line_ids.payment_id.state'):
+            raise ValidationError(_("You cannot modify a journal entry linked to a posted payment."))
+
+    @api.constrains('name', 'journal_id')
+    def _check_unique_sequence_number(self):
+        if not self:
+            return
+
+        self._cr.execute('''
+            SELECT move.id
+            FROM account_move move
+            INNER JOIN account_move move2 ON
+                move2.name = move.name
+                AND move2.company_id = move.company_id
+                AND move2.journal_id = move.journal_id
+                AND move2.type = move.type
+                AND move2.id != move.id
+            WHERE move.id IN %s
+            AND move.state = 'posted'
+            AND move2.state = 'posted'
+        ''', [tuple(self.ids)])
+        res = self._cr.fetchone()
+        if res:
+            raise ValidationError(_('Posted journal entry must have an unique sequence number per company.'))
+
+    @api.constrains('ref')
+    def _check_duplicate_supplier_reference(self):
+        moves = self.filtered(lambda move: move.is_purchase_document() and move.ref)
+        if not moves:
+            return
+
+        self._cr.execute('''
+            SELECT move.id
+            FROM account_move move
+            INNER JOIN account_move move2 ON
+                move2.ref = move.ref
+                AND move2.company_id = move.company_id
+                AND move2.commercial_partner_id = move.commercial_partner_id
+                AND move2.type = move.type
+                AND move2.id != move.id
+            WHERE move.id IN %s
+            AND move.type in ('in_invoice', 'in_refund')
+            AND move.ref IS NOT NULL
+        ''', [tuple(self.ids)])
+        if self._cr.fetchone():
+            raise ValidationError(_('Duplicated vendor reference detected. You probably encoded twice the same vendor bill/credit note.'))
+
+    @api.multi
+    def _check_balanced(self):
+        ''' Assert the move is fully balanced debit = credit.
+        An error is raised if it's not the case.
+        '''
+        moves = self.filtered(lambda move: move.line_ids)
+        if not moves:
+            return
+
+        # /!\ As this method is called in create / write, we can't make the assumption the computed stored fields
+        # are already done. Then, this query MUST NOT depend of computed stored fields (e.g. balance).
+        # It happens as the ORM makes the create with the 'no_recompute' statement.
+        self._cr.execute('''
+            SELECT line.move_id
+            FROM account_move_line line
+            JOIN account_move move ON move.id = line.move_id
+            JOIN account_journal journal ON journal.id = move.journal_id
+            JOIN res_company company ON company.id = journal.company_id
+            JOIN res_currency currency ON currency.id = company.currency_id
+            WHERE line.move_id IN %s
+            GROUP BY line.move_id, currency.decimal_places
+            HAVING ROUND(SUM(debit - credit), currency.decimal_places) != 0.0;
+        ''', [tuple(self.ids)])
+
+        query_res = self._cr.fetchall()
+        if query_res:
+            ids = [res[0] for res in query_res]
+            raise UserError(_("Cannot create unbalanced journal entry. Ids: %s") % str(ids))
+
+    @api.multi
+    def _check_fiscalyear_lock_date(self):
+        for move in self:
+            lock_date = max(move.company_id.period_lock_date or date.min, move.company_id.fiscalyear_lock_date or date.min)
+            if self.user_has_groups('account.group_account_manager'):
+                lock_date = move.company_id.fiscalyear_lock_date
+            if move.date <= (lock_date or date.min):
+                if self.user_has_groups('account.group_account_manager'):
+                    message = _("You cannot add/modify entries prior to and inclusive of the lock date %s") % lock_date
+                else:
+                    message = _("You cannot add/modify entries prior to and inclusive of the lock date %s. Check the company settings or ask someone with the 'Adviser' role") % lock_date
+                raise UserError(message)
+        return True
+
+    @api.multi
+    def _check_tax_lock_date(self):
+        if not self:
+            return
+
+        self._cr.execute('''
+            SELECT move.id, company.tax_lock_date
+            FROM account_move move
+            JOIN account_journal journal ON journal.id = move.journal_id
+            JOIN res_company company ON company.id = journal.company_id
+            WHERE move.id IN %s
+            AND move.date < company.tax_lock_date
+        ''', [tuple(self.ids)])
+
+        query_res = self._cr.fetchone()
+        if query_res:
+            raise UserError(_('''
+                The operation is refused as it would impact an already issued tax statement.
+                Please change the journal entry date or the tax lock date set in the settings (%s) to proceed
+            ''' % query_res[1]))
+
+    @api.multi
+    def _check_move_consistency(self):
+        for move in self:
+            if move.line_ids:
+                if not all([x.company_id.id == move.company_id.id for x in move.line_ids]):
+                    raise UserError(_("Cannot create moves for different companies."))
+
+        self._check_balanced()
+        self._check_fiscalyear_lock_date()
+
+    # -------------------------------------------------------------------------
+    # LOW-LEVEL METHODS
+    # -------------------------------------------------------------------------
+
+    @api.multi
+    def _move_autocomplete_invoice_lines_values(self):
+        ''' This method recomputes dynamic lines on the current journal entry that include taxes, cash rounding
+        and payment terms lines.
+        '''
+        self.ensure_one()
+
+        line_currency = self.currency_id if self.currency_id != self.company_id.currency_id else False
+        for line in self.line_ids:
+            # Do something only on invoice lines.
+            if line.exclude_from_invoice_tab:
+                continue
+
+            # Ensure related fields are well copied.
+            line.partner_id = self.partner_id
+            line.date = self.date
+            line.recompute_tax_line = True
+            line.currency_id = line_currency
+
+            # Shortcut to load the demo data.
+            if not line.account_id:
+                line.account_id = line._get_computed_account()
+                if not line.account_id:
+                    if self.is_sale_document(include_receipts=True):
+                        line.account_id = self.journal_id.default_credit_account_id
+                    elif self.is_purchase_document(include_receipts=True):
+                        line.account_id = self.journal_id.default_debit_account_id
+
+        self.line_ids._onchange_price_subtotal()
+        self._recompute_dynamic_lines(recompute_all_taxes=True)
+
+        values = self._convert_to_write(self._cache)
+        values.pop('invoice_line_ids', None)
+        return values
+
+    @api.model
+    def _move_autocomplete_invoice_lines_create(self, vals_list):
+        ''' During the create of an account.move with only 'invoice_line_ids' set and not 'line_ids', this method is called
+        to auto compute accounting lines of the invoice. In that case, accounts will be retrieved and taxes, cash rounding
+        and payment terms will be computed. At the end, the values will contains all accounting lines in 'line_ids'
+        and the moves should be balanced.
+
+        :param vals_list:   The list of values passed to the 'create' method.
+        :return:            Modified list of values.
+        '''
+        new_vals_list = []
+        for vals in vals_list:
+            if not vals.get('invoice_line_ids'):
+                new_vals_list.append(vals)
+                continue
+            if vals.get('line_ids'):
+                vals.pop('invoice_line_ids', None)
+                new_vals_list.append(vals)
+                continue
+            if not vals.get('type') and not self._context.get('default_type'):
+                vals.pop('invoice_line_ids', None)
+                new_vals_list.append(vals)
+                continue
+            vals['type'] = vals.get('type', self._context.get('default_type', 'entry'))
+            if not vals['type'] in self.get_invoice_types(include_receipts=True):
+                new_vals_list.append(vals)
+                continue
+
+            vals['line_ids'] = vals.pop('invoice_line_ids')
+
+            if vals.get('invoice_date') and not vals.get('date'):
+                vals['date'] = vals['invoice_date']
+
+            ctx_vals = {'default_type': vals.get('type') or self._context.get('default_type')}
+            if vals.get('journal_id'):
+                ctx_vals['default_journal_id'] = vals['journal_id']
+            self_ctx = self.with_context(**ctx_vals)
+            new_vals = self_ctx._add_missing_default_values(vals)
+
+            move = self_ctx.new(new_vals)
+            new_vals_list.append(move._move_autocomplete_invoice_lines_values())
+        return new_vals_list
+
+    @api.multi
+    def _move_autocomplete_invoice_lines_write(self, vals):
+        ''' During the write of an account.move with only 'invoice_line_ids' set and not 'line_ids', this method is called
+        to auto compute accounting lines of the invoice. In that case, accounts will be retrieved and taxes, cash rounding
+        and payment terms will be computed. At the end, the values will contains all accounting lines in 'line_ids'
+        and the moves should be balanced.
+
+        :param vals_list:   A python dict representing the values to write.
+        :return:            True if the auto-completion did something, False otherwise.
+        '''
+        enable_autocomplete = 'invoice_line_ids' in vals and 'line_ids' not in vals and True or False
+
+        if not enable_autocomplete:
+            return False
+
+        vals['line_ids'] = vals.pop('invoice_line_ids')
+        for invoice in self:
+            invoice_new = invoice.with_context(default_type=invoice.type, default_journal_id=invoice.journal_id.id).new(origin=invoice)
+            invoice_new.update(vals)
+            values = invoice_new._move_autocomplete_invoice_lines_values()
+            values.pop('invoice_line_ids', None)
+            invoice.write(values)
+        return True
+
+    @api.model_create_multi
+    def create(self, vals_list):
+        # OVERRIDE
+        vals_list = self._move_autocomplete_invoice_lines_create(vals_list)
+
+        moves = super(AccountMove, self).create(vals_list)
+
+        # Trigger 'action_invoice_paid' when the invoice is directly paid at its creation.
+        moves.filtered(lambda move: move.is_invoice(include_receipts=True) and move.invoice_payment_state in ('paid', 'in_payment')).action_invoice_paid()
+
+        return moves
+
+    @api.multi
+    def write(self, vals):
+        not_paid_invoices = self.filtered(lambda move: move.is_invoice(include_receipts=True) and move.invoice_payment_state not in ('paid', 'in_payment'))
+
+        if self._move_autocomplete_invoice_lines_write(vals):
+            res = True
+        else:
+            vals.pop('invoice_line_ids', None)
+            res = super(AccountMove, self.with_context(check_move_validity=False)).write(vals)
+
+        # Ensure the move is still well balanced.
+        if 'line_ids' in vals and self._context.get('check_move_validity', True):
+            # 'check_move_validity' is needed as the write will be done line per line.
+            self._check_move_consistency()
+
+        # Trigger 'action_invoice_paid' when the invoice becomes paid after a write.
+        not_paid_invoices.filtered(lambda move: move.invoice_payment_state in ('paid', 'in_payment')).action_invoice_paid()
+
+        return res
+
+    @api.multi
+    def unlink(self):
+        for move in self:
+            # check the lock date + check if some entries are reconciled
+            move.line_ids._update_check()
+            move.line_ids.unlink()
+        return super(AccountMove, self).unlink()
+
+    @api.multi
+    @api.depends('name', 'state')
+    def name_get(self):
+        result = []
+        for move in self:
+            if self._context.get('name_groupby') and not (move.type == 'entry' and move.state == 'draft'):
+                name = '**%s**, %s       %s' % (format_date(self.env, move.date), move.name, move.partner_id.name or '')
+            elif move.type == 'entry':
+                # Miscellaneous operation.
+                if move.state == 'draft':
+                    name = '* %s' % str(move.id)
+                else:
+                    name = move.name
+            else:
+                # Invoice.
+                name = move._get_invoice_display_name(show_ref=True)
+            result.append((move.id, name))
+        return result
+
+    @api.multi
+    def _track_subtype(self, init_values):
+        # OVERRIDE to add custom subtype depending of the state.
+        self.ensure_one()
+
+        if not self.is_invoice(include_receipts=True):
+            return super(AccountMove, self)._track_subtype(init_values)
+
+        if 'invoice_payment_state' in init_values and self.invoice_payment_state == 'paid':
+            return self.env.ref('account.mt_invoice_paid')
+        elif 'state' in init_values and self.state == 'posted' and self.is_sale_document(include_receipts=True):
+            return self.env.ref('account.mt_invoice_validated')
+        elif 'state' in init_values and self.state == 'draft' and self.is_sale_document(include_receipts=True):
+            return self.env.ref('account.mt_invoice_created')
+        return super(AccountMove, self)._track_subtype(init_values)
+
+    # -------------------------------------------------------------------------
+    # BUSINESS METHODS
+    # -------------------------------------------------------------------------
 
     @api.model
-    @api.depends('reconcile_model_id')
-    def _search_reconcile_model(self, operator, operand):
-        if operand:
-            rmi = self.search([('line_ids.reconcile_model_id', operator, operand)])
+    def get_invoice_types(self, include_receipts=False):
+        return ['out_invoice', 'out_refund', 'in_refund', 'in_invoice'] + (include_receipts and ['out_receipt', 'in_receipt'] or [])
+
+    def is_invoice(self, include_receipts=False):
+        return self.type in self.get_invoice_types(include_receipts)
+
+    @api.model
+    def get_sale_types(self, include_receipts=False):
+        return ['out_invoice', 'out_refund'] + (include_receipts and ['out_receipt'] or [])
+
+    def is_sale_document(self, include_receipts=False):
+        return self.type in self.get_sale_types(include_receipts)
+
+    @api.model
+    def get_purchase_types(self, include_receipts=False):
+        return ['in_invoice', 'in_refund'] + (include_receipts and ['in_receipt'] or [])
+
+    def is_purchase_document(self, include_receipts=False):
+        return self.type in self.get_purchase_types(include_receipts)
+
+    @api.model
+    def get_inbound_types(self, include_receipts=True):
+        return ['out_invoice', 'in_refund'] + (include_receipts and ['out_receipt'] or [])
+
+    def is_inbound(self, include_receipts=True):
+        return self.type in self.get_inbound_types(include_receipts)
+
+    @api.model
+    def get_outbound_types(self, include_receipts=True):
+        return ['in_invoice', 'out_refund'] + (include_receipts and ['in_receipt'] or [])
+
+    def is_outbound(self, include_receipts=True):
+        return self.type in self.get_outbound_types(include_receipts)
+
+    @api.multi
+    def _get_invoice_reference_euro_invoice(self):
+        """ This computes the reference based on the RF Creditor Reference.
+            The data of the reference is the database id number of the invoice.
+            For instance, if an invoice is issued with id 43, the check number
+            is 07 so the reference will be 'RF07 43'.
+        """
+        self.ensure_one()
+        base = self.id
+        check_digits = mod_97_10.calc_check_digits('{}RF'.format(base))
+        reference = 'RF{} {}'.format(check_digits, " ".join(["".join(x) for x in zip_longest(*[iter(str(base))]*4, fillvalue="")]))
+        return reference
+
+    @api.multi
+    def _get_invoice_reference_euro_partner(self):
+        """ This computes the reference based on the RF Creditor Reference.
+            The data of the reference is the user defined reference of the
+            partner or the database id number of the parter.
+            For instance, if an invoice is issued for the partner with internal
+            reference 'food buyer 654', the digits will be extracted and used as
+            the data. This will lead to a check number equal to 00 and the
+            reference will be 'RF00 654'.
+            If no reference is set for the partner, its id in the database will
+            be used.
+        """
+        self.ensure_one()
+        partner_ref = self.partner_id.ref
+        partner_ref_nr = re.sub('\D', '', partner_ref or '')[-21:] or str(self.partner_id.id)[-21:]
+        partner_ref_nr = partner_ref_nr[-21:]
+        check_digits = mod_97_10.calc_check_digits('{}RF'.format(partner_ref_nr))
+        reference = 'RF{} {}'.format(check_digits, " ".join(["".join(x) for x in zip_longest(*[iter(partner_ref_nr)]*4, fillvalue="")]))
+        return reference
+
+    @api.multi
+    def _get_invoice_reference_odoo_invoice(self):
+        """ This computes the reference based on the Odoo format.
+            We simply return the number of the invoice, defined on the journal
+            sequence.
+        """
+        self.ensure_one()
+        return self.name
+
+    @api.multi
+    def _get_invoice_reference_odoo_partner(self):
+        """ This computes the reference based on the Odoo format.
+            The data used is the reference set on the partner or its database
+            id otherwise. For instance if the reference of the customer is
+            'dumb customer 97', the reference will be 'CUST/dumb customer 97'.
+        """
+        ref = self.partner_id.ref or str(self.partner_id.id)
+        prefix = _('CUST')
+        return '%s/%s' % (prefix, ref)
+
+    @api.multi
+    def _get_invoice_computed_reference(self):
+        self.ensure_one()
+        if self.journal_id.invoice_reference_type == 'none':
+            return ''
         else:
-            rmi = self.search([('line_ids', operator, operand)])
-        if rmi:
-            return [('id', 'in', rmi.ids)]
-        return [('id', '=', False)]
+            ref_function = getattr(self, '_get_invoice_reference_{}_{}'.format(self.journal_id.invoice_reference_model, self.journal_id.invoice_reference_type))
+            if ref_function:
+                return ref_function()
+            else:
+                raise UserError(_('The combination of reference model and reference type on the journal is not implemented'))
 
     @api.multi
-    def _get_default_journal(self):
-        if self.env.context.get('default_journal_type'):
-            return self.env['account.journal'].search([('company_id', '=', self.env.company.id), ('type', '=', self.env.context['default_journal_type'])], limit=1).id
+    def _get_sequence(self):
+        ''' Return the sequence to be used during the post of the current move.
+        :return: An ir.sequence record or False.
+        '''
+        self.ensure_one()
+
+        journal = self.journal_id
+        if self.type in ('entry', 'out_invoice', 'in_invoice') or not journal.refund_sequence:
+            return journal.sequence_id
+        if not journal.refund_sequence_id:
+            return
+        return journal.refund_sequence_id
+
+    @api.multi
+    def _get_invoice_display_name(self, show_ref=False):
+        ''' Helper to get the display name of an invoice depending of its type.
+        :param show_ref:    A flag indicating of the display name must include or not the journal entry reference.
+        :return:            A string representing the invoice.
+        '''
+        self.ensure_one()
+        if self.state == 'draft':
+            return {
+                'out_invoice': _('Draft Invoice'),
+                'out_refund': _('Credit Note'),
+                'in_invoice': _('Vendor Bill'),
+                'in_refund': _('Vendor Credit Note'),
+                'out_receipt': _('Sales Receipt'),
+                'in_receipt': _('Purchase Receipt'),
+            }[self.type]
+        else:
+            return ('%s' % self.name) + (show_ref and self.ref and '(%s)' % self.ref or '')
+
+    @api.multi
+    def _get_invoice_delivery_partner_id(self):
+        ''' Hook allowing to retrieve the right delivery address depending of installed modules.
+        :return: A res.partner record's id representing the delivery address.
+        '''
+        self.ensure_one()
+        return self.partner_id.address_get(['delivery'])['delivery']
+
+    @api.multi
+    def _get_invoice_intrastat_country_id(self):
+        ''' Hook allowing to retrieve the intrastat country depending of installed modules.
+        :return: A res.country record's id.
+        '''
+        self.ensure_one()
+        return self.partner_id.country_id.id
+
+    @api.multi
+    def _get_cash_basis_matched_percentage(self):
+        """Compute the percentage to apply for cash basis method. This value is relevant only for moves that
+        involve journal items on receivable or payable accounts.
+        """
+        self.ensure_one()
+        query = '''
+            SELECT
+            (
+                SELECT COALESCE(SUM(line.balance), 0.0)
+                FROM account_move_line line
+                JOIN account_account account ON account.id = line.account_id
+                JOIN account_account_type account_type ON account_type.id = account.user_type_id
+                WHERE line.move_id = %s AND account_type.type IN ('receivable', 'payable')
+            ) AS total_amount,
+            (
+                SELECT COALESCE(SUM(partial.amount), 0.0)
+                FROM account_move_line line
+                JOIN account_account account ON account.id = line.account_id
+                JOIN account_account_type account_type ON account_type.id = account.user_type_id
+                LEFT JOIN account_partial_reconcile partial ON
+                    partial.debit_move_id = line.id
+                    OR
+                    partial.credit_move_id = line.id
+                WHERE line.move_id = %s AND account_type.type IN ('receivable', 'payable')
+            ) AS total_reconciled
+        '''
+        params = [self.id, self.id]
+        self._cr.execute(query, params)
+        total_amount, total_reconciled = self._cr.fetchone()
+        if float_is_zero(total_amount, precision_rounding=self.company_id.currency_id.rounding):
+            return 1.0
+        else:
+            return abs(total_reconciled / total_amount)
 
     @api.multi
-    @api.depends('line_ids.partner_id')
-    def _compute_partner_id(self):
-        for move in self:
-            partner = move.line_ids.mapped('partner_id')
-            move.partner_id = partner.id if len(partner) == 1 else False
-
-    @api.onchange('date')
-    def _onchange_date(self):
-        '''On the form view, a change on the date will trigger onchange() on account.move
-        but not on account.move.line even the date field is related to account.move.
-        Then, trigger the _onchange_amount_currency manually.
+    def _reverse_move_vals(self, default_values, cancel=True):
+        ''' Reverse values passed as parameter being the copied values of the original journal entry.
+        For example, debit / credit must be switched. The tax lines must be edited in case of refunds.
+
+        :param default_values:  A copy_date of the original journal entry.
+        :param cancel:          A flag indicating the reverse is made to cancel the original journal entry.
+        :return:                The updated default_values.
         '''
-        self.line_ids._onchange_amount_currency()
-
-    name = fields.Char(string='Number', required=True, copy=False, default='/')
-    ref = fields.Char(string='Reference', copy=False)
-    date = fields.Date(required=True, states={'posted': [('readonly', True)]}, index=True, default=fields.Date.context_today)
-    journal_id = fields.Many2one('account.journal', string='Journal', required=True, states={'posted': [('readonly', True)]}, default=_get_default_journal)
-    state = fields.Selection([('draft', 'Unposted'), ('posted', 'Posted')], string='Status',
-      required=True, readonly=True, copy=False, default='draft',
-      help='All manually created new journal entries are usually in the status \'Unposted\', '
-           'but you can set the option to skip that status on the related journal. '
-           'In that case, they will behave as journal entries automatically created by the '
-           'system on document validation (invoices, bank statements...) and will be created '
-           'in \'Posted\' status.')
-    line_ids = fields.One2many('account.move.line', 'move_id', string='Journal Items',
-        states={'posted': [('readonly', True)]}, copy=True)
-    partner_id = fields.Many2one('res.partner', compute='_compute_partner_id', string="Partner", store=True, readonly=True)
-    amount = fields.Monetary(compute='_amount_compute', inverse="_set_amount", store=True)
-    currency_id = fields.Many2one('res.currency', compute='_amount_compute', store=True, string="Currency")
-    narration = fields.Text(string='Internal Note')
-    company_id = fields.Many2one('res.company', related='journal_id.company_id', string='Company', store=True, readonly=True)
-    matched_percentage = fields.Float('Percentage Matched', compute='_compute_matched_percentage', digits=0, store=True, readonly=True, help="Technical field used in cash basis method")
-    reconcile_model_id = fields.Many2many('account.reconcile.model', compute='_compute_reconcile_model', search='_search_reconcile_model', string="Reconciliation Model", readonly=True)
-    # Dummy Account field to search on account.move by account_id
-    dummy_account_id = fields.Many2one('account.account', related='line_ids.account_id', string='Account', store=False, readonly=True)
-    tax_cash_basis_rec_id = fields.Many2one(
-        'account.partial.reconcile',
-        string='Tax Cash Basis Entry of',
-        help="Technical field used to keep track of the tax cash basis reconciliation. "
-        "This is needed when cancelling the source: it will post the inverse journal entry to cancel that part too.")
-    auto_post = fields.Boolean(string='Post Automatically', default=False, help='If this checkbox is ticked, this entry will be automatically posted at its date.')
-    reverse_entry_id = fields.Many2one('account.move', String="Reverse entry", store=True, readonly=True)
-    to_check = fields.Boolean(string='To Check', default=False, help='If this checkbox is ticked, it means that the user was not sure of all the related informations at the time of the creation of the move and that the move needs to be checked again.')
-    tax_type_domain = fields.Char(store=False, help='Technical field used to have a dynamic taxes domain on the form view.')
+        self.ensure_one()
 
-    @api.constrains('line_ids', 'journal_id')
-    def _validate_move_modification(self):
-        if 'posted' in self.mapped('line_ids.payment_id.state'):
-            raise ValidationError(_("You cannot modify a journal entry linked to a posted payment."))
+        def compute_tax_repartition_lines_mapping(move_vals):
+            ''' Computes and returns a mapping between the current repartition lines to the new expected one.
+            :param move_vals:   The newly created invoice as a python dictionary to be passed to the 'create' method.
+            :return:            A map invoice_repartition_line => refund_repartition_line.
+            '''
+            # invoice_repartition_line => refund_repartition_line
+            mapping = {}
+
+            # Do nothing if the move is not a credit note.
+            if move_vals['type'] not in ('out_refund', 'in_refund'):
+                return mapping
+
+            for line_command in move_vals.get('line_ids', []):
+                line_vals = line_command[2]  # (0, 0, {...})
+
+                if line_vals.get('tax_ids') and line_vals['tax_ids'][0][2]:
+                    # Base line.
+                    tax_ids = line_vals['tax_ids'][0][2]
+                elif line_vals.get('tax_line_id'):
+                    # Tax line.
+                    tax_ids = [line_vals['tax_line_id']]
+                else:
+                    continue
 
-    @api.onchange('journal_id')
-    def _onchange_journal_id(self):
-        self.tax_type_domain = self.journal_id.type if self.journal_id.type in ('sale', 'purchase') else None
+                for tax in self.env['account.tax'].browse(tax_ids):
+                    for inv_rep_line, ref_rep_line in zip(tax.invoice_repartition_line_ids, tax.refund_repartition_line_ids):
+                        mapping[inv_rep_line] = ref_rep_line
+            return mapping
 
-    @api.onchange('line_ids')
-    def _onchange_line_ids(self):
-        '''Compute additional lines corresponding to the taxes set on the line_ids.
+        move_vals = self.with_context(include_business_fields=True).copy_data(default=default_values)[0]
 
-        For example, add a line with 1000 debit and 15% tax, this onchange will add a new
-        line with 150 debit.
-        '''
-        def _str_to_list(string):
-            #remove heading and trailing brackets and return a list of int. This avoid calling safe_eval on untrusted field content
-            string = string[1:-1]
-            if string:
-                return [int(x) for x in string.split(',')]
-            return []
-
-        def _build_grouping_key(line):
-            #build a string containing all values used to create the tax line
-            return str(line.tax_ids.ids) + '-' + str(line.analytic_tag_ids.ids) + '-' + (line.analytic_account_id and str(line.analytic_account_id.id) or '')
-
-        def _parse_grouping_key(line):
-            # Retrieve values computed the last time this method has been run.
-            if not line.tax_line_grouping_key:
-                return {'tax_ids': [], 'tag_ids': [], 'analytic_account_id': False}
-            tax_str, tags_str, analytic_account_str = line.tax_line_grouping_key.split('-')
-            return {
-                'tax_ids': _str_to_list(tax_str),
-                'tag_ids': _str_to_list(tags_str),
-                'analytic_account_id': analytic_account_str and int(analytic_account_str) or False,
-            }
+        tax_repartition_lines_mapping = compute_tax_repartition_lines_mapping(move_vals)
 
-        def _find_existing_tax_line(line_ids, tax_repartition_line_id, analytic_tag_ids, analytic_account_id):
-            # tax_repartition_line_id, tag_ids and analytic_account_id are real ids
-            if tax.analytic:
-                return line_ids.filtered(lambda x: x.tax_repartition_line_id.id == tax_repartition_line_id and x.analytic_tag_ids.ids == analytic_tag_ids and x.analytic_account_id.id == analytic_account_id)
-            return line_ids.filtered(lambda x: x.tax_repartition_line_id.id == tax_repartition_line_id)
+        for line_command in move_vals.get('line_ids', []):
+            line_vals = line_command[2]  # (0, 0, {...})
 
-        def _get_lines_to_sum(line_ids, tax, tag_ids, analytic_account_id):
-            # tax is a real record; tag_ids and analytic_account_id are real ids
-            if tax.analytic:
-                return line_ids.filtered(lambda x: tax in x.tax_ids._origin and x.analytic_tag_ids.ids == tag_ids and x.analytic_account_id.id == analytic_account_id)
-            return line_ids.filtered(lambda x: tax in x.tax_ids._origin)
+            # ==== Inverse debit / credit / amount_currency ====
+            amount_currency = -line_vals.get('amount_currency', 0.0)
+            balance = line_vals['credit'] - line_vals['debit']
 
-        # Cache the already computed tax to avoid useless recalculation (real records)
-        processed_taxes = self.env['account.tax']
+            line_vals.update({
+                'amount_currency': amount_currency,
+                'debit': balance > 0.0 and balance or 0.0,
+                'credit': balance < 0.0 and -balance or 0.0,
+            })
 
-        self.ensure_one()
-        for line in self.line_ids.filtered(lambda x: x.recompute_tax_line):
-            # Retrieve old field values.
-            parsed_key = _parse_grouping_key(line)
-
-            # Unmark the line.
-            line.recompute_tax_line = False
-
-            # Manage group of taxes (new records)
-            group_taxes = line.tax_ids.filtered(lambda t: t.amount_type == 'group')
-            children_taxes = group_taxes.mapped('children_tax_ids')
-            if children_taxes:
-                line.tax_ids |= children_taxes
-                # Because the taxes on the line changed, we need to recompute them.
-                processed_taxes -= children_taxes._origin
-
-            # Get the taxes to process (actual records)
-            taxes = self.env['account.tax'].browse(parsed_key['tax_ids'])
-            taxes |= line.tax_ids._origin
-            taxes |= children_taxes._origin
-            to_process_taxes = (taxes - processed_taxes).filtered(lambda t: t.amount_type != 'group')
-            processed_taxes += to_process_taxes
-
-            # Apply tags on base line
-            line.tag_ids = taxes.mapped('invoice_repartition_line_ids').filtered(lambda x: x.repartition_type == 'base').mapped('tag_ids')
-
-            # Process taxes (real records)
-            for tax in to_process_taxes:
-                lines_to_sum = _get_lines_to_sum(self.line_ids, tax, parsed_key['tag_ids'], parsed_key['analytic_account_id'])
-
-                balance = sum([l.balance for l in lines_to_sum])
-
-                # Compute the tax amount one by one.
-                quantity = len(lines_to_sum) if tax.amount_type == 'fixed' else 1
-                taxes_vals = tax.compute_all(balance, quantity=quantity, currency=line.currency_id, product=line.product_id, partner=line.partner_id)
-
-                if taxes_vals.get('taxes'):
-                    for line_vals in taxes_vals['taxes']:
-                        tax_line = _find_existing_tax_line(self.line_ids, line_vals['tax_repartition_line_id'], parsed_key['tag_ids'], parsed_key['analytic_account_id'])
-                        if tax_line:
-                            if not lines_to_sum:
-                                # Drop tax line because the originator tax is no longer used.
-                                self.line_ids -= tax_line
-                            elif balance:
-                                # Update the existing tax_line.
-                                # Update the debit/credit amount according to the new balance.
-                                amount = line_vals['amount']
-                                account = line_vals['account_id'] or line.account_id
-                                tax_line.debit = amount > 0 and amount or 0.0
-                                tax_line.credit = amount < 0 and -amount or 0.0
-                                tax_line.account_id = account
-                            else:
-                                # Reset debit/credit in case of the originator line is temporary set to 0 in both debit/credit.
-                                tax_line.debit = tax_line.credit = 0.0
-                        else:
-                            # Create a new tax_line.
-                            amount = line_vals['amount']
-                            to_create_vals = {
-                                'account_id': line_vals['account_id'] or line.account_id.id,
-                                'name': line_vals['name'],
-                                'partner_id': line.partner_id.id,
-                                'debit': amount > 0 and amount or 0.0,
-                                'credit': amount < 0 and -amount or 0.0,
-                                'analytic_account_id': line.analytic_account_id.id if tax.analytic else False,
-                                'analytic_tag_ids': line.analytic_tag_ids.ids if tax.analytic else False,
-                                'move_id': self.id,
-                                'tax_exigible': tax.tax_exigibility == 'on_invoice',
-                                'company_id': self.company_id.id,
-                                'company_currency_id': self.company_id.currency_id.id,
-                                'tax_repartition_line_id': line_vals['tax_repartition_line_id'],
-                                'tag_ids': line_vals['tag_ids'],
-                                'tax_base_amount': line_vals['base'],
-                            }
-                            # N.B. currency_id/amount_currency are not set because if we have two lines with the same tax
-                            # and different currencies, we have no idea which currency set on this line.
-                            self.env['account.move.line'].new(to_create_vals)
-
-            # Keep record of the values used as taxes the last time this method has been run.
-            line.tax_line_grouping_key = _build_grouping_key(line)
+            if move_vals['type'] not in ('out_refund', 'in_refund'):
+                continue
 
-    @api.model
-    def fields_view_get(self, view_id=None, view_type='form', toolbar=False, submenu=False):
-        res = super(AccountMove, self).fields_view_get(
-            view_id=view_id, view_type=view_type, toolbar=toolbar, submenu=submenu)
-        if self._context.get('vat_domain'):
-            res['fields']['line_ids']['views']['tree']['fields']['tax_line_id']['domain'] = [('tag_ids', 'in', [self.env.ref(self._context.get('vat_domain')).id])]
-        return res
+            # ==== Map tax repartition lines ====
+            if line_vals.get('tax_ids') and line_vals['tax_ids'][0][2]:
+                # Base line.
+                invoice_repartition_lines = self.env['account.tax'].browse(line_vals['tax_ids'][0][2])\
+                    .mapped('invoice_repartition_line_ids')\
+                    .filtered(lambda line: line.repartition_type == 'base')
+                refund_repartition_lines = invoice_repartition_lines\
+                    .mapped(lambda line: tax_repartition_lines_mapping[line])
+
+                line_vals['tag_ids'] = [(6, 0, refund_repartition_lines.mapped('tag_ids').ids)]
+            elif line_vals.get('tax_repartition_line_id'):
+                # Tax line.
+                invoice_repartition_line = self.env['account.tax.repartition.line'].browse(line_vals['tax_repartition_line_id'])
+                refund_repartition_line = tax_repartition_lines_mapping[invoice_repartition_line]
+
+                # Find the right account.
+                account_id = self.env['account.move.line']._get_default_tax_account(refund_repartition_line).id
+                if not account_id:
+                    if not invoice_repartition_line.account_id:
+                        # Keep the current account as the current one comes from the base line.
+                        account_id = line_vals['account_id']
+                    else:
+                        tax = invoice_repartition_line.invoice_tax_id
+                        base_line = self.line_ids.filtered(lambda line: tax in line.tax_ids)[0]
+                        account_id = base_line.account_id.id
 
-    @api.model
-    def create(self, vals):
-        move = super(AccountMove, self.with_context(mail_create_nolog=True, check_move_validity=False, partner_id=vals.get('partner_id'))).create(vals)
-        move.assert_balanced()
-        return move
+                line_vals.update({
+                    'tax_repartition_line_id': refund_repartition_line.id,
+                    'account_id': account_id,
+                    'tag_ids': [(6, 0, refund_repartition_line.tag_ids.ids)],
+                })
+        return move_vals
 
     @api.multi
-    def write(self, vals):
-        if 'line_ids' in vals:
-            res = super(AccountMove, self.with_context(check_move_validity=False)).write(vals)
-            self.assert_balanced()
-        else:
-            res = super(AccountMove, self).write(vals)
-        return res
+    def _reverse_moves(self, default_values_list=None, cancel=False):
+        ''' Reverse a recordset of account.move.
+        If cancel parameter is true, the reconcilable or liquidity lines
+        of each original move will be reconciled with its reverse's.
+
+        :param default_values_list: A list of default values to consider per move.
+                                    ('type' & 'reversed_entry_id' are computed in the method).
+        :return:                    An account.move recordset, reverse of the current self.
+        '''
+        if not default_values_list:
+            default_values_list = [{} for move in self]
+
+        if cancel:
+            lines = self.mapped('line_ids')
+            # Avoid maximum recursion depth.
+            if lines:
+                lines.remove_move_reconcile()
+
+        reverse_type_map = {
+            'entry': 'entry',
+            'out_invoice': 'out_refund',
+            'in_invoice': 'in_refund',
+            'in_refund': 'in_invoice',
+            'out_receipt': 'in_receipt',
+            'in_receipt': 'out_receipt',
+        }
+
+        move_vals_list = []
+        for move, default_values in zip(self, default_values_list):
+            default_values.update({
+                'type': reverse_type_map[self.type],
+                'reversed_entry_id': self.id,
+            })
+            move_vals_list.append(move._reverse_move_vals(default_values, cancel=cancel))
+        reverse_moves = self.env['account.move'].create(move_vals_list)
+
+        # Reconcile moves together to cancel the previous one.
+        if cancel:
+            reverse_moves.with_context(move_reverse_cancel=cancel).post()
+            for move, reverse_move in zip(self, reverse_moves):
+                accounts = move.mapped('line_ids.account_id') \
+                    .filtered(lambda account: account.reconcile or account.internal_type == 'liquidity')
+                for account in accounts:
+                    (move.line_ids + reverse_move.line_ids)\
+                        .filtered(lambda line: line.account_id == account and line.balance)\
+                        .reconcile()
+
+        return reverse_moves
+
+    @api.multi
+    def open_reconcile_view(self):
+        return self.line_ids.open_reconcile_view()
 
     @api.multi
     def post(self):
-        self._post_validate()
+        for move in self:
+            if move.auto_post and move.date > fields.Date.today():
+                date_msg = move.date.strftime(self.env['res.lang']._lang_get(self.env.user.lang).date_format)
+                raise UserError(_("This move is configured to be auto-posted on %s" % date_msg))
+
+            if not move.partner_id:
+                if move.is_sale_document():
+                    raise UserError(_("The field 'Customer' is required, please complete it to validate the Customer Invoice."))
+                elif move.is_purchase_document():
+                    raise UserError(_("The field 'Vendor' is required, please complete it to validate the Vendor Bill."))
+
+            if move.is_invoice(include_receipts=True) and float_compare(move.amount_total, 0.0, precision_rounding=move.currency_id.rounding) < 0:
+                raise UserError(_("You cannot validate an invoice with a negative total amount. You should create a credit note instead."))
+
+            # Handle case when the invoice_date is not set. In that case, the invoice_date is set at today and then,
+            # lines are recomputed accordingly.
+            if not move.invoice_date and move.is_invoice(include_receipts=True):
+                move.invoice_date = fields.Date.context_today(self)
+                move.with_context(check_move_validity=False)._onchange_invoice_date()
+
+        self._check_tax_lock_date()
+        self._check_move_consistency()
         # Create the analytic lines in batch is faster as it leads to less cache invalidation.
         self.mapped('line_ids').create_analytic_lines()
         for move in self:
             if move.auto_post and move.date > fields.Date.today():
                 raise UserError(_("This move is configured to be auto-posted on {}".format(move.date.strftime(self.env['res.lang']._lang_get(self.env.user.lang).date_format))))
+            to_write = {'state': 'posted'}
 
             if move.name == '/':
-                new_name = False
-                journal = move.journal_id
+                # Get the journal's sequence.
+                sequence = move._get_sequence()
+                if not sequence:
+                    raise UserError(_('Please define a sequence on your journal.'))
 
-                if journal.sequence_id:
-                    sequence = journal.sequence_id
-                    new_name = sequence.with_context(ir_sequence_date=move.date).next_by_id()
-                else:
-                    raise UserError(_('Please define a sequence on the journal.'))
+                # Consume a new number.
+                to_write['name'] = sequence.next_by_id(sequence_date=move.date)
+
+            move.write(to_write)
 
-                if new_name:
-                    move.name = new_name
+            # Compute 'ref' for 'out_invoice'.
+            if move.type == 'out_invoice' and not move.invoice_payment_ref:
+                to_write = {
+                    'invoice_payment_ref': move._get_invoice_computed_reference(),
+                    'line_ids': []
+                }
+                for line in move.line_ids.filtered(lambda line: line.account_id.user_type_id.type in ('receivable', 'payable')):
+                    to_write['line_ids'].append((1, line.id, {'name': to_write['invoice_payment_ref']}))
+                move.write(to_write)
 
             if move == move.company_id.account_opening_move_id and not move.company_id.account_bank_reconciliation_start:
                 # For opening moves, we set the reconciliation date threshold
@@ -352,22 +1906,41 @@ class AccountMove(models.Model):
                 # installing Accounting- with bank statements)
                 move.company_id.account_bank_reconciliation_start = move.date
 
-        return self.write({'state': 'posted'})
+    @api.multi
+    def action_reverse(self):
+        action = self.env.ref('account.action_view_account_move_reversal').read()[0]
+
+        if self.is_invoice():
+            action['name'] = _('Credit Note')
+
+        return action
 
     @api.multi
     def action_post(self):
-        if self.mapped('line_ids.payment_id'):
-            if any(self.mapped('journal_id.post_at_bank_rec')):
-                raise UserError(_("A payment journal entry generated in a journal configured to post entries only when payments are reconciled with a bank statement cannot be manually posted. Those will be posted automatically after performing the bank reconciliation."))
+        if self.mapped('line_ids.payment_id') and any(self.mapped('journal_id.post_at_bank_rec')):
+            raise UserError(_("A payment journal entry generated in a journal configured to post entries only when payments are reconciled with a bank statement cannot be manually posted. Those will be posted automatically after performing the bank reconciliation."))
         return self.post()
 
+    @api.multi
+    def js_assign_outstanding_line(self, line_id):
+        self.ensure_one()
+        lines = self.env['account.move.line'].browse(line_id)
+        lines += self.line_ids.filtered(lambda line: line.account_id == lines[0].account_id and not line.reconciled)
+        return lines.reconcile()
+
+    @api.multi
+    def button_draft(self):
+        if any(move.state != 'cancel' for move in self):
+            raise UserError(_('Only cancelled journal entries can be reset to draft.'))
+        self.write({'state': 'draft'})
+
     @api.multi
     def button_cancel(self):
         AccountMoveLine = self.env['account.move.line']
         excluded_move_ids = []
 
-        if self._context.get('edition_mode'):
-            excluded_move_ids = AccountMoveLine.search(AccountMoveLine._get_domain_for_edition_mode() + [('move_id', 'in', self.ids)]).mapped('move_id').ids
+        if self._context.get('suspense_moves_mode'):
+            excluded_move_ids = AccountMoveLine.search(AccountMoveLine._get_suspense_moves_domain() + [('move_id', 'in', self.ids)]).mapped('move_id').ids
 
         for move in self:
             if not move.journal_id.update_posted and move.id not in excluded_move_ids:
@@ -377,122 +1950,130 @@ class AccountMove(models.Model):
         if self.ids:
             self.check_access_rights('write')
             self.check_access_rule('write')
-            self._check_lock_date()
-            self._cr.execute('UPDATE account_move '\
-                       'SET state=%s '\
-                       'WHERE id IN %s', ('draft', tuple(self.ids),))
+            self._check_fiscalyear_lock_date()
+            self._cr.execute('UPDATE account_move SET state=%s WHERE id IN %s', ('cancel', tuple(self.ids)))
             self.invalidate_cache()
-        self._check_lock_date()
+        self._check_fiscalyear_lock_date()
+        self.mapped('line_ids').remove_move_reconcile()
         return True
 
     @api.multi
-    def unlink(self):
-        for move in self:
-            #check the lock date + check if some entries are reconciled
-            move.line_ids._update_check()
-            move.line_ids.unlink()
-        return super(AccountMove, self).unlink()
+    def action_invoice_sent(self):
+        """ Open a window to compose an email, with the edi invoice template
+            message loaded by default
+        """
+        self.ensure_one()
+        template = self.env.ref('account.email_template_edi_invoice', raise_if_not_found=False)
+        compose_form = self.env.ref('account.account_invoice_send_wizard_form', raise_if_not_found=False)
+        ctx = dict(
+            default_model='account.move',
+            default_res_id=self.id,
+            default_use_template=bool(template),
+            default_template_id=template and template.id or False,
+            default_composition_mode='comment',
+            mark_invoice_as_sent=True,
+            custom_layout="mail.mail_notification_paynow",
+            force_email=True
+        )
+        return {
+            'name': _('Send Invoice'),
+            'type': 'ir.actions.act_window',
+            'view_type': 'form',
+            'view_mode': 'form',
+            'res_model': 'account.invoice.send',
+            'views': [(compose_form.id, 'form')],
+            'view_id': compose_form.id,
+            'target': 'new',
+            'context': ctx,
+        }
 
     @api.multi
-    def _post_validate(self):
-        for move in self:
-            if move.line_ids:
-                if not all([x.company_id.id == move.company_id.id for x in move.line_ids]):
-                    raise UserError(_("Cannot create moves for different companies."))
-        self.assert_balanced()
-        return self._check_lock_date()
+    def action_invoice_print(self):
+        """ Print the invoice and mark it as sent, so that we can see more
+            easily the next step of the workflow
+        """
+        if any(not move.is_invoice(include_receipts=True) for move in self):
+            raise UserError(_("Only invoices could be printed."))
+
+        self.filtered(lambda inv: not inv.invoice_sent).write({'invoice_sent': True})
+        if self.user_has_groups('account.group_account_invoice'):
+            return self.env.ref('account.account_invoices').report_action(self)
+        else:
+            return self.env.ref('account.account_invoices_without_payment').report_action(self)
 
     @api.multi
-    def _check_lock_date(self):
-        for move in self:
-            lock_date = max(move.company_id.period_lock_date or date.min, move.company_id.fiscalyear_lock_date or date.min)
-            if self.user_has_groups('account.group_account_manager'):
-                lock_date = move.company_id.fiscalyear_lock_date
-            if move.date <= (lock_date or date.min):
-                if self.user_has_groups('account.group_account_manager'):
-                    message = _("You cannot add/modify entries prior to and inclusive of the lock date %s") % (lock_date)
-                else:
-                    message = _("You cannot add/modify entries prior to and inclusive of the lock date %s. Check the company settings or ask someone with the 'Adviser' role") % (lock_date)
-                raise UserError(message)
-        return True
+    def action_invoice_paid(self):
+        ''' Hook to be overrided called when the invoice moves to the paid state. '''
+        pass
 
     @api.multi
-    def assert_balanced(self):
-        if not self.ids:
-            return True
-        prec = self.env.company.currency_id.decimal_places
-
-        self._cr.execute("""\
-            SELECT      move_id
-            FROM        account_move_line
-            WHERE       move_id in %s
-            GROUP BY    move_id
-            HAVING      abs(sum(debit) - sum(credit)) > %s
-            """, (tuple(self.ids), 10 ** (-max(5, prec))))
-        if len(self._cr.fetchall()) != 0:
-            raise UserError(_("Cannot create unbalanced journal entry."))
-        return True
+    def action_open_matching_suspense_moves(self):
+        self.ensure_one()
+        domain = self._get_domain_matching_supsense_moves()
+        ids = self.env['account.move.line'].search(domain).mapped('statement_line_id').ids
+        action_context = {'show_mode_selector': False, 'company_ids': self.mapped('company_id').ids}
+        action_context.update({'suspense_moves_mode': True})
+        action_context.update({'statement_line_ids': ids})
+        action_context.update({'partner_id': self.partner_id.id})
+        action_context.update({'partner_name': self.partner_id.name})
+        return {
+            'type': 'ir.actions.client',
+            'tag': 'bank_statement_reconciliation_view',
+            'context': action_context,
+        }
+
+    @api.multi
+    def action_invoice_register_payment(self):
+        return self.env['account.payment']\
+            .with_context(active_ids=self.ids, active_model='account.move', active_id=self.id)\
+            .action_register_payment()
+
+    @api.multi
+    def _get_report_base_filename(self):
+        if any(not move.is_invoice() for move in self):
+            raise UserError(_("Only invoices could be printed."))
+        return self._get_invoice_display_name()
 
     @api.multi
-    def _reverse_move(self, date=None, journal_id=None):
+    def preview_invoice(self):
         self.ensure_one()
-        date = date or fields.Date.today()
-        with self.env.norecompute():
-            reversed_move = self.copy(default={
-                'date': date,
-                'journal_id': journal_id.id if journal_id else self.journal_id.id,
-                'ref': _('Reversal of: %s') % (self.name),
-            })
-            for acm_line in reversed_move.line_ids.with_context(check_move_validity=False):
-                acm_line.write({
-                    'debit': acm_line.credit,
-                    'credit': acm_line.debit,
-                    'amount_currency': -acm_line.amount_currency
-                })
-            self.reverse_entry_id = reversed_move
-        self.recompute()
-        return reversed_move
-
-    @api.multi
-    def reverse_moves(self, date=None, journal_id=None):
-        date = date or fields.Date.today()
-        reversed_moves = self.env['account.move']
-        for ac_move in self:
-            #unreconcile all lines reversed
-            aml = ac_move.line_ids.filtered(lambda x: x.account_id.reconcile or x.account_id.internal_type == 'liquidity')
-            aml.remove_move_reconcile()
-            reversed_move = ac_move._reverse_move(date=date, journal_id=journal_id)
-            reversed_moves |= reversed_move
-            #reconcile together the reconcilable (or the liquidity aml) and their newly created counterpart
-            for account in set([x.account_id for x in aml]):
-                to_rec = aml.filtered(lambda y: y.account_id == account)
-                to_rec |= reversed_move.line_ids.filtered(lambda y: y.account_id == account)
-                #reconciliation will be full, so speed up the computation by using skip_full_reconcile_check in the context
-                to_rec.reconcile()
-        if reversed_moves:
-            reversed_moves._post_validate()
-            reversed_moves.post()
-            return [x.id for x in reversed_moves]
-        return []
+        return {
+            'type': 'ir.actions.act_url',
+            'target': 'self',
+            'url': self.get_portal_url(),
+        }
 
     @api.multi
-    def open_reconcile_view(self):
-        return self.line_ids.open_reconcile_view()
+    def _compute_access_url(self):
+        super(AccountMove, self)._compute_access_url()
+        for move in self.filtered(lambda move: move.is_invoice()):
+            move.access_url = '/my/invoices/%s' % (move.id)
 
-    # FIXME: Clarify me and change me in master
     @api.multi
-    def action_duplicate(self):
+    def action_view_reverse_entry(self):
         self.ensure_one()
-        action = self.env.ref('account.action_move_journal_line').read()[0]
-        action['context'] = dict(self.env.context)
-        action['context']['form_view_initial_mode'] = 'edit'
-        action['context']['view_no_maturity'] = False
-        action['views'] = [(self.env.ref('account.view_move_form').id, 'form')]
-        action['res_id'] = self.copy().id
+
+        # Create action.
+        action = {
+            'name': _('Reverse Moves'),
+            'type': 'ir.actions.act_window',
+            'res_model': 'account.move',
+        }
+        reverse_entries = self.env['account.move'].search([('reversed_entry_id', '=', self.id)])
+        if len(reverse_entries) == 1:
+            action.update({
+                'view_mode': 'form',
+                'res_id': reverse_entries.id,
+            })
+        else:
+            action.update({
+                'view_mode': 'tree',
+                'domain': [('id', 'in', reverse_entries.ids)],
+            })
         return action
 
     @api.model
-    def _run_post_draft_to_post(self):
+    def _autopost_draft_entries(self):
         ''' This method is called from a cron job.
         It is used to post entries such as those created by the module
         account_asset.
@@ -504,46 +2085,546 @@ class AccountMove(models.Model):
         ])
         records.post()
 
-    @api.multi
-    def action_view_reverse_entry(self):
-        action = self.env.ref('account.action_move_journal_line').read()[0]
-        action['views'] = [(self.env.ref('account.view_move_form').id, 'form')]
-        action['res_id'] = self.reverse_entry_id.id
-        return action
 
 class AccountMoveLine(models.Model):
     _name = "account.move.line"
     _description = "Journal Item"
-    _order = "date desc, move_name desc, id desc"
+    _order = "sequence, date desc, move_name desc, id"
+
+    # ==== Business fields ====
+    move_id = fields.Many2one('account.move', string='Journal Entry',
+        index=True, required=True, auto_join=True, ondelete="cascade",
+        help="The move of this entry line.")
+    move_name = fields.Char(string='Number', related='move_id.name', store=True, index=True)
+    date = fields.Date(related='move_id.date', store=True, readonly=True, index=True, copy=False)
+    ref = fields.Char(related='move_id.ref', store=True, copy=False, index=True, readonly=False)
+    parent_state = fields.Selection(related='move_id.state', store=True, readonly=True)
+    journal_id = fields.Many2one(related='move_id.journal_id', store=True, readonly=False, index=True, copy=False)
+    company_id = fields.Many2one(related='move_id.company_id', store=True, readonly=True)
+    company_currency_id = fields.Many2one(related='company_id.currency_id', string='Company Currency',
+        readonly=True, store=True,
+        help='Utility field to express amount currency')
+    account_id = fields.Many2one('account.account', string='Account',
+        index=True, ondelete="cascade",
+        domain=[('deprecated', '=', False)])
+    account_internal_type = fields.Selection(related='account_id.user_type_id.type', string="Internal Type", store=True, readonly=True)
+    sequence = fields.Integer(default=10)
+    name = fields.Char(string='Label')
+    quantity = fields.Float(string='Quantity',
+        default=1.0, digits=dp.get_precision('Product Unit of Measure'),
+        help="The optional quantity expressed by this line, eg: number of product sold."
+             "The quantity is not a legal requirement but is very useful for some reports.")
+    price_unit = fields.Float(string='Unit Price', digits=dp.get_precision('Product Price'))
+    discount = fields.Float(string='Discount (%)', digits=dp.get_precision('Discount'), default=0.0)
+    debit = fields.Monetary(string='Debit', default=0.0, currency_field='company_currency_id')
+    credit = fields.Monetary(string='Credit', default=0.0, currency_field='company_currency_id')
+    balance = fields.Monetary(string='Balance', store=True,
+        currency_field='company_currency_id',
+        compute='_compute_balance',
+        help="Technical field holding the debit - credit in order to open meaningful graph views from reports")
+    amount_currency = fields.Monetary(string='Balance in Currency', store=True, copy=True,
+        help="The amount expressed in an optional other currency if it is a multi-currency entry.")
+    price_subtotal = fields.Monetary(string='Subtotal', store=True, readonly=True,
+        currency_field='always_set_currency_id')
+    price_total = fields.Monetary(string='Total', store=True, readonly=True,
+        currency_field='always_set_currency_id')
+    reconciled = fields.Boolean(compute='_amount_residual', store=True)
+    blocked = fields.Boolean(string='No Follow-up', default=False,
+        help="You can check this box to mark this journal item as a litigation with the associated partner")
+    date_maturity = fields.Date(string='Due date', index=True,
+        help="This field is used for payable and receivable journal entries. You can put the limit date for the payment of this line.")
+    currency_id = fields.Many2one('res.currency', string='Currency')
+    partner_id = fields.Many2one('res.partner', string='Partner', ondelete='restrict')
+    product_uom_id = fields.Many2one('uom.uom', string='Unit of Measure')
+    product_id = fields.Many2one('product.product', string='Product')
+
+    # ==== Origin fields ====
+    reconcile_model_id = fields.Many2one('account.reconcile.model', string="Reconciliation Model", copy=False)
+    payment_id = fields.Many2one('account.payment', string="Originator Payment", copy=False,
+        help="Payment that created this entry")
+    statement_line_id = fields.Many2one('account.bank.statement.line',
+        string='Bank statement line reconciled with this entry',
+        index=True, copy=False, readonly=True)
+    statement_id = fields.Many2one(related='statement_line_id.statement_id', store=True, index=True, copy=False,
+        help="The bank statement used for bank reconciliation")
+
+    # ==== Tax fields ====
+    tax_ids = fields.Many2many('account.tax', string='Taxes')
+    tax_line_id = fields.Many2one('account.tax', string='Originator tax', ondelete='restrict', store=True,
+        compute='_compute_tax_line_id')
+    tax_base_amount = fields.Monetary(string="Base Amount", store=True,
+        currency_field='company_currency_id')
+    tax_exigible = fields.Boolean(string='Appears in VAT report', default=True,
+        help="Technical field used to mark a tax line as exigible in the vat report or not (only exigible journal items"
+             " are displayed). By default all new journal items are directly exigible, but with the feature cash_basis"
+             " on taxes, some will become exigible only when the payment is recorded.")
+    tax_repartition_line_id = fields.Many2one(comodel_name='account.tax.repartition.line',
+        string="Originator Tax Repartition Line", ondelete='restrict',
+        help="Tax repartition line that caused the creation of this move line, if any")
+    tag_ids = fields.Many2many(string="Tags", comodel_name='account.account.tag', ondelete='restrict',
+        help="Tags assigned to this line by the tax creating it, if any. It determines its impact on financial reports.")
+    tax_audit = fields.Char(string="Tax Audit String", compute="_compute_tax_audit", store=True,
+        help="Computed field, listing the tax grids impacted by this line, and the amount it applies to each of them.")
+
+    # ==== Reconciliation fields ====
+    amount_residual = fields.Monetary(string='Residual Amount', store=True,
+        currency_field='company_currency_id',
+        compute='_amount_residual',
+        help="The residual amount on a journal item expressed in the company currency.")
+    amount_residual_currency = fields.Monetary(string='Residual Amount in Currency', store=True,
+        compute='_amount_residual',
+        help="The residual amount on a journal item expressed in its currency (possibly not the company currency).")
+    full_reconcile_id = fields.Many2one('account.full.reconcile', string="Matching Number", copy=False, index=True)
+    matched_debit_ids = fields.One2many('account.partial.reconcile', 'credit_move_id', String='Matched Debits',
+        help='Debit journal items that are matched with this journal item.')
+    matched_credit_ids = fields.One2many('account.partial.reconcile', 'debit_move_id', String='Matched Credits',
+        help='Credit journal items that are matched with this journal item.')
+
+    # ==== Analytic fields ====
+    analytic_line_ids = fields.One2many('account.analytic.line', 'move_id', string='Analytic lines')
+    analytic_account_id = fields.Many2one('account.analytic.account', string='Analytic Account', index=True)
+    analytic_tag_ids = fields.Many2many('account.analytic.tag', string='Analytic Tags')
+
+    # ==== Onchange / display purpose fields ====
+    recompute_tax_line = fields.Boolean(store=False, readonly=True,
+        help="Technical field used to know on which lines the taxes must be recomputed.")
+    display_type = fields.Selection([
+        ('line_section', 'Section'),
+        ('line_note', 'Note'),
+    ], default=False, help="Technical field for UX purpose.")
+    is_rounding_line = fields.Boolean(help="Technical field used to retrieve the cash rounding line.")
+    exclude_from_invoice_tab = fields.Boolean(help="Technical field used to exclude some lines from the invoice_line_ids tab in the form view.")
+    always_set_currency_id = fields.Many2one('res.currency', string='Foreign Currency',
+        compute='_compute_always_set_currency_id',
+        help="Technical field used to compute the monetary field. As currency_id is not a required field, we need to use either the foreign currency, either the company one.")
+
+    _sql_constraints = [
+        (
+            'check_credit_debit',
+            'CHECK(credit + debit>=0 AND credit * debit=0)',
+            'Wrong credit or debit value in accounting entry !'
+        ),
+        (
+            'check_accountable_required_fields',
+             "CHECK(display_type IN ('line_section', 'line_note') OR account_id IS NOT NULL)",
+             "Missing required account on accountable invoice line."
+        ),
+        (
+            'check_non_accountable_fields_null',
+             "CHECK(display_type NOT IN ('line_section', 'line_note') OR (amount_currency = 0 AND debit = 0 AND credit = 0 AND account_id IS NULL))",
+             "Forbidden unit price, account and quantity on non-accountable invoice line"
+        ),
+        (
+            'check_amount_currency_balance_sign',
+            '''CHECK(
+                currency_id IS NULL
+                OR
+                company_currency_id IS NULL
+                OR
+                (
+                    (currency_id != company_currency_id)
+                    AND
+                    (
+                        (balance > 0 AND amount_currency > 0)
+                        OR (balance <= 0 AND amount_currency <= 0)
+                        OR (balance >= 0 AND amount_currency >= 0)
+                    )
+                )
+            )''',
+            "The amount expressed in the secondary currency must be positive when account is debited and negative when account is credited."
+        ),
+    ]
+
+    # -------------------------------------------------------------------------
+    # HELPERS
+    # -------------------------------------------------------------------------
+
+    @api.model
+    def _get_default_tax_account(self, repartition_line):
+        tax = repartition_line.invoice_tax_id or repartition_line.refund_tax_id
+        if tax.tax_exigibility == 'on_payment':
+            account = tax.cash_basis_transition_account_id
+        else:
+            account = repartition_line.account_id
+        return account
+
+    @api.multi
+    def _get_computed_name(self):
+        self.ensure_one()
+
+        if not self.product_id:
+            return ''
+
+        if self.partner_id.lang:
+            product = self.product_id.with_context(lang=self.partner_id.lang)
+        else:
+            product = self.product_id
+
+        values = []
+        if product.partner_ref:
+            values.append(product.partner_ref)
+        if self.journal_id.type == 'sale':
+            if product.description_sale:
+                values.append(product.description_sale)
+        elif self.journal_id.type == 'purchase':
+            if product.description_purchase:
+                values.append(product.description_purchase)
+        return '\n'.join(values)
+
+    @api.multi
+    def _get_computed_price_unit(self):
+        self.ensure_one()
+
+        if not self.product_id:
+            return self.price_unit
+        elif self.move_id.is_sale_document(include_receipts=True):
+            # Out invoice.
+            price_unit = self.product_id.lst_price
+        elif self.move_id.is_purchase_document(include_receipts=True):
+            # In invoice.
+            price_unit = self.product_id.standard_price
+        else:
+            return self.price_unit
+
+        if self.product_uom_id != self.product_id.uom_id:
+            price_unit = self.product_id.uom_id._compute_price(price_unit, self.product_uom_id)
+
+        company = self.move_id.company_id
+        if self.move_id.currency_id != company.currency_id:
+            price_unit = company.currency_id._convert(
+                price_unit, self.move_id.currency_id, company, self.move_id.date)
+        return price_unit
+
+    @api.multi
+    def _get_computed_account(self):
+        self.ensure_one()
+
+        if not self.product_id:
+            return
+
+        fiscal_position = self.move_id.fiscal_position_id
+        accounts = self.product_id.product_tmpl_id.get_product_accounts(fiscal_pos=fiscal_position)
+        if self.move_id.is_sale_document(include_receipts=True):
+            # Out invoice.
+            return accounts['income']
+        elif self.move_id.is_purchase_document(include_receipts=True):
+            # In invoice.
+            return accounts['expense']
+
+    @api.multi
+    def _get_computed_taxes(self):
+        self.ensure_one()
+
+        if self.move_id.is_sale_document(include_receipts=True):
+            # Out invoice.
+            if self.product_id.taxes_id:
+                tax_ids = self.product_id.taxes_id.filtered(lambda tax: tax.company_id == self.move_id.company_id)
+            elif self.account_id.tax_ids:
+                tax_ids = self.account_id.tax_ids
+            else:
+                tax_ids = self.env['account.tax']
+            if not tax_ids and not self.exclude_from_invoice_tab:
+                tax_ids = self.move_id.company_id.account_sale_tax_id
+        elif self.move_id.is_purchase_document(include_receipts=True):
+            # In invoice.
+            if self.product_id.supplier_taxes_id:
+                tax_ids = self.product_id.supplier_taxes_id.filtered(lambda tax: tax.company_id == self.move_id.company_id)
+            elif self.account_id.tax_ids:
+                tax_ids = self.account_id.tax_ids
+            else:
+                tax_ids = self.env['account.tax']
+            if not tax_ids and not self.exclude_from_invoice_tab:
+                tax_ids = self.move_id.company_id.account_purchase_tax_id
+        else:
+            # Miscellaneous operation.
+            tax_ids = self.account_id.tax_ids
+
+        if self.company_id:
+            tax_ids = tax_ids.filtered(lambda tax: tax.company_id == self.company_id)
+
+        fiscal_position = self.move_id.fiscal_position_id
+        if tax_ids and fiscal_position:
+            return fiscal_position.map_tax(tax_ids, partner=self.partner_id)
+        else:
+            return tax_ids
+
+    @api.multi
+    def _get_computed_uom(self):
+        self.ensure_one()
+        if self.product_id:
+            return self.product_id.uom_id
+        return False
+
+    @api.multi
+    def _get_price_total_and_subtotal(self, price_unit=None, quantity=None, discount=None, currency=None, product=None, partner=None, taxes=None, move_type=None):
+        self.ensure_one()
+        return self._get_price_total_and_subtotal_model(
+            price_unit=price_unit or self.price_unit,
+            quantity=quantity or self.quantity,
+            discount=discount or self.discount,
+            currency=currency or self.currency_id,
+            product=product or self.product_id,
+            partner=partner or self.partner_id,
+            taxes=taxes or self.tax_ids,
+            move_type=move_type or self.move_id.type,
+        )
+
+    @api.model
+    def _get_price_total_and_subtotal_model(self, price_unit, quantity, discount, currency, product, partner, taxes, move_type):
+        ''' This method is used to compute 'price_total' & 'price_subtotal'.
+
+        :param price_unit:  The current price unit.
+        :param quantity:    The current quantity.
+        :param discount:    The current discount.
+        :param currency:    The line's currency.
+        :param product:     The line's product.
+        :param partner:     The line's partner.
+        :param taxes:       The applied taxes.
+        :param move_type:   The type of the move.
+        :return:            A dictionary containing 'price_subtotal' & 'price_total'.
+        '''
+        res = {}
+
+        # Compute 'price_subtotal'.
+        price_unit_wo_discount = price_unit * (1 - (discount / 100.0))
+        subtotal = quantity * price_unit_wo_discount
+
+        # Compute 'price_total'.
+        if taxes:
+            taxes_res = taxes._origin.compute_all(price_unit_wo_discount,
+                quantity=quantity, currency=currency, product=product, partner=partner, is_refund=move_type in ('out_refund', 'in_refund'))
+            res['price_subtotal'] = taxes_res['total_excluded']
+            res['price_total'] = taxes_res['total_included']
+        else:
+            res['price_total'] = res['price_subtotal'] = subtotal
+        return res
+
+    @api.multi
+    def _get_fields_onchange_subtotal(self, price_subtotal=None, move_type=None, currency=None, company=None, date=None):
+        self.ensure_one()
+        return self._get_fields_onchange_subtotal_model(
+            price_subtotal=price_subtotal or self.price_subtotal,
+            move_type=move_type or self.move_id.type,
+            currency=currency or self.currency_id,
+            company=company or self.move_id.company_id,
+            date=date or self.move_id.date,
+        )
+
+    @api.model
+    def _get_fields_onchange_subtotal_model(self, price_subtotal, move_type, currency, company, date):
+        ''' This method is used to recompute the values of 'amount_currency', 'debit', 'credit' due to a change made
+        in some business fields (affecting the 'price_subtotal' field).
+
+        :param price_subtotal:  The untaxed amount.
+        :param move_type:       The type of the move.
+        :param currency:        The line's currency.
+        :param company:         The move's company.
+        :param date:            The move's date.
+        :return:                A dictionary containing 'debit', 'credit', 'amount_currency'.
+        '''
+        if move_type in self.move_id.get_outbound_types():
+            sign = 1
+        elif move_type in self.move_id.get_inbound_types():
+            sign = -1
+        else:
+            sign = 1
+        price_subtotal *= sign
+
+        if currency and currency != company.currency_id:
+            # Multi-currencies.
+            balance = currency._convert(price_subtotal, company.currency_id, company, date)
+            return {
+                'amount_currency': price_subtotal,
+                'debit': balance > 0.0 and balance or 0.0,
+                'credit': balance < 0.0 and -balance or 0.0,
+            }
+        else:
+            # Single-currency.
+            return {
+                'amount_currency': 0.0,
+                'debit': price_subtotal > 0.0 and price_subtotal or 0.0,
+                'credit': price_subtotal < 0.0 and -price_subtotal or 0.0,
+            }
+
+    @api.multi
+    def _get_fields_onchange_balance(self, quantity=None, discount=None, balance=None, move_type=None, currency=None, taxes=None):
+        self.ensure_one()
+        return self._get_fields_onchange_balance_model(
+            quantity=quantity or self.quantity,
+            discount=discount or self.discount,
+            balance=balance or self.balance,
+            move_type=move_type or self.move_id.type,
+            currency=currency or self.currency_id,
+            taxes=taxes or self.tax_ids,
+        )
+
+    @api.model
+    def _get_fields_onchange_balance_model(self, quantity, discount, balance, move_type, currency, taxes):
+        ''' This method is used to recompute the values of 'quantity', 'discount', 'price_unit' due to a change made
+        in some accounting fields such as 'balance'.
+
+        This method is a bit complex as we need to handle some special cases.
+        For example, setting a positive balance with a 100% discount.
+
+        :param quantity:    The current quantity.
+        :param discount:    The current discount.
+        :param balance:     The new balance.
+        :param move_type:   The type of the move.
+        :param currency:    The currency.
+        :param taxes:       The applied taxes.
+        :return:            A dictionary containing 'quantity', 'discount', 'price_unit'.
+        '''
+        if move_type in self.move_id.get_outbound_types():
+            sign = 1
+        elif move_type in self.move_id.get_inbound_types():
+            sign = -1
+        else:
+            sign = 1
+        balance *= sign
+
+        taxes = taxes.flatten_taxes_hierarchy()
+        if taxes and any(tax.price_include for tax in taxes):
+            # Inverse taxes. E.g:
+            #
+            # Price Unit    | Taxes         | Originator Tax    |Price Subtotal     | Price Total
+            # -----------------------------------------------------------------------------------
+            # 110           | 10% incl, 5%  |                   | 100               | 115
+            # 10            |               | 10% incl          | 10                | 10
+            # 5             |               | 5%                | 5                 | 5
+            #
+            # When setting the balance to -200, the expected result is:
+            #
+            # Price Unit    | Taxes         | Originator Tax    |Price Subtotal     | Price Total
+            # -----------------------------------------------------------------------------------
+            # 220           | 10% incl, 5%  |                   | 200               | 230
+            # 20            |               | 10% incl          | 20                | 20
+            # 10            |               | 5%                | 10                | 10
+            taxes_res = taxes._origin.compute_all(balance, currency=currency, handle_price_include=False)
+            for tax_res in taxes_res['taxes']:
+                tax = self.env['account.tax'].browse(tax_res['id'])
+                if tax.price_include:
+                    balance += tax_res['amount']
+
+        discount_factor = 1 - (discount / 100.0)
+        if balance and discount_factor:
+            # discount != 100%
+            vals = {
+                'quantity': quantity or 1.0,
+                'price_unit': balance / discount_factor / (quantity or 1.0),
+            }
+        elif balance and not discount_factor:
+            # discount == 100%
+            vals = {
+                'quantity': quantity or 1.0,
+                'discount': 0.0,
+                'price_unit': balance / (quantity or 1.0),
+            }
+        else:
+            vals = {}
+        return vals
+
+    # -------------------------------------------------------------------------
+    # ONCHANGE METHODS
+    # -------------------------------------------------------------------------
+
+    @api.onchange('amount_currency', 'currency_id', 'debit', 'credit', 'tax_ids', 'account_id', 'analytic_account_id', 'analytic_tag_ids')
+    def _onchange_mark_recompute_taxes(self):
+        ''' Recompute the dynamic onchange based on taxes.
+        If the edited line is a tax line, don't recompute anything as the user must be able to
+        set a custom value.
+        '''
+        for line in self:
+            if not line.tax_repartition_line_id:
+                line.recompute_tax_line = True
 
-    @api.onchange('debit', 'credit', 'tax_ids', 'analytic_account_id', 'analytic_tag_ids')
-    def onchange_tax_ids_create_aml(self):
+    @api.onchange('product_id')
+    def _onchange_product_id(self):
         for line in self:
-            line.recompute_tax_line = True
+            if not line.product_id or line.display_type in ('line_section', 'line_note'):
+                continue
+
+            line.name = line._get_computed_name()
+            line.account_id = line._get_computed_account()
+            line.tax_ids = line._get_computed_taxes()
+            line.product_uom_id = line._get_computed_uom()
+            line.price_unit = line._get_computed_price_unit()
+
+        if len(self) == 1:
+            return {'domain': {'product_uom_id': [('category_id', '=', self.product_uom_id.category_id.id)]}}
+
+    @api.onchange('product_uom_id')
+    def _onchange_uom_id(self):
+        ''' Recompute the 'price_unit' depending of the unit of measure. '''
+        self.price_unit = self._get_computed_price_unit()
+
+    @api.onchange('account_id')
+    def _onchange_account_id(self):
+        ''' Recompute 'tax_ids' based on 'account_id'. '''
+        if not self.display_type in ('line_section', 'line_note'):
+            self.tax_ids = self._get_computed_taxes()
+
+    @api.multi
+    def _onchange_balance(self):
+        for line in self:
+            if line.currency_id:
+                continue
+            if not line.move_id.is_invoice(include_receipts=True):
+                continue
+            line.update(line._get_fields_onchange_balance())
+            line.update(line._get_price_total_and_subtotal())
 
     @api.onchange('debit')
     def _onchange_debit(self):
-        self.ensure_one()
-        if self.debit != 0:
-            self.credit = 0
+        if self.debit:
+            self.credit = 0.0
+        self._onchange_balance()
 
     @api.onchange('credit')
     def _onchange_credit(self):
-        self.ensure_one()
-        if self.credit != 0:
-            self.debit = 0
+        if self.credit:
+            self.debit = 0.0
+        self._onchange_balance()
 
-    @api.model_cr
-    def init(self):
-        """ change index on partner_id to a multi-column index on (partner_id, ref), the new index will behave in the
-            same way when we search on partner_id, with the addition of being optimal when having a query that will
-            search on partner_id and ref at the same time (which is the case when we open the bank reconciliation widget)
-        """
-        cr = self._cr
-        cr.execute('DROP INDEX IF EXISTS account_move_line_partner_id_index')
-        cr.execute('SELECT indexname FROM pg_indexes WHERE indexname = %s', ('account_move_line_partner_id_ref_idx',))
-        if not cr.fetchone():
-            cr.execute('CREATE INDEX account_move_line_partner_id_ref_idx ON account_move_line (partner_id, ref)')
+    @api.onchange('amount_currency')
+    def _onchange_amount_currency(self):
+        for line in self:
+            if not line.currency_id:
+                continue
+            if not line.move_id.is_invoice(include_receipts=True):
+                continue
+            line.update(line._get_fields_onchange_balance(
+                balance=line.amount_currency,
+            ))
+            line.update(line._get_price_total_and_subtotal())
+
+    @api.onchange('quantity', 'discount', 'price_unit', 'tax_ids')
+    def _onchange_price_subtotal(self):
+        for line in self:
+            if not line.move_id.is_invoice(include_receipts=True):
+                continue
+
+            line.update(line._get_price_total_and_subtotal())
+            line.update(line._get_fields_onchange_subtotal())
+
+    @api.onchange('currency_id')
+    def _onchange_currency(self):
+        for line in self:
+            if line.move_id.is_invoice(include_receipts=True):
+                line._onchange_price_subtotal()
+
+    # -------------------------------------------------------------------------
+    # COMPUTE METHODS
+    # -------------------------------------------------------------------------
+
+    @api.depends('currency_id')
+    def _compute_always_set_currency_id(self):
+        for line in self:
+            line.always_set_currency_id = line.currency_id or line.company_currency_id
+
+    @api.depends('debit', 'credit')
+    def _compute_balance(self):
+        for line in self:
+            line.balance = line.debit - line.credit
 
     @api.depends('debit', 'credit', 'amount_currency', 'currency_id', 'matched_debit_ids', 'matched_credit_ids', 'matched_debit_ids.amount', 'matched_credit_ids.amount', 'move_id.state')
     def _amount_residual(self):
@@ -596,163 +2677,9 @@ class AccountMoveLine(models.Model):
                     reconciled = True
             line.reconciled = reconciled
 
-            line.amount_residual = line.company_id.currency_id.round(amount * sign)
+            line.amount_residual = line.move_id.company_id.currency_id.round(amount * sign)
             line.amount_residual_currency = line.currency_id and line.currency_id.round(amount_residual_currency * sign) or 0.0
 
-    @api.depends('debit', 'credit')
-    def _store_balance(self):
-        for line in self:
-            line.balance = line.debit - line.credit
-
-    @api.model
-    def _get_currency(self):
-        currency = False
-        context = self._context or {}
-        if context.get('default_journal_id', False):
-            currency = self.env['account.journal'].browse(context['default_journal_id']).currency_id
-        return currency
-
-    @api.depends('move_id')
-    def _compute_parent_state(self):
-        for record in self.filtered('move_id'):
-            record.parent_state = record.move_id.state
-
-    name = fields.Char(string="Label")
-    move_name = fields.Char(string='Number', related='move_id.name', store=True, index=True)
-    quantity = fields.Float(digits=dp.get_precision('Product Unit of Measure'),
-        help="The optional quantity expressed by this line, eg: number of product sold. The quantity is not a legal requirement but is very useful for some reports.")
-    product_uom_id = fields.Many2one('uom.uom', string='Unit of Measure')
-    product_id = fields.Many2one('product.product', string='Product')
-    debit = fields.Monetary(default=0.0, currency_field='company_currency_id')
-    credit = fields.Monetary(default=0.0, currency_field='company_currency_id')
-    balance = fields.Monetary(compute='_store_balance', store=True, currency_field='company_currency_id',
-        help="Technical field holding the debit - credit in order to open meaningful graph views from reports")
-    amount_currency = fields.Monetary(default=0.0, help="The amount expressed in an optional other currency if it is a multi-currency entry.")
-    company_currency_id = fields.Many2one('res.currency', related='company_id.currency_id', string="Company Currency", readonly=True,
-        help='Utility field to express amount currency', store=True)
-    currency_id = fields.Many2one('res.currency', string='Currency', default=_get_currency,
-        help="The optional other currency if it is a multi-currency entry.")
-    amount_residual = fields.Monetary(compute='_amount_residual', string='Residual Amount', store=True, currency_field='company_currency_id',
-        help="The residual amount on a journal item expressed in the company currency.")
-    amount_residual_currency = fields.Monetary(compute='_amount_residual', string='Residual Amount in Currency', store=True,
-        help="The residual amount on a journal item expressed in its currency (possibly not the company currency).")
-    tax_base_amount = fields.Monetary(string="Base Amount", currency_field='company_currency_id')
-    account_id = fields.Many2one('account.account', string='Account', required=True, index=True,
-        ondelete="cascade", domain=[('deprecated', '=', False)], default=lambda self: self._context.get('account_id', False))
-    move_id = fields.Many2one('account.move', string='Journal Entry', ondelete="cascade",
-        help="The move of this entry line.", index=True, required=True, auto_join=True)
-    narration = fields.Text(related='move_id.narration', string='Narration', readonly=False)
-    ref = fields.Char(related='move_id.ref', string='Reference', store=True, copy=False, index=True, readonly=False)
-    payment_id = fields.Many2one('account.payment', string="Originator Payment", help="Payment that created this entry", copy=False)
-    statement_line_id = fields.Many2one('account.bank.statement.line', index=True, string='Bank statement line reconciled with this entry', copy=False, readonly=True)
-    statement_id = fields.Many2one('account.bank.statement', related='statement_line_id.statement_id', string='Statement', store=True,
-        help="The bank statement used for bank reconciliation", index=True, copy=False)
-    reconciled = fields.Boolean(compute='_amount_residual', store=True)
-    reconcile_model_id = fields.Many2one('account.reconcile.model', string="Reconciliation Model", copy=False)
-    full_reconcile_id = fields.Many2one('account.full.reconcile', string="Matching Number", copy=False, index=True)
-    matched_debit_ids = fields.One2many('account.partial.reconcile', 'credit_move_id', String='Matched Debits',
-        help='Debit journal items that are matched with this journal item.')
-    matched_credit_ids = fields.One2many('account.partial.reconcile', 'debit_move_id', String='Matched Credits',
-        help='Credit journal items that are matched with this journal item.')
-    journal_id = fields.Many2one('account.journal', related='move_id.journal_id', string='Journal', readonly=False,
-        index=True, store=True, copy=False)  # related is required
-    blocked = fields.Boolean(string='No Follow-up', default=False,
-        help="You can check this box to mark this journal item as a litigation with the associated partner")
-    date_maturity = fields.Date(string='Due date', index=True, required=True, copy=False,
-        help="This field is used for payable and receivable journal entries. You can put the limit date for the payment of this line.")
-    date = fields.Date(related='move_id.date', string='Date', index=True, store=True, copy=False, readonly=False)  # related is required
-    analytic_line_ids = fields.One2many('account.analytic.line', 'move_id', string='Analytic lines', oldname="analytic_lines")
-    tax_ids = fields.Many2many('account.tax', string='Taxes', domain=['|', ('active', '=', False), ('active', '=', True)])
-    tax_line_id = fields.Many2one('account.tax', string='Originator tax', ondelete='restrict', compute='_compute_tax_line_id', store=True)
-    tax_repartition_line_id = fields.Many2one(comodel_name='account.tax.repartition.line', string="Originator Tax Repartition Line", ondelete='restrict', help="Tax repartition line that caused the creation of this move line, if any")
-    analytic_account_id = fields.Many2one('account.analytic.account', string='Analytic Account', index=True)
-    analytic_tag_ids = fields.Many2many('account.analytic.tag', string='Analytic Tags')
-    company_id = fields.Many2one('res.company', related='account_id.company_id', string='Company', store=True, readonly=True)
-
-    # TODO: put the invoice link and partner_id on the account_move
-    invoice_id = fields.Many2one('account.invoice', oldname="invoice")
-    partner_id = fields.Many2one('res.partner', string='Partner', ondelete='restrict')
-    tax_exigible = fields.Boolean(string='Appears in VAT report', default=True,
-        help="Technical field used to mark a tax line as exigible in the vat report or not (only exigible journal items are displayed). By default all new journal items are directly exigible, but with the feature cash_basis on taxes, some will become exigible only when the payment is recorded.")
-    parent_state = fields.Char(compute="_compute_parent_state", help="State of the parent account.move")
-
-    recompute_tax_line = fields.Boolean(store=False, help="Technical field used to know if the tax_ids field has been modified in the UI.")
-    tax_line_grouping_key = fields.Char(store=False, string='Old Taxes', help="Technical field used to store the old values of fields used to compute tax lines (in account.move form view) between the moment the user changed it and the moment the ORM reflects that change in its one2many")
-    tag_ids = fields.Many2many(string="Tags", comodel_name='account.account.tag', ondelete='restrict', help="Tags assigned to this line by the tax creating it, if any. It determines its impact on financial reports.")
-    tax_audit = fields.Char(string="Tax Audit String", compute="_compute_tax_audit", store=True, help="Computed field, listing the tax grids impacted by this line, and the amount it applies to each of them.")
-
-    _sql_constraints = [
-        ('credit_debit1', 'CHECK (credit*debit=0)', 'Wrong credit or debit value in accounting entry! Credit or debit should be zero.'),
-        ('credit_debit2', 'CHECK (credit+debit>=0)', 'Wrong credit or debit value in accounting entry! Credit and debit should be positive.'),
-    ]
-
-    @api.model
-    def default_get(self, fields):
-        rec = super(AccountMoveLine, self).default_get(fields)
-        if 'line_ids' not in self._context or "account_move_line_default_get" in self._context:
-            return rec
-        if {'debit', 'credit', 'partner_id', 'account_id'}.isdisjoint(fields):
-            return rec
-        # compute the default credit/debit of the next line in case of a manual entry
-        move = self.env['account.move'].with_context(account_move_line_default_get=True).new({'line_ids': self._context['line_ids']})
-        balance = 0
-        for line in move.line_ids:
-            balance += line.debit - line.credit
-        if balance < 0:
-            rec.update({'debit': -balance})
-        if balance > 0:
-            rec.update({'credit': balance})
-
-        # Set the partner/account to the same value as the two last lines if they are equal
-        if len(move.line_ids) > 1:
-            last_lines = move.line_ids[-2:]
-            if last_lines[0].account_id == last_lines[1].account_id:
-                rec['account_id'] = last_lines[0].account_id.id
-            if last_lines[0].partner_id == last_lines[1].partner_id:
-                rec['partner_id'] = last_lines[0].partner_id.id
-
-        return rec
-
-    @api.multi
-    @api.constrains('tax_ids', 'tax_line_id')
-    def _check_tax_lock_date1(self):
-        for line in self:
-            if line.date <= (line.company_id.tax_lock_date or date.min):
-                raise ValidationError(_("The operation is refused as it would impact an already issued tax statement. " +
-                "Please change the journal entry date or the tax lock date set in the settings ({}) to proceed").format(line.company_id.tax_lock_date or date.min))
-
-    @api.multi
-    @api.constrains('credit', 'debit', 'date')
-    def _check_tax_lock_date2(self):
-        for line in self:
-            if (line.tax_ids or line.tax_line_id) and line.date <= (line.company_id.tax_lock_date or date.min):
-                raise ValidationError(_("The operation is refused as it would impact an already issued tax statement. " +
-                "Please change the journal entry date or the tax lock date set in the settings ({}) to proceed").format(line.company_id.tax_lock_date or date.min))
-
-    @api.multi
-    @api.constrains('currency_id', 'account_id')
-    def _check_currency(self):
-        for line in self:
-            account_currency = line.account_id.currency_id
-            if account_currency and account_currency != line.company_id.currency_id:
-                if not line.currency_id or line.currency_id != account_currency:
-                    raise ValidationError(_('The selected account of your Journal Entry forces to provide a secondary currency. You should remove the secondary currency on the account.'))
-
-    @api.multi
-    @api.constrains('currency_id', 'amount_currency')
-    def _check_currency_and_amount(self):
-        for line in self:
-            if (line.amount_currency and not line.currency_id):
-                raise ValidationError(_("You cannot create journal items with a secondary currency without filling both 'currency' and 'amount currency' fields."))
-
-    @api.multi
-    @api.constrains('amount_currency', 'debit', 'credit')
-    def _check_currency_amount(self):
-        for line in self:
-            if line.amount_currency:
-                if (line.amount_currency > 0.0 and line.credit > 0.0) or (line.amount_currency < 0.0 and line.debit > 0.0):
-                    raise ValidationError(_('The amount expressed in the secondary currency must be positive when account is debited and negative when account is credited.'))
-
     @api.depends('tax_repartition_line_id.invoice_tax_id', 'tax_repartition_line_id.refund_tax_id')
     def _compute_tax_line_id(self):
         """ tax_line_id is computed as the tax linked to the repartition line creating
@@ -769,7 +2696,7 @@ class AccountMoveLine(models.Model):
             unaffected_earnings_type = self.env.ref("account.data_unaffected_earnings")
             record.is_unaffected_earnings_line = unaffected_earnings_type == record.account_id.user_type_id
 
-    @api.depends('tag_ids', 'debit', 'credit', 'journal_id', 'invoice_id')
+    @api.depends('tag_ids', 'debit', 'credit', 'journal_id')
     def _compute_tax_audit(self):
         separator = '        '
 
@@ -777,7 +2704,7 @@ class AccountMoveLine(models.Model):
             currency = record.company_id.currency_id
             audit_str = ''
             for tag in record.tag_ids:
-                tag_amount = (tag.tax_negate and -1 or 1) * (record.journal_id.type == 'sale' and -1 or 1) * (record.invoice_id.type in ('in_refund', 'out_refund') and -1 or 1) * record.balance
+                tag_amount = (tag.tax_negate and -1 or 1) * (record.move_id.is_outbound() and -1 or 1) * record.balance
 
                 if tag.tax_report_line_ids:
                     #Then, the tag comes from a report line, and hence has a + or - sign (also in its name)
@@ -791,24 +2718,279 @@ class AccountMoveLine(models.Model):
 
             record.tax_audit = audit_str
 
-    @api.onchange('amount_currency', 'currency_id', 'account_id')
-    def _onchange_amount_currency(self):
-        '''Recompute the debit/credit based on amount_currency/currency_id and date.
-        However, date is a related field on account.move. Then, this onchange will not be triggered
-        by the form view by changing the date on the account.move.
-        To fix this problem, see _onchange_date method on account.move.
-        '''
+    # -------------------------------------------------------------------------
+    # CONSTRAINT METHODS
+    # -------------------------------------------------------------------------
+
+    @api.constrains('account_id')
+    def _check_constrains_account_id(self):
+        for line in self:
+            account = line.account_id
+            journal = line.journal_id
+
+            if account.deprecated:
+                raise UserError(_('The account %s (%s) is deprecated.') % (account.name, account.code))
+
+            control_type_failed = journal.type_control_ids and account.user_type_id not in journal.type_control_ids
+            control_account_failed = journal.account_control_ids and account not in journal.account_control_ids
+            if control_type_failed or control_account_failed:
+                raise UserError(_('You cannot use this general account in this journal, check the tab \'Entry Controls\' on the related journal.'))
+
+    @api.constrains('tax_ids', 'tax_line_id')
+    def _check_tax_lock_date1(self):
+        for line in self:
+            if line.date <= (line.company_id.tax_lock_date or date.min):
+                raise ValidationError(
+                    _("The operation is refused as it would impact an already issued tax statement. " +
+                      "Please change the journal entry date or the tax lock date set in the settings ({}) to proceed").format(
+                        line.company_id.tax_lock_date or date.min))
+
+    @api.constrains('credit', 'debit', 'date')
+    def _check_tax_lock_date2(self):
+        for line in self:
+            if (line.tax_ids or line.tax_line_id) and line.date <= (line.company_id.tax_lock_date or date.min):
+                raise ValidationError(
+                    _("The operation is refused as it would impact an already issued tax statement. " +
+                      "Please change the journal entry date or the tax lock date set in the settings ({}) to proceed").format(
+                        line.company_id.tax_lock_date or date.min))
+
+    @api.multi
+    def _update_check(self):
+        """ Raise Warning to cause rollback if the move is posted, some entries are reconciled or the move is older than the lock date"""
+        move_ids = set()
+        for line in self:
+            err_msg = _('Move name (id): %s (%s)') % (line.move_id.name, str(line.move_id.id))
+            if line.move_id.state != 'draft':
+                raise UserError(_('You cannot do this modification on a posted journal entry, you can just change some non legal fields. You must revert the journal entry to cancel it.\n%s.') % err_msg)
+            if line.reconciled and not (line.debit == 0 and line.credit == 0):
+                raise UserError(_('You cannot do this modification on a reconciled entry. You can just change some non legal fields or you must unreconcile first.\n%s.') % err_msg)
+            if line.move_id.id not in move_ids:
+                move_ids.add(line.move_id.id)
+        self.env['account.move'].browse(list(move_ids))._check_fiscalyear_lock_date()
+        return True
+
+    # -------------------------------------------------------------------------
+    # LOW-LEVEL METHODS
+    # -------------------------------------------------------------------------
+
+    @api.model_cr
+    def init(self):
+        """ change index on partner_id to a multi-column index on (partner_id, ref), the new index will behave in the
+            same way when we search on partner_id, with the addition of being optimal when having a query that will
+            search on partner_id and ref at the same time (which is the case when we open the bank reconciliation widget)
+        """
+        cr = self._cr
+        cr.execute('DROP INDEX IF EXISTS account_move_line_partner_id_index')
+        cr.execute('SELECT indexname FROM pg_indexes WHERE indexname = %s', ('account_move_line_partner_id_ref_idx',))
+        if not cr.fetchone():
+            cr.execute('CREATE INDEX account_move_line_partner_id_ref_idx ON account_move_line (partner_id, ref)')
+
+    @api.model_create_multi
+    def create(self, vals_list):
+        # OVERRIDE
+        ACCOUNTING_FIELDS = ('debit', 'credit', 'amount_currency')
+        BUSINESS_FIELDS = ('price_unit', 'quantity', 'discount', 'tax_ids')
+
+        for vals in vals_list:
+            move = self.env['account.move'].browse(vals['move_id'])
+
+            if move.is_invoice(include_receipts=True):
+                currency = self.env['res.currency'].browse(vals.get('currency_id'))
+                partner = self.env['res.partner'].browse(vals.get('partner_id'))
+                taxes = self.resolve_2many_commands('tax_ids', vals.get('tax_ids', []), fields=['id'])
+                tax_ids = set(tax['id'] for tax in taxes)
+                taxes = self.env['account.tax'].browse(tax_ids)
+
+                # Ensure consistency between accounting & business fields.
+                # As we can't express such synchronization as computed fields without cycling, we need to do it both
+                # in onchange and in create/write. So, if something changed in accounting [resp. business] fields,
+                # business [resp. accounting] fields are recomputed.
+                if any(vals.get(field) for field in ACCOUNTING_FIELDS):
+                    if vals.get('currency_id'):
+                        balance = vals.get('amount_currency', 0.0)
+                    else:
+                        balance = vals.get('debit', 0.0) - vals.get('credit', 0.0)
+                    vals.update(self._get_fields_onchange_balance_model(
+                        vals.get('quantity', 0.0),
+                        vals.get('discount', 0.0),
+                        balance,
+                        move.type,
+                        currency,
+                        taxes
+                    ))
+                    vals.update(self._get_price_total_and_subtotal_model(
+                        vals.get('price_unit', 0.0),
+                        vals.get('quantity', 0.0),
+                        vals.get('discount', 0.0),
+                        currency,
+                        self.env['product.product'].browse(vals.get('product_id')),
+                        partner,
+                        taxes,
+                        move.type,
+                    ))
+                elif any(vals.get(field) for field in BUSINESS_FIELDS):
+                    vals.update(self._get_price_total_and_subtotal_model(
+                        vals.get('price_unit', 0.0),
+                        vals.get('quantity', 0.0),
+                        vals.get('discount', 0.0),
+                        currency,
+                        self.env['product.product'].browse(vals.get('product_id')),
+                        partner,
+                        taxes,
+                        move.type,
+                    ))
+                    vals.update(self._get_fields_onchange_subtotal_model(
+                        vals['price_subtotal'],
+                        move.type,
+                        currency,
+                        move.company_id,
+                        move.date,
+                    ))
+
+            # Ensure consistency between taxes & tax exigibility fields.
+            if 'tax_exigible' in vals:
+                continue
+            if vals.get('tax_repartition_line_id'):
+                repartition_line = self.env['account.tax.repartition.line'].browse(vals['tax_repartition_line_id'])
+                tax = repartition_line.invoice_tax_id or repartition_line.refund_tax_id
+                vals['tax_exigible'] = tax.tax_exigibility == 'on_invoice'
+            elif vals.get('tax_ids'):
+                taxes = self.resolve_2many_commands('tax_ids', vals['tax_ids'])
+                vals['tax_exigible'] = not any([tax['tax_exigibility'] == 'on_payment' for tax in taxes])
+
+        lines = super(AccountMoveLine, self).create(vals_list)
+
+        # Check the move is balanced debit = credit.
+        if self._context.get('check_move_validity', True):
+            lines.mapped('move_id')._check_move_consistency()
+
+        return lines
+
+    @api.multi
+    def write(self, vals):
+        # OVERRIDE
+        ACCOUNTING_FIELDS = ('debit', 'credit', 'amount_currency')
+        BUSINESS_FIELDS = ('price_unit', 'quantity', 'discount', 'tax_ids')
+
+        if ('account_id' in vals) and self.env['account.account'].browse(vals['account_id']).deprecated:
+            raise UserError(_('You cannot use a deprecated account.'))
+        if any(key in vals for key in ('account_id', 'journal_id', 'date', 'move_id', 'debit', 'credit')):
+            self._update_check()
+        if not self._context.get('allow_amount_currency') and any(
+                key in vals for key in ('amount_currency', 'currency_id')):
+            # hackish workaround to write the amount_currency when assigning a payment to an invoice through the 'add' button
+            # this is needed to compute the correct amount_residual_currency and potentially create an exchange difference entry
+            self._update_check()
+        # when making a reconciliation on an existing liquidity journal item, mark the payment as reconciled
+        for record in self:
+            if 'statement_line_id' in vals and record.payment_id:
+                # In case of an internal transfer, there are 2 liquidity move lines to match with a bank statement
+                if all(line.statement_id for line in record.payment_id.move_line_ids.filtered(
+                        lambda r: r.id != record.id and r.account_id.internal_type == 'liquidity')):
+                    record.payment_id.state = 'reconciled'
+
+        result = super(AccountMoveLine, self).write(vals)
+
+        for line in self:
+            if not line.move_id.is_invoice(include_receipts=True):
+                continue
+
+            # Ensure consistency between accounting & business fields.
+            # As we can't express such synchronization as computed fields without cycling, we need to do it both
+            # in onchange and in create/write. So, if something changed in accounting [resp. business] fields,
+            # business [resp. accounting] fields are recomputed.
+            if any(field in vals for field in ACCOUNTING_FIELDS):
+                price_subtotal = line.currency_id and line.amount_currency or line.debit - line.credit
+                to_write = line._get_fields_onchange_balance(
+                    balance=price_subtotal,
+                )
+                to_write.update(line._get_price_total_and_subtotal(
+                    price_unit=to_write.get('price_unit', line.price_unit),
+                    quantity=to_write.get('quantity', line.quantity),
+                    discount=to_write.get('discount', line.discount),
+                ))
+                super(AccountMoveLine, line).write(to_write)
+            elif any(field in vals for field in BUSINESS_FIELDS):
+                to_write = self._get_price_total_and_subtotal()
+                to_write.update(line._get_fields_onchange_subtotal(
+                    price_subtotal=to_write['price_subtotal'],
+                ))
+                super(AccountMoveLine, line).write(to_write)
+
+        if self._context.get('check_move_validity', True) and any(key in vals for key in ('account_id', 'journal_id', 'date', 'move_id', 'debit', 'credit')):
+            self.env['account.move'].browse(self.mapped('move_id.id'))._check_move_consistency()
+
+        return result
+
+    @api.multi
+    def unlink(self):
+        self._update_check()
+        self._check_tax_lock_date2()
+        move_ids = set()
+        for line in self:
+            if line.move_id.id not in move_ids:
+                move_ids.add(line.move_id.id)
+        result = super(AccountMoveLine, self).unlink()
+        if self._context.get('check_move_validity', True) and move_ids:
+            self.env['account.move'].browse(list(move_ids))._check_move_consistency()
+        return result
+
+    @api.model
+    def default_get(self, default_fields):
+        # OVERRIDE
+        values = super(AccountMoveLine, self).default_get(default_fields)
+
+        if 'account_id' in default_fields \
+            and (self._context.get('journal_id') or self._context.get('default_journal_id')) \
+            and not values.get('account_id') \
+            and self._context.get('default_type') in self.move_id.get_inbound_types():
+            # Fill missing 'account_id'.
+            journal = self.env['account.journal'].browse(self._context.get('default_journal_id') or self._context['journal_id'])
+            values['account_id'] = journal.default_credit_account_id.id
+        elif 'account_id' in default_fields \
+            and (self._context.get('journal_id') or self._context.get('default_journal_id')) \
+            and not values.get('account_id') \
+            and self._context.get('default_type') in self.move_id.get_outbound_types():
+            # Fill missing 'account_id'.
+            journal = self.env['account.journal'].browse(self._context.get('default_journal_id') or self._context['journal_id'])
+            values['account_id'] = journal.default_debit_account_id.id
+        elif self._context.get('line_ids') and any(field_name in default_fields for field_name in ('debit', 'credit', 'account_id', 'partner_id')):
+            move = self.env['account.move'].new({'line_ids': self._context['line_ids']})
+
+            # Suggest default value for debit / credit to balance the journal entry.
+            balance = sum(line['debit'] - line['credit'] for line in move.line_ids)
+            if balance < 0.0:
+                values.update({'debit': -balance})
+            if balance > 0.0:
+                values.update({'credit': balance})
+
+            # Suggest default value for 'partner_id'.
+            if 'partner_id' in default_fields and not values.get('partner_id'):
+                partners = move.line_ids[-2:].mapped('partner_id')
+                if len(partners) == 1:
+                    values['partner_id'] = partners.id
+
+            # Suggest default value for 'account_id'.
+            if 'account_id' in default_fields and not values.get('account_id'):
+                accounts = move.line_ids[-2:].mapped('account_id')
+                if len(accounts) == 1:
+                    values['account_id'] = accounts.id
+        return values
+
+    @api.multi
+    @api.depends('ref', 'move_id')
+    def name_get(self):
+        result = []
         for line in self:
-            company_currency_id = line.account_id.company_id.currency_id
-            amount = line.amount_currency
-            if line.currency_id and company_currency_id and line.currency_id != company_currency_id:
-                amount = line.currency_id._convert(amount, company_currency_id, line.company_id, line.date or fields.Date.today())
-                line.debit = amount > 0 and amount or 0.0
-                line.credit = amount < 0 and -amount or 0.0
+            if line.ref:
+                result.append((line.id, (line.move_id.name or '') + '(' + line.ref + ')'))
+            else:
+                result.append((line.id, line.move_id.name))
+        return result
 
-    ####################################################
-    # Reconciliation methods
-    ####################################################
+    # -------------------------------------------------------------------------
+    # RECONCILIATION
+    # -------------------------------------------------------------------------
 
     @api.multi
     def check_full_reconcile(self):
@@ -889,7 +3071,7 @@ class AccountMoveLine(models.Model):
             exchange_move_id = False
             # Eventually create a journal entry to book the difference due to foreign currency's exchange rate that fluctuates
             if to_balance and any([not float_is_zero(residual, precision_rounding=digits_rounding_precision) for aml, residual in to_balance.values()]):
-                exchange_move = self.env['account.move'].create(
+                exchange_move = self.env['account.move'].with_context(default_type='entry').create(
                     self.env['account.full.reconcile']._prepare_exchange_diff_move(move_date=maxdate, company=amls[0].company_id))
                 part_reconcile = self.env['account.partial.reconcile']
                 for aml_to_balance, total in to_balance.values():
@@ -980,13 +3162,12 @@ class AccountMoveLine(models.Model):
             for after_rec_dict in cash_basis_subjected:
                 new_rec = part_rec.create(after_rec_dict)
                 # if the pair belongs to move being reverted, do not create CABA entry
-                if cash_basis and not (new_rec.debit_move_id + new_rec.credit_move_id).mapped('move_id').mapped('reverse_entry_id'):
+                if cash_basis and not (new_rec.debit_move_id + new_rec.credit_move_id).mapped('move_id.reversed_entry_id'):
                     new_rec.create_tax_cash_basis_entry(cash_basis_percentage_before_rec)
         self.recompute()
 
         return debit_moves+credit_moves
 
-
     @api.multi
     def auto_reconcile_lines(self):
         # Create list of debit and list of credit move ordered by date-currency
@@ -1027,7 +3208,7 @@ class AccountMoveLine(models.Model):
         # Empty self can happen if the user tries to reconcile entries which are already reconciled.
         # The calling method might have filtered out reconciled lines.
         if not self:
-            return True
+            return
 
         self._check_reconcile_validity()
         #reconcile everything that can be
@@ -1053,7 +3234,6 @@ class AccountMoveLine(models.Model):
     def _create_writeoff(self, writeoff_vals):
         """ Create a writeoff move per journal for the account.move.lines in self. If debit/credit is not specified in vals,
             the writeoff amount will be computed as the sum of amount_residual of the given recordset.
-
             :param writeoff_vals: list of dicts containing values suitable for account_move_line.create(). The data in vals will
                 be processed to create bot writeoff acount.move.line and their enclosing account.move.
         """
@@ -1133,208 +3313,38 @@ class AccountMoveLine(models.Model):
                 'line_ids': [(0, 0, line) for line in writeoff_lines],
             })
             writeoff_moves += writeoff_move
-            # writeoff_move.post()
-
             line_to_reconcile += writeoff_move.line_ids.filtered(lambda r: r.account_id == self[0].account_id).sorted(key='id')[-1:]
+
+        #post all the writeoff moves at once
         if writeoff_moves:
             writeoff_moves.post()
+
         # Return the writeoff move.line which is to be reconciled
         return line_to_reconcile
 
     @api.multi
     def remove_move_reconcile(self):
         """ Undo a reconciliation """
-        if not self:
-            return True
-        rec_move_ids = self.env['account.partial.reconcile']
-        for account_move_line in self:
-            account_move_line.reconcile_model_id = False
-            for invoice in account_move_line.payment_id.invoice_ids:
-                if invoice.id == self.env.context.get('invoice_id') and account_move_line in invoice.payment_move_line_ids:
-                    account_move_line.payment_id.write({'invoice_ids': [(3, invoice.id, None)]})
-            rec_move_ids += account_move_line.matched_debit_ids
-            rec_move_ids += account_move_line.matched_credit_ids
-        if self.env.context.get('invoice_id'):
-            current_invoice = self.env['account.invoice'].browse(self.env.context['invoice_id'])
-            aml_to_keep = current_invoice.move_id.line_ids | current_invoice.move_id.line_ids.mapped('full_reconcile_id.exchange_move_id.line_ids')
-            rec_move_ids = rec_move_ids.filtered(
-                lambda r: (r.debit_move_id + r.credit_move_id) & aml_to_keep
-            )
-        return rec_move_ids.unlink()
-
-    def _apply_taxes(self, vals, amount):
-        tax_lines_vals = []
-        # Get ids from triplets : https://www.odoo.com/documentation/10.0/reference/orm.html#odoo.models.Model.write
-        tax_ids = [tax['id'] for tax in self.resolve_2many_commands('tax_ids', vals['tax_ids']) if tax.get('id')]
-        # Since create() receives ids instead of recordset, let's just use the old-api bridge
-        taxes = self.env['account.tax'].browse(tax_ids)
-        currency = self.env['res.currency'].browse(vals.get('currency_id'))
-        partner = self.env['res.partner'].browse(vals.get('partner_id'))
-        ctx = dict(self._context)
-        ctx['round'] = ctx.get('round', True)
-        res = taxes.with_context(ctx).compute_all(amount,
-            currency, 1, vals.get('product_id'), partner)
-        # Adjust line amount if any tax is price_include
-        if abs(res['total_excluded']) < abs(amount):
-            if vals['debit'] != 0.0: vals['debit'] = res['total_excluded']
-            if vals['credit'] != 0.0: vals['credit'] = -res['total_excluded']
-            if vals.get('amount_currency'):
-                vals['amount_currency'] = self.env['res.currency'].browse(vals['currency_id']).round(vals['amount_currency'] * (res['total_excluded']/amount))
-        # Create tax lines
-        for tax_vals in res['taxes']:
-            if tax_vals['amount']:
-                tax = self.env['account.tax'].browse([tax_vals['id']])
-                account_id = (amount > 0 and tax_vals['account_id'] or tax_vals['refund_account_id'])
-                if not account_id: account_id = vals['account_id']
-                temp = {
-                    'account_id': account_id,
-                    'name': vals['name'] + ' ' + tax_vals['name'],
-                    'tax_line_id': tax_vals['id'],
-                    'move_id': vals['move_id'],
-                    'partner_id': vals.get('partner_id'),
-                    'statement_id': vals.get('statement_id'),
-                    'debit': tax_vals['amount'] > 0 and tax_vals['amount'] or 0.0,
-                    'credit': tax_vals['amount'] < 0 and -tax_vals['amount'] or 0.0,
-                    'analytic_account_id': vals.get('analytic_account_id') if tax.analytic else False,
-                }
-                bank = self.env["account.bank.statement.line"].browse(vals.get('statement_line_id')).statement_id
-                if bank.currency_id != bank.company_id.currency_id:
-                    ctx = {}
-                    if 'date' in vals:
-                        ctx['date'] = vals['date']
-                    elif 'date_maturity' in vals:
-                        ctx['date'] = vals['date_maturity']
-                    temp['currency_id'] = bank.currency_id.id
-                    temp['amount_currency'] = bank.company_id.currency_id.with_context(ctx).compute(tax_vals['amount'], bank.currency_id, round=True)
-                if vals.get('tax_exigible'):
-                    temp['tax_exigible'] = True
-                    temp['account_id'] = tax.cash_basis_account.id or account_id
-                tax_lines_vals.append(temp)
-        return tax_lines_vals
-
-    ####################################################
-    # CRUD methods
-    ####################################################
-
-    @api.model_create_multi
-    def create(self, vals_list):
-        """ :context's key `check_move_validity`: check data consistency after move line creation. Eg. set to false to disable verification that the move
-                debit-credit == 0 while creating the move lines composing the move.
-        """
-        for vals in vals_list:
-            amount = vals.get('debit', 0.0) - vals.get('credit', 0.0)
-            move = self.env['account.move'].browse(vals['move_id'])
-            account = self.env['account.account'].browse(vals['account_id'])
-            if account.deprecated:
-                raise UserError(_('The account %s (%s) is deprecated.') %(account.name, account.code))
-            journal = vals.get('journal_id') and self.env['account.journal'].browse(vals['journal_id']) or move.journal_id
-            vals['date_maturity'] = vals.get('date_maturity') or vals.get('date') or move.date
-
-            ok = (
-                (not journal.type_control_ids and not journal.account_control_ids)
-                or account.user_type_id in journal.type_control_ids
-                or account in journal.account_control_ids
-            )
-            if not ok:
-                raise UserError(_('You cannot use this general account in this journal, check the tab \'Entry Controls\' on the related journal.'))
-
-            # Automatically convert in the account's secondary currency if there is one and
-            # the provided values were not already multi-currency
-            if account.currency_id and 'amount_currency' not in vals and account.currency_id.id != account.company_id.currency_id.id:
-                vals['currency_id'] = account.currency_id.id
-                date = vals.get('date') or vals.get('date_maturity') or fields.Date.today()
-                vals['amount_currency'] = account.company_id.currency_id._convert(amount, account.currency_id, account.company_id, date)
-
-            #Toggle the 'tax_exigible' field to False in case it is not yet given and the tax in 'tax_line_id' or one of
-            #the 'tax_ids' is a cash based tax.
-            taxes = False
-            if vals.get('tax_repartition_line_id'):
-                taxes = [{'tax_exigibility': self.env['account.tax.repartition.line'].browse(vals['tax_repartition_line_id']).tax_id.tax_exigibility}]
-            if vals.get('tax_ids'):
-                taxes = self.env['account.move.line'].resolve_2many_commands('tax_ids', vals['tax_ids'])
-            if taxes and any([tax['tax_exigibility'] == 'on_payment' for tax in taxes]) and not vals.get('tax_exigible'):
-                vals['tax_exigible'] = False
-
-        lines = super(AccountMoveLine, self).create(vals_list)
-
-        if self._context.get('check_move_validity', True):
-            lines.mapped('move_id')._post_validate()
-
-        return lines
-
-    @api.multi
-    def unlink(self):
-        self._update_check()
-        self._check_tax_lock_date2()
-        move_ids = set()
-        for line in self:
-            if line.move_id.id not in move_ids:
-                move_ids.add(line.move_id.id)
-        result = super(AccountMoveLine, self).unlink()
-        if self._context.get('check_move_validity', True) and move_ids:
-            self.env['account.move'].browse(list(move_ids))._post_validate()
-        return result
+        (self.mapped('matched_debit_ids') + self.mapped('matched_credit_ids')).unlink()
 
     @api.multi
-    def write(self, vals):
-        if ('account_id' in vals) and self.env['account.account'].browse(vals['account_id']).deprecated:
-            raise UserError(_('You cannot use a deprecated account.'))
-        if any(key in vals for key in ('account_id', 'journal_id', 'date', 'move_id', 'debit', 'credit')):
-            self._update_check()
-        if not self._context.get('allow_amount_currency') and any(key in vals for key in ('amount_currency', 'currency_id')):
-            #hackish workaround to write the amount_currency when assigning a payment to an invoice through the 'add' button
-            #this is needed to compute the correct amount_residual_currency and potentially create an exchange difference entry
-            self._update_check()
-        #when we set the expected payment date, log a note on the invoice_id related (if any)
-        if vals.get('expected_pay_date') and self.invoice_id:
-            str_expected_pay_date = vals['expected_pay_date']
-            if isinstance(str_expected_pay_date, date):
-                str_expected_pay_date = fields.Date.to_string(str_expected_pay_date)
-            msg = _('New expected payment date: ') + str_expected_pay_date + '.\n' + vals.get('internal_note', '')
-            self.invoice_id.message_post(body=msg) #TODO: check it is an internal note (not a regular email)!
-        #when making a reconciliation on an existing liquidity journal item, mark the payment as reconciled
-        for record in self:
-            if 'statement_line_id' in vals and record.payment_id:
-                # In case of an internal transfer, there are 2 liquidity move lines to match with a bank statement
-                if all(line.statement_id for line in record.payment_id.move_line_ids.filtered(lambda r: r.id != record.id and r.account_id.internal_type=='liquidity')):
-                    record.payment_id.state = 'reconciled'
-
-        result = super(AccountMoveLine, self).write(vals)
-        if self._context.get('check_move_validity', True) and any(key in vals for key in ('account_id', 'journal_id', 'date', 'move_id', 'debit', 'credit')):
-            move_ids = set()
-            for line in self:
-                if line.move_id.id not in move_ids:
-                    move_ids.add(line.move_id.id)
-            self.env['account.move'].browse(list(move_ids))._post_validate()
-        return result
+    def _copy_data_extend_business_fields(self, values):
+        ''' Hook allowing copying business fields under certain conditions.
+        E.g. The link to the sale order lines must be preserved in case of a refund.
+        '''
+        self.ensure_one()
 
     @api.multi
-    def _update_check(self):
-        """ Raise Warning to cause rollback if the move is posted, some entries are reconciled or the move is older than the lock date"""
-        move_ids = set()
-        for line in self:
-            err_msg = _('Move name (id): %s (%s)') % (line.move_id.name, str(line.move_id.id))
-            if line.reconciled and not (line.debit == 0 and line.credit == 0):
-                raise UserError(_('You cannot do this modification on a reconciled entry. You can just change some non legal fields or you must unreconcile first.\n%s.') % err_msg)
-            if line.move_id.id not in move_ids:
-                move_ids.add(line.move_id.id)
-        self.env['account.move'].browse(list(move_ids))._check_lock_date()
-        return True
-
-    ####################################################
-    # Misc / utility methods
-    ####################################################
+    def copy_data(self, default=None):
+        res = super(AccountMoveLine, self).copy_data(default=default)
+        if self._context.get('include_business_fields'):
+            for line, values in zip(self, res):
+                line._copy_data_extend_business_fields(values)
+        return res
 
-    @api.multi
-    @api.depends('ref', 'move_id')
-    def name_get(self):
-        result = []
-        for line in self:
-            if line.ref:
-                result.append((line.id, (line.move_id.name or '') + '(' + line.ref + ')'))
-            else:
-                result.append((line.id, line.move_id.name))
-        return result
+    # -------------------------------------------------------------------------
+    # MISC
+    # -------------------------------------------------------------------------
 
     def _get_matched_percentage(self):
         """ This function returns a dictionary giving for each move_id of self, the percentage to consider as cash basis factor.
@@ -1365,7 +3375,7 @@ class AccountMoveLine(models.Model):
                                     break
                 if not all_same_currency:
                     #we cannot rely on amount_currency fields as it is not present on all partial reconciliation
-                    matched_percentage_per_move[line.move_id.id] = line.move_id.matched_percentage
+                    matched_percentage_per_move[line.move_id.id] = line.move_id._get_cash_basis_matched_percentage()
                 else:
                     #we can rely on amount_currency fields, which allow us to post a tax cash basis move at the initial rate
                     #to avoid currency rate difference issues.
@@ -1375,22 +3385,6 @@ class AccountMoveLine(models.Model):
                         matched_percentage_per_move[line.move_id.id] = total_reconciled_currency / total_amount_currency
         return matched_percentage_per_move
 
-    @api.model
-    def _compute_amount_fields(self, amount, src_currency, company_currency):
-        """ Helper function to compute value for fields debit/credit/amount_currency based on an amount and the currencies given in parameter"""
-        amount_currency = False
-        currency_id = False
-        date = self.env.context.get('date') or fields.Date.today()
-        company = self.env.context.get('company_id')
-        company = self.env['res.company'].browse(company) if company else self.env.company
-        if src_currency and src_currency != company_currency:
-            amount_currency = amount
-            amount = src_currency._convert(amount, company_currency, company, date)
-            currency_id = src_currency.id
-        debit = amount > 0 and amount or 0.0
-        credit = amount < 0 and -amount or 0.0
-        return debit, credit, amount_currency, currency_id
-
     def _get_analytic_tag_ids(self):
         self.ensure_one()
         return self.analytic_tag_ids.filtered(lambda r: not r.active_analytic_distribution).ids
@@ -1436,7 +3430,7 @@ class AccountMoveLine(models.Model):
                 'general_account_id': move_line.account_id.id,
                 'ref': move_line.ref,
                 'move_id': move_line.id,
-                'user_id': move_line.invoice_id.user_id.id or self._uid,
+                'user_id': move_line.move_id.invoice_user_id.id or self._uid,
                 'partner_id': move_line.partner_id.id,
                 'company_id': move_line.analytic_account_id.company_id.id or self.env.company.id,
             })
@@ -1462,7 +3456,7 @@ class AccountMoveLine(models.Model):
             'general_account_id': self.account_id.id,
             'ref': self.ref,
             'move_id': self.id,
-            'user_id': self.invoice_id.user_id.id or self._uid,
+            'user_id': self.move_id.invoice_user_id.id or self._uid,
             'company_id': distribution.account_id.company_id.id or self.env.company.id,
         }
 
@@ -1526,6 +3520,9 @@ class AccountMoveLine(models.Model):
         where_clause_params = []
         tables = ''
         if domain:
+            domain.append(('display_type', 'not in', ('line_section', 'line_note')))
+            domain.append(('move_id.state', '!=', 'cancel'))
+
             query = self._where_calc(domain)
 
             # Wrap the query with 'company_id IN (...)' to avoid bypassing company access rights.
@@ -1534,6 +3531,19 @@ class AccountMoveLine(models.Model):
             tables, where_clause, where_clause_params = query.get_sql()
         return tables, where_clause, where_clause_params
 
+    # FIXME: Clarify me and change me in master
+    @api.multi
+    def action_duplicate(self):
+        self.ensure_one()
+        action = self.env.ref('account.action_move_journal_line').read()[0]
+        action['target'] = 'inline'
+        action['context'] = dict(self.env.context)
+        action['context']['form_view_initial_mode'] = 'edit'
+        action['context']['view_no_maturity'] = False
+        action['views'] = [(self.env.ref('account.view_move_form').id, 'form')]
+        action['res_id'] = self.copy().id
+        return action
+
     @api.multi
     def open_reconcile_view(self):
         [action] = self.env.ref('account.action_account_moves_all').read()
@@ -1546,7 +3556,7 @@ class AccountMoveLine(models.Model):
         return action
 
     @api.model
-    def _get_domain_for_edition_mode(self):
+    def _get_suspense_moves_domain(self):
         return [
             ('move_id.to_check', '=', True),
             ('full_reconcile_id', '=', False),
@@ -1598,7 +3608,6 @@ class AccountPartialReconcile(models.Model):
         new journal item will be made into the given `move` in the company
         `currency_exchange_journal_id`, and one of its journal items is
         matched with the other lines to balance the full reconciliation.
-
         :param aml_to_fix: recordset of account.move.line (possible several
             but sharing the same currency)
         :param move: account.move
@@ -1648,7 +3657,6 @@ class AccountPartialReconcile(models.Model):
 
     def _get_tax_cash_basis_base_account(self, line, tax):
         ''' Get the account of lines that will contain the base amount of taxes.
-
         :param line: An account.move.line record
         :param tax: An account.tax record
         :return: An account record
@@ -1706,7 +3714,6 @@ class AccountPartialReconcile(models.Model):
                                 'account_id': line.tax_repartition_line_id.account_id.id,
                                 'analytic_account_id': line.analytic_account_id.id,
                                 'analytic_tag_ids': line.analytic_tag_ids.ids,
-                                'tax_line_id': line.tax_line_id.id,
                                 'tax_exigible': True,
                                 'amount_currency': line.amount_currency and line.currency_id.round(line.amount_currency * amount / line.balance) or 0.0,
                                 'currency_id': line.currency_id.id,
@@ -1787,9 +3794,9 @@ class AccountPartialReconcile(models.Model):
         #reverse the tax basis move created at the reconciliation time
         for move in self.env['account.move'].search([('tax_cash_basis_rec_id', 'in', self._ids)]):
             if move.date > (move.company_id.period_lock_date or date.min):
-                move.reverse_moves(date=move.date)
+                move._reverse_moves([{'ref': _('Reversal of %s') % move.name}], cancel=True)
             else:
-                move.reverse_moves()
+                move._reverse_moves([{'date': fields.Date.today(), 'ref': _('Reversal of %s') % move.name}], cancel=True)
         res = super(AccountPartialReconcile, self).unlink()
         if full_to_unlink:
             full_to_unlink.unlink()
@@ -1819,7 +3826,10 @@ class AccountFullReconcile(models.Model):
                 # (reversing will cause a nested attempt to drop the full reconciliation)
                 to_reverse = rec.exchange_move_id
                 rec.exchange_move_id = False
-                to_reverse.reverse_moves()
+                to_reverse._reverse_moves([{
+                    'date': fields.Date.today(),
+                    'ref': _('Reversal of: %s') % to_reverse.name,
+                }], cancel=True)
         return super(AccountFullReconcile, self).unlink()
 
     @api.model

--- a/addons/account/models/account_payment.py
+++ b/addons/account/models/account_payment.py
@@ -2,22 +2,14 @@
 
 from odoo import models, fields, api, _
 from odoo.exceptions import UserError, ValidationError
-from odoo.tools import float_compare
-
-from itertools import groupby
 
 MAP_INVOICE_TYPE_PARTNER_TYPE = {
     'out_invoice': 'customer',
     'out_refund': 'customer',
+    'out_receipt': 'customer',
     'in_invoice': 'supplier',
     'in_refund': 'supplier',
-}
-# Since invoice amounts are unsigned, this is how we know if money comes in or goes out
-MAP_INVOICE_TYPE_PAYMENT_SIGN = {
-    'out_invoice': 1,
-    'in_refund': -1,
-    'in_invoice': -1,
-    'out_refund': 1,
+    'in_receipt': 'supplier',
 }
 
 
@@ -47,11 +39,11 @@ class account_payment(models.Model):
     # For money transfer, money goes from journal_id to a transfer account, then from the transfer account to destination_journal_id
     destination_journal_id = fields.Many2one('account.journal', string='Transfer To', domain=[('type', 'in', ('bank', 'cash'))], readonly=True, states={'draft': [('readonly', False)]})
 
-    invoice_ids = fields.Many2many('account.invoice', 'account_invoice_payment_rel', 'payment_id', 'invoice_id', string="Invoices", copy=False, readonly=True,
+    invoice_ids = fields.Many2many('account.move', 'account_invoice_payment_rel', 'payment_id', 'invoice_id', string="Invoices", copy=False, readonly=True,
                                    help="""Technical field containing the invoice for which the payment has been generated.
                                    This does not especially correspond to the invoices reconciled with the payment,
                                    as it can have been generated first, and reconciled later""")
-    reconciled_invoice_ids = fields.Many2many('account.invoice', string='Reconciled Invoices', compute='_compute_reconciled_invoice_ids', help="Invoices whose journal items have been reconciled with this payment's.")
+    reconciled_invoice_ids = fields.Many2many('account.move', string='Reconciled Invoices', compute='_compute_reconciled_invoice_ids', help="Invoices whose journal items have been reconciled with these payments.")
     has_invoices = fields.Boolean(compute="_compute_reconciled_invoice_ids", help="Technical field used for usability purposes")
 
     move_line_ids = fields.One2many('account.move.line', 'payment_id', readonly=True, copy=False, ondelete='restrict')
@@ -94,19 +86,19 @@ class account_payment(models.Model):
     require_partner_bank_account = fields.Boolean(compute='_compute_show_partner_bank', help='Technical field used to know whether the field `partner_bank_account_id` needs to be required or not in the payments form views')
 
     @api.model
-    def default_get(self, fields):
-        rec = super(account_payment, self).default_get(fields)
+    def default_get(self, default_fields):
+        rec = super(account_payment, self).default_get(default_fields)
         active_ids = self._context.get('active_ids') or self._context.get('active_id')
         active_model = self._context.get('active_model')
 
         # Check for selected invoices ids
-        if not active_ids or active_model != 'account.invoice':
+        if not active_ids or active_model != 'account.move':
             return rec
 
-        invoices = self.env['account.invoice'].browse(active_ids)
+        invoices = self.env['account.move'].browse(active_ids).filtered(lambda move: move.is_invoice(include_receipts=True))
 
         # Check all invoices are open
-        if any(invoice.state != 'open' for invoice in invoices):
+        if not invoices or any(invoice.state != 'posted' for invoice in invoices):
             raise UserError(_("You can only register payments for open invoices"))
         # Check if, in batch payments, there are not negative invoices and positive invoices
         dtype = invoices[0].type
@@ -119,23 +111,23 @@ class account_payment(models.Model):
                         (dtype == 'out_invoice' and inv.type == 'out_refund')):
                     raise UserError(_("You cannot register payments for customer invoices and credit notes at the same time."))
 
-        amount = self._compute_payment_amount(invoices, invoices[0].currency_id)
+        amount = self._compute_payment_amount(invoices, invoices[0].currency_id, invoices[0].journal_id, rec.get('payment_date') or fields.Date.today())
         rec.update({
             'currency_id': invoices[0].currency_id.id,
             'amount': abs(amount),
             'payment_type': 'inbound' if amount > 0 else 'outbound',
             'partner_id': invoices[0].commercial_partner_id.id,
             'partner_type': MAP_INVOICE_TYPE_PARTNER_TYPE[invoices[0].type],
-            'communication': invoices[0].reference or invoices[0].number,
+            'communication': invoices[0].ref or invoices[0].name,
             'invoice_ids': [(6, 0, invoices.ids)],
         })
         return rec
 
-    @api.one
     @api.constrains('amount')
     def _check_amount(self):
-        if self.amount < 0:
-            raise ValidationError(_('The payment amount cannot be negative.'))
+        for payment in self:
+            if payment.amount < 0:
+                raise ValidationError(_('The payment amount cannot be negative.'))
 
     @api.model
     def _get_method_codes_using_bank_account(self):
@@ -169,11 +161,14 @@ class account_payment(models.Model):
     def _compute_payment_difference(self):
         for pay in self.filtered(lambda p: p.invoice_ids and p.state == 'draft'):
             payment_amount = -pay.amount if pay.payment_type == 'outbound' else pay.amount
-            pay.payment_difference = pay._compute_payment_amount() - payment_amount
+            pay.payment_difference = pay._compute_payment_amount(pay.invoice_ids, pay.currency_id, pay.journal_id, pay.payment_date) - payment_amount
 
     @api.onchange('journal_id')
     def _onchange_journal(self):
         if self.journal_id:
+            if self.journal_id.currency_id:
+                self.currency_id = self.journal_id.currency_id
+
             # Set default payment method (we consider the first to be the default one)
             payment_methods = self.payment_type == 'inbound' and self.journal_id.inbound_payment_method_ids or self.journal_id.outbound_payment_method_ids
             payment_methods_list = payment_methods.ids
@@ -190,18 +185,18 @@ class account_payment(models.Model):
 
             domain = {'payment_method_id': [('payment_type', '=', payment_type), ('id', 'in', payment_methods_list)]}
 
-            if self.env.context.get('active_model') == 'account.invoice':
+            if self.env.context.get('active_model') == 'account.move':
                 active_ids = self._context.get('active_ids')
-                invoices = self.env['account.invoice'].browse(active_ids)
-                self.amount = abs(self._compute_payment_amount(invoices))
+                invoices = self.env['account.move'].browse(active_ids)
+                self.amount = abs(self._compute_payment_amount(invoices, self.currency_id, self.journal_id, self.payment_date))
 
             return {'domain': domain}
         return {}
 
     @api.onchange('partner_id')
     def _onchange_partner_id(self):
-        if self.invoice_ids and self.invoice_ids[0].partner_bank_id:
-            self.partner_bank_account_id = self.invoice_ids[0].partner_bank_id
+        if self.invoice_ids and self.invoice_ids[0].invoice_partner_bank_id:
+            self.partner_bank_account_id = self.invoice_ids[0].invoice_partner_bank_id
         elif self.partner_id != self.partner_bank_account_id.partner_id:
             # This condition ensures we use the default value provided into
             # context for partner_bank_account_id properly when provided with a
@@ -272,7 +267,7 @@ class account_payment(models.Model):
 
     @api.onchange('currency_id')
     def _onchange_currency(self):
-        self.amount = abs(self._compute_payment_amount())
+        self.amount = abs(self._compute_payment_amount(self.invoice_ids, self.currency_id, self.journal_id, self.payment_date))
 
         if self.journal_id:  # TODO: only return if currency differ?
             return
@@ -285,36 +280,48 @@ class account_payment(models.Model):
         if journal:
             return {'value': {'journal_id': journal.id}}
 
-    @api.multi
-    def _compute_payment_amount(self, invoices=None, currency=None):
+    @api.model
+    def _compute_payment_amount(self, invoices, currency, journal, date):
         '''Compute the total amount for the payment wizard.
 
-        :param invoices: If not specified, pick all the invoices.
-        :param currency: If not specified, search a default currency on wizard/journal.
-        :return: The total amount to pay the invoices.
+        :param invoices:    Invoices on which compute the total as an account.invoice recordset.
+        :param currency:    The payment's currency as a res.currency record.
+        :param journal:     The payment's journal as an account.journal record.
+        :param date:        The payment's date as a datetime.date object.
+        :return:            The total amount to pay the invoices.
         '''
+        company = journal.company_id
+        currency = currency or journal.currency_id or company.currency_id
+        date = date or fields.Date.today()
 
-        # Get the payment invoices
         if not invoices:
-            invoices = self.invoice_ids
-
-        # Get the payment currency
-        if not currency:
-            currency = self.currency_id or self.journal_id.currency_id or self.journal_id.company_id.currency_id
+            return 0.0
+
+        self._cr.execute('''
+            SELECT
+                move.type AS type,
+                move.currency_id AS currency_id,
+                SUM(line.amount_residual) AS amount_residual,
+                SUM(line.amount_residual_currency) AS residual_currency
+            FROM account_move move
+            LEFT JOIN account_move_line line ON line.move_id = move.id
+            LEFT JOIN account_account account ON account.id = line.account_id
+            LEFT JOIN account_account_type account_type ON account_type.id = account.user_type_id
+            WHERE move.id IN %s
+            AND account_type.type IN ('receivable', 'payable')
+            GROUP BY move.id, move.type
+        ''', [tuple(invoices.ids)])
+        query_res = self._cr.dictfetchall()
 
-        # Avoid currency rounding issues by summing the amounts according to the company_currency_id before
-        invoice_datas = invoices.read_group(
-            [('id', 'in', invoices.ids)],
-            ['currency_id', 'type', 'residual_signed'],
-            ['currency_id', 'type'], lazy=False)
         total = 0.0
-        for invoice_data in invoice_datas:
-            amount_total = MAP_INVOICE_TYPE_PAYMENT_SIGN[invoice_data['type']] * invoice_data['residual_signed']
-            payment_currency = self.env['res.currency'].browse(invoice_data['currency_id'][0])
-            if payment_currency == currency:
-                total += amount_total
+        for res in query_res:
+            move_currency = self.env['res.currency'].browse(res['currency_id'])
+            if move_currency == currency and move_currency != company.currency_id:
+                total += res['residual_currency']
+            elif move_currency == currency == company.currency_id:
+                total += res['amount_residual']
             else:
-                total += payment_currency._convert(amount_total, currency, self.env.company, self.payment_date or fields.Date.today())
+                total += move_currency._convert(res['amount_residual'], currency, company, date)
         return total
 
     @api.multi
@@ -358,7 +365,8 @@ class account_payment(models.Model):
     @api.depends('invoice_ids', 'payment_type', 'partner_type', 'partner_id')
     def _compute_destination_account_id(self):
         if self.invoice_ids:
-            self.destination_account_id = self.invoice_ids[0].account_id.id
+            self.destination_account_id = self.invoice_ids[0].mapped('line_ids.account_id')\
+                .filtered(lambda account: account.user_type_id.type in ('receivable', 'payable'))[0]
         elif self.payment_type == 'transfer':
             if not self.company_id.transfer_account_id.id:
                 raise UserError(_('There is no Transfer Account defined in the accounting settings. Please define one to be able to confirm this transfer.'))
@@ -378,8 +386,9 @@ class account_payment(models.Model):
     @api.depends('move_line_ids.matched_debit_ids', 'move_line_ids.matched_credit_ids')
     def _compute_reconciled_invoice_ids(self):
         for record in self:
-            record.reconciled_invoice_ids = (record.move_line_ids.mapped('matched_debit_ids.debit_move_id.invoice_id') |
-                                             record.move_line_ids.mapped('matched_credit_ids.credit_move_id.invoice_id'))
+            reconciled_moves = record.move_line_ids.mapped('matched_debit_ids.debit_move_id.move_id')\
+                               + record.move_line_ids.mapped('matched_credit_ids.credit_move_id.move_id')
+            record.reconciled_invoice_ids = reconciled_moves.filtered(lambda move: move.is_invoice())
             record.has_invoices = bool(record.reconciled_invoice_ids)
 
     @api.multi
@@ -413,17 +422,13 @@ class account_payment(models.Model):
 
     @api.multi
     def button_invoices(self):
-        if self.partner_type == 'supplier':
-            views = [(self.env.ref('account.invoice_supplier_tree').id, 'tree'), (self.env.ref('account.invoice_supplier_form').id, 'form')]
-        else:
-            views = [(self.env.ref('account.invoice_tree').id, 'tree'), (self.env.ref('account.invoice_form').id, 'form')]
         return {
             'name': _('Paid Invoices'),
             'view_type': 'form',
             'view_mode': 'tree,form',
-            'res_model': 'account.invoice',
+            'res_model': 'account.move',
             'view_id': False,
-            'views': views,
+            'views': [(self.env.ref('account.view_move_tree').id, 'tree'), (self.env.ref('account.view_move_form').id, 'form')],
             'type': 'ir.actions.act_window',
             'domain': [('id', 'in', [x.id for x in self.reconciled_invoice_ids])],
         }
@@ -457,6 +462,186 @@ class account_payment(models.Model):
             raise UserError(_('It is not allowed to delete a payment that already created a journal entry since it would create a gap in the numbering. You should create the journal entry again and cancel it thanks to a regular revert.'))
         return super(account_payment, self).unlink()
 
+    @api.multi
+    def _prepare_payment_moves(self):
+        ''' Prepare the creation of journal entries (account.move) by creating a list of python dictionary to be passed
+        to the 'create' method.
+
+        Example 1: outbound with write-off:
+
+        Account             | Debit     | Credit
+        ---------------------------------------------------------
+        BANK                |   900.0   |
+        RECEIVABLE          |           |   1000.0
+        WRITE-OFF ACCOUNT   |   100.0   |
+
+        Example 2: internal transfer from BANK to CASH:
+
+        Account             | Debit     | Credit
+        ---------------------------------------------------------
+        BANK                |           |   1000.0
+        TRANSFER            |   1000.0  |
+        CASH                |   1000.0  |
+        TRANSFER            |           |   1000.0
+
+        :return: A list of Python dictionary to be passed to env['account.move'].create.
+        '''
+        all_move_vals = []
+        for payment in self:
+            company_currency = payment.company_id.currency_id
+
+            # Compute amounts.
+            write_off_amount = payment.payment_difference_handling == 'reconcile' and -payment.payment_difference or 0.0
+            if payment.payment_type in ('outbound', 'transfer'):
+                counterpart_amount = payment.amount
+                liquidity_line_account = payment.journal_id.default_debit_account_id
+            else:
+                counterpart_amount = -payment.amount
+                liquidity_line_account = payment.journal_id.default_credit_account_id
+
+            # Manage currency.
+            if payment.currency_id == company_currency:
+                # Single-currency.
+                balance = counterpart_amount
+                write_off_balance = write_off_amount
+                counterpart_amount = write_off_amount = 0.0
+                currency_id = False
+            else:
+                # Multi-currencies.
+                balance = payment.currency_id._convert(counterpart_amount, company_currency, payment.company_id, payment.payment_date)
+                write_off_balance = payment.currency_id._convert(write_off_amount, company_currency, payment.company_id, payment.payment_date)
+                currency_id = payment.currency_id.id
+
+            # Manage custom currency on journal for liquidity line.
+            if payment.journal_id.currency_id and payment.currency_id != payment.journal_id.currency_id:
+                # Custom currency on journal.
+                liquidity_line_currency_id = payment.journal_id.currency_id.id
+                liquidity_amount = company_currency._convert(
+                    balance, payment.journal_id.currency_id, payment.company_id, payment.payment_date)
+            else:
+                # Use the payment currency.
+                liquidity_line_currency_id = currency_id
+                liquidity_amount = counterpart_amount
+
+            # Compute 'name' to be used in receivable/payable line.
+            rec_pay_line_name = ''
+            if payment.payment_type == 'transfer':
+                rec_pay_line_name = payment.name
+            else:
+                if payment.partner_type == 'customer':
+                    if payment.payment_type == 'inbound':
+                        rec_pay_line_name += _("Customer Payment")
+                    elif payment.payment_type == 'outbound':
+                        rec_pay_line_name += _("Customer Credit Note")
+                elif payment.partner_type == 'supplier':
+                    if payment.payment_type == 'inbound':
+                        rec_pay_line_name += _("Vendor Credit Note")
+                    elif payment.payment_type == 'outbound':
+                        rec_pay_line_name += _("Vendor Payment")
+                if payment.invoice_ids:
+                    rec_pay_line_name += ': %s' % ', '.join(payment.invoice_ids.mapped('name'))
+
+            # Compute 'name' to be used in liquidity line.
+            if payment.payment_type == 'transfer':
+                liquidity_line_name = _('Transfer to %s') % payment.destination_journal_id.name
+            else:
+                liquidity_line_name = payment.name
+
+            # ==== 'inbound' / 'outbound' ====
+
+            move_vals = {
+                'date': payment.payment_date,
+                'ref': payment.communication,
+                'journal_id': payment.journal_id.id,
+                'currency_id': payment.journal_id.currency_id.id or payment.company_id.currency_id.id,
+                'partner_id': payment.partner_id.id,
+                'line_ids': [
+                    # Receivable / Payable / Transfer line.
+                    (0, 0, {
+                        'name': rec_pay_line_name,
+                        'amount_currency': counterpart_amount + write_off_amount,
+                        'currency_id': currency_id,
+                        'debit': balance + write_off_balance > 0.0 and balance + write_off_balance or 0.0,
+                        'credit': balance + write_off_balance < 0.0 and -balance - write_off_balance or 0.0,
+                        'date_maturity': payment.payment_date,
+                        'partner_id': payment.partner_id.id,
+                        'account_id': payment.destination_account_id.id,
+                        'payment_id': payment.id,
+                    }),
+                    # Liquidity line.
+                    (0, 0, {
+                        'name': liquidity_line_name,
+                        'amount_currency': -liquidity_amount,
+                        'currency_id': liquidity_line_currency_id,
+                        'debit': balance < 0.0 and -balance or 0.0,
+                        'credit': balance > 0.0 and balance or 0.0,
+                        'date_maturity': payment.payment_date,
+                        'partner_id': payment.partner_id.id,
+                        'account_id': liquidity_line_account.id,
+                        'payment_id': payment.id,
+                    }),
+                ],
+            }
+            if write_off_balance:
+                # Write-off line.
+                move_vals['line_ids'].append((0, 0, {
+                    'name': payment.writeoff_label,
+                    'amount_currency': -write_off_amount,
+                    'currency_id': currency_id,
+                    'debit': write_off_balance < 0.0 and -write_off_balance or 0.0,
+                    'credit': write_off_balance > 0.0 and write_off_balance or 0.0,
+                    'date_maturity': payment.payment_date,
+                    'partner_id': payment.partner_id.id,
+                    'account_id': payment.writeoff_account_id.id,
+                    'payment_id': payment.id,
+                }))
+
+            all_move_vals.append(move_vals)
+
+            # ==== 'transfer' ====
+            if payment.payment_type == 'transfer':
+
+                if payment.destination_journal_id.currency_id:
+                    transfer_amount = payment.currency_id._convert(counterpart_amount, payment.destination_journal_id.currency_id, payment.company_id, payment.payment_date)
+                else:
+                    transfer_amount = 0.0
+
+                transfer_move_vals = {
+                    'date': payment.payment_date,
+                    'ref': payment.communication,
+                    'partner_id': payment.partner_id.id,
+                    'journal_id': payment.destination_journal_id.id,
+                    'line_ids': [
+                        # Transfer debit line.
+                        (0, 0, {
+                            'name': payment.name,
+                            'amount_currency': -counterpart_amount,
+                            'currency_id': currency_id,
+                            'debit': balance < 0.0 and -balance or 0.0,
+                            'credit': balance > 0.0 and balance or 0.0,
+                            'date_maturity': payment.payment_date,
+                            'partner_id': payment.partner_id.id,
+                            'account_id': payment.company_id.transfer_account_id.id,
+                            'payment_id': payment.id,
+                        }),
+                        # Liquidity credit line.
+                        (0, 0, {
+                            'name': _('Transfer from %s') % payment.journal_id.name,
+                            'amount_currency': transfer_amount,
+                            'currency_id': payment.destination_journal_id.currency_id.id,
+                            'debit': balance > 0.0 and balance or 0.0,
+                            'credit': balance < 0.0 and -balance or 0.0,
+                            'date_maturity': payment.payment_date,
+                            'partner_id': payment.partner_id.id,
+                            'account_id': payment.destination_journal_id.default_credit_account_id.id,
+                            'payment_id': payment.id,
+                        }),
+                    ],
+                }
+
+                all_move_vals.append(transfer_move_vals)
+        return all_move_vals
+
     @api.multi
     def post(self):
         """ Create the journal items for the payment and update the payment's state to 'posted'.
@@ -465,12 +650,13 @@ class account_payment(models.Model):
             If invoice_ids is not empty, there will be one reconcilable move line per invoice to reconcile with.
             If the payment is a transfer, a second journal entry is created in the destination journal to receive money from the transfer account.
         """
+        AccountMove = self.env['account.move'].with_context(default_type='entry')
         for rec in self:
 
             if rec.state != 'draft':
                 raise UserError(_("Only a draft payment can be posted."))
 
-            if any(inv.state != 'open' for inv in rec.invoice_ids):
+            if any(inv.state != 'posted' for inv in rec.invoice_ids):
                 raise ValidationError(_("The payment cannot be processed because the invoice is not open!"))
 
             # keep the name in case of a payment reset to draft
@@ -489,187 +675,35 @@ class account_payment(models.Model):
                             sequence_code = 'account.payment.supplier.refund'
                         if rec.payment_type == 'outbound':
                             sequence_code = 'account.payment.supplier.invoice'
-                rec.name = self.env['ir.sequence'].with_context(ir_sequence_date=rec.payment_date).next_by_code(sequence_code)
+                rec.name = self.env['ir.sequence'].next_by_code(sequence_code, sequence_date=rec.payment_date)
                 if not rec.name and rec.payment_type != 'transfer':
                     raise UserError(_("You have to define a sequence for %s in your company.") % (sequence_code,))
 
-            # Create the journal entry
-            amount = rec.amount * (rec.payment_type in ('outbound', 'transfer') and 1 or -1)
-            move = rec._create_payment_entry(amount)
+            moves = AccountMove.create(rec._prepare_payment_moves())
+            moves.filtered(lambda move: not move.journal_id.post_at_bank_rec).post()
+
+            # Update the state / move before performing any reconciliation.
+            rec.write({'state': 'posted', 'move_name': moves[0].name})
 
-            # In case of a transfer, the first journal entry created debited the source liquidity account and credited
-            # the transfer account. Now we debit the transfer account and credit the destination liquidity account.
-            if rec.payment_type == 'transfer':
-                transfer_credit_aml = move.line_ids.filtered(lambda r: r.account_id == rec.company_id.transfer_account_id)
-                transfer_debit_aml = rec._create_transfer_entry(amount)
-                (transfer_credit_aml + transfer_debit_aml).reconcile()
+            if rec.payment_type in ('inbound', 'outbound'):
+                # ==== 'inbound' / 'outbound' ====
+                if rec.invoice_ids:
+                    (moves[0] + rec.invoice_ids).line_ids \
+                        .filtered(lambda line: not line.reconciled and line.account_id == rec.destination_account_id)\
+                        .reconcile()
+            elif rec.payment_type == 'transfer':
+                # ==== 'transfer' ====
+                moves.mapped('line_ids')\
+                    .filtered(lambda line: line.account_id == rec.company_id.transfer_account_id)\
+                    .reconcile()
 
-            rec.write({'state': 'posted', 'move_name': move.name})
         return True
 
     @api.multi
     def action_draft(self):
         return self.write({'state': 'draft'})
 
-    def _create_payment_entry(self, amount):
-        """ Create a journal entry corresponding to a payment, if the payment references invoice(s) they are reconciled.
-            Return the journal entry.
-        """
-        aml_obj = self.env['account.move.line'].with_context(check_move_validity=False)
-        debit, credit, amount_currency, currency_id = aml_obj.with_context(date=self.payment_date)._compute_amount_fields(amount, self.currency_id, self.company_id.currency_id)
-
-        move = self.env['account.move'].create(self._get_move_vals())
-
-        #Write line corresponding to invoice payment
-        counterpart_aml_dict = self._get_shared_move_line_vals(debit, credit, amount_currency, move.id, False)
-        counterpart_aml_dict.update(self._get_counterpart_move_line_vals(self.invoice_ids))
-        counterpart_aml_dict.update({'currency_id': currency_id})
-        counterpart_aml = aml_obj.create(counterpart_aml_dict)
-
-        #Reconcile with the invoices
-        if self.payment_difference_handling == 'reconcile' and self.payment_difference:
-            writeoff_line = self._get_shared_move_line_vals(0, 0, 0, move.id, False)
-            debit_wo, credit_wo, amount_currency_wo, currency_id = aml_obj.with_context(date=self.payment_date)._compute_amount_fields(self.payment_difference, self.currency_id, self.company_id.currency_id)
-            writeoff_line['name'] = self.writeoff_label
-            writeoff_line['account_id'] = self.writeoff_account_id.id
-            writeoff_line['debit'] = debit_wo
-            writeoff_line['credit'] = credit_wo
-            writeoff_line['amount_currency'] = amount_currency_wo
-            writeoff_line['currency_id'] = currency_id
-            writeoff_line = aml_obj.create(writeoff_line)
-            if counterpart_aml['debit'] or (writeoff_line['credit'] and not counterpart_aml['credit']):
-                counterpart_aml['debit'] += credit_wo - debit_wo
-            if counterpart_aml['credit'] or (writeoff_line['debit'] and not counterpart_aml['debit']):
-                counterpart_aml['credit'] += debit_wo - credit_wo
-            counterpart_aml['amount_currency'] -= amount_currency_wo
-
-        #Write counterpart lines
-        if not self.currency_id.is_zero(self.amount):
-            if not self.currency_id != self.company_id.currency_id:
-                amount_currency = 0
-            liquidity_aml_dict = self._get_shared_move_line_vals(credit, debit, -amount_currency, move.id, False)
-            liquidity_aml_dict.update(self._get_liquidity_move_line_vals(-amount))
-            aml_obj.create(liquidity_aml_dict)
-
-        #validate the payment
-        if not self.journal_id.post_at_bank_rec:
-            move.post()
-
-        #reconcile the invoice receivable/payable line(s) with the payment
-        if self.invoice_ids:
-            self.invoice_ids.register_payment(counterpart_aml)
-
-        return move
-
-    def _create_transfer_entry(self, amount):
-        """ Create the journal entry corresponding to the 'incoming money' part of an internal transfer, return the reconcilable move line
-        """
-        aml_obj = self.env['account.move.line'].with_context(check_move_validity=False)
-        debit, credit, amount_currency, dummy = aml_obj.with_context(date=self.payment_date)._compute_amount_fields(amount, self.currency_id, self.company_id.currency_id)
-        amount_currency = self.destination_journal_id.currency_id and self.currency_id._convert(amount, self.destination_journal_id.currency_id, self.company_id, self.payment_date or fields.Date.today()) or 0
-
-        dst_move = self.env['account.move'].create(self._get_move_vals(self.destination_journal_id))
-
-        dst_liquidity_aml_dict = self._get_shared_move_line_vals(debit, credit, amount_currency, dst_move.id)
-        dst_liquidity_aml_dict.update({
-            'name': _('Transfer from %s') % self.journal_id.name,
-            'account_id': self.destination_journal_id.default_credit_account_id.id,
-            'currency_id': self.destination_journal_id.currency_id.id,
-            'journal_id': self.destination_journal_id.id})
-        aml_obj.create(dst_liquidity_aml_dict)
-
-        transfer_debit_aml_dict = self._get_shared_move_line_vals(credit, debit, 0, dst_move.id)
-        transfer_debit_aml_dict.update({
-            'name': self.name,
-            'account_id': self.company_id.transfer_account_id.id,
-            'journal_id': self.destination_journal_id.id})
-        if self.currency_id != self.company_id.currency_id:
-            transfer_debit_aml_dict.update({
-                'currency_id': self.currency_id.id,
-                'amount_currency': -self.amount,
-            })
-        transfer_debit_aml = aml_obj.create(transfer_debit_aml_dict)
-        if not self.destination_journal_id.post_at_bank_rec:
-            dst_move.post()
-        return transfer_debit_aml
-
-    def _get_move_vals(self, journal=None):
-        """ Return dict to create the payment move
-        """
-        journal = journal or self.journal_id
-        move_vals = {
-            'date': self.payment_date,
-            'ref': self.communication or '',
-            'company_id': self.company_id.id,
-            'journal_id': journal.id,
-        }
-        if self.move_name:
-            move_vals['name'] = self.move_name
-        return move_vals
-
-    def _get_shared_move_line_vals(self, debit, credit, amount_currency, move_id, invoice_id=False):
-        """ Returns values common to both move lines (except for debit, credit and amount_currency which are reversed)
-        """
-        return {
-            'partner_id': self.payment_type in ('inbound', 'outbound') and self.env['res.partner']._find_accounting_partner(self.partner_id).id or False,
-            'invoice_id': invoice_id and invoice_id.id or False,
-            'move_id': move_id,
-            'debit': debit,
-            'credit': credit,
-            'amount_currency': amount_currency or False,
-            'payment_id': self.id,
-            'journal_id': self.journal_id.id,
-        }
-
-    def _get_counterpart_move_line_vals(self, invoice=False):
-        if self.payment_type == 'transfer':
-            name = self.name
-        else:
-            name = ''
-            if self.partner_type == 'customer':
-                if self.payment_type == 'inbound':
-                    name += _("Customer Payment")
-                elif self.payment_type == 'outbound':
-                    name += _("Customer Credit Note")
-            elif self.partner_type == 'supplier':
-                if self.payment_type == 'inbound':
-                    name += _("Vendor Credit Note")
-                elif self.payment_type == 'outbound':
-                    name += _("Vendor Payment")
-            if invoice:
-                name += ': '
-                for inv in invoice:
-                    if inv.move_id:
-                        name += inv.number + ', '
-                name = name[:len(name)-2]
-        return {
-            'name': name,
-            'account_id': self.destination_account_id.id,
-            'currency_id': self.currency_id != self.company_id.currency_id and self.currency_id.id or False,
-        }
-
-    def _get_liquidity_move_line_vals(self, amount):
-        name = self.name
-        if self.payment_type == 'transfer':
-            name = _('Transfer to %s') % self.destination_journal_id.name
-        vals = {
-            'name': name,
-            'account_id': self.payment_type in ('outbound', 'transfer') and self.journal_id.default_debit_account_id.id or self.journal_id.default_credit_account_id.id,
-            'journal_id': self.journal_id.id,
-            'currency_id': self.currency_id != self.company_id.currency_id and self.currency_id.id or False,
-        }
-
-        # If the journal has a currency specified, the journal item need to be expressed in this currency
-        if self.journal_id.currency_id and self.currency_id != self.journal_id.currency_id:
-            amount = self.currency_id._convert(amount, self.journal_id.currency_id, self.company_id, self.payment_date or fields.Date.today())
-            debit, credit, amount_currency, dummy = self.env['account.move.line'].with_context(date=self.payment_date)._compute_amount_fields(amount, self.journal_id.currency_id, self.company_id.currency_id)
-            vals.update({
-                'amount_currency': amount_currency,
-                'currency_id': self.journal_id.currency_id.id,
-            })
-
-        return vals
-
+    @api.multi
     def _get_invoice_payment_amount(self, inv):
         """
         Computes the amount covered by the current payment in the given invoice.
@@ -680,11 +714,10 @@ class account_payment(models.Model):
         self.ensure_one()
         return sum([
             data['amount']
-            for data in inv._get_payments_vals()
+            for data in inv._get_reconciled_info_JSON_values()
             if data['account_payment_id'] == self.id
         ])
 
-
 class payment_register(models.TransientModel):
     _name = 'account.payment.register'
     _description = 'Register Payment'
@@ -697,21 +730,20 @@ class payment_register(models.TransientModel):
                                         "Check: Pay bill by check and print it from Odoo.\n"
                                         "Batch Deposit: Encase several customer checks at once by generating a batch deposit to submit to your bank. When encoding the bank statement in Odoo, you are suggested to reconcile the transaction with the batch deposit.To enable batch deposit, module account_batch_payment must be installed.\n"
                                         "SEPA Credit Transfer: Pay bill from a SEPA Credit Transfer file you submit to your bank. To enable sepa credit transfer, module account_sepa must be installed ")
-    invoice_ids = fields.Many2many('account.invoice', 'account_invoice_payment_rel_transient', 'payment_id', 'invoice_id', string="Invoices", copy=False, readonly=True)
+    invoice_ids = fields.Many2many('account.move', 'account_invoice_payment_rel_transient', 'payment_id', 'invoice_id', string="Invoices", copy=False, readonly=True)
 
     @api.model
     def default_get(self, fields):
         rec = super(payment_register, self).default_get(fields)
         active_ids = self._context.get('active_ids')
-        active_model = self._context.get('active_model')
-        invoices = self.env['account.invoice'].browse(active_ids)
+        invoices = self.env['account.move'].browse(active_ids)
 
         # Check all invoices are open
-        if any(invoice.state != 'open' for invoice in invoices):
+        if any(invoice.state != 'posted' or invoice.invoice_payment_state != 'not_paid' or not invoice.is_invoice() for invoice in invoices):
             raise UserError(_("You can only register payments for open invoices"))
         # Check all invoices are inbound or all invoices are outbound
-        outbound_list = [invoice.type in ('in_invoice', 'out_refund') for invoice in invoices]
-        first_outbound = invoices[0].type in ('in_invoice', 'out_refund')
+        outbound_list = [invoice.is_outbound() for invoice in invoices]
+        first_outbound = invoices[0].is_outbound()
         if any(x != first_outbound for x in outbound_list):
             raise UserError(_("You can only register at the same time for payment that are all inbound or all outbound"))
         if 'invoice_ids' not in rec:
@@ -719,7 +751,7 @@ class payment_register(models.TransientModel):
         if 'journal_id' not in rec:
             rec['journal_id'] = self.env['account.journal'].search([('company_id', '=', self.env.company.id), ('type', 'in', ('bank', 'cash'))], limit=1).id
         if 'payment_method_id' not in rec:
-            if invoices[0].type in ('out_invoice', 'in_refund'):
+            if invoices[0].is_inbound():
                 domain = [('payment_type', '=', 'inbound')]
             else:
                 domain = [('payment_type', '=', 'outbound')]
@@ -729,9 +761,9 @@ class payment_register(models.TransientModel):
     @api.onchange('journal_id', 'invoice_ids')
     def _onchange_journal(self):
         active_ids = self._context.get('active_ids')
-        invoices = self.env['account.invoice'].browse(active_ids)
+        invoices = self.env['account.move'].browse(active_ids)
         if self.journal_id and invoices:
-            if invoices[0].type in ('out_invoice', 'in_refund'):
+            if invoices[0].is_inbound():
                 domain = [('payment_type', '=', 'inbound'), ('id', 'in', self.journal_id.inbound_payment_method_ids.ids)]
             else:
                 domain = [('payment_type', '=', 'outbound'), ('id', 'in', self.journal_id.outbound_payment_method_ids.ids)]
@@ -746,19 +778,19 @@ class payment_register(models.TransientModel):
         :param invoice: A single invoice/bill to pay.
         :return: The payment values as a dictionary.
         '''
-        amount = self.env['account.payment']._compute_payment_amount(invoices=invoice, currency=invoice.currency_id)
+        amount = self.env['account.payment']._compute_payment_amount(invoice, invoice.currency_id, self.journal_id, self.payment_date)
         values = {
             'journal_id': self.journal_id.id,
             'payment_method_id': self.payment_method_id.id,
             'payment_date': self.payment_date,
-            'communication': invoice.reference or invoice.number,
+            'communication': invoice.ref or invoice.name,
             'invoice_ids': [(6, 0, invoice.ids)],
             'payment_type': ('inbound' if amount > 0 else 'outbound'),
             'amount': abs(amount),
             'currency_id': invoice.currency_id.id,
             'partner_id': invoice.commercial_partner_id.id,
             'partner_type': MAP_INVOICE_TYPE_PARTNER_TYPE[invoice.type],
-            'partner_bank_account_id': invoice.partner_bank_id.id,
+            'partner_bank_account_id': invoice.invoice_partner_bank_id.id,
         }
         return values
 

--- a/addons/account/models/account_payment_term.py
+++ b/addons/account/models/account_payment_term.py
@@ -33,15 +33,15 @@ class AccountPaymentTerm(models.Model):
                 raise ValidationError(_('A Payment Term should have only one line of type Balance.'))
 
     @api.multi
-    def compute(self, value, date_ref=False):
+    def compute(self, value, date_ref=False, currency=None):
         self.ensure_one()
         date_ref = date_ref or fields.Date.today()
         amount = value
         sign = value < 0 and -1 or 1
         result = []
-        if self.env.context.get('currency_id'):
+        if not currency and self.env.context.get('currency_id'):
             currency = self.env['res.currency'].browse(self.env.context['currency_id'])
-        else:
+        elif not currency:
             currency = self.env.company.currency_id
         for line in self.line_ids:
             if line.value == 'fixed':
@@ -50,19 +50,18 @@ class AccountPaymentTerm(models.Model):
                 amt = currency.round(value * (line.value_amount / 100.0))
             elif line.value == 'balance':
                 amt = currency.round(amount)
-            if amt:
-                next_date = fields.Date.from_string(date_ref)
-                if line.option == 'day_after_invoice_date':
-                    next_date += relativedelta(days=line.days)
-                    if line.day_of_the_month > 0:
-                        months_delta = (line.day_of_the_month < next_date.day) and 1 or 0
-                        next_date += relativedelta(day=line.day_of_the_month, months=months_delta)
-                elif line.option == 'day_following_month':
-                    next_date += relativedelta(day=line.days, months=1)
-                elif line.option == 'day_current_month':
-                    next_date += relativedelta(day=line.days, months=0)
-                result.append((fields.Date.to_string(next_date), amt))
-                amount -= amt
+            next_date = fields.Date.from_string(date_ref)
+            if line.option == 'day_after_invoice_date':
+                next_date += relativedelta(days=line.days)
+                if line.day_of_the_month > 0:
+                    months_delta = (line.day_of_the_month < next_date.day) and 1 or 0
+                    next_date += relativedelta(day=line.day_of_the_month, months=months_delta)
+            elif line.option == 'day_following_month':
+                next_date += relativedelta(day=line.days, months=1)
+            elif line.option == 'day_current_month':
+                next_date += relativedelta(day=line.days, months=0)
+            result.append((fields.Date.to_string(next_date), amt))
+            amount -= amt
         amount = sum(amt for _, amt in result)
         dist = currency.round(value - amount)
         if dist:
@@ -73,7 +72,7 @@ class AccountPaymentTerm(models.Model):
     @api.multi
     def unlink(self):
         for terms in self:
-            if self.env['account.invoice'].search([('payment_term_id', 'in', terms.ids)]):
+            if self.env['account.move'].search([('payment_term_id', 'in', terms.ids)]):
                 raise UserError(_('You can not delete payment terms as other records still reference it. However, you can archive it.'))
             property_recs = self.env['ir.property'].search([('value_reference', 'in', ['account.payment.term,%s'%payment_term.id for payment_term in terms])])
             property_recs.unlink()

--- a/addons/account/models/account_reconcile_model.py
+++ b/addons/account/models/account_reconcile_model.py
@@ -102,18 +102,25 @@ class AccountReconcileModel(models.Model):
     second_analytic_account_id = fields.Many2one('account.analytic.account', string='Second Analytic Account', ondelete='set null')
     second_analytic_tag_ids = fields.Many2many('account.analytic.tag', string='Second Analytic Tags',
                                                relation='account_reconcile_model_second_analytic_tag_rel')
-    
+
     number_entries = fields.Integer(string='Number of entries related to this model', compute='_compute_number_entries')
 
     @api.multi
     def action_reconcile_stat(self):
+        self.ensure_one()
         action = self.env.ref('account.action_move_journal_line').read()[0]
+        self._cr.execute('''
+            SELECT ARRAY_AGG(DISTINCT move_id)
+            FROM account_move_line
+            WHERE reconcile_model_id = %s
+        ''', [self.id])
         action.update({
-            'context': {'search_default_reconcile_model_id': self.name},
+            'context': {},
+            'domain': [('id', 'in', self._cr.fetchone()[0])],
             'help': """<p class="o_view_nocontent_empty_folder">{}</p>""".format(_('No move from this reconciliation model')),
         })
         return action
-        
+
     @api.multi
     def _compute_number_entries(self):
         data = self.env['account.move.line'].read_group([('reconcile_model_id', 'in', self.ids)], ['reconcile_model_ids'], 'reconcile_model_id')
@@ -438,10 +445,11 @@ class AccountReconcileModel(models.Model):
             LEFT JOIN res_company company           ON company.id = st_line.company_id
             LEFT JOIN partners_table line_partner   ON line_partner.line_id = st_line.id
             , account_move_line aml
-            LEFT JOIN account_move move             ON move.id = aml.move_id
+            LEFT JOIN account_move move             ON move.id = aml.move_id AND move.state = 'posted'
             LEFT JOIN account_account account       ON account.id = aml.account_id
             WHERE st_line.id IN %s
                 AND aml.company_id = st_line.company_id
+                AND move.state = 'posted'
                 AND (
                         -- the field match_partner of the rule might enforce the second part of
                         -- the OR condition, later in _apply_conditions()
@@ -456,7 +464,7 @@ class AccountReconcileModel(models.Model):
 
                 -- if there is a partner, propose all aml of the partner, otherwise propose only the ones
                 -- matching the statement line communication
-                AND 
+                AND
                 (
                     (
                         line_partner.partner_id != 0

--- a/addons/account/models/chart_template.py
+++ b/addons/account/models/chart_template.py
@@ -264,7 +264,7 @@ class AccountChartTemplate(models.Model):
         the provided company (meaning hence that its chart of accounts cannot
         be changed anymore).
         """
-        model_to_check = ['account.move.line', 'account.invoice', 'account.payment', 'account.bank.statement']
+        model_to_check = ['account.move', 'account.payment', 'account.bank.statement']
         for model in model_to_check:
             if len(self.env[model].search([('company_id', '=', company_id.id)])) > 0:
                 return True

--- a/addons/account/models/company.py
+++ b/addons/account/models/company.py
@@ -2,7 +2,6 @@
 
 from datetime import timedelta, datetime
 import calendar
-import time
 from dateutil.relativedelta import relativedelta
 
 from odoo import fields, models, api, _
@@ -10,6 +9,7 @@ from odoo.exceptions import ValidationError, UserError, RedirectWarning
 from odoo.tools.misc import DEFAULT_SERVER_DATE_FORMAT
 from odoo.tools.float_utils import float_round, float_is_zero
 from odoo.tools import date_utils
+from odoo.tests.common import Form
 
 
 MONTH_SELECTION = [
@@ -102,7 +102,7 @@ Best Regards,'''))
     account_dashboard_onboarding_state = fields.Selection([('not_done', "Not done"), ('just_done', "Just done"), ('done', "Done"), ('closed', "Closed")], string="State of the account dashboard onboarding panel", default='not_done')
     invoice_terms = fields.Text(string='Default Terms and Conditions', translate=True)
 
-    @api.constrains('account_opening_date', 'fiscalyear_last_day', 'fiscalyear_last_month')
+    @api.constrains('account_opening_move_id', 'fiscalyear_last_day', 'fiscalyear_last_month')
     def _check_fiscalyear_last_day(self):
         # if the user explicitly chooses the 29th of February we allow it:
         # there is no "fiscalyear_last_year" so we do not know his intentions.
@@ -484,7 +484,7 @@ Best Regards,'''))
 
         company_id = self.env.company.id
         # try to find an existing sample invoice
-        sample_invoice = self.env['account.invoice'].search(
+        sample_invoice = self.env['account.move'].search(
             [('company_id', '=', company_id),
              ('partner_id', '=', partner.id)], limit=1)
 
@@ -499,25 +499,23 @@ Best Regards,'''))
                         "\nPlease go to Configuration > Journals.")
                 raise RedirectWarning(msg, action.id, _("Go to the journal configuration"))
 
-            sample_invoice = self.env['account.invoice'].create({
-                'name': _("Sample invoice"),
-                'journal_id': journal.id,
+            sample_invoice = self.env['account.move'].with_context(default_type='out_invoice', default_journal_id=journal.id).create({
+                'invoice_payment_ref': _('Sample invoice'),
                 'partner_id': partner.id,
-            })
-            # sample invoice lines
-            self.env['account.invoice.line'].create({
-                'name': _("Sample invoice line name"),
-                'invoice_id': sample_invoice.id,
-                'account_id': account.id,
-                'price_unit': 199.99,
-                'quantity': 2,
-            })
-            self.env['account.invoice.line'].create({
-                'name': _("Sample invoice line name 2"),
-                'invoice_id': sample_invoice.id,
-                'account_id': account.id,
-                'price_unit': 25,
-                'quantity': 1,
+                'invoice_line_ids': [
+                    (0, 0, {
+                        'name': _('Sample invoice line name'),
+                        'account_id': account.id,
+                        'quantity': 2,
+                        'price_unit': 199.99,
+                    }),
+                    (0, 0, {
+                        'name': _('Sample invoice line name 2'),
+                        'account_id': account.id,
+                        'quantity': 1,
+                        'price_unit': 25.0,
+                    }),
+                ],
             })
         return sample_invoice
 
@@ -532,7 +530,7 @@ Best Regards,'''))
             'default_res_id': sample_invoice.id,
             'default_use_template': bool(template),
             'default_template_id': template and template.id or False,
-            'default_model': 'account.invoice',
+            'default_model': 'account.move',
             'default_composition_mode': 'comment',
             'mark_invoice_as_sent': True,
             'custom_layout': 'mail.mail_notification_borders',

--- a/addons/account/models/digest.py
+++ b/addons/account/models/digest.py
@@ -16,14 +16,18 @@ class Digest(models.Model):
             raise AccessError(_("Do not have access, skip this data for user's digest email"))
         for record in self:
             start, end, company = record._get_kpi_compute_parameters()
-            account_moves = self.env['account.move'].read_group([
-                ('journal_id.type', '=', 'sale'),
-                ('company_id', '=', company.id),
-                ('date', '>=', start),
-                ('date', '<', end)], ['journal_id', 'amount'], ['journal_id'])
-            record.kpi_account_total_revenue_value = sum([account_move['amount'] for account_move in account_moves])
+            self._cr.execute('''
+                SELECT SUM(line.debit)
+                FROM account_move_line line
+                JOIN account_move move ON move.id = line.move_id
+                JOIN account_journal journal ON journal.id = move.journal_id
+                WHERE line.company_id = %s AND line.date >= %s AND line.date < %s
+                AND journal.type = 'sale'
+            ''', [company.id, start, end])
+            query_res = self._cr.fetchone()
+            record.kpi_account_total_revenue_value = query_res and query_res[0] or 0.0
 
     def compute_kpis_actions(self, company, user):
         res = super(Digest, self).compute_kpis_actions(company, user)
-        res['kpi_account_total_revenue'] = 'account.action_invoice_tree1&menu_id=%s' % self.env.ref('account.menu_finance').id
+        res['kpi_account_total_revenue'] = 'account.action_move_out_invoice_type&menu_id=%s' % self.env.ref('account.menu_finance').id
         return res

--- a/addons/account/models/partner.py
+++ b/addons/account/models/partner.py
@@ -209,7 +209,7 @@ class ResPartner(models.Model):
         if where_clause:
             where_clause = 'AND ' + where_clause
         self._cr.execute("""SELECT account_move_line.partner_id, act.type, SUM(account_move_line.amount_residual)
-                      FROM account_move_line
+                      FROM """ + tables + """
                       LEFT JOIN account_account a ON (account_move_line.account_id=a.id)
                       LEFT JOIN account_account_type act ON (a.user_type_id=act.id)
                       WHERE act.type IN ('receivable','payable')
@@ -286,7 +286,7 @@ class ResPartner(models.Model):
 
         # price_total is in the company currency
         query = """
-                  SELECT SUM(price_total) as total, partner_id
+                  SELECT SUM(price_subtotal) as total, partner_id
                     FROM account_invoice_report account_invoice_report
                    WHERE %s
                    GROUP BY partner_id
@@ -410,7 +410,7 @@ class ResPartner(models.Model):
         help='Last time the invoices & payments matching was performed for this partner. '
              'It is set either if there\'s not at least an unreconciled debit and an unreconciled credit '
              'or if you click the "Done" button.')
-    invoice_ids = fields.One2many('account.invoice', 'partner_id', string='Invoices', readonly=True, copy=False)
+    invoice_ids = fields.One2many('account.move', 'partner_id', string='Invoices', readonly=True, copy=False)
     contract_ids = fields.One2many('account.analytic.account', 'partner_id', string='Partner Contracts', readonly=True)
     bank_account_count = fields.Integer(compute='_compute_bank_count', string="Bank")
     trust = fields.Selection([('good', 'Good Debtor'), ('normal', 'Normal Debtor'), ('bad', 'Bad Debtor')], string='Degree of trust you have in this debtor', default='normal', company_dependent=True)
@@ -437,14 +437,16 @@ class ResPartner(models.Model):
     @api.multi
     def action_view_partner_invoices(self):
         self.ensure_one()
-        action = self.env.ref('account.action_invoice_refund_out_tree').read()[0]
-        action['domain'] = literal_eval(action['domain'])
-        action['domain'].append(('partner_id', 'child_of', self.id))
+        action = self.env.ref('account.action_move_out_invoice_type').read()[0]
+        action['domain'] = [
+            ('type', 'in', ('out_invoice', 'out_refund')),
+            ('type', '=', 'posted'),
+            ('partner_id', 'child_of', self.id),
+        ]
         return action
 
     @api.onchange('company_id')
     def _onchange_company_id(self):
-        company = self.env['res.company']
         if self.company_id:
             company = self.company_id
         else:
@@ -455,10 +457,9 @@ class ResPartner(models.Model):
         can_edit_vat = super(ResPartner, self).can_edit_vat()
         if not can_edit_vat:
             return can_edit_vat
-        Invoice = self.env['account.invoice']
-        has_invoice = Invoice.search([
+        has_invoice = self.env['account.move'].search([
             ('type', 'in', ['out_invoice', 'out_refund']),
             ('partner_id', 'child_of', self.commercial_partner_id.id),
-            ('state', 'not in', ['draft', 'cancel'])
+            ('state', '=', 'posted')
         ], limit=1)
         return can_edit_vat and not (bool(has_invoice))

--- a/addons/account/models/product.py
+++ b/addons/account/models/product.py
@@ -55,31 +55,3 @@ class ProductTemplate(models.Model):
         if not fiscal_pos:
             fiscal_pos = self.env['account.fiscal.position']
         return fiscal_pos.map_accounts(accounts)
-
-class ProductProduct(models.Model):
-    _inherit = "product.product"
-
-    @api.model
-    def _convert_prepared_anglosaxon_line(self, line, partner):
-        return {
-            'date_maturity': line.get('date_maturity', False),
-            'partner_id': partner,
-            'name': line['name'],
-            'debit': line['price'] > 0 and line['price'],
-            'credit': line['price'] < 0 and -line['price'],
-            'account_id': line['account_id'],
-            'analytic_line_ids': line.get('analytic_line_ids', []),
-            'amount_currency': line['price'] > 0 and abs(line.get('amount_currency', False)) or -abs(line.get('amount_currency', False)),
-            'currency_id': line.get('currency_id', False),
-            'quantity': line.get('quantity', 1.00),
-            'product_id': line.get('product_id', False),
-            'product_uom_id': line.get('uom_id', False),
-            'analytic_account_id': line.get('account_analytic_id', False),
-            'invoice_id': line.get('invoice_id', False),
-            'tax_ids': line.get('tax_ids', False),
-            'tax_line_id': line.get('tax_line_id', False),
-            'analytic_tag_ids': line.get('analytic_tag_ids', False),
-            'tax_repartition_line_id': line.get('tax_repartition_line_id'),
-            'tag_ids': line.get('tag_ids'),
-            'tax_base_amount': line.get('tax_base_amount'),
-        }

--- a/addons/account/models/reconciliation_widget.py
+++ b/addons/account/models/reconciliation_widget.py
@@ -200,7 +200,7 @@ class AccountReconciliation(models.AbstractModel):
         """
         if not bank_statement_line_ids:
             return {}
-        edition_mode = self._context.get('edition_mode')
+        suspense_moves_mode = self._context.get('suspense_moves_mode')
         bank_statements = self.env['account.bank.statement.line'].browse(bank_statement_line_ids).mapped('statement_id')
 
         search_sql = '''
@@ -220,7 +220,7 @@ class AccountReconciliation(models.AbstractModel):
              {srch}
              GROUP BY line.id
         '''.format(
-            cond=not edition_mode and "AND NOT EXISTS (SELECT 1 from account_move_line aml WHERE aml.statement_line_id = line.id)" or "",
+            cond=not suspense_moves_mode and "AND NOT EXISTS (SELECT 1 from account_move_line aml WHERE aml.statement_line_id = line.id)" or "",
             srch=search_str and search_sql or "",
         )
         self.env.cr.execute(query, {'ids':tuple(bank_statement_line_ids), 'search_str':search_str})
@@ -503,7 +503,7 @@ class AccountReconciliation(models.AbstractModel):
         AccountMoveLine = self.env['account.move.line']
 
         #Always exclude the journal items that have been marked as 'to be checked' in a former bank statement reconciliation
-        to_check_excluded = AccountMoveLine.search(AccountMoveLine._get_domain_for_edition_mode()).ids
+        to_check_excluded = AccountMoveLine.search(AccountMoveLine._get_suspense_moves_domain()).ids
         excluded_ids.extend(to_check_excluded)
 
         domain_reconciliation = [
