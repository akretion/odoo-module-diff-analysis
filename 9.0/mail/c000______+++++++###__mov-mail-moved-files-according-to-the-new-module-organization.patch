PR: https://github.com/odoo/odoo/pull/

From: 4a975f1b7d719ebbf17e0d4194cf3fcc56e2f56f
From: Thibault DelavallÃ©e
Date: 2015-04-27 10:52:45

Structural Changes: 130
Total Changes: 5484

[MOV] mail: moved files according to the new module organization

================================= pseudo patch: =================================

--- a/None
+++ b/addons/mail/models/__init__.py
@@ -0,0 +1,18 @@
+# -*- coding: utf-8 -*-
+
+import ir_attachment
+import mail_message_subtype
+import mail_alias
+import mail_followers
+import mail_message
+import mail_mail
+import mail_thread
+import mail_group
+import mail_template
+import res_partner
+import res_users
+import res_config
+import ir_ui_menu
+import update
+import ir_actions
+import html2text
\ No newline at end of file

--- a/None
+++ b/addons/mail/models/html2text.py
@@ -0,0 +1,456 @@
+#!/usr/bin/env python
+"""html2text: Turn HTML into equivalent Markdown-structured text."""
+__version__ = "2.36"
+__author__ = "Aaron Swartz (me@aaronsw.com)"
+__copyright__ = "(C) 2004-2008 Aaron Swartz. GNU GPL 3."
+__contributors__ = ["Martin 'Joey' Schulze", "Ricardo Reyes", "Kevin Jay North"]
+
+# TODO:
+#   Support decoded entities with unifiable.
+
+if not hasattr(__builtins__, 'True'): True, False = 1, 0
+import re, sys, urllib, htmlentitydefs, codecs
+import sgmllib
+import urlparse
+sgmllib.charref = re.compile('&#([xX]?[0-9a-fA-F]+)[^0-9a-fA-F]')
+
+try: from textwrap import wrap
+except: pass
+
+# Use Unicode characters instead of their ascii psuedo-replacements
+UNICODE_SNOB = 0
+
+# Put the links after each paragraph instead of at the end.
+LINKS_EACH_PARAGRAPH = 0
+
+# Wrap long lines at position. 0 for no wrapping. (Requires Python 2.3.)
+BODY_WIDTH = 78
+
+# Don't show internal links (href="#local-anchor") -- corresponding link targets
+# won't be visible in the plain text file anyway.
+SKIP_INTERNAL_LINKS = False
+
+### Entity Nonsense ###
+
+def name2cp(k):
+    if k == 'apos': return ord("'")
+    if hasattr(htmlentitydefs, "name2codepoint"): # requires Python 2.3
+        return htmlentitydefs.name2codepoint[k]
+    else:
+        k = htmlentitydefs.entitydefs[k]
+        if k.startswith("&#") and k.endswith(";"): return int(k[2:-1]) # not in latin-1
+        return ord(codecs.latin_1_decode(k)[0])
+
+unifiable = {'rsquo':"'", 'lsquo':"'", 'rdquo':'"', 'ldquo':'"',
+'copy':'(C)', 'mdash':'--', 'nbsp':' ', 'rarr':'->', 'larr':'<-', 'middot':'*',
+'ndash':'-', 'oelig':'oe', 'aelig':'ae',
+'agrave':'a', 'aacute':'a', 'acirc':'a', 'atilde':'a', 'auml':'a', 'aring':'a',
+'egrave':'e', 'eacute':'e', 'ecirc':'e', 'euml':'e',
+'igrave':'i', 'iacute':'i', 'icirc':'i', 'iuml':'i',
+'ograve':'o', 'oacute':'o', 'ocirc':'o', 'otilde':'o', 'ouml':'o',
+'ugrave':'u', 'uacute':'u', 'ucirc':'u', 'uuml':'u'}
+
+unifiable_n = {}
+
+for k in unifiable.keys():
+    unifiable_n[name2cp(k)] = unifiable[k]
+
+def charref(name):
+    if name[0] in ['x','X']:
+        c = int(name[1:], 16)
+    else:
+        c = int(name)
+
+    if not UNICODE_SNOB and c in unifiable_n.keys():
+        return unifiable_n[c]
+    else:
+        return unichr(c)
+
+def entityref(c):
+    if not UNICODE_SNOB and c in unifiable.keys():
+        return unifiable[c]
+    else:
+        try: name2cp(c)
+        except KeyError: return "&" + c
+        else: return unichr(name2cp(c))
+
+def replaceEntities(s):
+    s = s.group(1)
+    if s[0] == "#":
+        return charref(s[1:])
+    else: return entityref(s)
+
+r_unescape = re.compile(r"&(#?[xX]?(?:[0-9a-fA-F]+|\w{1,8}));")
+def unescape(s):
+    return r_unescape.sub(replaceEntities, s)
+
+def fixattrs(attrs):
+    # Fix bug in sgmllib.py
+    if not attrs: return attrs
+    newattrs = []
+    for attr in attrs:
+        newattrs.append((attr[0], unescape(attr[1])))
+    return newattrs
+
+### End Entity Nonsense ###
+
+def onlywhite(line):
+    """Return true if the line does only consist of whitespace characters."""
+    for c in line:
+        if c is not ' ' and c is not '  ':
+            return c is ' '
+    return line
+
+def optwrap(text):
+    """Wrap all paragraphs in the provided text."""
+    if not BODY_WIDTH:
+        return text
+
+    assert wrap, "Requires Python 2.3."
+    result = ''
+    newlines = 0
+    for para in text.split("\n"):
+        if len(para) > 0:
+            if para[0] is not ' ' and para[0] is not '-' and para[0] is not '*':
+                for line in wrap(para, BODY_WIDTH):
+                    result += line + "\n"
+                result += "\n"
+                newlines = 2
+            else:
+                if not onlywhite(para):
+                    result += para + "\n"
+                    newlines = 1
+        else:
+            if newlines < 2:
+                result += "\n"
+                newlines += 1
+    return result
+
+def hn(tag):
+    if tag[0] == 'h' and len(tag) == 2:
+        try:
+            n = int(tag[1])
+            if n in range(1, 10): return n
+        except ValueError: return 0
+
+class _html2text(sgmllib.SGMLParser):
+    def __init__(self, out=sys.stdout.write, baseurl=''):
+        sgmllib.SGMLParser.__init__(self)
+
+        if out is None: self.out = self.outtextf
+        else: self.out = out
+        self.outtext = u''
+        self.quiet = 0
+        self.p_p = 0
+        self.outcount = 0
+        self.start = 1
+        self.space = 0
+        self.a = []
+        self.astack = []
+        self.acount = 0
+        self.list = []
+        self.blockquote = 0
+        self.pre = 0
+        self.startpre = 0
+        self.lastWasNL = 0
+        self.abbr_title = None # current abbreviation definition
+        self.abbr_data = None # last inner HTML (for abbr being defined)
+        self.abbr_list = {} # stack of abbreviations to write later
+        self.baseurl = baseurl
+
+    def outtextf(self, s):
+        self.outtext += s
+
+    def close(self):
+        sgmllib.SGMLParser.close(self)
+
+        self.pbr()
+        self.o('', 0, 'end')
+
+        return self.outtext
+
+    def handle_charref(self, c):
+        self.o(charref(c))
+
+    def handle_entityref(self, c):
+        self.o(entityref(c))
+
+    def unknown_starttag(self, tag, attrs):
+        self.handle_tag(tag, attrs, 1)
+
+    def unknown_endtag(self, tag):
+        self.handle_tag(tag, None, 0)
+
+    def previousIndex(self, attrs):
+        """ returns the index of certain set of attributes (of a link) in the
+            self.a list
+
+            If the set of attributes is not found, returns None
+        """
+        if not attrs.has_key('href'): return None
+
+        i = -1
+        for a in self.a:
+            i += 1
+            match = 0
+
+            if a.has_key('href') and a['href'] == attrs['href']:
+                if a.has_key('title') or attrs.has_key('title'):
+                        if (a.has_key('title') and attrs.has_key('title') and
+                            a['title'] == attrs['title']):
+                            match = True
+                else:
+                    match = True
+
+            if match: return i
+
+    def handle_tag(self, tag, attrs, start):
+        attrs = fixattrs(attrs)
+
+        if hn(tag):
+            self.p()
+            if start: self.o(hn(tag)*"#" + ' ')
+
+        if tag in ['p', 'div']: self.p()
+
+        if tag == "br" and start: self.o("  \n")
+
+        if tag == "hr" and start:
+            self.p()
+            self.o("* * *")
+            self.p()
+
+        if tag in ["head", "style", 'script']:
+            if start: self.quiet += 1
+            else: self.quiet -= 1
+
+        if tag in ["body"]:
+            self.quiet = 0 # sites like 9rules.com never close <head>
+
+        if tag == "blockquote":
+            if start:
+                self.p(); self.o('> ', 0, 1); self.start = 1
+                self.blockquote += 1
+            else:
+                self.blockquote -= 1
+                self.p()
+
+        if tag in ['em', 'i', 'u']: self.o("_")
+        if tag in ['strong', 'b']: self.o("**")
+        if tag == "code" and not self.pre: self.o('`') #TODO: `` `this` ``
+        if tag == "abbr":
+            if start:
+                attrsD = {}
+                for (x, y) in attrs: attrsD[x] = y
+                attrs = attrsD
+
+                self.abbr_title = None
+                self.abbr_data = ''
+                if attrs.has_key('title'):
+                    self.abbr_title = attrs['title']
+            else:
+                if self.abbr_title != None:
+                    self.abbr_list[self.abbr_data] = self.abbr_title
+                    self.abbr_title = None
+                self.abbr_data = ''
+
+        if tag == "a":
+            if start:
+                attrsD = {}
+                for (x, y) in attrs: attrsD[x] = y
+                attrs = attrsD
+                if attrs.has_key('href') and not (SKIP_INTERNAL_LINKS and attrs['href'].startswith('#')):
+                    self.astack.append(attrs)
+                    self.o("[")
+                else:
+                    self.astack.append(None)
+            else:
+                if self.astack:
+                    a = self.astack.pop()
+                    if a:
+                        i = self.previousIndex(a)
+                        if i is not None:
+                            a = self.a[i]
+                        else:
+                            self.acount += 1
+                            a['count'] = self.acount
+                            a['outcount'] = self.outcount
+                            self.a.append(a)
+                        self.o("][" + `a['count']` + "]")
+
+        if tag == "img" and start:
+            attrsD = {}
+            for (x, y) in attrs: attrsD[x] = y
+            attrs = attrsD
+            if attrs.has_key('src'):
+                attrs['href'] = attrs['src']
+                alt = attrs.get('alt', '')
+                i = self.previousIndex(attrs)
+                if i is not None:
+                    attrs = self.a[i]
+                else:
+                    self.acount += 1
+                    attrs['count'] = self.acount
+                    attrs['outcount'] = self.outcount
+                    self.a.append(attrs)
+                self.o("![")
+                self.o(alt)
+                self.o("]["+`attrs['count']`+"]")
+
+        if tag == 'dl' and start: self.p()
+        if tag == 'dt' and not start: self.pbr()
+        if tag == 'dd' and start: self.o('    ')
+        if tag == 'dd' and not start: self.pbr()
+
+        if tag in ["ol", "ul"]:
+            if start:
+                self.list.append({'name':tag, 'num':0})
+            else:
+                if self.list: self.list.pop()
+
+            self.p()
+
+        if tag == 'li':
+            if start:
+                self.pbr()
+                if self.list: li = self.list[-1]
+                else: li = {'name':'ul', 'num':0}
+                self.o("  "*len(self.list)) #TODO: line up <ol><li>s > 9 correctly.
+                if li['name'] == "ul": self.o("* ")
+                elif li['name'] == "ol":
+                    li['num'] += 1
+                    self.o(`li['num']`+". ")
+                self.start = 1
+            else:
+                self.pbr()
+
+        if tag in ["table", "tr"] and start: self.p()
+        if tag == 'td': self.pbr()
+
+        if tag == "pre":
+            if start:
+                self.startpre = 1
+                self.pre = 1
+            else:
+                self.pre = 0
+            self.p()
+
+    def pbr(self):
+        if self.p_p == 0: self.p_p = 1
+
+    def p(self):
+        self.p_p = 2
+
+    def o(self, data, puredata=0, force=0):
+        if self.abbr_data is not None: self.abbr_data += data
+
+        if not self.quiet:
+            if puredata and not self.pre:
+                data = re.sub('\s+', ' ', data)
+                if data and data[0] == ' ':
+                    self.space = 1
+                    data = data[1:]
+            if not data and not force: return
+
+            if self.startpre:
+                #self.out(" :") #TODO: not output when already one there
+                self.startpre = 0
+
+            bq = (">" * self.blockquote)
+            if not (force and data and data[0] == ">") and self.blockquote: bq += " "
+
+            if self.pre:
+                bq += "    "
+                data = data.replace("\n", "\n"+bq)
+
+            if self.start:
+                self.space = 0
+                self.p_p = 0
+                self.start = 0
+
+            if force == 'end':
+                # It's the end.
+                self.p_p = 0
+                self.out("\n")
+                self.space = 0
+
+
+            if self.p_p:
+                self.out(('\n'+bq)*self.p_p)
+                self.space = 0
+
+            if self.space:
+                if not self.lastWasNL: self.out(' ')
+                self.space = 0
+
+            if self.a and ((self.p_p == 2 and LINKS_EACH_PARAGRAPH) or force == "end"):
+                if force == "end": self.out("\n")
+
+                newa = []
+                for link in self.a:
+                    if self.outcount > link['outcount']:
+                        self.out("   ["+`link['count']`+"]: " + urlparse.urljoin(self.baseurl, link['href']))
+                        if link.has_key('title'): self.out(" ("+link['title']+")")
+                        self.out("\n")
+                    else:
+                        newa.append(link)
+
+                if self.a != newa: self.out("\n") # Don't need an extra line when nothing was done.
+
+                self.a = newa
+
+            if self.abbr_list and force == "end":
+                for abbr, definition in self.abbr_list.items():
+                    self.out("  *[" + abbr + "]: " + definition + "\n")
+
+            self.p_p = 0
+            self.out(data)
+            self.lastWasNL = data and data[-1] == '\n'
+            self.outcount += 1
+
+    def handle_data(self, data):
+        if r'\/script>' in data: self.quiet -= 1
+        self.o(data, 1)
+
+    def unknown_decl(self, data):
+        pass
+
+def wrapwrite(text): sys.stdout.write(text.encode('utf8'))
+
+def html2text_file(html, out=wrapwrite, baseurl=''):
+    h = _html2text(out, baseurl)
+    h.feed(html)
+    h.feed("")
+    return h.close()
+
+def html2text(html, baseurl=''):
+    return optwrap(html2text_file(html, None, baseurl))
+
+if __name__ == "__main__":
+    baseurl = ''
+    if sys.argv[1:]:
+        arg = sys.argv[1]
+        if arg.startswith('http://'):
+            baseurl = arg
+            j = urllib.urlopen(baseurl)
+            try:
+                from feedparser import _getCharacterEncoding as enc
+            except ImportError:
+                   enc = lambda x, y: ('utf-8', 1)
+            text = j.read()
+            encoding = enc(j.headers, text)[0]
+            if encoding == 'us-ascii': encoding = 'utf-8'
+            data = text.decode(encoding)
+
+        else:
+            encoding = 'utf8'
+            if len(sys.argv) > 2:
+                encoding = sys.argv[2]
+            f = open(arg, 'r')
+            try:
+                    data = f.read().decode(encoding)
+            finally:
+                    f.close()
+    else:
+        data = sys.stdin.read().decode('utf8')
+    wrapwrite(html2text(data, baseurl))

--- a/None
+++ b/addons/mail/models/ir_actions.py
@@ -0,0 +1,40 @@
+# -*- coding: utf-8 -*-
+
+from openerp import _, api, fields, models
+from openerp.exceptions import UserError
+
+
+class ServerActions(models.Model):
+    """ Add email option in server actions. """
+    _name = 'ir.actions.server'
+    _inherit = ['ir.actions.server']
+
+    @api.model
+    def _get_states(self):
+        res = super(ServerActions, self)._get_states()
+        res.insert(0, ('email', 'Send Email'))
+        return res
+
+    email_from = fields.Char('From', related='template_id.email_from', readonly=True)
+    email_to = fields.Char('To (Emails)', related='template_id.email_to', readonly=True)
+    partner_to = fields.Char('To (Partners)', related='template_id.partner_to', readonly=True)
+    subject = fields.Char('Subject', related='template_id.subject', readonly=True)
+    body_html = fields.Html('Body', related='template_id.body_html', readonly=True)
+    template_id = fields.Many2one(
+        'mail.template', 'Email Template', ondelete='set null',
+        domain="[('model_id', '=', model_id)]",
+    )
+
+    @api.onchange('template_id')
+    def on_change_template_id(self):
+        """ Render the raw template in the server action fields. """
+        if self.template_id and not self.template_id.email_from:
+            raise UserError(_('Your template should define email_from'))
+
+    @api.model
+    def run_action_email(self, action, eval_context=None):
+        # TDE CLEANME: when going to new api with server action, remove action
+        if not action.template_id or not self._context.get('active_id'):
+            return False
+        action.template_id.send_mail(self._context.get('active_id'), force_send=False, raise_exception=False)
+        return False

--- a/None
+++ b/addons/mail/models/ir_attachment.py
@@ -0,0 +1,174 @@
+# -*- coding: utf-8 -*-
+
+import os.path
+
+from openerp import api, fields, models
+
+
+class IrAttachment(models.Model):
+    """ Update partner to add a field about notification preferences """
+    _name = "ir.attachment"
+    _inherit = 'ir.attachment'
+
+    _fileext_to_type = {
+        '7z': 'archive',
+        'aac': 'audio',
+        'ace': 'archive',
+        'ai': 'vector',
+        'aiff': 'audio',
+        'apk': 'archive',
+        'app': 'binary',
+        'as': 'script',
+        'asf': 'video',
+        'ass': 'text',
+        'avi': 'video',
+        'bat': 'script',
+        'bin': 'binary',
+        'bmp': 'image',
+        'bzip2': 'archive',
+        'c': 'script',
+        'cab': 'archive',
+        'cc': 'script',
+        'ccd': 'disk',
+        'cdi': 'disk',
+        'cdr': 'vector',
+        'cer': 'certificate',
+        'cgm': 'vector',
+        'cmd': 'script',
+        'coffee': 'script',
+        'com': 'binary',
+        'cpp': 'script',
+        'crl': 'certificate',
+        'crt': 'certificate',
+        'cs': 'script',
+        'csr': 'certificate',
+        'css': 'html',
+        'csv': 'spreadsheet',
+        'cue': 'disk',
+        'd': 'script',
+        'dds': 'image',
+        'deb': 'archive',
+        'der': 'certificate',
+        'djvu': 'image',
+        'dmg': 'archive',
+        'dng': 'image',
+        'doc': 'document',
+        'docx': 'document',
+        'dvi': 'print',
+        'eot': 'font',
+        'eps': 'vector',
+        'exe': 'binary',
+        'exr': 'image',
+        'flac': 'audio',
+        'flv': 'video',
+        'gif': 'webimage',
+        'gz': 'archive',
+        'gzip': 'archive',
+        'h': 'script',
+        'htm': 'html',
+        'html': 'html',
+        'ico': 'image',
+        'icon': 'image',
+        'img': 'disk',
+        'iso': 'disk',
+        'jar': 'archive',
+        'java': 'script',
+        'jp2': 'image',
+        'jpe': 'webimage',
+        'jpeg': 'webimage',
+        'jpg': 'webimage',
+        'jpx': 'image',
+        'js': 'script',
+        'key': 'presentation',
+        'keynote': 'presentation',
+        'lisp': 'script',
+        'lz': 'archive',
+        'lzip': 'archive',
+        'm': 'script',
+        'm4a': 'audio',
+        'm4v': 'video',
+        'mds': 'disk',
+        'mdx': 'disk',
+        'mid': 'audio',
+        'midi': 'audio',
+        'mkv': 'video',
+        'mng': 'image',
+        'mp2': 'audio',
+        'mp3': 'audio',
+        'mp4': 'video',
+        'mpe': 'video',
+        'mpeg': 'video',
+        'mpg': 'video',
+        'nrg': 'disk',
+        'numbers': 'spreadsheet',
+        'odg': 'vector',
+        'odm': 'document',
+        'odp': 'presentation',
+        'ods': 'spreadsheet',
+        'odt': 'document',
+        'ogg': 'audio',
+        'ogm': 'video',
+        'otf': 'font',
+        'p12': 'certificate',
+        'pak': 'archive',
+        'pbm': 'image',
+        'pdf': 'print',
+        'pem': 'certificate',
+        'pfx': 'certificate',
+        'pgf': 'image',
+        'pgm': 'image',
+        'pk3': 'archive',
+        'pk4': 'archive',
+        'pl': 'script',
+        'png': 'webimage',
+        'pnm': 'image',
+        'ppm': 'image',
+        'pps': 'presentation',
+        'ppt': 'presentation',
+        'ps': 'print',
+        'psd': 'image',
+        'psp': 'image',
+        'py': 'script',
+        'r': 'script',
+        'ra': 'audio',
+        'rar': 'archive',
+        'rb': 'script',
+        'rpm': 'archive',
+        'rtf': 'text',
+        'sh': 'script',
+        'sub': 'disk',
+        'svg': 'vector',
+        'sxc': 'spreadsheet',
+        'sxd': 'vector',
+        'tar': 'archive',
+        'tga': 'image',
+        'tif': 'image',
+        'tiff': 'image',
+        'ttf': 'font',
+        'txt': 'text',
+        'vbs': 'script',
+        'vc': 'spreadsheet',
+        'vml': 'vector',
+        'wav': 'audio',
+        'webp': 'image',
+        'wma': 'audio',
+        'wmv': 'video',
+        'woff': 'font',
+        'xar': 'vector',
+        'xbm': 'image',
+        'xcf': 'image',
+        'xhtml': 'html',
+        'xls': 'spreadsheet',
+        'xlsx': 'spreadsheet',
+        'xml': 'html',
+        'zip': 'archive'
+    }
+
+    file_type_icon = fields.Char('File Type Icon', compute='get_attachment_type', store=True)
+    file_type = fields.Char(related='file_type_icon')     # FIXME remove in trunk
+
+    @api.depends('datas_fname')
+    @api.one
+    def get_attachment_type(self):
+        fileext = os.path.splitext(self.datas_fname or '')[1].lower()[1:]
+        self.file_type_icon = self._fileext_to_type.get(fileext, 'unknown')

--- a/None
+++ b/addons/mail/models/ir_ui_menu.py
@@ -0,0 +1,36 @@
+# -*- coding: utf-8 -*-
+
+from openerp import api, fields, models
+
+
+class IrUiMenu(models.Model):
+    """ Override of ir.ui.menu class. When adding mail_thread module, each
+        new mail.group will create a menu entry. This overrides checks that
+        the current user is in the mail.group followers. If not, the menu
+        entry is taken off the list of menu ids. This way the user will see
+        menu entries for the mail.group he is following.
+    """
+    _inherit = 'ir.ui.menu'
+
+    mail_group_id = fields.Many2one('mail.group', 'Mail Group')
+
+    def search(self, cr, uid, args, offset=0, limit=None, order=None, context=None, count=False):
+        """ Remove mail.group menu entries when the user is not a follower."""
+        ids = super(IrUiMenu, self).search(cr, uid, args, offset=offset,
+                                           limit=limit, order=order,
+                                           context=context, count=False)
+        if ids:
+            cr.execute("""
+                SELECT id FROM ir_ui_menu m
+                WHERE m.mail_group_id IS NULL OR EXISTS (
+                        SELECT 1 FROM mail_followers
+                        WHERE res_model = 'mail.group' AND res_id = m.mail_group_id
+                            AND partner_id = (SELECT partner_id FROM res_users WHERE id = %s)
+                        ) AND id in %s
+                """, (uid, tuple(ids)))
+            # Preserve original search order
+            visible_ids = set(x[0] for x in cr.fetchall())
+            ids = [i for i in ids if i in visible_ids]
+        if count:
+            return len(ids)
+        return ids

--- a/None
+++ b/addons/mail/models/mail_alias.py
@@ -0,0 +1,249 @@
+# -*- coding: utf-8 -*-
+
+import logging
+import re
+import unicodedata
+
+from openerp import _, api, fields, models, SUPERUSER_ID
+from openerp.exceptions import UserError
+from openerp.modules.registry import RegistryManager
+from openerp.tools import ustr
+
+_logger = logging.getLogger(__name__)
+
+
+# Inspired by http://stackoverflow.com/questions/517923
+def remove_accents(input_str):
+    """Suboptimal-but-better-than-nothing way to replace accented
+    latin letters by an ASCII equivalent. Will obviously change the
+    meaning of input_str and work only for some cases"""
+    input_str = ustr(input_str)
+    nkfd_form = unicodedata.normalize('NFKD', input_str)
+    return u''.join([c for c in nkfd_form if not unicodedata.combining(c)])
+
+
+class Alias(models.Model):
+    """A Mail Alias is a mapping of an email address with a given OpenERP Document
+       model. It is used by OpenERP's mail gateway when processing incoming emails
+       sent to the system. If the recipient address (To) of the message matches
+       a Mail Alias, the message will be either processed following the rules
+       of that alias. If the message is a reply it will be attached to the
+       existing discussion on the corresponding record, otherwise a new
+       record of the corresponding model will be created.
+
+       This is meant to be used in combination with a catch-all email configuration
+       on the company's mail server, so that as soon as a new mail.alias is
+       created, it becomes immediately usable and OpenERP will accept email for it.
+     """
+    _name = 'mail.alias'
+    _description = "Email Aliases"
+    _rec_name = 'alias_name'
+    _order = 'alias_model_id, alias_name'
+
+    alias_name = fields.Char('Alias Name', help="The name of the email alias, e.g. 'jobs' if you want to catch emails for <jobs@example.odoo.com>")
+    alias_model_id = fields.Many2one('ir.model', 'Aliased Model', required=True, ondelete="cascade",
+                                     help="The model (Odoo Document Kind) to which this alias "
+                                          "corresponds. Any incoming email that does not reply to an "
+                                          "existing record will cause the creation of a new record "
+                                          "of this model (e.g. a Project Task)",
+                                      # hack to only allow selecting mail_thread models (we might
+                                      # (have a few false positives, though)
+                                      domain="[('field_id.name', '=', 'message_ids')]")
+    alias_user_id = fields.Many2one('res.users', 'Owner', defaults=lambda self: self.env.user,
+                                    help="The owner of records created upon receiving emails on this alias. "
+                                         "If this field is not set the system will attempt to find the right owner "
+                                         "based on the sender (From) address, or will use the Administrator account "
+                                         "if no system user is found for that address.")
+    alias_defaults = fields.Text('Default Values', required=True, default='{}',
+                                 help="A Python dictionary that will be evaluated to provide "
+                                      "default values when creating new records for this alias.")
+    alias_force_thread_id = fields.Integer(
+        'Record Thread ID',
+        help="Optional ID of a thread (record) to which all incoming messages will be attached, even "
+             "if they did not reply to it. If set, this will disable the creation of new records completely.")
+    alias_domain = fields.Char('Alias domain', compute='_get_alias_domain')
+    alias_parent_model_id = fields.Many2one(
+        'ir.model', 'Parent Model',
+        help="Parent model holding the alias. The model holding the alias reference"
+             "is not necessarily the model given by alias_model_id"
+             "(example: project (parent_model) and task (model))")
+    alias_parent_thread_id = fields.Integer('Parent Record Thread ID', help="ID of the parent record holding the alias (example: project holding the task creation alias)")
+    alias_contact = fields.Selection([
+        ('everyone', 'Everyone'),
+        ('partners', 'Authenticated Partners'),
+        ('followers', 'Followers only')], default='everyone',
+        string='Alias Contact Security', required=True,
+        help="Policy to post a message on the document using the mailgateway.\n"
+             "- everyone: everyone can post\n"
+             "- partners: only authenticated partners\n"
+             "- followers: only followers of the related document\n")
+
+    _sql_constraints = [
+        ('alias_unique', 'UNIQUE(alias_name)', 'Unfortunately this email alias is already used, please choose a unique one')
+    ]
+
+    @api.multi
+    def _get_alias_domain(self):
+        alias_domain = self.env["ir.config_parameter"].get_param("mail.catchall.domain")
+        for record in self:
+            record.alias_domain = alias_domain
+
+    @api.one
+    @api.constrains('alias_defaults')
+    def _check_alias_defaults(self):
+        try:
+            dict(eval(self.alias_defaults))
+        except Exception:
+            raise UserError(_('Invalid expression, it must be a literal python dictionary definition e.g. "{\'field\': \'value\'}"'))
+
+    @api.model
+    def create(self, vals):
+        """ Creates an email.alias record according to the values provided in ``vals``,
+            with 2 alterations: the ``alias_name`` value may be suffixed in order to
+            make it unique (and certain unsafe characters replaced), and
+            he ``alias_model_id`` value will set to the model ID of the ``model_name``
+            context value, if provided.
+        """
+        model_name = self._context.get('alias_model_name')
+        parent_model_name = self._context.get('alias_parent_model_name')
+        if vals.get('alias_name'):
+            vals['alias_name'] = self._clean_and_make_unique(vals.get('alias_name'))
+        if model_name:
+            model = self.env['ir.model'].search([('model', '=', model_name)])
+            vals['alias_model_id'] = model.id
+        if parent_model_name:
+            model = self.env['ir.model'].search([('model', '=', parent_model_name)])
+            vals['alias_parent_model_id'] = model.id
+        return super(Alias, self).create(vals)
+
+    @api.multi
+    def write(self, vals):
+        """"give a unique alias name if given alias name is already assigned"""
+        if vals.get('alias_name') and self.ids:
+            vals['alias_name'] = self._clean_and_make_unique(vals.get('alias_name'), alias_ids=self.ids)
+        return super(Alias, self).write(vals)
+
+    @api.multi
+    def name_get(self):
+        """Return the mail alias display alias_name, including the implicit
+           mail catchall domain if exists from config otherwise "New Alias".
+           e.g. `jobs@mail.odoo.com` or `jobs` or 'New Alias'
+        """
+        res = []
+        for record in self:
+            if record.alias_name and record.alias_domain:
+                res.append((record['id'], "%s@%s" % (record.alias_name, record.alias_domain)))
+            elif record.alias_name:
+                res.append((record['id'], "%s" % (record.alias_name)))
+            else:
+                res.append((record['id'], _("Inactive Alias")))
+        return res
+
+    @api.model
+    def _find_unique(self, name, alias_ids=False):
+        """Find a unique alias name similar to ``name``. If ``name`` is
+           already taken, make a variant by adding an integer suffix until
+           an unused alias is found.
+        """
+        sequence = None
+        while True:
+            new_name = "%s%s" % (name, sequence) if sequence is not None else name
+            domain = [('alias_name', '=', new_name)]
+            if alias_ids:
+                domain += [('id', 'not in', alias_ids)]
+            if not self.search(domain):
+                break
+            sequence = (sequence + 1) if sequence else 2
+        return new_name
+
+    @api.model
+    def _clean_and_make_unique(self, name, alias_ids=False):
+        # when an alias name appears to already be an email, we keep the local part only
+        name = remove_accents(name).lower().split('@')[0]
+        name = re.sub(r'[^\w+.]+', '-', name)
+        return self._find_unique(name, alias_ids=alias_ids)
+
+    def migrate_to_alias(self, cr, child_model_name, child_table_name, child_model_auto_init_fct,
+        alias_model_name, alias_id_column, alias_key, alias_prefix='', alias_force_key='', alias_defaults={},
+        alias_generate_name=False, context=None):
+        """ Installation hook to create aliases for all users and avoid constraint errors.
+
+            :param child_model_name: model name of the child class (i.e. res.users)
+            :param child_table_name: table name of the child class (i.e. res_users)
+            :param child_model_auto_init_fct: pointer to the _auto_init function
+                (i.e. super(res_users,self)._auto_init(cr, context=context))
+            :param alias_model_name: name of the aliased model
+            :param alias_id_column: alias_id column (i.e. self._columns['alias_id'])
+            :param alias_key: name of the column used for the unique name (i.e. 'login')
+            :param alias_prefix: prefix for the unique name (i.e. 'jobs' + ...)
+            :param alias_force_key': name of the column for force_thread_id;
+                if empty string, not taken into account
+            :param alias_defaults: dict, keys = mail.alias columns, values = child
+                model column name used for default values (i.e. {'job_id': 'id'})
+            :param alias_generate_name: automatically generate alias name using prefix / alias key;
+                default alias_name value is False because since 8.0 it is not required anymore
+        """
+        if context is None:
+            context = {}
+
+        # disable the unique alias_id not null constraint, to avoid spurious warning during
+        # super.auto_init. We'll reinstall it afterwards.
+        alias_id_column.required = False
+
+        # call _auto_init
+        res = child_model_auto_init_fct(cr, context=context)
+
+        registry = RegistryManager.get(cr.dbname)
+        mail_alias = registry.get('mail.alias')
+        child_class_model = registry[child_model_name]
+        no_alias_ids = child_class_model.search(cr, SUPERUSER_ID, [('alias_id', '=', False)], context={'active_test': False})
+        # Use read() not browse(), to avoid prefetching uninitialized inherited fields
+        for obj_data in child_class_model.read(cr, SUPERUSER_ID, no_alias_ids, [alias_key]):
+            alias_vals = {'alias_name': False}
+            if alias_generate_name:
+                alias_vals['alias_name'] = '%s%s' % (alias_prefix, obj_data[alias_key])
+            if alias_force_key:
+                alias_vals['alias_force_thread_id'] = obj_data[alias_force_key]
+            alias_vals['alias_defaults'] = dict((k, obj_data[v]) for k, v in alias_defaults.iteritems())
+            alias_vals['alias_parent_thread_id'] = obj_data['id']
+            alias_create_ctx = dict(context, alias_model_name=alias_model_name, alias_parent_model_name=child_model_name)
+            alias_id = mail_alias.create(cr, SUPERUSER_ID, alias_vals, context=alias_create_ctx)
+            child_class_model.write(cr, SUPERUSER_ID, obj_data['id'], {'alias_id': alias_id}, context={'mail_notrack': True})
+            _logger.info('Mail alias created for %s %s (id %s)', child_model_name, obj_data[alias_key], obj_data['id'])
+
+        # Finally attempt to reinstate the missing constraint
+        try:
+            cr.execute('ALTER TABLE %s ALTER COLUMN alias_id SET NOT NULL' % (child_table_name))
+        except Exception:
+            _logger.warning("Table '%s': unable to set a NOT NULL constraint on column '%s' !\n"\
+                            "If you want to have it, you should update the records and execute manually:\n"\
+                            "ALTER TABLE %s ALTER COLUMN %s SET NOT NULL",
+                            child_table_name, 'alias_id', child_table_name, 'alias_id')
+
+        # set back the unique alias_id constraint
+        alias_id_column.required = True
+        return res
+
+    @api.multi
+    def open_document(self):
+        if not self.alias_model_id or not self.alias_force_thread_id:
+            return False
+        return {
+            'view_type': 'form',
+            'view_mode': 'form',
+            'res_model': self.alias_model_id.model,
+            'res_id': self.alias_force_thread_id,
+            'type': 'ir.actions.act_window',
+        }
+
+    @api.multi
+    def open_parent_document(self):
+        if not self.alias_parent_model_id or not self.alias_parent_thread_id:
+            return False
+        return {
+            'view_type': 'form',
+            'view_mode': 'form',
+            'res_model': self.alias_parent_model_id.model,
+            'res_id': self.alias_parent_thread_id,
+            'type': 'ir.actions.act_window',
+        }

--- a/None
+++ b/addons/mail/models/mail_followers.py
@@ -0,0 +1,223 @@
+# -*- coding: utf-8 -*-
+
+import threading
+
+from openerp import _, api, fields, models
+from openerp import tools
+
+
+class Followers(models.Model):
+    """ mail_followers holds the data related to the follow mechanism inside
+    Odoo. Partners can choose to follow documents (records) of any kind
+    that inherits from mail.thread. Following documents allow to receive
+    notifications for new messages. A subscription is characterized by:
+
+    :param: res_model: model of the followed objects
+    :param: res_id: ID of resource (may be 0 for every objects)
+    """
+    _name = 'mail.followers'
+    _rec_name = 'partner_id'
+    _log_access = False
+    _description = 'Document Followers'
+
+    res_model = fields.Char(
+        'Related Document Model', required=True, select=1, help='Model of the followed resource')
+    res_id = fields.Integer(
+        'Related Document ID', select=1, help='Id of the followed resource')
+    partner_id = fields.Many2one(
+        'res.partner', string='Related Partner', ondelete='cascade', required=True, select=1)
+    subtype_ids = fields.Many2many(
+        'mail.message.subtype', string='Subtype',
+        help="Message subtypes followed, meaning subtypes that will be pushed onto the user's Wall.")
+
+    #
+    # Modifying followers change access rights to individual documents. As the
+    # cache may contain accessible/inaccessible data, one has to refresh it.
+    #
+    @api.model
+    def create(self, vals):
+        res = super(Followers, self).create(vals)
+        self.invalidate_cache()
+        return res
+
+    @api.multi
+    def write(self, vals):
+        res = super(Followers, self).write(vals)
+        self.invalidate_cache()
+        return res
+
+    @api.multi
+    def unlink(self):
+        res = super(Followers, self).unlink()
+        self.invalidate_cache()
+        return res
+
+    _sql_constraints = [('mail_followers_res_partner_res_model_id_uniq', 'unique(res_model,res_id,partner_id)', 'Error, a partner cannot follow twice the same object.')]
+
+
+class Notification(models.Model):
+    """ Class holding notifications pushed to partners. Followers and partners
+    added in 'contacts to notify' receive notifications. """
+    _name = 'mail.notification'
+    _rec_name = 'partner_id'
+    _log_access = False
+    _description = 'Notifications'
+
+    partner_id = fields.Many2one('res.partner', string='Contact', ondelete='cascade', required=True, select=1)
+    is_read = fields.Boolean('Read', select=1, oldname='read')
+    starred = fields.Boolean('Starred', select=1, help='Starred message that goes into the todo mailbox')
+    message_id = fields.Many2one('mail.message', string='Message', ondelete='cascade', required=True, select=1)
+
+    def init(self, cr):
+        cr.execute('SELECT indexname FROM pg_indexes WHERE indexname = %s', ('mail_notification_partner_id_read_starred_message_id',))
+        if not cr.fetchone():
+            cr.execute('CREATE INDEX mail_notification_partner_id_read_starred_message_id ON mail_notification (partner_id, is_read, starred, message_id)')
+
+    def get_partners_to_email(self, message):
+        """ Return the list of partners to notify, based on their preferences.
+
+            :param browse_record message: mail.message to notify
+            :param list partners_to_notify: optional list of partner ids restricting
+                the notifications to process
+        """
+        notify_pids = []
+        for notification in self:
+            if notification.is_read:
+                continue
+            partner = notification.partner_id
+            # Do not send to partners without email address defined
+            if not partner.email:
+                continue
+            # Do not send to partners having same email address than the author (can cause loops or bounce effect due to messy database)
+            if message.author_id and message.author_id.email == partner.email:
+                continue
+            # Partner does not want to receive any emails or is opt-out
+            if partner.notify_email == 'none':
+                continue
+            notify_pids.append(partner.id)
+        return notify_pids
+
+    @api.model
+    def get_signature_footer(self, user_id, res_model=None, res_id=None, user_signature=True):
+        """ Format a standard footer for notification emails (such as pushed messages
+            notification or invite emails).
+            Format:
+                <p>--<br />
+                    Administrator
+                </p>
+                <div>
+                    <small>Sent from <a ...>Your Company</a> using <a ...>OpenERP</a>.</small>
+                </div>
+        """
+        footer = ""
+        if not user_id:
+            return footer
+
+        # add user signature
+        user = self.env.user
+        if user_signature:
+            if self.env.user.signature:
+                signature = user.signature
+            else:
+                signature = "--<br />%s" % user.name
+            footer = tools.append_content_to_html(footer, signature, plaintext=False)
+
+        # add company signature
+        if user.company_id.website:
+            website_url = ('http://%s' % user.company_id.website) if not user.company_id.website.lower().startswith(('http:', 'https:')) \
+                else user.company_id.website
+            company = "<a style='color:inherit' href='%s'>%s</a>" % (website_url, user.company_id.name)
+        else:
+            company = user.company_id.name
+        sent_by = _('Sent by %(company)s using %(odoo)s')
+
+        signature_company = '<br /><small>%s</small>' % (sent_by % {
+            'company': company,
+            'odoo': "<a style='color:inherit' href='https://www.odoo.com/'>Odoo</a>"
+        })
+        footer = tools.append_content_to_html(footer, signature_company, plaintext=False, container_tag='div')
+
+        return footer
+
+    def update_message_notification(self, message, partners):
+        # update existing notifications
+        self.write({'is_read': False})
+
+        # create new notifications
+        new_notif_ids = self.env['mail.notification']
+        for new_pid in partners - self.mapped('partner_id'):
+            new_notif_ids |= self.create({'message_id': message.id, 'partner_id': new_pid.id, 'is_read': False})
+        return new_notif_ids
+
+    @api.multi
+    def _notify_email(self, message, force_send=False, user_signature=True):
+
+        # compute partners
+        email_pids = self.get_partners_to_email(message)
+        if not email_pids:
+            return True
+
+        # compute email body (signature, company data)
+        body_html = message.body
+        # add user signature except for mail groups, where users are usually adding their own signatures already
+        user_id = message.author_id and message.author_id.user_ids and message.author_id.user_ids[0] and message.author_id.user_ids[0].id or None
+        signature_company = self.get_signature_footer(user_id, res_model=message.model, res_id=message.res_id, user_signature=(user_signature and message.model != 'mail.group'))
+        if signature_company:
+            body_html = tools.append_content_to_html(body_html, signature_company, plaintext=False, container_tag='div')
+
+        # compute email references
+        references = message.parent_id.message_id if message.parent_id else False
+
+        # custom values
+        custom_values = dict()
+        if message.model and message.res_id and self.pool.get(message.model) and hasattr(self.pool[message.model], 'message_get_email_values'):
+            custom_values = self.env[message.model].browse(message.res_id).message_get_email_values(message)
+
+        # create email values
+        max_recipients = 50
+        chunks = [email_pids[x:x + max_recipients] for x in xrange(0, len(email_pids), max_recipients)]
+        emails = self.env['mail.mail']
+        for chunk in chunks:
+            mail_values = {
+                'mail_message_id': message.id,
+                'auto_delete': self._context.get('mail_auto_delete', True),
+                'body_html': body_html,
+                'recipient_ids': [(4, id) for id in chunk],
+                'references': references,
+            }
+            mail_values.update(custom_values)
+            emails |= self.env['mail.mail'].create(mail_values)
+        # NOTE:
+        #   1. for more than 50 followers, use the queue system
+        #   2. do not send emails immediately if the registry is not loaded,
+        #      to prevent sending email during a simple update of the database
+        #      using the command-line.
+        if force_send and len(chunks) < 2 and \
+               (not self.pool._init or
+                getattr(threading.currentThread(), 'testing', False)):
+            emails.send()
+        return True
+
+    @api.model
+    def _notify(self, message, recipients=None, force_send=False, user_signature=True):
+        """ Send by email the notification depending on the user preferences
+
+            :param list partners_to_notify: optional list of partner ids restricting
+                the notifications to process
+            :param bool force_send: if True, the generated mail.mail is
+                immediately sent after being created, as if the scheduler
+                was executed for this message only.
+            :param bool user_signature: if True, the generated mail.mail body is
+                the body of the related mail.message with the author's signature
+        """
+        notif_ids = self.sudo().search([('message_id', '=', message.id), ('partner_id', 'in', recipients.ids)])
+
+        # update or create notifications
+        new_notif_ids = notif_ids.update_message_notification(message, recipients)  # tde check: sudo
+
+        # mail_notify_noemail (do not send email) or no partner_ids: do not send, return
+        if self.env.context.get('mail_notify_noemail'):
+            return True
+
+        # browse as SUPERUSER_ID because of access to res_partner not necessarily allowed
+        new_notif_ids._notify_email(message, force_send, user_signature)  # tde check this one too

--- a/None
+++ b/addons/mail/models/mail_group.py
@@ -0,0 +1,197 @@
+# -*- coding: utf-8 -*-
+
+from openerp import _, api, fields, models, modules, tools
+from openerp.exceptions import UserError
+
+
+class MailGroup(models.Model):
+    """ A mail_group is a collection of users sharing messages in a discussion
+        group. The group mechanics are based on the followers. """
+    _description = 'Discussion group'
+    _name = 'mail.group'
+    _mail_flat_thread = False
+    _mail_post_access = 'read'
+    _inherit = ['mail.thread']
+    _inherits = {'mail.alias': 'alias_id'}
+
+    def _get_default_image(self):
+        image_path = modules.get_module_resource('mail', 'static/src/img', 'groupdefault.png')
+        return tools.image_resize_image_big(open(image_path, 'rb').read().encode('base64'))
+
+    name = fields.Char('Name', required=True, translate=True)
+    description = fields.Text('Description')
+    menu_id = fields.Many2one('ir.ui.menu', string='Related Menu', required=True, ondelete="cascade")
+    public = fields.Selection([
+        ('public', 'Everyone'),
+        ('private', 'Invited people only'),
+        ('groups', 'Selected group of users')],
+        'Privacy', required=True, default='groups',
+        help='This group is visible by non members. Invisible groups can add members through the invite button.')
+    group_public_id = fields.Many2one('res.groups', string='Authorized Group',
+                                      default=lambda self: self.env.ref('base.group_user'))
+    group_ids = fields.Many2many(
+        'res.groups', rel='mail_group_res_group_rel',
+        id1='mail_group_id', id2='groups_id', string='Auto Subscription',
+        help="Members of those groups will automatically added as followers. "
+             "Note that they will be able to manage their subscription manually "
+             "if necessary.")
+    # image: all image fields are base64 encoded and PIL-supported
+    image = fields.Binary("Photo", default=_get_default_image,
+                          help="This field holds the image used as photo for the group, limited to 1024x1024px.")
+    image_medium = fields.Binary('Medium-sized photo', compute='_get_image', inverse='_set_image', store=True,
+                                 help="Medium-sized photo of the group. It is automatically "
+                                      "resized as a 128x128px image, with aspect ratio preserved. "
+                                      "Use this field in form views or some kanban views.")
+    image_small = fields.Binary('Small-sized photo', compute='_get_image', inverse='_set_image', store=True,
+                                help="Small-sized photo of the group. It is automatically "
+                                     "resized as a 64x64px image, with aspect ratio preserved. "
+                                     "Use this field anywhere a small image is required.")
+    alias_id = fields.Many2one(
+        'mail.alias', 'Alias', ondelete="restrict", required=True,
+        help="The email address associated with this group. New emails received will automatically "
+             "create new topics.")
+
+    @api.one
+    @api.depends('image')
+    def _get_image(self):
+        res = tools.image_get_resized_images(self.image)
+        self.image_medium = res['image_medium']
+        self.image_small = res['image_small']
+
+    def _set_image(self):
+        self.image = tools.image_resize_image_big(self.image)
+
+    @api.model
+    def create(self, vals):
+        # get parent menu
+        menu_parent = self.env.ref('mail.mail_group_root')
+
+        # Create menu id
+        menu = self.env['ir.ui.menu'].sudo().create({'name': vals['name'], 'parent_id': menu_parent.id})
+        vals['menu_id'] = menu.id
+
+        # Create group and alias
+        group = super(MailGroup, self.with_context(
+            alias_model_name=self._name, alias_parent_model_name=self._name, mail_create_nolog=True)
+        ).create(vals)
+        group.alias_id.write({"alias_force_thread_id": group.id, 'alias_parent_thread_id': group.id})
+
+        # Create client action for this group and link the menu to it
+        inbox_ref = self.env.ref('mail.action_mail_group_feeds')
+        search_ref = self.env.ref('mail.view_message_search')
+        params = {
+            'search_view_id': search_ref.id,
+            'domain': [
+                ('model', '=', 'mail.group'),
+                ('res_id', '=', group.id),
+            ],
+            'context': {
+                'default_model': 'mail.group',
+                'default_res_id': group.id,
+            },
+            'res_model': 'mail.message',
+            'thread_level': 1,
+            'header_description': group._get_header(),
+            'view_mailbox': True,
+            'compose_placeholder': 'Send a message to the group',
+        }
+        new_action = inbox_ref.sudo().copy(default={'params': str(params), 'name': vals['name']})
+        menu.write({'action': 'ir.actions.client,%d' % new_action.id, 'mail_group_id': group.id})
+
+        if vals.get('group_ids'):
+            group._subscribe_users()
+        return group
+
+    @api.multi
+    def unlink(self):
+        aliases = self.mapped('alias_id')
+        menus = self.mapped('menu_id')
+
+        # Delete mail_group
+        try:
+            all_emp_group = self.env.ref('mail.group_all_employees')
+        except ValueError:
+            all_emp_group = None
+        if all_emp_group and all_emp_group in self:
+            raise UserError(_('You cannot delete those groups, as the Whole Company group is required by other modules.'))
+        res = super(MailGroup, self).unlink()
+        # Cascade-delete mail aliases as well, as they should not exist without the mail group.
+        aliases.sudo().unlink()
+        # Cascade-delete menu entries as well
+        menus.sudo().unlink()
+        return res
+
+    @api.multi
+    def write(self, vals):
+        result = super(MailGroup, self).write(vals)
+        if vals.get('group_ids'):
+            self._subscribe_users()
+        # if description, name or alias is changed: update client action
+        if vals.get('description') or vals.get('name') or vals.get('alias_id') or vals.get('alias_name'):
+            for group in self:
+                new_params = group.menu_id.action.params
+                new_params['header_description'] = group._generate_header_description()
+                group.menu_id.action.sudo().write({'params': str(new_params)})
+        # if name is changed: update menu
+        if vals.get('name'):
+            self.sudo().mapped('menu_id').write({'name': vals.get('name')})
+        return result
+
+    def _get_header(self):
+        self.ensure_one()
+        header = '%(description)s%(gateway)s' % {
+            'description': '%s<br />' % self.description if self.description else '',
+            'gateway': _('Group email gateway: %s@%s') % (self.alias_name, self.alias_domain) if self.alias_name and self.alias_domain else ''
+        }
+        return header
+    # compat
+    _generate_header_description = _get_header
+
+    def _subscribe_users(self):
+        for mail_group in self:
+            partner_ids = mail_group.mapped('group_ids').mapped('users').mapped('partner_id')
+            mail_group.message_subscribe(partner_ids.ids)
+
+    @api.multi
+    def action_follow(self):
+        """ Wrapper because message_subscribe_users take a user_ids=None
+            that receive the context without the wrapper. """
+        return self.message_subscribe_users()
+
+    @api.multi
+    def action_unfollow(self):
+        """ Wrapper because message_unsubscribe_users take a user_ids=None
+            that receive the context without the wrapper. """
+        return self.message_unsubscribe_users()
+
+    @api.model
+    def get_suggested_thread(self, removed_suggested_threads=None):
+        """Show the suggestion of groups if display_groups_suggestions if the
+        user perference allows it."""
+        if not self.env.user.display_groups_suggestions:
+            return []
+        return super(MailGroup, self).get_suggested_thread(removed_suggested_threads)
+
+    @api.multi
+    def message_get_email_values(self, notif_mail=None):
+        self.ensure_one()
+        res = super(MailGroup, self).message_get_email_values(notif_mail=notif_mail)
+        headers = {}
+        if res.get('headers'):
+            try:
+                headers.update(eval(res['headers']))
+            except Exception:
+                pass
+        headers['Precedence'] = 'list'
+        # avoid out-of-office replies from MS Exchange
+        # http://blogs.technet.com/b/exchange/archive/2006/10/06/3395024.aspx
+        headers['X-Auto-Response-Suppress'] = 'OOF'
+        if self.alias_domain and self.alias_name:
+            headers['List-Id'] = '%s.%s' % (self.alias_name, self.alias_domain)
+            headers['List-Post'] = '<mailto:%s@%s>' % (self.alias_name, self.alias_domain)
+            # Avoid users thinking it was a personal message
+            # X-Forge-To: will replace To: after SMTP envelope is determined by ir.mail.server
+            list_to = '"%s" <%s@%s>' % (self.name, self.alias_name, self.alias_domain)
+            headers['X-Forge-To'] = list_to
+        res['headers'] = repr(headers)
+        return res

--- a/None
+++ b/addons/mail/models/mail_mail.py
@@ -0,0 +1,337 @@
+# -*- coding: utf-8 -*-
+
+import base64
+import logging
+from email.utils import formataddr
+from urlparse import urljoin
+
+from openerp import _, api, fields, models
+from openerp import tools
+from openerp.addons.base.ir.ir_mail_server import MailDeliveryException
+from openerp.tools.safe_eval import safe_eval as eval
+
+_logger = logging.getLogger(__name__)
+
+
+class MailMail(models.Model):
+    """ Model holding RFC2822 email messages to send. This model also provides
+        facilities to queue and send new email messages.  """
+    _name = 'mail.mail'
+    _description = 'Outgoing Mails'
+    _inherits = {'mail.message': 'mail_message_id'}
+    _order = 'id desc'
+    _rec_name = 'subject'
+
+    mail_message_id = fields.Many2one('mail.message', 'Message', required=True, ondelete='cascade', auto_join=True)
+    state = fields.Selection([
+        ('outgoing', 'Outgoing'),
+        ('sent', 'Sent'),
+        ('received', 'Received'),
+        ('exception', 'Delivery Failed'),
+        ('cancel', 'Cancelled'),
+    ], 'Status', readonly=True, copy=False, default='outgoing')
+    auto_delete = fields.Boolean('Auto Delete', help="Permanently delete this email after sending it, to save space")
+    references = fields.Text('References', help='Message references, such as identifiers of previous messages', readonly=1)
+    email_to = fields.Text('To', help='Message recipients (emails)')
+    recipient_ids = fields.Many2many('res.partner', string='To (Partners)')
+    email_cc = fields.Char('Cc', help='Carbon copy message recipients')
+    body_html = fields.Text('Rich-text Contents', help="Rich-text/HTML message")
+    headers = fields.Text('Headers', copy=False)
+    failure_reason = fields.Text('Failure Reason', help="Failure reason. This is usually the exception thrown by the email server, stored to ease the debugging of mailing issues.", readonly=1)
+    # Auto-detected based on create() - if 'mail_message_id' was passed then this mail is a notification
+    # and during unlink() we will not cascade delete the parent and its attachments
+    notification = fields.Boolean('Is Notification', help='Mail has been created to notify people of an existing mail.message')
+
+    @api.model
+    def create(self, values):
+        # notification field: if not set, set if mail comes from an existing mail.message
+        if 'notification' not in values and values.get('mail_message_id'):
+            values['notification'] = True
+        return super(MailMail, self).create(values)
+
+    @api.multi
+    def unlink(self):
+        # cascade-delete the parent message for all mails that are not created for a notification
+        to_cascade = self.search([('notification', '=', False), ('id', 'in', self.ids)]).mapped('mail_message_id')
+        res = super(MailMail, self).unlink()
+        to_cascade.unlink()
+        return res
+
+    @api.model
+    def default_get(self, fields):
+        # protection for `default_type` values leaking from menu action context (e.g. for invoices)
+        # To remove when automatic context propagation is removed in web client
+        if self._context.get('default_type') not in self._all_columns['message_type'].column.selection:
+            self = self.with_context(dict(self._context, default_type=None))
+        return super(MailMail, self).default_get(fields)
+
+    @api.multi
+    def mark_outgoing(self):
+        return self.write({'state': 'outgoing'})
+
+    @api.multi
+    def cancel(self):
+        return self.write({'state': 'cancel'})
+
+    @api.model
+    def process_email_queue(self, ids=None):
+        """Send immediately queued messages, committing after each
+           message is sent - this is not transactional and should
+           not be called during another transaction!
+
+           :param list ids: optional list of emails ids to send. If passed
+                            no search is performed, and these ids are used
+                            instead.
+           :param dict context: if a 'filters' key is present in context,
+                                this value will be used as an additional
+                                filter to further restrict the outgoing
+                                messages to send (by default all 'outgoing'
+                                messages are sent).
+        """
+        if not self.ids:
+            filters = [('state', '=', 'outgoing')]
+            if 'filters' in self._context:
+                filters.extend(self._context['filters'])
+            ids = self.search(filters).ids
+        res = None
+        try:
+            # Force auto-commit - this is meant to be called by
+            # the scheduler, and we can't allow rolling back the status
+            # of previously sent emails!
+            res = self.browse(ids).send(auto_commit=True)
+        except Exception:
+            _logger.exception("Failed processing mail queue")
+        return res
+
+    @api.cr_uid_context
+    def _postprocess_sent_message(self, cr, uid, mail, context=None, mail_sent=True):
+        return True
+
+    @api.multi
+    def _postprocess_sent_message_v9(self, mail_sent=True):
+        """Perform any post-processing necessary after sending ``mail``
+        successfully, including deleting it completely along with its
+        attachment if the ``auto_delete`` flag of the mail was set.
+        Overridden by subclasses for extra post-processing behaviors.
+
+        :param browse_record mail: the mail that was just sent
+        :return: True
+        """
+        # Compat mode until v9
+        for mail in self:
+            self._postprocess_sent_message(mail, mail_sent=mail_sent)
+
+        if mail_sent:
+            self.sudo().filtered(lambda self: self.auto_delete).unlink()
+        return True
+
+    # ------------------------------------------------------
+    # mail_mail formatting, tools and send mechanism
+    # ------------------------------------------------------
+
+    @api.multi
+    def _get_partner_access_link(self, partner=None):
+        """Generate URLs for links in mails: partner has access (is user):
+        link to action_mail_redirect action that will redirect to doc or Inbox """
+        self.ensure_one()
+        if partner and partner.user_ids:
+            base_url = self.env['ir.config_parameter'].sudo().get_param('web.base.url')
+            mail_model = self.model or 'mail.thread'
+            if not hasattr(self.env[mail_model], '_get_access_link'):
+                return None
+            url = urljoin(base_url, self.env[mail_model]._get_access_link(self, partner))
+            return "<span class='oe_mail_footer_access'><small>%(access_msg)s <a style='color:inherit' href='%(portal_link)s'>%(portal_msg)s</a></small></span>" % {
+                'access_msg': _('about') if self.record_name else _('access'),
+                'portal_link': url,
+                'portal_msg': '%s %s' % (self._context.get('model_name', ''), self.record_name) if self.record_name else _('your messages'),
+            }
+        else:
+            return None
+
+    @api.multi
+    def send_get_mail_subject(self, force=False, partner=None):
+        """If subject is void, set the subject as 'Re: <Resource>' or
+        'Re: <mail.parent_id.subject>'
+
+            :param boolean force: force the subject replacement
+        """
+        self.ensure_one()
+        if (force or not self.subject) and self.record_name:
+            return 'Re: %s' % (self.record_name)
+        elif (force or not self.subject) and self.parent_id and self.parent_id.subject:
+            return 'Re: %s' % (self.parent_id.subject)
+        return self.subject
+
+    @api.multi
+    def send_get_mail_body(self, partner=None):
+        """Return a specific ir_email body. The main purpose of this method
+        is to be inherited to add custom content depending on some module."""
+        self.ensure_one()
+        body = self.body_html or ''
+
+        # generate access links for notifications or emails linked to a specific document with auto threading
+        link = None
+        if self.notification or (self.model and self.res_id and not self.no_auto_thread):
+            link = self._get_partner_access_link(partner)
+        if link:
+            body = tools.append_content_to_html(body, link, plaintext=False, container_tag='div')
+        return body
+
+    @api.multi
+    def send_get_mail_to(self, partner=None):
+        """Forge the email_to with the following heuristic:
+          - if 'partner', recipient specific (Partner Name <email>)
+          - else fallback on mail.email_to splitting """
+        self.ensure_one()
+        if partner:
+            email_to = [formataddr((partner.name, partner.email))]
+        else:
+            email_to = tools.email_split(self.email_to)
+        return email_to
+
+    @api.multi
+    def send_get_email_dict(self, partner=None):
+        """Return a dictionary for specific email values, depending on a
+        partner, or generic to the whole recipients given by mail.email_to.
+
+            :param browse_record mail: mail.mail browse_record
+            :param browse_record partner: specific recipient partner
+        """
+        self.ensure_one()
+        body = self.send_get_mail_body(partner=partner)
+        body_alternative = tools.html2plaintext(body)
+        res = {
+            'body': body,
+            'body_alternative': body_alternative,
+            'subject': self.send_get_mail_subject(partner=partner),
+            'email_to': self.send_get_mail_to(partner=partner),
+        }
+        return res
+
+    @api.multi
+    def send(self, auto_commit=False, raise_exception=False):
+        """ Sends the selected emails immediately, ignoring their current
+            state (mails that have already been sent should not be passed
+            unless they should actually be re-sent).
+            Emails successfully delivered are marked as 'sent', and those
+            that fail to be deliver are marked as 'exception', and the
+            corresponding error mail is output in the server logs.
+
+            :param bool auto_commit: whether to force a commit of the mail status
+                after sending each mail (meant only for scheduler processing);
+                should never be True during normal transactions (default: False)
+            :param bool raise_exception: whether to raise an exception if the
+                email sending process has failed
+            :return: True
+        """
+        IrMailServer = self.env['ir.mail_server']
+
+        for mail in self:
+            try:
+                # TDE note: remove me when model_id field is present on mail.message - done here to avoid doing it multiple times in the sub method
+                if mail.model:
+                    model = self.env['ir.model'].sudo().search([('model', '=', mail.model)])[0]
+                else:
+                    model = None
+                if model:
+                    mail = mail.with_context(model_name=model.name)
+
+                # load attachment binary data with a separate read(), as prefetching all
+                # `datas` (binary field) could bloat the browse cache, triggerring
+                # soft/hard mem limits with temporary data.
+                attachments = [(a['datas_fname'], base64.b64decode(a['datas']))
+                               for a in mail.attachment_ids.sudo().read(['datas_fname', 'datas'])]
+
+                # specific behavior to customize the send email for notified partners
+                email_list = []
+                if mail.email_to:
+                    email_list.append(mail.send_get_email_dict())
+                for partner in mail.recipient_ids:
+                    email_list.append(mail.send_get_email_dict(partner=partner))
+
+                # headers
+                headers = {}
+                bounce_alias = self.env['ir.config_parameter'].get_param("mail.bounce.alias")
+                catchall_domain = self.env['ir.config_parameter'].get_param("mail.catchall.domain")
+                if bounce_alias and catchall_domain:
+                    if mail.model and mail.res_id:
+                        headers['Return-Path'] = '%s-%d-%s-%d@%s' % (bounce_alias, mail.id, mail.model, mail.res_id, catchall_domain)
+                    else:
+                        headers['Return-Path'] = '%s-%d@%s' % (bounce_alias, mail.id, catchall_domain)
+                if mail.headers:
+                    try:
+                        headers.update(eval(mail.headers))
+                    except Exception:
+                        pass
+
+                # Writing on the mail object may fail (e.g. lock on user) which
+                # would trigger a rollback *after* actually sending the email.
+                # To avoid sending twice the same email, provoke the failure earlier
+                mail.write({
+                    'state': 'exception',
+                    'failure_reason': _('Error without exception. Probably due do sending an email without computed recipients.'),
+                })
+                mail_sent = False
+
+                # build an RFC2822 email.message.Message object and send it without queuing
+                res = None
+                for email in email_list:
+                    msg = IrMailServer.build_email(
+                        email_from=mail.email_from,
+                        email_to=email.get('email_to'),
+                        subject=email.get('subject'),
+                        body=email.get('body'),
+                        body_alternative=email.get('body_alternative'),
+                        email_cc=tools.email_split(mail.email_cc),
+                        reply_to=mail.reply_to,
+                        attachments=attachments,
+                        message_id=mail.message_id,
+                        references=mail.references,
+                        object_id=mail.res_id and ('%s-%s' % (mail.res_id, mail.model)),
+                        subtype='html',
+                        subtype_alternative='plain',
+                        headers=headers)
+                    try:
+                        res = IrMailServer.send_email(msg, mail_server_id=mail.mail_server_id.id)
+                    except AssertionError as error:
+                        if error.message == IrMailServer.NO_VALID_RECIPIENT:
+                            # No valid recipient found for this particular
+                            # mail item -> ignore error to avoid blocking
+                            # delivery to next recipients, if any. If this is
+                            # the only recipient, the mail will show as failed.
+                            _logger.info("Ignoring invalid recipients for mail.mail %s: %s",
+                                         mail.message_id, email.get('email_to'))
+                        else:
+                            raise
+                if res:
+                    mail.write({'state': 'sent', 'message_id': res, 'failure_reason': False})
+                    mail_sent = True
+
+                # /!\ can't use mail.state here, as mail.refresh() will cause an error
+                # see revid:odo@openerp.com-20120622152536-42b2s28lvdv3odyr in 6.1
+                if mail_sent:
+                    _logger.info('Mail with ID %r and Message-Id %r successfully sent', mail.id, mail.message_id)
+                mail._postprocess_sent_message_v9(mail_sent=mail_sent)
+            except MemoryError:
+                # prevent catching transient MemoryErrors, bubble up to notify user or abort cron job
+                # instead of marking the mail as failed
+                _logger.exception(
+                    'MemoryError while processing mail with ID %r and Msg-Id %r. Consider raising the --limit-memory-hard startup option',
+                    mail.id, mail.message_id)
+                raise
+            except Exception as e:
+                failure_reason = tools.ustr(e)
+                _logger.exception('failed sending mail (id: %s) due to %s', mail.id, failure_reason)
+                mail.write({'state': 'exception', 'failure_reason': failure_reason})
+                mail._postprocess_sent_message_v9(mail_sent=False)
+                if raise_exception:
+                    if isinstance(e, AssertionError):
+                        # get the args of the original error, wrap into a value and throw a MailDeliveryException
+                        # that is an except_orm, with name and value as arguments
+                        value = '. '.join(e.args)
+                        raise MailDeliveryException(_("Mail Delivery Failed"), value)
+                    raise
+
+            if auto_commit is True:
+                self._cr.commit()
+        return True

--- a/None
+++ b/addons/mail/models/mail_message.py
@@ -0,0 +1,845 @@
+# -*- coding: utf-8 -*-
+
+from email.header import decode_header
+from email.utils import formataddr
+import logging
+
+from openerp import _, api, fields, models, SUPERUSER_ID
+from openerp import tools
+from openerp.exceptions import UserError, AccessError
+
+
+_logger = logging.getLogger(__name__)
+
+
+def decode(text):
+    """Returns unicode() string conversion of the the given encoded smtp header text"""
+    # TDE proposal: move to tools ?
+    if text:
+        text = decode_header(text.replace('\r', ''))
+        return ''.join([tools.ustr(x[0], x[1]) for x in text])
+
+
+class Message(models.Model):
+    """ Messages model: system notification (replacing res.log notifications),
+        comments (OpenChatter discussion) and incoming emails. """
+    _name = 'mail.message'
+    _description = 'Message'
+    _inherit = ['ir.needaction_mixin']
+    _order = 'id desc'
+    _rec_name = 'record_name'
+
+    _message_read_limit = 30
+    _message_read_fields = ['id', 'parent_id', 'model', 'res_id', 'body', 'subject', 'date', 'to_read', 'email_from',
+        'message_type', 'vote_user_ids', 'attachment_ids', 'author_id', 'partner_ids', 'record_name']
+    _message_record_name_length = 18
+    _message_read_more_limit = 1024
+
+    @api.model
+    def _get_default_from(self):
+        if self.env.user.alias_name and self.env.user.alias_domain:
+            return formataddr((self.env.user.name, '%s@%s' % (self.env.user.alias_name, self.env.user.alias_domain)))
+        elif self.env.user.email:
+            return formataddr((self.env.user.name, self.env.user.email))
+        raise UserError(_("Unable to send email, please configure the sender's email address or alias."))
+
+    @api.model
+    def _get_default_author(self):
+        return self.env.user.partner_id.id
+
+    message_type = fields.Selection([
+        ('email', 'Email'),
+        ('comment', 'Comment'),
+        ('notification', 'System notification')],
+        'Type', required=True, default='email',
+        help="Message type: email for email message, notification for system "
+             "message, comment for other messages such as user replies",
+        oldname='type')
+    email_from = fields.Char('From', default=_get_default_from,
+                             help="Email address of the sender. This field is set when no matching partner is found for incoming emails.")
+    reply_to = fields.Char('Reply-To', help='Reply email address. Setting the reply_to bypasses the automatic thread creation.')
+    no_auto_thread = fields.Boolean('No threading for answers', help='Answers do not go in the original document\' discussion thread. This has an impact on the generated message-id.')
+    author_id = fields.Many2one(
+        'res.partner', 'Author', select=1,
+        ondelete='set null', default=_get_default_author,
+        help="Author of the message. If not set, email_from may hold an email address that did not match any partner.")
+    author_avatar = fields.Binary("Author's avatar", related='author_id.image_small')
+    partner_ids = fields.Many2many('res.partner', string='Recipients')
+    notified_partner_ids = fields.Many2many(
+        'res.partner', 'mail_notification',
+        'message_id', 'partner_id', 'Notified partners',
+        help='Partners that have a notification pushing this message in their mailboxes')
+    attachment_ids = fields.Many2many(
+        'ir.attachment', 'message_attachment_rel',
+        'message_id', 'attachment_id', 'Attachments')
+    parent_id = fields.Many2one(
+        'mail.message', 'Parent Message', select=True,
+        ondelete='set null', help="Initial thread message.")
+    child_ids = fields.One2many('mail.message', 'parent_id', 'Child Messages')
+    model = fields.Char('Related Document Model', select=1)
+    res_id = fields.Integer('Related Document ID', select=1)
+    record_name = fields.Char('Message Record Name', help="Name get of the related document.")
+    notification_ids = fields.One2many(
+        'mail.notification', 'message_id',
+        string='Notifications', auto_join=True,
+        help='Technical field holding the message notifications. Use notified_partner_ids to access notified partners.')
+    subject = fields.Char('Subject')
+    date = fields.Datetime('Date', default=fields.Datetime.now)
+    message_id = fields.Char('Message-Id', help='Message unique identifier', select=1, readonly=1, copy=False)
+    body = fields.Html('Contents', default='', help='Automatically sanitized HTML contents')
+    to_read = fields.Boolean(
+        'To read', compute='_get_to_read', search='_search_to_read',
+        help='Current user has an unread notification linked to this message')
+    starred = fields.Boolean(
+        'Starred', compute='_get_starred', search='_search_starred',
+        help='Current user has a starred notification linked to this message')
+    subtype_id = fields.Many2one('mail.message.subtype', 'Subtype', ondelete='set null', select=1)
+    vote_user_ids = fields.Many2many(
+        'res.users', 'mail_vote', 'message_id', 'user_id', string='Votes',
+        help='Users that voted for this message')
+    mail_server_id = fields.Many2one('ir.mail_server', 'Outgoing mail server', readonly=1)
+
+    @api.depends('notification_ids')
+    def _get_to_read(self):
+        """ Compute if the message is unread by the current user. """
+        partner_id = self.env.user.partner_id.id
+        notifications = self.env['mail.notification'].sudo().search([
+            ('partner_id', '=', partner_id),
+            ('message_id', 'in', self.ids),
+            ('is_read', '=', False)])
+        for message in self:
+            message.to_read = message in notifications.mapped('message_id')
+
+    def _search_to_read(self, operator, operand):
+        """ Search for messages to read by the current user. Condition is
+        inversed because we search unread message on a is_read column. """
+        return ['&', ('notification_ids.partner_id.user_ids', 'in', [self.env.uid]), ('notification_ids.is_read', operator, not operand)]
+
+    @api.depends('notification_ids')
+    def _get_starred(self):
+        """ Compute if the message is starred by the current user. """
+        partner_id = self.env.user.partner_id.id
+        notifications = self.env['mail.notification'].sudo().search([
+            ('partner_id', '=', partner_id),
+            ('message_id', 'in', self.ids),
+            ('starred', '=', True)])
+        for message in self:
+            message.starred = message in notifications.mapped('message_id')
+
+    def _search_starred(self, operator, operand):
+        """ Search for starred messages by the current user."""
+        return ['&', ('notification_ids.partner_id.user_ids', 'in', [self.env.uid]), ('notification_ids.starred', operator, operand)]
+
+    @api.model
+    def _needaction_domain_get(self):
+        return [('to_read', '=', True)]
+
+    #------------------------------------------------------
+    # Vote/Like
+    #------------------------------------------------------
+
+    @api.multi
+    def vote_toggle(self):
+        ''' Toggles vote. Performed using read to avoid access rights issues. '''
+        for message in self.sudo():
+            new_has_voted = not (self._uid in message.vote_user_ids.ids)
+            if new_has_voted:
+                self.browse(message.id).write({'vote_user_ids': [(4, self._uid)]})  # tde: todo with user access rights
+            else:
+                self.browse(message.id).write({'vote_user_ids': [(3, self._uid)]})  # tde: todo with user access rights
+        return new_has_voted or False
+
+    #------------------------------------------------------
+    # download an attachment
+    #------------------------------------------------------
+
+    @api.multi
+    def download_attachment(self, attachment_id):
+        self.ensure_one()
+        if attachment_id in self.attachment_ids.ids:
+            attachment = self.env['ir.attachment'].sudo().browse(attachment_id)
+            if attachment.datas and attachment.datas_fname:
+                return {
+                    'base64': attachment.datas,
+                    'filename': attachment.datas_fname,
+                }
+        return False
+
+    #------------------------------------------------------
+    # Notification API
+    #------------------------------------------------------
+
+    @api.multi
+    def set_message_read(self, read, create_missing=True):
+        """ Set messages as (un)read. Technically, the notifications related
+            to uid are set to (un)read. If for some msg_ids there are missing
+            notifications (i.e. due to load more or thread parent fetching),
+            they are created.
+
+            :param bool read: set notification as (un)read
+            :param bool create_missing: create notifications for missing entries
+                (i.e. when acting on displayed messages not notified)
+
+            :return number of message mark as read
+        """
+        notifications = self.env['mail.notification'].search([
+            ('partner_id', '=', self.env.user.partner_id.id),
+            ('message_id', 'in', self.ids),
+            ('is_read', '=', not read)])
+        notifications.write({'is_read': read})
+
+        # some messages do not have notifications: find which one, create notification, update read status
+        if len(notifications) < len(self) and create_missing:
+            for message in self - notifications.mapped('message_id'):
+                self.env['mail.notification'].create({'partner_id': self.env.user.partner_id.id, 'is_read': read, 'message_id': message.id})
+
+        return len(notifications)
+
+    @api.multi
+    def set_message_starred(self, starred, create_missing=True):
+        """ Set messages as (un)starred. Technically, the notifications related
+            to uid are set to (un)starred.
+
+            :param bool starred: set notification as (un)starred
+            :param bool create_missing: create notifications for missing entries
+                (i.e. when acting on displayed messages not notified)
+        """
+        values = {'starred': starred}
+        if starred:
+            values['is_read'] = False
+        notifications = self.env['mail.notification'].search([
+            ('partner_id', '=', self.env.user.partner_id.id),
+            ('message_id', 'in', self.ids),
+            ('starred', '=', not starred)])
+        notifications.write(values)
+
+        # some messages do not have notifications: find which one, create notification, update starred status
+        if len(notifications) < len(self) and create_missing:
+            values['partner_id'] = self.env.user.partner_id.id
+            for message in self - notifications.mapped('message_id'):
+                values['message_id'] = message.id
+                self.env['mail.notification'].create(values)
+
+        return starred
+
+    #------------------------------------------------------
+    # Message loading for web interface
+    #------------------------------------------------------
+
+    @api.model
+    def _message_read_dict_postprocess(self, messages, message_tree):
+        """ Post-processing on values given by message_read. This method will
+            handle partners in batch to avoid doing numerous queries.
+
+            :param list messages: list of message, as get_dict result
+            :param dict message_tree: {[msg.id]: msg browse record}
+        """
+        pid = self.env.user.partner_id.id
+
+        # 1. Aggregate partners (author_id and partner_ids) and attachments
+        partner_ids = set()
+        attachment_ids = set()
+        for key, message in message_tree.iteritems():
+            if message.author_id:
+                partner_ids |= set([message.author_id.id])
+            if message.subtype_id and message.notified_partner_ids:  # take notified people of message with a subtype
+                partner_ids |= set([partner.id for partner in message.notified_partner_ids])
+            elif not message.subtype_id and message.partner_ids:  # take specified people of message without a subtype (log)
+                partner_ids |= set([partner.id for partner in message.partner_ids])
+            if message.attachment_ids:
+                attachment_ids |= set([attachment.id for attachment in message.attachment_ids])
+        # Read partners as SUPERUSER -> display the names like classic m2o even if no access
+        partners = self.env['res.partner'].sudo().browse(partner_ids).name_get()
+        partner_tree = dict((partner[0], partner) for partner in partners)
+
+        # 2. Attachments as SUPERUSER, because could receive msg and attachments for doc uid cannot see
+        attachments = self.env['ir.attachment'].sudo().browse(attachment_ids).read(['id', 'datas_fname', 'name', 'file_type_icon'])
+        attachments_tree = dict((attachment['id'], {
+            'id': attachment['id'],
+            'filename': attachment['datas_fname'],
+            'name': attachment['name'],
+            'file_type_icon': attachment['file_type_icon'],
+        }) for attachment in attachments)
+
+        # 3. Update message dictionaries
+        for message_dict in messages:
+            message_id = message_dict.get('id')
+            message = message_tree[message_id]
+            if message.author_id:
+                author = partner_tree[message.author_id.id]
+            else:
+                author = (0, message.email_from)
+            partner_ids = []
+            if message.subtype_id:
+                partner_ids = [partner_tree[partner.id] for partner in message.notified_partner_ids
+                                if partner.id in partner_tree]
+            else:
+                partner_ids = [partner_tree[partner.id] for partner in message.partner_ids
+                                if partner.id in partner_tree]
+            attachment_ids = []
+            for attachment in message.attachment_ids:
+                if attachment.id in attachments_tree:
+                    attachment_ids.append(attachments_tree[attachment.id])
+            message_dict.update({
+                'is_author': pid == author[0],
+                'author_id': author,
+                'partner_ids': partner_ids,
+                'attachment_ids': attachment_ids,
+                'user_pid': pid
+                })
+        return True
+
+    @api.multi
+    def _message_read_dict(self, parent_id=False):
+        """ Return a dict representation of the message. This representation is
+            used in the JS client code, to display the messages. Partners and
+            attachments related stuff will be done in post-processing in batch.
+
+            :param dict message: mail.message browse record
+        """
+        self.ensure_one()
+        # private message: no model, no res_id
+        is_private = False
+        if not self.model or not self.res_id:
+            is_private = True
+        # votes and favorites: res.users ids, no prefetching should be done
+        vote_nb = len(self.vote_user_ids)
+        has_voted = self._uid in [user.id for user in self.vote_user_ids]
+
+        try:
+            if parent_id:
+                max_length = 300
+            else:
+                max_length = 100
+            body_short = tools.html_email_clean(self.body, remove=False, shorten=True, max_length=max_length)
+
+        except Exception:
+            body_short = '<p><b>Encoding Error : </b><br/>Unable to convert this message (id: %s).</p>' % self.id
+            _logger.exception(Exception)
+
+        return {'id': self.id,
+                'type': self.message_type,
+                'subtype': self.subtype_id.name if self.subtype_id else False,
+                'body': self.body,
+                'body_short': body_short,
+                'model': self.model,
+                'res_id': self.res_id,
+                'record_name': self.record_name,
+                'subject': self.subject,
+                'date': self.date,
+                'to_read': self.to_read,
+                'parent_id': parent_id,
+                'is_private': is_private,
+                'author_id': False,
+                'author_avatar': self.author_avatar,
+                'is_author': False,
+                'partner_ids': [],
+                'vote_nb': vote_nb,
+                'has_voted': has_voted,
+                'is_favorite': self.starred,
+                'attachment_ids': [],
+            }
+
+    @api.model
+    def _message_read_add_expandables(self, messages, message_tree, parent_tree,
+            message_unload_ids=[], thread_level=0, domain=[], parent_id=False):
+        """ Create expandables for message_read, to load new messages.
+            1. get the expandable for new threads
+                if display is flat (thread_level == 0):
+                    fetch message_ids < min(already displayed ids), because we
+                    want a flat display, ordered by id
+                else:
+                    fetch message_ids that are not childs of already displayed
+                    messages
+            2. get the expandables for new messages inside threads if display
+               is not flat
+                for each thread header, search for its childs
+                    for each hole in the child list based on message displayed,
+                    create an expandable
+
+            :param list messages: list of message structure for the Chatter
+                widget to which expandables are added
+            :param dict message_tree: dict [id]: browse record of this message
+            :param dict parent_tree: dict [parent_id]: [child_ids]
+            :param list message_unload_ids: list of message_ids we do not want
+                to load
+            :return bool: True
+        """
+        def _get_expandable(domain, message_nb, parent_id, max_limit):
+            return {
+                'domain': domain,
+                'nb_messages': message_nb,
+                'type': 'expandable',
+                'parent_id': parent_id,
+                'max_limit':  max_limit,
+            }
+
+        if not messages:
+            return True
+        message_ids = sorted(message_tree.keys())
+
+        # 1. get the expandable for new threads
+        if thread_level == 0:
+            exp_domain = domain + [('id', '<', min(message_unload_ids + message_ids))]
+        else:
+            exp_domain = domain + ['!', ('id', 'child_of', message_unload_ids + parent_tree.keys())]
+        more_count = self.search_count(exp_domain)
+        if more_count:
+            # inside a thread: prepend
+            if parent_id:
+                messages.insert(0, _get_expandable(exp_domain, -1, parent_id, True))
+            # new threads: append
+            else:
+                messages.append(_get_expandable(exp_domain, -1, parent_id, True))
+
+        # 2. get the expandables for new messages inside threads if display is not flat
+        if thread_level == 0:
+            return True
+        for message_id in message_ids:
+            message = message_tree[message_id]
+
+            # generate only for thread header messages (TDE note: parent_id may be False is uid cannot see parent_id, seems ok)
+            if message.parent_id:
+                continue
+
+            # check there are message for expandable
+            child_ids = set([child.id for child in message.child_ids]) - set(message_unload_ids)
+            child_ids = sorted(list(child_ids), reverse=True)
+            if not child_ids:
+                continue
+
+            # make groups of unread messages
+            id_min, id_max, nb = max(child_ids), 0, 0
+            for child_id in child_ids:
+                if not child_id in message_ids:
+                    nb += 1
+                    if id_min > child_id:
+                        id_min = child_id
+                    if id_max < child_id:
+                        id_max = child_id
+                elif nb > 0:
+                    exp_domain = [('id', '>=', id_min), ('id', '<=', id_max), ('id', 'child_of', message_id)]
+                    idx = [msg.get('id') for msg in messages].index(child_id) + 1
+                    # messages.append(_get_expandable(exp_domain, nb, message_id, False))
+                    messages.insert(idx, _get_expandable(exp_domain, nb, message_id, False))
+                    id_min, id_max, nb = max(child_ids), 0, 0
+                else:
+                    id_min, id_max, nb = max(child_ids), 0, 0
+            if nb > 0:
+                exp_domain = [('id', '>=', id_min), ('id', '<=', id_max), ('id', 'child_of', message_id)]
+                idx = [msg.get('id') for msg in messages].index(message_id) + 1
+                # messages.append(_get_expandable(exp_domain, nb, message_id, id_min))
+                messages.insert(idx, _get_expandable(exp_domain, nb, message_id, False))
+
+        return True
+
+    @api.cr_uid_context
+    def message_read_wrapper(self, cr, uid, ids=None, domain=None, message_unload_ids=None,
+                        thread_level=0, context=None, parent_id=False, limit=None):
+        return self.message_read(cr, uid, ids, domain=domain, message_unload_ids=message_unload_ids, thread_level=thread_level, parent_id=parent_id, limit=limit)
+
+    @api.multi
+    def message_read(self, domain=None, message_unload_ids=None, thread_level=0, parent_id=False, limit=None):
+        """ Read messages from mail.message, and get back a list of structured
+            messages to be displayed as discussion threads. If IDs is set,
+            fetch these records. Otherwise use the domain to fetch messages.
+            After having fetch messages, their ancestors will be added to obtain
+            well formed threads, if uid has access to them.
+
+            After reading the messages, expandable messages are added in the
+            message list (see ``_message_read_add_expandables``). It consists
+            in messages holding the 'read more' data: number of messages to
+            read, domain to apply.
+
+            :param list ids: optional IDs to fetch
+            :param list domain: optional domain for searching ids if ids not set
+            :param list message_unload_ids: optional ids we do not want to fetch,
+                because i.e. they are already displayed somewhere
+            :param int parent_id: context of parent_id
+                - if parent_id reached when adding ancestors, stop going further
+                  in the ancestor search
+                - if set in flat mode, ancestor_id is set to parent_id
+            :param int limit: number of messages to fetch, before adding the
+                ancestors and expandables
+            :return list: list of message structure for the Chatter widget
+        """
+        assert thread_level in [0, 1], 'message_read() thread_level should be 0 (flat) or 1 (1 level of thread); given %s.' % thread_level
+        domain = domain if domain is not None else []
+        message_unload_ids = message_unload_ids if message_unload_ids is not None else []
+        if message_unload_ids:
+            domain += [('id', 'not in', message_unload_ids)]
+        limit = limit or self._message_read_limit
+        message_tree = {}
+        message_list = []
+        parent_tree = {}
+
+        # no specific IDS given: fetch messages according to the domain, add their parents if uid has access to
+        if not self.ids and domain:
+            self = self.search(domain, limit=limit)
+
+        # fetch parent if threaded, sort messages
+        for message in self:
+            message_id = message.id
+            if message_id in message_tree:
+                continue
+            message_tree[message_id] = message
+
+            # find parent_id
+            if thread_level == 0:
+                tree_parent_id = parent_id
+            else:
+                tree_parent_id = message_id
+                parent = message
+                while parent.parent_id and parent.parent_id.id != parent_id:
+                    parent = parent.parent_id
+                    tree_parent_id = parent.id
+                if parent.id not in message_tree:
+                    message_tree[parent.id] = parent
+            # newest messages first
+            parent_tree.setdefault(tree_parent_id, [])
+            if tree_parent_id != message_id:
+                parent_tree[tree_parent_id].append(message_tree[message_id]._message_read_dict(parent_id=tree_parent_id))
+
+        if thread_level:
+            for key, message_id_list in parent_tree.iteritems():
+                message_id_list.sort(key=lambda item: item['id'])
+                message_id_list.insert(0, message_tree[key]._message_read_dict())
+
+        # create final ordered message_list based on parent_tree
+        parent_list = parent_tree.items()
+        parent_list = sorted(parent_list, key=lambda item: max([msg.get('id') for msg in item[1]]) if item[1] else item[0], reverse=True)
+        message_list = [message for (key, msg_list) in parent_list for message in msg_list]
+
+        # get the child expandable messages for the tree
+        self._message_read_dict_postprocess(message_list, message_tree)
+        self._message_read_add_expandables(message_list, message_tree, parent_tree,
+            thread_level=thread_level, message_unload_ids=message_unload_ids, domain=domain, parent_id=parent_id)
+        return message_list
+
+    @api.multi
+    def get_like_names(self, limit=10):
+        """ Return the people list who liked this message. """
+        self.ensure_one()
+        voter_names = [voter.name for voter in self.vote_user_ids[:limit]]
+        if len(self.vote_user_ids) > limit:
+            voter_names.append(_("and %s others like this") % (len(self.vote_user_ids) - limit))
+        return voter_names
+    # compat
+    get_likers_list = get_like_names
+
+    #------------------------------------------------------
+    # mail_message internals
+    #------------------------------------------------------
+
+    def init(self, cr):
+        cr.execute("""SELECT indexname FROM pg_indexes WHERE indexname = 'mail_message_model_res_id_idx'""")
+        if not cr.fetchone():
+            cr.execute("""CREATE INDEX mail_message_model_res_id_idx ON mail_message (model, res_id)""")
+
+    @api.model
+    def _find_allowed_model_wise(self, doc_model, doc_dict):
+        doc_ids = doc_dict.keys()
+        allowed_doc_ids = self.env[doc_model].with_context(active_test=False).search([('id', 'in', doc_ids)]).ids
+        return set([message_id for allowed_doc_id in allowed_doc_ids for message_id in doc_dict[allowed_doc_id]])
+
+    @api.model
+    def _find_allowed_doc_ids(self, model_ids):
+        IrModelAccess = self.env['ir.model.access']
+        allowed_ids = set()
+        for doc_model, doc_dict in model_ids.iteritems():
+            if not IrModelAccess.check(doc_model, 'read', False):
+                continue
+            allowed_ids |= self._find_allowed_model_wise(doc_model, doc_dict)
+        return allowed_ids
+
+    @api.model
+    def _search(self, args, offset=0, limit=None, order=None, count=False, access_rights_uid=None):
+        """ Override that adds specific access rights of mail.message, to remove ids uid could not see according to our custom rules. Please refer to check_access_rule for more details about those rules.
+
+            Non employees users see only message with subtype (aka do not see
+            internal logs).
+
+        After having received ids of a classic search, keep only:
+        - if author_id == pid, uid is the author, OR
+        - a notification (id, pid) exists, uid has been notified, OR
+        - uid have read access to the related document is model, res_id
+        - otherwise: remove the id
+        """
+        # Rules do not apply to administrator
+        if self._uid == SUPERUSER_ID:
+            return super(Message, self)._search(
+                args, offset=offset, limit=limit, order=order,
+                count=count, access_rights_uid=access_rights_uid)
+        # Non-employee see only messages with a subtype (aka, no internal logs)
+        if not self.env['res.users'].has_group('base.group_user'):
+            args = ['&', ('subtype_id', '!=', False)] + list(args)
+        # Perform a super with count as False, to have the ids, not a counter
+        ids = super(Message, self)._search(
+            args, offset=offset, limit=limit, order=order,
+            count=False, access_rights_uid=access_rights_uid)
+        if not ids and count:
+            return 0
+        elif not ids:
+            return ids
+
+        pid = self.env.user.partner_id.id
+        author_ids, partner_ids, allowed_ids = set([]), set([]), set([])
+        model_ids = {}
+
+        # check read access rights before checking the actual rules on the given ids
+        super(Message, self.sudo(access_rights_uid or self._uid)).check_access_rights('read')
+
+        self._cr.execute("""SELECT DISTINCT m.id, m.model, m.res_id, m.author_id, n.partner_id
+            FROM "%s" m LEFT JOIN "mail_notification" n
+            ON n.message_id=m.id AND n.partner_id = (%%s)
+            WHERE m.id = ANY (%%s)""" % self._table, (pid, ids,))
+        for id, rmod, rid, author_id, partner_id in self._cr.fetchall():
+            if author_id == pid:
+                author_ids.add(id)
+            elif partner_id == pid:
+                partner_ids.add(id)
+            elif rmod and rid:
+                model_ids.setdefault(rmod, {}).setdefault(rid, set()).add(id)
+
+        allowed_ids = self._find_allowed_doc_ids(model_ids)
+        final_ids = author_ids | partner_ids | allowed_ids
+
+        if count:
+            return len(final_ids)
+        else:
+            # re-construct a list based on ids, because set did not keep the original order
+            id_list = [id for id in ids if id in final_ids]
+            return id_list
+
+    @api.multi
+    def check_access_rule(self, operation):
+        """ Access rules of mail.message:
+            - read: if
+                - author_id == pid, uid is the author, OR
+                - mail_notification (id, pid) exists, uid has been notified, OR
+                - uid have read access to the related document if model, res_id
+                - otherwise: raise
+            - create: if
+                - no model, no res_id, I create a private message OR
+                - pid in message_follower_ids if model, res_id OR
+                - mail_notification (parent_id.id, pid) exists, uid has been notified of the parent, OR
+                - uid have write or create access on the related document if model, res_id, OR
+                - otherwise: raise
+            - write: if
+                - author_id == pid, uid is the author, OR
+                - uid has write or create access on the related document if model, res_id
+                - otherwise: raise
+            - unlink: if
+                - uid has write or create access on the related document if model, res_id
+                - otherwise: raise
+
+        Specific case: non employee users see only messages with subtype (aka do
+        not see internal logs).
+        """
+        def _generate_model_record_ids(msg_val, msg_ids):
+            """ :param model_record_ids: {'model': {'res_id': (msg_id, msg_id)}, ... }
+                :param message_values: {'msg_id': {'model': .., 'res_id': .., 'author_id': ..}}
+            """
+            model_record_ids = {}
+            for id in msg_ids:
+                vals = msg_val.get(id, {})
+                if vals.get('model') and vals.get('res_id'):
+                    model_record_ids.setdefault(vals['model'], set()).add(vals['res_id'])
+            return model_record_ids
+
+        if self._uid == SUPERUSER_ID:
+            return
+        # Non employees see only messages with a subtype (aka, not internal logs)
+        if not self.env['res.users'].has_group('base.group_user'):
+            self._cr.execute('SELECT DISTINCT id FROM "%s" WHERE message_type = %%s AND subtype_id IS NULL AND id = ANY (%%s)' % (self._table), ('comment', self.ids,))
+            if self._cr.fetchall():
+                raise AccessError(
+                    _('The requested operation cannot be completed due to security restrictions. Please contact your system administrator.\n\n(Document type: %s, Operation: %s)') %
+                    (self._description, operation))
+
+        Notification = self.env['mail.notification']
+        Followers = self.env['mail.followers']
+        partner_id = self.env.user.partner_id.id
+
+        # Read mail_message.ids to have their values
+        message_values = dict((res_id, {}) for res_id in self.ids)
+        self._cr.execute('SELECT DISTINCT id, model, res_id, author_id, parent_id FROM "%s" WHERE id = ANY (%%s)' % self._table, (self.ids,))
+        for mid, rmod, rid, author_id, parent_id in self._cr.fetchall():
+            message_values[mid] = {'model': rmod, 'res_id': rid, 'author_id': author_id, 'parent_id': parent_id}
+
+        # Author condition (READ, WRITE, CREATE (private)) -> could become an ir.rule ?
+        author_ids = []
+        if operation == 'read' or operation == 'write':
+            author_ids = [mid for mid, message in message_values.iteritems()
+                          if message.get('author_id') and message.get('author_id') == partner_id]
+        elif operation == 'create':
+            author_ids = [mid for mid, message in message_values.iteritems()
+                          if not message.get('model') and not message.get('res_id')]
+
+        # Parent condition, for create (check for received notifications for the created message parent)
+        notified_ids = []
+        if operation == 'create':
+            parent_ids = [message.get('parent_id') for mid, message in message_values.iteritems()
+                          if message.get('parent_id')]
+            notifications = Notification.sudo().search([('message_id.id', 'in', parent_ids), ('partner_id', '=', partner_id)])
+            not_parent_ids = [notif.message_id.id for notif in notifications]
+            notified_ids += [mid for mid, message in message_values.iteritems()
+                             if message.get('parent_id') in not_parent_ids]
+
+        # Notification condition, for read (check for received notifications and create (in message_follower_ids)) -> could become an ir.rule, but not till we do not have a many2one variable field
+        other_ids = set(self.ids).difference(set(author_ids), set(notified_ids))
+        model_record_ids = _generate_model_record_ids(message_values, other_ids)
+        if operation == 'read':
+            notifications = Notification.sudo().search([
+                ('partner_id', '=', partner_id),
+                ('message_id', 'in', self.ids)])
+            notified_ids = [notification.message_id.id for notification in notifications]
+        elif operation == 'create':
+            for doc_model, doc_ids in model_record_ids.items():
+                followers = Followers.sudo().search([
+                    ('res_model', '=', doc_model),
+                    ('res_id', 'in', list(doc_ids)),
+                    ('partner_id', '=', partner_id)])
+                fol_mids = [follower.res_id for follower in followers]
+                notified_ids += [mid for mid, message in message_values.iteritems()
+                                 if message.get('model') == doc_model and message.get('res_id') in fol_mids]
+
+        # CRUD: Access rights related to the document
+        other_ids = other_ids.difference(set(notified_ids))
+        model_record_ids = _generate_model_record_ids(message_values, other_ids)
+        document_related_ids = []
+        for model, doc_ids in model_record_ids.items():
+            DocumentModel = self.env[model]
+            mids = DocumentModel.browse(doc_ids).exists()
+            if hasattr(DocumentModel, 'check_mail_message_access'):
+                DocumentModel.check_mail_message_access(mids.ids, operation)  # ?? mids ?
+            else:
+                self.env['mail.thread'].check_mail_message_access(mids.ids, operation, model_name=model)
+            document_related_ids += [mid for mid, message in message_values.iteritems()
+                                     if message.get('model') == model and message.get('res_id') in mids.ids]
+
+        # Calculate remaining ids: if not void, raise an error
+        other_ids = other_ids.difference(set(document_related_ids))
+        if not other_ids:
+            return
+        raise AccessError(
+            _('The requested operation cannot be completed due to security restrictions. Please contact your system administrator.\n\n(Document type: %s, Operation: %s)') %
+            (self._description, operation))
+
+    @api.model
+    def _get_record_name(self, values):
+        """ Return the related document name, using name_get. It is done using
+            SUPERUSER_ID, to be sure to have the record name correctly stored. """
+        model = values.get('model', self.env.context.get('default_model'))
+        res_id = values.get('res_id', self.env.context.get('default_res_id'))
+        if not model or not res_id or model not in self.pool:
+            return False
+        return self.env[model].sudo().browse(res_id).name_get()[0][1]
+
+    @api.model
+    def _get_reply_to(self, values):
+        """ Return a specific reply_to: alias of the document through
+        message_get_reply_to or take the email_from """
+        model, res_id, email_from = values.get('model', self._context.get('default_model')), values.get('res_id', self._context.get('default_res_id')), values.get('email_from')  # ctx values / defualt_get res ?
+        if model:
+            # return self.env[model].browse(res_id).message_get_reply_to([res_id], default=email_from)[res_id]
+            return self.env[model].message_get_reply_to([res_id], default=email_from)[res_id]
+        else:
+            # return self.env['mail.thread'].message_get_reply_to(default=email_from)[None]
+            return self.env['mail.thread'].message_get_reply_to([None], default=email_from)[None]
+
+    @api.model
+    def _get_message_id(self, values):
+        if values.get('no_auto_thread', False) is True:
+            message_id = tools.generate_tracking_message_id('reply_to')
+        elif values.get('res_id') and values.get('model'):
+            message_id = tools.generate_tracking_message_id('%(res_id)s-%(model)s' % values)
+        else:
+            message_id = tools.generate_tracking_message_id('private')
+        return message_id
+
+    @api.model
+    def create(self, values):
+        default_starred = self.env.context.get('default_starred')
+
+        if 'email_from' not in values:  # needed to compute reply_to
+            values['email_from'] = self._get_default_from()
+        if not values.get('message_id'):
+            values['message_id'] = self._get_message_id(values)
+        if 'reply_to' not in values:
+            values['reply_to'] = self._get_reply_to(values)
+        if 'record_name' not in values and 'default_record_name' not in self.env.context:
+            values['record_name'] = self._get_record_name(values)
+
+        message = super(Message, self).create(values)
+
+        message._notify(force_send=self.env.context.get('mail_notify_force_send', True),
+                        user_signature=self.env.context.get('mail_notify_user_signature', True))
+        # TDE FIXME: handle default_starred. Why not setting an inv on starred ?
+        # Because starred will call set_message_starred, that looks for notifications.
+        # When creating a new mail_message, it will create a notification to a message
+        # that does not exist, leading to an error (key not existing). Also this
+        # this means unread notifications will be created, yet we can not assure
+        # this is what we want.
+        if default_starred:
+            message.set_message_starred(True)
+        return message
+
+    @api.multi
+    def read(self, fields=None, load='_classic_read'):
+        """ Override to explicitely call check_access_rule, that is not called
+            by the ORM. It instead directly fetches ir.rules and apply them. """
+        self.check_access_rule('read')
+        return super(Message, self).read(fields=fields, load=load)
+
+    @api.multi
+    def unlink(self):
+        # cascade-delete attachments that are directly attached to the message (should only happen
+        # for mail.messages that act as parent for a standalone mail.mail record).
+        self.check_access_rule('unlink')
+        self.mapped('attachment_ids').filtered(
+            lambda attach: attach.res_model == self._name and (attach.res_id in self.ids or attach.res_id == 0)
+        ).unlink()
+        return super(Message, self).unlink()
+
+    #------------------------------------------------------
+    # Messaging API
+    #------------------------------------------------------
+
+    @api.multi
+    def _notify(self, force_send=False, user_signature=True):
+        """ Add the related record followers to the destination partner_ids if is not a private message.
+            Call mail_notification.notify to manage the email sending
+        """
+        self.ensure_one()  # tde: not sure, just for testinh, will see
+        partners_to_notify = self.env['res.partner']
+
+        # all followers of the mail.message document have to be added as partners and notified if a subtype is defined (otherwise: log message)
+        if self.subtype_id and self.model and self.res_id:
+            followers = self.env['mail.followers'].sudo().search([('res_model', '=', self.model), ('res_id', '=', self.res_id)])
+            partners_to_notify |= followers.filtered(lambda fol: self.subtype_id in fol.subtype_ids).mapped('partner_id')
+
+        # remove me from notified partners, unless the message is written on my own wall
+        if self.subtype_id and self.author_id and self.model == "res.partner" and self.res_id == self.author_id.id:
+            partners_to_notify |= self.author_id
+        elif self.author_id:
+            partners_to_notify -= self.author_id
+
+        # all partner_ids of the mail.message have to be notified regardless of the above (even the author if explicitly added!)
+        partners_to_notify |= self.partner_ids
+
+        # notify
+        self.env['mail.notification']._notify(self, recipients=partners_to_notify, force_send=force_send, user_signature=user_signature)
+
+        # An error appear when a user receive a notification without notifying
+        # the parent message -> add a read notification for the parent
+        if self.parent_id:
+            # all notified_partner_ids of the mail.message have to be notified for the parented messages
+            partners_to_parent_notify = self.notified_partner_ids - self.parent_id.notified_partner_ids
+            self.parent_id.invalidate_cache()  # avoid access rights issues, as notifications are used for access
+            Notification = self.env['mail.notification'].sudo()
+            for partner in partners_to_parent_notify:
+                Notification.create({
+                    'message_id': self.parent_id.id,
+                    'partner_id': partner.id,
+                    'is_read': True})

--- a/None
+++ b/addons/mail/models/mail_message_subtype.py
@@ -0,0 +1,36 @@
+# -*- coding: utf-8 -*-
+
+from openerp import fields, models
+
+
+class MailMessageSubtype(models.Model):
+    """ Class holding subtype definition for messages. Subtypes allow to tune
+        the follower subscription, allowing only some subtypes to be pushed
+        on the Wall. """
+    _name = 'mail.message.subtype'
+    _description = 'Message subtypes'
+    _order = 'sequence, id'
+
+    name = fields.Char(
+        'Message Type', required=True, translate=True,
+        help='Message subtype gives a more precise type on the message, '
+             'especially for system notifications. For example, it can be '
+             'a notification related to a new record (New), or to a stage '
+             'change in a process (Stage change). Message subtypes allow to '
+             'precisely tune the notifications the user want to receive on its wall.')
+    description = fields.Text(
+        'Description', translate=True,
+        help='Description that will be added in the message posted for this '
+             'subtype. If void, the name will be added instead.')
+    parent_id = fields.Many2one(
+        'mail.message.subtype', string='Parent', ondelete='set null',
+        help='Parent subtype, used for automatic subscription.')
+    relation_field = fields.Char(
+        'Relation field',
+        help='Field used to link the related model to the subtype model when '
+             'using automatic subscription on a related document. The field '
+             'is used to compute getattr(related_document.relation_field).')
+    res_model = fields.Char('Model', help="Model the subtype applies to. If False, this subtype applies to all models.")
+    default = fields.Boolean('Default', default=True, help="Activated by default when subscribing.")
+    sequence = fields.Integer('Sequence', default=1, help="Used to order subtypes.")
+    hidden = fields.Boolean('Hidden', help="Hide the subtype in the follower options")

--- a/None
+++ b/addons/mail/models/mail_template.py
@@ -0,0 +1,564 @@
+# -*- coding: utf-8 -*-
+
+import base64
+import datetime
+import dateutil.relativedelta as relativedelta
+import logging
+import lxml
+import urlparse
+from urllib import urlencode, quote as quote
+
+from openerp import _, api, fields, models, SUPERUSER_ID
+from openerp import tools
+from openerp import report as odoo_report
+from openerp.exceptions import UserError
+
+_logger = logging.getLogger(__name__)
+
+
+def format_tz(pool, cr, uid, dt, tz=False, format=False, context=None):
+    context = dict(context or {})
+    if tz:
+        context['tz'] = tz or pool.get('res.users').read(cr, SUPERUSER_ID, uid, ['tz'])['tz'] or "UTC"
+    timestamp = datetime.datetime.strptime(dt, tools.DEFAULT_SERVER_DATETIME_FORMAT)
+
+    ts = fields.Datetime.context_timestamp(cr, uid, timestamp, context)
+
+    if format:
+        return ts.strftime(format)
+    else:
+        lang = context.get("lang")
+        lang_params = {}
+        if lang:
+            res_lang = pool.get('res.lang')
+            ids = res_lang.search(cr, uid, [("code", "=", lang)])
+            if ids:
+                lang_params = res_lang.read(cr, uid, ids[0], ["date_format", "time_format"])
+        format_date = lang_params.get("date_format", '%B-%d-%Y')
+        format_time = lang_params.get("time_format", '%I-%M %p')
+
+        fdate = ts.strftime(format_date)
+        ftime = ts.strftime(format_time)
+        return "%s %s%s" % (fdate, ftime, (' (%s)' % tz) if tz else '')
+
+try:
+    # We use a jinja2 sandboxed environment to render mako templates.
+    # Note that the rendering does not cover all the mako syntax, in particular
+    # arbitrary Python statements are not accepted, and not all expressions are
+    # allowed: only "public" attributes (not starting with '_') of objects may
+    # be accessed.
+    # This is done on purpose: it prevents incidental or malicious execution of
+    # Python code that may break the security of the server.
+    from jinja2.sandbox import SandboxedEnvironment
+    mako_template_env = SandboxedEnvironment(
+        block_start_string="<%",
+        block_end_string="%>",
+        variable_start_string="${",
+        variable_end_string="}",
+        comment_start_string="<%doc>",
+        comment_end_string="</%doc>",
+        line_statement_prefix="%",
+        line_comment_prefix="##",
+        trim_blocks=True,               # do not output newline after blocks
+        autoescape=True,                # XML/HTML automatic escaping
+    )
+    mako_template_env.globals.update({
+        'str': str,
+        'quote': quote,
+        'urlencode': urlencode,
+        'datetime': datetime,
+        'len': len,
+        'abs': abs,
+        'min': min,
+        'max': max,
+        'sum': sum,
+        'filter': filter,
+        'reduce': reduce,
+        'map': map,
+        'round': round,
+
+        # dateutil.relativedelta is an old-style class and cannot be directly
+        # instanciated wihtin a jinja2 expression, so a lambda "proxy" is
+        # is needed, apparently.
+        'relativedelta': lambda *a, **kw : relativedelta.relativedelta(*a, **kw),
+    })
+except ImportError:
+    _logger.warning("jinja2 not available, templating features will not work!")
+
+
+class MailTemplate(models.Model):
+    "Templates for sending email"
+    _name = "mail.template"
+    _description = 'Email Templates'
+    _order = 'name'
+
+    @api.model
+    def default_get(self, fields):
+        res = super(MailTemplate, self).default_get(fields)
+        if res.get('model'):
+            res['model_id'] = self.env['ir.model'].search([('model', '=', res.pop('model'))]).id
+        return res
+
+    name = fields.Char('Name')
+    model_id = fields.Many2one('ir.model', 'Applies to', help="The kind of document with with this template can be used")
+    model = fields.Char('Related Document Model', related='model_id.model', select=True, store=True, readonly=True)
+    lang = fields.Char('Language',
+                       help="Optional translation language (ISO code) to select when sending out an email. "
+                            "If not set, the english version will be used. "
+                            "This should usually be a placeholder expression "
+                            "that provides the appropriate language, e.g. "
+                            "${object.partner_id.lang}.",
+                       placeholder="${object.partner_id.lang}")
+    user_signature = fields.Boolean('Add Signature',
+                                    help="If checked, the user's signature will be appended to the text version "
+                                         "of the message")
+    subject = fields.Char('Subject', translate=True, help="Subject (placeholders may be used here)")
+    email_from = fields.Char('From',
+                             help="Sender address (placeholders may be used here). If not set, the default "
+                                  "value will be the author's email alias if configured, or email address.")
+    use_default_to = fields.Boolean(
+        'Default recipients',
+        help="Default recipients of the record:\n"
+             "- partner (using id on a partner or the partner_id field) OR\n"
+             "- email (using email_from or email field)")
+    email_to = fields.Char('To (Emails)', help="Comma-separated recipient addresses (placeholders may be used here)")
+    partner_to = fields.Char('To (Partners)', oldname='email_recipients',
+                             help="Comma-separated ids of recipient partners (placeholders may be used here)")
+    email_cc = fields.Char('Cc', help="Carbon copy recipients (placeholders may be used here)")
+    reply_to = fields.Char('Reply-To', help="Preferred response address (placeholders may be used here)")
+    mail_server_id = fields.Many2one('ir.mail_server', 'Outgoing Mail Server', readonly=False,
+                                     help="Optional preferred server for outgoing mails. If not set, the highest "
+                                          "priority one will be used.")
+    body_html = fields.Html('Body', translate=True, sanitize=False, help="Rich-text/HTML version of the message (placeholders may be used here)")
+    report_name = fields.Char('Report Filename', translate=True,
+                              help="Name to use for the generated report file (may contain placeholders)\n"
+                                   "The extension can be omitted and will then come from the report type.")
+    report_template = fields.Many2one('ir.actions.report.xml', 'Optional report to print and attach')
+    ref_ir_act_window = fields.Many2one('ir.actions.act_window', 'Sidebar action', readonly=True, copy=False,
+                                        help="Sidebar action to make this template available on records "
+                                             "of the related document model")
+    ref_ir_value = fields.Many2one('ir.values', 'Sidebar Button', readonly=True, copy=False,
+                                   help="Sidebar button to open the sidebar action")
+    attachment_ids = fields.Many2many('ir.attachment', 'email_template_attachment_rel', 'email_template_id',
+                                      'attachment_id', 'Attachments',
+                                      help="You may attach files to this template, to be added to all "
+                                           "emails created from this template")
+    auto_delete = fields.Boolean('Auto Delete', default=True, help="Permanently delete this email after sending it, to save space")
+
+    # Fake fields used to implement the placeholder assistant
+    model_object_field = fields.Many2one('ir.model.fields', string="Field",
+                                         help="Select target field from the related document model.\n"
+                                              "If it is a relationship field you will be able to select "
+                                              "a target field at the destination of the relationship.")
+    sub_object = fields.Many2one('ir.model', 'Sub-model', readonly=True,
+                                 help="When a relationship field is selected as first field, "
+                                      "this field shows the document model the relationship goes to.")
+    sub_model_object_field = fields.Many2one('ir.model.fields', 'Sub-field',
+                                             help="When a relationship field is selected as first field, "
+                                                  "this field lets you select the target field within the "
+                                                  "destination document model (sub-model).")
+    null_value = fields.Char('Default Value', help="Optional value to use if the target field is empty")
+    copyvalue = fields.Char('Placeholder Expression', help="Final placeholder expression, to be copy-pasted in the desired template field.")
+
+    @api.onchange('model_id')
+    def onchange_model_id(self):
+        # TDE CLEANME: should'nt it be a stored related ?
+        if self.model_id:
+            self.model = self.env['ir.model'].browse(self.model_id).model
+        else:
+            self.model = False
+
+    def build_expression(self, field_name, sub_field_name, null_value):
+        """Returns a placeholder expression for use in a template field,
+        based on the values provided in the placeholder assistant.
+
+        :param field_name: main field name
+        :param sub_field_name: sub field name (M2O)
+        :param null_value: default value if the target value is empty
+        :return: final placeholder expression """
+        expression = ''
+        if field_name:
+            expression = "${object." + field_name
+            if sub_field_name:
+                expression += "." + sub_field_name
+            if null_value:
+                expression += " or '''%s'''" % null_value
+            expression += "}"
+        return expression
+
+    @api.onchange('model_object_field', 'sub_model_object_field', 'null_value')
+    def onchange_sub_model_object_value_field(self):
+        if self.model_object_field:
+            if self.model_object_field.ttype in ['many2one', 'one2many', 'many2many']:
+                models = self.env['ir.model'].search([('model', '=', self.model_object_field.relation)])
+                if models:
+                    self.sub_object = models.id
+                    self.copyvalue = self.build_expression(self.model_object_field.name, self.sub_model_object_field and self.sub_model_object_field.name or False, self.null_value or False)
+            else:
+                self.sub_object = False
+                self.sub_model_object_field = False
+                self.copyvalue = self.build_expression(self.model_object_field.name, False, self.null_value or False)
+        else:
+            self.sub_object = False
+            self.copyvalue = False
+            self.sub_model_object_field = False
+            self.null_value = False
+
+    @api.multi
+    def unlink(self):
+        self.unlink_action()
+        return super(MailTemplate, self).unlink()
+
+    @api.multi
+    def copy(self, default=None):
+        default = dict(default or {},
+                       name=_("%s (copy)") % self.name)
+        return super(MailTemplate, self).copy(default=default)
+
+    @api.multi
+    def unlink_action(self):
+        for template in self:
+            if template.ref_ir_act_window:
+                template.ref_ir_act_window.sudo().unlink()
+            if template.ref_ir_value:
+                template.ref_ir_value.sudo().unlink()
+        return True
+
+    @api.multi
+    def create_action(self):
+        ActWindow = self.env['ir.actions.act_window'].sudo()
+
+        data_obj = self.pool.get('ir.model.data')
+
+        for template in self:
+            src_obj = template.model_id.model
+            model_data_id = data_obj._get_id(cr, uid, 'mail', 'email_compose_message_wizard_form')
+            res_id = data_obj.browse(cr, uid, model_data_id, context=context).res_id
+            button_name = _('Send Mail (%s)') % template.name
+            act_id = action_obj.create(cr, SUPERUSER_ID, {
+                 'name': button_name,
+                 'type': 'ir.actions.act_window',
+                 'res_model': 'mail.compose.message',
+                 'src_model': src_obj,
+                 'view_type': 'form',
+                 'context': "{'default_composition_mode': 'mass_mail', 'default_template_id' : %d, 'default_use_template': True}" % (template.id),
+                 'view_mode':'form,tree',
+                 'view_id': res_id,
+                 'target': 'new',
+                 'auto_refresh':1
+            }, context)
+            ir_values_id = self.pool.get('ir.values').create(cr, SUPERUSER_ID, {
+                 'name': button_name,
+                 'model': src_obj,
+                 'key2': 'client_action_multi',
+                 'value': "ir.actions.act_window,%s" % act_id,
+                 'object': True,
+             }, context)
+
+            template.write({
+                'ref_ir_act_window': act_id,
+                'ref_ir_value': ir_values_id,
+            })
+
+        return True
+
+    # ----------------------------------------
+    # RENDERING
+    # ----------------------------------------
+
+    @api.model
+    def _replace_local_links(self, html):
+        """ Post-processing of html content to replace local links to absolute
+        links, using web.base.url as base url. """
+        if not html:
+            return html
+
+        # form a tree
+        root = lxml.html.fromstring(html)
+        if not len(root) and root.text is None and root.tail is None:
+            html = '<div>%s</div>' % html
+            root = lxml.html.fromstring(html)
+
+        base_url = self.env['ir.config_parameter'].get_param('web.base.url')
+        (base_scheme, base_netloc, bpath, bparams, bquery, bfragment) = urlparse.urlparse(base_url)
+
+        def _process_link(url):
+            new_url = url
+            (scheme, netloc, path, params, query, fragment) = urlparse.urlparse(url)
+            if not scheme and not netloc:
+                new_url = urlparse.urlunparse((base_scheme, base_netloc, path, params, query, fragment))
+            return new_url
+
+        # check all nodes, replace :
+        # - img src -> check URL
+        # - a href -> check URL
+        for node in root.iter():
+            if node.tag == 'a' and node.get('href'):
+                node.set('href', _process_link(node.get('href')))
+            elif node.tag == 'img' and not node.get('src', 'data').startswith('data'):
+                node.set('src', _process_link(node.get('src')))
+
+        html = lxml.html.tostring(root, pretty_print=False, method='html')
+        # this is ugly, but lxml/etree tostring want to put everything in a 'div' that breaks the editor -> remove that
+        if html.startswith('<div>') and html.endswith('</div>'):
+            html = html[5:-6]
+        return html
+
+    @api.model
+    def render_post_process(self, html):
+        html = self._replace_local_links(html)
+        return html
+
+    @api.model
+    def render_template(self, template_txt, model, res_ids, post_process=False):
+        """ Render the given template text, replace mako expressions ``${expr}``
+        with the result of evaluating these expressions with an evaluation
+        context containing:
+
+         - ``user``: browse_record of the current user
+         - ``object``: record of the document record this mail is related to
+         - ``context``: the context passed to the mail composition wizard
+
+        :param str template_txt: the template text to render
+        :param str model: model name of the document record this mail is related to.
+        :param int res_ids: list of ids of document records those mails are related to.
+        """
+        multi_mode = True
+        if isinstance(res_ids, (int, long)):
+            multi_mode = False
+            res_ids = [res_ids]
+
+        results = dict.fromkeys(res_ids, u"")
+
+        # try to load the template
+        try:
+            template = mako_template_env.from_string(tools.ustr(template_txt))
+        except Exception:
+            _logger.info("Failed to load template %r", template_txt, exc_info=True)
+            return multi_mode and results or results[res_ids[0]]
+
+        # prepare template variables
+        records = self.env[model].browse(filter(None, res_ids))  # filter to avoid browsing [None]
+        res_to_rec = dict.fromkeys(res_ids, None)
+        for record in records:
+            res_to_rec[record.id] = record
+        variables = {
+            'format_tz': lambda dt, tz=False, format=False, context=self._context: format_tz(self.pool, self._cr, self._uid, dt, tz, format, context),
+            'user': self.env.user,
+            'ctx': self._context,  # context kw would clash with mako internals
+        }
+        for res_id, record in res_to_rec.iteritems():
+            variables['object'] = record
+            try:
+                render_result = template.render(variables)
+            except Exception:
+                _logger.info("Failed to render template %r using values %r" % (template, variables), exc_info=True)
+                raise UserError(_("Failed to render template %r using values %r")% (template, variables))
+                render_result = u""
+            if render_result == u"False":
+                render_result = u""
+            results[res_id] = render_result
+
+        if post_process:
+            for res_id, result in results.iteritems():
+                results[res_id] = self.render_post_process(result)
+
+        return multi_mode and results or results[res_ids[0]]
+
+    @api.multi
+    def get_email_template(self, res_ids):
+        multi_mode = True
+        if isinstance(res_ids, (int, long)):
+            res_ids = [res_ids]
+            multi_mode = False
+
+        if res_ids is None:
+            res_ids = [None]
+        results = dict.fromkeys(res_ids, False)
+
+        if not self.ids:
+            return results
+        self.ensure_one()
+
+        langs = self.render_template(self.lang, self.model, res_ids)
+        for res_id, lang in langs.iteritems():
+            if lang:
+                template = self.with_context(lang=lang)
+            else:
+                template = self
+            results[res_id] = template
+
+        return multi_mode and results or results[res_ids[0]]
+
+    @api.multi
+    def generate_recipients(self, results, res_ids):
+        """Generates the recipients of the template. Default values can ben generated
+        instead of the template values if requested by template or context.
+        Emails (email_to, email_cc) can be transformed into partners if requested
+        in the context. """
+        self.ensure_one()
+
+        if self.use_default_to or self._context.get('tpl_force_default_to'):
+            default_recipients = self.env['mail.thread'].message_get_default_recipients(res_model=self.model, res_ids=res_ids)
+            for res_id, recipients in default_recipients.iteritems():
+                results[res_id].pop('partner_to', None)
+                results[res_id].update(recipients)
+
+        for res_id, values in results.iteritems():
+            partner_ids = values.get('partner_ids', list())
+            if self._context.get('tpl_partners_only'):
+                mails = tools.email_split(values.pop('email_to', '')) + tools.email_split(values.pop('email_cc', ''))
+                for mail in mails:
+                    partner_id = self.env['res.partner'].find_or_create(mail)
+                    partner_ids.append(partner_id)
+            partner_to = values.pop('partner_to', '')
+            if partner_to:
+                # placeholders could generate '', 3, 2 due to some empty field values
+                tpl_partner_ids = [int(pid) for pid in partner_to.split(',') if pid]
+                partner_ids += self.env['res.partner'].sudo().browse(tpl_partner_ids).exists().ids
+            results[res_id]['partner_ids'] = partner_ids
+        return results
+
+    @api.multi
+    def generate_email(self, res_ids, fields=None):
+        """Generates an email from the template for given the given model based on
+        records given by res_ids.
+
+        :param template_id: id of the template to render.
+        :param res_id: id of the record to use for rendering the template (model
+                       is taken from template definition)
+        :returns: a dict containing all relevant fields for creating a new
+                  mail.mail entry, with one extra key ``attachments``, in the
+                  format [(report_name, data)] where data is base64 encoded.
+        """
+        self.ensure_one()
+        multi_mode = True
+        if isinstance(res_ids, (int, long)):
+            res_ids = [res_ids]
+            multi_mode = False
+        if fields is None:
+            fields = ['subject', 'body_html', 'email_from', 'email_to', 'partner_to', 'email_cc', 'reply_to']
+
+        res_ids_to_templates = self.get_email_template_batch(res_ids)
+
+        # templates: res_id -> template; template -> res_ids
+        templates_to_res_ids = {}
+        for res_id, template in res_ids_to_templates.iteritems():
+            templates_to_res_ids.setdefault(template, []).append(res_id)
+
+        results = dict()
+        for template, template_res_ids in templates_to_res_ids.iteritems():
+            Template = self.env['mail.template']
+            # generate fields value for all res_ids linked to the current template
+            if template.lang:
+                Template = Template.with_context(lang=template._context.get('lang'))
+            for field in fields:
+                generated_field_values = Template.render_template(
+                    getattr(template, field), template.model, template_res_ids,
+                    post_process=(field == 'body_html'))
+                for res_id, field_value in generated_field_values.iteritems():
+                    results.setdefault(res_id, dict())[field] = field_value
+            # compute recipients
+            results = template.generate_recipients(results, template_res_ids)
+            # update values for all res_ids
+            for res_id in template_res_ids:
+                values = results[res_id]
+                # body: add user signature, sanitize
+                if 'body_html' in fields and template.user_signature:
+                    signature = self.env.user.signature
+                    if signature:
+                        values['body_html'] = tools.append_content_to_html(values['body_html'], signature, plaintext=False)
+                if values.get('body_html'):
+                    values['body'] = tools.html_sanitize(values['body_html'])
+                # technical settings
+                values.update(
+                    mail_server_id=template.mail_server_id.id or False,
+                    auto_delete=template.auto_delete,
+                    model=template.model,
+                    res_id=res_id or False,
+                    attachment_ids=[attach.id for attach in template.attachment_ids],
+                )
+
+            # Add report in attachments: generate once for all template_res_ids
+            if template.report_template:
+                for res_id in template_res_ids:
+                    attachments = []
+                    report_name = self.render_template(template.report_name, template.model, res_id)
+                    report = template.report_template
+                    report_service = report.report_name
+
+                    if report.report_type in ['qweb-html', 'qweb-pdf']:
+                        result, format = self.pool['report'].get_pdf(self._cr, self._uid, [res_id], report_service, context=Template._context), 'pdf'
+                    else:
+                        result, format = odoo_report.render_report(self._cr, self._uid, [res_id], report_service, {'model': template.model}, Template._context)
+
+                    # TODO in trunk, change return format to binary to match message_post expected format
+                    result = base64.b64encode(result)
+                    if not report_name:
+                        report_name = 'report.' + report_service
+                    ext = "." + format
+                    if not report_name.endswith(ext):
+                        report_name += ext
+                    attachments.append((report_name, result))
+                    results[res_id]['attachments'] = attachments
+
+        return multi_mode and results or results[res_ids[0]]
+
+    @api.multi
+    def send_mail(self, res_id, force_send=False, raise_exception=False):
+        """Generates a new mail message for the given template and record,
+           and schedules it for delivery through the ``mail`` module's scheduler.
+
+           :param int res_id: id of the record to render the template with
+                              (model is taken from the template)
+           :param bool force_send: if True, the generated mail.message is
+                immediately sent after being created, as if the scheduler
+                was executed for this message only.
+           :returns: id of the mail.message that was created
+        """
+        self.ensure_one()
+        Mail = self.env['mail.mail']
+        Attachment = self.env['ir.attachment']  # TDE FIXME: should remove dfeault_type from context
+
+        # create a mail_mail based on values, without attachments
+        values = self.generate_email(res_id)
+        values['recipient_ids'] = [(4, pid) for pid in values.get('partner_ids', list())]
+        attachment_ids = values.pop('attachment_ids', [])
+        attachments = values.pop('attachments', [])
+        # add a protection against void email_from
+        if 'email_from' in values and not values.get('email_from'):
+            values.pop('email_from')
+        mail = Mail.create(values)
+
+        # manage attachments
+        for attachment in attachments:
+            attachment_data = {
+                'name': attachment[0],
+                'datas_fname': attachment[0],
+                'datas': attachment[1],
+                'res_model': 'mail.message',
+                'res_id': mail.mail_message_id.id,
+            }
+            attachment_ids.append(Attachment.create(attachment_data).id)
+        if attachment_ids:
+            values['attachment_ids'] = [(6, 0, attachment_ids)]
+            mail.write({'attachment_ids': [(6, 0, attachment_ids)]})
+
+        if force_send:
+            mail.send(raise_exception=raise_exception)
+        return mail.id  # TDE CLEANME: return mail + api.returns ?
+
+    # compatibility
+    render_template_batch = render_template
+    get_email_template_batch = get_email_template
+    generate_email_batch = generate_email
+
+    # Compatibility method
+    # def render_template(self, cr, uid, template, model, res_id, context=None):
+    #     return self.render_template_batch(cr, uid, template, model, [res_id], context)[res_id]
+
+    # def get_email_template(self, cr, uid, template_id=False, record_id=None, context=None):
+    #     return self.get_email_template_batch(cr, uid, template_id, [record_id], context)[record_id]
+
+    # def generate_email(self, cr, uid, template_id, res_id, context=None):
+    #     return self.generate_email_batch(cr, uid, template_id, [res_id], context)[res_id]

--- a/None
+++ b/addons/mail/models/mail_thread.py
@@ -0,0 +1,1966 @@
+# -*- coding: utf-8 -*-
+
+import base64
+from collections import OrderedDict
+import datetime
+import dateutil
+import email
+try:
+    import simplejson as json
+except ImportError:
+    import json
+from lxml import etree
+import logging
+import pytz
+import re
+import socket
+import time
+import xmlrpclib
+from email.message import Message
+from email.utils import formataddr
+from urllib import urlencode
+
+from openerp import _, api, fields, models, SUPERUSER_ID
+from openerp import exceptions
+from openerp import tools
+from openerp.addons.mail.models.mail_message import decode
+from openerp.tools.safe_eval import safe_eval as eval
+
+
+_logger = logging.getLogger(__name__)
+
+
+mail_header_msgid_re = re.compile('<[^<>]+>')
+
+
+def decode_header(message, header, separator=' '):
+    return separator.join(map(decode, filter(None, message.get_all(header, []))))
+
+
+class MailThread(models.AbstractModel):
+    ''' mail_thread model is meant to be inherited by any model that needs to
+        act as a discussion topic on which messages can be attached. Public
+        methods are prefixed with ``message_`` in order to avoid name
+        collisions with methods of the models that will inherit from this class.
+
+        ``mail.thread`` defines fields used to handle and display the
+        communication history. ``mail.thread`` also manages followers of
+        inheriting classes. All features and expected behavior are managed
+        by mail.thread. Widgets has been designed for the 7.0 and following
+        versions of OpenERP.
+
+        Inheriting classes are not required to implement any method, as the
+        default implementation will work for any model. However it is common
+        to override at least the ``message_new`` and ``message_update``
+        methods (calling ``super``) to add model-specific behavior at
+        creation and update of a thread when processing incoming emails.
+
+        Options:
+            - _mail_flat_thread: if set to True, all messages without parent_id
+                are automatically attached to the first message posted on the
+                ressource. If set to False, the display of Chatter is done using
+                threads, and no parent_id is automatically set.
+    '''
+    _name = 'mail.thread'
+    _description = 'Email Thread'
+    _mail_flat_thread = True  # flatten the discussino history
+    _mail_post_access = 'write'  # access required on the document to post on it
+    _mail_mass_mailing = False  # enable mass mailing on this model
+
+    message_is_follower = fields.Boolean('Is Follower', compute='_get_followers', search='_search_is_follower')
+    message_follower_ids = fields.Many2many(
+        comodel_name='res.partner', string='Followers',
+        inverse='_set_followers',
+        compute='_get_followers', search='_search_followers', type='many2many')
+    message_ids = fields.One2many(
+        'mail.message', 'res_id', string='Messages',
+        domain=lambda self: [('model', '=', self._name)], auto_join=True,
+        help="Messages and communication history")
+    message_last_post = fields.Datetime('Last Message Date', help='Date of the last message posted on the record.')
+    message_unread = fields.Boolean(
+        'Unread Messages', compute='_get_message_unread', search='_search_message_unread',
+        help="If checked new messages require your attention.")
+    message_summary = fields.Text(
+        'Summary', compute='_get_message_unread',
+        help="Holds the Chatter summary (number of messages, ...). "\
+             "This summary is directly in html format in order to "\
+             "be inserted in kanban views.")
+
+    @api.multi
+    def _get_followers(self):
+        res = dict.fromkeys(self.ids, self.env['res.partner'])
+        followers = self.env['mail.followers'].sudo().search([('res_model', '=', self._name), ('res_id', 'in', self.ids)])
+        for follower in followers:
+            res[follower.res_id] |= follower.partner_id
+        for record in self:
+            record.message_follower_ids = res[record.id]
+            record.message_is_follower = self.env.user.partner_id in record.message_follower_ids
+
+    @api.multi
+    def _set_followers(self):
+        # read the old set of followers, and determine the new set of followers
+        old = self.env['mail.followers'].sudo().search([('res_model', '=', self._name), ('res_id', 'in', self.ids)]).mapped('partner_id')
+        new = self.env['res.partner']
+        Partner = self.env['res.partner']
+
+        old_style_commands = self._fields['message_follower_ids'].convert_to_write(self.message_follower_ids)
+        for command in old_style_commands:
+            if command[0] == 0:
+                new |= Partner.create(command[2])
+            elif command[0] == 1:
+                partner = Partner.browse(command[1])
+                partner.write(command[2])
+                new |= partner
+            elif command[0] == 2:
+                partner = Partner.browse(command[1])
+                new -= partner
+                partner.unlink()
+            elif command[0] == 3:
+                new -= Partner.browse(command[1])
+            elif command[0] == 4:
+                new |= Partner.browse(command[1])
+            elif command[0] == 5:
+                new = self.env['res.partner']
+            elif command[0] == 6:
+                new = self.env['res.partner'].browse(command[2])
+
+        # remove partners that are no longer followers
+        self.message_unsubscribe((old-new).ids)
+        # add new followers
+        self.message_subscribe((new-old).ids)
+
+    @api.model
+    def _search_followers(self, operator, operand):
+        """Search function for message_follower_ids
+
+        Do not use with operator 'not in'. Use instead message_is_followers
+        """
+        # TOFIX make it work with not in
+        assert operator != "not in", "Do not search message_follower_ids with 'not in'"
+        followers = self.env['mail.followers'].sudo().search([('res_model', '=', self._name), ('partner_id', operator, operand)])
+        return [('id', 'in', followers.mapped('res_id'))]
+
+    @api.model
+    def _search_is_follower(self, operator, operand):
+        """Search function for message_is_follower"""
+        user_pid = self.env.user.partner_id.id
+        if (operator == '=' and operand) or (operator == '!=' and not operand):  # is a follower
+            followers = self.env['mail.followers'].sudo().search([('res_model', '=', self._name), ('partner_id', '=', user_pid)])
+            return [('id', 'in', followers.mapped('res_id'))]
+        else:  # is not a follower or unknown domain
+            followers = self.env['mail.followers'].sudo().search([('res_model', '=', self._name), ('partner_id', '=', user_pid)])
+            return [('id', 'not in', followers.mapped('res_id'))]
+
+    @api.multi
+    def _get_message_unread(self):
+        """ Compute the existence of unread message (message_unread) + the kanban
+        summary for unread messages (message_summary) """
+        res = dict((res_id, 0) for res_id in self.ids)
+
+        # search for unread messages, directly in SQL to improve performances
+        self._cr.execute(""" SELECT m.res_id FROM mail_message m
+                             RIGHT JOIN mail_notification n
+                             ON (n.message_id = m.id AND n.partner_id = %s AND (n.is_read = False or n.is_read IS NULL))
+                             WHERE m.model = %s AND m.res_id in %s""",
+                         (self.env.user.partner_id.id, self._name, tuple(self.ids),))
+        for result in self._cr.fetchall():
+            res[result[0]] += 1
+
+        for record in self:
+            record.message_unread = res.get(record.id, 0) >= 1
+            if record.message_unread:
+                record.message_summary = "<span class='oe_kanban_mail_new' title='%(title)s'><i class='fa fa-comments'/> %(count)d</span>" % {
+                    'title': '%d%s' % (res[record.id], _('unread messages')),
+                    'count': res[record.id]}
+            else:
+                record.message_summary = ''
+
+    @api.model
+    def _search_message_unread(self, operator, operand):
+        return [('message_ids.to_read', operator, operand)]
+
+    # ------------------------------------------------------
+    # CRUD overrides for automatic subscription and logging
+    # ------------------------------------------------------
+
+    @api.model
+    def create(self, values):
+        """ Chatter override :
+            - subscribe uid
+            - subscribe followers of parent
+            - log a creation message
+        """
+        if self._context.get('tracking_disable'):
+            return super(MailThread, self).create(values)
+
+        # subscribe uid unless asked not to
+        if not self._context.get('mail_create_nosubscribe'):
+            message_follower_ids = values.get('message_follower_ids') or []  # webclient can send None or False
+            message_follower_ids.append([4, self.env.user.partner_id.id])
+            values['message_follower_ids'] = message_follower_ids
+        thread = super(MailThread, self).create(values)
+
+        # automatic logging unless asked not to (mainly for various testing purpose)
+        if not self._context.get('mail_create_nolog'):
+            doc_name = self.env['ir.model'].search([('model', '=', self._name)]).read(['name'])[0]['name']
+            thread.message_post(body=_('%s created') % doc_name)
+
+        # auto_subscribe: take values and defaults into account
+        create_values = dict(values)
+        for key, val in self._context.iteritems():
+            if key.startswith('default_') and key[8:] not in create_values:
+                create_values[key[8:]] = val
+        thread.message_auto_subscribe(create_values.keys(), values=create_values)
+
+        # track values
+        if not self._context.get('mail_notrack'):
+            if 'lang' not in self._context:
+                track_thread = thread.with_context(lang=self.env.user.lang)
+            else:
+                track_thread = thread
+            tracked_fields = track_thread._get_tracked_fields(values.keys())
+            if tracked_fields:
+                initial_values = {thread.id: dict.fromkeys(tracked_fields, False)}
+                track_thread.message_track(tracked_fields, initial_values)
+        return thread
+
+    @api.multi
+    def write(self, values):
+        if self._context.get('tracking_disable'):
+            return super(MailThread, self).write(values)
+
+        # Track initial values of tracked fields
+        if 'lang' not in self._context:
+            track_self = self.with_context(lang=self.env.user.lang)
+        else:
+            track_self = self
+
+        tracked_fields = None
+        if not self._context.get('mail_notrack'):
+            tracked_fields = track_self._get_tracked_fields(values.keys())
+        if tracked_fields:
+            initial_values = dict((record.id, dict((key, getattr(record, key)) for key in tracked_fields))
+                                  for record in track_self)
+
+        # Perform write, update followers
+        result = super(MailThread, self).write(values)
+        self.message_auto_subscribe(values.keys(), values=values)
+
+        # Perform the tracking
+        if tracked_fields:
+            track_self.message_track(tracked_fields, initial_values)
+
+        return result
+
+    @api.multi
+    def unlink(self):
+        """ Override unlink to delete messages and followers. This cannot be
+        cascaded, because link is done through (res_model, res_id). """
+        self.env['mail.message'].search([('model', '=', self._name), ('res_id', 'in', self.ids)]).unlink()
+        res = super(MailThread, self).unlink()
+        self.env['mail.followers'].sudo().search(
+            [('res_model', '=', self._name), ('res_id', 'in', self.ids)]
+        ).unlink()
+        return res
+
+    def copy_data(self, cr, uid, id, default=None, context=None):
+        context = dict(context or {}, mail_notrack=True)
+        # avoid tracking multiple temporary changes during copy
+        return super(MailThread, self).copy_data(cr, uid, id, default=default, context=context)
+
+    # ------------------------------------------------------
+    # Technical methods (to clean / move to controllers ?)
+    # ------------------------------------------------------
+
+    @api.model
+    def get_empty_list_help(self, help):
+        """ Override of BaseModel.get_empty_list_help() to generate an help message
+        that adds alias information. """
+        model = self._context.get('empty_list_help_model')
+        res_id = self._context.get('empty_list_help_id')
+        catchall_domain = self.env['ir.config_parameter'].sudo().get_param("mail.catchall.domain")
+        document_name = self._context.get('empty_list_help_document_name', _('document'))
+        add_arrow = not help or help.find("oe_view_nocontent_create") == -1
+        alias = None
+
+        if catchall_domain and model and res_id:  # specific res_id -> find its alias (i.e. section_id specified)
+            record = self.env[model].sudo().browse(res_id)
+            # check that the alias effectively creates new records
+            if record.alias_id and record.alias_id.alias_name and \
+                    record.alias_id.alias_model_id and \
+                    record.alias_id.alias_model_id.model == self._name and \
+                    record.alias_id.alias_force_thread_id == 0:
+                alias = record.alias_id
+        if not alias and catchall_domain and model:  # no res_id or res_id not linked to an alias -> generic help message, take a generic alias of the model
+            Alias = self.env['mail.alias']
+            aliases = Alias.search([
+                ("alias_parent_model_id.model", "=", model),
+                ("alias_name", "!=", False),
+                ('alias_force_thread_id', '=', False),
+                ('alias_parent_thread_id', '=', False)], order='id ASC')
+            if aliases and len(aliases) == 1:
+                alias = aliases[0]
+
+        if alias:
+            email_link = "<a href='mailto:%(email)s'>%(email)s</a>" % {'email': alias.name_get()[0][1]}
+            if add_arrow:
+                return "<p class='oe_view_nocontent_create'>%(dyn_help)s</p>%(static_help)s" % {
+                    'static_help': help or '',
+                    'dyn_help': _("Click here to add new %(document)s or send an email to: %(email_link)s") % {
+                        'document': document_name,
+                        'email_link': email_link
+                    }
+                }
+            return "%(static_help)s<p>%(dyn_help)s" % {
+                    'static_help': help or '',
+                    'dyn_help': _("You could also add a new %(document)s by sending an email to: %(email_link)s.") %  {
+                        'document': document_name,
+                        'email_link': email_link,
+                    }
+                }
+
+        if add_arrow:
+            return "<p class='oe_view_nocontent_create'>%(dyn_help)s</p>%(static_help)s" % {
+                'static_help': help or '',
+                'dyn_help': _("Click here to add new %s") % document_name,
+                }
+
+        return help
+
+    def fields_view_get(self, cr, uid, view_id=None, view_type='form', context=None, toolbar=False, submenu=False):
+        res = super(MailThread, self).fields_view_get(cr, uid, view_id=view_id, view_type=view_type, context=context, toolbar=toolbar, submenu=submenu)
+        if view_type == 'form':
+            doc = etree.XML(res['arch'])
+            for node in doc.xpath("//field[@name='message_ids']"):
+                options = json.loads(node.get('options', '{}'))
+                user = self.pool['res.users'].browse(cr, SUPERUSER_ID, uid, context=context)
+                options['display_log_button'] = user.has_group('base.group_user')
+                node.set('options', json.dumps(options))
+            res['arch'] = etree.tostring(doc)
+        return res
+
+    @api.model
+    def read_followers_data(self, follower_ids):
+        # TDE NOTE: move as controller ? (used in mail_followers.js)$
+        # TDE NOTE2: usefull anyway ?
+        result = []
+        is_editable = self.env.user.has_group('base.group_no_one')
+        for follower in self.env['res.partner'].browse(follower_ids):
+            is_uid = self.env.user.partner_id.id in follower.ids
+            data = (follower.id,
+                    follower.name,
+                    {'is_editable': is_editable, 'is_uid': is_uid},
+                    )
+            result.append(data)
+        return result
+
+    @api.multi
+    def _get_subscription_data(self, user_pid=None):
+        # TDE NOTE: move as controller ? (used in mail_followers.js)
+        """ Computes:
+            - message_subtype_data: data about document subtypes: which are
+                available, which are followed if any """
+        res = dict((id, dict(message_subtype_data='')) for id in self.ids)
+        if user_pid is None:
+            user_pid = self.env.user.partner_id.id
+
+        # find current model subtypes, add them to a dictionary
+        subtypes = self.env['mail.message.subtype'].search(['&', ('hidden', '=', False), '|', ('res_model', '=', self._name), ('res_model', '=', False)])
+        subtype_dict = OrderedDict(
+            (subtype.name, {
+                'default': subtype.default,
+                'followed': False,
+                'parent_model': subtype.parent_id and subtype.parent_id.res_model or self._name,
+                'id': subtype.id
+            }) for subtype in subtypes)
+        for res_id in self.ids:
+            res[res_id]['message_subtype_data'] = subtype_dict.copy()
+
+        # find the document followers, update the data
+        followers = self.env['mail.followers'].search([
+            ('partner_id', '=', user_pid),
+            ('res_id', 'in', self.ids),
+            ('res_model', '=', self._name),
+        ])
+        for fol in followers:
+            thread_subtype_dict = res[fol.res_id]['message_subtype_data']
+            for subtype in [st for st in fol.subtype_ids if st.name in thread_subtype_dict]:
+                thread_subtype_dict[subtype.name]['followed'] = True
+            res[fol.res_id]['message_subtype_data'] = thread_subtype_dict
+
+        return res
+
+    # ------------------------------------------------------
+    # Automatic log / Tracking
+    # ------------------------------------------------------
+
+    @api.model
+    def _get_tracked_fields(self, updated_fields):
+        """ Return a structure of tracked fields for the current model.
+            :param list updated_fields: modified field names
+            :return dict: a dict mapping field name to description, containing
+                always tracked fields and modified on_change fields
+        """
+        tracked_fields = []
+        for name, field in self._fields.items():
+            if getattr(field, 'track_visibility', False):
+                tracked_fields.append(name)
+
+        if tracked_fields:
+            return self.fields_get(tracked_fields)
+        return {}
+
+    @api.multi
+    def _track_subtype(self, init_values):
+        """ Give the subtypes triggered by the changes on the record according
+        to values that have been updated.
+
+        :param ids: list of a single ID, the ID of the record being modified
+        :type ids: singleton list
+        :param init_values: the original values of the record; only modified fields
+                            are present in the dict
+        :type init_values: dict
+        :returns: a subtype xml_id or False if no subtype is trigerred
+        """
+        return False
+
+    @api.multi
+    def message_track(self, tracked_fields, initial_values):
+
+        def convert_for_display(value, col_info):
+            if not value and col_info['type'] == 'boolean':
+                return 'False'
+            if not value:
+                return ''
+            if col_info['type'] == 'many2one':
+                return value.name_get()[0][1]
+            if col_info['type'] == 'selection':
+                return dict(col_info['selection'])[value]
+            return value
+
+        def format_message(message_description, tracked_values):
+            message = ''
+            if message_description:
+                message = '<span>%s</span>' % message_description
+            for name, change in tracked_values.items():
+                message += '<div> &nbsp; &nbsp; &bull; <b>%s</b>: ' % change.get('col_info')
+                if change.get('old_value'):
+                    message += '%s &rarr; ' % change.get('old_value')
+                message += '%s</div>' % change.get('new_value')
+            return message
+
+        if not tracked_fields:
+            return True
+
+        for record in self:
+            initial = initial_values[record.id]
+            changes = set()
+            tracked_values = {}
+
+            # generate tracked_values data structure: {'col_name': {col_info, new_value, old_value}}
+            for col_name, col_info in tracked_fields.items():
+                field = self._fields[col_name]
+                initial_value = initial[col_name]
+                record_value = getattr(record, col_name)
+
+                if record_value == initial_value and getattr(field, 'track_visibility', None) == 'always':
+                    tracked_values[col_name] = dict(
+                        col_info=col_info['string'],
+                        new_value=convert_for_display(record_value, col_info),
+                    )
+                elif record_value != initial_value and (record_value or initial_value):  # because browse null != False
+                    if getattr(field, 'track_visibility', None) in ['always', 'onchange']:
+                        tracked_values[col_name] = dict(
+                            col_info=col_info['string'],
+                            old_value=convert_for_display(initial_value, col_info),
+                            new_value=convert_for_display(record_value, col_info),
+                        )
+                    if col_name in tracked_fields:
+                        changes.add(col_name)
+            if not changes:
+                continue
+
+            # find subtypes and post messages or log if no subtype found
+            subtype_xmlid = False
+            # By passing this key, that allows to let the subtype empty and so don't sent email because partners_to_notify from mail_message._notify will be empty
+            if not self._context.get('mail_track_log_only'):
+                subtype_xmlid = record._track_subtype(dict((col_name, initial[col_name]) for col_name in changes))
+                # compatibility: use the deprecated _track dict
+                if not subtype_xmlid and hasattr(self, '_track'):
+                    for field, track_info in self._track.items():
+                        if field not in changes or subtype_xmlid:
+                            continue
+                        for subtype, method in track_info.items():
+                            if method(self, self._cr, self._uid, record, self._context):
+                                _logger.warning("Model %s still using deprecated _track dict; override _track_subtype method instead" % self._name)
+                                subtype_xmlid = subtype
+
+            if subtype_xmlid:
+                subtype_rec = self.env.ref(subtype_xmlid)  # TDE FIXME check for raise if not found
+                if not (subtype_rec and subtype_rec.exists()):
+                    _logger.debug('subtype %s not found' % subtype_xmlid)
+                    continue
+                message = format_message(subtype_rec.description if subtype_rec.description else subtype_rec.name, tracked_values)
+            else:
+                message = format_message('', tracked_values)
+            record.message_post(body=message, subtype=subtype_xmlid)
+        return True
+
+    #------------------------------------------------------
+    # mail.message wrappers and tools
+    #------------------------------------------------------
+
+    @api.model
+    def _needaction_domain_get(self):
+        if self._needaction:
+            return [('message_unread', '=', True)]
+        return []
+
+    @api.model
+    def _garbage_collect_attachments(self):
+        """ Garbage collect lost mail attachments. Those are attachments
+            - linked to res_model 'mail.compose.message', the composer wizard
+            - with res_id 0, because they were created outside of an existing
+                wizard (typically user input through Chatter or reports
+                created on-the-fly by the templates)
+            - unused since at least one day (create_date and write_date)
+        """
+        limit_date = datetime.datetime.utcnow() - datetime.timedelta(days=1)
+        limit_date_str = datetime.datetime.strftime(limit_date, tools.DEFAULT_SERVER_DATETIME_FORMAT)
+        self.env['ir.attachment'].search([
+            ('res_model', '=', 'mail.compose.message'),
+            ('res_id', '=', 0),
+            ('create_date', '<', limit_date_str),
+            ('write_date', '<', limit_date_str)]
+        ).unlink()
+        return True
+
+    @api.model
+    def check_mail_message_access(self, res_ids, operation, model_name=None):
+        """ mail.message check permission rules for related document. This method is
+            meant to be inherited in order to implement addons-specific behavior.
+            A common behavior would be to allow creating messages when having read
+            access rule on the document, for portal document such as issues. """
+        if model_name:
+            DocModel = self.env[model_name]
+        else:
+            DocModel = self
+        if hasattr(DocModel, '_mail_post_access'):
+            create_allow = DocModel._mail_post_access
+        else:
+            create_allow = 'write'
+
+        if operation in ['write', 'unlink']:
+            check_operation = 'write'
+        elif operation == 'create' and create_allow in ['create', 'read', 'write', 'unlink']:
+            check_operation = create_allow
+        elif operation == 'create':
+            check_operation = 'write'
+        else:
+            check_operation = operation
+
+        DocModel.check_access_rights(check_operation)
+        DocModel.browse(res_ids).check_access_rule(check_operation)
+
+    @api.model
+    def _get_inbox_action_xml_id(self):
+        """ When redirecting towards the Inbox, choose which action xml_id has
+            to be fetched. This method is meant to be inherited, at least in portal
+            because portal users have a different Inbox action than classic users. """
+        return 'mail.action_mail_inbox_feeds'
+
+    @api.model
+    def message_redirect_action(self):
+        """ For a given message, return an action that either
+            - opens the form view of the related document if model, res_id, and
+              read access to the document
+            - opens the Inbox with a default search on the conversation if model,
+              res_id
+            - opens the Inbox with context propagated
+
+        """
+        # default action is the Inbox action
+        action = self.env.ref(self._get_inbox_action_xml_id()).read()[0]
+        params = self._context.get('params')
+        msg_id = model = res_id = None
+
+        if params:
+            msg_id = params.get('message_id')
+            model = params.get('model')
+            res_id = params.get('res_id', params.get('id'))  # signup automatically generated id instead of res_id
+        if not msg_id and not (model and res_id):
+            return action
+        if msg_id and not (model and res_id):
+            msg = self.env['mail.message'].browse(msg_id).exists()
+            try:
+                model, res_id = msg.model, msg.res_id
+            except exceptions.AccessError:
+                pass
+
+        # if model + res_id found: try to redirect to the document or fallback on the Inbox
+        if model and res_id:
+            RecordModel = self.env[model]
+            if RecordModel.check_access_rights('read', raise_exception=False):
+                try:
+                    # TDE FIXME: clean that copde
+                    RecordModel.browse(res_id).check_access_rule('read')
+                    action = RecordModel.browse(res_id).get_access_action()[0]
+                except exceptions.AccessError:
+                    pass
+            action.update({
+                'context': {
+                    'search_default_model': model,
+                    'search_default_res_id': res_id,
+                }
+            })
+        return action
+
+    @api.model
+    def _get_access_link(self, mail, partner):
+        # the parameters to encode for the query and fragment part of url
+        query = {'db': self._cr.dbname}
+        fragment = {
+            'login': partner.user_ids[0].login,
+            'action': 'mail.action_mail_redirect',
+        }
+        if mail.notification:
+            fragment['message_id'] = mail.mail_message_id.id
+        elif mail.model and mail.res_id:
+            fragment.update(model=mail.model, res_id=mail.res_id)
+
+        return "/web?%s#%s" % (urlencode(query), urlencode(fragment))
+
+    # ------------------------------------------------------
+    # Email specific
+    # ------------------------------------------------------
+
+    @api.multi
+    def message_get_default_recipients(self, res_model=None, res_ids=None):
+        if res_model and res_ids:
+            if hasattr(self.env[res_model], 'message_get_default_recipients'):
+                return self.env[res_model].browse(res_ids).message_get_default_recipients()
+            records = self.env[res_model].sudo().browse(res_ids)
+        else:
+            records = self.sudo()
+        res = {}
+        for record in records:
+            recipient_ids, email_to, email_cc = set(), False, False
+            if 'partner_id' in self._fields and record.partner_id:
+                recipient_ids.add(record.partner_id.id)
+            elif 'email_from' in self._fields and record.email_from:
+                email_to = record.email_from
+            elif 'email' in self._fields:
+                email_to = record.email
+            res[record.id] = {'partner_ids': list(recipient_ids), 'email_to': email_to, 'email_cc': email_cc}
+        return res
+
+    @api.model
+    def message_get_reply_to(self, res_ids, default=None):
+        """ Returns the preferred reply-to email address that is basically the
+        alias of the document, if it exists. Override this method to implement
+        a custom behavior about reply-to for generated emails. """
+        model_name = self.env.context.get('thread_model') or self._name
+        alias_domain = self.env['ir.config_parameter'].get_param("mail.catchall.domain")
+        res = dict.fromkeys(res_ids, False)
+
+        # alias domain: check for aliases and catchall
+        aliases = {}
+        doc_names = {}
+        if alias_domain:
+            if model_name and model_name != 'mail.thread' and res_ids:
+                mail_aliases = self.env['mail.alias'].sudo().search([
+                    ('alias_parent_model_id.model', '=', model_name),
+                    ('alias_parent_thread_id', 'in', res_ids),
+                    ('alias_name', '!=', False)])
+                aliases.update(
+                    dict((alias.alias_parent_thread_id, '%s@%s' % (alias.alias_name, alias_domain)) for alias in mail_aliases))
+                doc_names.update(
+                    dict((ng_res[0], ng_res[1])
+                         for ng_res in self.env[model_name].sudo().browse(aliases.keys()).name_get()))
+            # left ids: use catchall
+            left_ids = set(res_ids).difference(set(aliases.keys()))
+            if left_ids:
+                catchall_alias = self.env['ir.config_parameter'].get_param("mail.catchall.alias")
+                if catchall_alias:
+                    aliases.update(dict((res_id, '%s@%s' % (catchall_alias, alias_domain)) for res_id in left_ids))
+            # compute name of reply-to
+            company_name = self.env.user.company_id.name
+            for res_id in aliases.keys():
+                email_name = '%s%s' % (company_name, doc_names.get(res_id) and (' ' + doc_names[res_id]) or '')
+                email_addr = aliases[res_id]
+                res[res_id] = formataddr((email_name, email_addr))
+        left_ids = set(res_ids).difference(set(aliases.keys()))
+        if left_ids:
+            res.update(dict((res_id, default) for res_id in res_ids))
+        return res
+
+    @api.multi
+    def message_get_email_values(self, notif_mail=None):
+        """ Get specific notification email values to store on the notification
+        mail_mail. Void method, inherit it to add custom values. """
+        self.ensure_one()
+        res = dict()
+        return res
+
+    # ------------------------------------------------------
+    # Mail gateway
+    # ------------------------------------------------------
+
+    @api.model
+    def message_capable_models(self):
+        """ Used by the plugin addon, based for plugin_outlook and others. """
+        ret_dict = {}
+        for model_name in self.pool.obj_list():
+            model = self.pool[model_name]
+            if hasattr(model, "message_process") and hasattr(model, "message_post"):
+                ret_dict[model_name] = model._description
+        return ret_dict
+
+    def _message_find_partners(self, message, header_fields=['From']):
+        """ Find partners related to some header fields of the message.
+
+            :param string message: an email.message instance """
+        s = ', '.join([decode(message.get(h)) for h in header_fields if message.get(h)])
+        return filter(lambda x: x, self._find_partner_from_emails(tools.email_split(s)))
+
+    @api.model
+    def message_route_verify(self, message, message_dict, route, update_author=True, assert_model=True, create_fallback=True, allow_private=False):
+        """ Verify route validity. Check and rules:
+            1 - if thread_id -> check that document effectively exists; otherwise
+                fallback on a message_new by resetting thread_id
+            2 - check that message_update exists if thread_id is set; or at least
+                that message_new exist
+            [ - find author_id if udpate_author is set]
+            3 - if there is an alias, check alias_contact:
+                'followers' and thread_id:
+                    check on target document that the author is in the followers
+                'followers' and alias_parent_thread_id:
+                    check on alias parent document that the author is in the
+                    followers
+                'partners': check that author_id id set
+        """
+
+        assert isinstance(route, (list, tuple)), 'A route should be a list or a tuple'
+        assert len(route) == 5, 'A route should contain 5 elements: model, thread_id, custom_values, uid, alias record'
+
+        message_id = message.get('Message-Id')
+        email_from = decode_header(message, 'From')
+        author_id = message_dict.get('author_id')
+        model, thread_id, alias = route[0], route[1], route[4]
+        record_set = None
+
+        def _create_bounce_email():
+            self.env['mail.mail'].create({
+                'body_html': '<div><p>Hello,</p>'
+                             '<p>The following email sent to %s cannot be accepted because this is '
+                             'a private email address. Only allowed people can contact us at this address.</p></div>'
+                             '<blockquote>%s</blockquote>' % (message.get('to'), message_dict.get('body')),
+                'subject': 'Re: %s' % message.get('subject'),
+                'email_to': message.get('from'),
+                'auto_delete': True,
+            }).send()
+
+        def _warn(message):
+            _logger.info('Routing mail with Message-Id %s: route %s: %s',
+                         message_id, route, message)
+
+        # Wrong model
+        if model and model not in self.pool:
+            if assert_model:
+                assert model in self.pool, 'Routing: unknown target model %s' % model
+            _warn('unknown target model %s' % model)
+            return ()
+
+        # Private message: should not contain any thread_id
+        if not model and thread_id:
+            if assert_model:
+                if thread_id:
+                    raise ValueError('Routing: posting a message without model should be with a null res_id (private message), received %s.' % thread_id)
+            _warn('posting a message without model should be with a null res_id (private message), received %s resetting thread_id' % thread_id)
+            thread_id = 0
+        # Private message: should have a parent_id (only answers)
+        if not model and not message_dict.get('parent_id'):
+            if assert_model:
+                if not message_dict.get('parent_id'):
+                    raise ValueError('Routing: posting a message without model should be with a parent_id (private mesage).')
+            _warn('posting a message without model should be with a parent_id (private mesage), skipping')
+            return ()
+
+        if model and thread_id:
+            record_set = self.env[model].browse(thread_id)
+        elif model:
+            record_set = self.env[model]
+
+        # Existing Document: check if exists; if not, fallback on create if allowed
+        if thread_id and not record_set.exists():
+            if create_fallback:
+                _warn('reply to missing document (%s,%s), fall back on new document creation' % (model, thread_id))
+                thread_id = None
+            elif assert_model:
+                # TDE FIXME: change assert to some real error
+                assert record_set.exists(), 'Routing: reply to missing document (%s,%s)' % (model, thread_id)
+            else:
+                _warn('reply to missing document (%s,%s), skipping' % (model, thread_id))
+                return ()
+
+        # Existing Document: check model accepts the mailgateway
+        if thread_id and model and not hasattr(record_set, 'message_update'):
+            if create_fallback:
+                _warn('model %s does not accept document update, fall back on document creation' % model)
+                thread_id = None
+            elif assert_model:
+                assert hasattr(record_set, 'message_update'), 'Routing: model %s does not accept document update, crashing' % model
+            else:
+                _warn('model %s does not accept document update, skipping' % model)
+                return ()
+
+        # New Document: check model accepts the mailgateway
+        if not thread_id and model and not hasattr(record_set, 'message_new'):
+            if assert_model:
+                if not hasattr(record_set, 'message_new'):
+                    raise ValueError(
+                        'Model %s does not accept document creation, crashing' % model
+                    )
+            _warn('model %s does not accept document creation, skipping' % model)
+            return ()
+
+        # Update message author if asked
+        # We do it now because we need it for aliases (contact settings)
+        if not author_id and update_author:
+            author_ids = self.env['mail.thread']._find_partner_from_emails([email_from], res_model=model, res_id=thread_id)
+            if author_ids:
+                author_id = author_ids[0]
+                message_dict['author_id'] = author_id
+
+        # Alias: check alias_contact settings
+        if alias and alias.alias_contact == 'followers' and (thread_id or alias.alias_parent_thread_id):
+            if thread_id:
+                obj = record_set[0]
+            else:
+                obj = self.env[alias.alias_parent_model_id.model].browse(alias.alias_parent_thread_id)
+            if not author_id or author_id not in [fol.id for fol in obj.message_follower_ids]:
+                _warn('alias %s restricted to internal followers, skipping' % alias.alias_name)
+                _create_bounce_email()
+                return ()
+        elif alias and alias.alias_contact == 'partners' and not author_id:
+            _warn('alias %s does not accept unknown author, skipping' % alias.alias_name)
+            _create_bounce_email()
+            return ()
+
+        if not model and not thread_id and not alias and not allow_private:
+            return ()
+
+        return (model, thread_id, route[2], route[3], route[4])
+
+    @api.model
+    def message_route(self, message, message_dict, model=None, thread_id=None, custom_values=None):
+        """Attempt to figure out the correct target model, thread_id,
+        custom_values and user_id to use for an incoming message.
+        Multiple values may be returned, if a message had multiple
+        recipients matching existing mail.aliases, for example.
+
+        The following heuristics are used, in this order:
+             1. If the message replies to an existing thread_id, and
+                properly contains the thread model in the 'In-Reply-To'
+                header, use this model/thread_id pair, and ignore
+                custom_value (not needed as no creation will take place)
+             2. Look for a mail.alias entry matching the message
+                recipient, and use the corresponding model, thread_id,
+                custom_values and user_id.
+             3. Fallback to the ``model``, ``thread_id`` and ``custom_values``
+                provided.
+             4. If all the above fails, raise an exception.
+
+           :param string message: an email.message instance
+           :param dict message_dict: dictionary holding message variables
+           :param string model: the fallback model to use if the message
+               does not match any of the currently configured mail aliases
+               (may be None if a matching alias is supposed to be present)
+           :type dict custom_values: optional dictionary of default field values
+                to pass to ``message_new`` if a new record needs to be created.
+                Ignored if the thread record already exists, and also if a
+                matching mail.alias was found (aliases define their own defaults)
+           :param int thread_id: optional ID of the record/thread from ``model``
+               to which this mail should be attached. Only used if the message
+               does not reply to an existing thread and does not match any mail alias.
+           :return: list of [model, thread_id, custom_values, user_id, alias]
+
+        :raises: ValueError, TypeError
+        """
+        if not isinstance(message, Message):
+            raise TypeError('message must be an email.message.Message at this point')
+        MailMessage = self.env['mail.message']
+        fallback_model = model
+
+        # Get email.message.Message variables for future processing
+        message_id = message.get('Message-Id')
+        email_from = decode_header(message, 'From')
+        email_to = decode_header(message, 'To')
+        references = decode_header(message, 'References')
+        in_reply_to = decode_header(message, 'In-Reply-To')
+        thread_references = references or in_reply_to
+
+        # 0. First check if this is a bounce message or not.
+        #    See http://datatracker.ietf.org/doc/rfc3462/?include_text=1
+        #    As all MTA does not respect this RFC (googlemail is one of them),
+        #    we also need to verify if the message come from "mailer-daemon"
+        localpart = (tools.email_split(email_from) or [''])[0].split('@', 1)[0].lower()
+        if message.get_content_type() == 'multipart/report' or localpart == 'mailer-daemon':
+            _logger.info("Not routing bounce email from %s to %s with Message-Id %s",
+                         email_from, email_to, message_id)
+            return []
+
+        # 1. message is a reply to an existing message (exact match of message_id)
+        ref_match = thread_references and tools.reference_re.search(thread_references)
+        msg_references = mail_header_msgid_re.findall(thread_references)
+        mail_messages = MailMessage.sudo().search([('message_id', 'in', msg_references)], limit=1)
+        if ref_match and mail_messages:
+            model, thread_id = mail_messages.model, mail_messages.res_id
+            route = self.message_route_verify(
+                message, message_dict,
+                (model, thread_id, custom_values, self._uid, None),
+                update_author=True, assert_model=False, create_fallback=True)
+            if route:
+                _logger.info(
+                    'Routing mail from %s to %s with Message-Id %s: direct reply to msg: model: %s, thread_id: %s, custom_values: %s, uid: %s',
+                    email_from, email_to, message_id, model, thread_id, custom_values, self._uid)
+                return [route]
+
+        # 2. message is a reply to an existign thread (6.1 compatibility)
+        if ref_match:
+            reply_thread_id = int(ref_match.group(1))
+            reply_model = ref_match.group(2) or fallback_model
+            reply_hostname = ref_match.group(3)
+            local_hostname = socket.gethostname()
+            # do not match forwarded emails from another OpenERP system (thread_id collision!)
+            if local_hostname == reply_hostname:
+                thread_id, model = reply_thread_id, reply_model
+                if thread_id and model in self.pool:
+                    record = self.env[model].browse(thread_id)
+                    compat_mail_msg_ids = MailMessage.search([
+                        ('message_id', '=', False),
+                        ('model', '=', model),
+                        ('res_id', '=', thread_id)])
+                    if compat_mail_msg_ids and record.exists() and hasattr(record, 'message_update'):
+                        route = self.message_route_verify(
+                            message, message_dict,
+                            (model, thread_id, custom_values, self._uid, None),
+                            update_author=True, assert_model=True, create_fallback=True)
+                        if route:
+                            _logger.info(
+                                'Routing mail from %s to %s with Message-Id %s: direct thread reply (compat-mode) to model: %s, thread_id: %s, custom_values: %s, uid: %s',
+                                email_from, email_to, message_id, model, thread_id, custom_values, self._uid)
+                            return [route]
+
+        # 3. Reply to a private message
+        if in_reply_to:
+            mail_message_ids = MailMessage.search([
+                ('message_id', '=', in_reply_to),
+                '!', ('message_id', 'ilike', 'reply_to')
+            ], limit=1)
+            if mail_message_ids:
+                route = self.message_route_verify(
+                    message, message_dict,
+                    (mail_message_ids.model, mail_message_ids.res_id, custom_values, self._uid, None),
+                    update_author=True, assert_model=True, create_fallback=True, allow_private=True)
+                if route:
+                    _logger.info(
+                        'Routing mail from %s to %s with Message-Id %s: direct reply to a private message: %s, custom_values: %s, uid: %s',
+                        email_from, email_to, message_id, mail_message_ids.id, custom_values, self._uid)
+                    return [route]
+
+        # 4. Look for a matching mail.alias entry
+        # Delivered-To is a safe bet in most modern MTAs, but we have to fallback on To + Cc values
+        # for all the odd MTAs out there, as there is no standard header for the envelope's `rcpt_to` value.
+        rcpt_tos = \
+             ','.join([decode_header(message, 'Delivered-To'),
+                       decode_header(message, 'To'),
+                       decode_header(message, 'Cc'),
+                       decode_header(message, 'Resent-To'),
+                       decode_header(message, 'Resent-Cc')])
+        local_parts = [e.split('@')[0] for e in tools.email_split(rcpt_tos)]
+        if local_parts:
+            Alias = self.env['mail.alias']
+            aliases = Alias.search([('alias_name', 'in', local_parts)])
+            if aliases:
+                routes = []
+                for alias in aliases:
+                    user_id = alias.alias_user_id.id
+                    if not user_id:
+                        # TDE note: this could cause crashes, because no clue that the user
+                        # that send the email has the right to create or modify a new document
+                        # Fallback on user_id = uid
+                        # Note: recognized partners will be added as followers anyway
+                        # user_id = self._message_find_user_id(cr, uid, message, context=context)
+                        user_id = self._uid
+                        _logger.info('No matching user_id for the alias %s', alias.alias_name)
+                    route = (alias.alias_model_id.model, alias.alias_force_thread_id, eval(alias.alias_defaults), user_id, alias)
+                    route = self.message_route_verify(
+                        message, message_dict, route,
+                        update_author=True, assert_model=True, create_fallback=True)
+                    if route:
+                        _logger.info(
+                            'Routing mail from %s to %s with Message-Id %s: direct alias match: %r',
+                            email_from, email_to, message_id, route)
+                        routes.append(route)
+                return routes
+
+        # 5. Fallback to the provided parameters, if they work
+        if not thread_id:
+            # Legacy: fallback to matching [ID] in the Subject
+            match = tools.res_re.search(decode_header(message, 'Subject'))
+            thread_id = match and match.group(1)
+            # Convert into int (bug spotted in 7.0 because of str)
+            try:
+                thread_id = int(thread_id)
+            except:
+                thread_id = False
+        route = self.message_route_verify(
+            message, message_dict,
+            (fallback_model, thread_id, custom_values, self._uid, None),
+            update_author=True, assert_model=True)
+        if route:
+            _logger.info(
+                'Routing mail from %s to %s with Message-Id %s: fallback to model:%s, thread_id:%s, custom_values:%s, uid:%s',
+                email_from, email_to, message_id, fallback_model, thread_id, custom_values, self._uid)
+            return [route]
+
+        # ValueError if no routes found and if no bounce occured
+        raise ValueError(
+            'No possible route found for incoming message from %s to %s (Message-Id %s:). '
+            'Create an appropriate mail.alias or force the destination model.' %
+            (email_from, email_to, message_id)
+        )
+
+    @api.model
+    def message_route_process(self, message, message_dict, routes):
+        # postpone setting message_dict.partner_ids after message_post, to avoid double notifications
+        partner_ids = message_dict.pop('partner_ids', [])
+        thread_id = False
+        for model, thread_id, custom_values, user_id, alias in routes:
+            if model:
+                Model = self.env[model]
+                if not (thread_id and hasattr(Model, 'message_update') or hasattr(Model, 'message_new')):
+                    raise ValueError(
+                        "Undeliverable mail with Message-Id %s, model %s does not accept incoming emails" %
+                        (message_dict['message_id'], model)
+                    )
+
+                # disabled subscriptions during message_new/update to avoid having the system user running the
+                # email gateway become a follower of all inbound messages
+                MessageModel = Model.sudo(user_id).with_context(mail_create_nosubscribe=True, mail_create_nolog=True)
+                if thread_id and hasattr(MessageModel, 'message_update'):
+                    MessageModel.browse(thread_id).message_update(message_dict)
+                else:
+                    thread_id = MessageModel.message_new(message_dict, custom_values)
+            else:
+                if thread_id:
+                    raise ValueError("Posting a message without model should be with a null res_id, to create a private message.")
+                Model = self.env['mail.thread']
+            if not hasattr(Model, 'message_post'):
+                Model = self.env['mail.thread'].with_context(thread_model=model)
+            new_msg = Model.browse(thread_id).message_post(subtype='mail.mt_comment', **message_dict)
+
+            if partner_ids:
+                # postponed after message_post, because this is an external message and we don't want to create
+                # duplicate emails due to notifications
+                new_msg.write({'partner_ids': partner_ids})
+        return thread_id
+
+    @api.model
+    def message_process(self, model, message, custom_values=None,
+                        save_original=False, strip_attachments=False,
+                        thread_id=None):
+        """ Process an incoming RFC2822 email message, relying on
+            ``mail.message.parse()`` for the parsing operation,
+            and ``message_route()`` to figure out the target model.
+
+            Once the target model is known, its ``message_new`` method
+            is called with the new message (if the thread record did not exist)
+            or its ``message_update`` method (if it did).
+
+            There is a special case where the target model is False: a reply
+            to a private message. In this case, we skip the message_new /
+            message_update step, to just post a new message using mail_thread
+            message_post.
+
+           :param string model: the fallback model to use if the message
+               does not match any of the currently configured mail aliases
+               (may be None if a matching alias is supposed to be present)
+           :param message: source of the RFC2822 message
+           :type message: string or xmlrpclib.Binary
+           :type dict custom_values: optional dictionary of field values
+                to pass to ``message_new`` if a new record needs to be created.
+                Ignored if the thread record already exists, and also if a
+                matching mail.alias was found (aliases define their own defaults)
+           :param bool save_original: whether to keep a copy of the original
+                email source attached to the message after it is imported.
+           :param bool strip_attachments: whether to strip all attachments
+                before processing the message, in order to save some space.
+           :param int thread_id: optional ID of the record/thread from ``model``
+               to which this mail should be attached. When provided, this
+               overrides the automatic detection based on the message
+               headers.
+        """
+        # extract message bytes - we are forced to pass the message as binary because
+        # we don't know its encoding until we parse its headers and hence can't
+        # convert it to utf-8 for transport between the mailgate script and here.
+        if isinstance(message, xmlrpclib.Binary):
+            message = str(message.data)
+        # Warning: message_from_string doesn't always work correctly on unicode,
+        # we must use utf-8 strings here :-(
+        if isinstance(message, unicode):
+            message = message.encode('utf-8')
+        msg_txt = email.message_from_string(message)
+
+        # parse the message, verify we are not in a loop by checking message_id is not duplicated
+        msg = self.message_parse(msg_txt, save_original=save_original)
+        if strip_attachments:
+            msg.pop('attachments', None)
+
+        if msg.get('message_id'):   # should always be True as message_parse generate one if missing
+            existing_msg_ids = self.env['mail.message'].search([('message_id', '=', msg.get('message_id'))])
+            if existing_msg_ids:
+                _logger.info('Ignored mail from %s to %s with Message-Id %s: found duplicated Message-Id during processing',
+                                msg.get('from'), msg.get('to'), msg.get('message_id'))
+                return False
+
+        # find possible routes for the message
+        routes = self.message_route(msg_txt, msg, model, thread_id, custom_values)
+        thread_id = self.message_route_process(msg_txt, msg, routes)
+        return thread_id
+
+    @api.model
+    def message_new(self, msg_dict, custom_values=None):
+        """Called by ``message_process`` when a new message is received
+           for a given thread model, if the message did not belong to
+           an existing thread.
+           The default behavior is to create a new record of the corresponding
+           model (based on some very basic info extracted from the message).
+           Additional behavior may be implemented by overriding this method.
+
+           :param dict msg_dict: a map containing the email details and
+                                 attachments. See ``message_process`` and
+                                ``mail.message.parse`` for details.
+           :param dict custom_values: optional dictionary of additional
+                                      field values to pass to create()
+                                      when creating the new thread record.
+                                      Be careful, these values may override
+                                      any other values coming from the message.
+           :param dict context: if a ``thread_model`` value is present
+                                in the context, its value will be used
+                                to determine the model of the record
+                                to create (instead of the current model).
+           :rtype: int
+           :return: the id of the newly created thread object
+        """
+        data = {}
+        if isinstance(custom_values, dict):
+            data = custom_values.copy()
+        model = self._context.get('thread_model') or self._name
+        RecordModel = self.env[model]
+        fields = RecordModel.fields_get()
+        if 'name' in fields and not data.get('name'):
+            data['name'] = msg_dict.get('subject', '')
+        res = RecordModel.create(data)
+        return res.id
+
+    @api.multi
+    def message_update(self, msg_dict, update_vals=None):
+        """Called by ``message_process`` when a new message is received
+           for an existing thread. The default behavior is to update the record
+           with update_vals taken from the incoming email.
+           Additional behavior may be implemented by overriding this
+           method.
+           :param dict msg_dict: a map containing the email details and
+                               attachments. See ``message_process`` and
+                               ``mail.message.parse()`` for details.
+           :param dict update_vals: a dict containing values to update records
+                              given their ids; if the dict is None or is
+                              void, no write operation is performed.
+        """
+        if update_vals:
+            self.write(update_vals)
+        return True
+
+    def _message_extract_payload(self, message, save_original=False):
+        """Extract body as HTML and attachments from the mail message"""
+        attachments = []
+        body = u''
+        if save_original:
+            attachments.append(('original_email.eml', message.as_string()))
+
+        # Be careful, content-type may contain tricky content like in the
+        # following example so test the MIME type with startswith()
+        #
+        # Content-Type: multipart/related;
+        #   boundary="_004_3f1e4da175f349248b8d43cdeb9866f1AMSPR06MB343eurprd06pro_";
+        #   type="text/html"
+        if not message.is_multipart() or message.get('content-type', '').startswith("text/"):
+            encoding = message.get_content_charset()
+            body = message.get_payload(decode=True)
+            body = tools.ustr(body, encoding, errors='replace')
+            if message.get_content_type() == 'text/plain':
+                # text/plain -> <pre/>
+                body = tools.append_content_to_html(u'', body, preserve=True)
+        else:
+            alternative = False
+            mixed = False
+            html = u''
+            for part in message.walk():
+                if part.get_content_type() == 'multipart/alternative':
+                    alternative = True
+                if part.get_content_type() == 'multipart/mixed':
+                    mixed = True
+                if part.get_content_maintype() == 'multipart':
+                    continue  # skip container
+                # part.get_filename returns decoded value if able to decode, coded otherwise.
+                # original get_filename is not able to decode iso-8859-1 (for instance).
+                # therefore, iso encoded attachements are not able to be decoded properly with get_filename
+                # code here partially copy the original get_filename method, but handle more encoding
+                filename=part.get_param('filename', None, 'content-disposition')
+                if not filename:
+                    filename=part.get_param('name', None)
+                if filename:
+                    if isinstance(filename, tuple):
+                        # RFC2231
+                        filename=email.utils.collapse_rfc2231_value(filename).strip()
+                    else:
+                        filename=decode(filename)
+                encoding = part.get_content_charset()  # None if attachment
+                # 1) Explicit Attachments -> attachments
+                if filename or part.get('content-disposition', '').strip().startswith('attachment'):
+                    attachments.append((filename or 'attachment', part.get_payload(decode=True)))
+                    continue
+                # 2) text/plain -> <pre/>
+                if part.get_content_type() == 'text/plain' and (not alternative or not body):
+                    body = tools.append_content_to_html(body, tools.ustr(part.get_payload(decode=True),
+                                                                         encoding, errors='replace'), preserve=True)
+                # 3) text/html -> raw
+                elif part.get_content_type() == 'text/html':
+                    # mutlipart/alternative have one text and a html part, keep only the second
+                    # mixed allows several html parts, append html content
+                    append_content = not alternative or (html and mixed)
+                    html = tools.ustr(part.get_payload(decode=True), encoding, errors='replace')
+                    if not append_content:
+                        body = html
+                    else:
+                        body = tools.append_content_to_html(body, html, plaintext=False)
+                # 4) Anything else -> attachment
+                else:
+                    attachments.append((filename or 'attachment', part.get_payload(decode=True)))
+        return body, attachments
+
+    @api.model
+    def message_parse(self, message, save_original=False):
+        """Parses a string or email.message.Message representing an
+           RFC-2822 email, and returns a generic dict holding the
+           message details.
+
+           :param message: the message to parse
+           :type message: email.message.Message | string | unicode
+           :param bool save_original: whether the returned dict
+               should include an ``original`` attachment containing
+               the source of the message
+           :rtype: dict
+           :return: A dict with the following structure, where each
+                    field may not be present if missing in original
+                    message::
+
+                    { 'message_id': msg_id,
+                      'subject': subject,
+                      'from': from,
+                      'to': to,
+                      'cc': cc,
+                      'body': unified_body,
+                      'attachments': [('file1', 'bytes'),
+                                      ('file2', 'bytes')}
+                    }
+        """
+        msg_dict = {
+            'message_type': 'email',
+        }
+        if not isinstance(message, Message):
+            if isinstance(message, unicode):
+                # Warning: message_from_string doesn't always work correctly on unicode,
+                # we must use utf-8 strings here :-(
+                message = message.encode('utf-8')
+            message = email.message_from_string(message)
+
+        message_id = message['message-id']
+        if not message_id:
+            # Very unusual situation, be we should be fault-tolerant here
+            message_id = "<%s@localhost>" % time.time()
+            _logger.debug('Parsing Message without message-id, generating a random one: %s', message_id)
+        msg_dict['message_id'] = message_id
+
+        if message.get('Subject'):
+            msg_dict['subject'] = decode(message.get('Subject'))
+
+        # Envelope fields not stored in mail.message but made available for message_new()
+        msg_dict['from'] = decode(message.get('from'))
+        msg_dict['to'] = decode(message.get('to'))
+        msg_dict['cc'] = decode(message.get('cc'))
+        msg_dict['email_from'] = decode(message.get('from'))
+        partner_ids = self._message_find_partners(message, ['To', 'Cc'])
+        msg_dict['partner_ids'] = [(4, partner_id) for partner_id in partner_ids]
+
+        if message.get('Date'):
+            try:
+                date_hdr = decode(message.get('Date'))
+                parsed_date = dateutil.parser.parse(date_hdr, fuzzy=True)
+                if parsed_date.utcoffset() is None:
+                    # naive datetime, so we arbitrarily decide to make it
+                    # UTC, there's no better choice. Should not happen,
+                    # as RFC2822 requires timezone offset in Date headers.
+                    stored_date = parsed_date.replace(tzinfo=pytz.utc)
+                else:
+                    stored_date = parsed_date.astimezone(tz=pytz.utc)
+            except Exception:
+                _logger.info('Failed to parse Date header %r in incoming mail '
+                                'with message-id %r, assuming current date/time.',
+                                message.get('Date'), message_id)
+                stored_date = datetime.datetime.now()
+            msg_dict['date'] = stored_date.strftime(tools.DEFAULT_SERVER_DATETIME_FORMAT)
+
+        if message.get('In-Reply-To'):
+            parent_ids = self.env['mail.message'].search([('message_id', '=', decode(message['In-Reply-To'].strip()))], limit=1)
+            if parent_ids:
+                msg_dict['parent_id'] = parent_ids.id
+
+        if message.get('References') and 'parent_id' not in msg_dict:
+            msg_list = mail_header_msgid_re.findall(decode(message['References']))
+            parent_ids = self.env['mail.message'].search([('message_id', 'in', [x.strip() for x in msg_list])], limit=1)
+            if parent_ids:
+                msg_dict['parent_id'] = parent_ids.id
+
+        msg_dict['body'], msg_dict['attachments'] = self._message_extract_payload(message, save_original=save_original)
+        return msg_dict
+
+    #------------------------------------------------------
+    # Note specific
+    #------------------------------------------------------
+
+    @api.multi
+    def _message_add_suggested_recipient(self, result, partner=None, email=None, reason=''):
+        """ Called by message_get_suggested_recipients, to add a suggested
+            recipient in the result dictionary. The form is :
+                partner_id, partner_name<partner_email> or partner_name, reason """
+        self.ensure_one()
+        if email and not partner:
+            # get partner info from email
+            partner_info = self.message_partner_info_from_emails([email])[0]
+            if partner_info.get('partner_id'):
+                partner = self.env['res.partner'].sudo().browse([partner_info['partner_id']])[0]
+        if email and email in [val[1] for val in result[self.ids[0]]]:  # already existing email -> skip
+            return result
+        if partner and partner in self.message_follower_ids:  # recipient already in the followers -> skip
+            return result
+        if partner and partner.id in [val[0] for val in result[self.ids[0]]]:  # already existing partner ID -> skip
+            return result
+        if partner and partner.email:  # complete profile: id, name <email>
+            result[self.ids[0]].append((partner.id, '%s<%s>' % (partner.name, partner.email), reason))
+        elif partner:  # incomplete profile: id, name
+            result[self.ids[0]].append((partner.id, '%s' % (partner.name), reason))
+        else:  # unknown partner, we are probably managing an email address
+            result[self.ids[0]].append((False, email, reason))
+        return result
+
+    @api.multi
+    def message_get_suggested_recipients(self):
+        """ Returns suggested recipients for ids. Those are a list of
+        tuple (partner_id, partner_name, reason), to be managed by Chatter. """
+        result = dict((res_id, []) for res_id in self.ids)
+        if 'user_id' in self._fields:
+            for obj in self.sudo():  # SUPERUSER because of a read on res.users that would crash otherwise
+                if not obj.user_id or not obj.user_id.partner_id:
+                    continue
+                obj._message_add_suggested_recipient(result, partner=obj.user_id.partner_id, reason=self._fields['user_id'].string)
+        return result
+
+    @api.model
+    def _find_partner_from_emails(self, emails, res_model=None, res_id=None, check_followers=True):
+        """ Utility method to find partners from email addresses. The rules are :
+            1 - check in document (model | self, id) followers
+            2 - try to find a matching partner that is also an user
+            3 - try to find a matching partner
+
+            :param list emails: list of email addresses
+            :param string model: model to fetch related record; by default self
+                is used.
+            :param boolean check_followers: check in document followers
+        """
+        if res_model is None:
+            res_model = self._name
+        if res_id is None and self.ids:
+            res_id = self.ids[0]
+        followers = self.env['res.partner']
+        if res_model and res_id:
+            record = self.env[res_model].browse(res_id)
+            if hasattr(record, 'message_follower_ids'):
+                followers = record.message_follower_ids
+
+        Partner = self.env['res.partner'].sudo()
+        partner_ids = []
+
+        for contact in emails:
+            partner_id = False
+            email_address = tools.email_split(contact)
+            if not email_address:
+                partner_ids.append(partner_id)
+                continue
+            email_address = email_address[0]
+            # first try: check in document's followers
+            for follower in followers:
+                if follower.email == email_address:
+                    partner_id = follower.id
+                    break
+            # second try: check in partners that are also users
+            # Escape special SQL characters in email_address to avoid invalid matches
+            email_address = (email_address.replace('\\', '\\\\').replace('%', '\\%').replace('_', '\\_'))
+            email_brackets = "<%s>" % email_address
+            if not partner_id:
+                # exact, case-insensitive match
+                partners = Partner.search([('email', '=ilike', email_address), ('user_ids', '!=', False)], limit=1)
+                if not partners:
+                    # if no match with addr-spec, attempt substring match within name-addr pair
+                    partners = Partner.search([('email', 'ilike', email_brackets), ('user_ids', '!=', False)], limit=1)
+                if partners:
+                    partner_id = partners[0].id
+            # third try: check in partners
+            if not partner_id:
+                # exact, case-insensitive match
+                partners = Partner.search([('email', '=ilike', email_address)], limit=1)
+                if not partners:
+                    # if no match with addr-spec, attempt substring match within name-addr pair
+                    partners = Partner.search([('email', 'ilike', email_brackets)], limit=1)
+                if partners:
+                    partner_id = partners[0].id
+            partner_ids.append(partner_id)
+        return partner_ids
+
+    @api.multi
+    def message_partner_info_from_emails(self, emails, link_mail=False):
+        """ Convert a list of emails into a list partner_ids and a list
+            new_partner_ids. The return value is non conventional because
+            it is meant to be used by the mail widget.
+
+            :return dict: partner_ids and new_partner_ids """
+        self.ensure_one()
+        MailMessage = self.env['mail.message'].sudo()
+        partner_ids = self._find_partner_from_emails(emails)
+        result = list()
+        for idx in range(len(emails)):
+            email_address = emails[idx]
+            partner_id = partner_ids[idx]
+            partner_info = {'full_name': email_address, 'partner_id': partner_id}
+            result.append(partner_info)
+            # link mail with this from mail to the new partner id
+            if link_mail and partner_info['partner_id']:
+                # Escape special SQL characters in email_address to avoid invalid matches
+                email_address = (email_address.replace('\\', '\\\\').replace('%', '\\%').replace('_', '\\_'))
+                email_brackets = "<%s>" % email_address
+                MailMessage.search([
+                    '|',
+                    ('email_from', '=ilike', email_address),
+                    ('email_from', 'ilike', email_brackets),
+                    ('author_id', '=', False)
+                ]).write({'author_id': partner_info['partner_id']})
+        return result
+
+    @api.model
+    def _message_preprocess_attachments(self, attachments, attachment_ids, attach_model, attach_res_id):
+        """ Preprocess attachments for mail_thread.message_post() or mail_mail.create().
+
+        :param list attachments: list of attachment tuples in the form ``(name,content)``,
+                                 where content is NOT base64 encoded
+        :param list attachment_ids: a list of attachment ids, not in tomany command form
+        :param str attach_model: the model of the attachments parent record
+        :param integer attach_res_id: the id of the attachments parent record
+        """
+        m2m_attachment_ids = []
+        if attachment_ids:
+            filtered_attachment_ids = self.env['ir.attachment'].sudo().search([
+                ('res_model', '=', 'mail.compose.message'),
+                ('create_uid', '=', self._uid),
+                ('id', 'in', attachment_ids)])
+            if filtered_attachment_ids:
+                filtered_attachment_ids.write({'res_model': attach_model, 'res_id': attach_res_id})
+            m2m_attachment_ids += [(4, id) for id in attachment_ids]
+        # Handle attachments parameter, that is a dictionary of attachments
+        for name, content in attachments:
+            if isinstance(content, unicode):
+                content = content.encode('utf-8')
+            data_attach = {
+                'name': name,
+                'datas': base64.b64encode(str(content)),
+                'datas_fname': name,
+                'description': name,
+                'res_model': attach_model,
+                'res_id': attach_res_id,
+            }
+            m2m_attachment_ids.append((0, 0, data_attach))
+        return m2m_attachment_ids
+
+    @api.multi
+    @api.returns('self', lambda value: value.id)
+    def message_post(self, body='', subject=None, message_type='notification',
+                     subtype=None, parent_id=False, attachments=None, context=None,
+                     content_subtype='html', **kwargs):
+        """ Post a new message in an existing thread, returning the new
+            mail.message ID.
+
+            :param int thread_id: thread ID to post into, or list with one ID;
+                if False/0, mail.message model will also be set as False
+            :param str body: body of the message, usually raw HTML that will
+                be sanitized
+            :param str type: see mail_message.type field
+            :param str content_subtype:: if plaintext: convert body into html
+            :param int parent_id: handle reply to a previous message by adding the
+                parent partners to the message in case of private discussion
+            :param tuple(str,str) attachments or list id: list of attachment tuples in the form
+                ``(name,content)``, where content is NOT base64 encoded
+
+            Extra keyword arguments will be used as default column values for the
+            new mail.message record. Special cases:
+                - attachment_ids: supposed not attached to any document; attach them
+                    to the related document. Should only be set by Chatter.
+            :return int: ID of newly created mail.message
+        """
+        if attachments is None:
+            attachments = {}
+        if self.ids and not self.ensure_one():
+            raise exceptions.Warning(_('Invalid record set: should be called as model (without records) or on single-record recordset'))
+
+        # if we're processing a message directly coming from the gateway, the destination model was
+        # set in the context.
+        model = False
+        if self.ids:
+            self.ensure_one()
+            model = self._context.get('thread_model', False) if self._name == 'mail.thread' else self._name
+            if model and model != self._name and hasattr(self.env[model], 'message_post'):
+                RecordModel = self.env[model].with_context(thread_model=None)  # TDE: was removing the key ?
+                return RecordModel.browse(self.ids).message_post(
+                    body=body, subject=subject, message_type=message_type,
+                    subtype=subtype, parent_id=parent_id, attachments=attachments,
+                    content_subtype=content_subtype, **kwargs)
+
+        # 0: Find the message's author, because we need it for private discussion
+        author_id = kwargs.get('author_id')
+        if author_id is None:  # keep False values
+            author_id = self.env['mail.message']._get_default_author()
+
+        # 1: Handle content subtype: if plaintext, converto into HTML
+        if content_subtype == 'plaintext':
+            body = tools.plaintext2html(body)
+
+        # 2: Private message: add recipients (recipients and author of parent message) - current author
+        #   + legacy-code management (! we manage only 4 and 6 commands)
+        partner_ids = set()
+        kwargs_partner_ids = kwargs.pop('partner_ids', [])
+        for partner_id in kwargs_partner_ids:
+            if isinstance(partner_id, (list, tuple)) and partner_id[0] == 4 and len(partner_id) == 2:
+                partner_ids.add(partner_id[1])
+            if isinstance(partner_id, (list, tuple)) and partner_id[0] == 6 and len(partner_id) == 3:
+                partner_ids |= set(partner_id[2])
+            elif isinstance(partner_id, (int, long)):
+                partner_ids.add(partner_id)
+            else:
+                pass  # we do not manage anything else
+        if parent_id and not model:
+            parent_message = self.env['mail.message'].browse(parent_id)
+            private_followers = set([partner.id for partner in parent_message.partner_ids])
+            if parent_message.author_id:
+                private_followers.add(parent_message.author_id.id)
+            private_followers -= set([author_id])
+            partner_ids |= private_followers
+
+        # 3. Attachments
+        #   - HACK TDE FIXME: Chatter: attachments linked to the document (not done JS-side), load the message
+        attachment_ids = self._message_preprocess_attachments(
+            attachments, kwargs.pop('attachment_ids', []), model, self.ids and self.ids[0] or None)
+
+        # 4: mail.message.subtype
+        subtype_id = False
+        if subtype:
+            if '.' not in subtype:
+                subtype = 'mail.%s' % subtype
+            subtype_id = self.env['ir.model.data'].xmlid_to_res_id(subtype)
+
+        # automatically subscribe recipients if asked to
+        if self._context.get('mail_post_autofollow') and self.ids and partner_ids:
+            partner_to_subscribe = partner_ids
+            if self._context.get('mail_post_autofollow_partner_ids'):
+                partner_to_subscribe = filter(lambda item: item in self._context.get('mail_post_autofollow_partner_ids'), partner_ids)
+            self.message_subscribe(list(partner_to_subscribe))
+
+        # _mail_flat_thread: automatically set free messages to the first posted message
+        MailMessage = self.env['mail.message']
+        if self._mail_flat_thread and model and not parent_id and self.ids:
+            messages = MailMessage.search(['&', ('res_id', '=', self.ids[0]), ('model', '=', model), ('message_type', '=', 'email')], order="id ASC", limit=1)
+            if not messages:
+                messages = MailMessage.search(['&', ('res_id', '=', self.ids[0]), ('model', '=', model)], order="id ASC", limit=1)
+            parent_id = messages and messages[0].id or False
+        # we want to set a parent: force to set the parent_id to the oldest ancestor, to avoid having more than 1 level of thread
+        elif parent_id:
+            messages = MailMessage.sudo().search([('id', '=', parent_id), ('parent_id', '!=', False)], limit=1)
+            # avoid loops when finding ancestors
+            processed_list = []
+            if messages:
+                message = messages[0]
+                while (message.parent_id and message.parent_id.id not in processed_list):
+                    processed_list.append(message.parent_id.id)
+                    message = message.parent_id
+                parent_id = message.id
+
+        values = kwargs
+        values.update({
+            'author_id': author_id,
+            'model': model,
+            'res_id': model and self.ids[0] or False,
+            'body': body,
+            'subject': subject or False,
+            'message_type': message_type,
+            'parent_id': parent_id,
+            'attachment_ids': attachment_ids,
+            'subtype_id': subtype_id,
+            'partner_ids': [(4, pid) for pid in partner_ids],
+        })
+
+        # Avoid warnings about non-existing fields
+        for x in ('from', 'to', 'cc'):
+            values.pop(x, None)
+
+        # Post the message
+        new_message = MailMessage.create(values)
+
+        # Post-process: subscribe author, update message_last_post
+        if model and model != 'mail.thread' and self.ids and subtype_id:
+            # done with SUPERUSER_ID, because on some models users can post only with read access, not necessarily write access
+            self.sudo().write({'message_last_post': fields.datetime.now()})
+        if new_message.author_id and model and self.ids and message_type != 'notification' and not self._context.get('mail_create_nosubscribe'):
+            self.message_subscribe([new_message.author_id.id])
+        return new_message
+
+    # ------------------------------------------------------
+    # Followers API
+    # ------------------------------------------------------
+
+    @api.multi
+    def message_get_subscription_data(self, user_pid=None):
+        # TDE CLEANME: is that method usefull ?
+        """ Wrapper to get subtypes data. """
+        return self._get_subscription_data(user_pid=user_pid)
+
+    @api.multi
+    def message_subscribe_users(self, user_ids=None, subtype_ids=None):
+        """ Wrapper on message_subscribe, using users. If user_ids is not
+            provided, subscribe uid instead. """
+        if user_ids is None:
+            user_ids = [self._uid]
+        result = self.message_subscribe(self.env['res.users'].browse(user_ids).mapped('partner_id').ids, subtype_ids=subtype_ids)
+        if user_ids and result:
+            self.pool['ir.ui.menu'].clear_cache()
+        return result
+
+    @api.multi
+    def message_subscribe(self, partner_ids, subtype_ids=None, context=None):
+        """ Add partners to the records followers. """
+        # not necessary for computation, but saves an access right check
+        if not partner_ids:
+            return True
+
+        Followers = self.env['mail.followers']
+        Subtype = self.env['mail.message.subtype']
+
+        if set(partner_ids) == set([self.env.user.partner_id.id]):
+            try:
+                self.check_access_rights('read')
+                self.check_access_rule('read')
+            except exceptions.AccessError:
+                return False
+        else:
+            self.check_access_rights('write')
+            self.check_access_rule('write')
+
+        existing_pids_dict = dict.fromkeys(self.ids, self.env['res.partner'])
+        followers = Followers.sudo().search([
+            '&', '&',
+            ('res_model', '=', self._name),
+            ('res_id', 'in', self.ids),
+            ('partner_id', 'in', partner_ids)])
+        for follower in followers:
+            existing_pids_dict[follower.res_id] |= follower.partner_id
+
+        # subtype_ids specified: update already subscribed partners
+        if subtype_ids and followers:
+            followers.write({'subtype_ids': [(6, 0, subtype_ids)]})
+        # subtype_ids not specified: do not update already subscribed partner, fetch default subtypes for new partners
+        if subtype_ids is None:
+            subtype_ids = Subtype.search([
+                ('default', '=', True),
+                '|',
+                ('res_model', '=', self._name),
+                ('res_model', '=', False)]).ids
+
+        for record in self:
+            existing_pids = existing_pids_dict[record.id]
+            new_partners = self.env['res.partner'].browse(partner_ids) - existing_pids
+
+            # subscribe new followers
+            for new_partner in new_partners:
+                Followers.sudo().create({
+                    'res_model': self._name,
+                    'res_id': record.id,
+                    'partner_id': new_partner.id,
+                    'subtype_ids': [(6, 0, subtype_ids)]})
+
+        return True
+
+    @api.multi
+    def message_unsubscribe_users(self, user_ids=None):
+        """ Wrapper on message_subscribe, using users. If user_ids is not
+            provided, unsubscribe uid instead. """
+        if user_ids is None:
+            user_ids = [self._uid]
+        partner_ids = [user.partner_id.id for user in self.env['res.users'].browse(user_ids)]
+        result = self.message_unsubscribe(partner_ids)
+        if partner_ids and result:
+            self.pool['ir.ui.menu'].clear_cache()
+        return result
+
+    @api.multi
+    def message_unsubscribe(self, partner_ids):
+        """ Remove partners from the records followers. """
+        # not necessary for computation, but saves an access right check
+        if not partner_ids:
+            return True
+        user_pid = self.env.user.partner_id.id
+        if set(partner_ids) == set([user_pid]):
+            self.check_access_rights('read')
+            self.check_access_rule('read')
+        else:
+            self.check_access_rights('write')
+            self.check_access_rule('write')
+        self.env['mail.followers'].sudo().search([
+            ('res_model', '=', self._name),
+            ('res_id', 'in', self.ids),
+            ('partner_id', 'in', partner_ids)
+        ]).unlink()
+
+    @api.model
+    def _message_get_auto_subscribe_fields(self, updated_fields, auto_follow_fields=None):
+        """ Returns the list of relational fields linking to res.users that should
+            trigger an auto subscribe. The default list checks for the fields
+            - called 'user_id'
+            - linking to res.users
+            - with track_visibility set
+            In OpenERP V7, this is sufficent for all major addon such as opportunity,
+            project, issue, recruitment, sale.
+            Override this method if a custom behavior is needed about fields
+            that automatically subscribe users.
+        """
+        if auto_follow_fields is None:
+            auto_follow_fields = ['user_id']
+        user_field_lst = []
+        for name, field in self._fields.items():
+            if name in auto_follow_fields and name in updated_fields and getattr(field, 'track_visibility', False) and field.comodel_name == 'res.users':
+                user_field_lst.append(name)
+        return user_field_lst
+
+    @api.multi
+    def _message_auto_subscribe_notify(self, partner_ids):
+        """ Send notifications to the partners automatically subscribed to the thread
+            Override this method if a custom behavior is needed about partners
+            that should be notified or messages that should be sent
+        """
+        # find first email message, set it as unread for auto_subscribe fields for them to have a notification
+        if not partner_ids:
+            return
+        for record_id in self.ids:
+            # TDE FIXME: is sudo necessary / a goot option ?
+            MailMessage = self.env['mail.message'].sudo()
+            messages = MailMessage.search([
+                ('model', '=', self._name),
+                ('res_id', '=', record_id),
+                ('message_type', '=', 'email')], limit=1)
+            if not messages:
+                messages = MailMessage.search([
+                    ('model', '=', self._name),
+                    ('res_id', '=', record_id)], limit=1)
+            if messages:
+                message = messages[0]
+                notification_obj = self.env['mail.notification']
+                partners = self.env['res.partner'].sudo().browse(partner_ids)
+                notification_obj._notify(message, recipients=partners)
+                if message.parent_id:
+                    partner_ids_to_parent_notify = set(partner_ids).difference(partner.id for partner in message.parent_id.notified_partner_ids)
+                    for partner_id in partner_ids_to_parent_notify:
+                        notification_obj.create({
+                            'message_id': message.parent_id.id,
+                            'partner_id': partner_id,
+                            'is_read': True,
+                        })
+
+    @api.multi
+    def message_auto_subscribe(self, updated_fields, values=None):
+        """ Handle auto subscription. Two methods for auto subscription exist:
+
+         - tracked res.users relational fields, such as user_id fields. Those fields
+           must be relation fields toward a res.users record, and must have the
+           track_visilibity attribute set.
+         - using subtypes parent relationship: check if the current model being
+           modified has an header record (such as a project for tasks) whose followers
+           can be added as followers of the current records. Example of structure
+           with project and task:
+
+          - st_project_1.parent_id = st_task_1
+          - st_project_1.res_model = 'project.project'
+          - st_project_1.relation_field = 'project_id'
+          - st_task_1.model = 'project.task'
+
+        :param list updated_fields: list of updated fields to track
+        :param dict values: updated values; if None, the first record will be browsed
+                            to get the values. Added after releasing 7.0, therefore
+                            not merged with updated_fields argumment.
+        """
+        new_followers = dict()
+
+        # fetch auto_follow_fields: res.users relation fields whose changes are tracked for subscription
+        user_field_lst = self._message_get_auto_subscribe_fields(updated_fields)
+
+        # fetch header subtypes
+        subtypes = self.env['mail.message.subtype'].search(['|', ('res_model', '=', False), ('parent_id.res_model', '=', self._name)])
+
+        # if no change in tracked field or no change in tracked relational field: quit
+        relation_fields = set([subtype.relation_field for subtype in subtypes if subtype.relation_field is not False])
+        if not any(relation in updated_fields for relation in relation_fields) and not user_field_lst:
+            return True
+
+        # legacy behavior: if values is not given, compute the values by browsing
+        # @TDENOTE: remove me in 8.0
+        if values is None:
+            record = self[0]
+            for updated_field in updated_fields:
+                field_value = getattr(record, updated_field)
+                if isinstance(field_value, models.BaseModel):
+                    field_value = field_value.id
+                values[updated_field] = field_value
+
+        # find followers of headers, update structure for new followers
+        headers = set()
+        for subtype in subtypes:
+            if subtype.relation_field and values.get(subtype.relation_field):
+                headers.add((subtype.res_model, values.get(subtype.relation_field)))
+        if headers:
+            header_domain = ['|'] * (len(headers) - 1)
+            for header in headers:
+                header_domain += ['&', ('res_model', '=', header[0]), ('res_id', '=', header[1])]
+            for header_follower in self.env['mail.followers'].sudo().search(header_domain):
+                for subtype in header_follower.subtype_ids:
+                    if subtype.parent_id and subtype.parent_id.res_model == self._name:
+                        new_followers.setdefault(header_follower.partner_id.id, set()).add(subtype.parent_id.id)
+                    elif subtype.res_model is False:
+                        new_followers.setdefault(header_follower.partner_id.id, set()).add(subtype.id)
+
+        # add followers coming from res.users relational fields that are tracked
+        user_ids = [values[name] for name in user_field_lst if values.get(name)]
+        user_pids = [user.partner_id.id for user in self.env['res.users'].sudo().browse(user_ids)]
+        for partner_id in user_pids:
+            new_followers.setdefault(partner_id, None)
+
+        for pid, subtypes in new_followers.items():
+            subtypes = list(subtypes) if subtypes is not None else None
+            self.message_subscribe([pid], subtypes)
+
+        self._message_auto_subscribe_notify(user_pids)
+
+        return True
+
+    # ------------------------------------------------------
+    # Thread management
+    # ------------------------------------------------------
+
+    @api.multi
+    def message_mark_as_unread(self):
+        """ Set as unread. """
+        partner_id = self.env.user.partner_id.id
+        self._cr.execute('''
+            UPDATE mail_notification SET
+                is_read=false
+            WHERE
+                message_id IN (SELECT id from mail_message where res_id=any(%s) and model=%s limit 1) and
+                partner_id = %s
+        ''', (self.ids, self._name, partner_id))
+        self.env['mail.notification'].invalidate_cache(['is_read'])
+        return True
+
+    @api.multi
+    def message_mark_as_read(self):
+        """ Set as read. """
+        partner_id = self.env.user.partner_id.id
+        self._cr.execute('''
+            UPDATE mail_notification SET
+                is_read=true
+            WHERE
+                message_id IN (SELECT id FROM mail_message WHERE res_id=ANY(%s) AND model=%s) AND
+                partner_id = %s
+        ''', (self.ids, self._name, partner_id))
+        self.env['mail.notification'].invalidate_cache(['is_read'])
+        return True
+
+    @api.model
+    def get_suggested_thread(self, removed_suggested_threads=None):
+        """Return a list of suggested threads, sorted by the numbers of followers"""
+        # TDE HACK: originally by MAT from portal/mail_mail.py but not working until the inheritance graph bug is not solved in trunk
+        # TDE FIXME: relocate in portal when it won't be necessary to reload the hr.employee model in an additional bridge module
+        if 'is_portal' in self.pool['res.groups']._fields:
+            if any(group.is_portal for group in self.env.user.sudo().groups_id):
+                return []
+
+        threads = []
+        if removed_suggested_threads is None:
+            removed_suggested_threads = []
+
+        for thread in self.search([('id', 'not in', removed_suggested_threads), ('message_is_follower', '=', False)]):
+            data = {
+                'id': thread.id,
+                'popularity': len(thread.message_follower_ids),
+                'name': thread.name,
+                'image_small': thread.image_small
+            }
+            threads.append(data)
+        return sorted(threads, key=lambda x: (x['popularity'], x['id']), reverse=True)[:3]
+
+    @api.multi
+    def message_change_thread(self, new_thread):
+        """
+        Transfer the list of the mail thread messages from an model to another
+
+        :param id : the old res_id of the mail.message
+        :param new_res_id : the new res_id of the mail.message
+        :param new_model : the name of the new model of the mail.message
+
+        Example :   my_lead.message_change_thread(my_project_issue)
+                    will transfer the context of the thread of my_lead to my_project_issue
+        """
+        self.ensuer_one()
+        # get the sbtype id of the comment Message
+        subtype_res_id = self.env.ref('mail.mt_comment')
+
+        # get the ids of the comment and not-comment of the thread
+        # TDE check: sudo on mail.message, to be sure all messages are moved ?
+        MailMessage = self.env['mail.message']
+        msg_comment = MailMessage.search([
+            ('model', '=', self._name),
+            ('res_id', '=', id),
+            ('subtype_id', '=', subtype_res_id)])
+        msg_not_comment = MailMessage.search([
+            ('model', '=', self._name),
+            ('res_id', '=', id),
+            ('subtype_id', '!=', subtype_res_id)])
+
+        # update the messages
+        msg_comment.write({"res_id": new_thread.id, "model": new_thread._name})
+        msg_not_comment.write({"res_id": new_thread.id, "model": new_thread._name, "subtype_id": None})
+        return True

--- a/None
+++ b/addons/mail/models/res_config.py
@@ -0,0 +1,36 @@
+# -*- coding: utf-8 -*-
+
+import urlparse
+import datetime
+
+from openerp import fields, models, tools
+
+
+class BaseConfiguration(models.TransientModel):
+    """ Inherit the base settings to add a counter of failed email + configure
+    the alias domain. """
+    _inherit = 'base.config.settings'
+
+    fail_counter = fields.Integer('Fail Mail', readonly=True)
+    alias_domain = fields.Char('Alias Domain', help="If you have setup a catch-all email domain redirected to "
+                               "the Odoo server, enter the domain name here.")
+
+    def get_default_fail_counter(self):
+        previous_date = datetime.datetime.now() - datetime.timedelta(days=30)
+        return {
+            'fail_counter': self.env['mail.mail'].sudo().search([('date', '>=', previous_date.strftime(tools.DEFAULT_SERVER_DATETIME_FORMAT)), ('state', '=', 'exception')], count=True)
+        }
+
+    def get_default_alias_domain(self):
+        alias_domain = self.env["ir.config_parameter"].get_param("mail.catchall.domain", default=None)
+        if alias_domain is None:
+            domain = self.env["ir.config_parameter"].get_param("web.base.url")
+            try:
+                alias_domain = urlparse.urlsplit(domain).netloc.split(':')[0]
+            except Exception:
+                pass
+        return {'alias_domain': alias_domain or False}
+
+    def set_alias_domain(self):
+        for record in self:
+            self.env['ir.config_parameter'].set_param("mail.catchall.domain", record.alias_domain or '')

--- a/None
+++ b/addons/mail/models/res_partner.py
@@ -0,0 +1,33 @@
+# -*- coding: utf-8 -*-
+
+from openerp import _, fields, models
+
+
+class Partner(models.Model):
+    """ Update partner to add a field about notification preferences. Add a generic opt-out field that can be used
+       to restrict usage of automatic email templates. """
+    _name = "res.partner"
+    _inherit = ['res.partner', 'mail.thread']
+    _mail_flat_thread = False
+    _mail_mass_mailing = _('Customers')
+
+    notify_email = fields.Selection([
+        ('none', 'Never'),
+        ('always', 'All Messages')],
+        'Receive Inbox Notifications by Email', required=True,
+        oldname='notification_email_send', default='always',
+        help="Policy to receive emails for new messages pushed to your personal Inbox:\n"
+             "- Never: no emails are sent\n"
+             "- All Messages: for every notification you receive in your Inbox")
+    opt_out = fields.Boolean(
+        'Opt-Out', help="If opt-out is checked, this contact has refused to receive emails for mass mailing and marketing campaign. "
+                        "Filter 'Available for Mass Mailing' allows users to filter the partners when performing mass mailing.")
+
+    def message_get_suggested_recipients(self):
+        recipients = super(Partner, self).message_get_suggested_recipients()
+        for partner in self:
+            self._message_add_suggested_recipient(recipients, partner, partner=partner, reason=_('Partner Profile'))
+        return recipients
+
+    def message_get_default_recipients(self):
+        return dict((res_id, {'partner_ids': [res_id], 'email_to': False, 'email_cc': False}) for res_id in self.ids)

--- a/None
+++ b/addons/mail/models/res_users.py
@@ -0,0 +1,163 @@
+# -*- coding: utf-8 -*-
+
+from openerp import _, api, fields, models
+import openerp
+
+
+class Users(models.Model):
+    """ Update of res.users class
+        - add a preference about sending emails about notifications
+        - make a new user follow itself
+        - add a welcome message
+        - add suggestion preference
+    """
+    _name = 'res.users'
+    _inherit = ['res.users']
+    _inherits = {'mail.alias': 'alias_id'}
+
+    alias_id = fields.Many2one('mail.alias', 'Alias', ondelete="restrict", required=True,
+            help="Email address internally associated with this user. Incoming "\
+                 "emails will appear in the user's notifications.", copy=False, auto_join=True)
+    display_groups_suggestions = fields.Boolean("Display Groups Suggestions", default=True)
+
+    def __init__(self, pool, cr):
+        """ Override of __init__ to add access rights on notification_email_send
+            and alias fields. Access rights are disabled by default, but allowed
+            on some specific fields defined in self.SELF_{READ/WRITE}ABLE_FIELDS.
+        """
+        init_res = super(Users, self).__init__(pool, cr)
+        # duplicate list to avoid modifying the original reference
+        self.SELF_WRITEABLE_FIELDS = list(self.SELF_WRITEABLE_FIELDS)
+        self.SELF_WRITEABLE_FIELDS.extend(['notify_email', 'display_groups_suggestions'])
+        # duplicate list to avoid modifying the original reference
+        self.SELF_READABLE_FIELDS = list(self.SELF_READABLE_FIELDS)
+        self.SELF_READABLE_FIELDS.extend(['notify_email', 'alias_domain', 'alias_name', 'display_groups_suggestions'])
+        return init_res
+
+    def _auto_init(self, cr, context=None):
+        """ Installation hook: aliases, partner following themselves """
+        # create aliases for all users and avoid constraint errors
+        return self.pool.get('mail.alias').migrate_to_alias(cr, self._name, self._table, super(Users, self)._auto_init,
+            self._name, self._columns['alias_id'], 'login', alias_force_key='id', context=context)
+
+    @api.model
+    def create(self, values):
+        if not values.get('login', False):
+            action = self.env.ref('base.action_res_users')
+            msg = _("You cannot create a new user from here.\n To create new user please go to configuration panel.")
+            raise openerp.exceptions.RedirectWarning(msg, action.id, _('Go to the configuration panel'))
+
+        user = super(Users, self.with_context({
+            'alias_model_name': self._name,
+            'alias_parent_model_name': self._name
+        })).create(values)
+        user.alias_id.sudo().write({"alias_force_thread_id": user.id, "alias_parent_thread_id": user.id})
+
+        # create a welcome message
+        user._create_welcome_message()
+        return user
+
+    def copy_data(self, *args, **kwargs):
+        data = super(Users, self).copy_data(*args, **kwargs)
+        if data and data.get('alias_name'):
+            data['alias_name'] = data['login']
+        return data
+
+    def _create_welcome_message(self):
+        self.ensure_one()
+        if not self.has_group('base.group_user'):
+            return False
+        company_name = self.company_id.name if self.company_id else ''
+        body = _('%s has joined the %s network.') % (self.name, company_name)
+        # TODO change SUPERUSER_ID into user.id but catch errors
+        return self.partner_id.sudo().message_post(body=body)
+
+    def unlink(self):
+        # Cascade-delete mail aliases as well, as they should not exist without the user.
+        aliases = self.mapped('alias_id')
+        res = super(Users, self).unlink()
+        aliases.unlink()
+        return res
+
+    def _message_post_get_pid(self):
+        self.ensure_one()
+        if 'thread_model' in self.env.context:
+            self = self.with_context(thread_model='res.users')
+        return self.partner_id.id
+
+    @api.multi
+    def message_post(self, **kwargs):
+        """ Redirect the posting of message on res.users as a private discussion.
+            This is done because when giving the context of Chatter on the
+            various mailboxes, we do not have access to the current partner_id. """
+        current_pids = []
+        partner_ids = kwargs.get('partner_ids', [])
+        user_pid = self._message_post_get_pid()
+        for partner_id in partner_ids:
+            if isinstance(partner_id, (list, tuple)) and partner_id[0] == 4 and len(partner_id) == 2:
+                current_pids.append(partner_id[1])
+            elif isinstance(partner_id, (list, tuple)) and partner_id[0] == 6 and len(partner_id) == 3:
+                current_pids.append(partner_id[2])
+            elif isinstance(partner_id, (int, long)):
+                current_pids.append(partner_id)
+        if user_pid not in current_pids:
+            partner_ids.append(user_pid)
+        kwargs['partner_ids'] = partner_ids
+        # ??
+        # if context and context.get('thread_model') == 'res.partner':
+        #   return self.pool['res.partner'].message_post(cr, uid, user_pid, **kwargs)
+        return self.env['mail.thread'].message_post(**kwargs)  # ??
+
+    def message_update(self, msg_dict, update_vals=None):
+        return True
+
+    def message_subscribe(self, partner_ids, subtype_ids=None):
+        return True
+
+    @api.cr_uid_context
+    def message_get_partner_info_from_emails(self, cr, uid, emails, link_mail=False, context=None):
+        return self.pool.get('mail.thread').message_get_partner_info_from_emails(cr, uid, emails, link_mail=link_mail, context=context)
+
+    def message_get_suggested_recipients(self):
+        return dict((res_id, list()) for res_id in self._ids)
+
+    def stop_showing_groups_suggestions(self):
+        self.write({"display_groups_suggestions": False})
+
+
+class res_users_mail_group(models.Model):
+    """ Update of res.users class
+        - if adding groups to an user, check mail.groups linked to this user
+          group, and the user. This is done by overriding the write method.
+    """
+    _name = 'res.users'
+    _inherit = ['res.users']
+
+    @api.multi
+    def write(self, vals):
+        write_res = super(res_users_mail_group, self).write(vals)
+        if vals.get('groups_id'):
+            # form: {'group_ids': [(3, 10), (3, 3), (4, 10), (4, 3)]} or {'group_ids': [(6, 0, [ids]}
+            user_group_ids = [command[1] for command in vals['groups_id'] if command[0] == 4]
+            user_group_ids += [id for command in vals['groups_id'] if command[0] == 6 for id in command[2]]
+            self.env['mail.group'].search([('group_ids', 'in', user_group_ids)]).message_subscribe_users(self._ids)
+        return write_res
+
+
+class res_groups_mail_group(models.Model):
+    """ Update of res.groups class
+        - if adding users from a group, check mail.groups linked to this user
+          group and subscribe them. This is done by overriding the write method.
+    """
+    _name = 'res.groups'
+    _inherit = 'res.groups'
+
+    @api.multi
+    def write(self, vals, context=None):
+        write_res = super(res_groups_mail_group, self).write(vals)
+        if vals.get('users'):
+            # form: {'group_ids': [(3, 10), (3, 3), (4, 10), (4, 3)]} or {'group_ids': [(6, 0, [ids]}
+            user_ids = [command[1] for command in vals['users'] if command[0] == 4]
+            user_ids += [id for command in vals['users'] if command[0] == 6 for id in command[2]]
+            self.env['mail.group'].search([('group_ids', 'in', self._ids)]).message_subscribe_users(user_ids)
+        return write_res

--- a/None
+++ b/addons/mail/models/update.py
@@ -0,0 +1,111 @@
+# -*- coding: utf-8 -*-
+from ast import literal_eval
+import datetime
+from functools import partial
+import logging
+import werkzeug.urls
+import urllib2
+
+from openerp import release, SUPERUSER_ID
+from openerp.models import AbstractModel
+from openerp.osv import osv
+from openerp.tools.translate import _
+from openerp.tools.config import config
+from openerp.tools import misc
+from openerp.exceptions import UserError
+
+_logger = logging.getLogger(__name__)
+
+class publisher_warranty_contract(AbstractModel):
+    _name = "publisher_warranty.contract"
+
+    def _get_message(self, cr, uid):
+        Users = self.pool['res.users']
+        user_count = partial(Users.search_count, cr, uid)
+        get_param = partial(self.pool['ir.config_parameter'].get_param, cr, SUPERUSER_ID)
+
+        dbuuid = get_param('database.uuid')
+        db_create_date = get_param('database.create_date')
+        limit_date = datetime.datetime.now()
+        limit_date = limit_date - datetime.timedelta(15)
+        limit_date_str = limit_date.strftime(misc.DEFAULT_SERVER_DATETIME_FORMAT)
+        nbr_users = user_count([])
+        nbr_active_users = user_count([("login_date", ">=", limit_date_str)])
+        nbr_share_users = 0
+        nbr_active_share_users = 0
+        if "share" in Users._fields:
+            nbr_share_users = user_count([("share", "=", True)])
+            nbr_active_share_users = user_count([("share", "=", True), ("login_date", ">=", limit_date_str)])
+        user = Users.browse(cr, uid, uid)
+        domain = [('application', '=', True), ('state', 'in', ['installed', 'to upgrade', 'to remove'])]
+        apps = self.pool['ir.module.module'].search_read(cr, uid, domain, ['name'])
+
+        web_base_url = get_param('web.base.url')
+        msg = {
+            "dbuuid": dbuuid,
+            "nbr_users": nbr_users,
+            "nbr_active_users": nbr_active_users,
+            "nbr_share_users": nbr_share_users,
+            "nbr_active_share_users": nbr_active_share_users,
+            "dbname": cr.dbname,
+            "db_create_date": db_create_date,
+            "version": release.version,
+            "language": user.lang,
+            "web_base_url": web_base_url,
+            "apps": [app['name'] for app in apps],
+        }
+        msg.update(self.pool.get("res.company").read(cr, uid, [1], ["name", "email", "phone"])[0])
+        return msg
+
+    def _get_sys_logs(self, cr, uid):
+        """
+        Utility method to send a publisher warranty get logs messages.
+        """
+        msg = self._get_message(cr, uid)
+        arguments = {'arg0': msg, "action": "update"}
+        arguments_raw = werkzeug.urls.url_encode(arguments)
+
+        url = config.get("publisher_warranty_url")
+
+        uo = urllib2.urlopen(url, arguments_raw, timeout=30)
+        try:
+            submit_result = uo.read()
+            return literal_eval(submit_result)
+        finally:
+            uo.close()
+
+    def update_notification(self, cr, uid, ids, cron_mode=True, context=None):
+        """
+        Send a message to OpenERP's publisher warranty server to check the
+        validity of the contracts, get notifications, etc...
+
+        @param cron_mode: If true, catch all exceptions (appropriate for usage in a cron).
+        @type cron_mode: boolean
+        """
+        try:
+            try:
+                result = self._get_sys_logs(cr, uid)
+            except Exception:
+                if cron_mode:   # we don't want to see any stack trace in cron
+                    return False
+                _logger.debug("Exception while sending a get logs messages", exc_info=1)
+                raise UserError(_("Error during communication with the publisher warranty server."))
+            # old behavior based on res.log; now on mail.message, that is not necessarily installed
+            IMD = self.pool['ir.model.data']
+            user = self.pool['res.users'].browse(cr, SUPERUSER_ID, SUPERUSER_ID)
+            poster = IMD.xmlid_to_object(cr, SUPERUSER_ID, 'mail.group_all_employees', context=context)
+            if not (poster and poster.exists()):
+                if not user.exists():
+                    return True
+                poster = user
+            for message in result["messages"]:
+                try:
+                    poster.message_post(body=message, subtype='mt_comment', partner_ids=[user.partner_id.id])
+                except Exception:
+                    pass
+        except Exception:
+            if cron_mode:
+                return False    # we don't want to see any stack trace in cron
+            else:
+                raise
+        return True
