PR: https://github.com/odoo/odoo/pull/

From: 030db4a4b0885c55f637d67364a83c25e2f847f6
From: Arnold Moyaux
Date: 2019-04-12 12:50:34

Structural Changes: 2
Total Changes: 78

[IMP] mrp: tracability on byproducts

In MRP the tracability is only set between the finished
products and the components. However when the by-products is
tracked by serial number, it could be usefull to know from which
components it was created. This commit add the link between by-products
and raw materials (only in produce wizard at the moment).

Technically we replaced the one2many field by a many2many.

================================= pseudo patch: =================================

--- a/addons/mrp/models/mrp_abstract_workorder.py
+++ b/addons/mrp/models/mrp_abstract_workorder.py
@@ -175,7 +175,7 @@ class MrpAbstractWorkorder(models.AbstractModel):
             if float_compare(qty_to_consume, 0.0, precision_rounding=move.product_uom.rounding) <= 0:
                 break
             # move line already 'used' in workorder (from its lot for instance)
-            if move_line.lot_produced_id or float_compare(move_line.product_uom_qty, move_line.qty_done, precision_rounding=move.product_uom.rounding) <= 0:
+            if move_line.lot_produced_ids or float_compare(move_line.product_uom_qty, move_line.qty_done, precision_rounding=move.product_uom.rounding) <= 0:
                 continue
             # search wo line on which the lot is not fully consumed or other reserved lot
             linked_wo_line = self._workorder_line_ids().filtered(
@@ -332,9 +332,9 @@ class MrpAbstractWorkorderLine(models.AbstractModel):
         """ update a move line to save the workorder line data"""
         self.ensure_one()
         if self.lot_id:
-            move_lines = self.move_id.move_line_ids.filtered(lambda ml: ml.lot_id == self.lot_id and not ml.lot_produced_id)
+            move_lines = self.move_id.move_line_ids.filtered(lambda ml: ml.lot_id == self.lot_id and not ml.lot_produced_ids)
         else:
-            move_lines = self.move_id.move_line_ids.filtered(lambda ml: not ml.lot_id and not ml.lot_produced_id)
+            move_lines = self.move_id.move_line_ids.filtered(lambda ml: not ml.lot_id and not ml.lot_produced_ids)
 
         # Sanity check: if the product is a serial number and `lot` is already present in the other
         # consumed move lines, raise.
@@ -360,14 +360,14 @@ class MrpAbstractWorkorderLine(models.AbstractModel):
             if float_compare(new_quantity_done, ml.product_uom_qty, precision_rounding=rounding) >= 0:
                 ml.write({
                     'qty_done': new_quantity_done,
-                    'lot_produced_id': self._get_final_lot().id
+                    'lot_produced_ids': self._get_produced_lots(),
                 })
             else:
                 new_qty_reserved = ml.product_uom_qty - new_quantity_done
                 default = {
                     'product_uom_qty': new_quantity_done,
                     'qty_done': new_quantity_done,
-                    'lot_produced_id': self._get_final_lot().id
+                    'lot_produced_ids': self._get_produced_lots(),
                 }
                 ml.copy(default=default)
                 ml.with_context(bypass_reservation_update=True).write({
@@ -397,7 +397,7 @@ class MrpAbstractWorkorderLine(models.AbstractModel):
                 'product_uom_qty': 0,
                 'product_uom_id': quant.product_uom_id.id,
                 'qty_done': min(quantity, self.qty_done),
-                'lot_produced_id': self._get_final_lot().id,
+                'lot_produced_ids': self._get_produced_lots(),
             }
             if self.lot_id:
                 vals.update({'lot_id': self.lot_id.id})
@@ -417,7 +417,7 @@ class MrpAbstractWorkorderLine(models.AbstractModel):
                 'product_uom_qty': 0,
                 'product_uom_id': self.product_uom_id.id,
                 'qty_done': self.qty_done,
-                'lot_produced_id': self._get_final_lot().id,
+                'lot_produced_ids': self._get_produced_lots(),
             }
             if self.lot_id:
                 vals.update({'lot_id': self.lot_id.id})
@@ -435,6 +435,9 @@ class MrpAbstractWorkorderLine(models.AbstractModel):
         return self.move_id.move_line_ids.filtered(lambda ml:
         ml.lot_id == self.lot_id and ml.product_id == self.product_id)
 
+    def _get_produced_lots(self):
+        return self.move_id in self._get_production().move_raw_ids and self._get_final_lots() and [(4, lot.id) for lot in self._get_final_lots()]
+
     @api.model
     def _get_raw_workorder_inverse_name(self):
         raise NotImplementedError('Method _get_raw_workorder_inverse_name() undefined on %s' % self)
@@ -444,8 +447,8 @@ class MrpAbstractWorkorderLine(models.AbstractModel):
         raise NotImplementedError('Method _get_finished_workoder_inverse_name() undefined on %s' % self)
 
     # To be implemented in specific model
-    def _get_final_lot(self):
-        raise NotImplementedError('Method _get_final_lot() undefined on %s' % self)
+    def _get_final_lots(self):
+        raise NotImplementedError('Method _get_final_lots() undefined on %s' % self)
 
     def _get_production(self):
         raise NotImplementedError('Method _get_production() undefined on %s' % self)

--- a/addons/mrp/models/mrp_production.py
+++ b/addons/mrp/models/mrp_production.py
@@ -752,18 +752,18 @@ class MrpProduction(models.Model):
     def _check_lots(self):
         # Check that the raw materials were consumed for lots that we have produced.
         if self.product_id.tracking != 'none':
-            finished_lots = set(self.finished_move_line_ids.mapped('lot_id'))
-            raw_finished_lots = set(self.move_raw_ids.mapped('move_line_ids.lot_produced_id'))
-            if not (raw_finished_lots <= finished_lots):
+            finished_lots = self.finished_move_line_ids.mapped('lot_id')
+            raw_finished_lots = self.move_raw_ids.mapped('move_line_ids.lot_produced_ids')
+            if (raw_finished_lots - finished_lots):
                 lots_short = raw_finished_lots - finished_lots
                 error_msg = _(
                     'Some raw materials have been consumed for a lot/serial number that has not been produced. '
                     'Unlock the MO and click on the components lines to correct it.\n'
                     'List of the components:\n'
                 )
-                move_lines = self.move_raw_ids.mapped('move_line_ids').filtered(lambda x: x.lot_produced_id in lots_short)
+                move_lines = self.move_raw_ids.mapped('move_line_ids').filtered(lambda ml: lots_short & ml.lot_produced_ids)
                 for ml in move_lines:
-                    error_msg += ml.product_id.display_name + ' (' + ml.lot_produced_id.name +')\n'
+                    error_msg += ml.product_id.display_name + ' (' + (lots_short & ml.lot_produced_ids).mapped('name') + ')\n'
                 raise UserError(error_msg)
 
     @api.multi
@@ -819,16 +819,16 @@ class MrpProduction(models.Model):
             moves_to_do._action_done()
             moves_to_do = order.move_raw_ids.filtered(lambda x: x.state == 'done') - moves_not_to_do
             order._cal_price(moves_to_do)
-            moves_to_finish = order.move_finished_ids.filtered(lambda x: x.state not in ('done','cancel'))
+            moves_to_finish = order.move_finished_ids.filtered(lambda x: x.state not in ('done', 'cancel'))
             moves_to_finish._action_done()
             order.action_assign()
             consume_move_lines = moves_to_do.mapped('move_line_ids')
             for moveline in moves_to_finish.mapped('move_line_ids'):
-                if moveline.product_id == order.product_id and moveline.move_id.has_tracking != 'none':
-                    if any([not ml.lot_produced_id for ml in consume_move_lines]):
+                if moveline.move_id.has_tracking != 'none' and moveline.product_id == order.product_id or moveline.lot_id in consume_move_lines.mapped('lot_produced_ids'):
+                    if any([not ml.lot_produced_ids for ml in consume_move_lines]):
                         raise UserError(_('You can not consume without telling for which lot you consumed it'))
-                    # Link all movelines in the consumed with same lot_produced_id false or the correct lot_produced_id
-                    filtered_lines = consume_move_lines.filtered(lambda x: x.lot_produced_id == moveline.lot_id)
+                    # Link all movelines in the consumed with same lot_produced_ids false or the correct lot_produced_ids
+                    filtered_lines = consume_move_lines.filtered(lambda ml: moveline.lot_id in ml.lot_produced_ids)
                     moveline.write({'consume_line_ids': [(6, 0, [x for x in filtered_lines.ids])]})
                 else:
                     # Link with everything

--- a/addons/mrp/models/mrp_unbuild.py
+++ b/addons/mrp/models/mrp_unbuild.py
@@ -138,11 +138,11 @@ class MrpUnbuild(models.Model):
         for move in produce_moves | consume_moves:
             if move.has_tracking != 'none':
                 original_move = move in produce_moves and self.mo_id.move_raw_ids or self.mo_id.move_finished_ids
-                original_move = original_move.filtered(lambda move: move.product_id == move.product_id)
+                original_move = original_move.filtered(lambda m: m.product_id == move.product_id)
                 needed_quantity = move.product_qty
                 moves_lines = original_move.mapped('move_line_ids')
-                if move in produce_moves:
-                    moves_lines = moves_lines.filtered(lambda ml: ml.lot_produced_id == self.lot_id)
+                if move in produce_moves and self.lot_id:
+                    moves_lines = moves_lines.filtered(lambda ml: self.lot_id in ml.lot_produced_ids)
                 for move_line in moves_lines:
                     # Iterate over all move_lines until we unbuilded the correct quantity.
                     taken_quantity = min(needed_quantity, move_line.qty_done)
@@ -175,10 +175,10 @@ class MrpUnbuild(models.Model):
                 finished_moves = unbuild.mo_id.move_finished_ids.filtered(lambda move: move.state == 'done')
                 factor = unbuild.product_qty / unbuild.mo_id.product_uom_id._compute_quantity(unbuild.mo_id.product_qty, unbuild.product_uom_id)
                 for finished_move in finished_moves:
-                    moves += unbuild._generate_move_from_existing_move(finished_move, factor)
+                    moves += unbuild._generate_move_from_existing_move(finished_move, factor, finished_move.location_dest_id, finished_move.location_id)
             else:
                 factor = unbuild.product_uom_id._compute_quantity(unbuild.product_qty, unbuild.bom_id.product_uom_id) / unbuild.bom_id.product_qty
-                moves += unbuild._generate_move_from_bom_line(self.product_id, self.product_uom_id, unbuild.product_qty * factor)
+                moves += unbuild._generate_move_from_bom_line(self.product_id, self.product_uom_id, unbuild.product_qty)
                 for byproduct in unbuild.bom_id.sub_products:
                     quantity = byproduct.product_qty * factor
                     moves += unbuild._generate_move_from_bom_line(byproduct.product_id, byproduct.product_uom_id, quantity, subproduct_id=byproduct.id)
@@ -191,7 +191,7 @@ class MrpUnbuild(models.Model):
                 raw_moves = unbuild.mo_id.move_raw_ids.filtered(lambda move: move.state == 'done')
                 factor = unbuild.product_qty / unbuild.mo_id.product_uom_id._compute_quantity(unbuild.mo_id.product_qty, unbuild.product_uom_id)
                 for raw_move in raw_moves:
-                    moves += unbuild._generate_move_from_existing_move(raw_move, factor)
+                    moves += unbuild._generate_move_from_existing_move(raw_move, factor, raw_move.location_dest_id, self.location_dest_id)
             else:
                 factor = unbuild.product_uom_id._compute_quantity(unbuild.product_qty, unbuild.bom_id.product_uom_id) / unbuild.bom_id.product_qty
                 boms, lines = unbuild.bom_id.explode(unbuild.product_id, factor, picking_type=unbuild.bom_id.picking_type_id)
@@ -199,7 +199,7 @@ class MrpUnbuild(models.Model):
                     moves += unbuild._generate_move_from_bom_line(line.product_id, line.product_uom_id, line_data['qty'], bom_line_id=line.id)
         return moves
 
-    def _generate_move_from_existing_move(self, move, factor):
+    def _generate_move_from_existing_move(self, move, factor, location_id, location_dest_id):
         return self.env['stock.move'].create({
             'name': self.name,
             'date': self.create_date,
@@ -207,13 +207,16 @@ class MrpUnbuild(models.Model):
             'product_uom_qty': move.product_uom_qty * factor,
             'product_uom': move.product_uom.id,
             'procure_method': 'make_to_stock',
-            'location_dest_id': self.location_dest_id.id,
-            'location_id': move.location_dest_id.id,
-            'warehouse_id': self.location_dest_id.get_warehouse().id,
+            'location_dest_id': location_dest_id.id,
+            'location_id': location_id.id,
+            'warehouse_id': location_dest_id.get_warehouse().id,
             'unbuild_id': self.id,
         })
 
     def _generate_move_from_bom_line(self, product, product_uom, quantity, bom_line_id=False, subproduct_id=False):
+        location_id = bom_line_id and product.property_stock_production or self.location_id
+        location_dest_id = bom_line_id and self.location_dest_id or product.property_stock_production
+        warehouse = location_dest_id.get_warehouse()
         return self.env['stock.move'].create({
             'name': self.name,
             'date': self.create_date,
@@ -223,9 +226,9 @@ class MrpUnbuild(models.Model):
             'product_uom_qty': quantity,
             'product_uom': product_uom.id,
             'procure_method': 'make_to_stock',
-            'location_dest_id': self.location_dest_id.id,
-            'location_id': product.property_stock_production.id,
-            'warehouse_id': self.location_dest_id.get_warehouse().id,
+            'location_dest_id': location_dest_id.id,
+            'location_id': location_id.id,
+            'warehouse_id': warehouse.id,
             'unbuild_id': self.id,
         })
 

--- a/addons/mrp/models/stock_move.py
+++ b/addons/mrp/models/stock_move.py
@@ -12,7 +12,7 @@ class StockMoveLine(models.Model):
 
     workorder_id = fields.Many2one('mrp.workorder', 'Work Order')
     production_id = fields.Many2one('mrp.production', 'Production Order')
-    lot_produced_id = fields.Many2one('stock.production.lot', 'Finished Lot/Serial Number')
+    lot_produced_ids = fields.Many2many('stock.production.lot', string='Finished Lot/Serial Number')
     lot_produced_qty = fields.Float(
         'Quantity Finished Product', digits=dp.get_precision('Product Unit of Measure'),
         help="Informative, not used in matching")
@@ -32,7 +32,7 @@ class StockMoveLine(models.Model):
 
     def _reservation_is_updatable(self, quantity, reserved_quant):
         self.ensure_one()
-        if self.lot_produced_id:
+        if self.lot_produced_ids:
             ml_remaining_qty = self.qty_done - self.product_uom_qty
             ml_remaining_qty = self.product_uom_id._compute_quantity(ml_remaining_qty, self.product_id.uom_id, rounding_method="HALF-UP")
             if float_compare(ml_remaining_qty, quantity, precision_rounding=self.product_id.uom_id.rounding) < 0:
@@ -44,8 +44,8 @@ class StockMoveLine(models.Model):
         for move_line in self:
             if move_line.move_id.production_id and 'lot_id' in vals:
                 move_line.production_id.move_raw_ids.mapped('move_line_ids')\
-                    .filtered(lambda r: not r.done_move and r.lot_produced_id == move_line.lot_id)\
-                    .write({'lot_produced_id': vals['lot_id']})
+                    .filtered(lambda r: not r.done_move and move_line.lot_id in r.lot_produced_ids)\
+                    .write({'lot_produced_ids': [(4, vals['lot_id'])]})
             production = move_line.move_id.production_id or move_line.move_id.raw_material_production_id
             if production and move_line.state == 'done' and any(field in vals for field in ('lot_id', 'location_id', 'qty_done')):
                 move_line._log_message(production, move_line, 'mrp.track_production_move_template', vals)
