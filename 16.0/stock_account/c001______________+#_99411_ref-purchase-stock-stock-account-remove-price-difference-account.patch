PR: https://github.com/odoo/odoo/pull/99411

From: 35d6c58f863e9418511c905674780a7220cebd1f
From: Arnold Moyaux
Date: 2022-09-12 11:49:16

Structural Changes: 3
Total Changes: 183

[REF] purchase_stock, stock_account: remove price difference account

Invoice a different amount than on the purchase order will not
use the price difference account anymore. Instead it will create
a layer with the difference. It means the stock valuation will be
base on real quantity invoiced rather than the purchase order.

Since the price different account does not exists:
- Invoice correction is only done on `account.move.line` linked to a
  `purchase.order.line`. It means that additional lines won't be
 corrected and will debit the stock_input instead (that should be empty
 manually)

Part-of: odoo/odoo#99411

================================= pseudo patch: =================================

--- a/addons/stock_account/models/account_move.py
+++ b/addons/stock_account/models/account_move.py
@@ -1,6 +1,8 @@
 # -*- coding: utf-8 -*-
 
 from odoo import fields, models, api
+from odoo.tools.float_utils import float_compare, float_is_zero
+from odoo.tools.misc import groupby
 
 
 class AccountMove(models.Model):
@@ -37,12 +39,39 @@ class AccountMove(models.Model):
         if self._context.get('move_reverse_cancel'):
             return super()._post(soft)
 
+        # Create correction layer if invoice price is different
+        stock_valuation_layers = self.env['stock.valuation.layer'].sudo()
+        valued_lines = self.env['account.move.line'].sudo()
+        for invoice in self:
+            if invoice.sudo().stock_valuation_layer_ids:
+                continue
+            if invoice.move_type in ('in_invoice', 'in_refund', 'in_receipt'):
+                valued_lines |= invoice.invoice_line_ids.filtered(
+                    lambda l: l.product_id and l.product_id.cost_method != 'standard')
+        if valued_lines:
+            stock_valuation_layers |= valued_lines._create_in_invoice_svl()
+
+        for (product, company), dummy in groupby(stock_valuation_layers, key=lambda svl: (svl.product_id, svl.company_id)):
+            product = product.with_company(company.id)
+            if not float_is_zero(product.quantity_svl, precision_rounding=product.uom_id.rounding):
+                product.sudo().with_context(disable_auto_svl=True).write({'standard_price': product.value_svl / product.quantity_svl})
+
+        if stock_valuation_layers:
+            stock_valuation_layers._validate_accounting_entries()
+
         # Create additional COGS lines for customer invoices.
         self.env['account.move.line'].create(self._stock_account_prepare_anglo_saxon_out_lines_vals())
 
         # Post entries.
         posted = super()._post(soft)
 
+        # The invoice reference is set during the super call
+        for layer in stock_valuation_layers:
+            description = f"{layer.account_move_line_id.move_id.display_name} - {layer.product_id.display_name}"
+            layer.description = description
+            layer.account_move_id.ref = description
+            layer.account_move_id.line_ids.write({'name': description})
+
         # Reconcile COGS lines in case of anglo-saxon accounting with perpetual valuation.
         posted._stock_account_anglo_saxon_reconcile_valuation()
         return posted
@@ -199,7 +228,17 @@ class AccountMove(models.Model):
                         .filtered(lambda line: line.account_id == product_interim_account and not line.reconciled)
 
                     # Reconcile.
-                    product_account_moves.reconcile()
+                    if any(aml.amount_currency and not aml.balance for aml in product_account_moves):
+                        stock_aml = product_account_moves.filtered(lambda aml: aml.move_id.stock_valuation_layer_ids.stock_move_id)
+                        invoice_aml = product_account_moves.filtered(lambda aml: aml.move_id == move)
+                        correction_amls = product_account_moves - stock_aml - invoice_aml
+                        if sum(correction_amls.mapped('balance')) > 0:
+                            product_account_moves.with_context(no_exchange_difference=True).reconcile()
+                        else:
+                            (invoice_aml | correction_amls).with_context(no_exchange_difference=True).reconcile()
+                            (invoice_aml | stock_aml).with_context(no_exchange_difference=True).reconcile()
+                    else:
+                        product_account_moves.reconcile()
 
     def _get_invoiced_lot_values(self):
         return []
@@ -222,16 +261,118 @@ class AccountMoveLine(models.Model):
             if accounts['stock_input']:
                 line.account_id = accounts['stock_input']
 
+    def _create_in_invoice_svl(self):
+        svl_vals_list = []
+        for line in self:
+            line = line.with_company(line.company_id)
+            move = line.move_id.with_company(line.move_id.company_id)
+            po_line = line.purchase_line_id
+            uom = line.product_uom_id or line.product_id.uom_id
+
+            # Don't create value for more quantity than received
+            quantity = po_line.qty_received - (po_line.qty_invoiced - line.quantity)
+            quantity = max(min(line.quantity, quantity), 0)
+            if float_is_zero(quantity, precision_rounding=uom.rounding):
+                continue
+
+            layers = line._get_stock_valuation_layers(move)
+            # Retrieves SVL linked to a return.
+            if not layers:
+                continue
+
+            price_unit = -line.price_unit if move.move_type == 'in_refund' else line.price_unit
+            price_unit = price_unit * (1 - (line.discount or 0.0) / 100.0)
+            if line.tax_ids:
+                prec = 1e+6
+                price_unit *= prec
+                price_unit = line.tax_ids.with_context(round=False).compute_all(
+                    price_unit, currency=move.currency_id, quantity=1.0, is_refund=move.move_type == 'in_refund',
+                    fixed_multiplicator=move.direction_sign,
+                )['total_excluded']
+                price_unit /= prec
+            layers_price_unit = line._get_stock_valuation_layers_price_unit(layers)
+            layers_to_correct = line._get_stock_layer_price_difference(layers, layers_price_unit, price_unit)
+
+            svl_vals_list += line._prepare_in_invoice_svl_vals(layers_to_correct)
+        return self.env['stock.valuation.layer'].sudo().create(svl_vals_list)
+
     def _eligible_for_cogs(self):
         self.ensure_one()
         return self.product_id.type == 'product' and self.product_id.valuation == 'real_time'
 
+    def _get_stock_valuation_layers(self, move):
+        valued_moves = self._get_valued_in_moves()
+        if move.move_type == 'in_refund':
+            valued_moves = valued_moves.filtered(lambda stock_move: stock_move._is_out())
+        else:
+            valued_moves = valued_moves.filtered(lambda stock_move: stock_move._is_in())
+        return valued_moves.stock_valuation_layer_ids
+
+    def _get_stock_valuation_layers_price_unit(self, layers):
+        price_unit_by_layer = {}
+        for layer in layers:
+            price_unit_by_layer[layer] = layer.value / layer.quantity
+        return price_unit_by_layer
+
+    def _get_stock_layer_price_difference(self, layers, layers_price_unit, price_unit):
+        po_line = self.purchase_line_id
+        invoice_lines = po_line.invoice_lines - self
+        invoices_qty = 0
+        for invoice_line in invoice_lines:
+            invoices_qty += invoice_line.product_uom_id._compute_quantity(invoice_line.quantity, invoice_line.product_id.uom_id)
+        layers_to_correct = {}
+        for layer in layers:
+            if layer.quantity <= invoices_qty:
+                invoices_qty -= layer.quantity
+                continue
+            qty_to_correct = layer.quantity - invoices_qty
+            layer_price_unit = self.company_id.currency_id._convert(
+                layers_price_unit[layer], po_line.currency_id, self.company_id, self.date, round=False)
+            price_difference = price_unit - layer_price_unit
+            price_difference = po_line.currency_id._convert(
+                price_difference, self.company_id.currency_id, self.company_id, self.date, round=False)
+            # TODO convert in invoice currency
+            price_difference_curr = (po_line.price_unit - self.price_unit)
+            if float_is_zero(price_difference * qty_to_correct, precision_rounding=self.currency_id.rounding):
+                continue
+            layers_to_correct[layer] = (qty_to_correct, price_difference, price_difference_curr)
+        return layers_to_correct
+
+    def _get_valued_in_moves(self):
+        return self.env['stock.move']
+
+    def _prepare_in_invoice_svl_vals(self, layers_correction):
+        svl_vals_list = []
+        invoiced_qty = self.quantity
+        common_svl_vals = {
+            'account_move_id': self.move_id.id,
+            'account_move_line_id': self.id,
+            'company_id': self.company_id.id,
+            'product_id': self.product_id.id,
+            'quantity': 0,
+            'unit_cost': 0,
+            'remaining_qty': 0,
+            'remaining_value': 0,
+            'description': self.move_id.name and '%s - %s' % (self.move_id.name, self.product_id.name) or self.product_id.name,
+        }
+        for layer, (quantity, price_difference, price_difference_curr) in layers_correction.items():
+            svl_vals = self.product_id._prepare_in_svl_vals(quantity, price_difference)
+            svl_vals.update(**common_svl_vals, stock_valuation_layer_id=layer.id, price_diff_value=price_difference_curr * quantity)
+            svl_vals_list.append(svl_vals)
+            # Adds the difference into the last SVL's remaining value.
+            layer.remaining_value += svl_vals['value']
+            if float_compare(invoiced_qty, 0, self.product_id.uom_id.rounding) <= 0:
+                break
+
+        return svl_vals_list
+
     def _stock_account_get_anglo_saxon_price_unit(self):
         self.ensure_one()
         if not self.product_id:
             return self.price_unit
-        original_line = self.move_id.reversed_entry_id.line_ids.filtered(lambda l: l.display_type == 'cogs'
-            and l.product_id == self.product_id and l.product_uom_id == self.product_uom_id and l.price_unit >= 0)
+        original_line = self.move_id.reversed_entry_id.line_ids.filtered(
+            lambda l: l.display_type == 'cogs' and l.product_id == self.product_id and
+            l.product_uom_id == self.product_uom_id and l.price_unit >= 0)
         original_line = original_line and original_line[0]
         return original_line.price_unit if original_line \
             else self.product_id.with_company(self.company_id)._stock_account_get_anglo_saxon_price_unit(uom=self.product_uom_id)

--- a/addons/stock_account/models/product.py
+++ b/addons/stock_account/models/product.py
@@ -522,7 +522,7 @@ class ProductProduct(models.Model):
         move_lines = vacuum_svl.stock_move_id._prepare_account_move_line(
             vacuum_svl.quantity, vacuum_svl.value * -1,
             accounts['stock_output'].id, accounts['expense'].id,
-            description)
+            vacuum_svl, description)
         new_account_move = AccountMove.sudo().create({
             'journal_id': accounts['stock_journal'].id,
             'line_ids': move_lines,

--- a/addons/stock_account/models/stock_move.py
+++ b/addons/stock_account/models/stock_move.py
@@ -376,7 +376,7 @@ class StockMove(models.Model):
     def _get_dest_account(self, accounts_data):
         return self.location_dest_id.valuation_in_account_id.id or accounts_data['stock_output'].id
 
-    def _prepare_account_move_line(self, qty, cost, credit_account_id, debit_account_id, description):
+    def _prepare_account_move_line(self, qty, cost, credit_account_id, debit_account_id, svl_id, description):
         """
         Generate the account.move.line values to post to track the stock valuation difference due to the
         processing of the given quant.
@@ -389,7 +389,7 @@ class StockMove(models.Model):
         credit_value = debit_value
 
         valuation_partner_id = self._get_partner_id_for_valuation_lines()
-        res = [(0, 0, line_vals) for line_vals in self._generate_valuation_lines_data(valuation_partner_id, qty, debit_value, credit_value, debit_account_id, credit_account_id, description).values()]
+        res = [(0, 0, line_vals) for line_vals in self._generate_valuation_lines_data(valuation_partner_id, qty, debit_value, credit_value, debit_account_id, credit_account_id, svl_id, description).values()]
 
         return res
 
@@ -440,7 +440,7 @@ class StockMove(models.Model):
             'category': 'other',
         }
 
-    def _generate_valuation_lines_data(self, partner_id, qty, debit_value, credit_value, debit_account_id, credit_account_id, description):
+    def _generate_valuation_lines_data(self, partner_id, qty, debit_value, credit_value, debit_account_id, credit_account_id, svl_id, description):
         # This method returns a dictionary to provide an easy extension hook to modify the valuation lines (see purchase for an example)
         self.ensure_one()
         debit_line_vals = {
@@ -450,8 +450,7 @@ class StockMove(models.Model):
             'product_uom_id': self.product_id.uom_id.id,
             'ref': description,
             'partner_id': partner_id,
-            'debit': debit_value if debit_value > 0 else 0,
-            'credit': -debit_value if debit_value < 0 else 0,
+            'balance': debit_value,
             'account_id': debit_account_id,
         }
 
@@ -462,8 +461,7 @@ class StockMove(models.Model):
             'product_uom_id': self.product_id.uom_id.id,
             'ref': description,
             'partner_id': partner_id,
-            'credit': credit_value if credit_value > 0 else 0,
-            'debit': -credit_value if credit_value < 0 else 0,
+            'balance': -credit_value,
             'account_id': credit_account_id,
         }
 
@@ -471,10 +469,7 @@ class StockMove(models.Model):
         if credit_value != debit_value:
             # for supplier returns of product in average costing method, in anglo saxon mode
             diff_amount = debit_value - credit_value
-            price_diff_account = self.product_id.property_account_creditor_price_difference
-
-            if not price_diff_account:
-                price_diff_account = self.product_id.categ_id.property_account_creditor_price_difference_categ
+            price_diff_account = self.env.context.get('price_diff_account')
             if not price_diff_account:
                 raise UserError(_('Configuration error. Please configure the price difference account on the product or its category to process this operation.'))
 
@@ -502,8 +497,14 @@ class StockMove(models.Model):
     def _prepare_account_move_vals(self, credit_account_id, debit_account_id, journal_id, qty, description, svl_id, cost):
         self.ensure_one()
         valuation_partner_id = self._get_partner_id_for_valuation_lines()
-        move_ids = self._prepare_account_move_line(qty, cost, credit_account_id, debit_account_id, description)
-        date = self._context.get('force_period_date', fields.Date.context_today(self))
+        move_ids = self._prepare_account_move_line(qty, cost, credit_account_id, debit_account_id, svl_id, description)
+        svl = self.env['stock.valuation.layer'].browse(svl_id)
+        if self.env.context.get('force_period_date'):
+            date = self.env.context.get('force_period_date')
+        elif svl.account_move_line_id:
+            date = svl.account_move_line_id.date
+        else:
+            date = fields.Date.context_today(self)
         return {
             'journal_id': journal_id,
             'line_ids': move_ids,

--- a/addons/stock_account/models/stock_valuation_layer.py
+++ b/addons/stock_account/models/stock_valuation_layer.py
@@ -29,7 +29,9 @@ class StockValuationLayer(models.Model):
     stock_valuation_layer_ids = fields.One2many('stock.valuation.layer', 'stock_valuation_layer_id')
     stock_move_id = fields.Many2one('stock.move', 'Stock Move', readonly=True, check_company=True, index=True)
     account_move_id = fields.Many2one('account.move', 'Journal Entry', readonly=True, check_company=True)
+    account_move_line_id = fields.Many2one('account.move.line', 'Invoice Line', readonly=True, check_company=True, index=True)
     reference = fields.Char(related='stock_move_id.reference')
+    price_diff_value = fields.Float('Invoice value correction with invoice currency')
 
     def init(self):
         tools.create_index(
@@ -44,7 +46,10 @@ class StockValuationLayer(models.Model):
                 continue
             if svl.currency_id.is_zero(svl.value):
                 continue
-            am_vals += svl.stock_move_id._account_entry_move(svl.quantity, svl.description, svl.id, svl.value)
+            move = svl.stock_move_id
+            if not move:
+                move = svl.stock_valuation_layer_id.stock_move_id
+            am_vals += move._account_entry_move(svl.quantity, svl.description, svl.id, svl.value)
         if am_vals:
             account_moves = self.env['account.move'].sudo().create(am_vals)
             account_moves._post()
