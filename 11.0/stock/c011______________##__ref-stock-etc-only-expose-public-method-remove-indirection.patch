PR: https://github.com/odoo/odoo/pull/

From: 6aebc800538b6fabd79c6cd1e819ef6d961e7589
From: Simon Lejeune
Date: 2017-09-15 15:49:37

Structural Changes: 1
Total Changes: 214

[REF] stock, etc: only expose public method, remove indirection

also, remove now useless api.multi and dummy methods here and there

================================= pseudo patch: =================================

--- a/addons/stock/models/procurement.py
+++ b/addons/stock/models/procurement.py
@@ -62,7 +62,6 @@ class ProcurementRule(models.Model):
         'stock.warehouse', 'Warehouse to Propagate',
         help="The warehouse to propagate on the created move/procurement, which can be different of the warehouse this rule is for (e.g for resupplying rules from another warehouse)")
 
-    @api.multi
     def _run_move(self, product_id, product_qty, product_uom, location_id, name, origin, values):
         if not self.location_src_id:
             msg = _('No source location defined on procurement rule: %s!') % (self.name, )
@@ -79,8 +78,8 @@ class ProcurementRule(models.Model):
         data = self._get_stock_move_values(product_id, product_qty, product_uom, location_id, name, origin, values, group_id)
         # Since action_confirm launch following procurement_group we should activate it.
         move = self.env['stock.move'].sudo().create(data)
-        move.assign_picking()
-        move.action_confirm()
+        move._assign_picking()
+        move._action_confirm()
         return True
 
     def _get_stock_move_values(self, product_id, product_qty, product_uom, location_id, name, origin, values, group_id):
@@ -249,7 +248,7 @@ class ProcurementGroup(models.Model):
             # Search all confirmed stock_moves and try to assign them
             confirmed_moves = self.env['stock.move'].search([('state', '=', 'confirmed')], limit=None, order='priority desc, date_expected asc')
             for moves_chunk in split_every(100, confirmed_moves.ids):
-                self.env['stock.move'].browse(moves_chunk).action_assign()
+                self.env['stock.move'].browse(moves_chunk)._action_assign()
                 if use_new_cursor:
                     self._cr.commit()
 

--- a/addons/stock/models/product.py
+++ b/addons/stock/models/product.py
@@ -84,12 +84,10 @@ class Product(models.Model):
             product.outgoing_qty = res[product.id]['outgoing_qty']
             product.virtual_available = res[product.id]['virtual_available']
 
-    @api.multi
     def _product_available(self, field_names=None, arg=False):
         """ Compatibility method """
         return self._compute_quantities_dict(self._context.get('lot_id'), self._context.get('owner_id'), self._context.get('package_id'), self._context.get('from_date'), self._context.get('to_date'))
 
-    @api.multi
     def _compute_quantities_dict(self, lot_id, owner_id, package_id, from_date=False, to_date=False):
         domain_quant_loc, domain_move_in_loc, domain_move_out_loc = self._get_domain_locations()
         domain_quant = [('product_id', 'in', self.ids)] + domain_quant_loc
@@ -348,18 +346,15 @@ class Product(models.Model):
                         res['fields']['qty_available']['string'] = _('Produced Qty')
         return res
 
-    @api.multi
     def action_view_routes(self):
         return self.mapped('product_tmpl_id').action_view_routes()
 
-    @api.multi
     def action_view_stock_move_lines(self):
         self.ensure_one()
         action = self.env.ref('stock.stock_move_line_action').read()[0]
         action['domain'] = [('product_id', '=', self.id)]
         return action
 
-    @api.multi
     def action_open_product_lot(self):
         self.ensure_one()
         action = self.env.ref('stock.action_production_lot_form').read()[0]
@@ -367,7 +362,6 @@ class Product(models.Model):
         action['context'] = {'default_product_id': self.id}
         return action
 
-    @api.multi
     def write(self, values):
         res = super(Product, self).write(values)
         if 'active' in values and not values['active'] and self.mapped('orderpoint_ids').filtered(lambda r: r.active):
@@ -498,7 +492,6 @@ class ProductTemplate(models.Model):
     def onchange_tracking(self):
         return self.mapped('product_variant_ids').onchange_tracking()
 
-    @api.multi
     def write(self, vals):
         if 'uom_id' in vals:
             new_uom = self.env['product.uom'].browse(vals['uom_id'])
@@ -508,14 +501,12 @@ class ProductTemplate(models.Model):
                 raise UserError(_("You can not change the unit of measure of a product that has already been used in a done stock move. If you need to change the unit of measure, you may deactivate this product."))
         return super(ProductTemplate, self).write(vals)
 
-    @api.multi
     def action_view_routes(self):
         routes = self.mapped('route_ids') | self.mapped('categ_id').mapped('total_route_ids') | self.env['stock.location.route'].search([('warehouse_selectable', '=', True)])
         action = self.env.ref('stock.action_routes_form').read()[0]
         action['domain'] = [('id', 'in', routes.ids)]
         return action
 
-    @api.multi
     def action_open_quants(self):
         products = self.mapped('product_variant_ids')
         action = self.env.ref('stock.product_open_quants').read()[0]
@@ -523,7 +514,6 @@ class ProductTemplate(models.Model):
         action['context'] = {'search_default_internal_loc': 1}
         return action
 
-    @api.multi
     def action_view_orderpoints(self):
         products = self.mapped('product_variant_ids')
         action = self.env.ref('stock.product_open_orderpoint').read()[0]
@@ -534,14 +524,12 @@ class ProductTemplate(models.Model):
             action['context'] = {}
         return action
 
-    @api.multi
     def action_view_stock_move_lines(self):
         self.ensure_one()
         action = self.env.ref('stock.stock_move_line_action').read()[0]
         action['domain'] = [('product_id.product_tmpl_id', 'in', self.ids)]
         return action
 
-    @api.multi
     def action_open_product_lot(self):
         self.ensure_one()
         action = self.env.ref('stock.action_production_lot_form').read()[0]

--- a/addons/stock/models/stock_inventory.py
+++ b/addons/stock/models/stock_inventory.py
@@ -149,13 +149,10 @@ class Inventory(models.Model):
         if self.filter != 'pack' and self.package_id:
             raise UserError(_('The selected inventory options are not coherent.'))
 
-    @api.multi
     def action_reset_product_qty(self):
         self.mapped('line_ids').write({'product_qty': 0})
         return True
-    reset_real_qty = action_reset_product_qty
 
-    @api.multi
     def action_done(self):
         negative = next((line for line in self.mapped('line_ids') if line.product_qty < 0 and line.product_qty != line.theoretical_qty), False)
         if negative:
@@ -165,14 +162,12 @@ class Inventory(models.Model):
         self.post_inventory()
         return True
 
-    @api.multi
     def post_inventory(self):
         # The inventory is posted as a single step which means quants cannot be moved from an internal location to another using an inventory
         # as they will be moved to inventory loss, and other quants will be created to the encoded quant location. This is a normal behavior
         # as quants cannot be reuse from inventory location (users can still manually move the products before/after the inventory if they want).
-        self.mapped('move_ids').filtered(lambda move: move.state != 'done').action_done()
+        self.mapped('move_ids').filtered(lambda move: move.state != 'done')._action_done()
 
-    @api.multi
     def action_check(self):
         """ Checks the inventory and computes the stock move to do """
         # tde todo: clean after _generate_moves
@@ -181,15 +176,13 @@ class Inventory(models.Model):
             inventory.mapped('move_ids').unlink()
             inventory.line_ids._generate_moves()
 
-    @api.multi
     def action_cancel_draft(self):
-        self.mapped('move_ids').action_cancel()
+        self.mapped('move_ids')._action_cancel()
         self.write({
             'line_ids': [(5,)],
             'state': 'draft'
         })
 
-    @api.multi
     def action_start(self):
         for inventory in self:
             vals = {'state': 'confirm', 'date': fields.Datetime.now()}
@@ -197,9 +190,7 @@ class Inventory(models.Model):
                 vals.update({'line_ids': [(0, 0, line_values) for line_values in inventory._get_inventory_lines_values()]})
             inventory.write(vals)
         return True
-    prepare_inventory = action_start
 
-    @api.multi
     def action_inventory_line_tree(self):
         action = self.env.ref('stock.action_inventory_line_tree').read()[0]
         action['context'] = {
@@ -212,7 +203,6 @@ class Inventory(models.Model):
         }
         return action
 
-    @api.multi
     def _get_inventory_lines_values(self):
         # TDE CLEANME: is sql really necessary ? I don't think so
         locations = self.env['stock.location'].search([('id', 'child_of', [self.location_id.id])])

--- a/addons/stock/models/stock_location.py
+++ b/addons/stock/models/stock_location.py
@@ -79,7 +79,6 @@ class Location(models.Model):
             name = '%s/%s' % (current.name, name)
         self.complete_name = name
 
-    @api.multi
     def name_get(self):
         ret_list = []
         for location in self:
@@ -109,7 +108,6 @@ class Location(models.Model):
             current_location = current_location.location_id
         return putaway_location
 
-    @api.multi
     @api.returns('stock.warehouse', lambda value: value.id)
     def get_warehouse(self):
         """ Returns warehouse id of warehouse that contains location """
@@ -149,7 +147,6 @@ class Route(models.Model):
     categ_ids = fields.Many2many('product.category', 'stock_location_route_categ', 'route_id', 'categ_id', 'Product Categories')
     warehouse_ids = fields.Many2many('stock.warehouse', 'stock_route_warehouse', 'route_id', 'warehouse_id', 'Warehouses')
 
-    @api.multi
     def write(self, values):
         '''when a route is deactivated, deactivate also its pull and push rules'''
         res = super(Route, self).write(values)
@@ -158,7 +155,6 @@ class Route(models.Model):
             self.mapped('pull_ids').filtered(lambda rule: rule.active != values['active']).write({'active': values['active']})
         return res
 
-    @api.multi
     def view_product_ids(self):
         return {
             'name': _('Products'),
@@ -169,7 +165,6 @@ class Route(models.Model):
             'domain': [('route_ids', 'in', self.ids)],
         }
 
-    @api.multi
     def view_categ_ids(self):
         return {
             'name': _('Product Categories'),
@@ -228,7 +223,7 @@ class PushedFlow(models.Model):
             new_move_vals = self._prepare_move_copy_values(move, new_date)
             new_move = move.copy(new_move_vals)
             move.write({'move_dest_ids': [(4, new_move.id)]})
-            new_move.action_confirm()
+            new_move._action_confirm()
 
     def _prepare_move_copy_values(self, move_to_copy, new_date):
         new_move_vals = {

--- a/addons/stock/models/stock_move.py
+++ b/addons/stock/models/stock_move.py
@@ -14,6 +14,7 @@ from odoo.tools.float_utils import float_compare, float_round, float_is_zero
 
 PROCUREMENT_PRIORITIES = [('0', 'Not urgent'), ('1', 'Normal'), ('2', 'Urgent'), ('3', 'Very Urgent')]
 
+
 class StockMove(models.Model):
     _name = "stock.move"
     _description = "Stock Move"
@@ -92,7 +93,6 @@ class StockMove(models.Model):
     picking_id = fields.Many2one('stock.picking', 'Transfer Reference', index=True, states={'done': [('readonly', True)]})
     picking_partner_id = fields.Many2one('res.partner', 'Transfer Destination Address', related='picking_id.partner_id')
     note = fields.Text('Notes')
-    # TODO: state should be computed according to the move lines
     state = fields.Selection([
         ('draft', 'New'), ('cancel', 'Cancelled'),
         ('waiting', 'Waiting Another Move'),
@@ -157,7 +157,6 @@ class StockMove(models.Model):
     is_locked = fields.Boolean(related='picking_id.is_locked', readonly=True)
     is_initial_demand_editable = fields.Boolean('Is initial demand editable', compute='_compute_is_initial_demand_editable')
 
-    @api.multi
     @api.depends('product_id', 'has_tracking', 'move_line_ids', 'location_id', 'location_dest_id')
     def _compute_show_details_visible(self):
         """ According to this field, the button that calls `action_show_details` will be displayed
@@ -180,7 +179,6 @@ class StockMove(models.Model):
             else:
                 move.show_details_visible = False
 
-    @api.multi
     def _compute_show_reserved_availability(self):
         """ This field is only of use in an attrs in the picking view, in order to hide the
         "available" column if the move is coming from a supplier.
@@ -188,7 +186,6 @@ class StockMove(models.Model):
         for move in self:
             move.show_reserved_availability = not move.location_id.usage == 'supplier'
 
-    @api.multi
     @api.depends('state', 'picking_id')
     def _compute_is_initial_demand_editable(self):
         for move in self:
@@ -211,7 +208,6 @@ class StockMove(models.Model):
         self.ensure_one()
         return self.move_line_ids
 
-    @api.multi
     @api.depends('move_line_ids.qty_done', 'move_line_ids.product_uom_id')
     def _quantity_done_compute(self):
         for move in self:
@@ -219,7 +215,6 @@ class StockMove(models.Model):
                 # Transform the move_line quantity_done into the move uom.
                 move.quantity_done += move_line.product_uom_id._compute_quantity(move_line.qty_done, move.product_uom)
 
-    @api.multi
     def _quantity_done_set(self):
         quantity_done = self[0].quantity_done  # any call to create will invalidate `move.quantity_done`
         for move in self:
@@ -241,7 +236,6 @@ class StockMove(models.Model):
         detect errors. """
         raise UserError(_('The requested operation cannot be processed because of a programming error setting the `product_qty` field instead of the `product_uom_qty`.'))
 
-
     @api.one
     @api.depends('move_line_ids.product_qty')
     def _compute_reserved_availability(self):
@@ -264,7 +258,6 @@ class StockMove(models.Model):
             total_availability = self.env['stock.quant']._get_available_quantity(self.product_id, self.location_id)
             self.availability = min(self.product_qty, total_availability)
 
-    @api.multi
     def _compute_string_qty_information(self):
         precision = self.env['decimal.precision'].precision_get('Product Unit of Measure')
         void_moves = self.filtered(lambda move: move.state in ('draft', 'done', 'cancel') or move.location_id.usage != 'internal')
@@ -321,7 +314,6 @@ class StockMove(models.Model):
                 defaults['additional'] = True
         return defaults
 
-    @api.multi
     def name_get(self):
         res = []
         for move in self:
@@ -344,13 +336,12 @@ class StockMove(models.Model):
             picking.message_track(picking.fields_get(['state']), initial_values)
         return res
 
-    @api.multi
     def write(self, vals):
         # FIXME: pim fix your crap
         if vals.get('product_uom_qty'):
             if self.env.context.get('do_not_unreserve') is None:
                 move_to_unreserve = self.filtered(lambda m: m.state not in ['draft', 'done', 'cancel'] and m.reserved_availability > vals.get('product_uom_qty'))
-                move_to_unreserve.do_unreserve()
+                move_to_unreserve._do_unreserve()
                 (self - move_to_unreserve).filtered(lambda m: m.state == 'assigned').write({'state': 'partially_available'})
 
         # TDE CLEANME: it is a gros bordel + tracking
@@ -397,7 +388,6 @@ class StockMove(models.Model):
             pickings.message_track(pickings.fields_get(['state']), initial_values)
         return res
 
-    @api.multi
     def action_show_details(self):
         """ Returns an action that will open a form view (in a popup) allowing to work on all the
         move lines of a particular move. This form view is used when "show operations" is not
@@ -435,18 +425,14 @@ class StockMove(models.Model):
             ),
         }
 
-    # Misc tools
-    # ------------------------------------------------------------
-
-    @api.multi
-    def do_unreserve(self):
+    def _do_unreserve(self):
         if any(move.state in ('done', 'cancel') for move in self):
             raise UserError(_('Cannot unreserve a done move'))
         for move in self:
             move.move_line_ids.unlink()
-            if(move.procure_method == 'make_to_order' and not move.move_orig_ids):
+            if move.procure_method == 'make_to_order' and not move.move_orig_ids:
                 move.state = 'waiting'
-            elif(move.move_orig_ids and not all(orig.state in ('done', 'cancel') for orig in move.move_orig_ids)):
+            elif move.move_orig_ids and not all(orig.state in ('done', 'cancel') for orig in move.move_orig_ids):
                 move.state = 'waiting'
             else:
                 move.state = 'confirmed'
@@ -510,9 +496,7 @@ class StockMove(models.Model):
                 }
             }
 
-    # TDE DECORATOR: remove that api.multi when action_confirm is migrated
-    @api.multi
-    def assign_picking(self):
+    def _assign_picking(self):
         """ Try to assign the moves to an existing picking that has not been
         reserved yet and has the same procurement group, locations and picking
         type (moves should already have them identical). Otherwise, create a new
@@ -540,7 +524,6 @@ class StockMove(models.Model):
             if recompute:
                 move.recompute()
         return True
-    _picking_assign = assign_picking
 
     def _get_new_picking_values(self):
         """ Prepares a new picking for this move as it could not be assigned to
@@ -554,10 +537,8 @@ class StockMove(models.Model):
             'location_id': self.location_id.id,
             'location_dest_id': self.location_dest_id.id,
         }
-    _prepare_picking_assign = _get_new_picking_values
 
-    @api.multi
-    def action_confirm(self):
+    def _action_confirm(self):
         """ Confirms stock move or put it in waiting if it's linked to another move. """
         move_create_proc = self.env['stock.move']
         move_to_confirm = self.env['stock.move']
@@ -591,7 +572,7 @@ class StockMove(models.Model):
 
         # assign picking in batch for all confirmed move that share the same details
         for moves in to_assign.values():
-            moves.assign_picking()
+            moves._assign_picking()
         self._push_apply()
         return self
 
@@ -617,25 +598,13 @@ class StockMove(models.Model):
             'priority': self.priority,
         }
 
-    @api.multi
-    def force_assign(self):
+    def _force_assign(self):
         """ Allow to work on stock move lines even if the reservationis not possible. We just mark
         the move as assigned, so the view does not block the user.
         """
         for move in self.filtered(lambda m: m.state in ['confirmed', 'waiting', 'partially_available', 'assigned']):
             move.write({'state': 'assigned'})
 
-    @api.multi
-    def check_tracking(self, move_line):
-        """ Checks if serial number is assigned to stock move or not and raise an error if it had to. """
-        # TDE FIXME: I cannot able to understand
-        for move in self:
-            if move.picking_id and \
-                    (move.picking_id.picking_type_id.use_existing_lots or move.picking_id.picking_type_id.use_create_lots) and \
-                    move.product_id.tracking != 'none' and \
-                    not (move_line and (move_line.product_id and move_line.pack_lot_ids)) or (move_line and not move_line.product_id):
-                raise UserError(_('You need to provide a Lot/Serial Number for product %s') % ("%s (%s)" % (move.product_id.name, move.picking_id.name)))
-
     def _prepare_move_line_vals(self, quantity=None, reserved_quant=None):
         self.ensure_one()
         # apply putaway
@@ -692,8 +661,7 @@ class StockMove(models.Model):
                     self.env['stock.move.line'].create(self._prepare_move_line_vals(quantity=quantity, reserved_quant=reserved_quant))
         return taken_quantity
 
-    @api.multi
-    def action_assign(self):
+    def _action_assign(self):
         """ Reserve stock moves by creating their stock move lines. A stock move is 
         considered reserved once the sum of `product_qty` for all its move lines is
         equal to its `product_qty`. If it is less, the stock move is considered
@@ -795,17 +763,16 @@ class StockMove(models.Model):
         assigned_moves.write({'state': 'assigned'})
         self.mapped('picking_id')._check_entire_pack()
 
-    @api.multi
-    def action_cancel(self):
+    def _action_cancel(self):
         if any(move.state == 'done' for move in self):
             raise UserError(_('You cannot cancel a stock move that has been set to \'Done\'.'))
         for move in self:
-            move.do_unreserve()
+            move._do_unreserve()
             siblings_states = (move.move_dest_ids.mapped('move_orig_ids') - move).mapped('state')
             if move.propagate:
                 # only cancel the next move if all my siblings are also cancelled
                 if all(state == 'cancel' for state in siblings_states):
-                    move.move_dest_ids.action_cancel()
+                    move.move_dest_ids._action_cancel()
             else:
                 if all(state in ('done', 'cancel') for state in siblings_states):
                     move.move_dest_ids.write({'procure_method': 'make_to_stock'})
@@ -820,7 +787,6 @@ class StockMove(models.Model):
         }
         return vals
 
-    @api.multi
     def _create_extra_move(self):
         """ If the quantity done on a move exceeds its quantity todo, this method will create an
         extra move attached to a (potentially split) move line. If the previous condition is not
@@ -839,7 +805,7 @@ class StockMove(models.Model):
                 precision_rounding=self.product_uom.rounding,
                 rounding_method ='UP')
             extra_move_vals = self._prepare_extra_move_vals(extra_move_quantity)
-            extra_move = self.copy(default=extra_move_vals).action_confirm()
+            extra_move = self.copy(default=extra_move_vals)._action_confirm()
 
             # link it to some move lines
             for move_line in self.move_line_ids.filtered(lambda ml: ml.qty_done):
@@ -860,9 +826,8 @@ class StockMove(models.Model):
                     break
         return extra_move
 
-    @api.multi
-    def action_done(self):
-        self.filtered(lambda move: move.state == 'draft').action_confirm()  # MRP allows scrapping draft moves
+    def _action_done(self):
+        self.filtered(lambda move: move.state == 'draft')._action_confirm()  # MRP allows scrapping draft moves
 
         moves = self.filtered(lambda x: x.state not in ('done', 'cancel'))
         moves_todo = self.env['stock.move']
@@ -886,7 +851,7 @@ class StockMove(models.Model):
             if float_compare(move.quantity_done, move.product_uom_qty, precision_rounding=rounding) < 0:
                 # Need to do some kind of conversion here
                 qty_split = move.product_uom._compute_quantity(move.product_uom_qty - move.quantity_done, move.product_id.uom_id)
-                new_move = move.split(qty_split)
+                new_move = move._split(qty_split)
                 for move_line in move.move_line_ids:
                     if move_line.product_qty and move_line.qty_done:
                         # FIXME: there will be an issue if the move was partially available
@@ -900,10 +865,10 @@ class StockMove(models.Model):
                 # If you were already putting stock.move.lots on the next one in the work order, transfer those to the new move
                 move.move_line_ids.filtered(lambda x: x.qty_done == 0.0).write({'move_id': new_move})
                 self.browse(new_move).quantity_done = 0.0
-            move.move_line_ids.action_done()
+            move.move_line_ids._action_done()
         picking = self and self[0].picking_id or False
         moves_todo.write({'state': 'done', 'date': fields.Datetime.now()})
-        moves_todo.mapped('move_dest_ids').action_assign()
+        moves_todo.mapped('move_dest_ids')._action_assign()
         if picking:
             moves_to_backorder = picking.move_lines.filtered(lambda x: x.state not in ('done', 'cancel'))
             if moves_to_backorder:
@@ -916,10 +881,9 @@ class StockMove(models.Model):
                 picking.message_post('Backorder Created') #message needs to be improved
                 moves_to_backorder.write({'picking_id': backorder_picking.id})
                 moves_to_backorder.mapped('move_line_ids').write({'picking_id': backorder_picking.id})
-            moves_to_backorder.action_assign()
+            moves_to_backorder._action_assign()
         return moves_todo
 
-    @api.multi
     def unlink(self):
         if any(move.state not in ('draft', 'cancel') for move in self):
             raise UserError(_('You can only delete draft moves.'))
@@ -935,8 +899,7 @@ class StockMove(models.Model):
         }
         return vals
 
-    @api.multi
-    def split(self, qty, restrict_partner_id=False):
+    def _split(self, qty, restrict_partner_id=False):
         """ Splits qty from move move into a new move
 
         :param qty: float. quantity to split (given in product UoM)
@@ -975,7 +938,7 @@ class StockMove(models.Model):
         #     new_move.write({'move_dest_id': new_move_prop})
         # returning the first element of list returned by action_confirm is ok because we checked it wouldn't be exploded (and
         # thus the result of action_confirm should always be a list of 1 element length)
-        new_move.action_confirm()
+        new_move._action_confirm()
         # TDE FIXME: due to action confirm change
         return new_move.id
 

--- a/addons/stock/models/stock_move_line.py
+++ b/addons/stock/models/stock_move_line.py
@@ -76,14 +76,12 @@ class StockMoveLine(models.Model):
         detect errors. """
         raise UserError(_('The requested operation cannot be processed because of a programming error setting the `product_qty` field instead of the `product_uom_qty`.'))
 
-    @api.multi
     @api.constrains('product_uom_qty')
     def check_reserved_done_quantity(self):
         for move_line in self:
             if move_line.state == 'done' and not float_is_zero(move_line.product_uom_qty, precision_rounding=self.env['decimal.precision'].precision_get('Product Unit of Measure')):
                 raise ValidationError(_('A done move line should never have a reserved quantity.'))
 
-    @api.multi
     @api.onchange('product_id', 'product_uom_id')
     def onchange_product_id(self):
         if self.product_id:
@@ -122,11 +120,10 @@ class StockMoveLine(models.Model):
                         Quant._update_available_quantity(ml.product_id, ml.location_id, taken_from_untracked_qty, lot_id=ml.lot_id, package_id=ml.package_id, owner_id=ml.owner_id)
                 Quant._update_available_quantity(ml.product_id, ml.location_dest_id, quantity, lot_id=ml.lot_id, package_id=ml.result_package_id, owner_id=ml.owner_id, in_date=in_date)
             next_moves = ml.move_id.move_dest_ids.filtered(lambda move: move.state not in ('done', 'cancel'))
-            next_moves.do_unreserve()
-            next_moves.action_assign()
+            next_moves._do_unreserve()
+            next_moves._action_assign()
         return ml
 
-    @api.multi
     def write(self, vals):
         """ Through the interface, we allow users to change the charateristics of a move line. If a
         quantity has been reserved for this move line, we impact the reservation directly to free
@@ -195,7 +192,7 @@ class StockMoveLine(models.Model):
                         new_product_uom_qty = self.product_id.uom_id._compute_quantity(new_product_qty, self.product_uom_id, rounding_method='HALF-UP')
                         ml.with_context(bypass_reservation_update=True).product_uom_qty = new_product_uom_qty
 
-        # When editing a done move line, the reserved availability of a potential chained move is impacted. Take care of running again `action_assign` on the concerned moves.
+        # When editing a done move line, the reserved availability of a potential chained move is impacted. Take care of running again `_action_assign` on the concerned moves.
         next_moves = self.env['stock.move']
         if updates or 'qty_done' in vals:
             for ml in self.filtered(lambda ml: ml.move_id.state == 'done' and ml.product_id.type == 'product'):
@@ -240,11 +237,10 @@ class StockMoveLine(models.Model):
             moves = self.filtered(lambda ml: ml.move_id.state == 'done').mapped('move_id')
             for move in moves:
                 move.product_uom_qty = move.quantity_done
-        next_moves.do_unreserve()
-        next_moves.action_assign()
+        next_moves._do_unreserve()
+        next_moves._action_assign()
         return res
 
-    @api.multi
     def unlink(self):
         precision = self.env['decimal.precision'].precision_get('Product Unit of Measure')
         for ml in self:
@@ -256,7 +252,7 @@ class StockMoveLine(models.Model):
                                                                    package_id=ml.package_id, owner_id=ml.owner_id, strict=True)
         return super(StockMoveLine, self).unlink()
 
-    def action_done(self):
+    def _action_done(self):
         """ This method is called during a move's `action_done`. It'll actually move a quant from
         the source location to the destination location, and unreserve if needed in the source
         location.

--- a/addons/stock/models/stock_picking.py
+++ b/addons/stock/models/stock_picking.py
@@ -75,7 +75,6 @@ class PickingType(models.Model):
                 tristates.insert(0, {'tooltip': picking.name or '' + ": " + _('OK'), 'value': 1})
         self.last_done_picking = json.dumps(tristates)
 
-    @api.multi
     def _compute_picking_count(self):
         # TDE TODO count picking can be done using previous two
         domains = {
@@ -100,7 +99,6 @@ class PickingType(models.Model):
             record.rate_picking_late = record.count_picking and record.count_picking_late * 100 / record.count_picking or 0
             record.rate_picking_backorders = record.count_picking and record.count_picking_backorders * 100 / record.count_picking or 0
 
-    @api.multi
     def name_get(self):
         """ Display 'Warehouse_name: PickingType_name' """
         # TDE TODO remove context key support + update purchase
@@ -136,7 +134,6 @@ class PickingType(models.Model):
             self.default_location_src_id = self.env.ref('stock.stock_location_stock').id
             self.default_location_dest_id = self.env.ref('stock.stock_location_customers').id
 
-    @api.multi
     def _get_action(self, action_xmlid):
         # TDE TODO check to have one view + custo in methods
         action = self.env.ref(action_xmlid).read()[0]
@@ -144,23 +141,18 @@ class PickingType(models.Model):
             action['display_name'] = self.display_name
         return action
 
-    @api.multi
     def get_action_picking_tree_late(self):
         return self._get_action('stock.action_picking_tree_late')
 
-    @api.multi
     def get_action_picking_tree_backorder(self):
         return self._get_action('stock.action_picking_tree_backorder')
 
-    @api.multi
     def get_action_picking_tree_waiting(self):
         return self._get_action('stock.action_picking_tree_waiting')
 
-    @api.multi
     def get_action_picking_tree_ready(self):
         return self._get_action('stock.action_picking_tree_ready')
 
-    @api.multi
     def get_stock_picking_action_picking_type(self):
         return self._get_action('stock.stock_picking_action_picking_type')
 
@@ -449,7 +441,7 @@ class Picking(models.Model):
 
     @api.multi
     def unlink(self):
-        self.mapped('move_lines').action_cancel()
+        self.mapped('move_lines')._action_cancel()
         self.mapped('move_lines').unlink() # Checks if moves are not done
         return super(Picking, self).unlink()
 
@@ -467,14 +459,14 @@ class Picking(models.Model):
 
     @api.multi
     def action_confirm(self):
-        # call `action_confirm` on every draft move
+        # call `_action_confirm` on every draft move
         self.mapped('move_lines')\
             .filtered(lambda move: move.state == 'draft')\
-            .action_confirm()
-        # call `action_assign` on every confirmed move which location_id bypasses the reservation
+            ._action_confirm()
+        # call `_action_assign` on every confirmed move which location_id bypasses the reservation
         self.filtered(lambda picking: picking.location_id.usage in ('supplier', 'inventory', 'production'))\
             .filtered(lambda move: move.state == 'confirmed')\
-            .mapped('move_lines').action_assign()
+            .mapped('move_lines')._action_assign()
         return True
 
     @api.multi
@@ -488,7 +480,7 @@ class Picking(models.Model):
         moves = self.mapped('move_lines').filtered(lambda move: move.state not in ('draft', 'cancel', 'done'))
         if not moves:
             raise UserError(_('Nothing to check the availability for.'))
-        moves.action_assign()
+        moves._action_assign()
         return True
 
     @api.multi
@@ -496,12 +488,12 @@ class Picking(models.Model):
         """ Changes state of picking to available if moves are confirmed or waiting.
         @return: True
         """
-        self.mapped('move_lines').filtered(lambda move: move.state in ['confirmed', 'waiting', 'partially_available']).force_assign()
+        self.mapped('move_lines').filtered(lambda move: move.state in ['confirmed', 'waiting', 'partially_available'])._force_assign()
         return True
 
     @api.multi
     def action_cancel(self):
-        self.mapped('move_lines').action_cancel()
+        self.mapped('move_lines')._action_cancel()
         return True
 
     @api.multi
@@ -548,10 +540,10 @@ class Picking(models.Model):
                                                     'picking_id': pick.id,
                                                    })
                     ops.move_id = new_move.id
-                    new_move.action_confirm()
+                    new_move._action_confirm()
                     todo_moves |= new_move
                     #'qty_done': ops.qty_done})
-        todo_moves.action_done()
+        todo_moves._action_done()
         self.write({'date_done': fields.Datetime.now()})
         return True
 
@@ -584,7 +576,7 @@ class Picking(models.Model):
     def do_unreserve(self):
         for move in self:
             for move_line in move.move_lines:
-                move_line.do_unreserve()
+                move_line._do_unreserve()
         self.write({'state': 'confirmed'})
 
     @api.multi
@@ -627,13 +619,11 @@ class Picking(models.Model):
             }
 
         # Check backorder should check for other barcodes
-        if self.check_backorder():
+        if self._check_backorder():
             return self.action_generate_backorder_wizard()
         self.action_done()
         return
 
-    do_new_transfer = button_validate #TODO: replace later
-
     def action_generate_backorder_wizard(self):
         view = self.env.ref('stock.view_backorder_confirmation')
         wiz = self.env['stock.backorder.confirmation'].create({'pick_id': self.id})
@@ -654,7 +644,7 @@ class Picking(models.Model):
         self.is_locked = not self.is_locked
         return True
 
-    def check_backorder(self):
+    def _check_backorder(self):
         self.ensure_one()
         quantity_todo = {}
         quantity_done = {}
@@ -685,7 +675,7 @@ class Picking(models.Model):
                     vals = self._prepare_values_extra_move(move_line, product, remaining_qty)
                     moves |= moves.create(vals)
         if moves:
-            moves.with_context(skip_check=True).action_confirm()
+            moves.with_context(skip_check=True)._action_confirm()
         return moves
 
     @api.model
@@ -722,7 +712,6 @@ class Picking(models.Model):
             'group_id': picking.group_id.id,
         }
 
-    @api.multi
     def _create_backorder(self, backorder_moves=[]):
         """ Move all non-done lines into a new backorder picking. If the key 'do_only_split' is given in the context, then move all lines not in context.get('split', []) instead of all non-done lines.
         """
@@ -751,7 +740,6 @@ class Picking(models.Model):
             backorders |= backorder_picking
         return backorders
 
-    @api.multi
     def _put_in_pack(self):
         package = False
         for pick in self:
@@ -777,11 +765,9 @@ class Picking(models.Model):
                 raise UserError(_('Please process some quantities to put in the pack first!'))
         return package
 
-    @api.multi
     def put_in_pack(self):
         return self._put_in_pack()
 
-    @api.multi
     def button_scrap(self):
         self.ensure_one()
         return {
@@ -795,7 +781,6 @@ class Picking(models.Model):
             'target': 'new',
         }
 
-    @api.multi
     def action_see_move_scrap(self):
         self.ensure_one()
         action = self.env.ref('stock.action_stock_scrap').read()[0]
@@ -803,7 +788,6 @@ class Picking(models.Model):
         action['domain'] = [('id', 'in', scraps.ids)]
         return action
 
-    @api.multi
     def action_see_packages(self):
         self.ensure_one()
         action = self.env.ref('stock.action_package_view').read()[0]

--- a/addons/stock/models/stock_quant.py
+++ b/addons/stock/models/stock_quant.py
@@ -48,7 +48,6 @@ class StockQuant(models.Model):
         readonly=True, required=True)
     in_date = fields.Datetime('Incoming Date', readonly=True)
 
-    @api.multi
     def action_view_stock_moves(self):
         self.ensure_one()
         action = self.env.ref('stock.stock_move_line_action').read()[0]
@@ -60,20 +59,17 @@ class StockQuant(models.Model):
             ('package_id', '=', self.package_id.id)]
         return action
 
-    @api.multi
     @api.constrains('product_id')
     def check_product_id(self):
         if any(elem.product_id.type != 'product' for elem in self):
             raise ValidationError(_('Quants cannot be created for consumables or services.'))
 
-    @api.multi
     @api.constrains('quantity')
     def check_quantity(self):
         for quant in self:
             if quant.quantity > 1 and quant.lot_id and quant.product_id.tracking == 'serial':
                 raise ValidationError(_('A serial number should only be linked to a single product.'))
 
-    @api.multi
     @api.constrains('in_date', 'lot_id')
     def check_in_date(self):
         for quant in self:
@@ -304,7 +300,6 @@ class QuantPackage(models.Model):
             package.company_id = values['company_id']
             package.owner_id = values['owner_id']
 
-    @api.multi
     def name_get(self):
         return list(self._compute_complete_name().items())
 
@@ -325,7 +320,6 @@ class QuantPackage(models.Model):
             self.current_picking_move_line_ids = False
             self.current_picking_id = False
 
-
     def _search_location(self, operator, value):
         if value:
             packs = self.search([('quant_ids.location_id', operator, value)])
@@ -367,7 +361,6 @@ class QuantPackage(models.Model):
                 raise UserError(_('Everything inside a package should be in the same location'))
         return True
 
-    @api.multi
     def unpack(self):
         for package in self:
             move_lines_to_remove = self.move_line_ids.filtered(lambda move_line: move_line.state != 'done')
@@ -382,16 +375,13 @@ class QuantPackage(models.Model):
         action['domain'] = [('id', 'in', pickings.ids)]
         return action
 
-    @api.multi
     def view_content_package(self):
         action = self.env['ir.actions.act_window'].for_xml_id('stock', 'quantsact')
         action['domain'] = [('id', 'in', self._get_contained_quants().ids)]
         return action
-    get_content_package = view_content_package
 
     def _get_contained_quants(self):
         return self.env['stock.quant'].search([('package_id', 'child_of', self.ids)])
-    get_content = _get_contained_quants
 
     def _get_all_products_quantities(self):
         '''This function computes the different product quantities for the given package

--- a/addons/stock/models/stock_scrap.py
+++ b/addons/stock/models/stock_scrap.py
@@ -66,7 +66,6 @@ class StockScrap(models.Model):
         scrap.do_scrap()
         return scrap
 
-    @api.multi
     def unlink(self):
         if 'done' in self.mapped('state'):
             raise UserError(_('You cannot delete a scrap which is done.'))
@@ -75,7 +74,6 @@ class StockScrap(models.Model):
     def _get_origin_moves(self):
         return self.picking_id and self.picking_id.move_lines.filtered(lambda x: x.product_id == self.product_id)
 
-    @api.multi
     def do_scrap(self):
         for scrap in self:
             move = self.env['stock.move'].create(scrap._prepare_move_values())
@@ -89,7 +87,7 @@ class StockScrap(models.Model):
                 ]).mapped('quantity'))
                 if quantity_in_stock < move.product_qty:  # FIXME: float compare
                     raise UserError(_('You cannot scrap a move without having available stock for %s. You can correct it with an inventory adjustment.') % move.product_id.name)
-            move.action_done()
+            move._action_done()
             scrap.write({'move_id': move.id, 'state': 'done'})
         return True
 
@@ -116,18 +114,12 @@ class StockScrap(models.Model):
             'picking_id': self.picking_id.id
         }
 
-    @api.multi
     def action_get_stock_picking(self):
         action = self.env.ref('stock.action_picking_tree_all').read([])[0]
         action['domain'] = [('id', '=', self.picking_id.id)]
         return action
 
-    @api.multi
     def action_get_stock_move(self):
         action = self.env.ref('stock.stock_move_action').read([])[0]
         action['domain'] = [('id', '=', self.move_id.id)]
         return action
-
-    @api.multi
-    def action_done(self):
-        return {'type': 'ir.actions.act_window_close'}

--- a/addons/stock/models/stock_traceability.py
+++ b/addons/stock/models/stock_traceability.py
@@ -292,7 +292,6 @@ class MrpStockReport(models.TransientModel):
             final_vals += self.make_dict_head(level, model=model, stream=stream, parent_id=parent_id, move_line=line)
         return final_vals
 
-    @api.multi
     def get_pdf_lines(self, line_data=[]):
         final_vals = []
         lines = []

--- a/addons/stock/models/stock_warehouse.py
+++ b/addons/stock/models/stock_warehouse.py
@@ -118,7 +118,6 @@ class Warehouse(models.Model):
             self._update_partner_data(vals['partner_id'], vals.get('company_id'))
         return warehouse
 
-    @api.multi
     def write(self, vals):
         Route = self.env['stock.location.route']
         warehouses = self.with_context(active_test=False)  # TDE FIXME: check this
@@ -251,7 +250,6 @@ class Warehouse(models.Model):
         PickingType.browse(warehouse_data['in_type_id']).write({'return_picking_type_id': warehouse_data['out_type_id']})
         return warehouse_data
 
-    @api.multi
     def create_routes(self):
         self.ensure_one()
         routes_data = self.get_routes_dict()
@@ -459,7 +457,6 @@ class Warehouse(models.Model):
                 self.Routing(warehouse.wh_output_stock_loc_id, customer_loc, warehouse.out_type_id)],
         }) for warehouse in self)
 
-    @api.multi
     def _get_reception_delivery_route_values(self, route_type):
         return {
             'name': self._format_routename(route_type=route_type),
@@ -499,7 +496,6 @@ class Warehouse(models.Model):
     # Pull / Push tools
     # ------------------------------------------------------------
 
-    @api.multi
     def _get_push_pull_rules_values(self, route_values, values=None, push_values=None, pull_values=None, name_suffix=''):
         first_rule = True
         push_rules_list, pull_rules_list = [], []
@@ -584,7 +580,6 @@ class Warehouse(models.Model):
             '&', ('route_id', 'in', routes.ids),
             ('location_src_id.usage', '=', 'transit')]).write({'location_id': new_location.id})
 
-    @api.multi
     def _update_routes(self):
         routes_data = self.get_routes_dict()
         # change the default source and destination location and (de)activate operation types
@@ -601,7 +596,6 @@ class Warehouse(models.Model):
         for field_name, values in picking_type_values.items():
             self[field_name].write(values)
 
-    @api.multi
     def _update_name_and_code(self, new_name=False, new_code=False):
         if new_code:
             self.mapped('lot_stock_id').mapped('location_id').write({'name': new_code})
@@ -688,18 +682,15 @@ class Warehouse(models.Model):
             'int_type_id': {'name': self.name + _('Sequence internal'), 'prefix': self.code + '/INT/', 'padding': 5},
         }
 
-    @api.multi
     def _format_rulename(self, from_loc, dest_loc, suffix):
         return '%s: %s -> %s%s' % (self.code, from_loc.name, dest_loc.name, suffix)
 
-    @api.multi
     def _format_routename(self, name=None, route_type=None):
         if route_type:
             name = self._get_route_name(route_type)
         return '%s: %s' % (self.name, name)
 
     @api.returns('self')
-    @api.multi
     def _get_all_routes(self):
         # TDE FIXME: check overrides
         routes = self.mapped('route_ids') | self.mapped('mto_pull_id').mapped('route_id')
@@ -707,7 +698,6 @@ class Warehouse(models.Model):
         return routes
     get_all_routes_for_wh = _get_all_routes
 
-    @api.multi
     def action_view_all_routes(self):
         routes = self._get_all_routes()
         return {
@@ -786,7 +776,6 @@ class Orderpoint(models.Model):
         ('qty_multiple_check', 'CHECK( qty_multiple >= 0 )', 'Qty Multiple must be greater than or equal to zero.'),
     ]
 
-    @api.multi
     def _quantity_in_progress(self):
         """Return Quantities that are not yet in virtual stock but should be deduced from orderpoint rule
         (example: purchases created from orderpoints)"""
@@ -822,7 +811,6 @@ class Orderpoint(models.Model):
         date_planned = start_date + relativedelta.relativedelta(days=days)
         return date_planned.strftime(DEFAULT_SERVER_DATETIME_FORMAT)
 
-    @api.multi
     def _prepare_procurement_values(self, product_qty, date=False, group=False):
         """ Prepare specific key for moves or other components that will be created from a procurement rule
         comming from an orderpoint. This method could be override in order to add other custom key that could
