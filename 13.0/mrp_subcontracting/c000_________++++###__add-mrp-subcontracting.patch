PR: https://github.com/odoo/odoo/pull/

From: d91db5bde6133d9da86893043afbaed8134e4104
From: Simon Lejeune
Date: 2019-04-03 13:52:22

Structural Changes: 18
Total Changes: 447

[ADD] mrp_subcontracting

In a few words, it allows to send components to a subcontractor partner
and receive a finished product. The production is managed through classical
manufacturing orders where the raw and finished location is the
subcontracting location. When creating a receipt picking for a
subcontractor partner, the location_id of the moves will be set to the
subcontracting locations by using the property_stock_customer and
property_stock_supplier of the partner. An override of _action_confirm
will create the manufacturing order.

When a subcontracted bom contains tracking, the produce wizard is
available from the picking to record which lots were produced/consumed.

New type on the BoM: subcontract
New type on res.partner: subcontactor
New location per company (we still own the components stored at the
subcontractor so they're still valued)
New routes created to resupply the subcontracting location on order or
not (through a reordering rule).
Override of res.partner to set the property_stock_customer/supplier on
subcontactor partners.

Proper tests were added too.

Joint work with: Arnaud Baes <arb@odoo.com>

task 1831382

================================= pseudo patch: =================================

--- a/None
+++ b/addons/mrp_subcontracting/models/__init__.py
@@ -0,0 +1,9 @@
+# -*- coding: utf-8 -*-
+
+from . import mrp_bom
+from . import res_company
+from . import res_partner
+from . import stock_move
+from . import stock_picking
+from . import stock_warehouse
+

--- a/None
+++ b/addons/mrp_subcontracting/models/mrp_bom.py
@@ -0,0 +1,20 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from odoo import fields, models
+
+
+class MrpBom(models.Model):
+    _inherit = 'mrp.bom'
+
+    type = fields.Selection(selection_add=[('subcontract', 'Subcontracting')])
+    subcontractor_ids = fields.One2many('res.partner', 'bom_id', domain=[('type', '=', 'subcontractor')], string='Subcontractors')
+
+    def _bom_subcontract_find(self, product_tmpl=None, product=None, picking_type=None, company_id=False, bom_type='subcontract', subcontractor=False):
+        domain = self._bom_find_domain(product_tmpl=product_tmpl, product=product, picking_type=picking_type, company_id=company_id, bom_type=bom_type)
+        if subcontractor:
+            domain += ['|', ('subcontractor_ids', 'in', subcontractor.id), ('subcontractor_ids', '=', False)]
+        else:
+            domain += [('subcontractor_ids', '=', False)]
+        return self.search(domain, order='subcontractor_ids, sequence, product_id', limit=1)
+

--- a/None
+++ b/addons/mrp_subcontracting/models/res_company.py
@@ -0,0 +1,47 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from odoo import api, fields, models, _
+
+
+class ResCompany(models.Model):
+    _inherit = 'res.company'
+
+    subcontracting_location_id = fields.Many2one('stock.location')
+
+    def _create_per_company_locations(self):
+        super(ResCompany, self)._create_per_company_locations()
+        self._create_subcontracting_location()
+
+    def _create_subcontracting_location(self):
+        for company in self:
+            parent_location = self.env.ref('stock.stock_location_locations_partner', raise_if_not_found=False)
+            subcontracting_location = self.env['stock.location'].create({
+                'name': _('%s: Subcontracting Location') % company.name,
+                'usage': 'internal',
+                'location_id': parent_location.id,
+                'company_id': company.id,
+            })
+            company.write({'subcontracting_location_id': subcontracting_location.id})
+
+    @api.model
+    def create_missing_subcontracting_location(self):
+        company_without_subcontracting_loc = self.env['res.company'].search(
+            [('subcontracting_location_id', '=', False)])
+        for company in company_without_subcontracting_loc:
+            company._create_subcontracting_location()
+
+    def _create_resupply_subcontractor_rules(self):
+        self.ensure_one()
+        wh = self.env['stock.warehouse'].search([('company_id', '=', self.id), ('active', '=', True)], limit=1)
+        subcontracting_location = self.subcontracting_location_id
+        production_location = wh._get_production_location()
+        resupply_route = wh._find_global_route('mrp_subcontracting.route_resupply_subcontractor_mto', _('Resupply Subcontractor on Order'))
+        resupply_route.rule_ids = [(0, 0, {
+            'name': '%s â†’ %s' % (subcontracting_location.name, production_location.name),
+            'action': 'pull',
+            'picking_type_id': wh.subcontracting_type_id,
+            'location_src_id': subcontracting_location,
+            'location_id': production_location,
+        })],
+

--- a/None
+++ b/addons/mrp_subcontracting/models/res_partner.py
@@ -0,0 +1,56 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from odoo import api, fields, models, _
+
+
+class ResPartner(models.Model):
+    _inherit = 'res.partner'
+
+    type = fields.Selection(selection_add=[('subcontractor', 'Subcontractor')])
+    bom_id = fields.Many2one('mrp.bom', domain=[('type', '=', 'subcontract')])
+
+    def _get_name(self):
+        name = super(ResPartner, self)._get_name()
+        if self.type == 'subcontractor':
+            subcontractor = _('Subcontractor')
+            if name.endswith(', '):
+                name = "%s%s" % (name, subcontractor)
+            else:
+                name = '%s, %s' % (name, subcontractor)
+        return name
+
+    @api.onchange('type')
+    def _onchange_partner_type(self):
+        if self.type == 'subcontractor':
+            company = self.company_id or self.parent_id.company_id
+            subcontracting_location = company.subcontracting_location_id
+            self.update({
+                'property_stock_customer': subcontracting_location,
+                'property_stock_supplier': subcontracting_location
+            })
+        else:
+            self.update({
+                'property_stock_customer': self.env.ref('stock.stock_location_customers'),
+                'property_stock_supplier': self.env.ref('stock.stock_location_suppliers')
+            })
+
+    @api.model_create_multi
+    def create(self, vals_list):
+        for vals in vals_list:
+            if vals.get('type') == 'subcontractor':
+                if not vals.get('property_stock_supplier') and not vals.get('property_stock_customer'):
+                    company = vals.get('company_id') and self.env['res.company'].browse(vals['company_id']) or \
+                              self.browse(vals.get('parent_id')).company_id
+                    subcontracting_location = company.subcontracting_location_id
+                    vals['property_stock_supplier'] = subcontracting_location
+                    vals['property_stock_customer'] = subcontracting_location
+        return super(ResPartner, self).create(vals_list)
+
+    def write(self, vals):
+        if vals.get('type') == 'subcontractor':
+            subcontracting_location = self.env.user.company_id.subcontracting_location_id
+            if not vals.get('property_stock_supplier') and not vals.get('property_stock_customer'):
+                vals['property_stock_supplier'] = subcontracting_location.id
+                vals['property_stock_customer'] = subcontracting_location.id
+        return super(ResPartner, self).write(vals)

--- a/None
+++ b/addons/mrp_subcontracting/models/stock_move.py
@@ -0,0 +1,41 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from collections import defaultdict
+
+from odoo import models, _
+from odoo.exceptions import UserError
+
+
+class StockMove(models.Model):
+    _inherit = 'stock.move'
+
+    def _get_subcontract_bom(self):
+        self.ensure_one()
+        bom = self.env['mrp.bom']._bom_subcontract_find(
+            product=self.product_id,
+            picking_type=self.picking_type_id,
+            company_id=self.company_id.id,
+            bom_type='subcontract',
+            subcontractor=self.picking_id.partner_id,
+        )
+        return bom
+
+    def _action_confirm(self, merge=True, merge_into=False):
+        res = super(StockMove, self)._action_confirm(merge=merge, merge_into=merge_into)
+        subcontract_details_per_picking = defaultdict(list)
+        for move in res:
+            if not move.picking_id:
+                continue
+            if not move.picking_id._is_subcontract():
+                continue
+            bom = move._get_subcontract_bom()
+            if not bom:
+                error_message = _('Please define a BoM of type subcontracting for the product "%s". If you don\'t want to subcontract the product "%s", do not select a partner of type subcontractor.')
+                error_message += '\n\n'
+                error_message += _('If there is well a BoM of type subcontracting defined, check if you have set the correct subcontractors on it.')
+                raise UserError(error_message % (move.product_id.name, move.product_id.name))
+            subcontract_details_per_picking[move.picking_id].append((move, bom))
+        for picking, subcontract_details in subcontract_details_per_picking.items():
+            picking._subcontracted_produce(subcontract_details)
+        return res

--- a/None
+++ b/addons/mrp_subcontracting/models/stock_picking.py
@@ -0,0 +1,133 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from odoo import api, fields, models
+
+
+class StockPicking(models.Model):
+    _inherit = 'stock.picking'
+
+    display_action_record_components = fields.Boolean(compute='_compute_display_action_record_components')
+    display_view_subcontracted_move_lines = fields.Boolean(compute='_compute_display_view_subcontracted_move_lines')
+
+    @api.depends('state')
+    def _compute_display_action_record_components(self):
+        for picking in self:
+            # Hide if not encoding state
+            if picking.state in ('draft', 'cancel', 'done'):
+                continue
+            if not picking._is_subcontract():
+                continue
+            # Hide if no move is tracked
+            subcontracted_productions = picking._get_subcontracted_productions()
+            subcontracted_moves = subcontracted_productions.mapped('move_raw_ids')
+            subcontracted_moves |= subcontracted_productions.mapped('move_finished_ids')
+            if all(subcontracted_move.has_tracking == 'none' for subcontracted_move in subcontracted_moves):
+                continue
+            # Hide if the production is to close
+            if not subcontracted_productions.filtered(lambda mo: mo.state not in ('to_close', 'done')):
+                continue
+            picking.display_action_record_components = True
+
+    @api.depends('state')
+    def _compute_display_view_subcontracted_move_lines(self):
+        for picking in self:
+            # Hide if not encoding state
+            if picking.state in ('draft', 'cancel'):
+                continue
+            if not picking._is_subcontract():
+                continue
+            # Hide until state done if no move is tracked, if tracked until something was produced
+            subcontracted_productions = picking._get_subcontracted_productions()
+            subcontracted_moves = subcontracted_productions.mapped('move_raw_ids')
+            subcontracted_moves |= subcontracted_productions.mapped('move_finished_ids')
+            if all(subcontracted_move.has_tracking == 'none' for subcontracted_move in subcontracted_moves):
+                if picking.state != 'done':
+                    continue
+            # Hide if nothing was produced
+            if all(subcontracted_move.quantity_done == 0 for subcontracted_move in subcontracted_moves):
+                continue
+            picking.display_view_subcontracted_move_lines = True
+
+    # -------------------------------------------------------------------------
+    # Action methods
+    # -------------------------------------------------------------------------
+    def action_done(self):
+        for picking in self:
+            subcontracted_productions = picking._get_subcontracted_productions()
+            for subcontracted_production in subcontracted_productions:
+                subcontracted_production.button_mark_done()
+        return super(StockPicking, self).action_done()
+
+    def action_view_subcontracted_move_lines(self):
+        """ Returns a list view with the move lines of the subcontracted products. To find them, we
+        look on the origin moves of the move lines of the picking if there is a manufacturing order.
+        """
+        self.ensure_one()
+        subcontracted_productions = self._get_subcontracted_productions()
+        subcontracted_move_lines = self.env['stock.move.line']
+        for subcontracted_production in subcontracted_productions:
+            subcontracted_move_lines |= subcontracted_production.move_raw_ids.mapped('move_line_ids')
+            subcontracted_move_lines |= subcontracted_production.move_finished_ids.mapped('move_line_ids')
+        action = self.env.ref('stock.stock_move_line_action').read()[0]
+        action['context'] = {}
+        action['domain'] = [('id', 'in', subcontracted_move_lines.ids)]
+        return action
+
+    def action_record_components(self):
+        self.ensure_one()
+        subcontracted_productions = self._get_subcontracted_productions()
+        to_register = subcontracted_productions.filtered(lambda mo: mo.state not in ('to_close', 'done'))
+        if to_register:
+            mo = to_register[0]
+            action = self.env.ref('mrp.act_mrp_product_produce').read()[0]
+            action['context'] = dict(self.env.context, active_id=mo.id)
+            return action
+
+    # -------------------------------------------------------------------------
+    # Subcontract helpers
+    # -------------------------------------------------------------------------
+    def _is_subcontract(self):
+        self.ensure_one()
+        if self.partner_id.type == 'subcontractor' and \
+                self.picking_type_id.code == 'incoming':
+            return True
+        return False
+
+    def _get_subcontracted_productions(self):
+        self.ensure_one()
+        return self.move_lines.mapped('move_orig_ids.production_id')
+
+    def _prepare_subcontract_mo_vals(self, subcontract_move, bom):
+        subcontract_move.ensure_one()
+        product = subcontract_move.product_id
+        warehouse = subcontract_move.warehouse_id or self.picking_type_id.warehouse_id
+        vals = {
+            'product_id': product.id,
+            'product_uom_id': subcontract_move.product_uom.id,
+            'bom_id': bom.id,
+            'location_src_id': subcontract_move.picking_id.partner_id.property_stock_supplier.id,
+            'location_dest_id': subcontract_move.location_id.id,
+            'product_qty': subcontract_move.product_uom_qty,
+            'picking_type_id': warehouse.subcontracting_type_id.id
+        }
+        return vals
+
+    def _subcontracted_produce(self, subcontract_details):
+        self.ensure_one()
+        for move, bom in subcontract_details:
+            mo = self.env['mrp.production'].create(self._prepare_subcontract_mo_vals(move, bom))
+            self.env['stock.move'].create(mo._get_moves_raw_values())
+            mo.action_confirm()
+
+            # Link the finished to the receipt move.
+            finished_move = mo.move_finished_ids.filtered(lambda m: m.product_id == move.product_id)
+            finished_move.write({'move_dest_ids': [(4, move.id, False)]})
+            mo.action_assign()
+
+            # Only skip the produce wizard if no moves is tracked
+            moves = mo.mapped('move_raw_ids') + mo.mapped('move_finished_ids')
+            if any(move.has_tracking != 'none' for move in moves):
+                continue
+            for m in moves:
+                m.quantity_done = m.product_uom_qty

--- a/None
+++ b/addons/mrp_subcontracting/models/stock_warehouse.py
@@ -0,0 +1,141 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from odoo import api, fields, models, _
+
+
+class StockWarehouse(models.Model):
+    _inherit = 'stock.warehouse'
+
+    subcontracting_to_resupply = fields.Boolean(
+        'Resupply Subcontractors', default=True,
+        help="Resupply subcontractors with components")
+
+    subcontracting_mto_pull_id = fields.Many2one(
+        'stock.rule', 'Subcontracting MTO Rule')
+    subcontracting_pull_id = fields.Many2one(
+        'stock.rule', 'Subcontracting MTS Rule'
+    )
+
+    subcontracting_route_id = fields.Many2one('stock.location.route', 'Resupply Subcontractor', ondelete='restrict')
+
+    subcontracting_type_id = fields.Many2one(
+        'stock.picking.type', 'Subcontracting Operation Type',
+        domain=[('code', '=', 'mrp_operation')])
+
+    def get_rules_dict(self):
+        result = super(StockWarehouse, self).get_rules_dict()
+        subcontract_location_id = self._get_subcontracting_location()
+        for warehouse in self:
+            result[warehouse.id].update({
+                'subcontract': [
+                    self.Routing(warehouse.lot_stock_id, subcontract_location_id, warehouse.out_type_id, 'pull'),
+                ]
+            })
+        return result
+
+    def _get_routes_values(self):
+        routes = super(StockWarehouse, self)._get_routes_values()
+        routes.update({
+            'subcontracting_route_id': {
+                'routing_key': 'subcontract',
+                'depends': ['subcontracting_to_resupply'],
+                'route_create_values': {
+                    'product_categ_selectable': False,
+                    'warehouse_selectable': True,
+                    'product_selectable': False,
+                    'company_id': self.company_id.id,
+                    'sequence': 10,
+                    'name': self._format_routename(name=_('Resupply Subcontractor'))
+                },
+                'route_update_values': {
+                    'active': self.subcontracting_to_resupply,
+                },
+                'rules_values': {
+                    'active': self.subcontracting_to_resupply,
+                }
+            }
+        })
+        return routes
+
+    def _get_global_route_rules_values(self):
+        rules = super(StockWarehouse, self)._get_global_route_rules_values()
+        subcontract_location_id = self._get_subcontracting_location()
+        production_location_id = self._get_production_location()
+        rules.update({
+            'subcontracting_mto_pull_id': {
+                'depends': ['subcontracting_to_resupply'],
+                'create_values': {
+                    'procure_method': 'make_to_order',
+                    'company_id': self.company_id.id,
+                    'action': 'pull',
+                    'auto': 'manual',
+                    'propagate': True,
+                    'route_id': self._find_global_route('stock.route_warehouse0_mto', _('Make To Order')).id,
+                    'name': self._format_rulename(self.lot_stock_id, subcontract_location_id, 'MTO'),
+                    'location_id': subcontract_location_id.id,
+                    'location_src_id': self.lot_stock_id.id,
+                    'picking_type_id': self.out_type_id.id
+                },
+                'update_values': {
+                    'active': self.subcontracting_to_resupply
+                }
+            },
+            'subcontracting_pull_id': {
+                'depends': ['subcontracting_to_resupply'],
+                'create_values': {
+                    'procure_method': 'make_to_order',
+                    'company_id': self.company_id.id,
+                    'action': 'pull',
+                    'auto': 'manual',
+                    'propagate': True,
+                    'route_id': self._find_global_route('mrp_subcontracting.route_resupply_subcontractor_mto',
+                                                        _('Resupply Subcontractor on Order')).id,
+                    'name': self._format_rulename(self.lot_stock_id, subcontract_location_id, False),
+                    'location_id': production_location_id.id,
+                    'location_src_id': subcontract_location_id.id,
+                    'picking_type_id': self.out_type_id.id
+                },
+                'update_values': {
+                    'active': self.subcontracting_to_resupply
+                }
+            },
+        })
+        return rules
+
+    def _get_picking_type_create_values(self, max_sequence):
+        data, next_sequence = super(StockWarehouse, self)._get_picking_type_create_values(max_sequence)
+        data.update({
+            'subcontracting_type_id': {
+                'name': _('Subcontracting'),
+                'code': 'mrp_operation',
+                'use_create_lots': True,
+                'use_existing_lots': True,
+                'sequence': next_sequence + 2
+            },
+        })
+        return data, max_sequence + 4
+
+    def _get_sequence_values(self):
+        values = super(StockWarehouse, self)._get_sequence_values()
+        values.update({
+            'subcontracting_type_id': {'name': self.name + ' ' + _('Sequence subcontracting'), 'prefix': self.code + '/SBC/', 'padding': 5},
+        })
+        return values
+
+    def _get_picking_type_update_values(self):
+        data = super(StockWarehouse, self)._get_picking_type_update_values()
+        subcontract_location_id = self._get_subcontracting_location()
+        production_location_id = self._get_production_location()
+        data.update({
+            'subcontracting_type_id': {
+                'active': False,
+                'default_location_src_id': subcontract_location_id.id,
+                'default_location_dest_id': production_location_id.id,
+            },
+        })
+        return data
+
+    def _get_subcontracting_location(self):
+        return self.company_id.subcontracting_location_id
+
