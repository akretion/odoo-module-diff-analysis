PR: https://github.com/odoo/odoo/pull/189701

From: 704a5a19499469e5a14461bb81d33c832ce00d70
From: Julien Alardot (jual)
Date: 2025-02-14 19:09:48

Breaking data model changes scores: del:49 + add:3, change matches:
-    expense_sheet_id = fields.Many2one(comodel_name='hr.expense.sheet', ondelete='set null', copy=False, index='btree_not_null')
-    show_commercial_partner_warning = fields.Boolean(compute='_compute_show_commercial_partner_warning')
+    expense_ids = fields.One2many(comodel_name='hr.expense', inverse_name='account_move_id')
-    expense_sheet_id = fields.Many2one(related='move_id.expense_sheet_id')
+    expense_ids = fields.One2many(related='move_id.expense_ids')
-    expense_sheets_to_approve_count = fields.Integer(compute='_compute_expense_sheets_to_approve', string='Expenses Reports to Approve')
-    sheet_id = fields.Many2one(
-    approved_by = fields.Many2one(comodel_name='res.users', string="Approved By", related='sheet_id.user_id', tracking=False)
-    approved_on = fields.Datetime(string="Approved On", related='sheet_id.approval_date')
-    total_amount = fields.Monetary(
+    selectable_payment_method_line_ids = fields.Many2many(
-    accounting_date = fields.Date(
-    _inherit = ['mail.thread.main.attachment', 'mail.activity.mixin']
-    name = fields.Char(string="Expense Report Summary", required=True, tracking=True)
-    expense_line_ids = fields.One2many(
-    nb_expense = fields.Integer(compute='_compute_nb_expense', string="Number of Expenses")
-    state = fields.Selection(
-    approval_state = fields.Selection(
-    approval_date = fields.Datetime(string="Approval Date", readonly=True)
-    company_id = fields.Many2one(
-    employee_id = fields.Many2one(
-    department_id = fields.Many2one(
-    user_id = fields.Many2one(
-    product_ids = fields.Many2many(
-    total_amount = fields.Monetary(
-    untaxed_amount = fields.Monetary(
-    total_tax_amount = fields.Monetary(
-    amount_residual = fields.Monetary(
-    currency_id = fields.Many2one(
-    company_currency_id = fields.Many2one(
-    is_multiple_currency = fields.Boolean(
-    payment_state = fields.Selection(
-    payment_mode = fields.Selection(
-    employee_journal_id = fields.Many2one(
-    selectable_payment_method_line_ids = fields.Many2many(
-    payment_method_line_id = fields.Many2one(
-    attachment_ids = fields.One2many(
-    message_main_attachment_id = fields.Many2one(compute='_compute_main_attachment', store=True)
-    accounting_date = fields.Date(string="Expense Report Date", help="Specify the bill date of the related vendor bill.")
-    account_move_ids = fields.One2many(
-    nb_account_move = fields.Integer(string="Number of Journal Entries", compute='_compute_nb_account_move')
-    journal_id = fields.Many2one(
-    can_reset = fields.Boolean(string='Can Reset', compute='_compute_can_reset')
-    can_approve = fields.Boolean(string='Can Approve', compute='_compute_can_approve')
-    cannot_approve_reason = fields.Char(string='Cannot Approve Reason', compute='_compute_can_approve')
-    is_editable = fields.Boolean(string="Expense Lines Are Editable By Current User", compute='_compute_is_editable')
-    _inherit = 'ir.attachment'

Total Changes: 2716

[IMP] *expense*: Bye Bye reports

Most of the time, expenses are created as "standalone"s and forcing
the use of an expense report is adding frustrating unnecessary steps.

A simplification was decided and the model hr.expense.sheet is removed,
giving all of its remaining important logic to the `hr.expense`.

In addition, approval flow was simplified with the implementation of
an auto-validation process, where submitting an expense also approves it
when no expense manager is set on the employee.

See task for more details.

closes odoo/odoo#189701

Task-id: 4481615
Related: odoo/enterprise#75507
Related: odoo/upgrade#6990
Signed-off-by: Olivier Colson (oco) <oco@odoo.com>

================================= pseudo patch: =================================

--- a/addons/hr_expense/models/__init__.py
+++ b/addons/hr_expense/models/__init__.py
@@ -7,8 +7,6 @@ from . import account_payment
 from . import account_tax
 from . import hr_department
 from . import hr_expense
-from . import hr_expense_sheet
-from . import ir_attachment
 from . import product_product
 from . import product_template
 from . import res_config_settings

--- a/addons/hr_expense/models/account_move.py
+++ b/addons/hr_expense/models/account_move.py
@@ -1,77 +1,93 @@
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
+from markupsafe import Markup
 
-from odoo import models, fields, api, _
-from odoo.api import ondelete
-from odoo.exceptions import UserError
+from odoo import Command, models, fields, api, _
+from odoo.exceptions import ValidationError
 from odoo.tools.misc import frozendict
 
 
 class AccountMove(models.Model):
     _inherit = "account.move"
 
-    expense_sheet_id = fields.Many2one(comodel_name='hr.expense.sheet', ondelete='set null', copy=False, index='btree_not_null')
-    show_commercial_partner_warning = fields.Boolean(compute='_compute_show_commercial_partner_warning')
+    expense_ids = fields.One2many(comodel_name='hr.expense', inverse_name='account_move_id')
+    nb_expenses = fields.Integer(compute='_compute_nb_expenses', string='Number of Expenses', compute_sudo=True)
 
-    @api.depends('partner_id', 'expense_sheet_id', 'company_id')
+    def _compute_nb_expenses(self):
+        for move in self:
+            move.nb_expenses = len(move.expense_ids)
+
+    @api.depends('partner_id', 'expense_ids', 'company_id')
     def _compute_commercial_partner_id(self):
-        own_expense_moves = self.filtered(lambda move: move.sudo().expense_sheet_id.payment_mode == 'own_account')
+        own_expense_moves = self.filtered(lambda move: any(expense.payment_mode == 'own_account' for expense in move.sudo().expense_ids))
         for move in own_expense_moves:
-            if move.expense_sheet_id.payment_mode == 'own_account':
-                move.commercial_partner_id = (
-                    move.partner_id.commercial_partner_id
-                    if move.partner_id.commercial_partner_id != move.company_id.partner_id
-                    else move.partner_id
-                )
+            move.commercial_partner_id = (
+                move.partner_id.commercial_partner_id
+                if move.partner_id.commercial_partner_id != move.company_id.partner_id
+                else move.partner_id
+            )
         super(AccountMove, self - own_expense_moves)._compute_commercial_partner_id()
 
-    def action_open_expense_report(self):
+    @api.constrains('expense_ids')
+    def _check_expense_ids(self):
+        for move in self:
+            expense_payment_modes = move.expense_ids.mapped('payment_mode')
+            if 'company_account' in expense_payment_modes and len(move.expense_ids) > 1 :
+                raise ValidationError(_("Each expense paid by the company must have a distinct and dedicated journal entry."))
+
+    def action_open_expense(self):
         self.ensure_one()
+        linked_expenses = self.expense_ids
+        if len(linked_expenses) > 1:
+            return {
+            'name': _("Expenses"),
+            'type': 'ir.actions.act_window',
+            'view_mode': 'list,form',
+            'views': [(False, 'list'), (False, 'form')],
+            'res_model': 'hr.expense',
+            'domain': [('id', 'in', linked_expenses.ids)],
+        }
         return {
-            'name': self.expense_sheet_id.name,
+            'name': linked_expenses.name,
             'type': 'ir.actions.act_window',
             'view_mode': 'form',
             'views': [(False, 'form')],
-            'res_model': 'hr.expense.sheet',
-            'res_id': self.expense_sheet_id.id
+            'res_model': 'hr.expense',
+            'res_id': linked_expenses.id
         }
 
-    @api.depends('commercial_partner_id')
-    def _compute_show_commercial_partner_warning(self):
-        for move in self:
-            move.show_commercial_partner_warning = (
-                    move.commercial_partner_id == self.env.company.partner_id
-                    and move.move_type == 'in_invoice'
-                    and move.partner_id.employee_ids
-            )
-
     # Expenses can be written on journal other than purchase, hence don't include them in the constraint check
     def _check_journal_move_type(self):
-        return super(AccountMove, self.filtered(lambda x: not x.expense_sheet_id))._check_journal_move_type()
+        return super(AccountMove, self.filtered(lambda x: not x.expense_ids))._check_journal_move_type()
 
     def _creation_message(self):
-        if self.expense_sheet_id:
-            return _("Expense entry created from: %s", self.expense_sheet_id._get_html_link())
+        if self.expense_ids:
+            if len(self.expense_ids) == 1:
+                return _("Journal entry created from this expense: %(link)s", link=self.expense_ids._get_html_link())
+            links = self.expense_ids[0]._get_html_link()
+            for additional_expense in self.expense_ids[1:]:  # ', ' Destroys Markup, and each part here is safe
+                links += ', ' + additional_expense._get_html_link()
+            return _("Journal entry created from these expenses: %(links)s", links=links)
         return super()._creation_message()
 
-    @api.depends('expense_sheet_id')
+    @api.depends('expense_ids')
     def _compute_needed_terms(self):
         # EXTENDS account
         # We want to set the account destination based on the 'payment_mode'.
         super()._compute_needed_terms()
         for move in self:
-            if move.expense_sheet_id and move.expense_sheet_id.payment_mode == 'company_account':
+            if move.expense_ids and 'company_account' in move.expense_ids.mapped('payment_mode'):
                 term_lines = move.line_ids.filtered(lambda l: l.display_type != 'payment_term')
                 move.needed_terms = {
                     frozendict(
                         {
                             "move_id": move.id,
-                            "date_maturity": move.expense_sheet_id.accounting_date or fields.Date.context_today(move.expense_sheet_id),
+                            "date_maturity": fields.Date.context_today(move.expense_ids),
                         }
                     ): {
                         "balance": -sum(term_lines.mapped("balance")),
                         "amount_currency": -sum(term_lines.mapped("amount_currency")),
                         "name": "",
-                        "account_id": move.expense_sheet_id._get_expense_account_destination(),
+                        "account_id": move.expense_ids._get_expense_account_destination(),
                     }
                 }
 
@@ -84,20 +100,13 @@ class AccountMove(models.Model):
 
     def _reverse_moves(self, default_values_list=None, cancel=False):
         # EXTENDS account
-        own_expense_moves = self.filtered(lambda move: move.expense_sheet_id.payment_mode == 'own_account')
-        own_expense_moves.write({'expense_sheet_id': False, 'ref': False})
-        # else, when restarting the expense flow we get duplicate issue on vendor.bill
+        self.filtered('expense_ids').write({'expense_ids': [Command.clear()]})
         return super()._reverse_moves(default_values_list=default_values_list, cancel=cancel)
 
-    @ondelete(at_uninstall=True)
-    def _must_delete_all_expense_entries(self):
-        if self.expense_sheet_id and self.expense_sheet_id.account_move_ids - self:  # If not all the payments are to be deleted
-            raise UserError(_("You cannot delete only some entries linked to an expense report. All entries must be deleted at the same time."))
-
     def button_cancel(self):
         # EXTENDS account
         # We need to override this method to remove the link with the move, else we cannot reimburse them anymore.
         # And cancelling the move != cancelling the expense
         res = super().button_cancel()
-        self.write({'expense_sheet_id': False, 'ref': False})
+        self.filtered('expense_ids').write({'expense_ids': [Command.clear()]})
         return res

--- a/addons/hr_expense/models/account_move_line.py
+++ b/addons/hr_expense/models/account_move_line.py
@@ -1,9 +1,7 @@
-# -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
 from odoo import api, fields, models
 from odoo.tools import SQL
-from odoo.tools.misc import frozendict
 
 
 class AccountMoveLine(models.Model):
@@ -13,7 +11,7 @@ class AccountMoveLine(models.Model):
 
     @api.constrains('account_id', 'display_type')
     def _check_payable_receivable(self):
-        super(AccountMoveLine, self.filtered(lambda line: line.move_id.expense_sheet_id.payment_mode != 'company_account'))._check_payable_receivable()
+        super(AccountMoveLine, self.filtered(lambda line: line.expense_id.payment_mode != 'company_account'))._check_payable_receivable()
 
     def _get_attachment_domains(self):
         attachment_domains = super(AccountMoveLine, self)._get_attachment_domains()

--- a/addons/hr_expense/models/account_payment.py
+++ b/addons/hr_expense/models/account_payment.py
@@ -1,52 +1,46 @@
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
-from odoo import models, fields, _
-from odoo.api import ondelete
-from odoo.exceptions import UserError
+from odoo import api, models, fields, _
+from odoo.exceptions import UserError, ValidationError
 
 
 class AccountPayment(models.Model):
     _inherit = "account.payment"
 
-    expense_sheet_id = fields.Many2one(related='move_id.expense_sheet_id')
+    expense_ids = fields.One2many(related='move_id.expense_ids')
 
     def _compute_outstanding_account_id(self):
         # EXTENDS account
-        expense_company_payments = self.filtered(lambda payment: payment.expense_sheet_id.payment_mode == 'company_account')
+        expense_company_payments = self.filtered(lambda payment: payment.expense_ids.payment_mode == 'company_account')
         for payment in expense_company_payments:
-            payment.outstanding_account_id = payment.expense_sheet_id._get_expense_account_destination()
+            payment.outstanding_account_id = payment.expense_ids._get_expense_account_destination()
         super(AccountPayment, self - expense_company_payments)._compute_outstanding_account_id()
 
     def write(self, vals):
         trigger_fields = {
             'date', 'amount', 'payment_type', 'partner_type', 'payment_reference',
             'currency_id', 'partner_id', 'destination_account_id', 'partner_bank_id', 'journal_id'
-            'ref', 'expense_sheet_id', 'payment_method_line_id'
+            'ref', 'payment_method_line_id'
         }
-        if self.expense_sheet_id and any(field_name in trigger_fields for field_name in vals):
-            raise UserError(_("You cannot do this modification since the payment is linked to an expense report."))
+        if self.expense_ids and any(field_name in trigger_fields for field_name in vals):
+            raise UserError(_("You cannot do this modification since the payment is linked to an expense."))
         return super().write(vals)
 
-    def action_open_expense_report(self):
+    def action_open_expense(self):
         self.ensure_one()
         return {
-            'name': self.expense_sheet_id.name,
+            'name': self.expense_ids.name,
             'type': 'ir.actions.act_window',
-            'view_type': 'form',
             'view_mode': 'form',
             'views': [(False, 'form')],
-            'res_model': 'hr.expense.sheet',
-            'res_id': self.expense_sheet_id.id
+            'res_model': 'hr.expense',
+            'res_id': self.expense_ids.id,
         }
 
     def _creation_message(self):
         # EXTENDS mail
         self.ensure_one()
-        if self.move_id.expense_sheet_id:
-            return _("Payment created for: %s", self.move_id.expense_sheet_id._get_html_link())
+        if self.move_id.expense_ids:
+            return _("Payment created for: %s", self.move_id.expense_ids._get_html_link())
         return super()._creation_message()
 
-    @ondelete(at_uninstall=True)
-    def _must_delete_all_expense_payments(self):
-        if self.expense_sheet_id and self.expense_sheet_id.account_move_ids.payment_ids - self:  # If not all the payments are to be deleted
-            raise UserError(_("You cannot delete only some payments linked to an expense report. All payments must be deleted at the same time."))

--- a/addons/hr_expense/models/hr_department.py
+++ b/addons/hr_expense/models/hr_department.py
@@ -1,4 +1,3 @@
-# -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
 from odoo import fields, models
@@ -7,10 +6,11 @@ from odoo import fields, models
 class HrDepartment(models.Model):
     _inherit = 'hr.department'
 
-    def _compute_expense_sheets_to_approve(self):
-        expense_sheet_data = self.env['hr.expense.sheet']._read_group([('department_id', 'in', self.ids), ('state', '=', 'submit')], ['department_id'], ['__count'])
-        result = {department.id: count for department, count in expense_sheet_data}
+    expenses_to_approve_count = fields.Integer(compute='_compute_expenses_to_approve_count', string='Expenses to Approve')
+
+    def _compute_expenses_to_approve_count(self):
+        expense_data = self.env['hr.expense']._read_group([('department_id', 'in', self.ids), ('state', '=', 'submitted')], ['department_id'], ['__count'])
+        result = {department.id: count for department, count in expense_data}
         for department in self:
-            department.expense_sheets_to_approve_count = result.get(department.id, 0)
+            department.expenses_to_approve_count = result.get(department.id, 0)
 
-    expense_sheets_to_approve_count = fields.Integer(compute='_compute_expense_sheets_to_approve', string='Expenses Reports to Approve')

--- a/addons/hr_expense/models/hr_employee.py
+++ b/addons/hr_expense/models/hr_employee.py
@@ -38,10 +38,12 @@ class HrEmployee(models.Model):
         # When a group is created (at module installation), the `res.users` form view is
         # automatically modified to add application accesses. When modifying the view, it
         # reads the related field `expense_manager_id` of `res.users` and retrieve its domain.
-        # This is a problem because the `group_hr_expense_user` record has already been created but
+        # This is a problem because the `group_hr_expense_team_approver` record has already been created but
         # not its associated `ir.model.data` which makes `self.env.ref(...)` fail.
         group = self.env.ref('hr_expense.group_hr_expense_team_approver', raise_if_not_found=False)
-        return [('groups_id', 'in', group.ids)] if group else []
+        return [
+            '|', ('id', 'parent_of', self.ids), ('groups_id', 'in', group.ids)
+        ] if group else [('id', 'parent_of', self.ids)]
 
     expense_manager_id = fields.Many2one(
         comodel_name='res.users',
@@ -56,10 +58,9 @@ class HrEmployee(models.Model):
     def _compute_expense_manager(self):
         for employee in self:
             previous_manager = employee._origin.parent_id.user_id
-            manager = employee.parent_id.user_id
-            if manager and manager.has_group('hr_expense.group_hr_expense_user') \
-                    and (employee.expense_manager_id == previous_manager or not employee.expense_manager_id):
-                employee.expense_manager_id = manager
+            new_manager = employee.parent_id.user_id
+            if new_manager and (employee.expense_manager_id == previous_manager or not employee.expense_manager_id):
+                employee.expense_manager_id = new_manager
             elif not employee.expense_manager_id:
                 employee.expense_manager_id = False
 

--- a/addons/hr_expense/models/hr_expense.py
+++ b/addons/hr_expense/models/hr_expense.py
@@ -1,15 +1,44 @@
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
 import re
+
 from markupsafe import Markup
+import logging
 import werkzeug
 
 from odoo import api, fields, Command, models, _
-from odoo.exceptions import UserError, ValidationError
-from odoo.tools import email_normalize, float_repr, float_round, is_html_empty
+from odoo.exceptions import RedirectWarning, UserError, ValidationError
+from odoo.tools import clean_context, email_normalize, float_repr, float_round, is_html_empty
+
+
+_logger = logging.getLogger(__name__)
+
+EXPENSE_APPROVAL_STATE = [
+    ('submitted', 'Submitted'),
+    ('approved', 'Approved'),
+    ('refused', 'Refused'),
+]
 
 
 class HrExpense(models.Model):
+    """
+        Here are the rights associated with the expense flow
+
+        Action       Group                   Restriction
+        =================================================================================
+        Submit      Employee                Only his own
+                    Officer                 If he is expense manager of the employee, manager of the employee
+                                              or the employee is in the department managed by the officer
+                    Manager                 Always
+        Approve     Officer                 Not his own and he is expense manager of the employee, manager of the employee
+                                              or the employee is in the department managed by the officer
+                    Manager                 Always
+        Post        Billing accountant      State == approved
+        Cancel      Officer                 Not his own and he is expense manager of the employee, manager of the employee
+                                              or the employee is in the department managed by the officer
+                    Manager                 Always
+        =================================================================================
+    """
     _name = 'hr.expense'
     _inherit = ['mail.thread.main.attachment', 'mail.activity.mixin', 'analytic.mixin']
     _description = "Expense"
@@ -40,6 +69,20 @@ class HrExpense(models.Model):
         domain=[('filter_for_expense', '=', True)],
         tracking=True,
     )
+    department_id = fields.Many2one(
+        comodel_name='hr.department',
+        string="Department",
+        compute='_compute_from_employee_id', store=True,
+        copy=False,
+    )
+    manager_id = fields.Many2one(
+        comodel_name='res.users',
+        string="Manager",
+        compute='_compute_from_employee_id', store=True,
+        domain=lambda self: ['|', ('employee_id.expense_manager_id', 'in', self.env.user.id), ('groups_id', 'in', self.env.ref('hr_expense.group_hr_expense_team_approver').ids)],
+        copy=False,
+        tracking=True,
+    )
     company_id = fields.Many2one(
         comodel_name='res.company',
         string="Company",
@@ -77,30 +120,27 @@ class HrExpense(models.Model):
     )
     state = fields.Selection(
         selection=[
-            ('draft', 'To Report'),
-            ('reported', 'To Submit'),
+            # Pre-Approval states
+            ('draft', 'Draft'),
+            # Approval states
             ('submitted', 'Submitted'),
             ('approved', 'Approved'),
-            ('done', 'Done'),
-            ('refused', 'Refused')
+            ('posted', 'Posted'),
+            # Payment states
+            ('in_payment', 'In Payment'),
+            ('paid', 'Paid'),
+            # refused state is always last
+            ('refused', 'Refused'),
         ],
         string="Status",
         compute='_compute_state', store=True, readonly=True,
         index=True,
         copy=False,
         default='draft',
-    )
-    sheet_id = fields.Many2one(
-        comodel_name='hr.expense.sheet',
-        string="Expense Report",
-        domain="[('employee_id', '=', employee_id), ('company_id', '=', company_id)]",
-        readonly=True,
-        copy=False,
         tracking=True,
-        index=True,
     )
-    approved_by = fields.Many2one(comodel_name='res.users', string="Approved By", related='sheet_id.user_id', tracking=False)
-    approved_on = fields.Datetime(string="Approved On", related='sheet_id.approval_date')
+    approval_state = fields.Selection(selection=EXPENSE_APPROVAL_STATE, copy=False, readonly=True)
+    approval_date = fields.Datetime(string="Approval Date", readonly=True)
     duplicate_expense_ids = fields.Many2many(comodel_name='hr.expense', compute='_compute_duplicate_expense_ids')  # Used to trigger warnings
     same_receipt_expense_ids = fields.Many2many(comodel_name='hr.expense', compute='_compute_same_receipt_expense_ids')  # Used to trigger warnings
 
@@ -123,16 +163,26 @@ class HrExpense(models.Model):
         compute='_compute_total_amount_currency', precompute=True, store=True, readonly=False,
         tracking=True,
     )
+    total_amount = fields.Monetary(
+        string="Total",
+        currency_field='company_currency_id',
+        compute='_compute_total_amount', inverse='_inverse_total_amount', precompute=True, store=True, readonly=False,
+        tracking=True,
+    )
     untaxed_amount_currency = fields.Monetary(
         string="Total Untaxed Amount In Currency",
         currency_field='currency_id',
         compute='_compute_tax_amount_currency', precompute=True, store=True,
     )
-    total_amount = fields.Monetary(
-        string="Total",
+    untaxed_amount = fields.Monetary(
+        string="Total Untaxed Amount",
+        currency_field='currency_id',
+        compute='_compute_tax_amount', precompute=True, store=True,
+    )
+    amount_residual = fields.Monetary(
+        string="Amount Due",
         currency_field='company_currency_id',
-        compute='_compute_total_amount', inverse='_inverse_total_amount', precompute=True, store=True, readonly=False,
-        tracking=True,
+        related='account_move_id.amount_residual', readonly=True,
     )
     price_unit = fields.Float(
         string="Unit Price",
@@ -161,6 +211,28 @@ class HrExpense(models.Model):
     label_currency_rate = fields.Char(compute='_compute_currency_rate', readonly=True)
 
     # Account fields
+    journal_id = fields.Many2one(
+        comodel_name='account.journal',
+        related='payment_method_line_id.journal_id',
+        readonly=True,
+    )
+    selectable_payment_method_line_ids = fields.Many2many(
+        comodel_name='account.payment.method.line',
+        compute='_compute_selectable_payment_method_line_ids',
+    )
+    payment_method_line_id = fields.Many2one(
+        comodel_name='account.payment.method.line',
+        string="Payment Method",
+        compute='_compute_payment_method_line_id', store=True, readonly=False,
+        domain="[('id', 'in', selectable_payment_method_line_ids)]",
+        help="The payment method used when the expense is paid by the company.",
+    )
+    account_move_id = fields.Many2one(
+        string="Journal Entry",
+        comodel_name='account.move',
+        readonly=True,
+        copy=False,
+    )
     payment_mode = fields.Selection(
         selection=[
             ('own_account', "Employee (to reimburse)"),
@@ -191,34 +263,108 @@ class HrExpense(models.Model):
         check_company=True,
         help="Both price-included and price-excluded taxes will behave as price-included taxes for expenses.",
     )
-    accounting_date = fields.Date(  # The date used for the accounting entries or the one we'd like to use if not yet posted
-        related='sheet_id.accounting_date',
-        string="Accounting Date",
-        store=True,
-        groups='account.group_account_invoice,account.group_account_readonly',
-    )
 
     # Security fields
-    is_editable = fields.Boolean(string="Is Editable By Current User", compute='_compute_is_editable')
+    is_editable = fields.Boolean(string="Is Editable By Current User", compute='_compute_is_editable', readonly=True)
+    can_reset = fields.Boolean(string='Can Reset', compute='_compute_can_reset', readonly=True)
+    can_approve = fields.Boolean(string='Can Approve', compute='_compute_can_approve', readonly=True)
+
+    # Legacy sheet field, allow grouping of expenses to keep the grouping mechanic data and allow it to be re-used when re-implemented
+    former_sheet_id = fields.Integer(string='Former Report')
+
+    # --------------------------------------------
+    # Constraints
+    # --------------------------------------------
+
+    @api.constrains('state', 'approval_state', 'total_amount', 'total_amount_currency')
+    def _check_non_zero(self):
+        """ Helper to raise when we should ensure that an expense isn't approved  """
+        for expense in self:
+            total_amount_is_zero = expense.company_currency_id.is_zero(expense.total_amount)
+            total_amount_currency_is_zero = expense.currency_id.is_zero(expense.total_amount_currency)
+            if (expense.state != 'draft' or expense.approval_state != False) and (total_amount_is_zero or total_amount_currency_is_zero):
+                raise ValidationError(_("Only draft expenses can have a total of 0."))
+
+    @api.constrains('account_move_id')
+    def _check_o2o_payment(self):
+        for expense in self:
+            if len(expense.account_move_id.origin_payment_id.expense_ids) > 1:
+                raise ValidationError(_("Only one expense can be linked to a particular payment"))
+
+    # --------------------------------------------
+    # Compute methods
+    # --------------------------------------------
 
     @api.depends('product_has_cost')
     def _compute_currency_id(self):
         for expense in self:
-            if expense.product_has_cost and expense.state in {'draft', 'reported'}:
+            if expense.product_has_cost and expense.state == 'draft':
                 expense.currency_id = expense.company_currency_id
 
-    @api.depends('sheet_id.is_editable')
+    @api.depends_context('uid')
+    @api.depends('employee_id', 'manager_id', 'state')
     def _compute_is_editable(self):
+        is_hr_admin = (
+            self.env.user.has_group('hr_expense.group_hr_expense_manager')
+            or self.env.su
+        )
+        is_team_approver = self.env.user.has_group('hr_expense.group_hr_expense_team_approver')
+        is_all_approver = self.env.user.has_group('hr_expense.group_hr_expense_user')
+
+        expenses_employee_ids_under_user_ones = set()
+        if is_team_approver:
+            expenses_employee_ids_under_user_ones = set(
+                self.env['hr.employee'].sudo().search(
+                    [
+                        ('id', 'in', self.employee_id.ids),
+                        ('id', 'child_of', self.env.user.employee_ids.ids),
+                        ('id', 'not in', self.env.user.employee_ids.ids),
+                    ]
+                ).ids
+            )
         for expense in self:
-            if expense.sheet_id:
-                expense.is_editable = expense.sheet_id.is_editable
-            else:
+            if not expense.company_id:
+                # This would be happening when emptying the required company_id field, triggering the "onchange"s.
+                # This would lead to fields being set as editable, instead of using the env company,
+                # recomputing the interface just to be blocked when trying to save we choose not to recompute anything
+                # and wait for a proper company to be inputted.
+                continue
+            if expense.state not in {'draft', 'submitted', 'approved'} and not self.env.su:
+                # Not editable
+                expense.is_editable = False
+                continue
+
+            if is_hr_admin:
+                # Administrator-level users are not restricted, they can edit their own expenses
+                expense.is_editable = True
+                continue
+
+            employee = expense.employee_id
+            is_own_expense = employee.user_id == self.env.user
+            if is_own_expense and expense.state == 'draft':
+                # Anyone can edit their own draft expense
+                expense.is_editable = True
+                continue
+
+            managers = (
+                expense.manager_id
+                | employee.expense_manager_id
+                | employee.department_id.manager_id.user_id
+            )
+            if is_all_approver:
+                managers |= self.env.user
+            if expense.employee_id.id in expenses_employee_ids_under_user_ones:
+                    managers |= self.env.user
+            if not is_own_expense and self.env.user in managers:
+                # If Approver-level or designated manager, can edit other people expense
                 expense.is_editable = True
+                continue
+            expense.is_editable = False
 
     @api.onchange('product_has_cost')
     def _onchange_product_has_cost(self):
         """ Reset quantity to 1, in case of 0-cost product. To make sure switching non-0-cost to 0-cost doesn't keep the quantity."""
-        if not self.product_has_cost and self.state in {'draft', 'reported'}:
+        if not self.product_has_cost and self.state == 'draft':
             self.quantity = 1
 
     @api.depends_context('lang')
@@ -234,9 +380,10 @@ class HrExpense(models.Model):
 
     def _set_expense_currency_rate(self, date_today):
         for expense in self:
+            company_currency = expense.company_currency_id or self.env.company.currency_id
             expense.currency_rate = expense.env['res.currency']._get_conversion_rate(
-                from_currency=expense.currency_id,
-                to_currency=expense.company_currency_id,
+                from_currency=expense.currency_id or company_currency,
+                to_currency=company_currency,
                 company=expense.company_id,
                 date=expense.date or date_today,
             )
@@ -267,17 +414,20 @@ class HrExpense(models.Model):
                 expense.label_currency_rate = False
                 continue
 
+            company_currency = expense.company_currency_id or expense.env.company.currency_id
             expense.label_currency_rate = _(
                 '1 %(exp_cur)s = %(rate)s %(comp_cur)s',
-                exp_cur=expense.currency_id.name,
+                exp_cur=(expense.currency_id or company_currency).name,
                 rate=float_repr(expense.currency_rate, 6),
-                comp_cur=expense.company_currency_id.name,
+                comp_cur=company_currency.name,
             )
 
     @api.depends('currency_id', 'company_currency_id')
     def _compute_is_multiple_currency(self):
         for expense in self:
-            expense.is_multiple_currency = expense.currency_id != expense.company_currency_id
+            expense_currency = expense.currency_id or expense.company_currency_id or expense.env.company.currency_id
+            expense_company_currency = expense.company_currency_id or expense.env.company.currency_id
+            expense.is_multiple_currency = expense_currency != expense_company_currency
 
     @api.depends('product_id')
     def _compute_from_product(self):
@@ -290,21 +440,47 @@ class HrExpense(models.Model):
         for expense in self:
             expense.product_uom_id = expense.product_id.uom_id
 
-    @api.depends('sheet_id', 'sheet_id.account_move_ids', 'sheet_id.state')
+    @api.depends('amount_residual', 'account_move_id.state', 'account_move_id.payment_state', 'approval_state')
     def _compute_state(self):
+        """
+        Compute the states of the expense as such (priority is given to the last matching state of the list):
+            - draft: By default
+            - submitted: When the approval_state is 'submitted'
+            - approved: When the approval_state is 'approved'
+            - refused: When the approval_state is 'refused'
+            - paid: When it is a company paid expense or the move state is neither 'draft' nor 'posted'
+            - in_payment (or paid): When the move state is 'posted' and it's 'payment_state' is 'in_payment' or 'paid'
+                                    or ('partial' and there is a residual amount)
+            - posted: When the linked move state is 'draft', or if it is 'posted' and it's 'payment_state' is 'not_paid'
+        """
         for expense in self:
-            if not expense.sheet_id:
-                expense.state = 'draft'
-            elif expense.sheet_id.state == 'draft':
-                expense.state = 'reported'
-            elif expense.sheet_id.state == 'cancel':
-                expense.state = 'refused'
-            elif expense.sheet_id.state in {'approve', 'post'}:
-                expense.state = 'approved'
-            elif not expense.sheet_id.account_move_ids:
-                expense.state = 'submitted'
-            else:
-                expense.state = 'done'
+            move = expense.account_move_id
+            if move.state == 'cancel':
+                expense.state = 'paid'
+                continue
+            if move:
+                if expense.payment_mode == 'company_account':
+                    # Shortcut to paid, as it's already paid, but we may not have the bank statement yet
+                    expense.state = 'paid'
+                elif move.state == 'draft':
+                    expense.state = 'posted'
+                elif move.payment_state == 'not_paid':
+                    expense.state = 'posted'
+                elif (
+                        move.payment_state == 'in_payment'
+                        or (move.payment_state == 'partial' and not expense.company_currency_id.is_zero(expense.amount_residual))
+                ):
+                    expense.state = self.env['account.move']._get_invoice_in_payment_state()
+                else:  # Partial, reversed or in_payment
+                    expense.state = 'paid'
+                continue
+            expense.state = expense.approval_state or 'draft'
+
+    @api.depends('employee_id', 'employee_id.department_id')
+    def _compute_from_employee_id(self):
+        for expense in self:
+            expense.department_id = expense.employee_id.department_id
+            expense.manager_id = expense._get_default_responsible_for_approval()
 
     @api.depends('quantity', 'price_unit', 'tax_ids')
     def _compute_total_amount_currency(self):
@@ -336,6 +512,13 @@ class HrExpense(models.Model):
     def _compute_total_amount(self):
         AccountTax = self.env['account.tax']
         for expense in self:
+            if not expense.company_id:
+                # This would be happening when emptying the required company_id field, triggering the "onchange"s.
+                # A traceback would occur because company_currency_id would be set to False.
+                # Instead of using the env company, recomputing the interface just to be blocked when trying to save
+                # we choose not to recompute anything and wait for a proper company to be inputted.
+                continue
+
             if expense.is_multiple_currency:
                 base_line = expense._prepare_base_line_for_taxes_computation(
                     price_unit=expense.total_amount_currency * expense.currency_rate,
@@ -363,15 +546,17 @@ class HrExpense(models.Model):
                 AccountTax._round_base_lines_tax_details([base_line], expense.company_id)
                 tax_details = base_line['tax_details']
                 expense.tax_amount = tax_details['total_included_currency'] - tax_details['total_excluded_currency']
+                expense.untaxed_amount =  tax_details['total_excluded_currency']
             else:
                 expense.total_amount_currency = expense.total_amount
                 expense.tax_amount = expense.tax_amount_currency
+                expense.untaxed_amount = expense.untaxed_amount_currency
             expense.currency_rate = expense.total_amount / expense.total_amount_currency if expense.total_amount_currency else 1.0
             expense.price_unit = expense.total_amount / expense.quantity if expense.quantity else expense.total_amount
 
     @api.depends('product_id', 'company_id')
     def _compute_tax_ids(self):
-        for _expense in self:
+        for _expense in self.filtered('company_id'):   # Avoid a traceback, the field is required anyway
             expense = _expense.with_company(_expense.company_id)
             # taxes only from the same company
             expense.tax_ids = expense.product_id.supplier_taxes_id.filtered_domain(self.env['account.tax']._check_company_domain(expense.company_id))
@@ -384,6 +569,13 @@ class HrExpense(models.Model):
         """
         AccountTax = self.env['account.tax']
         for expense in self:
+            if not expense.company_id:
+                # This would be happening when emptying the required company_id field, triggering the "onchange"s.
+                # A traceback would occur because company_currency_id would be set to False.
+                # Instead of using the env company, recomputing the interface just to be blocked when trying to save
+                # we choose not to recompute anything and wait for a proper company to be inputted.
+                continue
+
             base_line = expense._prepare_base_line_for_taxes_computation(
                 price_unit=expense.total_amount_currency,
                 quantity=1.0,
@@ -397,11 +589,18 @@ class HrExpense(models.Model):
     @api.depends('total_amount', 'currency_rate', 'tax_ids', 'is_multiple_currency')
     def _compute_tax_amount(self):
         """
-             Note: as total_amount can be set directly by the user when the currency_rate is overriden,
+             Note: as total_amount can be set directly by the user when the currency_rate is overridden,
              the tax must be computed after the total_amount.
         """
         AccountTax = self.env['account.tax']
         for expense in self:
+            if not expense.company_id:
+                # This would be happening when emptying the required company_id field, triggering the "onchange"s.
+                # A traceback would occur because company_currency_id would be set to False.
+                # Instead of using the env company, recomputing the interface just to be blocked when trying to save
+                # we choose not to recompute anything and wait for a proper company to be inputted.
+                continue
+
             if expense.is_multiple_currency:
                 base_line = expense._prepare_base_line_for_taxes_computation(
                     price_unit=expense.total_amount,
@@ -412,8 +611,10 @@ class HrExpense(models.Model):
                 AccountTax._round_base_lines_tax_details([base_line], expense.company_id)
                 tax_details = base_line['tax_details']
                 expense.tax_amount = tax_details['total_included_currency'] - tax_details['total_excluded_currency']
+                expense.untaxed_amount = tax_details['total_excluded_currency']
             else:  # Mono-currency case computation shortcut
                 expense.tax_amount = expense.tax_amount_currency
+                expense.untaxed_amount = expense.untaxed_amount_currency
 
     @api.depends('total_amount', 'total_amount_currency')
     def _compute_price_unit(self):
@@ -423,8 +624,16 @@ class HrExpense(models.Model):
            when edited after creation.
         """
         for expense in self:
-            if expense.state not in {'draft', 'reported'}:
+            if expense.state != 'draft':
+                continue
+
+            if not expense.company_id:
+                # This would be happening when emptying the required company_id field, triggering the "onchange"s.
+                # A traceback would occur because company_currency_id would be set to False.
+                # Instead of using the env company, recomputing the interface just to be blocked when trying to save
+                # we choose not to recompute anything and wait for a proper company to be inputted.
                 continue
+
             product_id = expense.product_id
             if expense._needs_product_price_computation():
                 expense.price_unit = product_id._price_compute(
@@ -435,10 +644,23 @@ class HrExpense(models.Model):
             else:
                 expense.price_unit = expense.company_currency_id.round(expense.total_amount / expense.quantity) if expense.quantity else 0.
 
-    def _needs_product_price_computation(self):
-        # Hook to be overridden.
-        self.ensure_one()
-        return self.product_has_cost
+    @api.depends('selectable_payment_method_line_ids')
+    def _compute_payment_method_line_id(self):
+        for expense in self:
+            expense.payment_method_line_id = expense.selectable_payment_method_line_ids[:1]
+
+    @api.depends('company_id')
+    def _compute_selectable_payment_method_line_ids(self):
+        for expense in self:
+            allowed_method_line_ids = expense.company_id.company_expense_allowed_payment_method_line_ids
+            if allowed_method_line_ids:
+                expense.selectable_payment_method_line_ids = allowed_method_line_ids
+            else:
+                expense.selectable_payment_method_line_ids = self.env['account.payment.method.line'].search([
+                    # The journal is the source of the payment method line company
+                    *self.env['account.journal']._check_company_domain(expense.company_id),
+                    ('payment_type', '=', 'outbound'),
+                ])
 
     @api.depends('product_id', 'company_id')
     def _compute_account_id(self):
@@ -529,162 +751,198 @@ class HrExpense(models.Model):
         for expense in self:
             expense.nb_attachment = attachment.get(expense._origin.id, 0)
 
-    @api.constrains('payment_mode')
-    def _check_payment_mode(self):
-        self.sheet_id._check_payment_mode()
-
-    def _prepare_base_line_for_taxes_computation(self, **kwargs):
-        self.ensure_one()
-        return self.env['account.tax']._prepare_base_line_for_taxes_computation(
-            self,
-            **{
-                'partner_id': self.vendor_id,
-                'special_mode': 'total_included',
-                'rate': self.currency_rate,
-                **kwargs,
-            },
-        )
-
-    def attach_document(self, **kwargs):
-        """When an attachment is uploaded as a receipt, set it as the main attachment."""
-        self._message_set_main_attachment_id(self.env["ir.attachment"].browse(kwargs['attachment_ids'][-1:]), force=True)
-
-    @api.model
-    def create_expense_from_attachments(self, attachment_ids=None, view_type='list'):
-        """
-            Create the expenses from files.
-
-            :return: An action redirecting to hr.expense list view.
-        """
-        if not attachment_ids:
-            raise UserError(_("No attachment was provided"))
-        attachments = self.env['ir.attachment'].browse(attachment_ids)
-        expenses = self.env['hr.expense']
-
-        if any(attachment.res_id or attachment.res_model != 'hr.expense' for attachment in attachments):
-            raise UserError(_("Invalid attachments!"))
-
-        product = self.env['product.product'].search([('can_be_expensed', '=', True)])
-        if product:
-            product = product.filtered(lambda p: p.default_code == "EXP_GEN")[:1] or product[0]
-        else:
-            raise UserError(_("You need to have at least one category that can be expensed in your database to proceed!"))
+    @api.depends_context('uid')
+    @api.depends('employee_id', 'state')
+    def _compute_can_reset(self):
+        user = self.env.user
+        is_team_approver = user.has_group('hr_expense.group_hr_expense_team_approver') or self.env.su
+        is_all_approver = user.has_groups('hr_expense.group_hr_expense_user,hr_expense.group_hr_expense_manager') or self.env.su
+
+        valid_company_ids = set(self.env.companies.ids)
+        expenses_employee_ids_under_user_ones = set()
+        if is_team_approver:  # We don't need to search if the user has not the required rights
+            expenses_employee_ids_under_user_ones = set(self.env['hr.employee'].sudo().search([
+                ('id', 'in', self.employee_id.ids),
+                ('id', 'child_of', user.employee_ids.ids),
+                ('id', 'not in', user.employee_ids.ids),
+            ]).ids)
 
-        for attachment in attachments:
-            attachment_name = '.'.join(attachment.name.split('.')[:-1])
-            vals = {
-                'name': attachment_name,
-                'price_unit': 0,
-                'product_id': product.id,
-            }
-            if product.property_account_expense_id:
-                vals['account_id'] = product.property_account_expense_id.id
-            expense = self.env['hr.expense'].create(vals)
-            attachment.write({'res_model': 'hr.expense', 'res_id': expense.id})
+        for expense in self:
+            expense.can_reset = (
+                expense.company_id.id in valid_company_ids
+                and (
+                        is_all_approver
+                        or expense.employee_id.id in expenses_employee_ids_under_user_ones
+                        or expense.employee_id.expense_manager_id == user
+                        or (expense.state in {'draft', 'submitted'} and expense.employee_id.user_id == user)
+                )
+            )
 
-            expense._message_set_main_attachment_id(attachment, force=True)
-            expenses += expense
-        return {
-            'name': _('Generate Expenses'),
-            'res_model': 'hr.expense',
-            'type': 'ir.actions.act_window',
-            'views': [[False, view_type], [False, "form"]],
-            'domain': [('id', 'in', expenses.ids)],
-            'context': self.env.context,
-        }
+    @api.depends_context('uid')
+    @api.depends('employee_id')
+    def _compute_can_approve(self):
+        cannot_reason_per_record_id = self._get_cannot_approve_reason()
+        for expense in self:
+            expense.can_approve = not cannot_reason_per_record_id[expense.id]
 
     # ----------------------------------------
     # ORM Overrides
     # ----------------------------------------
 
     @api.ondelete(at_uninstall=False)
-    def _unlink_except_posted_or_approved(self):
+    def _unlink_except_approved(self):
         for expense in self:
-            if expense.state in {'done', 'approved'}:
+            if expense.state in {'approved', 'posted', 'in_payment', 'paid'}:
                 raise UserError(_('You cannot delete a posted or approved expense.'))
 
     def write(self, vals):
-        expense_to_previous_sheet = {}
-        if 'sheet_id' in vals:
-            # Check access rights on the sheet
-            self.env['hr.expense.sheet'].browse(vals['sheet_id']).check_access('write')
-
-            # Store the previous sheet of the expenses to unlink the attachments later if needed
-            for expense in self:
-                expense_to_previous_sheet[expense] = expense.sheet_id
+        if any(field in vals for field in {'is_editable', 'can_approve', 'can_refuse'}):
+            raise UserError(_("You cannot edit the security fields of an expense manually"))
 
-            # If the sheet_id is modified, we need to check that the expenses are not set to 0,
-            # unless it's to unlink the sheet
-            enforced_non_zero_expenses = self.env['hr.expense']
-            if vals.get('sheet_id'):  # If sheet is linked, we need to check all the newly linked expenses in self
-                enforced_non_zero_expenses = self
-        else:  # If sheet_id is not modified, we need to check all the expenses in self linked to a sheet
-            enforced_non_zero_expenses = self.filtered('sheet_id')
-
-        if 'tax_ids' in vals or 'analytic_distribution' in vals or 'account_id' in vals:
+        if any(field in vals for field in {'tax_ids', 'analytic_distribution', 'account_id', 'manager_id'}):
             if any(not expense.is_editable for expense in self):
-                raise UserError(_('You are not authorized to edit this expense report.'))
-
-        if enforced_non_zero_expenses:
-            enforced_non_zero_expenses.check_amount_not_zero(vals)
+                raise UserError(_('You are not authorized to edit this expense.'))
 
         res = super().write(vals)
 
+        if vals.get('state') == 'approved' or vals.get('approval_state') == 'approved':
+            self._check_can_approve()
+        elif vals.get('state') == 'refused' or vals.get('approval_state') == 'refused':
+            self._check_can_refuse()
+
         if 'currency_id' in vals:
             self._set_expense_currency_rate(date_today=fields.Date.context_today(self))
             for expense in self:
                 expense.total_amount = expense.total_amount_currency * expense.currency_rate
-
-        if 'employee_id' in vals:
-            # In case expense has sheet which has only one expense_line_ids,
-            # then changing the expense.employee_id triggers changing the sheet.employee_id too.
-            # Otherwise we unlink the expense line from sheet, (so that the user can create a new report).
-            if self.sheet_id:
-                employees = self.sheet_id.expense_line_ids.mapped('employee_id')
-                if len(employees) == 1:
-                    self.sheet_id.write({'employee_id': vals['employee_id']})
-                elif len(employees) > 1:
-                    self.sheet_id = False
-        if 'sheet_id' in vals:
-            # The sheet_id has been modified, either by an explicit write on sheet_id of the expense,
-            # or by processing a command on the sheet's expense_line_ids.
-            # We need to delete the attachments on the previous sheet coming from the expenses that were modified,
-            # and copy the attachments of the expenses to the new sheet,
-            # if it's a no-op (writing same sheet_id as the current sheet_id of the expense),
-            # nothing should be done (no unlink then copy of the same attachments)
-            attachments_to_unlink = self.env['ir.attachment']
-            for expense in self:
-                previous_sheet = expense_to_previous_sheet[expense]
-                checksums = set((expense.attachment_ids - previous_sheet.expense_line_ids.attachment_ids).mapped('checksum'))
-                attachments_to_unlink += previous_sheet.attachment_ids.filtered(lambda att: att.checksum in checksums)
-                if vals['sheet_id'] and expense.sheet_id != previous_sheet:
-                    for attachment in expense.attachment_ids.with_context(sync_attachment=False):
-                        attachment.copy({
-                            'res_model': 'hr.expense.sheet',
-                            'res_id': vals['sheet_id'],
-                        })
-            attachments_to_unlink.with_context(sync_attachment=False).unlink()
         return res
 
     @api.model_create_multi
     def create(self, vals_list):
         expenses = super().create(vals_list)
-        if self.env.context.get('check_total_amount_not_zero'):
-            for expense, vals in zip(expenses, vals_list):
-                expense.check_amount_not_zero(vals)
+        expenses.update_activities_and_mails()
         return expenses
 
-    def unlink(self):
-        attachments_to_unlink = self.env['ir.attachment']
-        for sheet in self.sheet_id:
-            checksums = set((sheet.expense_line_ids.attachment_ids & self.attachment_ids).mapped('checksum'))
-            attachments_to_unlink += sheet.attachment_ids.filtered(lambda att: att.checksum in checksums)
-        attachments_to_unlink.with_context(sync_attachment=False).unlink()
-        return super().unlink()
+    # --------------------------------------------
+    # Mail Thread
+    # --------------------------------------------
+
+    def _message_auto_subscribe_followers(self, updated_values, subtype_ids):
+        res = super()._message_auto_subscribe_followers(updated_values, subtype_ids)
+        if updated_values.get('employee_id'):
+            employee_user = self.env['hr.employee'].browse(updated_values['employee_id']).user_id
+            if employee_user:
+                res.append((employee_user.partner_id.id, subtype_ids, False))
+        return res
 
     @api.model
-    def get_empty_list_help(self, help_message):
-        return super().get_empty_list_help((help_message or '') + self._get_empty_list_mail_alias())
+    def _get_employee_from_email(self, email_address):
+        if not email_address:
+            return self.env['hr.employee']
+        employee = self.env['hr.employee'].search([
+            ('user_id', '!=', False), '|', ('work_email', 'ilike', email_address), ('user_id.email', 'ilike', email_address),
+        ])
+
+        if len(employee) > 1:
+            # Several employees can be linked to the same user.
+            # In that case, we only keep the employee that matched the user's company.
+            return employee.filtered(lambda e: e.company_id == e.user_id.company_id)
+
+        if not employee:
+            # An employee does not always have a user.
+            return self.env['hr.employee'].search([
+                ('user_id', '=', False),
+                ('work_email', 'ilike', email_address),
+            ], limit=1)
+
+        return employee
+
+    @api.model
+    def _parse_product(self, expense_description):
+        """
+            Parse the subject to find the product.
+            Product code should be the first word of expense_description
+            Return product.product and updated description
+        """
+        product_code = expense_description.split(' ')[0]
+        product = self.env['product.product'].search([('can_be_expensed', '=', True), ('default_code', '=ilike', product_code)], limit=1)
+        if product:
+            expense_description = expense_description.replace(product_code, '', 1)
+
+        return product, expense_description
+
+    @api.model
+    def _parse_price(self, expense_description, currencies):
+        """ Return price, currency and updated description """
+        symbols, symbols_pattern, float_pattern = [], '', r'[+-]?(\d+[.,]?\d*)'
+        price = 0.0
+        for currency in currencies:
+            symbols += [re.escape(currency.symbol), re.escape(currency.name)]
+        symbols_pattern = '|'.join(symbols)
+        price_pattern = f'(({symbols_pattern})?\\s?{float_pattern}\\s?({symbols_pattern})?)'
+        matches = re.findall(price_pattern, expense_description)
+        currency = currencies[:1]
+        if matches:
+            match = max(matches, key=lambda match: len([group for group in match if group]))
+            # get the longest match. e.g. "2 chairs 120$" -> the price is 120$, not 2
+            full_str = match[0]
+            currency_str = match[1] or match[3]
+            price = match[2].replace(',', '.')
+
+            if currency_str and currencies:
+                currencies = currencies.filtered(lambda c: currency_str in [c.symbol, c.name])
+                currency = currencies[:1] or currency
+            expense_description = expense_description.replace(full_str, ' ')  # remove price from description
+            expense_description = re.sub(' +', ' ', expense_description.strip())
+
+        return float(price), currency, expense_description
+
+    @api.model
+    def _parse_expense_subject(self, expense_description, currencies):
+        """
+            Fetch product, price and currency info from mail subject.
+
+            Product can be identified based on product name or product code.
+            It can be passed between [] or it can be placed at start.
+
+            When parsing, only consider currencies passed as parameter.
+            This will fetch currency in symbol($) or ISO name (USD).
+
+            Some valid examples:
+                Travel by Air [TICKET] USD 1205.91
+                TICKET $1205.91 Travel by Air
+                Extra expenses 29.10EUR [EXTRA]
+        """
+        product, expense_description = self._parse_product(expense_description)
+        price, currency_id, expense_description = self._parse_price(expense_description, currencies)
+
+        return product, price, currency_id, expense_description
+
+    def _send_expense_success_mail(self, msg_dict, expense):
+        """ Send a confirmation mail to the employee that an expense has been created by their previous mail """
+        if expense.employee_id.user_id:
+            mail_template_id = 'hr_expense.hr_expense_template_register'
+        else:
+            mail_template_id = 'hr_expense.hr_expense_template_register_no_user'
+        rendered_body = self.env['ir.qweb']._render(mail_template_id, {'expense': expense})
+        body = self.env['mail.render.mixin']._replace_local_links(rendered_body)
+        if expense.employee_id.user_id.partner_id:
+            expense.message_post(
+                body=body,
+                email_layout_xmlid='mail.mail_notification_light',
+                partner_ids=expense.employee_id.user_id.partner_id.ids,
+                subject=f'Re: {msg_dict.get("subject", "")}',
+                subtype_xmlid='mail.mt_note',
+            )
+        else:
+            self.env['mail.mail'].sudo().create({
+                'author_id': self.env.user.partner_id.id,
+                'auto_delete': True,
+                'body_html': body,
+                'email_from': self.env.user.email_formatted,
+                'email_to': msg_dict.get('email_from', False),
+                'references': msg_dict.get('message_id'),
+                'subject': f'Re: {msg_dict.get("subject", "")}',
+            }).send()
 
     @api.model
     def _get_empty_list_mail_alias(self):
@@ -702,117 +960,305 @@ class HrExpense(models.Model):
             }
         return ""
 
-    def get_expense_attachments(self):
-        return self.attachment_ids.mapped('image_src')
+    def _track_subtype(self, init_values):
+        self.ensure_one()
+        if 'state' not in init_values:
+            return super()._track_subtype(init_values)
+
+        match self.state:
+            case 'draft':
+                return self.env.ref('hr_expense.mt_expense_reset')
+            case 'cancel':
+                return self.env.ref('hr_expense.mt_expense_refused')
+            case 'paid':
+                return self.env.ref('hr_expense.mt_expense_paid')
+            case 'approved':
+                if init_values['state'] in {'posted', 'in_payment', 'paid'}:  # Reverting state
+                    subtype = 'hr_expense.mt_expense_entry_draft' if self.account_move_id else 'hr_expense.mt_expense_entry_delete'
+                    return self.env.ref(subtype)
+                return self.env.ref('hr_expense.mt_expense_approved')
+            case _:
+                return super()._track_subtype(init_values)
+
+    def update_activities_and_mails(self):
+        """ Update the "Review this expense" activity with the new state of the expense, also sends mail to approver to ask them to act """
+        expenses_activity_done = self.env['hr.expense']
+        expenses_activity_unlink = self.env['hr.expense']
+        expenses_submitted_to_review = self.env['hr.expense']
+        for expense in self:
+            if expense.state == 'submitted':
+                expense.activity_schedule(
+                    'hr_expense.mail_act_expense_approval',
+                    user_id=expense.sudo()._get_default_responsible_for_approval().id or self.env.user.id)
+                expenses_submitted_to_review |= expense
+            elif expense.state == 'approved':
+                expenses_activity_done |= expense
+            elif expense.state in {'draft', 'refused'}:
+                expenses_activity_unlink |= expense
+
+        # Batched actions
+        if expenses_activity_done:
+            expenses_activity_done.activity_feedback(['hr_expense.mail_act_expense_approval'])
+        if expenses_activity_unlink:
+            expenses_activity_unlink.activity_unlink(['hr_expense.mail_act_expense_approval'])
+        # Avoid sending yourself mails
+        expenses_submitted_to_review = expenses_submitted_to_review.filtered(lambda expense: expense.manager_id != self.env.user)
+        if expenses_submitted_to_review:
+            new_mails = []
+            for company, expenses_submitted_per_company in expenses_submitted_to_review.grouped('company_id').items():
+                parent_company_mails = company.parent_ids[::-1].mapped('email_formatted')
+                mail_from = (
+                        self.env.user.email
+                        or company.email_formatted
+                        or (parent_company_mails and parent_company_mails[0])
+                )
+
+                if not mail_from:  # We can't send a mail without sender
+                    _logger.warning(_("Failed to send mails for submitted expenses. No valid email was found for the company"))
+                    continue
+
+                for manager, expenses_submitted in expenses_submitted_per_company.grouped('manager_id').items():
+                    manager_langs = tuple(lang for lang in manager.partner_id.mapped('lang') if lang)
+                    mail_lang = (manager_langs and manager_langs[0]) or self.env.lang or 'en_US'
+                    body = self.env['ir.qweb']._render(
+                        template='hr_expense.hr_expense_template_submitted_expenses',
+                        values={'manager_name': manager.name, 'url': '/expenses-to-approve'},
+                        lang=mail_lang,
+                    )
+                    new_mails.append({
+                        'author_id': self.env.user.partner_id.id,
+                        'auto_delete': True,
+                        'body_html': body,
+                        'email_from': mail_from,
+                        'email_to': manager.employee_id.work_email or manager.email,
+                        'subject': _("New expenses waiting for your approval"),
+                    })
+                if new_mails:
+                    self.env['mail.mail'].sudo().create(new_mails).send()
+
+    @api.model
+    def get_empty_list_help(self, help_message):
+        return super().get_empty_list_help((help_message or '') + self._get_empty_list_mail_alias())
+
+    @api.model
+    def message_new(self, msg_dict, custom_values=None):
+        email_address = email_normalize(msg_dict.get('email_from'))
+        employee = self._get_employee_from_email(email_address)
+
+        if not employee:
+            return super().message_new(msg_dict, custom_values=custom_values)
+
+        expense_description = msg_dict.get('subject', '')
+
+        if employee.user_id:
+            company = employee.user_id.company_id
+            currencies = company.currency_id | employee.user_id.company_ids.mapped('currency_id')
+        else:
+            company = employee.company_id
+            currencies = company.currency_id
+
+        if not company:  # ultimate fallback, since company_id is required on expense
+            company = self.env.company
 
-    def check_amount_not_zero(self, vals):
-        error_msgs = []
-        if 'total_amount' in vals:
-            if any(expense.company_currency_id.is_zero(vals['total_amount']) for expense in self):
-                error_msgs.append(_("You cannot set the expense total to 0 if it's linked to a report."))
-        if 'total_amount_currency' in vals:
-            if any(expense.currency_id.is_zero(vals['total_amount_currency']) for expense in self):
-                error_msgs.append(_("You cannot set the expense total in currency to 0 if it's linked to a report."))
-        if error_msgs:
-            raise UserError("\n".join(error_msgs))
+        # The expenses alias is the same for all companies, we need to set the proper context
+        # To select the product account
+        self = self.with_company(company)
+
+        product, price, currency_id, expense_description = self._parse_expense_subject(expense_description, currencies)
+        vals = {
+            'employee_id': employee.id,
+            'name': expense_description,
+            'total_amount_currency': price,
+            'product_id': product.id if product else None,
+            'product_uom_id': product.uom_id.id,
+            'tax_ids': [Command.set(product.supplier_taxes_id.filtered(lambda r: r.company_id == company).ids)],
+            'quantity': 1,
+            'company_id': company.id,
+            'currency_id': currency_id.id
+        }
+
+        account = product.product_tmpl_id._get_product_accounts()['expense']
+        if account:
+            vals['account_id'] = account.id
+
+        expense = super().message_new(msg_dict, dict(custom_values or {}, **vals))
+        self._send_expense_success_mail(msg_dict, expense)
+        return expense
 
     # ----------------------------------------
     # Actions
     # ----------------------------------------
 
-    def action_show_same_receipt_expense_ids(self):
-        self.ensure_one()
-        return self.same_receipt_expense_ids._get_records_action(
-            name=_("Expenses with a similar receipt to %(other_expense_name)s", other_expense_name=self.name),
+    def action_submit(self):
+        """ Submit a draft expense to an approve, may skip to the approval step if no approver on the employee nor the expense """
+        user = self.env.user
+        for expense in self:
+            if user.employee_id != expense.employee_id and not expense.can_approve:
+                raise UserError(_("You do not have the required permission to submit this expense."))
+            if not expense.product_id:
+                raise UserError(_("You can not submit an expense without a category."))
+            if not expense.manager_id:
+                expense.manager_id = expense._get_default_responsible_for_approval()
+        expenses_autovalidated = self.filtered(lambda expense: not expense.manager_id and not expense.employee_id.expense_manager_id)
+        (self - expenses_autovalidated).approval_state = 'submitted'
+        if expenses_autovalidated:  # Note, this will and should bypass the duplicate check. May be changed later
+            expenses_autovalidated._do_approve(check=False)
+        self.sudo().update_activities_and_mails()
+
+    def action_approve(self):
+        """ Approve an expense, pops a wizard if a duplicated expense is found to confirm they are all valid expenses """
+        self._check_can_approve()
+        for expense in self:
+            expense._validate_distribution(
+                account=expense.account_id.id,
+                product=expense.product_id.id,
+                business_domain='expense',
+                company_id=expense.company_id.id,
+            )
+
+        duplicates = self.duplicate_expense_ids.filtered(lambda exp: exp.state in {'submitted', 'approved', 'posted', 'paid', 'in_payment'})
+        if duplicates:
+            action = self.env["ir.actions.act_window"]._for_xml_id('hr_expense.hr_expense_approve_duplicate_action')
+            action['context'] = {'default_expense_ids': duplicates.ids}
+            return action
+        self._do_approve(False)
+
+    def action_refuse(self):
+        """ Refuse an expense with a reason """
+        self._check_can_refuse()
+        return self.env["ir.actions.act_window"]._for_xml_id('hr_expense.hr_expense_refuse_wizard_action')
+
+    def action_post(self):
+        """
+        Post the expense, following one of those two options:
+            - Company-paid expenses: Create and post a payment, with an accounting entry
+            - Employee-paid expenses: Through a wizard, create and post a bill
+        """
+        # When a move has been deleted
+        self._check_can_create_move()
+
+        company_expenses = self.filtered(lambda expense: expense.payment_mode == 'company_account')
+        employee_expenses = self - company_expenses
+        if len(employee_expenses.company_id) > 1:
+            raise UserError(_("You can't post simultaneously employee-paid expenses belonging to different companies"))
+
+        if company_expenses:
+            company_expenses._create_company_paid_moves()
+            # Post the company-paid expense through the payment, to post both at the same time
+            company_expenses.account_move_id.origin_payment_id.action_post()
+
+        if employee_expenses:
+            return employee_expenses.with_context(company_paid_move_ids=company_expenses.account_move_id.ids)._post_wizard()
+
+    def action_pay(self):
+        """ Register payment shortcut on the expense form view """
+        return self.account_move_id.with_context(default_partner_bank_id=(
+            self.account_move_id.partner_bank_id.id if len(self.account_move_id.partner_bank_id) <= 1 else None
+        )).action_register_payment()
+
+    def action_reset(self):
+        """  Reset an expense to draft state, reversing the accounting entries if needed """
+        self._check_can_reset_approval()
+        self = self.with_context(clean_context(self.env.context))
+        moves_sudo = self.sudo().account_move_id
+        draft_moves_sudo = moves_sudo.filtered(lambda m: m.state == 'draft')
+        non_draft_moves_sudo = moves_sudo - draft_moves_sudo
+        non_draft_moves_sudo._reverse_moves(
+            default_values_list=[{'invoice_date': fields.Date.context_today(move_sudo)} for move_sudo in non_draft_moves_sudo],
+            cancel=True
         )
+        draft_moves_sudo.unlink()
+        self._do_reset_approval()
 
-    def action_view_sheet(self):
-        self.ensure_one()
-        return {
-            'type': 'ir.actions.act_window',
-            'view_mode': 'form',
-            'views': [[False, "form"]],
-            'res_model': 'hr.expense.sheet',
-            'target': 'current',
-            'res_id': self.sheet_id.id
-        }
+    def attach_document(self, **kwargs):
+        """When an attachment is uploaded as a receipt, set it as the main attachment."""
+        self._message_set_main_attachment_id(self.env["ir.attachment"].browse(kwargs['attachment_ids'][-1:]), force=True)
 
-    def _get_default_expense_sheet_values(self):
-        # If there is an expense with total_amount == 0, it means that expense has not been processed by OCR yet
-        expenses_with_amount = self.filtered(lambda expense: not (
-            expense.currency_id.is_zero(expense.total_amount_currency)
-            or expense.company_currency_id.is_zero(expense.total_amount)
-            or (expense.product_id and not float_round(expense.quantity, precision_rounding=expense.product_uom_id.rounding))
-        ))
+    @api.model
+    def create_expense_from_attachments(self, attachment_ids=None, view_type='list'):
+        """
+            Create the expenses from files.
 
-        if any(expense.state != 'draft' or expense.sheet_id for expense in expenses_with_amount):
-            raise UserError(_("You cannot report twice the same line!"))
-        if not expenses_with_amount:
-            raise UserError(_("You cannot report the expenses without amount!"))
-        if len(expenses_with_amount.mapped('employee_id')) != 1:
-            raise UserError(_("You cannot report expenses for different employees in the same report."))
-        if any(not expense.product_id for expense in expenses_with_amount):
-            raise UserError(_("You can not create report without category."))
-        if len(self.company_id) != 1:
-            raise UserError(_("You cannot report expenses for different companies in the same report."))
-
-        # Check if two reports should be created
-        own_expenses = expenses_with_amount.filtered(lambda x: x.payment_mode == 'own_account')
-        company_expenses = expenses_with_amount - own_expenses
-        create_two_reports = own_expenses and company_expenses
-
-        sheets = (own_expenses, company_expenses) if create_two_reports else (expenses_with_amount,)
-        values = []
-
-        # We use a fallback name only when several expense sheets are created,
-        # else we use the form view required name to force the user to set a name
-        for todo in sheets:
-            paid_by = 'company' if todo[0].payment_mode == 'company_account' else 'employee'
-            sheet_name = self.env['hr.expense.sheet']._get_default_sheet_name(todo)
-            if not sheet_name and len(sheets) > 1:
-                sheet_name = _("New Expense Report, paid by %(paid_by)s", paid_by=paid_by)
-            values.append({
-                'company_id': self.company_id.id,
-                'employee_id': self[0].employee_id.id,
-                'name': sheet_name,
-                'expense_line_ids': [Command.set(todo.ids)],
-                'state': 'draft',
-            })
-        return values
+            :return: An action redirecting to hr.expense list view.
+        """
+        if not attachment_ids:
+            raise UserError(_("No attachment was provided"))
+        attachments = self.env['ir.attachment'].browse(attachment_ids)
+        expenses = self.env['hr.expense']
 
-    def get_expenses_to_submit(self):
-        # if there ere no records selected, then select all draft expenses for the user
-        if self:
-            expenses = self.filtered(lambda expense: expense.state == 'draft' and not expense.sheet_id and expense.is_editable)
+        if any(attachment.res_id or attachment.res_model != 'hr.expense' for attachment in attachments):
+            raise UserError(_("Invalid attachments!"))
+
+        product = self.env['product.product'].search([('can_be_expensed', '=', True)])
+        if product:
+            product = product.filtered(lambda p: p.default_code == "EXP_GEN")[:1] or product[0]
         else:
-            expenses = self.env['hr.expense'].search([
-                ('state', '=', 'draft'),
-                ('sheet_id', '=', False),
-                ('employee_id', '=', self.env.user.employee_id.id),
-            ]).filtered(lambda expense: expense.is_editable)
-
-        if not expenses:
-            raise UserError(_('You have no expense to report'))
-        return expenses.action_submit_expenses()
-
-    def _create_sheets_from_expense(self):
-        if self.filtered(lambda expense: not expense.is_editable):
-            raise UserError(_('You are not authorized to edit this expense.'))
-        sheets = self.env['hr.expense.sheet'].create(self._get_default_expense_sheet_values())
-        return sheets
-
-    def action_submit_expenses(self):
-        sheets = self._create_sheets_from_expense()
+            raise UserError(_("You need to have at least one category that can be expensed in your database to proceed!"))
+
+        for attachment in attachments:
+            attachment_name = '.'.join(attachment.name.split('.')[:-1])
+            vals = {
+                'name': attachment_name,
+                'price_unit': 0,
+                'product_id': product.id,
+            }
+            if product.property_account_expense_id:
+                vals['account_id'] = product.property_account_expense_id.id
+            expense = self.env['hr.expense'].create(vals)
+            attachment.write({'res_model': 'hr.expense', 'res_id': expense.id})
+
+            expense._message_set_main_attachment_id(attachment, force=True)
+            expenses += expense
         return {
-            'name': _('New Expense Reports'),
+            'name': _("Generated Expense(s)"),
+            'res_model': 'hr.expense',
             'type': 'ir.actions.act_window',
-            'res_model': 'hr.expense.sheet',
+            'views': [[False, view_type], [False, "form"]],
+            'domain': [('id', 'in', expenses.ids)],
             'context': self.env.context,
-            'views': [[False, "list"], [False, "form"]] if len(sheets) > 1 else [[False, "form"]],
-            'domain': [('id', 'in', sheets.ids)],
-            'res_id': sheets.id if len(sheets) == 1 else False,
         }
 
+    def action_show_same_receipt_expense_ids(self):
+        self.ensure_one()
+        return self.same_receipt_expense_ids._get_records_action(
+            name=_("Expenses with a similar receipt to %(other_expense_name)s", other_expense_name=self.name),
+        )
+
+    @api.model
+    def get_expense_dashboard(self):
+        expense_state = {
+            'draft': {
+                'description': _("To Submit"),
+                'amount': 0.0,
+                'currency': self.env.company.currency_id.id,
+            },
+            'submitted': {
+                'description': _("Waiting Approval"),
+                'amount': 0.0,
+                'currency': self.env.company.currency_id.id,
+            },
+            'approved': {
+                'description': _("Waiting Reimbursement"),
+                'amount': 0.0,
+                'currency': self.env.company.currency_id.id,
+            }
+        }
+        if not self.env.user.employee_ids:
+            return expense_state
+        # Counting the expenses to display in the dashboard:
+        # - To Submit: contains the expenses paid either by the employee or by the company, and that are draft or reported
+        # - Waiting approval: contains expenses paid by the employee or paid by the company, and that have been submitted but still need to be approved/refused
+        # - To be reimbursed: contains ONLY expenses paid by the employee that are approved, the payment has not yet been made
+        fetched_expenses = self._read_group(
+            [
+                ('employee_id', 'in', self.env.user.employee_ids.ids),
+                '|', ('state', 'in', ('draft', 'submitted')),
+                     '&', ('payment_mode', '=', 'own_account'), ('state', '=', 'approved')
+            ], ['state'], ['total_amount:sum'])
+        for state, total_amount_sum in fetched_expenses:
+            expense_state[state]['amount'] += total_amount_sum
+        return expense_state
+
     def action_get_attachment_view(self):
         self.ensure_one()
         res = self.env['ir.actions.act_window']._for_xml_id('base.action_attachment')
@@ -830,6 +1276,173 @@ class HrExpense(models.Model):
                 author_id=root,
             )
 
+    def action_split_wizard(self):
+        self.ensure_one()
+        if self.filtered(lambda expense: expense.state in {'posted', 'paid', 'in_payment'}):
+            raise UserError(_("You cannot split an expense that is already posted."))
+        if not self.is_editable:
+            raise UserError(_("You do not have the rights to edit this expense."))
+
+        splits = self.env['hr.expense.split'].create(self._get_split_values())
+
+        wizard = self.env['hr.expense.split.wizard'].create([{
+            'expense_split_line_ids': splits.ids,
+            'expense_id': self.id,
+        }])
+        return {
+            'name': _("Expense split"),
+            'type': 'ir.actions.act_window',
+            'view_mode': 'form',
+            'views': [[False, "form"]],
+            'res_model': 'hr.expense.split.wizard',
+            'res_id': wizard.id,
+            'target': 'new',
+            'context': self.env.context,
+        }
+
+    def action_open_account_move(self):
+        self.ensure_one()
+        if self.payment_mode == 'own_account':
+            res_model = 'account.move'
+            record_id = self.account_move_id
+        else:
+            res_model = 'account.payment'
+            record_id = self.account_move_id.origin_payment_id
+
+        return {
+            'type': 'ir.actions.act_window',
+            'res_model': res_model,
+            'name': record_id.name,
+            'view_mode': 'form',
+            'res_id': record_id.id,
+            'views': [(False, 'form')],
+        }
+
+    # ----------------------------------------
+    # Business
+    # ----------------------------------------
+
+    def _check_can_approve(self):
+        if not all(self.mapped('can_approve')):
+            reasons_list = tuple(reason for reason in self._get_cannot_approve_reason().values() if reason)
+            reasons = _("You cannot approve:\n %(reasons)s", reasons="\n".join(reasons_list))
+            raise UserError(reasons)
+
+    def _get_cannot_approve_reason(self):
+        """ Returns the reason why the user cannot approve the expense """
+        is_team_approver = self.env.user.has_group('hr_expense.group_hr_expense_team_approver') or self.env.su
+        is_approver = self.env.user.has_group('hr_expense.group_hr_expense_user') or self.env.su
+        is_hr_admin = self.env.user.has_group('hr_expense.group_hr_expense_manager') or self.env.su
+
+        valid_company_ids = set(self.env.companies.ids)
+
+        expenses_employee_ids_under_user_ones = set()
+        if is_team_approver:  # We don't need to search if the user has not the required rights
+            expenses_employee_ids_under_user_ones = set(
+                self.env['hr.employee'].sudo().search([
+                    ('id', 'in', self.employee_id.ids),
+                    ('id', 'child_of', self.env.user.employee_ids.ids),
+                    ('id', 'not in', self.env.user.employee_ids.ids),
+                ]).ids
+            )
+        reasons_per_record_id = {}
+        for expense in self:
+            reason = False
+            expense_employee = expense.employee_id
+            is_expense_team_approver = (
+                    is_team_approver  # Admins are team approvers, not necessarily direct parents
+                    or expense_employee.id in expenses_employee_ids_under_user_ones
+                    or (expense_employee.expense_manager_id == self.env.user)
+            )
+            if expense.company_id.id not in valid_company_ids:
+                reason = _(
+                    "%(expense_name)s: Your are neither a Manager nor a HR Officer of this expense's company",
+                    expense_name=expense.name,
+                )
+
+            elif not is_expense_team_approver:
+                reason = _("%(expense_name)s: You are neither a Manager nor a HR Officer", expense_name=expense.name)
+
+            elif not is_hr_admin:
+                current_managers = (
+                        expense_employee.expense_manager_id
+                        | expense_employee.department_id.manager_id.user_id
+                        | expense.manager_id
+                )
+                if expense_employee.id in expenses_employee_ids_under_user_ones:
+                    current_managers |= self.env.user
+
+                if expense_employee.user_id == self.env.user:
+                    reason = _("%(expense_name)s: It is your own expense", expense_name=expense.name)
+
+                elif self.env.user not in current_managers and not is_approver:
+                    reason = _("%(expense_name)s: It is not from your department", expense_name=expense.name)
+            reasons_per_record_id[expense.id] = reason
+        return reasons_per_record_id
+
+    def _check_can_refuse(self):
+        if not all(self.mapped('can_approve')):
+            reasons = _("You cannot refuse:\n %(reasons)s", reasons="\n".join(self._get_cannot_approve_reason().values()))
+            raise UserError(reasons)
+
+    def _check_can_reset_approval(self):
+        if not all(self.mapped('can_reset')):
+            raise UserError(_("Only HR Officers, accountants, or the concerned employee can reset to draft."))
+        if any(state not in {False, 'draft'} for state in self.account_move_id.mapped('state')):
+            raise UserError(_("You cannot reset to draft an expense linked to a posted journal entry."))
+
+    def _check_can_create_move(self):
+        if any(expense.state != 'approved' for expense in self):
+            raise UserError(_("You can only generate an accounting entry for approved expense(s)."))
+
+        if False in self.mapped('payment_mode'):
+            raise UserError(_("Please specify if the expenses were paid by the company, or the employee."))
+
+        missing_email_employees = self.employee_id.filtered(lambda employee: not employee.work_email)
+        if missing_email_employees:
+            action = self.env['ir.actions.actions']._for_xml_id('hr.open_view_employee_list_my')
+            action['domain'] = [('id', 'in', missing_email_employees.ids)]
+            raise RedirectWarning(
+                message=_("The work email of some employees is missing. Please add it on their form."),
+                action=action,
+                button_text=_("Go to employees"),
+             )
+
+    def _do_approve(self, check=True):
+        if check:
+            self._check_can_approve()
+        expenses_to_approve = self.filtered(lambda s: s.state in {'submitted', 'draft'})
+        for expense in expenses_to_approve:
+            expense.write({
+                'approval_state': 'approved',
+                'manager_id': self.env.user.id,
+                'approval_date': fields.Date.context_today(expense),
+            })
+        self.update_activities_and_mails()
+
+    def _do_reset_approval(self):
+        self.sudo().write({'approval_state': False, 'approval_date': False, 'account_move_id': False})
+        self.update_activities_and_mails()
+
+    def _do_refuse(self, reason):
+        # Sudoed as approvers may not be accountants
+        draft_moves_sudo = self.sudo().account_move_id.filtered(lambda move: move.state == 'draft')
+        if self.sudo().account_move_id - draft_moves_sudo:
+            raise UserError(_("You cannot cancel an expense linked to a posted journal entry"))
+
+        if draft_moves_sudo:
+            draft_moves_sudo.unlink()  # Else we have lingering moves
+
+        self.approval_state = 'refused'
+        subtype_id = self.env['ir.model.data']._xmlid_to_res_id('mail.mt_comment')
+        for expense in self:
+            expense.message_post_with_source(
+                'hr_expense.hr_expense_template_refuse_reason',
+                subtype_id=subtype_id,
+                render_values={'reason': reason, 'name': expense.name},
+            )
+        self.update_activities_and_mails()
+
     def _get_split_values(self):
         self.ensure_one()
         half_price = self.total_amount_currency / 2
@@ -845,43 +1458,142 @@ class HrExpense(models.Model):
             'company_id': self.company_id.id,
             'analytic_distribution': self.analytic_distribution,
             'employee_id': self.employee_id.id,
+            'approval_state': self.approval_state,
+            'approval_date': self.approval_date,
+            'manager_id': self.manager_id.id,
             'expense_id': self.id,
         } for price in (price_round_up, price_round_down)]
 
-    def action_split_wizard(self):
+    def _get_default_responsible_for_approval(self):
         self.ensure_one()
-        splits = self.env['hr.expense.split'].create(self._get_split_values())
+        approver_group = 'hr_expense.group_hr_expense_team_approver'
 
-        wizard = self.env['hr.expense.split.wizard'].create({
-            'expense_split_line_ids': splits.ids,
-            'expense_id': self.id,
-        })
+        employee = self.employee_id
+        expense_manager = employee.expense_manager_id - employee.user_id
+        if expense_manager:
+            return expense_manager
+
+        department_manager = employee.department_id.manager_id.user_id - employee.user_id
+        if department_manager and department_manager.has_groups(approver_group):
+            return department_manager
+
+        employee_team_leader = employee.parent_id.user_id
+        if employee_team_leader:
+            return employee_team_leader
+
+        return self.env['res.users']
+
+    def _needs_product_price_computation(self):
+        # Hook to be overridden.
+        self.ensure_one()
+        return self.product_has_cost
+
+    def _post_wizard(self):
+        if 'company_account' in set(self.mapped('payment_mode')):
+            raise UserError(_("Only expense paid by the employee can be posted with the wizard"))
+
+        wizard_name = (
+            _("Post expenses paid by the employee")
+            if self.env.context.get('company_paid_move_ids')
+            else _("Post expenses")
+        )
         return {
-            'name': _('Expense split'),
             'type': 'ir.actions.act_window',
+            'name': wizard_name,
             'view_mode': 'form',
-            'views': [[False, "form"]],
-            'res_model': 'hr.expense.split.wizard',
-            'res_id': wizard.id,
+            'views': [(False, "form")],
+            'res_model': 'hr.expense.post.wizard',
+            'res_id': self.env['hr.expense.post.wizard'].create({}).id,
             'target': 'new',
-            'context': self.env.context,
+            'context': self.with_context(active_ids=self.ids).env.context,
         }
 
-    # ----------------------------------------
-    # Business
-    # ----------------------------------------
+    def _post_without_wizard(self):
+        """ Post an employee expense without any direct call for the wizard, should never be called unless in very specific flows """
+        # When a move has been deleted
+        self._check_can_create_move()
+        today = fields.Date.context_today(self)
+        employee_expenses = self.filtered(lambda expense: expense.payment_mode == 'own_account')
+
+        for company, expenses in employee_expenses.grouped('company_id').items():
+            expenses = expenses.with_company(company)
+            company_domain = self.env['account.journal']._check_company_domain(company)
+            journal = (
+                    company.expense_journal_id
+                    or expenses.env['account.journal'].search([*company_domain, ('type', '=', 'purchase')], limit=1))
+            expense_bill_vals_list = [
+                {
+                    **new_bill_vals,
+                    'journal_id': journal.id,
+                    'invoice_date': today,
+                }
+                for new_bill_vals in expenses._prepare_bills_vals()
+            ]
+            moves = self.env['account.move'].sudo().create(expense_bill_vals_list)
+            for move in moves:
+                move._message_set_main_attachment_id(move.attachment_ids, force=True, filter_xml=False)
+            moves.action_post()
+
+    def _create_company_paid_moves(self):
+        """
+        Creation of the account moves for the company paid expenses.
+        -> Create an account payment (we only "log" the already paid expense so it can be reconciled)
+        """
+        self = self.with_context(clean_context(self.env.context))  # remove default_*
+        company_account_expenses = self.filtered(lambda expense: expense.payment_mode == 'company_account')
+        moves_sudo = self.env['account.move'].sudo()
+
+        if company_account_expenses:
+            move_vals_list, payment_vals_list = zip(*[expense._prepare_payments_vals() for expense in company_account_expenses])
+
+            payment_moves_sudo = self.env['account.move'].sudo().create(move_vals_list)
+            for payment_vals, move in zip(payment_vals_list, payment_moves_sudo):
+                payment_vals['move_id'] = move.id
+
+            payments_sudo = self.env['account.payment'].sudo().create(payment_vals_list)
+            for payment_sudo, move_sudo in zip(payments_sudo, payment_moves_sudo):
+                move_sudo.update({
+                    'origin_payment_id': payment_sudo.id,
+                    # We need to put the journal_id because editing origin_payment_id triggers a re-computation chain
+                    # that voids the company_currency_id of the lines
+                    'journal_id': move_sudo.journal_id.id,
+                })
+
+            moves_sudo |= payment_moves_sudo
+
+        # returning the move with the superuser flag set back as it was at the origin of the call
+        return moves_sudo.sudo(self.env.su)
+
+    def _prepare_bills_vals(self):
+        attachments_data = []
+        for attachment in self.message_main_attachment_id:
+            attachments_data.append(
+                Command.create(attachment.copy_data({'res_model': 'account.move', 'res_id': False, 'raw': attachment.raw})[0])
+            )
 
-    def _get_move_line_name(self):
-        """ Helper to get the name of the account move lines related to an expense """
-        self.ensure_one()
-        expense_name = self.name.split("\n")[0][:64]
-        return _('%(employee_name)s: %(expense_name)s', employee_name=self.employee_id.name, expense_name=expense_name)
+        return_vals = []
+        for employee_sudo, expenses_sudo in self.sudo().grouped('employee_id').items():
+            multiple_expenses_name = _("Expenses of %(employee)s", employee=employee_sudo.name)
+            move_ref = expenses_sudo.name if len(expenses_sudo) == 1 else multiple_expenses_name
+            currency = expenses_sudo.currency_id if len(expenses_sudo.currency_id) == 1 else expenses_sudo.company_currency_id
+            return_vals.append({
+            **expenses_sudo._prepare_move_vals(),
+                'ref': move_ref,
+                'move_type': 'in_invoice',
+                'partner_id': employee_sudo.work_contact_id.id,
+                'commercial_partner_id': employee_sudo.user_partner_id.id,
+                'currency_id': currency.id,
+                'line_ids': [Command.create(expense_sudo._prepare_move_lines_vals()) for expense_sudo in expenses_sudo],
+                'partner_bank_id': employee_sudo.bank_account_id.id,
+                'attachment_ids': attachments_data,
+            })
+        return return_vals
 
     def _prepare_payments_vals(self):
         self.ensure_one()
 
-        journal = self.sheet_id.journal_id
-        payment_method_line = self.sheet_id.payment_method_line_id
+        journal = self.journal_id
+        payment_method_line = self.payment_method_line_id
         if not payment_method_line:
             raise UserError(_("You need to add a manual payment method on the journal (%s)", journal.name))
 
@@ -901,6 +1613,7 @@ class HrExpense(models.Model):
 
         # Base line.
         move_lines = []
+        base_move_line = {}
         for base_line, to_update in tax_results['base_lines_to_update']:
             base_move_line = {
                 'name': self._get_move_line_name(),
@@ -927,7 +1640,7 @@ class HrExpense(models.Model):
         # Outstanding payment line.
         move_lines.append({
             'name': self._get_move_line_name(),
-            'account_id': self.sheet_id._get_expense_account_destination(),
+            'account_id': self._get_expense_account_destination(),
             'balance': -self.total_amount,
             'amount_currency': self.currency_id.round(-self.total_amount_currency),
             'currency_id': self.currency_id.id,
@@ -946,9 +1659,9 @@ class HrExpense(models.Model):
             'company_id': self.company_id.id,
         }
         move_vals = {
-            **self.sheet_id._prepare_move_vals(),
+            **self._prepare_move_vals(),
+            'date': self.date or fields.Date.context_today(self),
             'ref': self.name,
-            'date': self.date,  # Overidden from self.sheet_id._prepare_move_vals() so we can use the expense date for the account move date
             'journal_id': journal.id,
             'partner_id': self.vendor_id.id,
             'currency_id': self.currency_id.id,
@@ -959,6 +1672,43 @@ class HrExpense(models.Model):
         }
         return move_vals, payment_vals
 
+    def _prepare_move_vals(self):
+        return {
+            # force the name to the default value, to avoid an eventual 'default_name' in the context
+            # that would set it to '' which would then cause no number to be given to the account.move
+            # when it is posted.
+            'name': '/',
+            'expense_ids': [Command.set(self.ids)],
+        }
+
+    def _prepare_move_lines_vals(self):
+        self.ensure_one()
+        return {
+            'name': self._get_move_line_name(),
+            'account_id': self._get_base_account().id,
+            'quantity': self.quantity or 1,
+            'price_unit': self.price_unit,
+            'product_id': self.product_id.id,
+            'product_uom_id': self.product_uom_id.id,
+            'analytic_distribution': self.analytic_distribution,
+            'expense_id': self.id,
+            'partner_id': False if self.payment_mode == 'company_account' else self.employee_id.sudo().work_contact_id.id,
+            'tax_ids': [Command.set(self.tax_ids.ids)],
+        }
+
+    def _prepare_base_line_for_taxes_computation(self, **kwargs):
+        self.ensure_one()
+        return self.env['account.tax']._prepare_base_line_for_taxes_computation(
+            self,
+            **{'partner_id': self.vendor_id, 'special_mode': 'total_included', 'rate': self.currency_rate, **kwargs},
+        )
+
+    def _get_move_line_name(self):
+        """ Helper to get the name of the account move lines related to an expense """
+        self.ensure_one()
+        expense_name = self.name.split("\n")[0][:64]
+        return _('%(employee_name)s: %(expense_name)s', employee_name=self.employee_id.name, expense_name=expense_name)
+
     def _get_base_account(self):
         """
         Returns the expense account or forces default values if none was found
@@ -972,7 +1722,6 @@ class HrExpense(models.Model):
 
         # expense account of the expense itself
         account = self.account_id
-
         if account:
             return account
 
@@ -986,224 +1735,36 @@ class HrExpense(models.Model):
             return account
 
         # expense account on the purchase journal for employee expense
-        journal = self.sheet_id.journal_id
+        journal = self.journal_id
         if journal.type == 'purchase':
             account = journal.default_account_id
 
         return account
 
-    def _prepare_move_lines_vals(self):
+    def _get_expense_account_destination(self):
         self.ensure_one()
-        account = self._get_base_account()
-
-        return {
-            'name': self._get_move_line_name(),
-            'account_id': account.id,
-            'quantity': self.quantity or 1,
-            'price_unit': self.price_unit,
-            'product_id': self.product_id.id,
-            'product_uom_id': self.product_uom_id.id,
-            'analytic_distribution': self.analytic_distribution,
-            'expense_id': self.id,
-            'partner_id': False if self.payment_mode == 'company_account' else self.employee_id.sudo().work_contact_id.id,
-            'tax_ids': [Command.set(self.tax_ids.ids)],
-        }
-
-    @api.model
-    def get_expense_dashboard(self):
-        expense_state = {
-            'to_submit': {
-                'description': _('to submit'),
-                'amount': 0.0,
-                'currency': self.env.company.currency_id.id,
-            },
-            'submitted': {
-                'description': _('under validation'),
-                'amount': 0.0,
-                'currency': self.env.company.currency_id.id,
-            },
-            'approved': {
-                'description': _('to be reimbursed'),
-                'amount': 0.0,
-                'currency': self.env.company.currency_id.id,
-            }
-        }
-        if not self.env.user.employee_ids:
-            return expense_state
-        target_currency = self.env.company.currency_id
-        # Counting the expenses to display in the dashboard:
-        # - To submit: contains the expenses paid either by the employee or by the company, and that are draft or reported
-        # - Under validation: contains expenses paid by the employee or paid by the company, and that have been submitted but still need to be approved/refused
-        # - To be reimbursed: contains ONLY expenses paid by the employee that are approved, the payment has not yet been made
-        expenses = self._read_group(
-            [
-                ('employee_id', 'in', self.env.user.employee_ids.ids),
-                '|', '&', ('payment_mode', 'in', ('own_account', 'company_account')), ('state', 'in', ('draft', 'reported', 'submitted')),
-                     '&', ('payment_mode', '=', 'own_account'), ('state', '=', 'approved')
-            ], ['state'], ['total_amount:sum'])
-        for state, total_amount_sum in expenses:
-            if state in {'draft', 'reported'}:  # Fuse the two states into only one "To Submit" state
-                state = 'to_submit'
-            expense_state[state]['amount'] += total_amount_sum
-        return expense_state
-
-    # ----------------------------------------
-    # Mail Thread
-    # ----------------------------------------
-
-    @api.model
-    def message_new(self, msg_dict, custom_values=None):
-        email_address = email_normalize(msg_dict.get('email_from'))
-        employee = self._get_employee_from_email(email_address)
-
-        if not employee:
-            return super().message_new(msg_dict, custom_values=custom_values)
-
-        expense_description = msg_dict.get('subject', '')
-
-        if employee.user_id:
-            company = employee.user_id.company_id
-            currencies = company.currency_id | employee.user_id.company_ids.mapped('currency_id')
-        else:
-            company = employee.company_id
-            currencies = company.currency_id
-
-        if not company:  # ultimate fallback, since company_id is required on expense
-            company = self.env.company
-
-        # The expenses alias is the same for all companies, we need to set the proper context
-        # To select the product account
-        self = self.with_company(company)
-
-        product, price, currency_id, expense_description = self._parse_expense_subject(expense_description, currencies)
-        vals = {
-            'employee_id': employee.id,
-            'name': expense_description,
-            'total_amount_currency': price,
-            'product_id': product.id if product else None,
-            'product_uom_id': product.uom_id.id,
-            'tax_ids': [Command.set(product.supplier_taxes_id.filtered(lambda r: r.company_id == company).ids)],
-            'quantity': 1,
-            'company_id': company.id,
-            'currency_id': currency_id.id
-        }
-
-        account = product.product_tmpl_id._get_product_accounts()['expense']
-        if account:
-            vals['account_id'] = account.id
-
-        expense = super().message_new(msg_dict, dict(custom_values or {}, **vals))
-        self._send_expense_success_mail(msg_dict, expense)
-        return expense
-
-    @api.model
-    def _get_employee_from_email(self, email_address):
-        if not email_address:
-            return self.env['hr.employee']
-        employee = self.env['hr.employee'].search([
-            ('user_id', '!=', False),
-            '|',
-            ('work_email', 'ilike', email_address),
-            ('user_id.email', 'ilike', email_address),
-        ])
-
-        if len(employee) > 1:
-            # Several employees can be linked to the same user.
-            # In that case, we only keep the employee that matched the user's company.
-            return employee.filtered(lambda e: e.company_id == e.user_id.company_id)
-
-        if not employee:
-            # An employee does not always have a user.
-            return self.env['hr.employee'].search([
-                ('user_id', '=', False),
-                ('work_email', 'ilike', email_address),
-            ], limit=1)
-
-        return employee
-
-    @api.model
-    def _parse_product(self, expense_description):
-        """
-            Parse the subject to find the product.
-            Product code should be the first word of expense_description
-            Return product.product and updated description
-        """
-        product_code = expense_description.split(' ')[0]
-        product = self.env['product.product'].search([('can_be_expensed', '=', True), ('default_code', '=ilike', product_code)], limit=1)
-        if product:
-            expense_description = expense_description.replace(product_code, '', 1)
-
-        return product, expense_description
-
-    @api.model
-    def _parse_price(self, expense_description, currencies):
-        """ Return price, currency and updated description """
-        symbols, symbols_pattern, float_pattern = [], '', r'[+-]?(\d+[.,]?\d*)'
-        price = 0.0
-        for currency in currencies:
-            symbols += [re.escape(currency.symbol), re.escape(currency.name)]
-        symbols_pattern = '|'.join(symbols)
-        price_pattern = f'(({symbols_pattern})?\\s?{float_pattern}\\s?({symbols_pattern})?)'
-        matches = re.findall(price_pattern, expense_description)
-        currency = currencies[:1]
-        if matches:
-            match = max(matches, key=lambda match: len([group for group in match if group]))
-            # get the longest match. e.g. "2 chairs 120$" -> the price is 120$, not 2
-            full_str = match[0]
-            currency_str = match[1] or match[3]
-            price = match[2].replace(',', '.')
-
-            if currency_str and currencies:
-                currencies = currencies.filtered(lambda c: currency_str in [c.symbol, c.name])
-                currency = currencies[:1] or currency
-            expense_description = expense_description.replace(full_str, ' ')  # remove price from description
-            expense_description = re.sub(' +', ' ', expense_description.strip())
-
-        return float(price), currency, expense_description
-
-    @api.model
-    def _parse_expense_subject(self, expense_description, currencies):
-        """
-            Fetch product, price and currency info from mail subject.
-
-            Product can be identified based on product name or product code.
-            It can be passed between [] or it can be placed at start.
-
-            When parsing, only consider currencies passed as parameter.
-            This will fetch currency in symbol($) or ISO name (USD).
-
-            Some valid examples:
-                Travel by Air [TICKET] USD 1205.91
-                TICKET $1205.91 Travel by Air
-                Extra expenses 29.10EUR [EXTRA]
-        """
-        product, expense_description = self._parse_product(expense_description)
-        price, currency_id, expense_description = self._parse_price(expense_description, currencies)
-
-        return product, price, currency_id, expense_description
-
-    def _send_expense_success_mail(self, msg_dict, expense):
-        if expense.employee_id.user_id:
-            mail_template_id = 'hr_expense.hr_expense_template_register'
-        else:
-            mail_template_id = 'hr_expense.hr_expense_template_register_no_user'
-        rendered_body = self.env['ir.qweb']._render(mail_template_id, {'expense': expense})
-        body = self.env['mail.render.mixin']._replace_local_links(rendered_body)
-        if expense.employee_id.user_id.partner_id:
-            expense.message_post(
-                body=body,
-                email_layout_xmlid='mail.mail_notification_light',
-                partner_ids=expense.employee_id.user_id.partner_id.ids,
-                subject=f'Re: {msg_dict.get("subject", "")}',
-                subtype_xmlid='mail.mt_note',
+        if self.payment_mode == 'company_account':
+            journal = self.payment_method_line_id.journal_id
+            account_dest = (
+                self.payment_method_line_id.payment_account_id
+                or journal.company_id.expense_outstanding_account_id
             )
+            if not account_dest:
+                error_msg = _(
+                    "A default outstanding account must be defined in the settings for company-paid expenses. "
+                    "You can alternatively specify one in the Journal for the %(method)s payment method.",
+                    method=self.payment_method_line_id.display_name,
+                )
+                if self.env['res.config.settings'].has_access('write'):
+                    action = self.env.ref('hr_expense.action_hr_expense_configuration')
+                    raise RedirectWarning(error_msg, action=action.id, button_text=_("Go to settings"))
+                else:
+                    raise UserError(error_msg)
         else:
-            self.env['mail.mail'].sudo().create({
-                'author_id': self.env.user.partner_id.id,
-                'auto_delete': True,
-                'body_html': body,
-                'email_from': self.env.user.email_formatted,
-                'email_to': msg_dict.get('email_from', False),
-                'references': msg_dict.get('message_id'),
-                'subject': f'Re: {msg_dict.get("subject", "")}',
-            }).send()
+            if not self.employee_id.sudo().work_contact_id:
+                raise UserError(
+                    _("No work contact found for the employee %(name)s, please configure one.", name=self.employee_id.name)
+                )
+            partner = self.employee_id.sudo().work_contact_id.with_company(self.company_id)
+            account_dest = partner.property_account_payable_id or partner.parent_id.property_account_payable_id
+        return account_dest.id

--- a/addons/hr_expense/models/hr_expense_sheet.py
+++ b/None
@@ -1,899 +0,0 @@
-# Part of Odoo. See LICENSE file for full copyright and licensing details.
-
-from odoo import api, fields, Command, models, _
-from odoo.exceptions import AccessError, UserError, ValidationError, RedirectWarning
-from odoo.tools.misc import clean_context
-from odoo.tools import format_date
-
-
-class HrExpenseSheet(models.Model):
-    """
-        Here are the rights associated with the expense flow
-
-        Action       Group                   Restriction
-        =================================================================================
-        Submit      Employee                Only his own
-                    Officer                 If he is expense manager of the employee, manager of the employee
-                                             or the employee is in the department managed by the officer
-                    Manager                 Always
-        Approve     Officer                 Not his own and he is expense manager of the employee, manager of the employee
-                                             or the employee is in the department managed by the officer
-                    Manager                 Always
-        Post        Anybody                 State = approve and journal_id defined
-        Done        Anybody                 State = approve and journal_id defined
-        Cancel      Officer                 Not his own and he is expense manager of the employee, manager of the employee
-                                             or the employee is in the department managed by the officer
-                    Manager                 Always
-        =================================================================================
-    """
-    _name = 'hr.expense.sheet'
-    _inherit = ['mail.thread.main.attachment', 'mail.activity.mixin']
-    _description = "Expense Report"
-    _order = "accounting_date desc, id desc"
-    _check_company_auto = True
-
-    @api.model
-    def _default_employee_id(self):
-        return self.env.user.employee_id
-
-    @api.model
-    def _default_journal_id(self):
-        """
-             The journal is determining the company of the accounting entries generated from expense.
-             We need to force journal company and expense sheet company to be the same.
-        """
-        company_journal_id = self.env.company.expense_journal_id
-        if company_journal_id:
-            return company_journal_id.id
-        default_company_id = self.default_get(['company_id'])['company_id']
-        journal = self.env['account.journal'].search([
-            *self.env['account.journal']._check_company_domain(default_company_id),
-            ('type', '=', 'purchase'),
-        ], limit=1)
-        return journal.id
-
-    name = fields.Char(string="Expense Report Summary", required=True, tracking=True)
-    expense_line_ids = fields.One2many(
-        comodel_name='hr.expense', inverse_name='sheet_id',
-        string="Expense Lines",
-        copy=False,
-    )
-    nb_expense = fields.Integer(compute='_compute_nb_expense', string="Number of Expenses")
-    state = fields.Selection(
-        selection=[
-            ('draft', 'To Submit'),
-            ('submit', 'Submitted'),
-            ('approve', 'Approved'),
-            ('post', 'Posted'),
-            ('done', 'Done'),
-            ('cancel', 'Refused')
-        ],
-        string="Status",
-        compute='_compute_state', store=True, readonly=True,
-        index=True,
-        required=True,
-        default='draft',
-        tracking=True,
-        copy=False,
-    )
-    approval_state = fields.Selection(
-        selection=[
-            ('submit', 'Submitted'),
-            ('approve', 'Approved'),
-            ('cancel', 'Refused'),
-        ],
-        copy=False,
-    )
-    approval_date = fields.Datetime(string="Approval Date", readonly=True)
-    company_id = fields.Many2one(
-        comodel_name='res.company',
-        string="Company",
-        required=True,
-        readonly=True,
-        default=lambda self: self.env.company,
-    )
-    employee_id = fields.Many2one(
-        comodel_name='hr.employee',
-        string="Employee",
-        required=True,
-        readonly=True,
-        default=_default_employee_id,
-        domain=[('filter_for_expense', '=', True)],
-        check_company=True,
-        tracking=True,
-    )
-
-    department_id = fields.Many2one(
-        comodel_name='hr.department',
-        related='employee_id.department_id',
-        string="Department",
-        store=True,
-        copy=False,
-    )
-    user_id = fields.Many2one(
-        comodel_name='res.users',
-        string="Manager",
-        compute='_compute_from_employee_id', store=True, readonly=True,
-        domain=lambda self: [('groups_id', 'in', self.env.ref('hr_expense.group_hr_expense_team_approver').id)],
-        copy=False,
-        tracking=True,
-    )
-    product_ids = fields.Many2many(
-        comodel_name='product.product',
-        string="Categories",
-        compute='_compute_product_ids',
-        search='_search_product_ids',
-        check_company=True,
-    )
-
-    # === Amount fields === #
-    total_amount = fields.Monetary(
-        string="Total",
-        currency_field='company_currency_id',
-        compute='_compute_amount', store=True, readonly=True,
-        tracking=True,
-    )
-    untaxed_amount = fields.Monetary(
-        string="Untaxed Amount",
-        currency_field='company_currency_id',
-        compute='_compute_amount', store=True, readonly=True,
-    )
-    total_tax_amount = fields.Monetary(
-        string="Taxes",
-        currency_field='company_currency_id',
-        compute='_compute_amount', store=True, readonly=True,
-    )
-    amount_residual = fields.Monetary(
-        string="Amount Due",
-        currency_field='company_currency_id',
-        compute='_compute_from_account_move_ids', store=True, readonly=True,
-    )
-    currency_id = fields.Many2one(
-        comodel_name='res.currency',
-        string="Currency",
-        compute='_compute_currency_id', store=True, readonly=True,
-    )
-    company_currency_id = fields.Many2one(
-        comodel_name='res.currency',
-        related='company_id.currency_id',
-        string="Report Company Currency"
-    )
-    is_multiple_currency = fields.Boolean(
-        string="Handle lines with different currencies",
-        compute='_compute_is_multiple_currency',
-    )
-
-    # === Account fields === #
-    payment_state = fields.Selection(
-        selection=lambda self: self.env["account.move"]._fields["payment_state"]._description_selection(self.env),
-        string="Payment Status",
-        compute='_compute_from_account_move_ids', store=True, readonly=True,
-        copy=False,
-        tracking=True,
-    )
-    payment_mode = fields.Selection(
-        related='expense_line_ids.payment_mode',
-        string="Paid By",
-        tracking=True,
-        readonly=True,
-    )
-    employee_journal_id = fields.Many2one(
-        comodel_name='account.journal',
-        string="Journal",
-        default=_default_journal_id,
-        check_company=True,
-        domain=[('type', '=', 'purchase')],
-        help="The journal used when the expense is paid by employee.",
-    )
-    selectable_payment_method_line_ids = fields.Many2many(
-        comodel_name='account.payment.method.line',
-        compute='_compute_selectable_payment_method_line_ids',
-    )
-    payment_method_line_id = fields.Many2one(
-        comodel_name='account.payment.method.line',
-        string="Payment Method",
-        compute='_compute_payment_method_line_id', store=True, readonly=False,
-        domain="[('id', 'in', selectable_payment_method_line_ids)]",
-        help="The payment method used when the expense is paid by the company.",
-    )
-    attachment_ids = fields.One2many(
-        comodel_name='ir.attachment',
-        inverse_name='res_id',
-        domain="[('res_model', '=', 'hr.expense.sheet')]",
-        string='Attachments of expenses',
-    )
-    message_main_attachment_id = fields.Many2one(compute='_compute_main_attachment', store=True)
-    accounting_date = fields.Date(string="Expense Report Date", help="Specify the bill date of the related vendor bill.")
-    account_move_ids = fields.One2many(
-        string="Journal Entries",
-        comodel_name='account.move', inverse_name='expense_sheet_id', readonly=True,
-    )
-    nb_account_move = fields.Integer(string="Number of Journal Entries", compute='_compute_nb_account_move')
-    journal_id = fields.Many2one(
-        comodel_name='account.journal',
-        string="Expense Journal",
-        compute='_compute_journal_id', store=True,
-        check_company=True,
-    )
-
-    # === Security fields === #
-    can_reset = fields.Boolean(string='Can Reset', compute='_compute_can_reset')
-    can_approve = fields.Boolean(string='Can Approve', compute='_compute_can_approve')
-    cannot_approve_reason = fields.Char(string='Cannot Approve Reason', compute='_compute_can_approve')
-    is_editable = fields.Boolean(string="Expense Lines Are Editable By Current User", compute='_compute_is_editable')
-
-    _journal_id_required_posted = models.Constraint(
-        "CHECK((state IN ('post', 'done') AND journal_id IS NOT NULL) OR (state NOT IN ('post', 'done')))",
-        'The journal must be set on posted expense',
-    )
-
-    @api.depends('expense_line_ids.total_amount', 'expense_line_ids.tax_amount')
-    def _compute_amount(self):
-        for sheet in self:
-            sheet.total_amount = sum(sheet.expense_line_ids.mapped('total_amount'))
-            sheet.total_tax_amount = sum(sheet.expense_line_ids.mapped('tax_amount'))
-            sheet.untaxed_amount = sheet.total_amount - sheet.total_tax_amount
-
-    @api.depends('account_move_ids.payment_state', 'account_move_ids.amount_residual')
-    def _compute_from_account_move_ids(self):
-        for sheet in self:
-            if sheet.payment_mode == 'company_account':
-                if sheet.account_move_ids.filtered(lambda move: move.state != 'draft'):
-                    # when the sheet is paid by the company, the state/amount of the related account_move_ids are not relevant
-                    # unless all moves have been reversed
-                    sheet.amount_residual = 0.
-                    if sheet.account_move_ids - sheet.account_move_ids.filtered('reversal_move_ids'):
-                        sheet.payment_state = 'paid'
-                    else:
-                        sheet.payment_state = 'reversed'
-                else:
-                    sheet.amount_residual = sum(sheet.account_move_ids.mapped('amount_residual'))
-                    payment_states = set(sheet.account_move_ids.mapped('payment_state'))
-                    if len(payment_states) <= 1:  # If only 1 move or only one state
-                        sheet.payment_state = payment_states.pop() if payment_states else 'not_paid'
-                    elif 'partial' in payment_states or 'paid' in payment_states:  # else if any are (partially) paid
-                        sheet.payment_state = 'partial'
-                    else:
-                        sheet.payment_state = 'not_paid'
-            else:
-                # Only one move is created when the expenses are paid by the employee
-                if sheet.account_move_ids.filtered(lambda move: move.state == 'posted'):
-                    sheet.amount_residual = sum(sheet.account_move_ids.mapped('amount_residual'))
-                    sheet.payment_state = sheet.account_move_ids[:1].payment_state
-                else:
-                    sheet.amount_residual = 0.0
-                    sheet.payment_state = 'not_paid'
-
-    @api.depends('selectable_payment_method_line_ids')
-    def _compute_payment_method_line_id(self):
-        for sheet in self:
-            sheet.payment_method_line_id = sheet.selectable_payment_method_line_ids[:1]
-
-    @api.depends('employee_journal_id', 'payment_method_line_id')
-    def _compute_journal_id(self):
-        for sheet in self:
-            if sheet.payment_mode == 'company_account':
-                sheet.journal_id = sheet.payment_method_line_id.journal_id
-            else:
-                sheet.journal_id = sheet.employee_journal_id
-
-    @api.depends('company_id')
-    def _compute_selectable_payment_method_line_ids(self):
-        for sheet in self:
-            allowed_method_line_ids = sheet.company_id.company_expense_allowed_payment_method_line_ids
-            if allowed_method_line_ids:
-                sheet.selectable_payment_method_line_ids = allowed_method_line_ids
-            else:
-                sheet.selectable_payment_method_line_ids = self.env['account.payment.method.line'].search([
-                    ('payment_type', '=', 'outbound'),
-                    ('company_id', 'parent_of', sheet.company_id.id)
-                ])
-
-    @api.depends('account_move_ids', 'payment_state', 'approval_state')
-    def _compute_state(self):
-        for sheet in self:
-            move_ids = sheet.account_move_ids
-            if not sheet.approval_state:
-                sheet.state = 'draft'
-            elif sheet.approval_state == 'cancel':
-                sheet.state = 'cancel'
-            elif move_ids:
-                if sheet.payment_state != 'not_paid':
-                    sheet.state = 'done'
-                elif all(move_ids.mapped(lambda move: move.state == 'draft')):
-                    sheet.state = 'approve'
-                else:
-                    sheet.state = 'post'
-            else:
-                sheet.state = sheet.approval_state  # Submit & approved without a move case
-
-    @api.depends('expense_line_ids.attachment_ids')
-    def _compute_main_attachment(self):
-        for sheet in self:
-            attachments = sheet.attachment_ids
-            if not sheet.message_main_attachment_id or sheet.message_main_attachment_id not in attachments:
-                expenses = sheet.expense_line_ids
-                expenses_mma_checksums = expenses.message_main_attachment_id.mapped('checksum')
-                sheet.message_main_attachment_id = attachments.filtered(
-                    lambda att: att.checksum in expenses_mma_checksums
-                )[:1] or attachments[:1]
-
-    @api.depends('expense_line_ids.currency_id', 'company_currency_id')
-    def _compute_currency_id(self):
-        for sheet in self:
-            if not sheet.expense_line_ids or sheet.is_multiple_currency or sheet.payment_mode == 'own_account':
-                sheet.currency_id = sheet.company_currency_id
-            else:
-                sheet.currency_id = sheet.expense_line_ids[:1].currency_id
-
-    @api.depends('expense_line_ids.currency_id')
-    def _compute_is_multiple_currency(self):
-        for sheet in self:
-            sheet.is_multiple_currency = any(sheet.expense_line_ids.mapped('is_multiple_currency')) \
-                                         or len(sheet.expense_line_ids.mapped('currency_id')) > 1
-
-    @api.depends('employee_id')
-    def _compute_can_reset(self):
-        is_expense_user = self.env.user.has_group('hr_expense.group_hr_expense_team_approver')
-        for sheet in self:
-            sheet.can_reset = is_expense_user if is_expense_user else sheet.employee_id.user_id == self.env.user
-
-    @api.depends_context('uid')
-    @api.depends('employee_id')
-    def _compute_can_approve(self):
-        is_team_approver = self.env.user.has_group('hr_expense.group_hr_expense_team_approver')
-        is_approver = self.env.user.has_group('hr_expense.group_hr_expense_user')
-        is_hr_admin = self.env.user.has_group('hr_expense.group_hr_expense_manager')
-
-        for sheet in self:
-            reason = False
-            if not is_team_approver:
-                reason = _("%s: Your are not a Manager or HR Officer", sheet.name)
-
-            elif not is_hr_admin:
-                sheet_employee = sheet.employee_id
-                current_managers = sheet_employee.expense_manager_id \
-                                   | sheet_employee.parent_id.user_id \
-                                   | sheet_employee.department_id.manager_id.user_id \
-                                   | sheet.user_id
-
-                if sheet_employee.user_id == self.env.user:
-                    reason = _("%s: It is your own expense", sheet.name)
-
-                elif self.env.user not in current_managers and not is_approver and sheet_employee.expense_manager_id.id != self.env.user.id:
-                    reason = _("%s: It is not from your department", sheet.name)
-
-            sheet.can_approve = not reason
-            sheet.cannot_approve_reason = reason
-
-    @api.depends('expense_line_ids')
-    def _compute_nb_expense(self):
-        for sheet in self:
-            sheet.nb_expense = len(sheet.expense_line_ids)
-
-    @api.depends('account_move_ids')
-    def _compute_nb_account_move(self):
-        for sheet in self:
-            sheet.nb_account_move = len(sheet.account_move_ids)
-
-    @api.depends('employee_id', 'employee_id.department_id')
-    def _compute_from_employee_id(self):
-        for sheet in self:
-            sheet.department_id = sheet.employee_id.department_id
-            sheet.user_id = sheet.employee_id.expense_manager_id or sheet.employee_id.parent_id.user_id
-
-    @api.depends_context('uid')
-    @api.depends('employee_id', 'user_id', 'state')
-    def _compute_is_editable(self):
-        is_hr_admin = (
-                self.env.user.has_group('hr_expense.group_hr_expense_manager')
-                or self.env.user.has_group('base.group_system')
-        )
-        is_approver = self.env.user.has_group('hr_expense.group_hr_expense_user')
-        for sheet in self:
-            if sheet.state not in {'draft', 'submit', 'approve'}:
-                # Not editable
-                sheet.is_editable = False
-                continue
-
-            if is_hr_admin or self.env.su:
-                # Administrator-level users are not restricted
-                sheet.is_editable = True
-                continue
-
-            employee = sheet.employee_id
-
-            is_own_sheet = employee.user_id == self.env.user
-            if is_own_sheet and sheet.state == 'draft':
-                # Anyone can edit their own draft sheet
-                sheet.is_editable = True
-                continue
-
-            managers = employee.expense_manager_id | employee.parent_id.user_id | employee.department_id.manager_id.user_id
-            if is_approver:
-                managers |= self.env.user
-            if not is_own_sheet and self.env.user in managers:
-                # If Approver-level or designated manager, can edit other people sheet
-                sheet.is_editable = True
-                continue
-            sheet.is_editable = False
-
-    @api.constrains('expense_line_ids')
-    def _check_payment_mode(self):
-        for sheet in self:
-            expense_lines = sheet.mapped('expense_line_ids')
-            if expense_lines and any(expense.payment_mode != expense_lines[:1].payment_mode for expense in expense_lines):
-                raise ValidationError(_("All expenses in an expense report must have the same \"paid by\" criteria."))
-
-    @api.depends('expense_line_ids')
-    def _compute_product_ids(self):
-        for sheet in self:
-            sheet.product_ids = sheet.expense_line_ids.mapped('product_id')
-
-    @api.constrains('expense_line_ids', 'employee_id')
-    def _check_employee(self):
-        for sheet in self:
-            if sheet.expense_line_ids.employee_id - sheet.employee_id:
-                raise ValidationError(_('You cannot add expenses of another employee.'))
-
-    @api.constrains('expense_line_ids', 'company_id')
-    def _check_expense_lines_company(self):
-        for sheet in self:
-            if sheet.expense_line_ids.company_id - sheet.company_id:
-                raise ValidationError(_('An expense report must contain only lines from the same company.'))
-
-    @api.onchange('expense_line_ids')
-    def _update_sheet_name(self):
-        """ Set the sheet name to the computed default sheet name when no name is specified. """
-        expense_lines = self.expense_line_ids
-        if not self.name and expense_lines:
-            self.name = self._get_default_sheet_name(expense_lines)
-
-    @api.model
-    def _get_default_sheet_name(self, expenses_to_report):
-        """ Computes the default name for a new expense sheet from the expenses name or dates """
-        if len(expenses_to_report) == 1:
-            sheet_name = expenses_to_report.name
-        else:
-            dates = expenses_to_report.mapped('date')
-            if False in dates:  # If at least one date isn't set, we don't set a default name
-                return False
-            min_date = format_date(self.env, min(dates))
-            max_date = format_date(self.env, max(dates))
-            if min_date == max_date:
-                sheet_name = min_date
-            else:
-                sheet_name = _("%(date_from)s - %(date_to)s", date_from=min_date, date_to=max_date)
-        return sheet_name
-
-    @api.model
-    def _search_product_ids(self, operator, value):
-        if operator == 'in' and not isinstance(value, list):
-            value = [value]
-        return [('expense_line_ids.product_id', operator, value)]
-
-    # ----------------------------------------
-    # ORM Overrides
-    # ----------------------------------------
-
-    @api.model_create_multi
-    def create(self, vals_list):
-        context = clean_context(self.env.context)
-        context.update({
-            'mail_create_nosubscribe': True,
-            'mail_auto_subscribe_no_notify': True,
-        })
-        sheets = super(HrExpenseSheet, self.with_context(context)).create(vals_list)
-        sheets.activity_update()
-        return sheets
-
-    def write(self, values):
-        res = super().write(values)
-
-        user_is_accountant = self.env.user.has_group('account.group_account_user')
-        edit_lines = 'expense_line_ids' in values
-        edit_states = 'state' in values or 'approval_state' in values
-        # Forbids (un)linking expenses from an approved sheet if you're not an accountant
-        if edit_lines and not user_is_accountant and set(self.mapped('state')) - {'draft', 'submit'}:
-            raise AccessError(_("You do not have the rights to add or remove any expenses on an approved or paid expense report."))
-
-        # Ensures there is no empty expense report in a state different from draft or cancel
-        if edit_states or edit_lines:
-            for sheet in self.filtered(lambda sheet: not sheet.expense_line_ids):
-                if sheet.state in {'submit', 'approve', 'post', 'done'}:  # Empty expense report in a state different from draft or cancel
-                    if edit_lines and not sheet.expense_line_ids:  # If you try to remove all expenses from the sheet
-                        raise UserError(_("You cannot remove all expenses from a submitted, approved or paid expense report."))
-                    else:  # If you try to submit, approve, post or pay an empty sheet
-                        raise UserError(_("This expense report is empty. You cannot submit or approve an empty expense report."))
-        return res
-
-    @api.ondelete(at_uninstall=False)
-    def _unlink_except_posted_or_paid(self):
-        for expense in self:
-            if expense.state in {'post', 'done'}:
-                raise UserError(_('You cannot delete a posted or paid expense.'))
-
-    # --------------------------------------------
-    # Mail Thread
-    # --------------------------------------------
-
-    def _track_subtype(self, init_values):
-        self.ensure_one()
-        if 'state' not in init_values:
-            return super()._track_subtype(init_values)
-
-        match self.state:
-            case 'draft':
-                return self.env.ref('hr_expense.mt_expense_reset')
-            case 'cancel':
-                return self.env.ref('hr_expense.mt_expense_refused')
-            case 'done':
-                return self.env.ref('hr_expense.mt_expense_paid')
-            case 'approve':
-                if init_values['state'] in {'post', 'done'}:  # Reverting state
-                    subtype = 'hr_expense.mt_expense_entry_draft' if self.account_move_ids else 'hr_expense.mt_expense_entry_delete'
-                    return self.env.ref(subtype)
-                return self.env.ref('hr_expense.mt_expense_approved')
-            case _:
-                return super()._track_subtype(init_values)
-
-    def _message_auto_subscribe_followers(self, updated_values, subtype_ids):
-        res = super()._message_auto_subscribe_followers(updated_values, subtype_ids)
-        if updated_values.get('employee_id'):
-            employee_user = self.env['hr.employee'].browse(updated_values['employee_id']).user_id
-            if employee_user:
-                res.append((employee_user.partner_id.id, subtype_ids, False))
-        return res
-
-    def activity_update(self):
-        reports_requiring_feedback = self.env['hr.expense.sheet']
-        reports_activity_unlink = self.env['hr.expense.sheet']
-        for expense_report in self:
-            if expense_report.state == 'submit':
-                expense_report.activity_schedule(
-                    'hr_expense.mail_act_expense_approval',
-                    user_id=expense_report.sudo()._get_responsible_for_approval().id or self.env.user.id)
-            elif expense_report.state == 'approve':
-                reports_requiring_feedback |= expense_report
-            elif expense_report.state in {'draft', 'cancel'}:
-                reports_activity_unlink |= expense_report
-        if reports_requiring_feedback:
-            reports_requiring_feedback.activity_feedback(['hr_expense.mail_act_expense_approval'])
-        if reports_activity_unlink:
-            reports_activity_unlink.activity_unlink(['hr_expense.mail_act_expense_approval'])
-
-    # --------------------------------------------
-    # Actions
-    # --------------------------------------------
-
-    def action_submit_sheet(self):
-        self._do_submit()
-
-    def action_approve_expense_sheets(self):
-        self._check_can_approve()
-        self._validate_analytic_distribution()
-        duplicates = self.expense_line_ids.duplicate_expense_ids.filtered(lambda exp: exp.state in {'approved', 'done'})
-        if duplicates:
-            action = self.env["ir.actions.act_window"]._for_xml_id('hr_expense.hr_expense_approve_duplicate_action')
-            action['context'] = {'default_sheet_ids': self.ids, 'default_expense_ids': duplicates.ids}
-            return action
-        self._do_approve()
-
-    def action_refuse_expense_sheets(self):
-        self._check_can_refuse()
-        return self.env["ir.actions.act_window"]._for_xml_id('hr_expense.hr_expense_refuse_wizard_action')
-
-    def action_sheet_move_post(self):
-        # When a move has been deleted
-        self.filtered(lambda sheet: not sheet.account_move_ids)._do_create_moves()
-
-        company_sheets = self.filtered(lambda sheet: sheet.payment_mode == 'company_account')
-        employee_sheets = self - company_sheets
-
-        # Post the employee-paid expenses moves
-        employee_sheets.account_move_ids.action_post()
-
-        # Post the company-paid expense through the payment instead, to post both at the same time
-        company_sheets.account_move_ids.origin_payment_id.action_post()
-
-    def action_reset_expense_sheets(self):
-        self.filtered(lambda sheet: sheet.state not in {'draft', 'submit'})._check_can_reset_approval()
-        self.sudo()._do_reverse_moves()
-        self._do_reset_approval()
-        self.sudo().account_move_ids = [Command.clear()]
-
-    def action_register_payment(self):
-        ''' Open the account.payment.register wizard to pay the selected journal entries.
-        There can be more than one bank_account_id in the expense sheet when registering payment for multiple expenses.
-        The default_partner_bank_id is set only if there is one available, if more than one the field is left empty.
-        :return: An action opening the account.payment.register wizard.
-        '''
-        return self.account_move_ids.with_context(default_partner_bank_id=(
-            self.account_move_ids.partner_bank_id.id if len(self.account_move_ids.partner_bank_id.ids) <= 1 else None
-        )).action_register_payment()
-
-    def action_open_expense_view(self):
-        self.ensure_one()
-        if self.nb_expense == 1:
-            return {
-                'type': 'ir.actions.act_window',
-                'view_mode': 'form',
-                'res_model': 'hr.expense',
-                'res_id': self.expense_line_ids.id,
-            }
-        return {
-            'name': _('Expenses'),
-            'type': 'ir.actions.act_window',
-            'view_mode': 'list,form',
-            'views': [[False, "list"], [False, "form"]],
-            'res_model': 'hr.expense',
-            'domain': [('id', 'in', self.expense_line_ids.ids)],
-        }
-
-    def action_open_account_moves(self):
-        self.ensure_one()
-        if self.payment_mode == 'own_account':
-            res_model = 'account.move'
-            record_ids = self.account_move_ids
-        else:
-            res_model = 'account.payment'
-            record_ids = self.account_move_ids.origin_payment_id
-
-        action = {'type': 'ir.actions.act_window', 'res_model': res_model}
-        if len(self.account_move_ids) == 1:
-            action.update({
-                'name': record_ids.name,
-                'view_mode': 'form',
-                'res_id': record_ids.id,
-                'views': [(False, 'form')],
-            })
-        else:
-            action.update({
-                'name': _("Journal entries"),
-                'view_mode': 'list',
-                'domain': [('id', 'in', record_ids.ids)],
-                'views': [(False, 'list'), (False, 'form')],
-            })
-        return action
-
-    # --------------------------------------------
-    # Business
-    # --------------------------------------------
-
-    def set_to_paid(self):
-        # hook used in other modules to bypass payment registration
-        self.write({'state': 'done'})
-
-    def set_to_posted(self):
-        # hook used in other modules to bypass move creation
-        self.write({'state': 'post'})
-
-    def _check_can_approve(self):
-        if not all(self.mapped('can_approve')):
-            reasons = _("You cannot approve:\n %s", "\n".join(self.mapped('cannot_approve_reason')))
-            raise UserError(reasons)
-
-    def _check_can_refuse(self):
-        if not all(self.mapped('can_approve')):
-            reasons = _("You cannot refuse:\n %s", "\n".join(self.mapped('cannot_approve_reason')))
-            raise UserError(reasons)
-
-    def _check_can_reset_approval(self):
-        if not all(self.mapped('can_reset')):
-            raise UserError(_("Only HR Officers or the concerned employee can reset to draft."))
-
-    def _check_can_create_move(self):
-        if any(not sheet.expense_line_ids for sheet in self):
-            raise UserError(_("You cannot create accounting entries for an expense report without expenses."))
-
-        if any(sheet.state != 'submit' for sheet in self):
-            raise UserError(_("You can only generate an accounting entry for approved expense(s)."))
-
-        if any(not sheet.journal_id for sheet in self):
-            raise UserError(_("Please specify an expense journal in order to generate accounting entries."))
-
-        if False in self.mapped('payment_mode'):
-            raise UserError(_(
-                "Please specify if the expenses for this report were paid by the company, or the employee"
-            ))
-
-        missing_email_employees = self.filtered(lambda sheet: not sheet.employee_id.work_email).employee_id
-        if missing_email_employees:
-            action = self.env['ir.actions.actions']._for_xml_id('hr.open_view_employee_list_my')
-            action['domain'] = [('id', 'in', missing_email_employees.ids)]
-            raise RedirectWarning(_("The work email of some employees is missing. Please add it on the employee form"), action, _("Show missing work email employees"))
-
-    def _do_submit(self):
-        self.approval_state = 'submit'
-        self.sudo().activity_update()
-
-    def _do_approve(self):
-        sheets_to_approve = self.filtered(lambda s: s.state in {'submit', 'draft'})
-        sheets_to_approve._check_can_create_move()
-        sheets_to_approve._do_create_moves()
-        for sheet in sheets_to_approve:
-            sheet.write({
-                'approval_state': 'approve',
-                'user_id': sheet.user_id.id or self.env.user.id,
-                'approval_date': fields.Date.context_today(sheet),
-            })
-        self.activity_update()
-
-    def _do_reset_approval(self):
-        self.sudo().write({'approval_state': False, 'approval_date': False, 'accounting_date': False})
-        self.activity_update()
-
-    def _do_refuse(self, reason):
-        # Sudoed as approvers may not be accountants
-        draft_moves_sudo = self.sudo().account_move_ids.filtered(lambda move: move.state == 'draft')
-        if self.sudo().account_move_ids - draft_moves_sudo:
-            raise UserError(_("You cannot cancel an expense sheet linked to a posted journal entry"))
-
-        if draft_moves_sudo:
-            draft_moves_sudo.unlink()  # Else we have lingering moves
-
-        self.approval_state = 'cancel'
-        subtype_id = self.env['ir.model.data']._xmlid_to_res_id('mail.mt_comment')
-        for sheet in self:
-            sheet.message_post_with_source(
-                'hr_expense.hr_expense_template_refuse_reason',
-                subtype_id=subtype_id,
-                render_values={'reason': reason, 'name': sheet.name},
-            )
-        self.activity_update()
-
-    def _do_create_moves(self):
-        """
-        Creation of the account moves for the expenses report. Sudo-ed as they are created in draft and the manager may not have
-        the accounting rights (and there is no reason to give them those rights).
-        There are two main flows at play:
-            - Expense paid by the company -> Create an account payment (we only "log" the already paid expense so it can be reconciled)
-            - Expense paid by he employee's own account -> As it should be reimbursed to them, it creates a vendor bill.
-        """
-        self = self.with_context(clean_context(self.env.context))  # remove default_*
-        own_account_sheets = self.filtered(lambda sheet: sheet.payment_mode == 'own_account')
-        company_account_sheets = self - own_account_sheets
-
-        for sheet in own_account_sheets:
-            sheet.accounting_date = sheet.accounting_date or sheet._calculate_default_accounting_date()
-        moves_sudo = self.env['account.move'].sudo().create([sheet._prepare_bills_vals() for sheet in own_account_sheets])
-        for move_sudo in moves_sudo:
-            move_sudo._message_set_main_attachment_id(move_sudo.attachment_ids, force=True, filter_xml=False)
-        if company_account_sheets:
-            move_vals_list, payment_vals_list = zip(*[
-                expense._prepare_payments_vals()
-                for expense in company_account_sheets.expense_line_ids
-            ])
-
-            payment_moves_sudo = self.env['account.move'].sudo().create(move_vals_list)
-            for payment_vals, move in zip(payment_vals_list, payment_moves_sudo):
-                payment_vals['move_id'] = move.id
-
-            payments_sudo = self.env['account.payment'].sudo().create(payment_vals_list)
-            for payment_sudo, move_sudo in zip(payments_sudo, payment_moves_sudo):
-                move_sudo.update({
-                    'origin_payment_id': payment_sudo.id,
-                    # We need to put the journal_id because editing origin_payment_id triggers a re-computation chain
-                    # that voids the company_currency_id of the lines
-                    'journal_id': move_sudo.journal_id.id,
-                })
-
-            moves_sudo |= payment_moves_sudo
-
-        # returning the move with the super user flag set back as it was at the origin of the call
-        return moves_sudo.sudo(self.env.su)
-
-    def _do_reverse_moves(self):
-        self = self.with_context(clean_context(self.env.context))
-        moves = self.account_move_ids
-        draft_moves = moves.filtered(lambda m: m.state == 'draft')
-        non_draft_moves = moves - draft_moves
-        non_draft_moves._reverse_moves(
-            default_values_list=[{'invoice_date': fields.Date.context_today(move), 'ref': False} for move in non_draft_moves],
-            cancel=True
-        )
-        draft_moves.unlink()
-
-    def _calculate_default_accounting_date(self):
-        """
-        Calculate the default accounting date for the expenses paid by employees
-        """
-        self.ensure_one()
-        today = fields.Date.context_today(self)
-        start_month = fields.Date.start_of(today, "month")
-        end_month = fields.Date.end_of(today, "month")
-        most_recent_expense = max(self.expense_line_ids.filtered(lambda exp: exp.date).mapped('date'), default=today)
-
-        if most_recent_expense > end_month:
-            return most_recent_expense
-
-        if most_recent_expense >= start_month:
-            return today
-
-        lock_date = self.company_id._get_user_fiscal_lock_date(self.journal_id)
-
-        return min(
-            max(
-                fields.Date.end_of(most_recent_expense, "month"),
-                fields.Date.end_of(fields.Date.add(lock_date, months=1), "month")
-            ),
-            today
-        )
-
-    def _prepare_bills_vals(self):
-        self.ensure_one()
-        move_vals = self._prepare_move_vals()
-        if self.employee_id.sudo().bank_account_id:
-            move_vals['partner_bank_id'] = self.employee_id.sudo().bank_account_id.id
-        return {
-            **move_vals,
-            'journal_id': self.journal_id.id,
-            'ref': self.name,
-            'move_type': 'in_invoice',
-            'partner_id': self.employee_id.sudo().work_contact_id.id,
-            'commercial_partner_id': self.employee_id.user_partner_id.id,
-            'currency_id': self.currency_id.id,
-            'line_ids': [Command.create(expense._prepare_move_lines_vals()) for expense in self.expense_line_ids],
-            'attachment_ids': [
-                Command.create(attachment.copy_data({'res_model': 'account.move', 'res_id': False, 'raw': attachment.raw})[0])
-                for attachment in self.expense_line_ids.message_main_attachment_id
-            ],
-        }
-
-    def _prepare_move_vals(self):
-        self.ensure_one()
-        to_return = {
-            # force the name to the default value, to avoid an eventual 'default_name' in the context
-            # to set it to '' which cause no number to be given to the account.move when posted.
-            'name': '/',
-            'expense_sheet_id': self.id,
-        }
-
-        today = fields.Date.context_today(self)
-        most_recent_expense = max(self.expense_line_ids.filtered(lambda exp: exp.date).mapped('date'), default=today)
-
-        if self.payment_mode == 'company_account':
-            to_return['date'] = most_recent_expense
-        else:
-            to_return['invoice_date'] = self.accounting_date
-
-        return to_return
-
-    def _validate_analytic_distribution(self):
-        for line in self.expense_line_ids:
-            line._validate_distribution(account=line.account_id.id, product=line.product_id.id, business_domain='expense', company_id=line.company_id.id)
-
-    def _get_responsible_for_approval(self):
-        if self.user_id:
-            return self.user_id
-        if self.employee_id.parent_id.user_id:
-            return self.employee_id.parent_id.user_id
-        if self.employee_id.department_id.manager_id.user_id:
-            return self.employee_id.department_id.manager_id.user_id
-        return self.env['res.users']
-
-    def _get_expense_account_destination(self):
-        self.ensure_one()
-        if self.payment_mode == 'company_account':
-            journal = self.payment_method_line_id.journal_id
-            account_dest = (
-                self.payment_method_line_id.payment_account_id
-                or journal.company_id.expense_outstanding_account_id
-            )
-            if not account_dest:
-                error_msg = _(
-                    "A default outstanding account must be defined in the settings for company-paid expenses. "
-                    "Or specify one in the Journal for the %(method)s payment method.",
-                    method=self.payment_method_line_id.display_name,
-                )
-                if self.env['res.config.settings'].has_access('write'):
-                    action = self.env.ref('hr_expense.action_hr_expense_configuration')
-                    raise RedirectWarning(error_msg, action=action.id, button_text=_("Go to settings"))
-                else:
-                    raise UserError(error_msg)
-        else:
-            if not self.employee_id.sudo().work_contact_id:
-                raise UserError(_("No work contact found for the employee %s, please configure one.", self.employee_id.name))
-            partner = self.employee_id.sudo().work_contact_id.with_company(self.company_id)
-            account_dest = partner.property_account_payable_id or partner.parent_id.property_account_payable_id
-        return account_dest.id

--- a/addons/hr_expense/models/ir_actions_report.py
+++ b/addons/hr_expense/models/ir_actions_report.py
@@ -13,14 +13,13 @@ class IrActionsReport(models.Model):
         if not res_ids:
             return res
         report = self._get_report(report_ref)
-        if report.report_name == 'hr_expense.report_expense_sheet':
-            expense_sheets = self.env['hr.expense.sheet'].browse(res_ids)
-            for expense_sheet in expense_sheets:
-                # Will contains the expense report
+        if report.report_name == 'hr_expense.report_expense':
+            for expense in self.env['hr.expense'].browse(res_ids):
+                # Will contains the expense
                 stream_list = []
-                stream = res[expense_sheet.id]['stream']
+                stream = res[expense.id]['stream']
                 stream_list.append(stream)
-                attachments = self.env['ir.attachment'].search([('res_id', 'in', expense_sheet.expense_line_ids.ids), ('res_model', '=', 'hr.expense')])
+                attachments = self.env['ir.attachment'].search([('res_id', 'in', expense.ids), ('res_model', '=', 'hr.expense')])
                 expense_report = OdooPdfFileReader(stream, strict=False)
                 output_pdf = OdooPdfFileWriter()
                 output_pdf.appendPagesFromReader(expense_report)
@@ -28,19 +27,19 @@ class IrActionsReport(models.Model):
                     if attachment.mimetype == 'application/pdf':
                         attachment_stream = pdf.to_pdf_stream(attachment)
                     else:
-                        # In case the attachment is not a pdf we will create a new PDF from the template "report_expense_sheet_img"
+                        # In case the attachment is not a pdf we will create a new PDF from the template "report_expense_img"
                         # And then append to the stream. By doing so, the attachment is put on a new page with the name of the expense
                         # associated to the attachment
                         data['attachment'] = attachment
-                        attachment_prep_stream = self._render_qweb_pdf_prepare_streams('hr_expense.report_expense_sheet_img', data, res_ids=res_ids)
-                        attachment_stream = attachment_prep_stream[expense_sheet.id]['stream']
+                        attachment_prep_stream = self._render_qweb_pdf_prepare_streams('hr_expense.report_expense_img', data, res_ids=res_ids)
+                        attachment_stream = attachment_prep_stream[expense.id]['stream']
                     attachment_reader = OdooPdfFileReader(attachment_stream, strict=False)
                     output_pdf.appendPagesFromReader(attachment_reader)
                     stream_list.append(attachment_stream)
 
                 new_pdf_stream = io.BytesIO()
                 output_pdf.write(new_pdf_stream)
-                res[expense_sheet.id]['stream'] = new_pdf_stream
+                res[expense.id]['stream'] = new_pdf_stream
 
                 for stream in stream_list:
                     stream.close()

--- a/addons/hr_expense/models/ir_attachment.py
+++ b/None
@@ -1,39 +0,0 @@
-from odoo import models, api
-
-
-class IrAttachment(models.Model):
-    _inherit = 'ir.attachment'
-
-    @api.model_create_multi
-    def create(self, vals_list):
-        attachments = super().create(vals_list)
-        if self.env.context.get('sync_attachment', True):
-            expenses_attachments = attachments.filtered(lambda att: att.res_model == 'hr.expense')
-            if expenses_attachments:
-                expenses = self.env['hr.expense'].browse(expenses_attachments.mapped('res_id'))
-                for expense in expenses.filtered('sheet_id'):
-                    checksums = set(expense.sheet_id.attachment_ids.mapped('checksum'))
-                    for attachment in expense.attachment_ids.filtered(lambda att: att.checksum not in checksums):
-                        attachment.copy({
-                            'res_model': 'hr.expense.sheet',
-                            'res_id': expense.sheet_id.id,
-                        })
-        return attachments
-
-    def unlink(self):
-        if self.env.context.get('sync_attachment', True):
-            attachments_to_unlink = self.env['ir.attachment']
-            expenses_attachments = self.filtered(lambda att: att.res_model == 'hr.expense')
-            if expenses_attachments:
-                expenses = self.env['hr.expense'].browse(expenses_attachments.mapped('res_id'))
-                for expense in expenses.exists().filtered('sheet_id'):
-                    checksums = set(expense.attachment_ids.mapped('checksum'))
-                    attachments_to_unlink += expense.sheet_id.attachment_ids.filtered(lambda att: att.checksum in checksums)
-            sheets_attachments = self.filtered(lambda att: att.res_model == 'hr.expense.sheet')
-            if sheets_attachments:
-                sheets = self.env['hr.expense.sheet'].browse(sheets_attachments.mapped('res_id'))
-                for sheet in sheets.exists():
-                    checksums = set((sheet.attachment_ids & sheets_attachments).mapped('checksum'))
-                    attachments_to_unlink += sheet.expense_line_ids.attachment_ids.filtered(lambda att: att.checksum in checksums)
-            super(IrAttachment, attachments_to_unlink).unlink()
-        return super().unlink()

--- a/addons/hr_expense/models/product_product.py
+++ b/addons/hr_expense/models/product_product.py
@@ -9,10 +9,10 @@ class ProductProduct(models.Model):
     @api.onchange('standard_price')
     def _compute_standard_price_update_warning(self):
         undone_expenses = self.env['hr.expense']._read_group(
-            domain=[('state', 'in', ['draft', 'reported']), ('product_id', 'in', self.ids)],
+            domain=[('state', '=', 'draft'), ('product_id', 'in', self.ids)],
             groupby=['price_unit'],
             )
-        # The following list is composed of all the unit_amounts of expenses that use this product and should NOT trigger a warning.
+        # The following list is composed of all the price_units of expenses that use this product and should NOT trigger a warning.
         # Those are the amounts of any undone expense using this product and 0.0 which is the default unit_amount.
         unit_amounts_no_warning = [self.env.company.currency_id.round(row[0]) for row in undone_expenses]
         for product in self:
@@ -31,7 +31,7 @@ class ProductProduct(models.Model):
             expenses_sudo = self.env['hr.expense'].sudo().search([
                 ('company_id', '=', self.env.company.id),
                 ('product_id', 'in', self.ids),
-                ('state', 'in', ['reported', 'draft']),
+                ('state', '=', 'draft'),
             ])
             for expense_sudo in expenses_sudo:
                 expense_product_sudo = expense_sudo.product_id

--- a/addons/hr_expense/models/res_config_settings.py
+++ b/addons/hr_expense/models/res_config_settings.py
@@ -1,5 +1,3 @@
-# -*- coding: utf-8 -*-
-
 from odoo import api, fields, models
 
 
