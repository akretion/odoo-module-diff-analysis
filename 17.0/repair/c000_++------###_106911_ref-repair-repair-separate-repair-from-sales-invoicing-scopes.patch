PR: https://github.com/odoo/odoo/pull/106911

From: eaa6e1a08c3d2cdcb558689523e5bd332978f5e4
From: Mathias Mathy (MAMA)
Date: 2023-07-20 15:01:00

Breaking data model changes scores: del:77 + add:3, change matches:
-    _inherit = 'account.move'
-    repair_ids = fields.One2many('repair.order', 'invoice_id', readonly=True, copy=False)
-    _inherit = 'account.move.line'
-    repair_line_ids = fields.One2many('repair.line', 'invoice_line_id', readonly=True, copy=False)
-    repair_fee_ids = fields.One2many('repair.fee', 'invoice_line_id', readonly=True, copy=False)
-    _inherit = 'stock.move'
-    description = fields.Char('Repair Description')
-    address_id = fields.Many2one(
-    default_address_id = fields.Many2one('res.partner', compute='_compute_default_address_id')
-    schedule_date = fields.Date("Scheduled Date")
+    tag_ids = fields.Many2many('repair.tags', string="Tags")
-    guarantee_limit = fields.Date('Warranty Expiration', states={'confirmed': [('readonly', True)]})
-    operations = fields.One2many(
-    pricelist_id = fields.Many2one(
-    currency_id = fields.Many2one(
-    partner_invoice_id = fields.Many2one('res.partner', 'Invoicing Address', check_company=True)
-    invoice_method = fields.Selection([
-    invoice_id = fields.Many2one(
-    move_id = fields.Many2one(
-    fees_lines = fields.One2many(
-    internal_notes = fields.Html('Internal Notes')
-    quotation_notes = fields.Html('Quotation Notes')
-    user_id = fields.Many2one('res.users', string="Responsible", default=lambda self: self.env.user, check_company=True)
-    company_id = fields.Many2one(
+    move_ids = fields.One2many(
-    tag_ids = fields.Many2many('repair.tags', string="Tags")
-    invoiced = fields.Boolean('Invoiced', copy=False, readonly=True)
-    repaired = fields.Boolean('Repaired', copy=False, readonly=True)
-    amount_untaxed = fields.Float('Untaxed Amount', compute='_amount_untaxed', store=True)
-    amount_tax = fields.Float('Taxes', compute='_amount_tax', store=True)
-    amount_total = fields.Float('Total', compute='_amount_total', store=True)
-    tracking = fields.Selection(string='Product Tracking', related="product_id.tracking", readonly=False)
-    invoice_state = fields.Selection(string='Invoice State', related='invoice_id.state')
-    priority = fields.Selection([('0', 'Normal'), ('1', 'Urgent')], default='0', string="Priority")
-    tax_calculation_rounding_method = fields.Selection(
-    name = fields.Text('Description', required=True)
-    repair_id = fields.Many2one(
-    company_id = fields.Many2one(
-    currency_id = fields.Many2one(
-    type = fields.Selection([
-    product_id = fields.Many2one(
-    invoiced = fields.Boolean('Invoiced', copy=False, readonly=True)
-    price_unit = fields.Float('Unit Price', required=True, digits='Product Price')
-    price_subtotal = fields.Float('Subtotal', compute='_compute_price_total_and_subtotal', store=True, digits=0)
-    price_total = fields.Float('Total', compute='_compute_price_total_and_subtotal', store=True, digits=0)
-    tax_id = fields.Many2many(
-    product_uom_qty = fields.Float(
-    product_uom = fields.Many2one(
-    product_uom_category_id = fields.Many2one(related='product_id.uom_id.category_id')
-    invoice_line_id = fields.Many2one(
-    location_id = fields.Many2one(
-    location_dest_id = fields.Many2one(
-    move_id = fields.Many2one(
-    lot_id = fields.Many2one(
-    state = fields.Selection([
-    tracking = fields.Selection(string='Product Tracking', related="product_id.tracking")
-    tax_calculation_rounding_method = fields.Selection(
-    repair_id = fields.Many2one(
-    company_id = fields.Many2one(
-    currency_id = fields.Many2one(
-    name = fields.Text('Description', index=True, required=True)
-    product_id = fields.Many2one(
-    product_uom_qty = fields.Float('Quantity', digits='Product Unit of Measure', required=True, default=1.0)
-    price_unit = fields.Float('Unit Price', required=True, digits='Product Price')
-    product_uom = fields.Many2one(
-    product_uom_category_id = fields.Many2one(related='product_id.uom_id.category_id')
-    price_subtotal = fields.Float('Subtotal', compute='_compute_price_total_and_subtotal', store=True, digits=0)
-    price_total = fields.Float('Total', compute='_compute_price_total_and_subtotal', store=True, digits=0)
-    tax_id = fields.Many2many(
-    invoice_line_id = fields.Many2one('account.move.line', 'Invoice Line', copy=False, readonly=True, check_company=True)
-    invoiced = fields.Boolean('Invoiced', copy=False, readonly=True)
+    repair_order_ids = fields.One2many(

Total Changes: 1702

[REF] repair, *_repair: Separate Repair from Sales/Invoicing scopes

Main changes include :
 - Separate Repair and Sales/Invoicing functionalities
 - Possible binding between a Sale Order and many Repair Orders
 - Specific 'repair.line' model is now replaced by a 'stock.move' inheritance
 - Added a new 'Repairs' Operation Type to warehouse(s)

Task : 3046560

Enterprise : odoo/enterprise#36088
Upgrade : odoo/upgrade#4391

closes odoo/odoo#106911

Signed-off-by: Arnold Moyaux (arm) <arm@odoo.com>

================================= pseudo patch: =================================

--- a/addons/repair/models/__init__.py
+++ b/addons/repair/models/__init__.py
@@ -2,9 +2,10 @@
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
 from . import repair
+from . import stock_move
 from . import stock_picking
 from . import stock_traceability
 from . import stock_lot
-from . import account_move
 from . import product
-from . import mail_compose_message
+from . import sale_order
+from . import stock_warehouse

--- a/addons/repair/models/account_move.py
+++ b/None
@@ -1,22 +0,0 @@
-# -*- coding: utf-8 -*-
-
-from odoo import models, fields
-
-
-class AccountMove(models.Model):
-    _inherit = 'account.move'
-
-    repair_ids = fields.One2many('repair.order', 'invoice_id', readonly=True, copy=False)
-
-    def unlink(self):
-        repairs = self.sudo().repair_ids.filtered(lambda repair: repair.state != 'cancel')
-        if repairs:
-            repairs.sudo(False).state = '2binvoiced'
-        return super().unlink()
-
-
-class AccountMoveLine(models.Model):
-    _inherit = 'account.move.line'
-
-    repair_line_ids = fields.One2many('repair.line', 'invoice_line_id', readonly=True, copy=False)
-    repair_fee_ids = fields.One2many('repair.fee', 'invoice_line_id', readonly=True, copy=False)

--- a/addons/repair/models/product.py
+++ b/addons/repair/models/product.py
@@ -1,18 +1,24 @@
 # -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
-from odoo import models
+from odoo import fields, models
 
 
 class Product(models.Model):
     _inherit = "product.product"
 
     def _count_returned_sn_products(self, sn_lot):
-        res = self.env['repair.line'].search_count([
-            ('type', '=', 'remove'),
+        res = self.env['stock.move'].search_count([
+            ('repair_line_type', '=', 'remove'),
             ('product_uom_qty', '=', 1),
-            ('lot_id', '=', sn_lot.id),
+            ('move_line_ids.lot_id', 'in', sn_lot.id),
             ('state', '=', 'done'),
-            ('location_dest_id.usage', '=', 'internal'),
+            ('location_dest_usage', '=', 'internal'),
         ])
         return super()._count_returned_sn_products(sn_lot) + res
+
+
+class ProductTemplate(models.Model):
+    _inherit = "product.template"
+
+    create_repair = fields.Boolean('Create Repair', help="Create a linked Repair Order on Sale Order confirmation of this product.", groups='stock.group_stock_user')

--- a/addons/repair/models/repair.py
+++ b/addons/repair/models/repair.py
@@ -1,125 +1,157 @@
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
-from collections import defaultdict
 from random import randint
 
-from markupsafe import Markup
-
-from odoo import api, fields, models, _
+from odoo import api, Command, fields, models, _
 from odoo.exceptions import UserError, ValidationError
-from odoo.tools import float_compare, is_html_empty
-
+from odoo.tools import float_compare, float_is_zero
+from odoo.tools.misc import format_date, groupby
 
-class StockMove(models.Model):
-    _inherit = 'stock.move'
-
-    repair_id = fields.Many2one('repair.order', check_company=True)
+MAP_REPAIR_TO_PICKING_LOCATIONS = {
+    'location_id': 'default_location_src_id',
+    'location_dest_id': 'default_location_dest_id',
+    'parts_location_id': 'default_remove_location_dest_id',
+    'recycle_location_id': 'default_recycle_location_dest_id',
+}
 
 
 class Repair(models.Model):
+    """ Repair Orders """
     _name = 'repair.order'
     _description = 'Repair Order'
     _inherit = ['mail.thread', 'mail.activity.mixin']
     _order = 'priority desc, create_date desc'
     _check_company_auto = True
 
+    @api.model
+    def _default_picking_type_id(self):
+        return self._get_picking_type().get((self.env.company, self.env.user))
+
+    # Common Fields
     name = fields.Char(
         'Repair Reference',
         default='New', index='trigram',
         copy=False, required=True,
         readonly=True)
-    description = fields.Char('Repair Description')
-    product_id = fields.Many2one(
-        'product.product', string='Product to Repair',
-        check_company=True,
-        domain="[('type', 'in', ['product', 'consu'])]",
-        readonly=True, required=True, states={'draft': [('readonly', False)]})
-    product_qty = fields.Float(
-        'Product Quantity',
-        default=1.0, digits='Product Unit of Measure',
-        readonly=True, required=True, states={'draft': [('readonly', False)]})
-    product_uom = fields.Many2one(
-        'uom.uom', 'Product Unit of Measure',
-        compute='_compute_product_uom', store=True, precompute=True,
-        readonly=True, required=True, states={'draft': [('readonly', False)]}, domain="[('category_id', '=', product_uom_category_id)]")
-    product_uom_category_id = fields.Many2one(related='product_id.uom_id.category_id')
-    partner_id = fields.Many2one(
-        'res.partner', 'Customer',
-        index=True, states={'confirmed': [('readonly', True)]}, check_company=True, change_default=True,
-        help='Choose partner for whom the order will be invoiced and delivered. You can find a partner by its Name, TIN, Email or Internal Reference.')
-    address_id = fields.Many2one(
-        'res.partner', 'Delivery Address',
-        domain="[('parent_id','=',partner_id)]", check_company=True,
-        states={'confirmed': [('readonly', True)]})
-    default_address_id = fields.Many2one('res.partner', compute='_compute_default_address_id')
+    company_id = fields.Many2one(
+        'res.company', 'Company',
+        readonly=True, required=True, index=True,
+        default=lambda self: self.env.company)
     state = fields.Selection([
-        ('draft', 'Quotation'),
+        ('draft', 'New'),
         ('confirmed', 'Confirmed'),
-        ('ready', 'Ready to Repair'),
         ('under_repair', 'Under Repair'),
-        ('2binvoiced', 'To be Invoiced'),
         ('done', 'Repaired'),
         ('cancel', 'Cancelled')], string='Status',
-        copy=False, default='draft', readonly=True, tracking=True,
-        help="* The \'Draft\' status is used when a user is encoding a new and unconfirmed repair order.\n"
+        copy=False, default='draft', readonly=True, tracking=True, index=True,
+        help="* The \'New\' status is used when a user is encoding a new and unconfirmed repair order.\n"
              "* The \'Confirmed\' status is used when a user confirms the repair order.\n"
-             "* The \'Ready to Repair\' status is used to start to repairing, user can start repairing only after repair order is confirmed.\n"
              "* The \'Under Repair\' status is used when the repair is ongoing.\n"
-             "* The \'To be Invoiced\' status is used to generate the invoice before or after repairing done.\n"
-             "* The \'Done\' status is set when repairing is completed.\n"
+             "* The \'Repaired\' status is set when repairing is completed.\n"
              "* The \'Cancelled\' status is used when user cancel repair order.")
-    schedule_date = fields.Date("Scheduled Date")
-    location_id = fields.Many2one(
-        'stock.location', 'Location',
-        compute="_compute_location_id", store=True, precompute=True,
-        index=True, readonly=True, required=True, check_company=True,
-        help="This is the location where the product to repair is located.",
-        states={'draft': [('readonly', False)], 'confirmed': [('readonly', True)]})
+    priority = fields.Selection([('0', 'Normal'), ('1', 'Urgent')], default='0', string="Priority")
+    partner_id = fields.Many2one(
+        'res.partner', 'Customer',
+        index=True, check_company=True, change_default=True,
+        help='Choose partner for whom the order will be invoiced and delivered. You can find a partner by its Name, TIN, Email or Internal Reference.')
+    user_id = fields.Many2one('res.users', string="Responsible", default=lambda self: self.env.user, check_company=True)
+
+    # Specific Fields
+    internal_notes = fields.Html('Internal Notes')
+    tag_ids = fields.Many2many('repair.tags', string="Tags")
+    under_warranty = fields.Boolean(
+        'Under Warranty',
+        help='If ticked, the sales price will be set to 0 for all products transferred from the repair order.',
+        states={'done': [('readonly', True)], 'cancel': [('readonly', True)]})
+    schedule_date = fields.Datetime("Scheduled Date", default=fields.Datetime.now, index=True, required=True, copy=False)
+
+    # Product To Repair
+    move_id = fields.Many2one(  # Generated in 'action_repair_done', needed for traceability
+        'stock.move', 'Inventory Move',
+        copy=False, readonly=True, tracking=True, check_company=True)
+    product_id = fields.Many2one(
+        'product.product', string='Product to Repair',
+        domain="[('type', 'in', ['product', 'consu']), '|', ('company_id', '=', company_id), ('company_id', '=', False)]",
+        states={'done': [('readonly', True)], 'cancel': [('readonly', True)]}, check_company=True)
+    product_qty = fields.Float(
+        'Product Quantity',
+        default=1.0, digits='Product Unit of Measure',
+        readonly=True, states={'draft': [('readonly', False)]})
+    product_uom = fields.Many2one(
+        'uom.uom', 'Product Unit of Measure',
+        compute='compute_product_uom', store=True, precompute=True,
+        readonly=True, states={'draft': [('readonly', False)]}, domain="[('category_id', '=', product_uom_category_id)]")
+    product_uom_category_id = fields.Many2one(related='product_id.uom_id.category_id')
     lot_id = fields.Many2one(
         'stock.lot', 'Lot/Serial',
+        default=False,
+        compute="compute_lot_id", store=True,
         domain="[('product_id','=', product_id), ('company_id', '=', company_id)]", check_company=True,
         help="Products repaired are all belonging to this lot")
-    guarantee_limit = fields.Date('Warranty Expiration', states={'confirmed': [('readonly', True)]})
-    operations = fields.One2many(
-        'repair.line', 'repair_id', 'Parts',
-        copy=True)
-    pricelist_id = fields.Many2one(
-        'product.pricelist', 'Pricelist',
-        help='Pricelist of the selected partner.', check_company=True)
-    currency_id = fields.Many2one(
-        comodel_name='res.currency',
-        compute='_compute_currency_id',
-        store=True,
-        precompute=True,
-        ondelete='restrict')
-    partner_invoice_id = fields.Many2one('res.partner', 'Invoicing Address', check_company=True)
-    invoice_method = fields.Selection([
-        ("none", "No Invoice"),
-        ("b4repair", "Before Repair"),
-        ("after_repair", "After Repair")], string="Invoice Method",
-        default='none', index=True, readonly=True, required=True,
-        states={'draft': [('readonly', False)]},
-        help='Selecting \'Before Repair\' or \'After Repair\' will allow you to generate invoice before or after the repair is done respectively. \'No invoice\' means you don\'t want to generate invoice for this repair order.')
-    invoice_id = fields.Many2one(
-        'account.move', 'Invoice',
-        copy=False, readonly=True, tracking=True,
-        domain=[('move_type', '=', 'out_invoice')])
-    move_id = fields.Many2one(
-        'stock.move', 'Inventory Move',
-        copy=False, readonly=True, tracking=True, check_company=True)
-    fees_lines = fields.One2many(
-        'repair.fee', 'repair_id', 'Operations',
-        copy=True, readonly=False)
-    internal_notes = fields.Html('Internal Notes')
-    quotation_notes = fields.Html('Quotation Notes')
-    user_id = fields.Many2one('res.users', string="Responsible", default=lambda self: self.env.user, check_company=True)
-    company_id = fields.Many2one(
-        'res.company', 'Company',
-        readonly=True, required=True, index=True,
-        default=lambda self: self.env.company)
+    tracking = fields.Selection(string='Product Tracking', related="product_id.tracking", readonly=False)
+
+    # Picking & Locations
+    picking_type_id = fields.Many2one(
+        'stock.picking.type', 'Operation Type', copy=True, readonly=False,
+        compute='_compute_picking_type_id', store=True,
+        default=_default_picking_type_id,
+        domain="[('code', '=', 'repair_operation'), ('company_id', '=', company_id)]",
+        required=True, check_company=True, index=True)
+    procurement_group_id = fields.Many2one(
+        'procurement.group', 'Procurement Group',
+        copy=False)
+    location_id = fields.Many2one(
+        'stock.location', 'Product to Repair Source & Destination Location',
+        compute="_compute_location_ids", store=True,
+        index=True, readonly=False, check_company=True, required=True,
+        help="This is the location where the product to repair is located.")
+    location_dest_id = fields.Many2one(
+        'stock.location', 'Added Parts Destination Location',
+        compute="_compute_location_ids", store=True,
+        index=True, readonly=True, check_company=True, required=True,
+        help="This is the location where the repaired product is located.")
+    parts_location_id = fields.Many2one(
+        'stock.location', 'Removed Parts Destination Location',
+        compute="_compute_location_ids", store=True,
+        index=True, readonly=True, check_company=True, required=True,
+        help="This is the location where the repair parts are located.")
+    recycle_location_id = fields.Many2one(
+        'stock.location', 'Recycled Parts Destination Location',
+        compute="_compute_location_ids", store=True,
+        index=True, readonly=False, check_company=True, required=True,
+        help="This is the location where the repair parts are located.")
+
+    # Parts
+    move_ids = fields.One2many(
+        'stock.move', 'repair_id', "Parts", check_company=True, copy=True,
+        domain=[('repair_line_type', '!=', False)])  # Once RO switch to state done, a binded move is created for the "Product to repair" (move_id), this move appears in 'move_ids' if not filtered
+    parts_availability = fields.Char(
+        string="Component Status", compute='_compute_parts_availability',
+        help="Latest parts availability status for this RO. If green, then the RO's readiness status is ready.")
+    parts_availability_state = fields.Selection([
+        ('available', 'Available'),
+        ('expected', 'Expected'),
+        ('late', 'Late')], compute='_compute_parts_availability')
+    is_parts_available = fields.Boolean(
+        'All Parts are available',
+        default=False, store=True, compute='_compute_availability_boolean')
+    is_parts_late = fields.Boolean(
+        'Any Part is late',
+        default=False, store=True, compute='_compute_availability_boolean')
+
+    # Sale Order Binding
     sale_order_id = fields.Many2one(
-        'sale.order', 'Sale Order', check_company=True,
-        copy=False, help="Sale Order from which the product to be repaired comes from.")
+        'sale.order', 'Sale Order', check_company=True, readonly=True,
+        copy=False, help="Sale Order from which the Repair Order comes from.")
+    sale_order_line_id = fields.Many2one(
+        'sale.order.line', check_company=True, readonly=True,
+        copy=False, help="Sale Order Line from which the Repair Order comes from.")
+    repair_request = fields.Char(
+        related='sale_order_line_id.product_id.display_name',
+        string='Repair Request',
+        help="Product from which the Repair Order was created.")
+
+    # Return Binding
     picking_id = fields.Many2one(
         'stock.picking', 'Return', check_company=True,
         copy=False, help="Return Order from which the product to be repaired comes from.")
@@ -127,101 +159,113 @@ class Repair(models.Model):
     is_returned = fields.Boolean(
         "Returned", compute='_compute_is_returned',
         help="True if this repair is linked to a Return Order and the order is 'Done'. False otherwise.")
-    tag_ids = fields.Many2many('repair.tags', string="Tags")
-    invoiced = fields.Boolean('Invoiced', copy=False, readonly=True)
-    repaired = fields.Boolean('Repaired', copy=False, readonly=True)
-    amount_untaxed = fields.Float('Untaxed Amount', compute='_amount_untaxed', store=True)
-    amount_tax = fields.Float('Taxes', compute='_amount_tax', store=True)
-    amount_total = fields.Float('Total', compute='_amount_total', store=True)
-    tracking = fields.Selection(string='Product Tracking', related="product_id.tracking", readonly=False)
-    invoice_state = fields.Selection(string='Invoice State', related='invoice_id.state')
-    priority = fields.Selection([('0', 'Normal'), ('1', 'Urgent')], default='0', string="Priority")
-    tax_calculation_rounding_method = fields.Selection(
-        related='company_id.tax_calculation_rounding_method',
-        string='Tax calculation rounding method', readonly=True)
+
+    # UI Fields
+    show_set_qty_button = fields.Boolean(compute='_compute_show_qty_button')
+    show_clear_qty_button = fields.Boolean(compute='_compute_show_qty_button')
+    unreserve_visible = fields.Boolean(
+        'Allowed to Unreserve Production', compute='_compute_unreserve_visible',
+        help='Technical field to check when we can unreserve')
+    reserve_visible = fields.Boolean(
+        'Allowed to Reserve Production', compute='_compute_unreserve_visible',
+        help='Technical field to check when we can reserve quantities')
+
+    @api.depends('product_id', 'product_id.uom_id.category_id', 'product_uom.category_id')
+    def compute_product_uom(self):
+        for repair in self:
+            if not repair.product_id:
+                repair.product_uom = False
+            elif not repair.product_uom or repair.product_uom.category_id != repair.product_id.uom_id.category_id:
+                repair.product_uom = repair.product_id.uom_id
+
+    @api.depends('product_id', 'lot_id', 'lot_id.product_id')
+    def compute_lot_id(self):
+        for repair in self:
+            if (repair.product_id and repair.lot_id and repair.lot_id.product_id != repair.product_id) or not repair.product_id:
+                repair.lot_id = False
+
+    @api.depends('user_id', 'company_id')
+    def _compute_picking_type_id(self):
+        picking_type_by_company = self._get_picking_type()
+        for ro in self:
+            ro.picking_type_id = picking_type_by_company.get((ro.company_id, ro.user_id)) or\
+                picking_type_by_company.get((ro.company_id, False))
+
+    @api.depends('picking_type_id')
+    def _compute_location_ids(self):
+        for repair_location_field, picking_location_field in MAP_REPAIR_TO_PICKING_LOCATIONS.items():
+            self[repair_location_field] = self.picking_type_id[picking_location_field]
+
+    @api.depends('state', 'schedule_date', 'move_ids', 'move_ids.forecast_availability', 'move_ids.forecast_expected_date')
+    def _compute_parts_availability(self):
+        repairs = self.filtered(lambda ro: ro.state in ('confirmed', 'under_repair'))
+        repairs.parts_availability_state = 'available'
+        repairs.parts_availability = _('Available')
+
+        other_repairs = self - repairs
+        other_repairs.parts_availability = False
+        other_repairs.parts_availability_state = False
+
+        all_moves = repairs.move_ids
+        # Force to prefetch more than 1000 by 1000
+        all_moves._fields['forecast_availability'].compute_value(all_moves)
+        for repair in repairs:
+            if any(float_compare(move.forecast_availability, move.product_qty, precision_rounding=move.product_id.uom_id.rounding) < 0 for move in repair.move_ids):
+                repair.parts_availability = _('Not Available')
+                repair.parts_availability_state = 'late'
+                continue
+            forecast_date = max(repair.move_ids.filtered('forecast_expected_date').mapped('forecast_expected_date'), default=False)
+            if not forecast_date:
+                continue
+            repair.parts_availability = _('Exp %s', format_date(self.env, forecast_date))
+            if repair.schedule_date:
+                repair.parts_availability_state = 'late' if forecast_date > repair.schedule_date else 'expected'
+
+    @api.depends('parts_availability_state')
+    def _compute_availability_boolean(self):
+        self.is_parts_available, self.is_parts_late = False, False
+        for repair in self:
+            if not repair.parts_availability_state:
+                continue
+            if repair.parts_availability_state == 'available':
+                repair.is_parts_available = True
+            elif repair.parts_availability_state == 'late':
+                repair.is_parts_late = True
 
     @api.depends('product_id')
     def _compute_allowed_picking_type_ids(self):
-        '''
-            computes the ids of return picking types
-        '''
-        out_picking_types = self.env['stock.picking.type'].search_read(domain=[('code', '=', 'outgoing')],
-                                                                          fields=['return_picking_type_id'], load='')
+        """Computes the ids of return picking types
+        """
+        out_picking_types = self.env['stock.picking.type'].search_read(
+            domain=[('code', '=', 'outgoing')], fields=['return_picking_type_id'], load='')
         self.allowed_picking_type_ids = [
             pt['return_picking_type_id'] for pt in out_picking_types if pt['return_picking_type_id']]
 
-    @api.depends('partner_id')
-    def _compute_default_address_id(self):
-        for order in self:
-            if order.partner_id:
-                order.default_address_id = order.partner_id.address_get(['contact'])['contact']
-
-    @api.depends('pricelist_id', 'company_id')
-    def _compute_currency_id(self):
-        for order in self:
-            order.currency_id = order.pricelist_id.currency_id.id or order.company_id.currency_id.id
-
     @api.depends('picking_id', 'picking_id.state')
     def _compute_is_returned(self):
         self.is_returned = False
         returned = self.filtered(lambda r: r.picking_id and r.picking_id.state == 'done')
         returned.is_returned = True
 
-    @api.depends('operations.price_subtotal', 'invoice_method', 'fees_lines.price_subtotal', 'currency_id')
-    def _amount_untaxed(self):
-        for order in self:
-            total = sum(operation.price_subtotal for operation in order.operations)
-            total += sum(fee.price_subtotal for fee in order.fees_lines)
-            order.amount_untaxed = order.currency_id.round(total)
-
-    @api.depends('operations.price_unit', 'operations.product_uom_qty', 'operations.product_id',
-                 'fees_lines.price_unit', 'fees_lines.product_uom_qty', 'fees_lines.product_id',
-                 'currency_id', 'partner_id')
-    def _amount_tax(self):
-        for order in self:
-            val = 0.0
-            currency = order.currency_id
-            for operation in order.operations:
-                if operation.tax_id:
-                    tax_calculate = operation.tax_id.compute_all(operation.price_unit, currency, operation.product_uom_qty, operation.product_id, order.partner_id)
-                    for c in tax_calculate['taxes']:
-                        val += c['amount']
-            for fee in order.fees_lines:
-                if fee.tax_id:
-                    tax_calculate = fee.tax_id.compute_all(fee.price_unit, currency, fee.product_uom_qty, fee.product_id, order.partner_id)
-                    for c in tax_calculate['taxes']:
-                        val += c['amount']
-            order.amount_tax = val
-
-    @api.depends('amount_untaxed', 'amount_tax')
-    def _amount_total(self):
-        for order in self:
-            order.amount_total = order.currency_id.round(order.amount_untaxed + order.amount_tax)
-
-    _sql_constraints = [
-        ('name', 'unique (name)', 'The name of the Repair Order must be unique!'),
-    ]
-
-    @api.onchange('location_id', 'picking_id')
-    def _onchange_location_picking(self):
-        location_warehouse = self.location_id.warehouse_id
-        picking_warehouse = self.picking_id.location_dest_id.warehouse_id
-        if location_warehouse and picking_warehouse and location_warehouse != picking_warehouse:
-            return {
-                'warning': {'title': _("Warning"), 'message': _("Note that the warehouses of the return and repair locations don't match!")},
-            }
-
-    @api.depends('product_id')
-    def _compute_product_uom(self):
+    @api.depends('state',
+                 'move_ids.reserved_availability',
+                 'move_ids.quantity_done')
+    def _compute_show_qty_button(self):
+        self.show_set_qty_button = False
+        self.show_clear_qty_button = False
+        for repair in self.filtered(lambda r: r.state not in ['cancel', 'done']):
+            if any(float_is_zero(m.quantity_done, precision_rounding=m.product_uom.rounding) and not float_is_zero(m.reserved_availability, precision_rounding=m.product_uom.rounding) for m in repair.move_ids):
+                repair.show_set_qty_button = True
+            elif any(not float_is_zero(m.quantity_done, precision_rounding=m.product_uom.rounding) and float_compare(m.quantity_done, m.reserved_availability, precision_rounding=m.product_uom.rounding) == 0 for m in repair.move_ids):
+                repair.show_clear_qty_button = True
+
+    @api.depends('move_ids', 'state', 'move_ids.product_uom_qty')
+    def _compute_unreserve_visible(self):
         for repair in self:
-            if repair.product_id:
-                repair.product_uom = repair.product_id.uom_id
+            already_reserved = repair.state not in ('done', 'cancel') and any(repair.mapped('move_ids.move_line_ids.reserved_qty'))
 
-    @api.onchange('product_id')
-    def onchange_product_id(self):
-        self.guarantee_limit = False
-        if (self.product_id and self.lot_id and self.lot_id.product_id != self.product_id) or not self.product_id:
-            self.lot_id = False
+            repair.unreserve_visible = already_reserved
+            repair.reserve_visible = repair.state in ('confirmed', 'under_repair') and any(move.product_uom_qty and move.state in ['confirmed', 'partially_available'] for move in repair.move_ids)
 
     @api.onchange('product_uom')
     def onchange_product_uom(self):
@@ -230,659 +274,313 @@ class Repair(models.Model):
             return res
         if self.product_uom.category_id != self.product_id.uom_id.category_id:
             res['warning'] = {'title': _('Warning'), 'message': _('The product unit of measure you chose has a different category than the product unit of measure.')}
-            self.product_uom = self.product_id.uom_id.id
         return res
 
-    @api.onchange('partner_id')
-    def onchange_partner_id(self):
-        self = self.with_company(self.company_id)
-        if not self.partner_id:
-            self.address_id = False
-            self.partner_invoice_id = False
-            self.pricelist_id = self.env['product.pricelist'].search([
-                ('company_id', 'in', [self.env.company.id, False]),
-            ], limit=1)
-        else:
-            addresses = self.partner_id.address_get(['delivery', 'invoice', 'contact'])
-            self.address_id = addresses['delivery'] or addresses['contact']
-            self.partner_invoice_id = addresses['invoice']
-            self.pricelist_id = self.partner_id.property_product_pricelist.id
-
-    @api.depends('company_id')
-    def _compute_location_id(self):
-        for order in self:
-            if order.company_id:
-                if order.location_id.company_id != order.company_id:
-                    warehouse = self.env['stock.warehouse'].search([('company_id', '=', order.company_id.id)], limit=1)
-                    order.location_id = warehouse.lot_stock_id
-            else:
-                order.location_id = False
-
-    @api.ondelete(at_uninstall=False)
-    def _unlink_except_confirmed(self):
-        for order in self:
-            if order.invoice_id and order.invoice_id.posted_before:
-                raise UserError(_('You can not delete a repair order which is linked to an invoice which has been posted once.'))
-            if order.state == 'done':
-                raise UserError(_('You cannot delete a completed repair order.'))
-            if order.state not in ('draft', 'cancel'):
-                raise UserError(_('You can not delete a repair order once it has been confirmed. You must first cancel it.'))
+    @api.onchange('location_id', 'picking_id')
+    def _onchange_location_picking(self):
+        location_warehouse = self.location_id.warehouse_id
+        picking_warehouse = self.picking_id.location_dest_id.warehouse_id
+        if location_warehouse and picking_warehouse and location_warehouse != picking_warehouse:
+            return {
+                'warning': {'title': _("Warning"), 'message': _("Note that the warehouses of the return and repair locations don't match!")},
+            }
 
     @api.model_create_multi
     def create(self, vals_list):
         # We generate a standard reference
         for vals in vals_list:
-            vals['name'] = self.env['ir.sequence'].next_by_code('repair.order') or '/'
+            picking_type = self.env['stock.picking.type'].browse(vals.get('picking_type_id', self.default_get('picking_type_id')))
+            if 'picking_type_id' not in vals:
+                vals['picking_type_id'] = picking_type.id
+            if not vals.get('name', False) or vals['name'] == _('New'):
+                vals['name'] = picking_type.sequence_id.next_by_id()
+            if not vals.get('procurement_group_id'):
+                vals['procurement_group_id'] = self.env["procurement.group"].create({'name': vals['name']}).id
+            for location_field, picking_field in MAP_REPAIR_TO_PICKING_LOCATIONS.items():
+                if location_field not in vals:
+                    vals[location_field] = picking_type[picking_field].id
         return super().create(vals_list)
 
-    def button_dummy(self):
-        # TDE FIXME: this button is very interesting
-        return True
+    def write(self, vals):
+        res = super().write(vals)
+        if 'product_id' in vals and self.tracking == 'serial':
+            self.write({'product_qty': 1.0})
 
-    def action_repair_cancel_draft(self):
-        if self.filtered(lambda repair: repair.state != 'cancel'):
-            raise UserError(_("Repair must be canceled in order to reset it to draft."))
-        self.mapped('operations').write({'state': 'draft'})
-        return self.write({'state': 'draft', 'invoice_id': False})
-
-    def action_validate(self):
-        self.ensure_one()
-        if self.filtered(lambda repair: any(op.product_uom_qty < 0 for op in repair.operations)):
-            raise UserError(_("You can not enter negative quantities."))
-        if self.product_id.type == 'consu':
-            return self.action_repair_confirm()
-        precision = self.env['decimal.precision'].precision_get('Product Unit of Measure')
-        available_qty_owner = self.env['stock.quant']._get_available_quantity(self.product_id, self.location_id, self.lot_id, owner_id=self.partner_id, strict=True)
-        available_qty_noown = self.env['stock.quant']._get_available_quantity(self.product_id, self.location_id, self.lot_id, strict=True)
-        repair_qty = self.product_uom._compute_quantity(self.product_qty, self.product_id.uom_id)
-        for available_qty in [available_qty_owner, available_qty_noown]:
-            if float_compare(available_qty, repair_qty, precision_digits=precision) >= 0:
-                return self.action_repair_confirm()
-        else:
-            return {
-                'name': self.product_id.display_name + _(': Insufficient Quantity To Repair'),
-                'view_mode': 'form',
-                'res_model': 'stock.warn.insufficient.qty.repair',
-                'view_id': self.env.ref('repair.stock_warn_insufficient_qty_repair_form_view').id,
-                'type': 'ir.actions.act_window',
-                'context': {
-                    'default_product_id': self.product_id.id,
-                    'default_location_id': self.location_id.id,
-                    'default_repair_id': self.id,
-                    'default_quantity': repair_qty,
-                    'default_product_uom_name': self.product_id.uom_name
-                },
-                'target': 'new'
-            }
+        for repair in self:
+            has_modified_location = any(key in vals for key in MAP_REPAIR_TO_PICKING_LOCATIONS)
+            if has_modified_location:
+                repair.move_ids._set_repair_locations()
+            if 'schedule_date' in vals:
+                (repair.move_id + repair.move_ids).filtered(lambda m: m.state not in ('done', 'cancel')).write({'date': repair.schedule_date})
+            if 'under_warranty' in vals:
+                repair._update_sale_order_line_price()
+        return res
 
-    def action_repair_confirm(self):
-        """ Repair order state is set to 'To be invoiced' when invoice method
-        is 'Before repair' else state becomes 'Confirmed'.
-        @param *arg: Arguments
-        @return: True
-        """
-        if self.filtered(lambda repair: repair.state != 'draft'):
-            raise UserError(_("Only draft repairs can be confirmed."))
-        self._check_company()
-        self.operations._check_company()
-        self.fees_lines._check_company()
-        before_repair = self.filtered(lambda repair: repair.invoice_method == 'b4repair')
-        before_repair.write({'state': '2binvoiced'})
-        to_confirm = self - before_repair
-        to_confirm_operations = to_confirm.mapped('operations')
-        to_confirm_operations.write({'state': 'confirmed'})
-        to_confirm.write({'state': 'confirmed'})
-        return True
+    @api.ondelete(at_uninstall=False)
+    def _unlink_except_confirmed(self):
+        repairs_to_cancel = self.filtered(lambda ro: ro.state not in ('draft', 'cancel'))
+        repairs_to_cancel.action_repair_cancel()
+
+    def action_assign(self):
+        return self.move_ids._action_assign()
+
+    def action_clear_quantities_to_zero(self):
+        return self.move_ids.filtered(lambda m: float_compare(m.quantity_done, m.reserved_availability, precision_rounding=m.product_uom.rounding) == 0)._clear_quantities_to_zero()
+
+    def action_create_sale_order(self):
+        if any(repair.sale_order_id for repair in self):
+            concerned_ro = self.filtered('sale_order_id')
+            ref_str = "\n".join(ro.name for ro in concerned_ro)
+            raise UserError(_("You cannot create a quotation for a repair order that is already linked to an existing sale order.\nConcerned repair order(s) :\n") + ref_str)
+        if any(not repair.partner_id for repair in self):
+            concerned_ro = self.filtered(lambda ro: not ro.partner_id)
+            ref_str = "\n".join(ro.name for ro in concerned_ro)
+            raise UserError(_("You need to define a customer for a repair order in order to create an associated quotation.\nConcerned repair order(s) :\n") + ref_str)
+        sale_order_values_list = []
+        for repair in self:
+            sale_order_values_list.append({
+                "company_id": self.company_id.id,
+                "partner_id": self.partner_id.id,
+                "warehouse_id": self.picking_type_id.warehouse_id.id,
+                "repair_order_ids": [Command.link(repair.id)],
+            })
+        self.env['sale.order'].create(sale_order_values_list)
+        # Add Sale Order Lines for 'add' move_ids
+        self.move_ids._create_repair_sale_order_line()
+        return self.action_view_sale_order()
 
     def action_repair_cancel(self):
         if any(repair.state == 'done' for repair in self):
-            raise UserError(_("You cannot cancel a completed repair order."))
-        invoice_to_cancel = self.filtered(lambda repair: repair.invoice_id.state == 'draft').invoice_id
-        if invoice_to_cancel:
-            invoice_to_cancel.button_cancel()
-        self.mapped('operations').write({'state': 'cancel'})
+            raise UserError(_("You cannot cancel a Repair Order that's already been completed"))
+        for repair in self:
+            if repair.sale_order_id:
+                repair.sale_order_line_id.write({'product_uom_qty': 0.0})  # Quantity of the product that generated the RO is set to 0
+        self.move_ids._action_cancel()  # Quantity of parts added from the RO to the SO is set to 0
         return self.write({'state': 'cancel'})
 
-    def action_send_mail(self):
-        self.ensure_one()
-        template_id = self.env.ref('repair.mail_template_repair_quotation').id
-        ctx = {
-            'default_model': 'repair.order',
-            'default_res_ids': self.ids,
-            'default_template_id': template_id,
-            'default_composition_mode': 'comment',
-            'default_email_layout_xmlid': 'mail.mail_notification_light',
-        }
-        return {
-            'type': 'ir.actions.act_window',
-            'view_mode': 'form',
-            'res_model': 'mail.compose.message',
-            'target': 'new',
-            'context': ctx,
-        }
-
-    def print_repair_order(self):
-        return self.env.ref('repair.action_report_repair_order').report_action(self)
-
-    def action_repair_invoice_create(self):
-        for repair in self:
-            repair._create_invoices()
-            if repair.invoice_method == 'b4repair':
-                repair.action_repair_ready()
-            elif repair.invoice_method == 'after_repair':
-                repair.write({'state': 'done'})
+    def action_repair_cancel_draft(self):
+        if self.filtered(lambda repair: repair.state != 'cancel'):
+            self.action_repair_cancel()
+        sale_line_to_update = self.move_ids.sale_line_id.filtered(lambda l: l.order_id.state != 'cancel' and float_is_zero(l.product_uom_qty, precision_rounding=l.product_uom.rounding))
+        sale_line_to_update.move_ids._update_repair_sale_order_line()
+        self.move_ids.state = 'draft'
+        self.state = 'draft'
         return True
 
-    def _create_invoices(self, group=False):
-        """ Creates invoice(s) for repair order.
-        @param group: It is set to true when group invoice is to be generated.
-        @return: Invoice Ids.
-        """
-        grouped_invoices_vals = {}
-        repairs = self.filtered(lambda repair: repair.state not in ('draft', 'cancel')
-                                               and not repair.invoice_id
-                                               and repair.invoice_method != 'none')
-        for repair in repairs:
-            repair = repair.with_company(repair.company_id)
-            partner_invoice = repair.partner_invoice_id or repair.partner_id
-            if not partner_invoice:
-                raise UserError(_('You have to select an invoice address in the repair form.'))
-
-            narration = repair.quotation_notes
-            currency = repair.currency_id
-            company = repair.env.company
-
-            if (partner_invoice.id, currency.id, company.id) not in grouped_invoices_vals:
-                grouped_invoices_vals[(partner_invoice.id, currency.id, company.id)] = []
-            current_invoices_list = grouped_invoices_vals[(partner_invoice.id, currency.id, company.id)]
-
-            if not group or len(current_invoices_list) == 0:
-                fpos = self.env['account.fiscal.position']._get_fiscal_position(partner_invoice, delivery=repair.address_id)
-                invoice_vals = {
-                    'move_type': 'out_invoice',
-                    'partner_id': partner_invoice.id,
-                    'partner_shipping_id': repair.address_id.id,
-                    'currency_id': currency.id,
-                    'narration': narration if not is_html_empty(narration) else '',
-                    'invoice_origin': repair.name,
-                    'repair_ids': [(4, repair.id)],
-                    'invoice_line_ids': [],
-                    'fiscal_position_id': fpos.id
-                }
-                if partner_invoice.property_payment_term_id:
-                    invoice_vals['invoice_payment_term_id'] = partner_invoice.property_payment_term_id.id
-                current_invoices_list.append(invoice_vals)
-            else:
-                # if group == True: concatenate invoices by partner and currency
-                invoice_vals = current_invoices_list[0]
-                invoice_vals['invoice_origin'] += ', ' + repair.name
-                invoice_vals['repair_ids'].append((4, repair.id))
-                if not is_html_empty(narration):
-                    if  is_html_empty(invoice_vals['narration']):
-                        invoice_vals['narration'] = narration
-                    else:
-                        invoice_vals['narration'] += Markup('<br/>') + narration
-
-            # Create invoice lines from operations.
-            for operation in repair.operations.filtered(lambda op: op.type == 'add'):
-                if group:
-                    name = repair.name + '-' + operation.name
-                else:
-                    name = operation.name
-
-                account = operation.product_id.product_tmpl_id.get_product_accounts(fiscal_pos=fpos)['income']
-                if not account:
-                    raise UserError(_('No account defined for product "%s".', operation.product_id.name))
-
-                invoice_line_vals = {
-                    'name': name,
-                    'account_id': account.id,
-                    'quantity': operation.product_uom_qty,
-                    'tax_ids': [(6, 0, operation.tax_id.ids)],
-                    'product_uom_id': operation.product_uom.id,
-                    'price_unit': operation.price_unit,
-                    'product_id': operation.product_id.id,
-                    'repair_line_ids': [(4, operation.id)],
-                }
-
-                if currency == company.currency_id:
-                    balance = -(operation.product_uom_qty * operation.price_unit)
-                    invoice_line_vals.update({
-                        'debit': balance > 0.0 and balance or 0.0,
-                        'credit': balance < 0.0 and -balance or 0.0,
-                    })
-                else:
-                    amount_currency = -(operation.product_uom_qty * operation.price_unit)
-                    balance = currency._convert(amount_currency, company.currency_id, company, fields.Date.today())
-                    invoice_line_vals.update({
-                        'amount_currency': amount_currency,
-                        'debit': balance > 0.0 and balance or 0.0,
-                        'credit': balance < 0.0 and -balance or 0.0,
-                        'currency_id': currency.id,
-                    })
-                invoice_vals['invoice_line_ids'].append((0, 0, invoice_line_vals))
-
-            # Create invoice lines from fees.
-            for fee in repair.fees_lines:
-                if group:
-                    name = repair.name + '-' + fee.name
-                else:
-                    name = fee.name
-
-                if not fee.product_id:
-                    raise UserError(_('No product defined on fees.'))
-
-                account = fee.product_id.product_tmpl_id.get_product_accounts(fiscal_pos=fpos)['income']
-                if not account:
-                    raise UserError(_('No account defined for product "%s".', fee.product_id.name))
-
-                invoice_line_vals = {
-                    'name': name,
-                    'account_id': account.id,
-                    'quantity': fee.product_uom_qty,
-                    'tax_ids': [(6, 0, fee.tax_id.ids)],
-                    'product_uom_id': fee.product_uom.id,
-                    'price_unit': fee.price_unit,
-                    'product_id': fee.product_id.id,
-                    'repair_fee_ids': [(4, fee.id)],
-                }
-
-                if currency == company.currency_id:
-                    balance = -(fee.product_uom_qty * fee.price_unit)
-                    invoice_line_vals.update({
-                        'debit': balance > 0.0 and balance or 0.0,
-                        'credit': balance < 0.0 and -balance or 0.0,
-                    })
-                else:
-                    amount_currency = -(fee.product_uom_qty * fee.price_unit)
-                    balance = currency._convert(amount_currency, company.currency_id, company,
-                                                fields.Date.today())
-                    invoice_line_vals.update({
-                        'amount_currency': amount_currency,
-                        'debit': balance > 0.0 and balance or 0.0,
-                        'credit': balance < 0.0 and -balance or 0.0,
-                        'currency_id': currency.id,
-                    })
-                invoice_vals['invoice_line_ids'].append((0, 0, invoice_line_vals))
-
-        # Create invoices.
-        invoices_vals_list_per_company = defaultdict(list)
-        for (partner_invoice_id, currency_id, company_id), invoices in grouped_invoices_vals.items():
-            for invoice in invoices:
-                invoices_vals_list_per_company[company_id].append(invoice)
-
-        for company_id, invoices_vals_list in invoices_vals_list_per_company.items():
-            # VFE TODO remove the default_company_id ctxt key ?
-            # Account fallbacks on self.env.company, which is correct with with_company
-            self.env['account.move'].with_company(company_id).with_context(default_company_id=company_id, default_move_type='out_invoice').create(invoices_vals_list)
-
-        repairs.write({'invoiced': True})
-        repairs.mapped('operations').filtered(lambda op: op.type == 'add').write({'invoiced': True})
-        repairs.mapped('fees_lines').write({'invoiced': True})
-
-        return dict((repair.id, repair.invoice_id.id) for repair in repairs)
-
-    def action_created_invoice(self):
-        self.ensure_one()
-        return {
-            'name': _('Invoice created'),
-            'type': 'ir.actions.act_window',
-            'view_mode': 'form',
-            'res_model': 'account.move',
-            'view_id': self.env.ref('account.view_move_form').id,
-            'target': 'current',
-            'res_id': self.invoice_id.id,
-            }
-
-    def action_repair_ready(self):
-        self.mapped('operations').write({'state': 'confirmed'})
-        return self.write({'state': 'ready'})
-
-    def action_repair_start(self):
-        """ Writes repair order state to 'Under Repair'
-        @return: True
-        """
-        if self.filtered(lambda repair: repair.state not in ['confirmed', 'ready']):
-            raise UserError(_("Repair must be confirmed before starting reparation."))
-        self.mapped('operations').write({'state': 'confirmed'})
-        return self.write({'state': 'under_repair'})
-
-    def action_repair_end(self):
-        """ Writes repair order state to 'To be invoiced' if invoice method is
-        After repair else state is set to 'Ready'.
+    def action_repair_done(self):
+        """ Creates stock move for final product of repair order.
+        Writes move_id and move_ids state to 'done'.
+        Writes repair order state to 'Repaired'.
         @return: True
         """
-        if self.filtered(lambda repair: repair.state != 'under_repair'):
-            raise UserError(_("Repair must be under repair in order to end reparation."))
         self._check_product_tracking()
-        for repair in self:
-            repair.write({'repaired': True})
-            vals = {'state': 'done'}
-            vals['move_id'] = repair.action_repair_done().get(repair.id)
-            if not repair.invoice_id and repair.invoice_method == 'after_repair':
-                vals['state'] = '2binvoiced'
-            repair.write(vals)
-        return True
 
-    def action_repair_done(self):
-        """ Creates stock move for operation and stock move for final product of repair order.
-        @return: Move ids of final products
-
-        """
-        if self.filtered(lambda repair: not repair.repaired):
-            raise UserError(_("Repair must be repaired in order to make the product moves."))
-        self._check_company()
-        self.operations._check_company()
-        self.fees_lines._check_company()
-        res = {}
         precision = self.env['decimal.precision'].precision_get('Product Unit of Measure')
-        Move = self.env['stock.move']
+        product_move_vals = []
+
+        # Cancel moves with 0 quantity_done
+        self.move_ids.filtered(lambda m: float_is_zero(m.quantity_done, precision_rounding=m.product_uom.rounding))._action_cancel()
+
+        #SOL qty delivered = repair.move_ids.quantity_done
         for repair in self:
+            if repair.sale_order_line_id:
+                ro_origin_product = repair.sale_order_line_id.product_template_id
+                if ro_origin_product.detailed_type == 'service':
+                    repair.sale_order_line_id.qty_delivered = repair.sale_order_line_id.product_uom_qty
+            if not repair.product_id:
+                continue
+            if repair.product_id.product_tmpl_id.tracking != 'none' and not repair.lot_id:
+                raise ValidationError(_(
+                    "Serial number is required for product to repair : %s",
+                    repair.product_id.display_name
+                ))
+
             # Try to create move with the appropriate owner
             owner_id = False
             available_qty_owner = self.env['stock.quant']._get_available_quantity(repair.product_id, repair.location_id, repair.lot_id, owner_id=repair.partner_id, strict=True)
             if float_compare(available_qty_owner, repair.product_qty, precision_digits=precision) >= 0:
                 owner_id = repair.partner_id.id
 
-            moves = self.env['stock.move']
-            for operation in repair.operations:
-                move = Move.create({
-                    'name': repair.name,
-                    'product_id': operation.product_id.id,
-                    'product_uom_qty': operation.product_uom_qty,
-                    'product_uom': operation.product_uom.id,
-                    'partner_id': repair.address_id.id,
-                    'location_id': operation.location_id.id,
-                    'location_dest_id': operation.location_dest_id.id,
-                    'repair_id': repair.id,
-                    'origin': repair.name,
-                    'company_id': repair.company_id.id,
-                })
-
-                # Best effort to reserve the product in a (sub)-location where it is available
-                product_qty = move.product_uom._compute_quantity(
-                    operation.product_uom_qty, move.product_id.uom_id, rounding_method='HALF-UP')
-                available_quantity = self.env['stock.quant']._get_available_quantity(
-                    move.product_id,
-                    move.location_id,
-                    lot_id=operation.lot_id,
-                    strict=False,
-                )
-                move._update_reserved_quantity(
-                    product_qty,
-                    available_quantity,
-                    move.location_id,
-                    lot_id=operation.lot_id,
-                    strict=False,
-                )
-                # Then, set the quantity done. If the required quantity was not reserved, negative
-                # quant is created in operation.location_id.
-                move._set_quantity_done(operation.product_uom_qty)
-
-                if operation.lot_id:
-                    move.move_line_ids.lot_id = operation.lot_id
-
-                moves |= move
-                operation.write({'move_id': move.id, 'state': 'done'})
-            move = Move.create({
+            product_move_vals.append({
                 'name': repair.name,
                 'product_id': repair.product_id.id,
                 'product_uom': repair.product_uom.id or repair.product_id.uom_id.id,
                 'product_uom_qty': repair.product_qty,
-                'partner_id': repair.address_id.id,
+                'partner_id': repair.partner_id.id,
                 'location_id': repair.location_id.id,
                 'location_dest_id': repair.location_id.id,
-                'move_line_ids': [(0, 0, {'product_id': repair.product_id.id,
-                                           'lot_id': repair.lot_id.id,
-                                           'reserved_uom_qty': 0,  # bypass reservation here
-                                           'product_uom_id': repair.product_uom.id or repair.product_id.uom_id.id,
-                                           'qty_done': repair.product_qty,
-                                           'package_id': False,
-                                           'result_package_id': False,
-                                           'owner_id': owner_id,
-                                           'location_id': repair.location_id.id, #TODO: owner stuff
-                                           'company_id': repair.company_id.id,
-                                           'location_dest_id': repair.location_id.id,})],
+                'move_line_ids': [(0, 0, {
+                    'product_id': repair.product_id.id,
+                    'lot_id': repair.lot_id.id,
+                    'reserved_uom_qty': 0,  # bypass reservation here
+                    'product_uom_id': repair.product_uom.id or repair.product_id.uom_id.id,
+                    'qty_done': repair.product_qty,
+                    'package_id': False,
+                    'result_package_id': False,
+                    'owner_id': owner_id,
+                    'location_id': repair.location_id.id,
+                    'company_id': repair.company_id.id,
+                    'location_dest_id': repair.location_id.id,
+                    'consume_line_ids': [(6, 0, repair.move_ids.move_line_ids.ids)]
+                })],
                 'repair_id': repair.id,
                 'origin': repair.name,
                 'company_id': repair.company_id.id,
             })
-            consumed_lines = moves.mapped('move_line_ids')
-            produced_lines = move.move_line_ids
-            moves |= move
-            moves._action_done()
-            produced_lines.write({'consume_line_ids': [(6, 0, consumed_lines.ids)]})
-            res[repair.id] = move.id
-        return res
 
-    def _check_product_tracking(self):
-        invalid_lines = self.operations.filtered(lambda x: x.tracking != 'none' and not x.lot_id)
-        if invalid_lines:
-            products = invalid_lines.product_id
-            raise ValidationError(_(
-                "Serial number is required for operation lines with products: %s",
-                ", ".join(products.mapped('display_name')),
-            ))
+        product_moves = self.env['stock.move'].create(product_move_vals)
+        self.move_id = product_moves.id
+        self.sale_order_line_id.move_ids._set_quantities_to_reservation()
 
+        all_moves = self.move_ids + product_moves + self.sale_order_line_id.move_ids
+        all_moves._action_done()
 
-class RepairLine(models.Model):
-    _name = 'repair.line'
-    _description = 'Repair Line (parts)'
-    _check_company_auto = True
+        for sale_line in self.move_ids.sale_line_id:
+            price_unit = sale_line.price_unit
+            sale_line.write({'product_uom_qty': sale_line.qty_delivered, 'price_unit': price_unit})
 
-    name = fields.Text('Description', required=True)
-    repair_id = fields.Many2one(
-        'repair.order', 'Repair Order Reference', required=True,
-        index=True, ondelete='cascade', check_company=True)
-    company_id = fields.Many2one(
-        related='repair_id.company_id', store=True, index=True)
-    currency_id = fields.Many2one(
-        related='repair_id.currency_id')
-    type = fields.Selection([
-        ('add', 'Add'),
-        ('remove', 'Remove')], 'Type', default='add', required=True)
-    product_id = fields.Many2one(
-        'product.product', 'Product', required=True, check_company=True,
-        domain="[('type', 'in', ['product', 'consu'])]")
-    invoiced = fields.Boolean('Invoiced', copy=False, readonly=True)
-    price_unit = fields.Float('Unit Price', required=True, digits='Product Price')
-    price_subtotal = fields.Float('Subtotal', compute='_compute_price_total_and_subtotal', store=True, digits=0)
-    price_total = fields.Float('Total', compute='_compute_price_total_and_subtotal', store=True, digits=0)
-    tax_id = fields.Many2many(
-        'account.tax', 'repair_operation_line_tax', 'repair_operation_line_id', 'tax_id', 'Taxes',
-        domain="[('type_tax_use','=','sale')]", check_company=True)
-    product_uom_qty = fields.Float(
-        'Quantity', default=1.0,
-        digits='Product Unit of Measure', required=True)
-    product_uom = fields.Many2one(
-        'uom.uom', 'Product Unit of Measure',
-        compute='_compute_product_uom', store=True, readonly=False, precompute=True,
-        required=True, domain="[('category_id', '=', product_uom_category_id)]")
-    product_uom_category_id = fields.Many2one(related='product_id.uom_id.category_id')
-    invoice_line_id = fields.Many2one(
-        'account.move.line', 'Invoice Line',
-        copy=False, readonly=True, check_company=True)
-    location_id = fields.Many2one(
-        'stock.location', 'Source Location',
-        compute='_compute_location_id', store=True, readonly=False, precompute=True,
-        index=True, required=True, check_company=True)
-    location_dest_id = fields.Many2one(
-        'stock.location', 'Dest. Location',
-        compute='_compute_location_id', store=True, readonly=False, precompute=True,
-        index=True, required=True, check_company=True)
-    move_id = fields.Many2one(
-        'stock.move', 'Inventory Move',
-        copy=False, readonly=True)
-    lot_id = fields.Many2one(
-        'stock.lot', 'Lot/Serial',
-        domain="[('product_id','=', product_id)]", check_company=True)
-    state = fields.Selection([
-        ('draft', 'Draft'),
-        ('confirmed', 'Confirmed'),
-        ('done', 'Done'),
-        ('cancel', 'Cancelled')], 'Status', default='draft',
-        copy=False, readonly=True, required=True,
-        help='The status of a repair line is set automatically to the one of the linked repair order.')
-    tracking = fields.Selection(string='Product Tracking', related="product_id.tracking")
-    tax_calculation_rounding_method = fields.Selection(
-        related='company_id.tax_calculation_rounding_method',
-        string='Tax calculation rounding method', readonly=True)
-
-    @api.depends('price_unit', 'repair_id', 'product_uom_qty', 'product_id', 'tax_id', 'repair_id.invoice_method')
-    def _compute_price_total_and_subtotal(self):
-        for line in self:
-            taxes = line.tax_id.compute_all(line.price_unit, line.repair_id.currency_id, line.product_uom_qty, line.product_id, line.repair_id.partner_id)
-            line.price_subtotal = taxes['total_excluded']
-            line.price_total = taxes['total_included']
+        self.state = 'done'
+        return True
 
-    @api.depends('product_id')
-    def _compute_product_uom(self):
-        for line in self:
-            line.product_uom = line.product_id.uom_id.id
-
-    @api.depends('type')
-    def _compute_location_id(self):
-        for line in self:
-            if not line.type:
-                line.location_id = False
-                line.location_dest_id = False
-            elif line.type == 'add':
-                args = line.repair_id.company_id and [('company_id', '=', line.repair_id.company_id.id)] or []
-                warehouse = line.env['stock.warehouse'].search(args, limit=1)
-                line.location_id = warehouse.lot_stock_id
-                line.location_dest_id = line.env['stock.location'].search([('usage', '=', 'production'), ('company_id', '=', line.repair_id.company_id.id)], limit=1)
-            else:
-                line.location_id = line.env['stock.location'].search([('usage', '=', 'production'), ('company_id', '=', line.repair_id.company_id.id)], limit=1).id
-                line.location_dest_id = line.env['stock.location'].search([('scrap_location', '=', True), ('company_id', 'in', [line.repair_id.company_id.id, False])], limit=1).id
-
-    @api.onchange('type')
-    def onchange_operation_type(self):
-        """ On change of operation type it sets source location, destination location
-        and to invoice field.
-        @param product: Changed operation type.
-        @param guarantee_limit: Guarantee limit of current record.
-        @return: Dictionary of values.
+    def action_repair_end(self):
+        """ Checks before action_repair_done.
+        @return: True
         """
-        if not self.type:
-            pass
-        elif self.type == 'add':
-            self.onchange_product_id()
-        else:
-            self.price_unit = 0.0
-            self.tax_id = False
-
-    @api.onchange('repair_id', 'product_id', 'product_uom_qty')
-    def onchange_product_id(self):
-        """ On change of product it sets product quantity, tax account, name,
-        uom of product, unit price and price subtotal. """
-        if not self.product_id or not self.product_uom_qty:
-            return
-        self = self.with_company(self.company_id)
-        partner = self.repair_id.partner_id
-        partner_invoice = self.repair_id.partner_invoice_id or partner
-        if partner:
-            self = self.with_context(lang=partner.lang)
-        product = self.product_id
-        self.name = product.display_name
-        if product.description_sale:
-            if partner:
-                self.name += '\n' + self.product_id.with_context(lang=partner.lang).description_sale
-            else:
-                self.name += '\n' + self.product_id.description_sale
-        if self.type != 'remove':
-            if partner:
-                fpos = self.env['account.fiscal.position']._get_fiscal_position(partner_invoice, delivery=self.repair_id.address_id)
-                taxes = self.product_id.taxes_id.filtered(lambda x: x.company_id == self.repair_id.company_id)
-                self.tax_id = fpos.map_tax(taxes)
-            self._onchange_product_uom()
+        if self.filtered(lambda repair: repair.state != 'under_repair'):
+            raise UserError(_("Repair must be under repair in order to end reparation."))
+        if any(float_compare(move.quantity_done, move.product_uom_qty, precision_rounding=move.product_uom.rounding) < 0 for move in self.move_ids):
+            ctx = dict(self.env.context or {})
+            ctx['default_repair_ids'] = self.ids
+            return {
+                'name': _('Uncomplete Move(s)'),
+                'type': 'ir.actions.act_window',
+                'view_mode': 'form',
+                'views': [(False, 'form')],
+                'res_model': 'repair.warn.uncomplete.move',
+                'target': 'new',
+                'context': ctx,
+            }
 
-    @api.onchange('product_uom')
-    def _onchange_product_uom(self):
-        if self.product_id and self.type != 'remove':
-            price = self.repair_id.pricelist_id._get_product_price(
-                self.product_id, self.product_uom_qty, uom=self.product_uom)
-            self.price_unit = price
+        return self.action_repair_done()
 
+    def action_repair_start(self):
+        """ Writes repair order state to 'Under Repair'
+        """
+        if self.filtered(lambda repair: repair.state != 'confirmed'):
+            self._action_repair_confirm()
+        return self.write({'state': 'under_repair'})
 
-class RepairFee(models.Model):
-    _name = 'repair.fee'
-    _description = 'Repair Fees'
-    _check_company_auto = True
+    def action_set_quantities_to_reservation(self):
+        return self.move_ids.filtered(lambda m: float_is_zero(m.quantity_done, precision_rounding=m.product_uom.rounding))._set_quantities_to_reservation()
 
-    repair_id = fields.Many2one(
-        'repair.order', 'Repair Order Reference',
-        index=True, ondelete='cascade', required=True)
-    company_id = fields.Many2one(
-        related="repair_id.company_id", index=True, store=True)
-    currency_id = fields.Many2one(
-        related="repair_id.currency_id")
-    name = fields.Text('Description', index=True, required=True)
-    product_id = fields.Many2one(
-        'product.product', 'Product', check_company=True,
-        domain="[('type', '=', 'service')]")
-    product_uom_qty = fields.Float('Quantity', digits='Product Unit of Measure', required=True, default=1.0)
-    price_unit = fields.Float('Unit Price', required=True, digits='Product Price')
-    product_uom = fields.Many2one(
-        'uom.uom', 'Product Unit of Measure',
-        compute='_compute_product_uom', store=True, readonly=False, precompute=True,
-        required=True, domain="[('category_id', '=', product_uom_category_id)]")
-    product_uom_category_id = fields.Many2one(related='product_id.uom_id.category_id')
-    price_subtotal = fields.Float('Subtotal', compute='_compute_price_total_and_subtotal', store=True, digits=0)
-    price_total = fields.Float('Total', compute='_compute_price_total_and_subtotal', store=True, digits=0)
-    tax_id = fields.Many2many(
-        'account.tax', 'repair_fee_line_tax', 'repair_fee_line_id', 'tax_id', 'Taxes',
-        domain="[('type_tax_use','=','sale')]", check_company=True)
-    invoice_line_id = fields.Many2one('account.move.line', 'Invoice Line', copy=False, readonly=True, check_company=True)
-    invoiced = fields.Boolean('Invoiced', copy=False, readonly=True)
-
-    @api.depends('price_unit', 'repair_id', 'product_uom_qty', 'product_id', 'tax_id')
-    def _compute_price_total_and_subtotal(self):
-        for fee in self:
-            taxes = fee.tax_id.compute_all(fee.price_unit, fee.repair_id.currency_id, fee.product_uom_qty, fee.product_id, fee.repair_id.partner_id)
-            fee.price_subtotal = taxes['total_excluded']
-            fee.price_total = taxes['total_included']
+    def action_unreserve(self):
+        return self.move_ids.filtered(lambda m: m.state in ('assigned', 'partially_available'))._do_unreserve()
 
-    @api.depends('product_id')
-    def _compute_product_uom(self):
-        for fee in self:
-            fee.product_uom = fee.product_id.uom_id
-
-    @api.onchange('repair_id', 'product_id', 'product_uom_qty')
-    def onchange_product_id(self):
-        """ On change of product it sets product quantity, tax account, name,
-        uom of product, unit price and price subtotal. """
-        if not self.product_id:
-            return
-
-        self = self.with_company(self.company_id)
-
-        partner = self.repair_id.partner_id
-        partner_invoice = self.repair_id.partner_invoice_id or partner
-
-        if partner and self.product_id:
-            fpos = self.env['account.fiscal.position']._get_fiscal_position(partner_invoice, delivery=self.repair_id.address_id)
-            taxes = self.product_id.taxes_id.filtered(lambda x: x.company_id == self.repair_id.company_id)
-            self.tax_id = fpos.map_tax(taxes)
-        if partner:
-            self.name = self.product_id.with_context(lang=partner.lang).display_name
-        else:
-            self.name = self.product_id.display_name
-        self.product_uom = self.product_id.uom_id.id
-        if self.product_id.description_sale:
-            if partner:
-                self.name += '\n' + self.product_id.with_context(lang=partner.lang).description_sale
+    def action_validate(self):
+        self.ensure_one()
+        if self.filtered(lambda repair: any(m.product_uom_qty < 0 for m in repair.move_ids)):
+            raise UserError(_("You can not enter negative quantities."))
+        if not self.product_id or self.product_id.type == 'consu':
+            return self._action_repair_confirm()
+        precision = self.env['decimal.precision'].precision_get('Product Unit of Measure')
+        available_qty_owner = self.env['stock.quant']._get_available_quantity(self.product_id, self.location_id, self.lot_id, owner_id=self.partner_id, strict=True)
+        available_qty_noown = self.env['stock.quant']._get_available_quantity(self.product_id, self.location_id, self.lot_id, strict=True)
+        repair_qty = self.product_uom._compute_quantity(self.product_qty, self.product_id.uom_id)
+        for available_qty in [available_qty_owner, available_qty_noown]:
+            if float_compare(available_qty, repair_qty, precision_digits=precision) >= 0:
+                return self._action_repair_confirm()
+
+        return {
+            'name': self.product_id.display_name + _(': Insufficient Quantity To Repair'),
+            'view_mode': 'form',
+            'res_model': 'stock.warn.insufficient.qty.repair',
+            'view_id': self.env.ref('repair.stock_warn_insufficient_qty_repair_form_view').id,
+            'type': 'ir.actions.act_window',
+            'context': {
+                'default_product_id': self.product_id.id,
+                'default_location_id': self.location_id.id,
+                'default_repair_id': self.id,
+                'default_quantity': repair_qty,
+                'default_product_uom_name': self.product_id.uom_name
+            },
+            'target': 'new'
+        }
+
+    def action_view_sale_order(self):
+        return {
+            "type": "ir.actions.act_window",
+            "res_model": "sale.order",
+            "views": [[False, "form"]],
+            "res_id": self.sale_order_id.id,
+        }
+
+    def print_repair_order(self):
+        return self.env.ref('repair.action_report_repair_order').report_action(self)
+
+    def _action_repair_confirm(self):
+        """ Repair order state is set to 'Confirmed'.
+        @param *arg: Arguments
+        @return: True
+        """
+        repairs_to_confirm = self.filtered(lambda repair: repair.state == 'draft')
+        repairs_to_confirm._check_company()
+        repairs_to_confirm.move_ids._check_company()
+        repairs_to_confirm.move_ids._adjust_procure_method()
+        repairs_to_confirm.move_ids._action_confirm()
+        repairs_to_confirm.move_ids._trigger_scheduler()
+        repairs_to_confirm.write({'state': 'confirmed'})
+        return True
+
+    def _check_product_tracking(self):
+        invalid_lines = self.move_ids.filtered(lambda x: x.has_tracking != 'none' and not x.lot_ids)
+        if invalid_lines:
+            products = invalid_lines.product_id
+            raise ValidationError(_(
+                "Serial number is required for operation lines with products: %s",
+                ", ".join(products.mapped('display_name')),
+            ))
+
+    def _get_location(self, field):
+        return self.picking_type_id[MAP_REPAIR_TO_PICKING_LOCATIONS[field]]
+
+    def _get_picking_type(self):
+        companies = self.company_id or self.env.company
+        if not self:
+            # default case
+            default_warehouse = self.env.user.with_company(companies.id)._get_default_warehouse_id()
+            if default_warehouse and default_warehouse.repair_type_id:
+                return {(companies, self.env.user): default_warehouse.repair_type_id}
+
+        picking_type_by_company_user = {}
+        without_default_warehouse_companies = set()
+        for (company, user), dummy in groupby(self, lambda r: (r.company_id, r.user_id)):
+            default_warehouse = user.with_company(company.id)._get_default_warehouse_id()
+            if default_warehouse and default_warehouse.repair_type_id:
+                picking_type_by_company_user[(company, user)] = default_warehouse.repair_type_id
             else:
-                self.name += '\n' + self.product_id.description_sale
+                without_default_warehouse_companies.add(company.id)
 
-        self._onchange_product_uom()
+        if not without_default_warehouse_companies:
+            return picking_type_by_company_user
 
-    @api.onchange('product_uom')
-    def _onchange_product_uom(self):
-        if self.product_id:
-            price = self.repair_id.pricelist_id._get_product_price(
-                self.product_id, self.product_uom_qty, uom=self.product_uom)
-            self.price_unit = price
+        domain = [
+            ('code', '=', 'repair_operation'),
+            ('warehouse_id.company_id', 'in', list(without_default_warehouse_companies)),
+        ]
 
+        picking_types = self.env['stock.picking.type'].search_read(domain, ['company_id'], load=False)
+        for picking_type in picking_types:
+            if (picking_type.company_id, False) not in picking_type_by_company_user:
+                picking_type_by_company_user[(picking_type.company_id, False)] = picking_type
+        return picking_type_by_company_user
+
+    def _update_sale_order_line_price(self):
+        for repair in self:
+            add_moves = repair.move_ids.filtered(lambda m: m.repair_line_type == 'add' and m.sale_line_id)
+            if repair.under_warranty:
+                add_moves.sale_line_id.write({'price_unit': 0.0})
+            else:
+                add_moves.sale_line_id._compute_price_unit()
 
 class RepairTags(models.Model):
     """ Tags of Repair's tasks """

--- a/None
+++ b/addons/repair/models/sale_order.py
@@ -0,0 +1,112 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from odoo import api, fields, models, _
+from odoo.tools import float_compare
+
+class SaleOrder(models.Model):
+    _inherit = 'sale.order'
+
+    repair_order_ids = fields.One2many(
+        comodel_name='repair.order', inverse_name='sale_order_id',
+        string='Repair Order', groups='stock.group_stock_user')
+    repair_count = fields.Integer(
+        "Repair Order(s)", compute='_compute_repair_count', groups='stock.group_stock_user')
+
+    @api.depends('repair_order_ids')
+    def _compute_repair_count(self):
+        for order in self:
+            order.repair_count = len(order.repair_order_ids)
+
+    def _action_cancel(self):
+        res = super()._action_cancel()
+        self.order_line._cancel_repair_order()
+        return res
+
+    def _action_confirm(self):
+        res = super()._action_confirm()
+        self.order_line._create_repair_order()
+        return res
+
+    def action_show_repair(self):
+        self.ensure_one()
+        if self.repair_count == 1:
+            return {
+                "type": "ir.actions.act_window",
+                "res_model": "repair.order",
+                "views": [[False, "form"]],
+                "res_id": self.repair_order_ids.id,
+            }
+        elif self.repair_count > 1:
+            return {
+                "name": _("Repair Orders"),
+                "type": "ir.actions.act_window",
+                "res_model": "repair.order",
+                "view_mode": "tree,form",
+                "domain": [('sale_order_id', '=', self.id)],
+            }
+
+
+class SaleOrderLine(models.Model):
+    _inherit = 'sale.order.line'
+
+    def _compute_qty_delivered(self):
+        remaining_so_lines = self
+        for so_line in self:
+            move = so_line.move_ids.sudo().filtered(lambda m: m.repair_id and m.state == 'done')
+            if len(move) != 1:
+                continue
+            remaining_so_lines -= so_line
+            so_line.qty_delivered = move.quantity_done
+        return super(SaleOrderLine, remaining_so_lines)._compute_qty_delivered()
+
+    @api.model_create_multi
+    def create(self, vals_list):
+        res = super().create(vals_list)
+        res.filtered(lambda line: line.state in ('sale', 'done'))._create_repair_order()
+        return res
+
+    def write(self, vals_list):
+        old_product_uom_qty = {line.id: line.product_uom_qty for line in self}
+        res = super().write(vals_list)
+        for line in self:
+            if line.state in ('sale', 'done'):
+                if float_compare(old_product_uom_qty[line.id], 0, precision_rounding=line.product_uom.rounding) <= 0 and float_compare(line.product_uom_qty, 0, precision_rounding=line.product_uom.rounding) > 0:
+                    self._create_repair_order()
+                if float_compare(old_product_uom_qty[line.id], 0, precision_rounding=line.product_uom.rounding) > 0 and float_compare(line.product_uom_qty, 0, precision_rounding=line.product_uom.rounding) <= 0:
+                    self._cancel_repair_order()
+        return res
+
+    def _action_launch_stock_rule(self, previous_product_uom_qty=False):
+        # Picking must be generated for products created from the SO but not for parts added from the RO, as they're already handled there
+        lines_without_repair_move = self.filtered(lambda line: not line.move_ids.sudo().repair_id)
+        return super(SaleOrderLine, lines_without_repair_move)._action_launch_stock_rule(previous_product_uom_qty)
+
+    def _create_repair_order(self):
+        new_repair_vals = []
+        for line in self:
+            # One RO for each line with at least a quantity of 1, quantities > 1 don't create multiple ROs
+            if any(line.id == ro.sale_order_line_id.id for ro in line.order_id.sudo().repair_order_ids) and float_compare(line.product_uom_qty, 0, precision_rounding=line.product_uom.rounding) > 0:
+                binded_ro_ids = line.order_id.sudo().repair_order_ids.filtered(lambda ro: ro.sale_order_line_id.id == line.id and ro.state == 'cancel')
+                binded_ro_ids.action_repair_cancel_draft()
+                binded_ro_ids._action_repair_confirm()
+                continue
+            if not line.product_template_id.sudo().create_repair or line.move_ids.sudo().repair_id or float_compare(line.product_uom_qty, 0, precision_rounding=line.product_uom.rounding) <= 0:
+                continue
+            order = line.order_id
+            new_repair_vals.append({
+                'state': 'confirmed',
+                'partner_id': order.partner_id.id,
+                'sale_order_id': order.id,
+                'sale_order_line_id': line.id,
+                'picking_type_id': order.warehouse_id.repair_type_id.id,
+            })
+        if new_repair_vals:
+            self.env['repair.order'].sudo().create(new_repair_vals)
+
+    def _cancel_repair_order(self):
+        # Each RO binded to a SO line with Qty set to 0 or cancelled is set to 'Cancelled'
+        binded_ro_ids = self.env['repair.order']
+        for line in self:
+            binded_ro_ids |= line.order_id.sudo().repair_order_ids.filtered(lambda ro: ro.sale_order_line_id.id == line.id and ro.state != 'done')
+        binded_ro_ids.action_repair_cancel()

--- a/addons/repair/models/stock_lot.py
+++ b/addons/repair/models/stock_lot.py
@@ -3,6 +3,7 @@
 from collections import defaultdict
 from odoo import api, fields, models, _
 
+
 class StockLot(models.Model):
     _inherit = 'stock.lot'
 
@@ -13,8 +14,9 @@ class StockLot(models.Model):
     @api.depends('name')
     def _compute_repair_order_ids(self):
         repair_orders = defaultdict(lambda: self.env['repair.order'])
-        for repair_line in self.env['repair.line'].search([('lot_id', 'in', self.ids), ('state', '=', 'done')]):
-            repair_orders[repair_line.lot_id.id] |= repair_line.repair_id
+        for repair_line in self.env['stock.move'].search([('repair_id', '!=', False), ('move_line_ids.lot_id', 'in', self.ids), ('state', '=', 'done')]):
+            for rl_id in repair_line.lot_ids.ids:
+                repair_orders[rl_id] |= repair_line.repair_id
         for lot in self:
             lot.repair_order_ids = repair_orders[lot.id]
             lot.repair_order_count = len(lot.repair_order_ids)

--- a/None
+++ b/addons/repair/models/stock_move.py
@@ -0,0 +1,190 @@
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from odoo import api, Command, fields, models
+from odoo.tools.misc import groupby
+
+MAP_REPAIR_LINE_TYPE_TO_MOVE_LOCATIONS_FROM_REPAIR = {
+    'add': {'location_id': 'location_id', 'location_dest_id': 'location_dest_id'},
+    'remove': {'location_id': 'location_dest_id', 'location_dest_id': 'parts_location_id'},
+    'recycle': {'location_id': 'location_dest_id', 'location_dest_id': 'recycle_location_id'},
+}
+
+
+class StockMove(models.Model):
+    _inherit = 'stock.move'
+
+    repair_id = fields.Many2one('repair.order', check_company=True)
+    repair_line_type = fields.Selection([
+        ('add', 'Add'),
+        ('remove', 'Remove'),
+        ('recycle', 'Recycle')
+    ], 'Type', store=True, index=True)
+
+    @api.depends('repair_line_type')
+    def _compute_forecast_information(self):
+        moves_to_compute = self.filtered(lambda move: not move.repair_line_type or move.repair_line_type == 'add')
+        for move in (self - moves_to_compute):
+            move.forecast_availability = move.product_qty
+            move.forecast_expected_date = False
+        return super(StockMove, moves_to_compute)._compute_forecast_information()
+
+    @api.depends('repair_id.picking_type_id')
+    def _compute_picking_type_id(self):
+        remaining_moves = self
+        for move in self:
+            if move.repair_id:
+                move.picking_type_id = move.repair_id.picking_type_id
+                remaining_moves -= move
+        return super(StockMove, remaining_moves)._compute_picking_type_id()
+
+    def copy_data(self, default=None):
+        default = dict(default or {})
+        if 'repair_id' in default or self.repair_id:
+            default['sale_line_id'] = False
+        return super().copy_data(default)
+
+    @api.ondelete(at_uninstall=False)
+    def _unlink_if_draft_or_cancel(self):
+        self.filtered('repair_id')._action_cancel()
+        return super()._unlink_if_draft_or_cancel()
+
+    def unlink(self):
+        self._clean_repair_sale_order_line()
+        return super().unlink()
+
+    @api.model_create_multi
+    def create(self, vals_list):
+        for vals in vals_list:
+            if not vals.get('repair_id') or 'repair_line_type' not in vals:
+                continue
+            repair_id = self.env['repair.order'].browse([vals['repair_id']])
+            vals['name'] = repair_id.name
+            src_location, dest_location = self._get_repair_locations(vals['repair_line_type'], repair_id)
+            if not vals.get('location_id'):
+                vals['location_id'] = src_location.id
+            if not vals.get('location_dest_id'):
+                vals['location_dest_id'] = dest_location.id
+        moves = super().create(vals_list)
+        repair_moves = self.env['stock.move']
+        for move in moves:
+            if not move.repair_id:
+                continue
+            move.group_id = move.repair_id.procurement_group_id.id
+            move.origin = move.name
+            move.picking_type_id = move.repair_id.picking_type_id.id
+            repair_moves |= move
+
+            if move.state == 'draft' and move.repair_id.state in ('confirmed', 'under_repair'):
+                move._check_company()
+                move._adjust_procure_method()
+                move._action_confirm()
+                move._trigger_scheduler()
+        repair_moves._create_repair_sale_order_line()
+        return moves
+
+    def write(self, vals):
+        res = super().write(vals)
+        repair_moves = self.env['stock.move']
+        moves_to_create_so_line = self.env['stock.move']
+        for move in self:
+            if not move.repair_id:
+                continue
+            # checks vals update
+            if 'repair_line_type' in vals or 'picking_type_id' in vals and move.product_id != move.repair_id.product_id:
+                move.location_id, move.location_dest_id = move._get_repair_locations(move.repair_line_type)
+            if not move.sale_line_id and 'sale_line_id' not in vals and move.repair_line_type == 'add':
+                moves_to_create_so_line |= move
+            if move.sale_line_id and ('repair_line_type' in vals or 'product_uom_qty' in vals):
+                repair_moves |= move
+
+        repair_moves._update_repair_sale_order_line()
+        moves_to_create_so_line._create_repair_sale_order_line()
+        return res
+
+    # Needed to also cancel the lastly added part
+    def _action_cancel(self):
+        self._clean_repair_sale_order_line()
+        return super()._action_cancel()
+
+    def _create_repair_sale_order_line(self):
+        if not self:
+            return
+        so_line_vals = []
+        for move in self:
+            if move.sale_line_id or move.repair_line_type != 'add' or not move.repair_id.sale_order_id:
+                continue
+            product_qty = move.product_uom_qty if move.repair_id.state != 'done' else move.quantity_done
+            so_line_vals.append({
+                'order_id': move.repair_id.sale_order_id.id,
+                'product_id': move.product_id.id,
+                'product_uom_qty': product_qty, # When relying only on so_line compute method, the sol quantity is only updated on next sol creation
+                'move_ids': [Command.link(move.id)],
+            })
+            if move.repair_id.under_warranty:
+                so_line_vals[-1]['price_unit'] = 0.0
+            elif move.price_unit:
+                so_line_vals[-1]['price_unit'] = move.price_unit
+
+        self.env['sale.order.line'].create(so_line_vals)
+
+    def _clean_repair_sale_order_line(self):
+        self.filtered(
+            lambda m: m.repair_id and m.sale_line_id
+        ).mapped('sale_line_id').write({'product_uom_qty': 0.0})
+
+    def _update_repair_sale_order_line(self):
+        if not self:
+            return
+        moves_to_clean = self.env['stock.move']
+        moves_to_update = self.env['stock.move']
+        for move in self:
+            if not move.repair_id:
+                continue
+            if move.sale_line_id and move.repair_line_type != 'add':
+                moves_to_clean |= move
+            if move.sale_line_id and move.repair_line_type == 'add':
+                moves_to_update |= move
+        moves_to_clean._clean_repair_sale_order_line()
+        for sale_line, _ in groupby(moves_to_update, lambda m: m.sale_line_id):
+            sale_line.product_uom_qty = sum(sale_line.move_ids.mapped('product_uom_qty'))
+
+    def _is_consuming(self):
+        return super()._is_consuming() or (self.repair_id and self.repair_line_type == 'add')
+
+    def _get_repair_locations(self, repair_line_type, repair_id=False):
+        location_map = MAP_REPAIR_LINE_TYPE_TO_MOVE_LOCATIONS_FROM_REPAIR.get(repair_line_type)
+        if location_map:
+            if not repair_id:
+                self.repair_id.ensure_one()
+                repair_id = self.repair_id
+            location_id, location_dest_id = [repair_id[field] for field in location_map.values()]
+        else:
+            location_id, location_dest_id = False, False
+        return location_id, location_dest_id
+
+    def _get_source_document(self):
+        return self.repair_id or super()._get_source_document()
+
+    def _set_repair_locations(self):
+        moves_per_repair = self.filtered(lambda m: (m.repair_id and m.repair_line_type) is not False).grouped('repair_id')
+        if not moves_per_repair:
+            return
+        for moves in moves_per_repair.values():
+            grouped_moves = moves.grouped('repair_line_type')
+            for line_type, m in grouped_moves.items():
+                m.location_id, m.location_dest_id = m._get_repair_locations(line_type)
+
+    def _should_be_assigned(self):
+        res = super(StockMove, self)._should_be_assigned()
+        return bool(res and not (self.repair_id and self.repair_line_type))
+
+    def _create_extra_move(self):
+        if self.repair_id:
+            return self
+        return super(StockMove, self)._create_extra_move()
+
+    def _split(self, qty, restrict_partner_id=False):
+        # When setting the Repair Order as done with partially done moves, do not split these moves
+        if self.repair_id:
+            return []
+        return super(StockMove, self)._split(qty, restrict_partner_id)

--- a/addons/repair/models/stock_picking.py
+++ b/addons/repair/models/stock_picking.py
@@ -1,24 +1,90 @@
 # -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
+import time
+
 from odoo import _, api, fields, models
+from odoo.tools import DEFAULT_SERVER_DATETIME_FORMAT
 
 
 class PickingType(models.Model):
     _inherit = 'stock.picking.type'
 
+    code = fields.Selection(selection_add=[
+        ('repair_operation', 'Repair')
+    ], ondelete={'repair_operation': 'cascade'})
+
+    count_repair_ready = fields.Integer(
+        string="Number of Repair Orders to Process", compute='_compute_count_repair')
+    count_repair_waiting = fields.Integer(
+        string="Number of Repair Orders Waiting", compute='_compute_count_repair')
+    count_repair_late = fields.Integer(
+        string="Number of Repair Orders Late", compute='_compute_count_repair')
+
+    default_location_dest_id = fields.Many2one(
+        readonly={"code", "=", "repair_operation"})
+    default_remove_location_dest_id = fields.Many2one(
+        'stock.location', 'Default Remove Destination Location',
+        check_company=True, readonly=True,
+        help="This is the default remove destination location when you create a repair order with this operation type.")
+
+    default_recycle_location_dest_id = fields.Many2one(
+        'stock.location', 'Default Recycle Destination Location',
+        check_company=True,
+        help="This is the default recycle destination location when you create a repair order with this operation type.")
+
     is_repairable = fields.Boolean(
         'Create Repair Orders from Returns',
         compute='_compute_is_repairable', store=True, readonly=False,
         help="If ticked, you will be able to directly create repair orders from a return.")
     return_type_of_ids = fields.One2many('stock.picking.type', 'return_picking_type_id')
 
+    def _compute_count_repair(self):
+        repair_picking_types = self.filtered(lambda picking: picking.code == 'repair_operation')
+
+        # By default, set count_repair_xxx to False
+        self.count_repair_ready = False
+        self.count_repair_waiting = False
+        self.count_repair_late = False
+
+        # shortcut
+        if not repair_picking_types:
+            return
+
+        domains = {
+            'count_repair_ready': [
+                ('is_parts_available', '=', True)
+            ],
+            'count_repair_waiting': [],
+            'count_repair_late': [
+                '|',
+                    ('schedule_date', '<', time.strftime(DEFAULT_SERVER_DATETIME_FORMAT)),
+                    ('is_parts_late', '=', True)
+            ],
+        }
+
+        for field, domain in domains.items():
+            picking_types = self.env['repair.order'].read_group(
+                [('picking_type_id', 'in', repair_picking_types.ids), ('state', 'in', ('confirmed', 'under_repair'))] + domain,
+                fields=['picking_type_id'],
+                groupby=['picking_type_id']
+            )
+            counts = {pt['picking_type_id'][0]:pt['picking_type_id_count'] for pt in picking_types}
+            for record in repair_picking_types:
+                record[field] = counts.get(record.id)
+
     @api.depends('return_type_of_ids', 'code')
     def _compute_is_repairable(self):
         for picking_type in self:
             if not(picking_type.code == 'incoming' and picking_type.return_type_of_ids):
                 picking_type.is_repairable = False
 
+    def get_repair_stock_picking_action_picking_type(self):
+        action = self.env["ir.actions.actions"]._for_xml_id('repair.action_picking_repair')
+        if self:
+            action['display_name'] = self.display_name
+        return action
+
 
 class Picking(models.Model):
     _inherit = 'stock.picking'

--- a/None
+++ b/addons/repair/models/stock_warehouse.py
@@ -0,0 +1,51 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from odoo import fields, models, _
+
+
+class StockWarehouse(models.Model):
+    _inherit = 'stock.warehouse'
+
+    repair_type_id = fields.Many2one('stock.picking.type', 'Repair Operation Type', check_company=True)
+
+    def _get_sequence_values(self, name=False, code=False):
+        values = super(StockWarehouse, self)._get_sequence_values(name=name, code=code)
+        values.update({
+            'repair_type_id': {
+                'name': self.name + ' ' + _('Sequence repair'),
+                'prefix': self.code + '/RO/',
+                'padding': 5,
+                'company_id': self.company_id.id
+                },
+        })
+        return values
+
+    def _get_picking_type_create_values(self, max_sequence):
+        data, next_sequence = super(StockWarehouse, self)._get_picking_type_create_values(max_sequence)
+        prod_location = self.env['stock.location'].search([('usage', '=', 'production'), ('company_id', '=', self.company_id.id)], limit=1)
+        scrap_location = self.env['stock.location'].search([('scrap_location', '=', True), ('company_id', 'in', [self.company_id.id, False])], limit=1)
+        data.update({
+            'repair_type_id': {
+                'name': _('Repairs'),
+                'code': 'repair_operation',
+                'default_location_src_id': self.lot_stock_id.id,
+                'default_location_dest_id': prod_location.id,
+                'default_remove_location_dest_id':scrap_location.id,
+                'default_recycle_location_dest_id': self.lot_stock_id.id,
+                'sequence': next_sequence + 1,
+                'sequence_code': 'RO',
+                'company_id': self.company_id.id,
+            },
+        })
+        return data, max_sequence + 2
+
+    def _get_picking_type_update_values(self):
+        data = super(StockWarehouse, self)._get_picking_type_update_values()
+        data.update({
+            'repair_type_id': {
+                'active': self.active,
+                'barcode': self.code.replace(" ", "").upper() + "-RO",
+            },
+        })
+        return data
