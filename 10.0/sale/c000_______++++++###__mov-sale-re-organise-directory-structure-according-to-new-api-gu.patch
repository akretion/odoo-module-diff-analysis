PR: https://github.com/odoo/odoo/pull/

From: a33e808ca63dffa30e7185f7325900e04bf337df
From: fwi-odoo
Date: 2016-08-10 09:00:21

Structural Changes: 92
Total Changes: 1464

[MOV] sale: re-organise directory structure according to new API guidelines

================================= pseudo patch: =================================

--- a/None
+++ b/addons/sale/models/__init__.py
@@ -0,0 +1,9 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+import res_partner
+import sale
+import sale_analytic
+import sale_config_settings
+import sale_layout
+import sales_team
\ No newline at end of file

--- a/None
+++ b/addons/sale/models/res_partner.py
@@ -0,0 +1,29 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from openerp.osv import fields,osv
+from openerp.addons.base.res.res_partner import WARNING_MESSAGE, WARNING_HELP
+
+class res_partner(osv.osv):
+    _inherit = 'res.partner'
+
+    def _sale_order_count(self, cr, uid, ids, field_name, arg, context=None):
+        res = dict(map(lambda x: (x,0), ids))
+        # The current user may not have access rights for sale orders
+        try:
+            for partner in self.browse(cr, uid, ids, context):
+                res[partner.id] = len(partner.sale_order_ids) + len(partner.mapped('child_ids.sale_order_ids'))
+        except:
+            pass
+        return res
+
+    _columns = {
+        'sale_order_count': fields.function(_sale_order_count, string='# of Sales Order', type='integer'),
+        'sale_order_ids': fields.one2many('sale.order', 'partner_id', 'Sales Order'),
+        'sale_warn': fields.selection(WARNING_MESSAGE, 'Sales Order', default='no-message', help=WARNING_HELP, required=True),
+        'sale_warn_msg': fields.text('Message for Sales Order'),
+    }
+
+    _defaults = {
+        'sale_warn': 'no-message',
+    }

--- a/None
+++ b/addons/sale/models/sale.py
@@ -0,0 +1,1079 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from itertools import groupby
+from datetime import datetime, timedelta
+from openerp import SUPERUSER_ID
+from openerp import api, fields, models, _
+import openerp.addons.decimal_precision as dp
+from openerp.exceptions import UserError
+from openerp.tools import float_is_zero, float_compare, DEFAULT_SERVER_DATETIME_FORMAT
+from openerp.tools.misc import formatLang
+from openerp.addons.base.res.res_partner import WARNING_MESSAGE, WARNING_HELP
+
+
+class res_company(models.Model):
+    _inherit = "res.company"
+    sale_note = fields.Text(string='Default Terms and Conditions', translate=True)
+
+
+class SaleOrder(models.Model):
+    _name = "sale.order"
+    _inherit = ['mail.thread', 'ir.needaction_mixin']
+    _description = "Sales Order"
+    _order = 'date_order desc, id desc'
+
+    @api.depends('order_line.price_total')
+    def _amount_all(self):
+        """
+        Compute the total amounts of the SO.
+        """
+        for order in self:
+            amount_untaxed = amount_tax = 0.0
+            for line in order.order_line:
+                amount_untaxed += line.price_subtotal
+                amount_tax += line.price_tax
+            order.update({
+                'amount_untaxed': order.pricelist_id.currency_id.round(amount_untaxed),
+                'amount_tax': order.pricelist_id.currency_id.round(amount_tax),
+                'amount_total': amount_untaxed + amount_tax,
+            })
+
+    @api.depends('state', 'order_line.invoice_status')
+    def _get_invoiced(self):
+        """
+        Compute the invoice status of a SO. Possible statuses:
+        - no: if the SO is not in status 'sale' or 'done', we consider that there is nothing to
+          invoice. This is also hte default value if the conditions of no other status is met.
+        - to invoice: if any SO line is 'to invoice', the whole SO is 'to invoice'
+        - invoiced: if all SO lines are invoiced, the SO is invoiced.
+        - upselling: if all SO lines are invoiced or upselling, the status is upselling.
+
+        The invoice_ids are obtained thanks to the invoice lines of the SO lines, and we also search
+        for possible refunds created directly from existing invoices. This is necessary since such a
+        refund is not directly linked to the SO.
+        """
+        for order in self:
+            invoice_ids = order.order_line.mapped('invoice_lines').mapped('invoice_id')
+            # Search for invoices which have been 'cancelled' (filter_refund = 'modify' in
+            # 'account.invoice.refund')
+            # use like as origin may contains multiple references (e.g. 'SO01, SO02')
+            refunds = invoice_ids.search([('origin', 'like', order.name)])
+            invoice_ids |= refunds.filtered(lambda r: order.name in [origin.strip() for origin in r.origin.split(',')])
+            # Search for refunds as well
+            refund_ids = self.env['account.invoice'].browse()
+            if invoice_ids:
+                refund_ids = refund_ids.search([('type', '=', 'out_refund'), ('origin', 'in', invoice_ids.mapped('number')), ('origin', '!=', False)])
+
+            line_invoice_status = [line.invoice_status for line in order.order_line]
+
+            if order.state not in ('sale', 'done'):
+                invoice_status = 'no'
+            elif any(invoice_status == 'to invoice' for invoice_status in line_invoice_status):
+                invoice_status = 'to invoice'
+            elif all(invoice_status == 'invoiced' for invoice_status in line_invoice_status):
+                invoice_status = 'invoiced'
+            elif all(invoice_status in ['invoiced', 'upselling'] for invoice_status in line_invoice_status):
+                invoice_status = 'upselling'
+            else:
+                invoice_status = 'no'
+
+            order.update({
+                'invoice_count': len(set(invoice_ids.ids + refund_ids.ids)),
+                'invoice_ids': invoice_ids.ids + refund_ids.ids,
+                'invoice_status': invoice_status
+            })
+
+    @api.model
+    def _default_note(self):
+        return self.env.user.company_id.sale_note
+
+    @api.model
+    def _get_default_team(self):
+        return self.env['crm.team']._get_default_team_id()
+
+    @api.onchange('fiscal_position_id')
+    def _compute_tax_id(self):
+        """
+        Trigger the recompute of the taxes if the fiscal position is changed on the SO.
+        """
+        for order in self:
+            order.order_line._compute_tax_id()
+
+    def _inverse_project_id(self):
+        self.project_id = self.related_project_id
+
+    name = fields.Char(string='Order Reference', required=True, copy=False, readonly=True, states={'draft': [('readonly', False)]}, index=True, default=lambda self: _('New'))
+    origin = fields.Char(string='Source Document', help="Reference of the document that generated this sales order request.")
+    client_order_ref = fields.Char(string='Customer Reference', copy=False)
+
+    state = fields.Selection([
+        ('draft', 'Quotation'),
+        ('sent', 'Quotation Sent'),
+        ('sale', 'Sale Order'),
+        ('done', 'Locked'),
+        ('cancel', 'Cancelled'),
+        ], string='Status', readonly=True, copy=False, index=True, track_visibility='onchange', default='draft')
+    date_order = fields.Datetime(string='Order Date', required=True, readonly=True, index=True, states={'draft': [('readonly', False)], 'sent': [('readonly', False)]}, copy=False, default=fields.Datetime.now)
+    validity_date = fields.Date(string='Expiration Date', readonly=True, states={'draft': [('readonly', False)], 'sent': [('readonly', False)]},
+        help="Manually set the expiration date of your quotation (offer), or it will set the date automatically based on the template if online quotation is installed.")
+    create_date = fields.Datetime(string='Creation Date', readonly=True, index=True, help="Date on which sales order is created.")
+    confirmation_date = fields.Datetime(string='Confirmation Date', readonly=True, index=True, help="Date on which the sale order is confirmed.", oldname="date_confirm")
+    user_id = fields.Many2one('res.users', string='Salesperson', index=True, track_visibility='onchange', default=lambda self: self.env.user)
+    partner_id = fields.Many2one('res.partner', string='Customer', readonly=True, states={'draft': [('readonly', False)], 'sent': [('readonly', False)]}, required=True, change_default=True, index=True, track_visibility='always')
+    partner_invoice_id = fields.Many2one('res.partner', string='Invoice Address', readonly=True, required=True, states={'draft': [('readonly', False)], 'sent': [('readonly', False)]}, help="Invoice address for current sales order.")
+    partner_shipping_id = fields.Many2one('res.partner', string='Delivery Address', readonly=True, required=True, states={'draft': [('readonly', False)], 'sent': [('readonly', False)]}, help="Delivery address for current sales order.")
+
+    pricelist_id = fields.Many2one('product.pricelist', string='Pricelist', required=True, readonly=True, states={'draft': [('readonly', False)], 'sent': [('readonly', False)]}, help="Pricelist for current sales order.")
+    currency_id = fields.Many2one("res.currency", related='pricelist_id.currency_id', string="Currency", readonly=True, required=True)
+    project_id = fields.Many2one('account.analytic.account', 'Analytic Account', readonly=True, states={'draft': [('readonly', False)], 'sent': [('readonly', False)]}, help="The analytic account related to a sales order.", copy=False)
+    related_project_id = fields.Many2one('account.analytic.account', inverse='_inverse_project_id', related='project_id', string='Analytic Account', help="The analytic account related to a sales order.")
+
+    order_line = fields.One2many('sale.order.line', 'order_id', string='Order Lines', states={'cancel': [('readonly', True)], 'done': [('readonly', True)]}, copy=True)
+
+    invoice_count = fields.Integer(string='# of Invoices', compute='_get_invoiced', readonly=True)
+    invoice_ids = fields.Many2many("account.invoice", string='Invoices', compute="_get_invoiced", readonly=True, copy=False)
+    invoice_status = fields.Selection([
+        ('upselling', 'Upselling Opportunity'),
+        ('invoiced', 'Fully Invoiced'),
+        ('to invoice', 'To Invoice'),
+        ('no', 'Nothing to Invoice')
+        ], string='Invoice Status', compute='_get_invoiced', store=True, readonly=True, default='no')
+
+    note = fields.Text('Terms and conditions', default=_default_note)
+
+    amount_untaxed = fields.Monetary(string='Untaxed Amount', store=True, readonly=True, compute='_amount_all', track_visibility='always')
+    amount_tax = fields.Monetary(string='Taxes', store=True, readonly=True, compute='_amount_all', track_visibility='always')
+    amount_total = fields.Monetary(string='Total', store=True, readonly=True, compute='_amount_all', track_visibility='always')
+
+    payment_term_id = fields.Many2one('account.payment.term', string='Payment Term', oldname='payment_term')
+    fiscal_position_id = fields.Many2one('account.fiscal.position', oldname='fiscal_position', string='Fiscal Position')
+    company_id = fields.Many2one('res.company', 'Company', default=lambda self: self.env['res.company']._company_default_get('sale.order'))
+    team_id = fields.Many2one('crm.team', 'Sales Team', change_default=True, default=_get_default_team, oldname='section_id')
+    procurement_group_id = fields.Many2one('procurement.group', 'Procurement Group', copy=False)
+
+    product_id = fields.Many2one('product.product', related='order_line.product_id', string='Product')
+
+    @api.model
+    def _get_customer_lead(self, product_tmpl_id):
+        return False
+
+    @api.multi
+    def button_dummy(self):
+        return True
+
+    @api.multi
+    def unlink(self):
+        for order in self:
+            if order.state not in ('draft', 'cancel'):
+                raise UserError(_('You can not delete a sent quotation or a sales order! Try to cancel it before.'))
+        return super(SaleOrder, self).unlink()
+
+    @api.multi
+    def _track_subtype(self, init_values):
+        self.ensure_one()
+        if 'state' in init_values and self.state == 'sale':
+            return 'sale.mt_order_confirmed'
+        elif 'state' in init_values and self.state == 'sent':
+            return 'sale.mt_order_sent'
+        return super(SaleOrder, self)._track_subtype(init_values)
+
+    @api.multi
+    @api.onchange('partner_shipping_id')
+    def onchange_partner_shipping_id(self):
+        """
+        Trigger the change of fiscal position when the shipping address is modified.
+        """
+        fiscal_position = self.env['account.fiscal.position'].get_fiscal_position(self.partner_id.id, self.partner_shipping_id.id)
+        if fiscal_position:
+            self.fiscal_position_id = fiscal_position
+        return {}
+
+    @api.multi
+    @api.onchange('partner_id')
+    def onchange_partner_id(self):
+        """
+        Update the following fields when the partner is changed:
+        - Pricelist
+        - Payment term
+        - Invoice address
+        - Delivery address
+        """
+        if not self.partner_id:
+            self.update({
+                'partner_invoice_id': False,
+                'partner_shipping_id': False,
+                'payment_term_id': False,
+                'fiscal_position_id': False,
+            })
+            return
+
+        addr = self.partner_id.address_get(['delivery', 'invoice'])
+        values = {
+            'pricelist_id': self.partner_id.property_product_pricelist and self.partner_id.property_product_pricelist.id or False,
+            'payment_term_id': self.partner_id.property_payment_term_id and self.partner_id.property_payment_term_id.id or False,
+            'partner_invoice_id': addr['invoice'],
+            'partner_shipping_id': addr['delivery'],
+        }
+        if self.env.user.company_id.sale_note:
+            values['note'] = self.with_context(lang=self.partner_id.lang).env.user.company_id.sale_note
+
+        if self.partner_id.user_id:
+            values['user_id'] = self.partner_id.user_id.id
+        if self.partner_id.team_id:
+            values['team_id'] = self.partner_id.team_id.id
+        self.update(values)
+
+    @api.onchange('partner_id')
+    def onchange_partner_id_warning(self):
+        if not self.partner_id:
+            return
+        warning = {}
+        title = False
+        message = False
+        partner = self.partner_id
+
+        # If partner has no warning, check its company
+        if partner.sale_warn == 'no-message' and partner.parent_id:
+            partner = partner.parent_id
+
+        if partner.sale_warn != 'no-message':
+            # Block if partner only has warning but parent company is blocked
+            if partner.sale_warn != 'block' and partner.parent_id and partner.parent_id.sale_warn == 'block':
+                partner = partner.parent_id
+            title =  _("Warning for %s") % partner.name
+            message = partner.sale_warn_msg
+            warning = {
+                    'title': title,
+                    'message': message,
+            }
+            if partner.sale_warn == 'block':
+                self.update({'partner_id': False, 'partner_invoice_id': False, 'partner_shipping_id': False, 'pricelist_id': False})
+                return {'warning': warning}
+
+        if warning:
+            return {'warning': warning}
+
+    @api.model
+    def create(self, vals):
+        if vals.get('name', 'New') == 'New':
+            vals['name'] = self.env['ir.sequence'].next_by_code('sale.order') or 'New'
+
+        # Makes sure partner_invoice_id', 'partner_shipping_id' and 'pricelist_id' are defined
+        if any(f not in vals for f in ['partner_invoice_id', 'partner_shipping_id', 'pricelist_id']):
+            partner = self.env['res.partner'].browse(vals.get('partner_id'))
+            addr = partner.address_get(['delivery', 'invoice'])
+            vals['partner_invoice_id'] = vals.setdefault('partner_invoice_id', addr['invoice'])
+            vals['partner_shipping_id'] = vals.setdefault('partner_shipping_id', addr['delivery'])
+            vals['pricelist_id'] = vals.setdefault('pricelist_id', partner.property_product_pricelist and partner.property_product_pricelist.id)
+        result = super(SaleOrder, self).create(vals)
+        return result
+
+
+    @api.multi
+    def _prepare_invoice(self):
+        """
+        Prepare the dict of values to create the new invoice for a sales order. This method may be
+        overridden to implement custom invoice generation (making sure to call super() to establish
+        a clean extension chain).
+        """
+        self.ensure_one()
+        journal_id = self.env['account.invoice'].default_get(['journal_id'])['journal_id']
+        if not journal_id:
+            raise UserError(_('Please define an accounting sale journal for this company.'))
+        invoice_vals = {
+            'name': self.client_order_ref or '',
+            'origin': self.name,
+            'type': 'out_invoice',
+            'account_id': self.partner_invoice_id.property_account_receivable_id.id,
+            'partner_id': self.partner_invoice_id.id,
+            'partner_shipping_id': self.partner_shipping_id.id,
+            'journal_id': journal_id,
+            'currency_id': self.pricelist_id.currency_id.id,
+            'comment': self.note,
+            'payment_term_id': self.payment_term_id.id,
+            'fiscal_position_id': self.fiscal_position_id.id or self.partner_invoice_id.property_account_position_id.id,
+            'company_id': self.company_id.id,
+            'user_id': self.user_id and self.user_id.id,
+            'team_id': self.team_id.id
+        }
+        return invoice_vals
+
+    @api.multi
+    def print_quotation(self):
+        self.filtered(lambda s: s.state == 'draft').write({'state': 'sent'})
+        return self.env['report'].get_action(self, 'sale.report_saleorder')
+
+    @api.multi
+    def action_view_invoice(self):
+        invoice_ids = self.mapped('invoice_ids')
+        imd = self.env['ir.model.data']
+        action = imd.xmlid_to_object('account.action_invoice_tree1')
+        list_view_id = imd.xmlid_to_res_id('account.invoice_tree')
+        form_view_id = imd.xmlid_to_res_id('account.invoice_form')
+
+        result = {
+            'name': action.name,
+            'help': action.help,
+            'type': action.type,
+            'views': [[list_view_id, 'tree'], [form_view_id, 'form'], [False, 'graph'], [False, 'kanban'], [False, 'calendar'], [False, 'pivot']],
+            'target': action.target,
+            'context': action.context,
+            'res_model': action.res_model,
+        }
+        if len(invoice_ids) > 1:
+            result['domain'] = "[('id','in',%s)]" % invoice_ids.ids
+        elif len(invoice_ids) == 1:
+            result['views'] = [(form_view_id, 'form')]
+            result['res_id'] = invoice_ids.ids[0]
+        else:
+            result = {'type': 'ir.actions.act_window_close'}
+        return result
+
+    @api.multi
+    def action_invoice_create(self, grouped=False, final=False):
+        """
+        Create the invoice associated to the SO.
+        :param grouped: if True, invoices are grouped by SO id. If False, invoices are grouped by
+                        (partner_invoice_id, currency)
+        :param final: if True, refunds will be generated if necessary
+        :returns: list of created invoices
+        """
+        inv_obj = self.env['account.invoice']
+        precision = self.env['decimal.precision'].precision_get('Product Unit of Measure')
+        invoices = {}
+        references = {}
+        for order in self:
+            group_key = order.id if grouped else (order.partner_invoice_id.id, order.currency_id.id)
+            for line in order.order_line.sorted(key=lambda l: l.qty_to_invoice < 0):
+                if float_is_zero(line.qty_to_invoice, precision_digits=precision):
+                    continue
+                if group_key not in invoices:
+                    inv_data = order._prepare_invoice()
+                    invoice = inv_obj.create(inv_data)
+                    references[invoice] = order
+                    invoices[group_key] = invoice
+                elif group_key in invoices:
+                    vals = {}
+                    if order.name not in invoices[group_key].origin.split(', '):
+                        vals['origin'] = invoices[group_key].origin + ', ' + order.name
+                    if order.client_order_ref and order.client_order_ref not in invoices[group_key].name.split(', '):
+                        vals['name'] = invoices[group_key].name + ', ' + order.client_order_ref
+                    invoices[group_key].write(vals)
+                if line.qty_to_invoice > 0:
+                    line.invoice_line_create(invoices[group_key].id, line.qty_to_invoice)
+                elif line.qty_to_invoice < 0 and final:
+                    line.invoice_line_create(invoices[group_key].id, line.qty_to_invoice)
+
+            if references.get(invoices.get(group_key)):
+                if order not in references[invoices[group_key]]:
+                    references[invoice] = references[invoice] | order
+
+        if not invoices:
+            raise UserError(_('There is no invoicable line.'))
+
+
+        for invoice in invoices.values():
+            if not invoice.invoice_line_ids:
+                raise UserError(_('There is no invoicable line.'))
+            # If invoice is negative, do a refund invoice instead
+            if invoice.amount_untaxed < 0:
+                invoice.type = 'out_refund'
+                for line in invoice.invoice_line_ids:
+                    line.quantity = -line.quantity
+            # Use additional field helper function (for account extensions)
+            for line in invoice.invoice_line_ids:
+                line._set_additional_fields(invoice)
+            # Necessary to force computation of taxes. In account_invoice, they are triggered
+            # by onchanges, which are not triggered when doing a create.
+            invoice.compute_taxes()
+            invoice.message_post_with_view('mail.message_origin_link',
+                values={'self': invoice, 'origin': references[invoice]},
+                subtype_id=self.env.ref('mail.mt_note').id)
+        return [inv.id for inv in invoices.values()]
+
+    @api.multi
+    def action_draft(self):
+        orders = self.filtered(lambda s: s.state in ['cancel', 'sent'])
+        orders.write({
+            'state': 'draft',
+            'procurement_group_id': False,
+        })
+        orders.mapped('order_line').mapped('procurement_ids').write({'sale_line_id': False})
+
+    @api.multi
+    def action_cancel(self):
+        self.write({'state': 'cancel'})
+
+    @api.multi
+    def action_quotation_send(self):
+        '''
+        This function opens a window to compose an email, with the edi sale template message loaded by default
+        '''
+        self.ensure_one()
+        ir_model_data = self.env['ir.model.data']
+        try:
+            template_id = ir_model_data.get_object_reference('sale', 'email_template_edi_sale')[1]
+        except ValueError:
+            template_id = False
+        try:
+            compose_form_id = ir_model_data.get_object_reference('mail', 'email_compose_message_wizard_form')[1]
+        except ValueError:
+            compose_form_id = False
+        ctx = dict()
+        ctx.update({
+            'default_model': 'sale.order',
+            'default_res_id': self.ids[0],
+            'default_use_template': bool(template_id),
+            'default_template_id': template_id,
+            'default_composition_mode': 'comment',
+            'mark_so_as_sent': True,
+            'custom_layout': "sale.mail_template_data_notification_email_sale_order"
+        })
+        return {
+            'type': 'ir.actions.act_window',
+            'view_type': 'form',
+            'view_mode': 'form',
+            'res_model': 'mail.compose.message',
+            'views': [(compose_form_id, 'form')],
+            'view_id': compose_form_id,
+            'target': 'new',
+            'context': ctx,
+        }
+
+    @api.multi
+    def force_quotation_send(self):
+        for order in self:
+            email_act = order.action_quotation_send()
+            if email_act and email_act.get('context'):
+                email_ctx = email_act['context']
+                email_ctx.update(default_email_from=order.company_id.email)
+                order.with_context(email_ctx).message_post_with_template(email_ctx.get('default_template_id'))
+        return True
+
+    @api.multi
+    def action_done(self):
+        self.write({'state': 'done'})
+
+    @api.model
+    def _prepare_procurement_group(self):
+        return {'name': self.name}
+
+    @api.multi
+    def action_confirm(self):
+        for order in self:
+            order.state = 'sale'
+            order.confirmation_date = fields.Datetime.now()
+            if self.env.context.get('send_email'):
+                self.force_quotation_send()
+            order.order_line._action_procurement_create()
+        if self.env['ir.values'].get_default('sale.config.settings', 'auto_done_setting'):
+            self.action_done()
+        return True
+
+    @api.multi
+    def _create_analytic_account(self, prefix=None):
+        for order in self:
+            name = order.name
+            if prefix:
+                name = prefix + ": " + order.name
+            analytic = self.env['account.analytic.account'].create({
+                'name': name,
+                'code': order.client_order_ref,
+                'company_id': order.company_id.id,
+                'partner_id': order.partner_id.id
+            })
+            order.project_id = analytic
+
+    @api.multi
+    def _notification_group_recipients(self, message, recipients, done_ids, group_data):
+        group_user = self.env.ref('base.group_user')
+        for recipient in recipients:
+            if recipient.id in done_ids:
+                continue
+            if not recipient.user_ids:
+                group_data['partner'] |= recipient
+            else:
+                group_data['user'] |= recipient
+            done_ids.add(recipient.id)
+        return super(SaleOrder, self)._notification_group_recipients(message, recipients, done_ids, group_data)
+
+    @api.multi
+    def order_lines_layouted(self):
+        """
+        Returns this order lines classified by sale_layout_category and separated in
+        pages according to the category pagebreaks. Used to render the report.
+        """
+        self.ensure_one()
+        report_pages = [[]]
+        for category, lines in groupby(self.order_line, lambda l: l.layout_category_id):
+            # If last added category induced a pagebreak, this one will be on a new page
+            if report_pages[-1] and report_pages[-1][-1]['pagebreak']:
+                report_pages.append([])
+            # Append category to current report page
+            report_pages[-1].append({
+                'name': category and category.name or 'Uncategorized',
+                'subtotal': category and category.subtotal,
+                'pagebreak': category and category.pagebreak,
+                'lines': list(lines)
+            })
+
+        return report_pages
+
+    @api.multi
+    def _get_tax_amount_by_group(self):
+        self.ensure_one()
+        res = {}
+        currency = self.currency_id or self.company_id.currency_id
+        for line in self.order_line:
+            for tax in line.tax_id:
+                group = tax.tax_group_id
+                res.setdefault(group, 0.0)
+                res[group] += tax.compute_all(line.price_unit, quantity=line.product_uom_qty)['taxes'][0]['amount']
+        res = sorted(res.items(), key=lambda l: l[0].sequence)
+        res = map(lambda l: (l[0].name, formatLang(self.env, l[1], currency_obj=currency)), res)
+        return res
+
+class SaleOrderLine(models.Model):
+    _name = 'sale.order.line'
+    _description = 'Sales Order Line'
+    _order = 'order_id, layout_category_id, sequence, id'
+
+    @api.depends('state', 'product_uom_qty', 'qty_delivered', 'qty_to_invoice', 'qty_invoiced')
+    def _compute_invoice_status(self):
+        """
+        Compute the invoice status of a SO line. Possible statuses:
+        - no: if the SO is not in status 'sale' or 'done', we consider that there is nothing to
+          invoice. This is also hte default value if the conditions of no other status is met.
+        - to invoice: we refer to the quantity to invoice of the line. Refer to method
+          `_get_to_invoice_qty()` for more information on how this quantity is calculated.
+        - upselling: this is possible only for a product invoiced on ordered quantities for which
+          we delivered more than expected. The could arise if, for example, a project took more
+          time than expected but we decided not to invoice the extra cost to the client. This
+          occurs onyl in state 'sale', so that when a SO is set to done, the upselling opportunity
+          is removed from the list.
+        - invoiced: the quantity invoiced is larger or equal to the quantity ordered.
+        """
+        precision = self.env['decimal.precision'].precision_get('Product Unit of Measure')
+        for line in self:
+            if line.state not in ('sale', 'done'):
+                line.invoice_status = 'no'
+            elif not float_is_zero(line.qty_to_invoice, precision_digits=precision):
+                line.invoice_status = 'to invoice'
+            elif line.state == 'sale' and line.product_id.invoice_policy == 'order' and\
+                    float_compare(line.qty_delivered, line.product_uom_qty, precision_digits=precision) == 1:
+                line.invoice_status = 'upselling'
+            elif float_compare(line.qty_invoiced, line.product_uom_qty, precision_digits=precision) >= 0:
+                line.invoice_status = 'invoiced'
+            else:
+                line.invoice_status = 'no'
+
+    @api.depends('product_uom_qty', 'discount', 'price_unit', 'tax_id')
+    def _compute_amount(self):
+        """
+        Compute the amounts of the SO line.
+        """
+        for line in self:
+            price = line.price_unit * (1 - (line.discount or 0.0) / 100.0)
+            taxes = line.tax_id.compute_all(price, line.order_id.currency_id, line.product_uom_qty, product=line.product_id, partner=line.order_id.partner_id)
+            line.update({
+                'price_tax': taxes['total_included'] - taxes['total_excluded'],
+                'price_total': taxes['total_included'],
+                'price_subtotal': taxes['total_excluded'],
+            })
+
+    @api.depends('product_id.invoice_policy', 'order_id.state')
+    def _compute_qty_delivered_updateable(self):
+        for line in self:
+            line.qty_delivered_updateable = (line.order_id.state == 'sale') and (line.product_id.track_service == 'manual') and (line.product_id.expense_policy=='no')
+
+    @api.depends('qty_invoiced', 'qty_delivered', 'product_uom_qty', 'order_id.state')
+    def _get_to_invoice_qty(self):
+        """
+        Compute the quantity to invoice. If the invoice policy is order, the quantity to invoice is
+        calculated from the ordered quantity. Otherwise, the quantity delivered is used.
+        """
+        for line in self:
+            if line.order_id.state in ['sale', 'done']:
+                if line.product_id.invoice_policy == 'order':
+                    line.qty_to_invoice = line.product_uom_qty - line.qty_invoiced
+                else:
+                    line.qty_to_invoice = line.qty_delivered - line.qty_invoiced
+            else:
+                line.qty_to_invoice = 0
+
+    @api.depends('invoice_lines.invoice_id.state', 'invoice_lines.quantity')
+    def _get_invoice_qty(self):
+        """
+        Compute the quantity invoiced. If case of a refund, the quantity invoiced is decreased. Note
+        that this is the case only if the refund is generated from the SO and that is intentional: if
+        a refund made would automatically decrease the invoiced quantity, then there is a risk of reinvoicing
+        it automatically, which may not be wanted at all. That's why the refund has to be created from the SO
+        """
+        for line in self:
+            qty_invoiced = 0.0
+            for invoice_line in line.invoice_lines:
+                if invoice_line.invoice_id.state != 'cancel':
+                    if invoice_line.invoice_id.type == 'out_invoice':
+                        qty_invoiced += invoice_line.uom_id._compute_quantity(invoice_line.quantity, line.product_uom)
+                    elif invoice_line.invoice_id.type == 'out_refund':
+                        qty_invoiced -= invoice_line.uom_id._compute_quantity(invoice_line.quantity, line.product_uom)
+            line.qty_invoiced = qty_invoiced
+
+    @api.depends('price_unit', 'discount')
+    def _get_price_reduce(self):
+        for line in self:
+            line.price_reduce = line.price_unit * (1.0 - line.discount / 100.0)
+
+    @api.depends('price_total', 'product_uom_qty')
+    def _get_price_reduce_tax(self):
+        for line in self:
+            line.price_reduce_taxinc = line.price_total / line.product_uom_qty if line.product_uom_qty else 0.0
+
+    @api.depends('price_subtotal', 'product_uom_qty')
+    def _get_price_reduce_notax(self):
+        for line in self:
+            line.price_reduce_taxexcl = line.price_subtotal / line.product_uom_qty if line.product_uom_qty else 0.0
+
+    @api.multi
+    def _compute_tax_id(self):
+        for line in self:
+            fpos = line.order_id.fiscal_position_id or line.order_id.partner_id.property_account_position_id
+            # If company_id is set, always filter taxes by the company
+            taxes = line.product_id.taxes_id.filtered(lambda r: not line.company_id or r.company_id == line.company_id)
+            line.tax_id = fpos.map_tax(taxes, line.product_id, line.order_id.partner_id) if fpos else taxes
+
+    @api.multi
+    def _prepare_order_line_procurement(self, group_id=False):
+        self.ensure_one()
+        return {
+            'name': self.name,
+            'origin': self.order_id.name,
+            'date_planned': datetime.strptime(self.order_id.date_order, DEFAULT_SERVER_DATETIME_FORMAT) + timedelta(days=self.customer_lead),
+            'product_id': self.product_id.id,
+            'product_qty': self.product_uom_qty,
+            'product_uom': self.product_uom.id,
+            'company_id': self.order_id.company_id.id,
+            'group_id': group_id,
+            'sale_line_id': self.id
+        }
+
+    @api.multi
+    def _action_procurement_create(self):
+        """
+        Create procurements based on quantity ordered. If the quantity is increased, new
+        procurements are created. If the quantity is decreased, no automated action is taken.
+        """
+        precision = self.env['decimal.precision'].precision_get('Product Unit of Measure')
+        new_procs = self.env['procurement.order'] #Empty recordset
+        for line in self:
+            if line.state != 'sale' or not line.product_id._need_procurement():
+                continue
+            qty = 0.0
+            for proc in line.procurement_ids:
+                qty += proc.product_qty
+            if float_compare(qty, line.product_uom_qty, precision_digits=precision) >= 0:
+                continue
+
+            if not line.order_id.procurement_group_id:
+                vals = line.order_id._prepare_procurement_group()
+                line.order_id.procurement_group_id = self.env["procurement.group"].create(vals)
+
+            vals = line._prepare_order_line_procurement(group_id=line.order_id.procurement_group_id.id)
+            vals['product_qty'] = line.product_uom_qty - qty
+            new_proc = self.env["procurement.order"].create(vals)
+            new_proc.message_post_with_view('mail.message_origin_link',
+                values={'self': new_proc, 'origin': line.order_id},
+                subtype_id=self.env.ref('mail.mt_note').id)
+            new_procs += new_proc
+        new_procs.run()
+        return new_procs
+
+    @api.model
+    def create(self, values):
+        onchange_fields = ['name', 'price_unit', 'product_uom', 'tax_id']
+        if values.get('order_id') and values.get('product_id') and any(f not in values for f in onchange_fields):
+            line = self.new(values)
+            line.product_id_change()
+            for field in onchange_fields:
+                if field not in values:
+                    values[field] = line._fields[field].convert_to_write(line[field], line)
+        line = super(SaleOrderLine, self).create(values)
+        if line.state == 'sale':
+            line._action_procurement_create()
+
+        return line
+
+    @api.multi
+    def write(self, values):
+        lines = False
+        if 'product_uom_qty' in values:
+            precision = self.env['decimal.precision'].precision_get('Product Unit of Measure')
+            lines = self.filtered(
+                lambda r: r.state == 'sale' and float_compare(r.product_uom_qty, values['product_uom_qty'], precision_digits=precision) == -1)
+        result = super(SaleOrderLine, self).write(values)
+        if lines:
+            lines._action_procurement_create()
+        return result
+
+    order_id = fields.Many2one('sale.order', string='Order Reference', required=True, ondelete='cascade', index=True, copy=False)
+    name = fields.Text(string='Description', required=True)
+    sequence = fields.Integer(string='Sequence', default=10)
+
+    invoice_lines = fields.Many2many('account.invoice.line', 'sale_order_line_invoice_rel', 'order_line_id', 'invoice_line_id', string='Invoice Lines', copy=False)
+    invoice_status = fields.Selection([
+        ('upselling', 'Upselling Opportunity'),
+        ('invoiced', 'Fully Invoiced'),
+        ('to invoice', 'To Invoice'),
+        ('no', 'Nothing to Invoice')
+        ], string='Invoice Status', compute='_compute_invoice_status', store=True, readonly=True, default='no')
+    price_unit = fields.Float('Unit Price', required=True, digits=dp.get_precision('Product Price'), default=0.0)
+
+    price_subtotal = fields.Monetary(compute='_compute_amount', string='Subtotal', readonly=True, store=True)
+    price_tax = fields.Monetary(compute='_compute_amount', string='Taxes', readonly=True, store=True)
+    price_total = fields.Monetary(compute='_compute_amount', string='Total', readonly=True, store=True)
+
+    price_reduce = fields.Monetary(compute='_get_price_reduce', string='Price Reduce', readonly=True, store=True)
+    tax_id = fields.Many2many('account.tax', string='Taxes', domain=['|', ('active', '=', False), ('active', '=', True)])
+    price_reduce_taxinc = fields.Monetary(compute='_get_price_reduce_tax', string='Price Reduce Tax inc', readonly=True, store=True)
+    price_reduce_taxexcl = fields.Monetary(compute='_get_price_reduce_notax', string='Price Reduce Tax excl', readonly=True, store=True)
+
+    discount = fields.Float(string='Discount (%)', digits=dp.get_precision('Discount'), default=0.0)
+
+    product_id = fields.Many2one('product.product', string='Product', domain=[('sale_ok', '=', True)], change_default=True, ondelete='restrict', required=True)
+    product_uom_qty = fields.Float(string='Quantity', digits=dp.get_precision('Product Unit of Measure'), required=True, default=1.0)
+    product_uom = fields.Many2one('product.uom', string='Unit of Measure', required=True)
+
+    qty_delivered_updateable = fields.Boolean(compute='_compute_qty_delivered_updateable', string='Can Edit Delivered', readonly=True, default=True)
+    qty_delivered = fields.Float(string='Delivered', copy=False, digits=dp.get_precision('Product Unit of Measure'), default=0.0)
+    qty_to_invoice = fields.Float(
+        compute='_get_to_invoice_qty', string='To Invoice', store=True, readonly=True,
+        digits=dp.get_precision('Product Unit of Measure'), default=0.0)
+    qty_invoiced = fields.Float(
+        compute='_get_invoice_qty', string='Invoiced', store=True, readonly=True,
+        digits=dp.get_precision('Product Unit of Measure'), default=0.0)
+
+    salesman_id = fields.Many2one(related='order_id.user_id', store=True, string='Salesperson', readonly=True)
+    currency_id = fields.Many2one(related='order_id.currency_id', store=True, string='Currency', readonly=True)
+    company_id = fields.Many2one(related='order_id.company_id', string='Company', store=True, readonly=True)
+    order_partner_id = fields.Many2one(related='order_id.partner_id', store=True, string='Customer')
+    analytic_tag_ids = fields.Many2many('account.analytic.tag', string='Analytic Tags')
+
+    state = fields.Selection([
+        ('draft', 'Quotation'),
+        ('sent', 'Quotation Sent'),
+        ('sale', 'Sale Order'),
+        ('done', 'Done'),
+        ('cancel', 'Cancelled'),
+    ], related='order_id.state', string='Order Status', readonly=True, copy=False, store=True, default='draft')
+
+    customer_lead = fields.Float(
+        'Delivery Lead Time', required=True, default=0.0,
+        help="Number of days between the order confirmation and the shipping of the products to the customer", oldname="delay")
+    procurement_ids = fields.One2many('procurement.order', 'sale_line_id', string='Procurements')
+
+    layout_category_id = fields.Many2one('sale.layout_category', string='Section')
+    layout_category_sequence = fields.Integer(related='layout_category_id.sequence', string='Layout Sequence', store=True)
+    #  Store is intentionally set in order to keep the "historic" order.
+
+    @api.multi
+    def _prepare_invoice_line(self, qty):
+        """
+        Prepare the dict of values to create the new invoice line for a sales order line.
+
+        :param qty: float quantity to invoice
+        """
+        self.ensure_one()
+        res = {}
+        account = self.product_id.property_account_income_id or self.product_id.categ_id.property_account_income_categ_id
+        if not account:
+            raise UserError(_('Please define income account for this product: "%s" (id:%d) - or for its category: "%s".') % \
+                            (self.product_id.name, self.product_id.id, self.product_id.categ_id.name))
+
+        fpos = self.order_id.fiscal_position_id or self.order_id.partner_id.property_account_position_id
+        if fpos:
+            account = fpos.map_account(account)
+
+        res = {
+            'name': self.name,
+            'sequence': self.sequence,
+            'origin': self.order_id.name,
+            'account_id': account.id,
+            'price_unit': self.price_unit,
+            'quantity': qty,
+            'discount': self.discount,
+            'uom_id': self.product_uom.id,
+            'product_id': self.product_id.id or False,
+            'layout_category_id': self.layout_category_id and self.layout_category_id.id or False,
+            'product_id': self.product_id.id or False,
+            'invoice_line_tax_ids': [(6, 0, self.tax_id.ids)],
+            'account_analytic_id': self.order_id.project_id.id,
+            'analytic_tag_ids': [(6, 0, self.analytic_tag_ids.ids)],
+        }
+        return res
+
+    @api.multi
+    def invoice_line_create(self, invoice_id, qty):
+        """
+        Create an invoice line. The quantity to invoice can be positive (invoice) or negative
+        (refund).
+
+        :param invoice_id: integer
+        :param qty: float quantity to invoice
+        """
+        precision = self.env['decimal.precision'].precision_get('Product Unit of Measure')
+        for line in self:
+            if not float_is_zero(qty, precision_digits=precision):
+                vals = line._prepare_invoice_line(qty=qty)
+                vals.update({'invoice_id': invoice_id, 'sale_line_ids': [(6, 0, [line.id])]})
+                self.env['account.invoice.line'].create(vals)
+
+    @api.multi
+    def _get_display_price(self, product):
+        return product.price
+
+    @api.multi
+    @api.onchange('product_id')
+    def product_id_change(self):
+        if not self.product_id:
+            return {'domain': {'product_uom': []}}
+
+        vals = {}
+        domain = {'product_uom': [('category_id', '=', self.product_id.uom_id.category_id.id)]}
+        if not self.product_uom or (self.product_id.uom_id.category_id.id != self.product_uom.category_id.id):
+            vals['product_uom'] = self.product_id.uom_id
+
+        product = self.product_id.with_context(
+            lang=self.order_id.partner_id.lang,
+            partner=self.order_id.partner_id.id,
+            quantity=self.product_uom_qty,
+            date=self.order_id.date_order,
+            pricelist=self.order_id.pricelist_id.id,
+            uom=self.product_uom.id
+        )
+
+        name = product.name_get()[0][1]
+        if product.description_sale:
+            name += '\n' + product.description_sale
+        vals['name'] = name
+
+        self._compute_tax_id()
+
+        if self.order_id.pricelist_id and self.order_id.partner_id:
+            vals['price_unit'] = self.env['account.tax']._fix_tax_included_price(self._get_display_price(product), product.taxes_id, self.tax_id)
+        self.update(vals)
+
+        title = False
+        message = False
+        warning = {}
+        if product.sale_line_warn != 'no-message':
+            title = _("Warning for %s") % product.name
+            message = product.sale_line_warn_msg
+            warning['title'] = title
+            warning['message'] = message
+            if product.sale_line_warn == 'block':
+                self.product_id = False
+            return {'warning': warning}
+        return {'domain': domain}
+
+    @api.onchange('product_uom', 'product_uom_qty')
+    def product_uom_change(self):
+        if not self.product_uom:
+            self.price_unit = 0.0
+            return
+        if self.order_id.pricelist_id and self.order_id.partner_id:
+            product = self.product_id.with_context(
+                lang=self.order_id.partner_id.lang,
+                partner=self.order_id.partner_id.id,
+                quantity=self.product_uom_qty,
+                date_order=self.order_id.date_order,
+                pricelist=self.order_id.pricelist_id.id,
+                uom=self.product_uom.id,
+                fiscal_position=self.env.context.get('fiscal_position')
+            )
+            self.price_unit = self.env['account.tax']._fix_tax_included_price(self._get_display_price(product), product.taxes_id, self.tax_id)
+
+    @api.multi
+    def unlink(self):
+        if self.filtered(lambda x: x.state in ('sale', 'done')):
+            raise UserError(_('You can not remove a sale order line.\nDiscard changes and try setting the quantity to 0.'))
+        return super(SaleOrderLine, self).unlink()
+
+    @api.multi
+    def _get_delivered_qty(self):
+        '''
+        Intended to be overridden in sale_stock and sale_mrp
+        :return: the quantity delivered
+        :rtype: float
+        '''
+        return 0.0
+
+
+class MailComposeMessage(models.TransientModel):
+    _inherit = 'mail.compose.message'
+
+    @api.multi
+    def send_mail(self, auto_commit=False):
+        if self._context.get('default_model') == 'sale.order' and self._context.get('default_res_id') and self._context.get('mark_so_as_sent'):
+            order = self.env['sale.order'].browse([self._context['default_res_id']])
+            if order.state == 'draft':
+                order.state = 'sent'
+        return super(MailComposeMessage, self.with_context(mail_post_autofollow=True)).send_mail(auto_commit=auto_commit)
+
+
+class AccountInvoice(models.Model):
+    _inherit = 'account.invoice'
+
+    @api.model
+    def _get_default_team(self):
+        return self.env['crm.team']._get_default_team_id()
+
+    def _default_comment(self):
+        invoice_type = self.env.context.get('type', 'out_invoice')
+        if invoice_type == 'out_invoice':
+            return self.env.user.company_id.sale_note
+
+    team_id = fields.Many2one('crm.team', string='Sales Team', default=_get_default_team, oldname='section_id')
+    comment = fields.Text(default=_default_comment)
+    partner_shipping_id = fields.Many2one(
+        'res.partner',
+        string='Delivery Address',
+        readonly=True,
+        states={'draft': [('readonly', False)]},
+        help="Delivery address for current invoice.")
+
+    @api.onchange('partner_shipping_id')
+    def _onchange_partner_shipping_id(self):
+        """
+        Trigger the change of fiscal position when the shipping address is modified.
+        """
+        fiscal_position = self.env['account.fiscal.position'].get_fiscal_position(self.partner_id.id, self.partner_shipping_id.id)
+        if fiscal_position:
+            self.fiscal_position_id = fiscal_position
+
+    @api.onchange('partner_id', 'company_id')
+    def _onchange_delivery_address(self):
+        addr = self.partner_id.address_get(['delivery'])
+        self.partner_shipping_id = addr and addr.get('delivery')
+
+    @api.multi
+    def confirm_paid(self):
+        res = super(AccountInvoice, self).confirm_paid()
+        todo = set()
+        for invoice in self:
+            for line in invoice.invoice_line_ids:
+                for sale_line in line.sale_line_ids:
+                    todo.add((sale_line.order_id, invoice.number))
+        for (order, name) in todo:
+            order.message_post(body=_("Invoice %s paid") % (name))
+        return res
+
+    @api.model
+    def _refund_cleanup_lines(self, lines):
+        result = super(AccountInvoice, self)._refund_cleanup_lines(lines)
+        if self.env.context.get('mode') == 'modify':
+            for i in xrange(0, len(lines)):
+                for name, field in lines[i]._fields.iteritems():
+                    if name == 'sale_line_ids':
+                        result[i][2][name] = [(6, 0, lines[i][name].ids)]
+                        lines[i][name] = False
+        return result
+
+    @api.multi
+    def order_lines_layouted(self):
+        """
+        Returns this sale order lines ordered by sale_layout_category sequence. Used to render the report.
+        """
+        self.ensure_one()
+        report_pages = [[]]
+        for category, lines in groupby(self.invoice_line_ids, lambda l: l.layout_category_id):
+            # If last added category induced a pagebreak, this one will be on a new page
+            if report_pages[-1] and report_pages[-1][-1]['pagebreak']:
+                report_pages.append([])
+            # Append category to current report page
+            report_pages[-1].append({
+                'name': category and category.name or 'Uncategorized',
+                'subtotal': category and category.subtotal,
+                'pagebreak': category and category.pagebreak,
+                'lines': list(lines)
+            })
+
+        return report_pages
+
+class AccountInvoiceLine(models.Model):
+    _inherit = 'account.invoice.line'
+    _order = 'invoice_id, layout_category_id, sequence, id'
+
+    sale_line_ids = fields.Many2many('sale.order.line', 'sale_order_line_invoice_rel', 'invoice_line_id', 'order_line_id', string='Sale Order Lines', readonly=True, copy=False)
+    layout_category_id = fields.Many2one('sale.layout_category', string='Section')
+    layout_category_sequence = fields.Integer(related='layout_category_id.sequence', string='Layout Sequence', store=True, default=0)
+
+
+class ProcurementOrder(models.Model):
+    _inherit = 'procurement.order'
+    sale_line_id = fields.Many2one('sale.order.line', string='Sale Order Line')
+
+
+class ProductProduct(models.Model):
+    _inherit = 'product.product'
+
+    @api.multi
+    def _sales_count(self):
+        r = {}
+        domain = [
+            ('state', 'in', ['sale', 'done']),
+            ('product_id', 'in', self.ids),
+        ]
+        for group in self.env['sale.report'].read_group(domain, ['product_id', 'product_uom_qty'], ['product_id']):
+            r[group['product_id'][0]] = group['product_uom_qty']
+        for product in self:
+            product.sales_count = r.get(product.id, 0)
+        return r
+
+    sales_count = fields.Integer(compute='_sales_count', string='# Sales')
+
+
+class ProductTemplate(models.Model):
+    _inherit = 'product.template'
+    track_service = fields.Selection([('manual', 'Manually set quantities on order')], string='Track Service',
+        help="Manually set quantities on order: Invoice based on the manually entered quantity, without creating an analytic account.\n"
+             "Timesheets on contract: Invoice based on the tracked hours on the related timesheet.\n"
+             "Create a task and track hours: Create a task on the sale order validation and track the work hours.",
+        default='manual')
+    sale_line_warn = fields.Selection(WARNING_MESSAGE, 'Sales Order Line', help=WARNING_HELP, required=True, default="no-message")
+    sale_line_warn_msg = fields.Text('Message for Sales Order Line')
+    expense_policy = fields.Selection(
+        [('no', 'No'), ('cost', 'At cost'), ('sales_price', 'At sale price')],
+        string='Re-Invoice Expenses',
+        default='no')
+    @api.multi
+    @api.depends('product_variant_ids.sales_count')
+    def _sales_count(self):
+        for product in self:
+            product.sales_count = sum([p.sales_count for p in product.product_variant_ids])
+
+    @api.multi
+    def action_view_sales(self):
+        self.ensure_one()
+        action = self.env.ref('sale.action_product_sale_list')
+        product_ids = self.product_variant_ids.ids
+
+        return {
+            'name': action.name,
+            'help': action.help,
+            'type': action.type,
+            'view_type': action.view_type,
+            'view_mode': action.view_mode,
+            'target': action.target,
+            'context': "{'default_product_id': " + str(product_ids[0]) + "}",
+            'res_model': action.res_model,
+            'domain': [('state', 'in', ['sale', 'done']), ('product_id.product_tmpl_id', '=', self.id)],
+        }
+
+    sales_count = fields.Integer(compute='_sales_count', string='# Sales')
+    invoice_policy = fields.Selection(
+        [('order', 'Ordered quantities'),
+         ('delivery', 'Delivered quantities'),
+        ], string='Invoicing Policy', help='Ordered Quantity: Invoice based on the quantity the customer ordered.\n'
+                                        'Delivered Quantity: Invoiced based on the quantity the vendor delivered (time or deliveries).',
+                                        default='order')

--- a/None
+++ b/addons/sale/models/sale_analytic.py
@@ -0,0 +1,120 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from openerp import api, fields, models, _
+from openerp.exceptions import UserError
+
+
+class SaleOrderLine(models.Model):
+    _inherit = "sale.order.line"
+
+    @api.multi
+    def _compute_analytic(self, domain=None):
+        lines = {}
+        if not domain:
+            # To filter on analyic lines linked to an expense
+            domain = [('so_line', 'in', self.ids), ('amount', '<=', 0.0)]
+        data = self.env['account.analytic.line'].read_group(
+            domain,
+            ['so_line', 'unit_amount', 'product_uom_id'], ['product_uom_id', 'so_line'], lazy=False
+        )
+        for d in data:
+            if not d['product_uom_id']:
+                continue
+            line = self.browse(d['so_line'][0])
+            lines.setdefault(line, 0.0)
+            uom = self.env['product.uom'].browse(d['product_uom_id'][0])
+            if line.product_uom.category_id == uom.category_id:
+                qty = uom._compute_quantity(d['unit_amount'], line.product_uom)
+            else:
+                qty = d['unit_amount']
+            lines[line] += qty
+
+        for line, qty in lines.items():
+            line.qty_delivered = qty
+        return True
+
+
+class AccountAnalyticLine(models.Model):
+    _inherit = "account.analytic.line"
+    so_line = fields.Many2one('sale.order.line', string='Sale Order Line')
+
+    def _get_invoice_price(self, order):
+        if self.product_id.expense_policy == 'sales_price':
+            return self.product_id.with_context(
+                partner=order.partner_id.id,
+                date_order=order.date_order,
+                pricelist=order.pricelist_id.id,
+                uom=self.product_uom_id.id
+            ).price
+        if self.unit_amount == 0.0:
+            return 0.0
+        price_unit = abs(self.amount / self.unit_amount)
+        currency_id = self.currency_id or self.account_id.currency_id
+        if currency_id and currency_id != order.currency_id:
+            price_unit = currency_id.compute(price_unit, order.currency_id)
+        return price_unit
+
+    def _get_sale_order_line_vals(self, order, price):
+        last_so_line = self.env['sale.order.line'].search([('order_id', '=', order.id)], order='sequence desc', limit=1)
+        last_sequence = last_so_line.sequence + 1 if last_so_line else 100
+
+        fpos = order.fiscal_position_id or order.partner_id.property_account_position_id
+        taxes = fpos.map_tax(self.product_id.taxes_id, self.product_id, order.partner_id)
+
+        return {
+            'order_id': order.id,
+            'name': self.name,
+            'sequence': last_sequence,
+            'price_unit': price,
+            'tax_id': [x.id for x in taxes],
+            'discount': 0.0,
+            'product_id': self.product_id.id,
+            'product_uom': self.product_uom_id.id,
+            'product_uom_qty': 0.0,
+            'qty_delivered': self.unit_amount,
+        }
+
+    def _get_sale_order_line(self, vals=None):
+        result = dict(vals or {})
+        so_line = result.get('so_line', False) or self.so_line
+        if not so_line and self.account_id and self.product_id and (self.product_id.expense_policy!='no'):
+            order = self.env['sale.order'].search([('project_id', '=', self.account_id.id), ('state','=','sale')], limit=1)
+            if not order:
+                return result
+            price = self._get_invoice_price(order)
+            so_lines = self.env['sale.order.line'].search([
+                ('order_id', '=', order.id),
+                ('price_unit', '=', price),
+                ('product_id', '=', self.product_id.id)])
+
+            if so_lines:
+                result.update({'so_line': so_lines[0].id})
+            else:
+                order_line_vals = self._get_sale_order_line_vals(order, price)
+                if order_line_vals:
+                    so_line = self.env['sale.order.line'].create(order_line_vals)
+                    so_line._compute_tax_id()
+                    result.update({'so_line': so_line.id})
+        return result
+
+    @api.multi
+    def write(self, values):
+        if self._context.get('create', False):
+            return super(AccountAnalyticLine, self).write(values)
+
+        lines = super(AccountAnalyticLine, self).write(values)
+        for line in self:
+            res = line.sudo()._get_sale_order_line(vals=values)
+            super(AccountAnalyticLine, line).write(res)
+
+        self.mapped('so_line').sudo()._compute_analytic()
+        return lines
+
+    @api.model
+    def create(self, values):
+        line = super(AccountAnalyticLine, self).create(values)
+        res = line.sudo()._get_sale_order_line(vals=values)
+        line.with_context(create=True).write(res)
+        line.mapped('so_line').sudo()._compute_analytic()
+        return line

--- a/None
+++ b/addons/sale/models/sale_config_settings.py
@@ -0,0 +1,141 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+import logging
+
+from openerp import SUPERUSER_ID
+from openerp.osv import fields, osv
+
+_logger = logging.getLogger(__name__)
+
+
+class sale_configuration(osv.TransientModel):
+    _inherit = 'sale.config.settings'
+
+    _columns = {
+        'group_product_variant': fields.selection([
+            (0, "No variants on products"),
+            (1, 'Products can have several attributes, defining variants (Example: size, color,...)')
+            ], "Product Variants",
+            help='Work with product variant allows you to define some variant of the same products, an ease the product management in the ecommerce for example',
+            implied_group='product.group_product_variant'),
+        'group_sale_pricelist':fields.boolean("Use pricelists to adapt your price per customers",implied_group='product.group_sale_pricelist',
+            help="""Allows to manage different prices based on rules per category of customers.
+                    Example: 10% for retailers, promotion of 5 EUR on this product, etc."""),
+        'group_pricelist_item':fields.boolean("Show pricelists to customers", implied_group='product.group_pricelist_item'),
+        'group_product_pricelist':fields.boolean("Show pricelists On Products", implied_group='product.group_product_pricelist'),
+        'group_uom':fields.selection([
+            (0, 'Products have only one unit of measure (easier)'),
+            (1, 'Some products may be sold/purchased in different units of measure (advanced)')
+            ], "Units of Measure",
+            implied_group='product.group_uom',
+            help="""Allows you to select and maintain different units of measure for products."""),
+        'group_discount_per_so_line': fields.selection([
+            (0, 'No discount on sales order lines, global discount only'),
+            (1, 'Allow discounts on sales order lines')
+            ], "Discount",
+            implied_group='sale.group_discount_per_so_line'),
+        'group_display_incoterm':fields.selection([
+            (0, 'No incoterm on reports'),
+            (1, 'Show incoterms on sale orders and invoices')
+            ], "Incoterms",
+            implied_group='sale.group_display_incoterm',
+            help="The printed reports will display the incoterms for the sale orders and the related invoices"),
+        'module_product_visible_discount': fields.selection([
+            (0, 'No discount policy on sale order line'),
+            (1, 'Allow discount policy on sale order line')
+            ], "Discount Policy"),
+        'module_sale_margin': fields.selection([
+            (0, 'Salespeople do not need to view margins when quoting'),
+            (1, 'Display margins on quotations and sales orders')
+            ], "Margins"),
+        'group_sale_layout': fields.selection([
+            (0, 'Do not personalize sale orders and invoice reports'),
+            (1, 'Personalize the sale orders and invoice report with categories, subtotals and page-breaks')
+            ], "Sale Reports Layout", implied_group='sale.group_sale_layout'),
+        'group_warning_sale': fields.selection([
+            (0, 'All the products and the customers can be used in sale orders'),
+            (1, 'An informative or blocking warning can be set on a product or a customer')
+            ], "Warning", implied_group='sale.group_warning_sale'),
+        'module_website_quote': fields.selection([
+            (0, 'Print quotes or send by email'),
+            (1, 'Send online quotations based on templates (advanced)')
+            ], "Online Quotations"),
+        'group_sale_delivery_address': fields.selection([
+            (0, "Invoicing and shipping addresses are always the same (Example: services companies)"),
+            (1, 'Display 3 fields on sales orders: customer, invoice address, delivery address')
+            ], "Addresses", implied_group='sale.group_delivery_invoice_address'),
+        'sale_pricelist_setting': fields.selection([('fixed', 'A single sale price per product'), ('percentage', 'Different prices per customer segment'), ('formula', 'Advanced pricing based on formula')], required=True,
+            help='Fix Price: all price manage from products sale price.\n'
+                 'Different prices per Customer: you can assign price on buying of minimum quantity in products sale tab.\n'
+                 'Advanced pricing based on formula: You can have all the rights on pricelist'),
+        'group_show_price_subtotal': fields.boolean("Show subtotal", implied_group='sale.group_show_price_subtotal', group='base.group_portal,base.group_user,base.group_public'),
+        'group_show_price_total': fields.boolean("Show total", implied_group='sale.group_show_price_total', group='base.group_portal,base.group_user,base.group_public'),
+        'sale_show_tax': fields.selection([
+            ('subtotal', 'Show line subtotals without taxes (B2B)'),
+            ('total', 'Show line subtotals with taxes included (B2C)')], "Tax Display",
+            required=True),
+        'default_invoice_policy': fields.selection([
+            ('order', 'Invoice ordered quantities'),
+            ('delivery', 'Invoice delivered quantities')
+            ], 'Default Invoicing', default_model='product.template'),
+        'deposit_product_id_setting': fields.many2one('product.product', 'Deposit Product',\
+            domain="[('type', '=', 'service')]",\
+            help='Default product used for payment advances'),
+        'auto_done_setting': fields.selection([
+            (0, "Allow to edit sales order from the 'Sales Order' menu (not from the Quotation menu)"),
+            (1, "Never allow to modify a confirmed sale order")
+            ], "Sale Order Modification"),
+        'module_sale_contract': fields.boolean("Manage subscriptions and recurring invoicing"),
+        'module_website_sale_digital': fields.boolean("Sell digital products - provide downloadable content on your customer portal"),
+        'module_website_portal': fields.boolean("Enable customer portal to track orders, delivery and invoices"),
+        'module_sale_order_dates': fields.selection([
+            (0, 'Procurements and deliveries dates are based on the sale order dates'),
+            (1, 'Allow to modify the sale order dates to postpone deliveries and procurements')
+            ], "Date"),
+    }
+
+    _defaults = {
+        'sale_pricelist_setting': 'fixed',
+        'sale_show_tax': 'subtotal',
+        'default_invoice_policy': 'order',
+    }
+
+    def set_sale_defaults(self, cr, uid, ids, context=None):
+        sale_price = self.browse(cr, uid, ids, context=context).sale_pricelist_setting
+        res = self.pool.get('ir.values').set_default(cr, SUPERUSER_ID, 'sale.config.settings', 'sale_pricelist_setting', sale_price)
+        return res
+
+    def set_deposit_product_id_defaults(self, cr, uid, ids, context=None):
+        deposit_product_id = self.browse(cr, uid, ids, context=context).deposit_product_id_setting
+        res = self.pool.get('ir.values').set_default(cr, SUPERUSER_ID, 'sale.config.settings', 'deposit_product_id_setting', deposit_product_id.id)
+        return res
+
+    def set_auto_done_defaults(self, cr, uid, ids, context=None):
+        auto_done = self.browse(cr, uid, ids, context=context).auto_done_setting
+        res = self.pool.get('ir.values').set_default(cr, SUPERUSER_ID, 'sale.config.settings', 'auto_done_setting', auto_done)
+        return res
+
+    def onchange_sale_price(self, cr, uid, ids, sale_pricelist_setting, context=None):
+        if sale_pricelist_setting == 'percentage':
+            return {'value': {'group_product_pricelist': True, 'group_sale_pricelist': True, 'group_pricelist_item': False}}
+        if sale_pricelist_setting == 'formula':
+            return {'value': {'group_pricelist_item': True, 'group_sale_pricelist': True, 'group_product_pricelist': False}}
+        return {'value': {'group_pricelist_item': False, 'group_sale_pricelist': False, 'group_product_pricelist': False}}
+
+    def set_sale_tax_defaults(self, cr, uid, ids, context=None):
+        sale_tax = self.browse(cr, uid, ids, context=context).sale_show_tax
+        res = self.pool.get('ir.values').set_default(cr, SUPERUSER_ID, 'sale.config.settings', 'sale_show_tax', sale_tax)
+        return res
+
+    def onchange_sale_tax(self, cr, uid, ids, sale_show_tax, context=None):
+        res = {'value': dict(group_show_price_subtotal=False, group_show_price_total=False)}
+        res['value']['group_show_price_%s' % sale_show_tax] = True
+        return res
+class account_config_settings(osv.osv_memory):
+    _inherit = 'account.config.settings'
+    _columns = {
+        'group_analytic_account_for_sales': fields.boolean('Analytic accounting for sales',
+            implied_group='sale.group_analytic_accounting',
+            help="Allows you to specify an analytic account on sales orders."),
+    }

--- a/None
+++ b/addons/sale/models/sale_layout.py
@@ -0,0 +1,21 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from openerp.osv import osv, fields
+
+
+class SaleLayoutCategory(osv.Model):
+    _name = 'sale.layout_category'
+    _order = 'sequence, id'
+    _columns = {
+        'name': fields.char('Name', required=True, translate=True),
+        'sequence': fields.integer('Sequence', required=True),
+        'subtotal': fields.boolean('Add subtotal'),
+        'pagebreak': fields.boolean('Add pagebreak')
+    }
+
+    _defaults = {
+        'subtotal': True,
+        'pagebreak': False,
+        'sequence': 10
+    }

--- a/None
+++ b/addons/sale/models/sales_team.py
@@ -0,0 +1,65 @@
+# -*- coding: utf-8 -*-
+
+import calendar
+from datetime import date
+from dateutil import relativedelta
+import json
+
+from openerp import tools
+from openerp.osv import fields, osv
+from openerp.tools.float_utils import float_repr
+
+class crm_team(osv.Model):
+    _inherit = 'crm.team'
+
+    def _get_sales_to_invoice_amount(self, cr, uid, ids, field_name, arg, context=None):
+        obj = self.pool['sale.order']
+
+        res = dict.fromkeys(ids, 0)
+        domain = [
+            ('team_id', 'in', ids),
+            ('invoice_status', '=', 'to invoice'),
+        ]
+        amounts = obj.read_group(cr, uid, domain, ['amount_total', 'team_id'], ['team_id'], context=context)
+        for rec in amounts:
+            res[rec['team_id'][0]] = rec['amount_total']
+        return res
+
+    def _get_monthly_invoiced(self, cr, uid, ids, field_name, arg, context=None):
+        obj_inv = self.pool['account.invoice']
+        res = dict.fromkeys(ids, 0)
+
+        # Cannot use read_group because amount_untaxed_signed is an unstored computed field
+        for team in ids:
+            domain = [
+                ('state', 'in', ['open', 'paid']),
+                ('team_id', '=', team),
+                ('date', '<=', date.today()),
+                ('date', '>=', date.today().replace(day=1))
+            ]
+            invoices = obj_inv.search_read(cr, uid, domain, ['amount_untaxed_signed'], context=context)
+            res[team] = sum([inv['amount_untaxed_signed'] for inv in invoices])
+        return res
+
+    _columns = {
+        'use_quotations': fields.boolean('Quotations', help="Check this box to manage quotations in this sales team."),
+        'use_invoices': fields.boolean('Invoices', help="Check this box to manage invoices in this sales team."),
+        'invoiced': fields.function(_get_monthly_invoiced, type='integer', readonly=True, string='Invoiced This Month',
+            help="Invoice revenue for the current month. This is the amount the sales "
+                    "team has invoiced this month. It is used to compute the progression ratio "
+                    "of the current and target revenue on the kanban view."),
+        'invoiced_target': fields.integer(string='Invoice Target',
+            help="Target of invoice revenue for the current month. This is the amount the sales "
+                    "team estimates to be able to invoice this month."),
+        'sales_to_invoice_amount': fields.function(_get_sales_to_invoice_amount,
+            type='integer', readonly=True,
+            string='Amount of sales to invoice'),
+        'currency_id': fields.related('company_id', 'currency_id', type="many2one", relation="res.currency", string="Currency", readonly=True, required=True),
+    }
+
+    _defaults = {
+        'use_quotations': True,
+    }
+
+    def update_invoiced_target(self, cr, uid, id, value, context=None):
+        return self.write(cr, uid, [id], {'invoiced_target': round(float(value or 0))}, context=context)
