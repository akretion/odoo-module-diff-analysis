PR: https://github.com/odoo/odoo/pull/34470

From: 50163143a915635eda08dc1f053e057c38871f42
From: Kevin Baptiste
Date: 2019-07-16 11:44:35

Structural Changes: 18
Total Changes: 83

[IMP] lunch: Improve the general UX (back2basics)

- Reorganize configure your order screen
- Alert users through chat: Alerts can now be configured to
send a chat message to the employees.
- Replace toppings by extras

closes odoo/odoo#34470

Signed-off-by: Yannick Tivisse (yti) <yti@odoo.com>

================================= pseudo patch: =================================

--- a/addons/lunch/models/lunch_alert.py
+++ b/addons/lunch/models/lunch_alert.py
@@ -1,9 +1,14 @@
 # -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
+import pytz
 
 from odoo import api, fields, models
 from odoo.osv import expression
 
+from .lunch_supplier import float_to_time
+from datetime import datetime, timedelta
+
+from odoo.addons.base.models.res_partner import _tz_get
 
 WEEKDAY_TO_NAME = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday']
 
@@ -14,9 +19,23 @@ class LunchAlert(models.Model):
     _description = 'Lunch Alert'
     _order = 'write_date desc, id'
 
-    name = fields.Char(required=True)
+    name = fields.Char('Alert Name', required=True)
     message = fields.Html('Message', required=True)
 
+    mode = fields.Selection([
+        ('alert', 'Alert in app'),
+        ('chat', 'Chat notification')], string='Display', default='alert')
+    recipients = fields.Selection([
+        ('everyone', 'Everyone'),
+        ('last_week', 'Employee who ordered last week'),
+        ('last_month', 'Employee who ordered last month'),
+        ('last_year', 'Employee who ordered last year')], string='Recipients', default='everyone')
+    notification_time = fields.Float(default=10.0, string='Notification Time')
+    notification_moment = fields.Selection([
+        ('am', 'AM'),
+        ('pm', 'PM')], default='am', required=True)
+    tz = fields.Selection(_tz_get, string='Timezone', required=True, default=lambda self: self.env.user.tz or 'UTC')
+
     until = fields.Date('Show Until')
     recurrency_monday = fields.Boolean('Monday')
     recurrency_tuesday = fields.Boolean('Tuesday')
@@ -33,6 +52,12 @@ class LunchAlert(models.Model):
 
     location_ids = fields.Many2many('lunch.location', string='Location')
 
+    _sql_constraints = [
+        ('notification_time_range',
+            'CHECK(notification_time >= 0 and notification_time <= 12)',
+            'Notification time must be between 0 and 12')
+    ]
+
     @api.depends('recurrency_monday', 'recurrency_tuesday', 'recurrency_wednesday',
                  'recurrency_thursday', 'recurrency_friday', 'recurrency_saturday',
                  'recurrency_sunday')
@@ -58,3 +83,37 @@ class LunchAlert(models.Model):
                 [('until', '>' if searching_for_true else '<', today)],
             ])
         ])
+
+    def _notify_chat(self):
+        records = self.search([('mode', '=', 'chat'), ('active', '=', True)])
+
+        today = fields.Date.today()
+        now = fields.Datetime.now()
+
+        for alert in records:
+            notification_to = now.astimezone(pytz.timezone(alert.tz)).replace(second=0, microsecond=0, tzinfo=None)
+            notification_from = notification_to - timedelta(minutes=5)
+            send_at = datetime.combine(fields.Date.today(),
+                float_to_time(alert.notification_time, alert.notification_moment))
+
+            if alert.available_today and send_at > notification_from and send_at <= notification_to:
+                order_domain = [('state', '!=', 'cancelled')]
+
+                if alert.location_ids.ids:
+                    order_domain = expression.AND([order_domain, [('user_id.last_lunch_location_id', 'in', alert.location_ids.ids)]])
+
+                if alert.recipients != 'everyone':
+                    weeks = 1
+
+                    if alert.recipients == 'last_month':
+                        weeks = 4
+                    else:  # last_year
+                        weeks = 52
+
+                    delta = timedelta(weeks=weeks)
+                    order_domain = expression.AND([order_domain, [('date', '>=', today - delta)]])
+
+                orders = self.env['lunch.order'].search(order_domain).mapped('user_id')
+                partner_ids = [user.partner_id.id for user in orders]
+                if partner_ids:
+                    self.env['mail.thread'].message_notify(body=alert.message, partner_ids=partner_ids)

--- a/addons/lunch/models/lunch_order.py
+++ b/addons/lunch/models/lunch_order.py
@@ -12,9 +12,9 @@ class LunchOrder(models.Model):
     _display_name = 'product_id'
 
     name = fields.Char(related='product_id.name', string="Product Name", readonly=True)  # to remove
-    topping_ids_1 = fields.Many2many('lunch.topping', 'lunch_order_topping', 'order_id', 'topping_id', string='Toppings 1', domain=[('topping_category', '=', 1)])
-    topping_ids_2 = fields.Many2many('lunch.topping', 'lunch_order_topping', 'order_id', 'topping_id', string='Toppings 2', domain=[('topping_category', '=', 2)])
-    topping_ids_3 = fields.Many2many('lunch.topping', 'lunch_order_topping', 'order_id', 'topping_id', string='Toppings 3', domain=[('topping_category', '=', 3)])
+    topping_ids_1 = fields.Many2many('lunch.topping', 'lunch_order_topping', 'order_id', 'topping_id', string='Extras 1', domain=[('topping_category', '=', 1)])
+    topping_ids_2 = fields.Many2many('lunch.topping', 'lunch_order_topping', 'order_id', 'topping_id', string='Extras 2', domain=[('topping_category', '=', 2)])
+    topping_ids_3 = fields.Many2many('lunch.topping', 'lunch_order_topping', 'order_id', 'topping_id', string='Extras 3', domain=[('topping_category', '=', 3)])
     product_id = fields.Many2one('lunch.product', string="Product", required=True)
     category_id = fields.Many2one('lunch.product.category', string='Product Category',
                                   related='product_id.category_id', readonly=True, store=True)
@@ -39,7 +39,7 @@ class LunchOrder(models.Model):
     currency_id = fields.Many2one('res.currency', related='company_id.currency_id', readonly=True, store=True)
     quantity = fields.Float('Quantity', required=True, default=1)
 
-    display_toppings = fields.Text('Toppings', compute='_compute_display_toppings', store=True)
+    display_toppings = fields.Text('Extras', compute='_compute_display_toppings', store=True)
 
     def init(self):
         self._cr.execute("""CREATE INDEX IF NOT EXISTS lunch_order_user_product_date ON %s (user_id, product_id, date)"""

--- a/addons/lunch/models/lunch_product.py
+++ b/addons/lunch/models/lunch_product.py
@@ -14,24 +14,24 @@ class LunchProductCategory(models.Model):
     name = fields.Char('Product Category', required=True)
     company_id = fields.Many2one('res.company', default=lambda self: self.env.company)
     currency_id = fields.Many2one('res.currency', related='company_id.currency_id')
-    topping_label_1 = fields.Char('Topping 1 Label', required=True, default='Supplements')
-    topping_label_2 = fields.Char('Topping 2 Label', required=True, default='Beverages')
-    topping_label_3 = fields.Char('Topping 3 Label', required=True, default='Topping Label 3')
+    topping_label_1 = fields.Char('Extra 1 Label', required=True, default='Extras')
+    topping_label_2 = fields.Char('Extra 2 Label', required=True, default='Beverages')
+    topping_label_3 = fields.Char('Extra 3 Label', required=True, default='Extra Label 3')
     topping_ids_1 = fields.One2many('lunch.topping', 'category_id', domain=[('topping_category', '=', 1)], ondelete='cascade')
     topping_ids_2 = fields.One2many('lunch.topping', 'category_id', domain=[('topping_category', '=', 2)], ondelete='cascade')
     topping_ids_3 = fields.One2many('lunch.topping', 'category_id', domain=[('topping_category', '=', 3)], ondelete='cascade')
     topping_quantity_1 = fields.Selection([
         ('0_more', 'None or More'),
         ('1_more', 'One or More'),
-        ('1', 'Only One')], 'Topping 1 Quantity', default='0_more', required=True)
+        ('1', 'Only One')], 'Extra 1 Quantity', default='0_more', required=True)
     topping_quantity_2 = fields.Selection([
         ('0_more', 'None or More'),
         ('1_more', 'One or More'),
-        ('1', 'Only One')], 'Topping 2 Quantity', default='0_more', required=True)
+        ('1', 'Only One')], 'Extra 2 Quantity', default='0_more', required=True)
     topping_quantity_3 = fields.Selection([
         ('0_more', 'None or More'),
         ('1_more', 'One or More'),
-        ('1', 'Only One')], 'Topping 3 Quantity', default='0_more', required=True)
+        ('1', 'Only One')], 'Extra 3 Quantity', default='0_more', required=True)
     product_count = fields.Integer(compute='_compute_product_count', help="The number of products related to this category")
 
     def _compute_product_count(self):
@@ -63,7 +63,7 @@ class LunchProductCategory(models.Model):
 class LunchTopping(models.Model):
     """"""
     _name = 'lunch.topping'
-    _description = 'Lunch Toppings'
+    _description = 'Lunch Extras'
 
     name = fields.Char('Name', required=True)
     company_id = fields.Many2one('res.company', default=lambda self: self.env.company)
