PR: https://github.com/odoo/odoo/pull/33466

From: 35202202687f6292261ad01a3958df20bcf15264
From: svs-odoo
Date: 2019-06-24 12:56:02

Structural Changes: 3
Total Changes: 69

[IMP] stock: generate multiple SN/LN for SML

Adds a button in stock move form view to generate multiple serial number
and assigns them to stock move lines.
Through a wizard, the user enter the first SN. Then, starting with this
number, iterates to assign and increment the SN on each move line who
doesn't have already one.

Task #1832645

closes odoo/odoo#33466

Signed-off-by: Arnold Moyaux <amoyaux@users.noreply.github.com>

================================= pseudo patch: =================================

--- a/addons/stock/models/stock_move.py
+++ b/addons/stock/models/stock_move.py
@@ -5,6 +5,7 @@ from datetime import datetime
 from dateutil import relativedelta
 from itertools import groupby
 from operator import itemgetter
+from re import search as regex_search, split as regex_split
 
 from odoo import api, fields, models, _
 from odoo.addons import decimal_precision as dp
@@ -164,12 +165,23 @@ class StockMove(models.Model):
     has_move_lines = fields.Boolean(compute='_compute_has_move_lines')
     package_level_id = fields.Many2one('stock.package_level', 'Package Level')
     picking_type_entire_packs = fields.Boolean(related='picking_type_id.show_entire_packs', readonly=True)
+    display_assign_serial = fields.Boolean(compute='_compute_display_assign_serial')
+    next_serial = fields.Char('Next Serial Number')
 
     @api.onchange('product_id', 'picking_type_id')
     def onchange_product(self):
         if self.product_id:
             self.description_picking = self.product_id._get_description(self.picking_type_id)
 
+    @api.depends('has_tracking', 'picking_type_id.use_create_lots', 'picking_type_id.use_existing_lots')
+    def _compute_display_assign_serial(self):
+        for move in self:
+            move.display_assign_serial = (
+                move.has_tracking == 'serial' and
+                move.picking_type_id.use_create_lots and
+                not move.picking_type_id.use_existing_lots
+            )
+
     @api.depends('picking_id.is_locked')
     def _compute_is_locked(self):
         for move in self:
@@ -471,6 +483,27 @@ class StockMove(models.Model):
             ),
         }
 
+    def action_assign_serial_show_details(self):
+        """ On `self.move_line_ids`, assign `lot_name` according to
+        `self.next_serial` before returning `self.action_show_details`.
+        """
+        self.ensure_one()
+        if not self.next_serial:
+            raise UserError(_("You need to set a Serial Number before generating more."))
+        self._generate_serial_numbers()
+        return self.action_show_details()
+
+    def action_assign_serial(self):
+        """ Opens a wizard to assign SN's name on each move lines.
+        """
+        self.ensure_one()
+        action = self.env.ref('stock.act_assign_serial_numbers').read()[0]
+        action['context'] = {
+            'default_product_id': self.product_id.id,
+            'default_move_id': self.id,
+        }
+        return action
+
     def _do_unreserve(self):
         moves_to_unreserve = self.env['stock.move']
         for move in self:
@@ -487,6 +520,41 @@ class StockMove(models.Model):
         moves_to_unreserve.mapped('move_line_ids').unlink()
         return True
 
+    def _generate_serial_numbers(self):
+        """ This method will generate `lot_name` from a string (field
+        `next_serial`) and assign each `lot_name` to a move line.
+        """
+        self.ensure_one()
+        # We look if the serial number contains at least one digit.
+        caught_initial_number = regex_search("\d+", self.next_serial)
+        if not caught_initial_number:
+            raise UserError(_('The serial number must contain at least one digit.'))
+        initial_number = caught_initial_number.group()
+        padding = len(initial_number)
+        # We split the serial number to get the prefix and suffix.
+        splitted = regex_split(initial_number, self.next_serial)
+        prefix = splitted[0]
+        suffix = splitted[1]
+        initial_number = int(initial_number)
+
+        # Then, for each move line without `lot_id` and `lot_name`, we compute
+        # and assign the `lot_name` and set the `qty_done` to one.
+        move_lines_commands = []
+        for move_line in self.move_line_ids:
+            if not move_line.lot_id and not move_line.lot_name:
+                lot_name = '%s%s%s' % (
+                    prefix,
+                    str(initial_number).zfill(padding),
+                    suffix
+                )
+                initial_number += 1
+                move_lines_commands.append((1, move_line.id, {
+                    'lot_name': lot_name,
+                    'qty_done': 1
+                }))
+        self.write({'move_line_ids': move_lines_commands})
+        return True
+
     def _push_apply(self):
         for move in self:
             # if the move is already chained, there is no need to check push rules

--- a/addons/stock/models/stock_picking.py
+++ b/addons/stock/models/stock_picking.py
@@ -289,6 +289,7 @@ class Picking(models.Model):
     show_validate = fields.Boolean(
         compute='_compute_show_validate',
         help='Technical field used to compute whether the validate should be shown.')
+    use_create_lots = fields.Boolean(related='picking_type_id.use_create_lots')
 
     owner_id = fields.Many2one(
         'res.partner', 'Owner',
