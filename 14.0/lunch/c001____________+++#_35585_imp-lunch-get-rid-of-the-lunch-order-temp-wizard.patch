PR: https://github.com/odoo/odoo/pull/35585

From: 69319bba3e9ba20d14f6b30bd555f6d2d7478f0a
From: RomainLibert
Date: 2019-10-18 12:37:52

Structural Changes: 13
Total Changes: 131

[IMP] lunch: get rid of the lunch_order_temp wizard

Replace lunch.order.temp wizard by lunch.order (fp request)

closes odoo/odoo#35585

Taskid: 2048667
Signed-off-by: Yannick Tivisse (yti) <yti@odoo.com>

================================= pseudo patch: =================================

--- a/addons/lunch/models/lunch_order.py
+++ b/addons/lunch/models/lunch_order.py
@@ -41,10 +41,130 @@ class LunchOrder(models.Model):
 
     display_toppings = fields.Text('Extras', compute='_compute_display_toppings', store=True)
 
+    product_description = fields.Text('Description', related='product_id.description')
+    topping_label_1 = fields.Char(related='product_id.category_id.topping_label_1')
+    topping_label_2 = fields.Char(related='product_id.category_id.topping_label_2')
+    topping_label_3 = fields.Char(related='product_id.category_id.topping_label_3')
+    topping_quantity_1 = fields.Selection(related='product_id.category_id.topping_quantity_1')
+    topping_quantity_2 = fields.Selection(related='product_id.category_id.topping_quantity_2')
+    topping_quantity_3 = fields.Selection(related='product_id.category_id.topping_quantity_3')
+    image_1920 = fields.Image(related='product_id.image_1920')
+    image_128 = fields.Image(related='product_id.image_128')
+
+    available_toppings_1 = fields.Boolean(help='Are extras available for this product', compute='_compute_available_toppings')
+    available_toppings_2 = fields.Boolean(help='Are extras available for this product', compute='_compute_available_toppings')
+    available_toppings_3 = fields.Boolean(help='Are extras available for this product', compute='_compute_available_toppings')
+
+    # YTI TODO Try to remove this brol
+    edit = fields.Boolean('Currently in edit mode', compute='_compute_edit')
+
+    def _compute_edit(self):
+        value = bool(self._context.get('active_id', False))
+        for line in self:
+            line.edit = value
+
+    @api.depends('product_id')
+    def _compute_available_toppings(self):
+        for line in self:
+            line.available_toppings_1 = bool(line.env['lunch.topping'].search_count([('category_id', '=', line.category_id.id), ('topping_category', '=', 1)]))
+            line.available_toppings_2 = bool(line.env['lunch.topping'].search_count([('category_id', '=', line.category_id.id), ('topping_category', '=', 2)]))
+            line.available_toppings_3 = bool(line.env['lunch.topping'].search_count([('category_id', '=', line.category_id.id), ('topping_category', '=', 3)]))
+
     def init(self):
         self._cr.execute("""CREATE INDEX IF NOT EXISTS lunch_order_user_product_date ON %s (user_id, product_id, date)"""
             % self._table)
 
+
+    def _extract_toppings(self, values):
+        """
+            If called in api.multi then it will pop topping_ids_1,2,3 from values
+        """
+        if self.ids:
+            # TODO This is not taking into account all the toppings for each individual order, this is usually not a problem
+            # since in the interface you usually don't update more than one order at a time but this is a bug nonetheless
+            topping_1 = values.pop('topping_ids_1')[0][2] if 'topping_ids_1' in values else self[:1].topping_ids_1.ids
+            topping_2 = values.pop('topping_ids_2')[0][2] if 'topping_ids_2' in values else self[:1].topping_ids_2.ids
+            topping_3 = values.pop('topping_ids_3')[0][2] if 'topping_ids_3' in values else self[:1].topping_ids_3.ids
+        else:
+            topping_1 = values['topping_ids_1'][0][2] if 'topping_ids_1' in values else []
+            topping_2 = values['topping_ids_2'][0][2] if 'topping_ids_2' in values else []
+            topping_3 = values['topping_ids_3'][0][2] if 'topping_ids_3' in values else []
+
+        return topping_1 + topping_2 + topping_3
+
+    @api.constrains('topping_ids_1', 'topping_ids_2', 'topping_ids_3')
+    def _check_topping_quantity(self):
+        errors = {
+            '1_more': _('You should order at least one %s'),
+            '1': _('You have to order one and only one %s'),
+        }
+        for line in self:
+            for index in range(1, 4):
+                availability = line['available_toppings_%s' % index]
+                quantity = line['topping_quantity_%s' % index]
+                toppings = line['topping_ids_%s' % index].filtered(lambda x: x.topping_category == index)
+                label = line['topping_label_%s' % index]
+
+                if availability and quantity != '0_more':
+                    check = bool(len(toppings) == 1 if quantity == '1' else toppings)
+                    if not check:
+                        raise ValidationError(errors[quantity] % label)
+
+    @api.model
+    def create(self, values):
+        lines = self._find_matching_lines({
+            **values,
+            'toppings': self._extract_toppings(values),
+        })
+        if lines:
+            # YTI FIXME This will update multiple lines in the case there are multiple
+            # matching lines which should not happen through the interface
+            lines.update_quantity(1)
+            return lines[:1]
+        return super().create(values)
+
+    def write(self, values):
+        merge_needed = 'note' in values or 'topping_ids_1' in values or 'topping_ids_2' in values or 'topping_ids_3' in values
+
+        # Only write on topping_ids_1 because they all share the same table
+        # and we don't want to remove all the records
+        # _extract_toppings will pop topping_ids_1, topping_ids_2 and topping_ids_3 from values
+        # This also forces us to invalidate the cache for topping_ids_2 and topping_ids_3 that
+        # could have changed through topping_ids_1 without the cache knowing about it
+        toppings = self._extract_toppings(values)
+        values['topping_ids_1'] = [(6, 0, toppings)]
+        self.invalidate_cache(['topping_ids_2', 'topping_ids_3'])
+
+        if merge_needed:
+            lines_to_deactivate = self.env['lunch.order']
+            for line in self:
+                matching_lines = self._find_matching_lines({
+                    'user_id': values.get('user_id', line.user_id.id),
+                    'product_id': values.get('product_id', line.product_id.id),
+                    'note': values.get('note', line.note or False),
+                    'toppings': toppings,
+                })
+                if matching_lines:
+                    lines_to_deactivate |= line
+                    # YTI TODO Try to batch it, be careful there might be multiple matching
+                    # lines for the same order hence quantity should not always be
+                    # line.quantity, but rather a sum
+                    matching_lines.update_quantity(line.quantity)
+            lines_to_deactivate.write({'active': False})
+            return super(LunchOrder, self - lines_to_deactivate).write(values)
+        return super().write(values)
+
+    @api.model
+    def _find_matching_lines(self, values):
+        domain = [
+            ('user_id', '=', values.get('user_id', self.default_get(['user_id'])['user_id'])),
+            ('product_id', '=', values.get('product_id', False)),
+            ('date', '=', fields.Date.today()),
+            ('note', '=', values.get('note', False)),
+        ]
+        toppings = values.get('toppings', [])
+        return self.search(domain).filtered(lambda line: (line.topping_ids_1 | line.topping_ids_2 | line.topping_ids_3).ids == toppings)
+
     @api.depends('topping_ids_1', 'topping_ids_2', 'topping_ids_3', 'product_id', 'quantity')
     def _compute_total_price(self):
         for line in self:
@@ -65,12 +185,19 @@ class LunchOrder(models.Model):
                 line.quantity += increment
         self._check_wallet()
 
+    def add_to_cart(self):
+        """
+            This method currently does nothing, we currently need it in order to
+            be able to reuse this model in place of a wizard
+        """
+        # YTI FIXME: Find a way to drop this.
+        return True
+
     def _check_wallet(self):
         self.flush()
         for line in self:
             if self.env['lunch.cashmove'].get_wallet_balance(line.user_id) < 0:
-                raise ValidationError(_('Your wallet does not contain enough money to order that.'
-                        'To add some money to your wallet, please contact your lunch manager.'))
+                raise ValidationError(_('Your wallet does not contain enough money to order that. To add some money to your wallet, please contact your lunch manager.'))
 
     def action_order(self):
         self.write({'state': 'ordered'})
