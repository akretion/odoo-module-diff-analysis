PR: https://github.com/odoo/odoo/pull/

From: f488dc58c37fdc7fd49df759165de641e213444b
From: Dharmang Soni
Date: 2018-03-27 11:26:41

Structural Changes: 4
Total Changes: 97

[IMP] mail: allow to use stand alone activities as reminders

This commit allows to create personal reminders and to manage them using
activities. It is done using activities not necessarily linked to a record
but only to a user. Reminders can be used for example as a personal todo
list.

Technically we choose to model a reminder as an activity related to no
record. This means having a void res_id and model. An activity type is
added to classify reminders in it.

Settings reminder as done is not done like classic activities. Indeed classic
activities are unlinked and a message is logged on the related document.
As there is no document for reminders those are archived instead. It means
an active field is added as well as an override of toggle_archive to update
systray counter.

Activities systray widget is improved to display reminders in activities
list. This entry leads to a kanban view of activities allowing their
management. It is also possible to create them directly from the systray
allowing a quick creation of reminders.

This commit is related to task ID 41745. Closes #22143 .

Co-authored-by: Dharmang Soni <dpr@odoo.com>
Co-authored-by: Xavier Doll√© <xdo@odoo.com>

================================= pseudo patch: =================================

--- a/addons/mail/models/mail_activity.py
+++ b/addons/mail/models/mail_activity.py
@@ -5,6 +5,7 @@ from datetime import date, datetime, timedelta
 
 from odoo import api, exceptions, fields, models, _
 from odoo.osv import expression
+from odoo.tools import html2plaintext
 
 
 class MailActivityType(models.Model):
@@ -45,7 +46,7 @@ class MailActivityType(models.Model):
         'mail.activity.type', 'mail_activity_rel', 'recommended_id', 'activity_id',
         string='Preceding Activities')
     category = fields.Selection([
-        ('default', 'Other')], default='default',
+        ('default', 'Other'), ('reminder', 'Reminder')], default='default',
         string='Category',
         help='Categories may trigger specific behavior like opening calendar view')
 
@@ -69,10 +70,10 @@ class MailActivity(models.Model):
         return res
 
     # owner
-    res_id = fields.Integer('Related Document ID', index=True, required=True)
+    res_id = fields.Integer('Related Document ID', index=True)
     res_model_id = fields.Many2one(
         'ir.model', 'Document Model',
-        index=True, ondelete='cascade', required=True)
+        index=True, ondelete='cascade')
     res_model = fields.Char(
         'Related Document Model',
         index=True, related='res_model_id.model', store=True, readonly=True)
@@ -89,6 +90,9 @@ class MailActivity(models.Model):
     note = fields.Html('Note')
     feedback = fields.Html('Feedback')
     date_deadline = fields.Date('Due Date', index=True, required=True, default=fields.Date.today)
+    active = fields.Boolean(
+        'Open', default=True,
+        help='Done reminders should be archived instead of marked as done.')
     # description
     user_id = fields.Many2one(
         'res.users', 'Assigned to',
@@ -115,7 +119,8 @@ class MailActivity(models.Model):
     @api.depends('res_model', 'res_id')
     def _compute_res_name(self):
         for activity in self:
-            activity.res_name = self.env[activity.res_model].browse(activity.res_id).name_get()[0][1]
+            if activity.res_model and activity.res_id:
+                activity.res_name = self.env[activity.res_model].browse(activity.res_id).name_get()[0][1]
 
     @api.depends('date_deadline')
     def _compute_state(self):
@@ -162,11 +167,17 @@ class MailActivity(models.Model):
                 pass
             else:
                 return
-
         doc_operation = 'read' if operation == 'read' else 'write'
         activity_to_documents = dict()
         for activity in self.sudo():
-            activity_to_documents.setdefault(activity.res_model, list()).append(activity.res_id)
+            if activity.res_model and activity.res_id:
+                activity_to_documents.setdefault(activity.res_model, list()).append(activity.res_id)
+            else:
+                if (operation != 'create' and self.env.user.id != activity.user_id.id):
+                    raise exceptions.AccessError(_("You can only access your own records."))
+                elif operation == 'create' and not self.env.user.has_group('base.group_user'):
+                    raise exceptions.AccessError(_("Only employee can create reminder."))
+
         for model, res_ids in activity_to_documents.items():
             self.env[model].check_access_rights(doc_operation, raise_exception=True)
             try:
@@ -182,11 +193,19 @@ class MailActivity(models.Model):
         values_w_defaults = self.default_get(self._fields.keys())
         values_w_defaults.update(values)
 
+        # Reminder have no summary (for display name) It will add first line of note to summary.
+        if 'res_model_id' not in values and 'summary' not in values:
+            values_w_defaults['summary'] = self._compute_summary_from_note(values.get('note', _('Reminder')))
+
         # continue as sudo because activities are somewhat protected
         activity = super(MailActivity, self.sudo()).create(values_w_defaults)
         activity_user = activity.sudo(self.env.user)
         activity_user._check_access('create')
-        self.env[activity_user.res_model].browse(activity_user.res_id).message_subscribe(partner_ids=[activity_user.user_id.partner_id.id])
+
+        # subscribe to document if any
+        if activity.res_id and activity.res_model:
+            self.env[activity_user.res_model].browse(activity_user.res_id).message_subscribe(partner_ids=[activity_user.user_id.partner_id.id])
+
         if activity.date_deadline <= fields.Date.today():
             self.env['bus.bus'].sendone(
                 (self._cr.dbname, 'res.partner', activity.user_id.partner_id.id),
@@ -196,13 +215,28 @@ class MailActivity(models.Model):
     @api.multi
     def write(self, values):
         self._check_access('write')
+        if not self.env.user._is_admin() and any(field in values.keys() for field in ['res_model', 'res_id', 'res_model_id']):
+            raise exceptions.AccessError(_("You cannot re-attach a reminder to another record."))
+
         if values.get('user_id'):
             pre_responsibles = self.mapped('user_id.partner_id')
-        res = super(MailActivity, self.sudo()).write(values)
+
+        reminders = self.filtered(lambda a: not a.res_id and not a.res_model) if 'note' in values and 'summary' not in values else self.env['mail.activity']
+        activities = self - reminders
+        res = True
+        if activities:
+            res &= super(MailActivity, activities.sudo()).write(values)
+        if reminders:  # if we have reminder, note is set and summary is not set. We need to update summary
+            upd_values = dict(
+                values,
+                summary=self._compute_summary_from_note(values['note'])
+            )
+            res &= super(MailActivity, reminders.sudo()).write(upd_values)
 
         if values.get('user_id'):
             for activity in self:
-                self.env[activity.res_model].browse(activity.res_id).message_subscribe(partner_ids=[activity.user_id.partner_id.id])
+                if activity.res_id and activity.res_model:  # subscribe to document if any
+                    self.env[activity.res_model].browse(activity.res_id).message_subscribe(partner_ids=[activity.user_id.partner_id.id])
                 if activity.date_deadline <= fields.Date.today():
                     self.env['bus.bus'].sendone(
                         (self._cr.dbname, 'res.partner', activity.user_id.partner_id.id),
@@ -225,6 +259,29 @@ class MailActivity(models.Model):
                     {'type': 'activity_updated', 'activity_deleted': True})
         return super(MailActivity, self.sudo()).unlink()
 
+    @api.multi
+    def toggle_active(self):
+        """ Override model-method to send bus notification about (un)archived reminders """
+        res = super(MailActivity, self).toggle_active()
+        for activity in self:
+            if activity.active:
+                self.env['bus.bus'].sendone(
+                    (self._cr.dbname, 'res.partner', activity.user_id.partner_id.id),
+                    {'type': 'activity_updated', 'activity_created': True})
+            else:
+                self.env['bus.bus'].sendone(
+                    (self._cr.dbname, 'res.partner', activity.user_id.partner_id.id),
+                    {'type': 'activity_updated', 'activity_deleted': True})
+        return res
+
+    def _compute_summary_from_note(self, note):
+        """ Returns the first line of html note """
+        if note:
+            summary = html2plaintext(note).strip().replace('*', '').split("\n")[0]
+        else:
+            summary = _('Reminder')
+        return summary or _('Reminder')
+
     @api.multi
     def action_done(self):
         """ Wrapper without feedback because web button add context as

--- a/addons/mail/models/res_users.py
+++ b/addons/mail/models/res_users.py
@@ -70,15 +70,16 @@ class Users(models.Model):
 
     @api.model
     def activity_user_count(self):
-        query = """SELECT m.id, count(*), act.res_model as model,
+        # Reminders don't having any model so here we assign 'mail.activity' as reminder's model.
+        query = """SELECT m.id, count(*), act.res_model AS model,
                         CASE
                             WHEN now()::date - act.date_deadline::date = 0 Then 'today'
                             WHEN now()::date - act.date_deadline::date > 0 Then 'overdue'
                             WHEN now()::date - act.date_deadline::date < 0 Then 'planned'
                         END AS states
                     FROM mail_activity AS act
-                    JOIN ir_model AS m ON act.res_model_id = m.id
-                    WHERE user_id = %s
+                    LEFT OUTER JOIN ir_model AS m ON act.res_model_id = m.id
+                    WHERE user_id = %s AND active = TRUE
                     GROUP BY m.id, states, act.res_model;
                     """
         self.env.cr.execute(query, [self.env.uid])
@@ -86,7 +87,18 @@ class Users(models.Model):
         model_ids = [a['id'] for a in activity_data]
         model_names = {n[0]:n[1] for n in self.env['ir.model'].browse(model_ids).name_get()}
 
-        user_activities = {}
+        # always add default entry for reminders
+        user_activities = {
+            None: {
+                'name': _("Reminder"),
+                'model': None,
+                'icon': '/mail/static/src/img/reminder.png',
+                'total_count': 0,
+                'today_count': 0,
+                'overdue_count': 0,
+                'planned_count': 0
+            }
+        }
         for activity in activity_data:
             if not user_activities.get(activity['model']):
                 user_activities[activity['model']] = {
@@ -96,7 +108,7 @@ class Users(models.Model):
                     'total_count': 0, 'today_count': 0, 'overdue_count': 0, 'planned_count': 0,
                 }
             user_activities[activity['model']]['%s_count' % activity['states']] += activity['count']
-            if activity['states'] in ('today','overdue'):
+            if activity['states'] in ('today', 'overdue'):
                 user_activities[activity['model']]['total_count'] += activity['count']
 
         return list(user_activities.values())
