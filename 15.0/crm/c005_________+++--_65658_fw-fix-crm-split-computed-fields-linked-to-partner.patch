PR: https://github.com/odoo/odoo/pull/65658

From: c146e637796689f0de79ede70356dcc8081a0e76
From: Thibault Delavall√©e
Date: 2021-02-05 17:51:33

Structural Changes: 16
Total Changes: 96

[FW][FIX] crm: split computed fields linked to partner

RATIONALE

Stored editable fields receive their values either from compute either from
user input. If a user input is given to create / write compute method is not
called. If multiple fields are computed through the same method giving one
field value discard call to compute method and other fields are not called.

SPECIFICATIONS

Split ``_compute_partner_id_values`` compute method so that partner related
fields are independent :

  * have a method for address fields as those are computed in group. Indeed
    either we take all from partner either none. Otherwise it would create mixed
    addresses that make no sense;
  * have a specific computation for partner_name and contact_name coming
    from ``_prepare_partner_values``;
  * have other fields separated (function, title, ...) acting like related on partner
    if not set by user;

LINKS

COM PR odoo/odoo#65381
Task ID-2451339

X-original-commit odoo/odoo@78eb46352efd5c7a6aa6933fd891cb08fafbf679

closes odoo/odoo#65658

X-original-commit: bb13421d3a7f04ede9350b3b28c1650c3d9890f8
Signed-off-by: Thibault Delavallee (tde) <tde@openerp.com>

================================= pseudo patch: =================================

--- a/addons/crm/models/crm_lead.py
+++ b/addons/crm/models/crm_lead.py
@@ -175,40 +175,40 @@ class Lead(models.Model):
     partner_is_blacklisted = fields.Boolean('Partner is blacklisted', related='partner_id.is_blacklisted', readonly=True)
     contact_name = fields.Char(
         'Contact Name', tracking=30,
-        compute='_compute_partner_id_values', readonly=False, store=True)
+        compute='_compute_contact_name', readonly=False, store=True)
     partner_name = fields.Char(
         'Company Name', tracking=20, index=True,
-        compute='_compute_partner_id_values', readonly=False, store=True,
+        compute='_compute_partner_name', readonly=False, store=True,
         help='The name of the future partner company that will be created while converting the lead into opportunity')
-    function = fields.Char('Job Position', compute='_compute_partner_id_values', readonly=False, store=True)
-    title = fields.Many2one('res.partner.title', string='Title',compute='_compute_partner_id_values', readonly=False, store=True)
+    function = fields.Char('Job Position', compute='_compute_function', readonly=False, store=True)
+    title = fields.Many2one('res.partner.title', string='Title', compute='_compute_title', readonly=False, store=True)
     email_from = fields.Char(
         'Email', tracking=40, index=True,
         compute='_compute_email_from', inverse='_inverse_email_from', readonly=False, store=True)
     phone = fields.Char(
         'Phone', tracking=50,
         compute='_compute_phone', inverse='_inverse_phone', readonly=False, store=True)
-    mobile = fields.Char('Mobile', compute='_compute_partner_id_values', readonly=False, store=True)
+    mobile = fields.Char('Mobile', compute='_compute_mobile', readonly=False, store=True)
     phone_state = fields.Selection([
         ('correct', 'Correct'),
         ('incorrect', 'Incorrect')], string='Phone Quality', compute="_compute_phone_state", store=True)
     email_state = fields.Selection([
         ('correct', 'Correct'),
         ('incorrect', 'Incorrect')], string='Email Quality', compute="_compute_email_state", store=True)
-    website = fields.Char('Website', index=True, help="Website of the contact", compute="_compute_partner_id_values", store=True, readonly=False)
+    website = fields.Char('Website', index=True, help="Website of the contact", compute="_compute_website", readonly=False, store=True)
     lang_id = fields.Many2one('res.lang', string='Language')
     # Address fields
-    street = fields.Char('Street', compute='_compute_partner_id_values', readonly=False, store=True)
-    street2 = fields.Char('Street2', compute='_compute_partner_id_values', readonly=False, store=True)
-    zip = fields.Char('Zip', change_default=True, compute='_compute_partner_id_values', readonly=False, store=True)
-    city = fields.Char('City', compute='_compute_partner_id_values', readonly=False, store=True)
+    street = fields.Char('Street', compute='_compute_partner_address_values', readonly=False, store=True)
+    street2 = fields.Char('Street2', compute='_compute_partner_address_values', readonly=False, store=True)
+    zip = fields.Char('Zip', change_default=True, compute='_compute_partner_address_values', readonly=False, store=True)
+    city = fields.Char('City', compute='_compute_partner_address_values', readonly=False, store=True)
     state_id = fields.Many2one(
         "res.country.state", string='State',
-        compute='_compute_partner_id_values', readonly=False, store=True,
+        compute='_compute_partner_address_values', readonly=False, store=True,
         domain="[('country_id', '=?', country_id)]")
     country_id = fields.Many2one(
         'res.country', string='Country',
-        compute='_compute_partner_id_values', readonly=False, store=True)
+        compute='_compute_partner_address_values', readonly=False, store=True)
     # Probability (Opportunity only)
     probability = fields.Float(
         'Probability', group_operator="avg", copy=False,
@@ -356,10 +356,50 @@ class Lead(models.Model):
                 lead.name = _("%s's opportunity") % lead.partner_id.name
 
     @api.depends('partner_id')
-    def _compute_partner_id_values(self):
+    def _compute_contact_name(self):
         """ compute the new values when partner_id has changed """
         for lead in self:
-            lead.update(lead._prepare_values_from_partner(lead.partner_id))
+            lead.update(lead._prepare_contact_name_from_partner(lead.partner_id))
+
+    @api.depends('partner_id')
+    def _compute_partner_name(self):
+        """ compute the new values when partner_id has changed """
+        for lead in self:
+            lead.update(lead._prepare_partner_name_from_partner(lead.partner_id))
+
+    @api.depends('partner_id')
+    def _compute_function(self):
+        """ compute the new values when partner_id has changed """
+        for lead in self:
+            if not lead.function or lead.partner_id.function:
+                lead.function = lead.partner_id.function
+
+    @api.depends('partner_id')
+    def _compute_title(self):
+        """ compute the new values when partner_id has changed """
+        for lead in self:
+            if not lead.title or lead.partner_id.title:
+                lead.title = lead.partner_id.title
+
+    @api.depends('partner_id')
+    def _compute_mobile(self):
+        """ compute the new values when partner_id has changed """
+        for lead in self:
+            if not lead.mobile or lead.partner_id.mobile:
+                lead.mobile = lead.partner_id.mobile
+
+    @api.depends('partner_id')
+    def _compute_website(self):
+        """ compute the new values when partner_id has changed """
+        for lead in self:
+            if not lead.website or lead.partner_id.website:
+                lead.website = lead.partner_id.website
+
+    @api.depends('partner_id')
+    def _compute_partner_address_values(self):
+        """ Sync all or none of address fields """
+        for lead in self:
+            lead.update(lead._prepare_address_values_from_partner(lead.partner_id))
 
     @api.depends('partner_id.email')
     def _compute_email_from(self):
@@ -499,25 +539,35 @@ class Lead(models.Model):
         copy on a lead. Non-address fields get the current lead
         values to avoid being reset if partner has no value for them. """
 
+        # Sync all address fields from partner, or none, to avoid mixing them.
+        values = self._prepare_address_values_from_partner(partner)
+
+        # For other fields, get the info from the partner, but only if set
+        values.update({f: partner[f] or self[f] for f in PARTNER_FIELDS_TO_SYNC})
+
+        # Fields with specific logic
+        values.update(self._prepare_contact_name_from_partner(partner))
+        values.update(self._prepare_partner_name_from_partner(partner))
+
+        return self._convert_to_write(values)
+
+    def _prepare_address_values_from_partner(self, partner):
         # Sync all address fields from partner, or none, to avoid mixing them.
         if any(partner[f] for f in PARTNER_ADDRESS_FIELDS_TO_SYNC):
             values = {f: partner[f] for f in PARTNER_ADDRESS_FIELDS_TO_SYNC}
         else:
             values = {f: self[f] for f in PARTNER_ADDRESS_FIELDS_TO_SYNC}
+        return values
 
-        # For other fields, get the info from the partner, but only if set
-        values.update({f: partner[f] or self[f] for f in PARTNER_FIELDS_TO_SYNC})
+    def _prepare_contact_name_from_partner(self, partner):
+        contact_name = False if partner.is_company else partner.name
+        return {'contact_name': contact_name or self.contact_name}
 
-        # Fields with specific logic
+    def _prepare_partner_name_from_partner(self, partner):
         partner_name = partner.parent_id.name
         if not partner_name and partner.is_company:
             partner_name = partner.name
-        contact_name = False if partner.is_company else partner.name
-        values.update({
-            'partner_name': partner_name or self.partner_name,
-            'contact_name': contact_name or self.contact_name,
-        })
-        return self._convert_to_write(values)
+        return {'partner_name': partner_name or self.partner_name}
 
     # ------------------------------------------------------------
     # ORM
