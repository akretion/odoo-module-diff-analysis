PR: https://github.com/odoo/odoo/pull/67331

From: 04522f01e6fdbf82a657b32b312449fd7d756f79
From: Nicolas (vin)
Date: 2021-06-03 10:00:26

Breaking data model changes scores: del:8 + add:4, change matches:
-    payment_debit_account_id = fields.Many2one(
-    payment_credit_account_id = fields.Many2one(
-    inbound_payment_method_ids = fields.Many2many(
+    inbound_payment_method_line_ids = fields.One2many(
-    outbound_payment_method_ids = fields.Many2many(
+    outbound_payment_method_line_ids = fields.One2many(
-    at_least_one_inbound = fields.Boolean(compute='_methods_compute', store=True)
-    at_least_one_outbound = fields.Boolean(compute='_methods_compute', store=True)
+    available_payment_method_ids = fields.Many2many(
+    available_payment_method_ids = fields.Many2many(related='journal_id.available_payment_method_ids')

Total Changes: 524

[IMP] account: allows multiple payment acquirers on a journal.

Users may want to be able to have transactions coming from multiple
payment acquirers to be registered in the same journal.

This will allows that.

Task id #2414749

closes odoo/odoo#67331

Related: odoo/upgrade#2500
Related: odoo/enterprise#17258
Signed-off-by: William Andr√© (wan) <wan@odoo.com>

================================= pseudo patch: =================================

--- a/addons/account/models/account_account.py
+++ b/addons/account/models/account_account.py
@@ -131,22 +131,57 @@ class AccountAccount(models.Model):
         self.env['account.journal'].flush([
             'currency_id',
             'default_account_id',
-            'payment_debit_account_id',
-            'payment_credit_account_id',
             'suspense_account_id',
         ])
+        self.env['account.payment.method'].flush(['payment_type'])
+        self.env['account.payment.method.line'].flush(['payment_method_id', 'payment_account_id'])
+
         self._cr.execute('''
-            SELECT account.id, journal.id
-            FROM account_account account
-            JOIN res_company company ON company.id = account.company_id
-            JOIN account_journal journal ON
-                journal.default_account_id = account.id
-            WHERE account.id IN %s
-            AND journal.type IN ('bank', 'cash')
-            AND journal.currency_id IS NOT NULL
+            SELECT 
+                account.id, 
+                journal.id
+            FROM account_journal journal
+            JOIN res_company company ON company.id = journal.company_id
+            JOIN account_account account ON account.id = journal.default_account_id
+            WHERE journal.currency_id IS NOT NULL
             AND journal.currency_id != company.currency_id
             AND account.currency_id != journal.currency_id
-        ''', [tuple(self.ids)])
+            AND account.id IN %(accounts)s
+            
+            UNION ALL
+            
+            SELECT 
+                account.id, 
+                journal.id
+            FROM account_journal journal
+            JOIN res_company company ON company.id = journal.company_id
+            JOIN account_payment_method_line apml ON apml.journal_id = journal.id
+            JOIN account_payment_method apm on apm.id = apml.payment_method_id
+            JOIN account_account account ON account.id = COALESCE(apml.payment_account_id, company.account_journal_payment_debit_account_id)
+            WHERE journal.currency_id IS NOT NULL
+            AND journal.currency_id != company.currency_id
+            AND account.currency_id != journal.currency_id
+            AND apm.payment_type = 'inbound'
+            AND account.id IN %(accounts)s
+            
+            UNION ALL
+            
+            SELECT 
+                account.id, 
+                journal.id
+            FROM account_journal journal
+            JOIN res_company company ON company.id = journal.company_id
+            JOIN account_payment_method_line apml ON apml.journal_id = journal.id
+            JOIN account_payment_method apm on apm.id = apml.payment_method_id
+            JOIN account_account account ON account.id = COALESCE(apml.payment_account_id, company.account_journal_payment_credit_account_id)
+            WHERE journal.currency_id IS NOT NULL
+            AND journal.currency_id != company.currency_id
+            AND account.currency_id != journal.currency_id
+            AND apm.payment_type = 'outbound'
+            AND account.id IN %(accounts)s
+        ''', {
+            'accounts': tuple(self.ids)
+        })
         res = self._cr.fetchone()
         if res:
             account = self.env['account.account'].browse(res[0])
@@ -200,14 +235,18 @@ class AccountAccount(models.Model):
             return
 
         self.flush(['reconcile'])
+        self.env['account.payment.method.line'].flush(['journal_id', 'payment_account_id'])
+
         self._cr.execute('''
             SELECT journal.id
             FROM account_journal journal
-            WHERE journal.payment_credit_account_id in %(credit_account)s
-            OR journal.payment_debit_account_id in %(debit_account)s ;
+            JOIN res_company company on journal.company_id = company.id
+            LEFT JOIN account_payment_method_line apml ON journal.id = apml.journal_id
+            WHERE company.account_journal_payment_credit_account_id in %(accounts)s
+            OR company.account_journal_payment_debit_account_id in %(accounts)s
+            OR apml.payment_account_id in %(accounts)s
         ''', {
-            'credit_account': tuple(accounts.ids),
-            'debit_account': tuple(accounts.ids)
+            'accounts': tuple(accounts.ids),
         })
 
         rows = self._cr.fetchall()

--- a/addons/account/models/account_bank_statement.py
+++ b/addons/account/models/account_bank_statement.py
@@ -1189,10 +1189,7 @@ class AccountBankStatementLine(models.Model):
         new_lines = self.env['account.move.line'].create(line_vals_list)
         new_lines = new_lines.with_context(skip_account_move_synchronization=True)
         for reconciliation_vals, line in zip(reconciliation_overview, new_lines):
-            if reconciliation_vals.get('payment'):
-                accounts = (self.journal_id.payment_debit_account_id, self.journal_id.payment_credit_account_id)
-                counterpart_line = reconciliation_vals['payment'].line_ids.filtered(lambda line: line.account_id in accounts)
-            elif reconciliation_vals.get('counterpart_line'):
+            if reconciliation_vals.get('counterpart_line'):
                 counterpart_line = reconciliation_vals['counterpart_line']
             else:
                 continue

--- a/addons/account/models/account_journal.py
+++ b/addons/account/models/account_journal.py
@@ -1,5 +1,5 @@
 # -*- coding: utf-8 -*-
-from odoo import api, fields, models, _
+from odoo import api, Command, fields, models, _
 from odoo.osv import expression
 from odoo.exceptions import UserError, ValidationError
 from odoo.addons.base.models.res_bank import sanitize_account_number
@@ -79,26 +79,6 @@ class AccountJournal(models.Model):
         domain="[('deprecated', '=', False), ('company_id', '=', company_id),"
                "'|', ('user_type_id', '=', default_account_type), ('user_type_id', 'in', type_control_ids),"
                "('user_type_id.type', 'not in', ('receivable', 'payable'))]")
-    payment_debit_account_id = fields.Many2one(
-        comodel_name='account.account', check_company=True, ondelete='restrict',
-        compute='_compute_payment_debit_account_id', store=True, readonly=False,
-        help="Incoming payments entries triggered by invoices/refunds will be posted on the Outstanding Receipts Account "
-             "and displayed as blue lines in the bank reconciliation widget. During the reconciliation process, concerned "
-             "transactions will be reconciled with entries on the Outstanding Receipts Account instead of the "
-             "receivable account.", string='Outstanding Receipts Account',
-        domain=lambda self: "[('deprecated', '=', False), ('company_id', '=', company_id), \
-                             ('user_type_id.type', 'not in', ('receivable', 'payable')), \
-                             '|', ('user_type_id', '=', %s), ('id', '=', default_account_id)]" % self.env.ref('account.data_account_type_current_assets').id)
-    payment_credit_account_id = fields.Many2one(
-        comodel_name='account.account', check_company=True, ondelete='restrict',
-        compute='_compute_payment_credit_account_id', store=True, readonly=False,
-        help="Outgoing payments entries triggered by bills/credit notes will be posted on the Outstanding Payments Account "
-             "and displayed as blue lines in the bank reconciliation widget. During the reconciliation process, concerned "
-             "transactions will be reconciled with entries on the Outstanding Payments Account instead of the "
-             "payable account.", string='Outstanding Payments Account',
-        domain=lambda self: "[('deprecated', '=', False), ('company_id', '=', company_id), \
-                             ('user_type_id.type', 'not in', ('receivable', 'payable')), \
-                             '|', ('user_type_id', '=', %s), ('id', '=', default_account_id)]" % self.env.ref('account.data_account_type_current_assets').id)
     suspense_account_id = fields.Many2one(
         comodel_name='account.account', check_company=True, ondelete='restrict', readonly=False, store=True,
         compute='_compute_suspense_account_id',
@@ -127,42 +107,35 @@ class AccountJournal(models.Model):
 
                                           "e.g: ^(?P<prefix1>.*?)(?P<year>\d{4})(?P<prefix2>\D*?)(?P<month>\d{2})(?P<prefix3>\D+?)(?P<seq>\d+)(?P<suffix>\D*?)$")
 
-    inbound_payment_method_ids = fields.Many2many(
-        comodel_name='account.payment.method',
-        relation='account_journal_inbound_payment_method_rel',
-        column1='journal_id',
-        column2='inbound_payment_method',
+    inbound_payment_method_line_ids = fields.One2many(
+        comodel_name='account.payment.method.line',
         domain=[('payment_type', '=', 'inbound')],
-        string='Inbound Payment Methods',
-        compute='_compute_inbound_payment_method_ids',
-        ondelete="restrict",
+        compute='_compute_inbound_payment_method_line_ids',
         store=True,
         readonly=False,
-        help="Manual: Get paid by cash, check or any other method outside of Odoo.\n"
-             "Electronic: Get paid automatically through a payment acquirer by requesting a transaction"
-             " on a card saved by the customer when buying or subscribing online (payment token).\n"
-             "Batch Deposit: Encase several customer checks at once by generating a batch deposit to"
-             " submit to your bank. When encoding the bank statement in Odoo,you are suggested to"
-             " reconcile the transaction with the batch deposit. Enable this option from the settings."
+        string='Inbound Payment Methods',
+        inverse_name='journal_id',
+        copy=False,
+        check_company=True,
+        help="Manual :Get paid by any method outside of Odoo."
+        "Payment Acquirers : Each payment acquirer has its own Payment Method. Request a transaction on/to a card thanks to a payment token saved by the partner when buying or subscribing online."
+        "Batch Deposit: Collect several customer checks at once generating and submitting a batch deposit to your bank. Module account_batch_payment is necessary."
+        "SEPA Direct Debit : Get paid in the SEPA zone thanks to a mandate your partner will have granted to you. Module account_sepa is necessary"
     )
-    outbound_payment_method_ids = fields.Many2many(
-        comodel_name='account.payment.method',
-        relation='account_journal_outbound_payment_method_rel',
-        column1='journal_id',
-        column2='outbound_payment_method',
+    outbound_payment_method_line_ids = fields.One2many(
+        comodel_name='account.payment.method.line',
         domain=[('payment_type', '=', 'outbound')],
-        string='Outbound Payment Methods',
-        compute='_compute_outbound_payment_method_ids',
-        ondelete="restrict",
+        compute='_compute_outbound_payment_method_line_ids',
         store=True,
         readonly=False,
-        help="Manual:Pay bill by cash or any other method outside of Odoo.\n"
-             "Check:Pay bill by check and print it from Odoo.\n"
-             "SEPA Credit Transfer: Pay bill from a SEPA Credit Transfer file you submit to your"
-             " bank. Enable this option from the settings."
+        string='Outbound Payment Methods',
+        inverse_name='journal_id',
+        copy=False,
+        check_company=True,
+        help="Manual : Pay by any method outside of Odoo."
+        "Check: Pay bills by check and print it from Odoo."
+        "SEPA Credit Transfer : Pay in the SEPA zone by submitting a SEPA Credit Transfer file to your bank. Module account_sepa is necessary"
     )
-    at_least_one_inbound = fields.Boolean(compute='_methods_compute', store=True)
-    at_least_one_outbound = fields.Boolean(compute='_methods_compute', store=True)
     profit_account_id = fields.Many2one(
         comodel_name='account.account', check_company=True,
         help="Used to register a profit when the ending balance of a cash register differs from what the system computes",
@@ -212,10 +185,87 @@ class AccountJournal(models.Model):
         check_company=True,
         readonly=True, copy=False)
 
+    available_payment_method_ids = fields.Many2many(
+        comodel_name='account.payment.method',
+        compute='_compute_available_payment_method_ids'
+    )
+
+    selected_payment_method_codes = fields.Char(
+        compute='_compute_selected_payment_method_codes',
+        help='Technical field used to hide or show payment method options if needed.'
+    )
+
     _sql_constraints = [
         ('code_company_uniq', 'unique (code, company_id)', 'Journal codes must be unique per company.'),
     ]
 
+    @api.depends('outbound_payment_method_line_ids', 'inbound_payment_method_line_ids')
+    def _compute_available_payment_method_ids(self):
+        """
+        Compute the available payment methods id by respecting the following rules:
+            Methods of mode 'unique' cannot be used twice on the same company
+            Methods of mode 'multi' cannot be used twice on the same journal
+        """
+        method_information = self.env['account.payment.method']._get_payment_method_information()
+        pay_methods = self.env['account.payment.method'].search([('code', 'in', list(method_information.keys()))])
+        pay_method_by_code = {x.code + x.payment_type: x for x in pay_methods}
+        unique_pay_methods = [k for k, v in method_information.items() if v['mode'] == 'unique']
+        installed_acquirers = self.env['payment.acquirer'].search([])
+
+        pay_methods_by_company = {}
+        pay_methods_by_journal = {}
+        if unique_pay_methods:
+            self._cr.execute('''
+                SELECT
+                    journal.id,
+                    journal.company_id,
+                    ARRAY_AGG(DISTINCT apm.id)
+                FROM account_payment_method_line apml
+                JOIN account_journal journal ON journal.id = apml.journal_id
+                JOIN account_payment_method apm ON apm.id = apml.payment_method_id
+                WHERE apm.code IN %s
+                GROUP BY
+                    journal.id,
+                    journal.company_id
+            ''', [tuple(unique_pay_methods)])
+            for journal_id, company_id, payment_method_ids in self._cr.fetchall():
+                pay_methods_by_company[company_id] = set(payment_method_ids)
+                pay_methods_by_journal[journal_id] = set(payment_method_ids)
+
+        pay_method_ids_commands_x_journal = {j: [Command.clear()] for j in self}
+        for payment_type in ('inbound', 'outbound'):
+            for code, vals in method_information.items():
+                payment_method = pay_method_by_code.get(code + payment_type)
+
+                if not payment_method:
+                    continue
+
+                # Get the domain of the journals on which the current method is usable.
+                method_domain = payment_method._get_payment_method_domain()
+
+                for journal in self.filtered_domain(method_domain):
+                    protected_pay_method_ids = pay_methods_by_company.get(journal.company_id._origin.id, set()) \
+                                               - pay_methods_by_journal.get(journal._origin.id, set())
+                    available_providers = installed_acquirers.filtered(
+                        lambda a: a.company_id == journal.company_id
+                    ).mapped('provider')
+
+                    if payment_type == 'inbound':
+                        lines = journal.inbound_payment_method_line_ids
+                    else:
+                        lines = journal.outbound_payment_method_line_ids
+
+                    available = payment_method.code in available_providers
+                    already_used = payment_method in lines.payment_method_id
+                    is_protected = payment_method.id in protected_pay_method_ids
+                    if vals['mode'] == 'unique' and (already_used or is_protected or not available):
+                        continue
+
+                    pay_method_ids_commands_x_journal[journal].append(Command.link(payment_method.id))
+
+        for journal, pay_method_ids_commands in pay_method_ids_commands_x_journal.items():
+            journal.available_payment_method_ids = pay_method_ids_commands
+
     @api.depends('type')
     def _compute_default_account_type(self):
         default_account_id_types = {
@@ -232,20 +282,38 @@ class AccountJournal(models.Model):
                 journal.default_account_type = False
 
     @api.depends('type')
-    def _compute_outbound_payment_method_ids(self):
+    def _compute_inbound_payment_method_line_ids(self):
         for journal in self:
+            pay_method_line_ids_commands = [Command.clear()]
             if journal.type in ('bank', 'cash'):
-                journal.outbound_payment_method_ids = self._default_outbound_payment_methods()
-            else:
-                journal.outbound_payment_method_ids = False
+                default_methods = journal._default_inbound_payment_methods()
+                pay_method_line_ids_commands += [Command.create({
+                    'name': pay_method.name,
+                    'payment_method_id': pay_method.id,
+                }) for pay_method in default_methods]
+            journal.inbound_payment_method_line_ids = pay_method_line_ids_commands
 
     @api.depends('type')
-    def _compute_inbound_payment_method_ids(self):
+    def _compute_outbound_payment_method_line_ids(self):
         for journal in self:
+            pay_method_line_ids_commands = [Command.clear()]
             if journal.type in ('bank', 'cash'):
-                journal.inbound_payment_method_ids = self._default_inbound_payment_methods()
-            else:
-                journal.inbound_payment_method_ids = False
+                default_methods = journal._default_outbound_payment_methods()
+                pay_method_line_ids_commands += [Command.create({
+                    'name': pay_method.name,
+                    'payment_method_id': pay_method.id,
+                }) for pay_method in default_methods]
+            journal.outbound_payment_method_line_ids = pay_method_line_ids_commands
+
+    @api.depends('outbound_payment_method_line_ids', 'inbound_payment_method_line_ids')
+    def _compute_selected_payment_method_codes(self):
+        """
+        Set the selected payment method as a list of comma separated codes like: ,manual,check_printing,...
+        These will be then used to display or not payment method specific fields in the view.
+        """
+        for journal in self:
+            codes = [line.code for line in journal.inbound_payment_method_line_ids + journal.outbound_payment_method_line_ids]
+            journal.selected_payment_method_codes = ',' + ','.join(codes) + ','
 
     @api.depends('company_id', 'type')
     def _compute_suspense_account_id(self):
@@ -259,30 +327,6 @@ class AccountJournal(models.Model):
             else:
                 journal.suspense_account_id = False
 
-    @api.depends('company_id', 'type')
-    def _compute_payment_debit_account_id(self):
-        for journal in self:
-            if journal.type not in ('bank', 'cash'):
-                journal.payment_debit_account_id = False
-            elif journal.payment_debit_account_id:
-                journal.payment_debit_account_id = journal.payment_debit_account_id
-            elif journal.company_id.account_journal_payment_debit_account_id:
-                journal.payment_debit_account_id = journal.company_id.account_journal_payment_debit_account_id
-            else:
-                journal.payment_debit_account_id = False
-
-    @api.depends('company_id', 'type')
-    def _compute_payment_credit_account_id(self):
-        for journal in self:
-            if journal.type not in ('bank', 'cash'):
-                journal.payment_credit_account_id = False
-            elif journal.payment_credit_account_id:
-                journal.payment_credit_account_id = journal.payment_credit_account_id
-            elif journal.company_id.account_journal_payment_credit_account_id:
-                journal.payment_credit_account_id = journal.company_id.account_journal_payment_credit_account_id
-            else:
-                journal.payment_credit_account_id = False
-
     def _compute_alias_domain(self):
         alias_domain = self._default_alias_domain()
         for record in self:
@@ -351,6 +395,38 @@ class AccountJournal(models.Model):
             if journal.type in ('sale', 'purchase') and journal.default_account_id.user_type_id.type in ('receivable', 'payable'):
                 raise ValidationError(_("The type of the journal's default credit/debit account shouldn't be 'receivable' or 'payable'."))
 
+    @api.constrains('inbound_payment_method_line_ids', 'outbound_payment_method_line_ids')
+    def _check_payment_method_line_ids_multiplicity(self):
+        """
+        Check and ensure that the payment method lines multiplicity is respected.
+        """
+        method_info = self.env['account.payment.method']._get_payment_method_information()
+        unique_codes = tuple(code for code, info in method_info.items() if info.get('mode') == 'unique')
+
+        self.flush(['inbound_payment_method_line_ids', 'outbound_payment_method_line_ids', 'company_id'])
+        self.env['account.payment.method.line'].flush(['payment_method_id', 'journal_id'])
+        self.env['account.payment.method'].flush(['code'])
+
+        if unique_codes:
+            self._cr.execute('''
+                SELECT apm.id
+                FROM account_payment_method apm
+                JOIN account_payment_method_line apml on apm.id = apml.payment_method_id
+                JOIN account_journal journal on journal.id = apml.journal_id
+                JOIN res_company company on journal.company_id = company.id
+                WHERE apm.code in %s
+                GROUP BY 
+                    company.id, 
+                    apm.id
+                HAVING array_length(array_agg(journal.id), 1) > 1;
+            ''', [unique_codes])
+
+        method_ids = [res[0] for res in self._cr.fetchall()]
+        if method_ids:
+            methods = self.env['account.payment.method'].browse(method_ids)
+            raise ValidationError(_("Some payment methods supposed to be unique already exists somewhere else.\n"
+                                    "(%s)", ', '.join([method.display_name for method in methods])))
+
     @api.onchange('type')
     def _onchange_type(self):
         self.refund_sequence = self.type in ('sale', 'purchase')
@@ -600,12 +676,6 @@ class AccountJournal(models.Model):
             domain = [connector, ('code', operator, name), ('name', operator, name)]
         return self._search(expression.AND([domain, args]), limit=limit, access_rights_uid=name_get_uid)
 
-    @api.depends('inbound_payment_method_ids', 'outbound_payment_method_ids')
-    def _methods_compute(self):
-        for journal in self:
-            journal.at_least_one_inbound = bool(len(journal.inbound_payment_method_ids))
-            journal.at_least_one_outbound = bool(len(journal.outbound_payment_method_ids))
-
     def action_configure_bank_journal(self):
         """ This function is called by the "configure" button of bank journals,
         visible on dashboard if no bank statement source has been defined yet
@@ -721,6 +791,26 @@ class AccountJournal(models.Model):
         nb_lines, balance, amount_currency = self._cr.fetchone()
         return amount_currency if journal_currency else balance, nb_lines
 
+    def _get_journal_inbound_outstanding_payment_accounts(self):
+        """
+        :return: A recordset with all the account.account used by this journal for inbound transactions.
+        """
+        self.ensure_one()
+        account_ids = set()
+        for line in self.inbound_payment_method_line_ids:
+            account_ids.add(line.payment_account_id.id or self.company_id.account_journal_payment_debit_account_id.id)
+        return self.env['account.account'].browse(account_ids)
+
+    def _get_journal_outbound_outstanding_payment_accounts(self):
+        """
+        :return: A recordset with all the account.account used by this journal for outbound transactions.
+        """
+        self.ensure_one()
+        account_ids = set()
+        for line in self.outbound_payment_method_line_ids:
+            account_ids.add(line.payment_account_id.id or self.company_id.account_journal_payment_credit_account_id.id)
+        return self.env['account.account'].browse(account_ids)
+
     def _get_journal_outstanding_payments_account_balance(self, domain=None, date=None):
         ''' Get the outstanding payments balance of the current journal by filtering the journal items using the
         journal's accounts.
@@ -733,7 +823,7 @@ class AccountJournal(models.Model):
         self.env['account.move.line'].check_access_rights('read')
         conversion_date = date or fields.Date.context_today(self)
 
-        accounts = self.payment_debit_account_id + self.payment_credit_account_id
+        accounts = self._get_journal_inbound_outstanding_payment_accounts().union(self._get_journal_outbound_outstanding_payment_accounts())
         if not accounts:
             return 0.0, 0
 

--- a/addons/account/models/account_payment.py
+++ b/addons/account/models/account_payment.py
@@ -52,11 +52,12 @@ class AccountPayment(models.Model):
         readonly=False, store=True,
         compute='_compute_payment_method_id',
         domain="[('id', 'in', available_payment_method_ids)]",
-        help="Manual: Get paid by cash, check or any other method outside of Odoo.\n"\
-        "Electronic: Get paid automatically through a payment acquirer by requesting a transaction on a card saved by the customer when buying or subscribing online (payment token).\n"\
-        "Check: Pay bill by check and print it from Odoo.\n"\
-        "Batch Deposit: Encase several customer checks at once by generating a batch deposit to submit to your bank. When encoding the bank statement in Odoo, you are suggested to reconcile the transaction with the batch deposit.To enable batch deposit, module account_batch_payment must be installed.\n"\
-        "SEPA Credit Transfer: Pay bill from a SEPA Credit Transfer file you submit to your bank. To enable sepa credit transfer, module account_sepa must be installed ")
+        help="Manual : Pay or Get paid by any method outside of Odoo."
+        "Payment Acquirers : Each payment acquirer has its own Payment Method. Request a transaction on/to a card thanks to a payment token saved by the partner when buying or subscribing online."
+        "Check: Pay bills by check and print it from Odoo."
+        "Batch Deposit: Collect several customer checks at once generating and submitting a batch deposit to your bank. Module account_batch_payment is necessary."
+        "SEPA Credit Transfer : Pay in the SEPA zone by submitting a SEPA Credit Transfer file to your bank. Module account_sepa is necessary"
+        "SEPA Direct Debit : Get paid in the SEPA zone thanks to a mandate your partner will have granted to you. Module account_sepa is necessary")
     available_payment_method_ids = fields.Many2many('account.payment.method',
         compute='_compute_payment_method_fields')
     hide_payment_method = fields.Boolean(
@@ -85,6 +86,12 @@ class AccountPayment(models.Model):
         compute='_compute_partner_id',
         domain="['|', ('parent_id','=', False), ('is_company','=', True)]",
         check_company=True)
+    outstanding_account_id = fields.Many2one(
+        comodel_name='account.account',
+        string="Outstanding Account",
+        store=True,
+        compute='_compute_outstanding_account_id',
+        check_company=True)
     destination_account_id = fields.Many2one(
         comodel_name='account.account',
         string='Destination Account',
@@ -162,11 +169,20 @@ class AccountPayment(models.Model):
         counterpart_lines = self.env['account.move.line']
         writeoff_lines = self.env['account.move.line']
 
+        if self.payment_type == 'inbound':
+            payment_method_account_ids = self.journal_id.inbound_payment_method_line_ids
+        else:
+            payment_method_account_ids = self.journal_id.outbound_payment_method_line_ids
+
+        payment_method_account_id = payment_method_account_ids\
+            .filtered(lambda line: line.code == self.payment_method_id.code).payment_account_id
+
         for line in self.move_id.line_ids:
             if line.account_id in (
                     self.journal_id.default_account_id,
-                    self.journal_id.payment_debit_account_id,
-                    self.journal_id.payment_credit_account_id,
+                    payment_method_account_id,
+                    self.journal_id.company_id.account_journal_payment_debit_account_id,
+                    self.journal_id.company_id.account_journal_payment_credit_account_id,
             ):
                 liquidity_lines += line
             elif line.account_id.internal_type in ('receivable', 'payable') or line.partner_id == line.company_id.partner_id:
@@ -187,10 +203,10 @@ class AccountPayment(models.Model):
         self.ensure_one()
         write_off_line_vals = write_off_line_vals or {}
 
-        if not self.journal_id.payment_debit_account_id or not self.journal_id.payment_credit_account_id:
+        if not self.outstanding_account_id:
             raise UserError(_(
-                "You can't create a new payment without an outstanding payments/receipts account set on the %s journal.",
-                self.journal_id.display_name))
+                "You can't create a new payment without an outstanding payments/receipts account set either on the company or the %s payment method in the %s journal.",
+                self.payment_method_id.name, self.journal_id.display_name))
 
         # Compute amounts.
         write_off_amount_currency = write_off_line_vals.get('amount', 0.0)
@@ -256,7 +272,7 @@ class AccountPayment(models.Model):
                 'debit': liquidity_balance if liquidity_balance > 0.0 else 0.0,
                 'credit': -liquidity_balance if liquidity_balance < 0.0 else 0.0,
                 'partner_id': self.partner_id.id,
-                'account_id': self.journal_id.payment_credit_account_id.id if liquidity_balance < 0.0 else self.journal_id.payment_debit_account_id.id,
+                'account_id': self.outstanding_account_id.id,
             },
             # Receivable / Payable.
             {
@@ -371,9 +387,9 @@ class AccountPayment(models.Model):
         '''
         for pay in self:
             if pay.payment_type == 'inbound':
-                available_payment_methods = pay.journal_id.inbound_payment_method_ids
+                available_payment_methods = pay.journal_id.inbound_payment_method_line_ids.mapped('payment_method_id')
             else:
-                available_payment_methods = pay.journal_id.outbound_payment_method_ids
+                available_payment_methods = pay.journal_id.outbound_payment_method_line_ids.mapped('payment_method_id')
 
             # Select the first available one by default.
             if pay.payment_method_id in available_payment_methods:
@@ -384,14 +400,14 @@ class AccountPayment(models.Model):
                 pay.payment_method_id = False
 
     @api.depends('payment_type',
-                 'journal_id.inbound_payment_method_ids',
-                 'journal_id.outbound_payment_method_ids')
+                 'journal_id.inbound_payment_method_line_ids',
+                 'journal_id.outbound_payment_method_line_ids')
     def _compute_payment_method_fields(self):
         for pay in self:
             if pay.payment_type == 'inbound':
-                pay.available_payment_method_ids = pay.journal_id.inbound_payment_method_ids
+                pay.available_payment_method_ids = pay.journal_id.inbound_payment_method_line_ids.mapped('payment_method_id')
             else:
-                pay.available_payment_method_ids = pay.journal_id.outbound_payment_method_ids
+                pay.available_payment_method_ids = pay.journal_id.outbound_payment_method_line_ids.mapped('payment_method_id')
             to_exclude = self._get_payment_method_codes_to_exclude()
             if to_exclude:
                 pay.available_payment_method_ids = pay.available_payment_method_ids.filtered(lambda x: x.code not in to_exclude)
@@ -417,6 +433,24 @@ class AccountPayment(models.Model):
             else:
                 pay.partner_id = pay.partner_id
 
+    @api.depends('journal_id', 'payment_type')
+    def _compute_outstanding_account_id(self):
+        for pay in self:
+            if pay.payment_type == 'inbound':
+                payment_method_account_id = pay.journal_id.inbound_payment_method_line_ids\
+                    .filtered(lambda line: line.code == pay.payment_method_id.code).payment_account_id
+
+                pay.outstanding_account_id = (payment_method_account_id
+                                              or pay.journal_id.company_id.account_journal_payment_debit_account_id)
+            elif pay.payment_type == 'outbound':
+                payment_method_account_id = pay.journal_id.outbound_payment_method_line_ids\
+                    .filtered(lambda line: line.code == pay.payment_method_id.code).payment_account_id
+
+                pay.outstanding_account_id = (payment_method_account_id
+                                              or pay.journal_id.company_id.account_journal_payment_credit_account_id)
+            else:
+                pay.outstanding_account_id = False
+
     @api.depends('journal_id', 'partner_id', 'partner_type', 'is_internal_transfer')
     def _compute_destination_account_id(self):
         self.destination_account_id = False
@@ -542,7 +576,7 @@ class AccountPayment(models.Model):
                 part.debit_move_id = counterpart_line.id
                 OR
                 part.credit_move_id = counterpart_line.id
-            WHERE (account.id = journal.payment_debit_account_id OR account.id = journal.payment_credit_account_id)
+            WHERE account.id = payment.outstanding_account_id
                 AND payment.id IN %(payment_ids)s
                 AND line.id != counterpart_line.id
                 AND counterpart_line.statement_id IS NOT NULL

--- a/addons/account/models/account_payment_method.py
+++ b/addons/account/models/account_payment_method.py
@@ -1,14 +1,120 @@
 # -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
 
-from odoo import models, fields
+from odoo import api, fields, models
+from odoo.osv import expression
 
 
 class AccountPaymentMethod(models.Model):
     _name = "account.payment.method"
     _description = "Payment Methods"
-    _order = 'sequence'
 
     name = fields.Char(required=True, translate=True)
     code = fields.Char(required=True)  # For internal identification
-    payment_type = fields.Selection([('inbound', 'Inbound'), ('outbound', 'Outbound')], required=True)
-    sequence = fields.Integer(help='Used to order Methods in the form view', default=10)
+    payment_type = fields.Selection(selection=[('inbound', 'Inbound'), ('outbound', 'Outbound')], required=True)
+
+    _sql_constraints = [
+        ('name_code_unique', 'unique (code, payment_type)', 'The combination code/payment type already exists!'),
+    ]
+
+    @api.model_create_multi
+    def create(self, vals_list):
+        payment_methods = super().create(vals_list)
+        methods_info = self._get_payment_method_information()
+        for method in payment_methods:
+            information = methods_info.get(method.code)
+            limit = None if information.get('mode') == 'multi' else 1
+
+            method_domain = method._get_payment_method_domain()
+
+            journals = self.env['account.journal'].search(method_domain, limit=limit)
+
+            self.env['account.payment.method.line'].create([{
+                'name': method.name,
+                'payment_method_id': method.id,
+                'journal_id': journal.id
+            } for journal in journals])
+        return payment_methods
+
+    def _get_payment_method_domain(self):
+        """
+        :return: The domain specyfying which journal can accomodate this payment method.
+        """
+        self.ensure_one()
+        information = self._get_payment_method_information().get(self.code)
+
+        unique = information.get('mode') == 'unique'
+        currency_id = information.get('currency_id')
+        country_id = information.get('country_id')
+        default_domain = [('type', 'in', ('bank', 'cash'))]
+        domains = [information.get('domain', default_domain)]
+
+        if currency_id:
+            domains += [expression.OR([
+                [('currency_id', '=', False), ('company_id.currency_id', '=', currency_id)],
+                [('currency_id', '=', currency_id)]],
+            )]
+
+        if country_id:
+            domains += [[('company_id.account_fiscal_country_id', '=', country_id)]]
+
+        if unique:
+            company_ids = self.env['payment.acquirer'].search([('provider', '=', self.code)]).mapped('company_id')
+            if company_ids:
+                domains += [[('company_id', 'in', company_ids.ids)]]
+
+        return expression.AND(domains)
+
+    @api.model
+    def _get_payment_method_information(self):
+        """
+        Contains details about how to initialize a payment method with the code x.
+        The contained info are:
+            mode: Either unique if we only want one of them at a single time (payment acquirers for example)
+                   or multi if we want the method on each journal fitting the domain.
+            domain: The domain defining the eligible journals.
+            currency_id: The id of the currency necessary on the journal (or company) for it to be eligible.
+            country_id: The id of the country needed on the company for it to be eligible.
+            hidden: If set to true, the method will not be automatically added to the journal,
+                    and will not be selectable by the user.
+        """
+        return {
+            'manual': {'mode': 'multi', 'domain': [('type', 'in', ('bank', 'cash'))]},
+        }
+
+
+class AccountPaymentMethodLine(models.Model):
+    _name = "account.payment.method.line"
+    _description = "Payment Methods"
+
+    # == Business fields ==
+    name = fields.Char(compute='_compute_name', readonly=False, store=True)
+    sequence = fields.Integer(default=10)
+    payment_method_id = fields.Many2one(
+        string='Payment Method',
+        comodel_name='account.payment.method',
+        domain="[('payment_type', '=?', payment_type), ('id', 'in', available_payment_method_ids)]",
+        required=True
+    )
+    payment_account_id = fields.Many2one(
+        comodel_name='account.account',
+        check_company=True,
+        copy=False,
+        ondelete='restrict',
+        domain=lambda self: "[('deprecated', '=', False), "
+                            "('company_id', '=', company_id), "
+                            "('user_type_id.type', 'not in', ('receivable', 'payable')), "
+                            "('user_type_id', '=', %s)]" % self.env.ref('account.data_account_type_current_assets').id
+    )
+    journal_id = fields.Many2one(comodel_name='account.journal', required=True, ondelete="cascade")
+
+    # == Display purpose fields ==
+    code = fields.Char(related='payment_method_id.code')
+    payment_type = fields.Selection(related='payment_method_id.payment_type')
+    company_id = fields.Many2one(related='journal_id.company_id')
+    available_payment_method_ids = fields.Many2many(related='journal_id.available_payment_method_ids')
+
+    @api.depends('payment_method_id.name')
+    def _compute_name(self):
+        for method in self:
+            method.name = method.payment_method_id.name
