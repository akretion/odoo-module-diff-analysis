PR: https://github.com/odoo/odoo/pull/

From: d2ed4ba93d0a6c2e9e6982acb45b761f9f89e7a9
From: David Beguin
Date: 2019-01-23 13:28:30

Structural Changes: 9
Total Changes: 59

[IMP] survey : add datetime question type

to be able to choose between asking for a date or a date with time,
a datetime question type is now added.

Task ID : 1911291
Closes PR #29054

================================= pseudo patch: =================================

--- a/addons/survey/models/survey_question.py
+++ b/addons/survey/models/survey_question.py
@@ -3,6 +3,7 @@
 
 import logging
 import re
+import datetime
 
 from odoo import api, fields, models, tools, _
 from odoo.exceptions import ValidationError
@@ -41,6 +42,7 @@ class SurveyQuestion(models.Model):
         ('textbox', 'Single Line Text Box'),
         ('numerical_box', 'Numerical Value'),
         ('date', 'Date'),
+        ('datetime', 'Datetime'),
         ('simple_choice', 'Multiple choice: only one answer'),
         ('multiple_choice', 'Multiple choice: multiple answers allowed'),
         ('matrix', 'Matrix')], string='Type of Question',
@@ -77,6 +79,8 @@ class SurveyQuestion(models.Model):
     validation_max_float_value = fields.Float('Maximum value')
     validation_min_date = fields.Date('Minimum Date')
     validation_max_date = fields.Date('Maximum Date')
+    validation_min_datetime = fields.Datetime('Minimum Datetime')
+    validation_max_datetime = fields.Datetime('Maximum Datetime')
     validation_error_msg = fields.Char('Validation Error message', translate=True, default=lambda self: _("The answer you entered is not valid."))
     # Constraints on number of answers (matrices)
     constr_mandatory = fields.Boolean('Mandatory Answer')
@@ -91,7 +95,8 @@ class SurveyQuestion(models.Model):
         ('positive_len_max', 'CHECK (validation_length_max >= 0)', 'A length must be positive!'),
         ('validation_length', 'CHECK (validation_length_min <= validation_length_max)', 'Max length cannot be smaller than min length!'),
         ('validation_float', 'CHECK (validation_min_float_value <= validation_max_float_value)', 'Max value cannot be smaller than min value!'),
-        ('validation_date', 'CHECK (validation_min_date <= validation_max_date)', 'Max date cannot be smaller than min date!')
+        ('validation_date', 'CHECK (validation_min_date <= validation_max_date)', 'Max date cannot be smaller than min date!'),
+        ('validation_datetime', 'CHECK (validation_min_datetime <= validation_max_datetime)','Max datetime cannot be smaller than min datetime!')
     ]
 
     @api.onchange('validation_email')
@@ -169,10 +174,11 @@ class SurveyQuestion(models.Model):
                     errors.update({answer_tag: self.validation_error_msg})
         return errors
 
-    @api.multi
-    def validate_date(self, post, answer_tag):
+    def date_validation(self, date_type, post, answer_tag, min_value, max_value):
         self.ensure_one()
         errors = {}
+        if date_type not in ('date', 'datetime'):
+            raise ValueError("Unexpected date type value")
         answer = post[answer_tag].strip()
         # Empty answer to mandatory question
         if self.constr_mandatory and not answer:
@@ -180,7 +186,10 @@ class SurveyQuestion(models.Model):
         # Checks if user input is a date
         if answer:
             try:
-                dateanswer = fields.Date.from_string(answer)
+                if date_type == 'datetime':
+                    dateanswer = fields.Datetime.from_string(answer)
+                else:
+                    dateanswer = fields.Date.from_string(answer)
             except ValueError:
                 errors.update({answer_tag: _('This is not a date')})
                 return errors
@@ -188,10 +197,13 @@ class SurveyQuestion(models.Model):
         if answer and self.validation_required:
             # Answer is not in the right range
             try:
-                date_from_string = fields.Date.from_string
+                if date_type == 'datetime':
+                    date_from_string = fields.Datetime.from_string
+                else:
+                    date_from_string = fields.Date.from_string
                 dateanswer = date_from_string(answer)
-                min_date = date_from_string(self.validation_min_date)
-                max_date = date_from_string(self.validation_max_date)
+                min_date = date_from_string(min_value)
+                max_date = date_from_string(max_value)
 
                 if min_date and max_date and not (min_date <= dateanswer <= max_date):
                     # If Minimum and Maximum Date are entered
@@ -206,6 +218,14 @@ class SurveyQuestion(models.Model):
                 pass
         return errors
 
+    @api.multi
+    def validate_date(self, post, answer_tag):
+        return self.date_validation('date', post, answer_tag, self.validation_min_date, self.validation_max_date)
+
+    @api.multi
+    def validate_datetime(self, post, answer_tag):
+        return self.date_validation('datetime', post, answer_tag, self.validation_min_datetime, self.validation_max_datetime)
+
     @api.multi
     def validate_simple_choice(self, post, answer_tag):
         self.ensure_one()

--- a/addons/survey/models/survey_user.py
+++ b/addons/survey/models/survey_user.py
@@ -110,11 +110,13 @@ class SurveyUserInputLine(models.Model):
         ('text', 'Text'),
         ('number', 'Number'),
         ('date', 'Date'),
+        ('datetime', 'Datetime'),
         ('free_text', 'Free Text'),
         ('suggestion', 'Suggestion')], string='Answer Type')
     value_text = fields.Char('Text answer')
     value_number = fields.Float('Numerical answer')
     value_date = fields.Date('Date answer')
+    value_datetime = fields.Datetime('Datetime answer')
     value_free_text = fields.Text('Free Text answer')
     value_suggested = fields.Many2one('survey.label', string="Suggested answer")
     value_suggested_row = fields.Many2one('survey.label', string="Row answer")
@@ -266,6 +268,29 @@ class SurveyUserInputLine(models.Model):
             old_uil.create(vals)
         return True
 
+    @api.model
+    def save_line_datetime(self, user_input_id, question, post, answer_tag):
+        vals = {
+            'user_input_id': user_input_id,
+            'question_id': question.id,
+            'survey_id': question.survey_id.id,
+            'skipped': False
+        }
+        if answer_tag in post and post[answer_tag].strip():
+            vals.update({'answer_type': 'datetime', 'value_datetime': post[answer_tag]})
+        else:
+            vals.update({'answer_type': None, 'skipped': True})
+        old_uil = self.search([
+            ('user_input_id', '=', user_input_id),
+            ('survey_id', '=', question.survey_id.id),
+            ('question_id', '=', question.id)
+        ])
+        if old_uil:
+            old_uil.write(vals)
+        else:
+            old_uil.create(vals)
+        return True
+
     @api.model
     def save_line_simple_choice(self, user_input_id, question, post, answer_tag):
         vals = {
