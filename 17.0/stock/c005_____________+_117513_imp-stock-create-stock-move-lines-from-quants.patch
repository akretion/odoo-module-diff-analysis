PR: https://github.com/odoo/odoo/pull/117513

From: d45f6ab2267f4cf3c2419e7274b2c550b00a796d
From: William Henrotin
Date: 2023-05-17 11:37:47

Structural Changes: 3
Total Changes: 72

[IMP] stock: create stock move lines from quants

In a flow where the reservation is used (internal transfers, deliveries,
...) adding a new stock move line is now made from the quantities
available in stock. The 'add a line' button in the show detail wizard
trigger the quant list view to directly pick the wanted lot or location
where the stock is available. Only the quantity done is needed to be
updated before the validation.

This commit remove the 'quant reserve wizard' as the behaviour is an
extension of it.

Task: 3256447
Part-of: odoo/odoo#117513

================================= pseudo patch: =================================

--- a/addons/stock/models/stock_move.py
+++ b/addons/stock/models/stock_move.py
@@ -768,7 +768,7 @@ Please change the quantity done or the rounding precision of your unit of measur
 
         if self.product_id.tracking == "serial" and self.state == "assigned":
             self.next_serial = self.env['stock.lot']._get_next_serial(self.company_id, self.product_id)
-
+        quant_mode = self.picking_type_id.code != 'incoming'
         return {
             'name': _('Detailed Operations'),
             'type': 'ir.actions.act_window',
@@ -780,13 +780,13 @@ Please change the quantity done or the rounding precision of your unit of measur
             'res_id': self.id,
             'context': dict(
                 self.env.context,
-                show_owner=self.picking_type_id.code != 'incoming',
-                show_lots_m2o=self.has_tracking != 'none' and (self.picking_type_id.use_existing_lots or self.state == 'done' or self.origin_returned_move_id.id),  # able to create lots, whatever the value of ` use_create_lots`.
+                show_owner=not quant_mode,
+                show_quant=quant_mode,
+                show_lots_m2o=not quant_mode and self.has_tracking != 'none' and (self.picking_type_id.use_existing_lots or self.state == 'done' or self.origin_returned_move_id.id),  # able to create lots, whatever the value of ` use_create_lots`.
                 show_lots_text=self.has_tracking != 'none' and self.picking_type_id.use_create_lots and not self.picking_type_id.use_existing_lots and self.state != 'done' and not self.origin_returned_move_id.id,
-                show_source_location=self.picking_type_id.code != 'incoming',
-                show_destination_location=self.picking_type_id.code != 'outgoing',
-                show_package=not self.location_id.usage == 'supplier',
-                show_reserved_quantity=self.state != 'done' and self.picking_type_id.code != 'incoming'
+                show_destination_location=not quant_mode,
+                show_package=not quant_mode,
+                show_reserved_quantity=self.state != 'done' and quant_mode
             ),
         }
 

--- a/addons/stock/models/stock_move_line.py
+++ b/addons/stock/models/stock_move_line.py
@@ -37,7 +37,8 @@ class StockMoveLine(models.Model):
         compute='_compute_reserved_qty', inverse='_set_reserved_qty', store=True)
     reserved_uom_qty = fields.Float(
         'Reserved', default=0.0, digits='Product Unit of Measure', required=True, copy=False)
-    qty_done = fields.Float('Done', default=0.0, digits='Product Unit of Measure', copy=False)
+    qty_done = fields.Float('Done', default=0.0, digits='Product Unit of Measure', copy=False,
+        compute='_compute_qty_done', store=True, readonly=False)
     package_id = fields.Many2one(
         'stock.quant.package', 'Source Package', ondelete='restrict',
         check_company=True,
@@ -82,6 +83,7 @@ class StockMoveLine(models.Model):
     tracking = fields.Selection(related='product_id.tracking', readonly=True)
     origin = fields.Char(related='move_id.origin', string='Source')
     description_picking = fields.Text(string="Description picking")
+    quant_id = fields.Many2one('stock.quant', "Pick From", store=False)  # Dummy field for the detailed operation view
 
     @api.depends('product_uom_id.category_id', 'product_id.uom_id.category_id', 'move_id.product_uom', 'product_id.uom_id')
     def _compute_product_uom_id(self):
@@ -131,6 +133,12 @@ class StockMoveLine(models.Model):
         detect errors. """
         raise UserError(_('The requested operation cannot be processed because of a programming error setting the `reserved_qty` field instead of the `reserved_uom_qty`.'))
 
+    @api.depends('quant_id')
+    def _compute_qty_done(self):
+        for record in self:
+            if not record.qty_done:
+                record.qty_done = min(record.quant_id.quantity, record.move_id.product_qty)
+
     @api.constrains('lot_id', 'product_id')
     def _check_lot_product(self):
         for line in self:
@@ -288,6 +296,8 @@ class StockMoveLine(models.Model):
                 vals['company_id'] = self.env['stock.move'].browse(vals['move_id']).company_id.id
             elif vals.get('picking_id'):
                 vals['company_id'] = self.env['stock.picking'].browse(vals['picking_id']).company_id.id
+            if vals.get('quant_id'):
+                vals.update(self._copy_quant_info(vals))
 
         mls = super().create(vals_list)
 
@@ -379,6 +389,8 @@ class StockMoveLine(models.Model):
             ('owner_id', 'res.partner'),
             ('product_uom_id', 'uom.uom')
         ]
+        if vals.get('quant_id'):
+            vals.update(self._copy_quant_info(vals))
         updates = {}
         for key, model in triggers:
             if key in vals:
@@ -872,6 +884,25 @@ class StockMoveLine(models.Model):
             'partner_id': self.picking_id.partner_id.id,
         }
 
+    def _copy_quant_info(self, vals):
+        quant = self.env['stock.quant'].browse(vals.get('quant_id', 0))
+        if self:
+            uom = self.product_uom_id
+        elif vals.get('product_uom_id'):
+            uom = self.env['uom.uom'].browse(vals.get('product_uom_id'))
+        else:
+            uom = quant.product_uom_id
+        line_data = {
+            'product_id': quant.product_id.id,
+            'lot_id': quant.lot_id.id,
+            'package_id': quant.package_id.id,
+            'location_id': quant.location_id.id,
+            'owner_id': quant.owner_id.id,
+        }
+        if not (self.qty_done or vals.get('qty_done')):
+            line_data['qty_done'] = uom._compute_quantity(quant.available_quantity, quant.product_uom_id, rounding_method='HALF_UP')
+        return line_data
+
     def action_open_reference(self):
         self.ensure_one()
         if self.move_id:
@@ -937,14 +968,3 @@ class StockMoveLine(models.Model):
                 'message': _("The inventory adjustments have been reverted."),
             }
         }
-
-    def action_open_reserve_stock(self):
-        move_id = self.env['stock.move'].browse(self.env.context.get('default_move_id'))
-        return {
-            'type': 'ir.actions.act_window',
-            'res_model': 'stock.quant.reserve',
-            'view_mode': 'form',
-            'context': {'default_move_id': move_id.id},
-            'target': 'new',
-            'name': _('Reserve stock: %(product)s', product=move_id.product_id.name),
-        }

--- a/addons/stock/models/stock_quant.py
+++ b/addons/stock/models/stock_quant.py
@@ -523,6 +523,20 @@ class StockQuant(models.Model):
             'target': 'new',
         }
 
+    def name_get(self):
+        """name that will be displayed in the detailed operation"""
+        name_parts = []
+        for record in self:
+            name = []
+            if self.env.user.has_group('stock.group_stock_multi_locations'):
+                name.append(record.location_id.display_name)
+            if self.env.user.has_group('stock.group_production_lot') and record.lot_id:
+                name.append(record.lot_id.name)
+            name_parts.append(name)
+        if name_parts:
+            return [(quant.id, ' - '.join(name)) for quant, name in zip(self, name_parts)]
+        return []
+
     @api.constrains('product_id')
     def check_product_id(self):
         if any(elem.product_id.type != 'product' for elem in self):
