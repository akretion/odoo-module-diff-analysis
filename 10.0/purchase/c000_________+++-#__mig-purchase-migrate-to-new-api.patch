PR: https://github.com/odoo/odoo/pull/

From: ba3d3582bc00b544a897d2b83fa08975f23ae0bd
From: Denis Vermylen (dve)
Date: 2016-08-05 12:04:37

Structural Changes: 16
Total Changes: 310

[MIG] purchase: Migrate to new API

================================= pseudo patch: =================================

--- a/addons/purchase/models/account_invoice.py
+++ b/addons/purchase/models/account_invoice.py
@@ -1,8 +1,8 @@
 # -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
-from openerp import api, fields, models, _
-from openerp.tools.float_utils import float_compare
+from odoo import api, fields, models, _
+from odoo.tools.float_utils import float_compare
 
 
 class AccountInvoice(models.Model):

--- a/addons/purchase/models/mail_mail.py
+++ b/addons/purchase/models/mail_mail.py
@@ -1,14 +1,18 @@
-from openerp.osv import osv
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
 
+from odoo import api, models
 
-class mail_mail(osv.Model):
+
+class MailMail(models.Model):
     _name = 'mail.mail'
     _inherit = 'mail.mail'
 
-    def _postprocess_sent_message(self, cr, uid, ids, context=None, mail_sent=True):
-        for mail in self.browse(cr, uid, ids, context=context):
+    @api.multi
+    def _postprocess_sent_message(self, mail_sent=True):
+        for mail in self:
             if mail_sent and mail.model == 'purchase.order':
-                obj = self.pool.get('purchase.order').browse(cr, uid, mail.res_id, context=context)
-                if obj.state == 'draft':
-                    self.pool.get('purchase.order').signal_workflow(cr, uid, [mail.res_id], 'send_rfq')
-        return super(mail_mail, self)._postprocess_sent_message(cr, uid, ids, context=context, mail_sent=mail_sent)
+                purchase_order = self.env['purchase.order'].browse(mail.res_id)
+                if purchase_order.state == 'draft':
+                    self.env['purchase.order'].signal_workflow([mail.res_id], 'send_rfq')
+        return super(MailMail, self)._postprocess_sent_message(mail_sent=mail_sent)

--- a/addons/purchase/models/purchase.py
+++ b/addons/purchase/models/purchase.py
@@ -3,14 +3,15 @@
 
 from datetime import datetime
 from dateutil.relativedelta import relativedelta
-from openerp import api, fields, models, _, SUPERUSER_ID
-from openerp.tools import DEFAULT_SERVER_DATETIME_FORMAT
-from openerp.tools.translate import _
-from openerp.tools.float_utils import float_is_zero, float_compare
-import openerp.addons.decimal_precision as dp
-from openerp.exceptions import UserError, AccessError
-from openerp.tools.misc import formatLang
-from openerp.addons.base.res.res_partner import WARNING_MESSAGE, WARNING_HELP
+
+from odoo import api, fields, models, SUPERUSER_ID, _
+from odoo.tools import DEFAULT_SERVER_DATETIME_FORMAT
+from odoo.tools.float_utils import float_is_zero, float_compare
+from odoo.exceptions import UserError, AccessError
+from odoo.tools.misc import formatLang
+from odoo.addons.base.res.res_partner import WARNING_MESSAGE, WARNING_HELP
+import odoo.addons.decimal_precision as dp
+
 
 class PurchaseOrder(models.Model):
     _name = "purchase.order"
@@ -96,7 +97,7 @@ class PurchaseOrder(models.Model):
         'cancel': [('readonly', True)],
     }
 
-    name = fields.Char('Order Reference', required=True, select=True, copy=False, default='New')
+    name = fields.Char('Order Reference', required=True, index=True, copy=False, default='New')
     origin = fields.Char('Source Document', copy=False,\
         help="Reference of the document that generated this purchase order "
              "request (e.g. a sale order or an internal procurement request)")
@@ -105,9 +106,9 @@ class PurchaseOrder(models.Model):
              "It's used to do the matching when you receive the "
              "products as this reference is usually written on the "
              "delivery order sent by your vendor.")
-    date_order = fields.Datetime('Order Date', required=True, states=READONLY_STATES, select=True, copy=False, default=fields.Datetime.now,\
+    date_order = fields.Datetime('Order Date', required=True, states=READONLY_STATES, index=True, copy=False, default=fields.Datetime.now,\
         help="Depicts the date where the Quotation should be validated and converted into a purchase order.")
-    date_approve = fields.Date('Approval Date', readonly=1, select=True, copy=False)
+    date_approve = fields.Date('Approval Date', readonly=1, index=True, copy=False)
     partner_id = fields.Many2one('res.partner', string='Vendor', required=True, states=READONLY_STATES, change_default=True, track_visibility='always')
     dest_address_id = fields.Many2one('res.partner', string='Drop Ship Address', states=READONLY_STATES,\
         help="Put an address if you want to deliver directly from the vendor to the customer. "\
@@ -121,7 +122,7 @@ class PurchaseOrder(models.Model):
         ('purchase', 'Purchase Order'),
         ('done', 'Locked'),
         ('cancel', 'Cancelled')
-        ], string='Status', readonly=True, select=True, copy=False, default='draft', track_visibility='onchange')
+        ], string='Status', readonly=True, index=True, copy=False, default='draft', track_visibility='onchange')
     order_line = fields.One2many('purchase.order.line', 'order_id', string='Order Lines', states={'cancel': [('readonly', True)], 'done': [('readonly', True)]}, copy=True)
     notes = fields.Text('Terms and Conditions')
 
@@ -137,7 +138,7 @@ class PurchaseOrder(models.Model):
     picking_ids = fields.Many2many('stock.picking', compute='_compute_picking', string='Receptions', copy=False)
 
     # There is no inverse function on purpose since the date may be different on each line
-    date_planned = fields.Datetime(string='Scheduled Date', compute='_compute_date_planned', store=True, select=True, oldname='minimum_planned_date')
+    date_planned = fields.Datetime(string='Scheduled Date', compute='_compute_date_planned', store=True, index=True, oldname='minimum_planned_date')
 
     amount_untaxed = fields.Monetary(string='Untaxed Amount', store=True, readonly=True, compute='_amount_all', track_visibility='always')
     amount_tax = fields.Monetary(string='Taxes', store=True, readonly=True, compute='_amount_all')
@@ -149,7 +150,7 @@ class PurchaseOrder(models.Model):
 
     product_id = fields.Many2one('product.product', related='order_line.product_id', string='Product')
     create_uid = fields.Many2one('res.users', 'Responsible')
-    company_id = fields.Many2one('res.company', 'Company', required=True, select=1, states=READONLY_STATES, default=lambda self: self.env.user.company_id.id)
+    company_id = fields.Many2one('res.company', 'Company', required=True, index=True, states=READONLY_STATES, default=lambda self: self.env.user.company_id.id)
 
     picking_type_id = fields.Many2one('stock.picking.type', 'Deliver To', states=READONLY_STATES, required=True, default=_default_picking_type,\
         help="This will determine picking type of incoming shipment")
@@ -548,7 +549,7 @@ class PurchaseOrderLine(models.Model):
     name = fields.Text(string='Description', required=True)
     sequence = fields.Integer(string='Sequence', default=10)
     product_qty = fields.Float(string='Quantity', digits=dp.get_precision('Product Unit of Measure'), required=True)
-    date_planned = fields.Datetime(string='Scheduled Date', required=True, select=True)
+    date_planned = fields.Datetime(string='Scheduled Date', required=True, index=True)
     taxes_id = fields.Many2many('account.tax', string='Taxes', domain=['|', ('active', '=', False), ('active', '=', True)])
     product_uom = fields.Many2one('product.uom', string='Product Unit of Measure', required=True)
     product_id = fields.Many2one('product.product', string='Product', domain=[('purchase_ok', '=', True)], change_default=True, required=True)
@@ -559,7 +560,7 @@ class PurchaseOrderLine(models.Model):
     price_total = fields.Monetary(compute='_compute_amount', string='Total', store=True)
     price_tax = fields.Monetary(compute='_compute_amount', string='Tax', store=True)
 
-    order_id = fields.Many2one('purchase.order', string='Order Reference', select=True, required=True, ondelete='cascade')
+    order_id = fields.Many2one('purchase.order', string='Order Reference', index=True, required=True, ondelete='cascade')
     account_analytic_id = fields.Many2one('account.analytic.account', string='Analytic Account')
     analytic_tag_ids = fields.Many2many('account.analytic.tag', string='Analytic Tags')
     company_id = fields.Many2one('res.company', related='order_id.company_id', string='Company', store=True, readonly=True)
@@ -776,6 +777,7 @@ class PurchaseOrderLine(models.Model):
 
 class ProcurementRule(models.Model):
     _inherit = 'procurement.rule'
+
     @api.model
     def _get_action(self):
         return [('buy', _('Buy'))] + super(ProcurementRule, self)._get_action()
@@ -1052,6 +1054,7 @@ class ProductProduct(models.Model):
 
     purchase_count = fields.Integer(compute='_purchase_count', string='# Purchases')
 
+
 class ProductCategory(models.Model):
     _inherit = "product.category"
 

--- a/addons/purchase/models/res_company.py
+++ b/addons/purchase/models/res_company.py
@@ -1,12 +1,12 @@
 # -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
-from openerp import fields, models
+from odoo import fields, models
 
-class company(models.Model):
+class Company(models.Model):
     _inherit = 'res.company'
 
-    po_lead = fields.Float(string='Purchase Lead Time', required=True,\
+    po_lead = fields.Float(string='Purchase Lead Time', required=True,
         help="Margin of error for vendor lead times. When the system "
              "generates Purchase Orders for procuring products, "
              "they will be scheduled that many days earlier "
@@ -21,8 +21,8 @@ class company(models.Model):
     po_double_validation = fields.Selection([
         ('one_step', 'Confirm purchase orders in one step'),
         ('two_step', 'Get 2 levels of approvals to confirm a purchase order')
-        ], string="Levels of Approvals", default='one_step',\
+        ], string="Levels of Approvals", default='one_step',
         help="Provide a double validation mechanism for purchases")
 
-    po_double_validation_amount = fields.Monetary(string='Double validation amount', default=5000,\
+    po_double_validation_amount = fields.Monetary(string='Double validation amount', default=5000,
         help="Minimum amount for which a double validation is required")

--- a/addons/purchase/models/res_config.py
+++ b/addons/purchase/models/res_config.py
@@ -1,62 +1,57 @@
 # -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
-from openerp import SUPERUSER_ID
-from openerp.osv import fields, osv
-from openerp.tools.translate import _
+from odoo import fields, models
 
-class purchase_config_settings(osv.osv_memory):
+
+class PurchaseConfigSettings(models.TransientModel):
     _name = 'purchase.config.settings'
     _inherit = 'res.config.settings'
 
-    _columns = {
-        'group_product_variant': fields.selection([
-            (0, "No variants on products"),
-            (1, 'Products can have several attributes, defining variants (Example: size, color,...)')
-            ], "Product Variants",
-            help='Work with product variant allows you to define some variant of the same products, an ease the product management in the ecommerce for example',
-            implied_group='product.group_product_variant'),
-        'group_uom':fields.selection([
-            (0, 'Products have only one unit of measure (easier)'),
-            (1, 'Some products may be sold/puchased in different units of measure (advanced)')
-            ], "Units of Measure",
-            implied_group='product.group_uom',
-            help="""Allows you to select and maintain different units of measure for products."""),
-        'group_costing_method':fields.selection([
-            (0, 'Set a fixed cost price on each product'),
-            (1, "Use a 'Fixed', 'Real' or 'Average' price costing method")
-            ], "Costing Methods",
-            implied_group='stock_account.group_inventory_valuation',
-            help="""Allows you to compute product cost price based on average cost."""),
-        'module_purchase_requisition': fields.selection([
-            (0, 'Purchase propositions trigger draft purchase orders to a single supplier'),
-            (1, 'Allow using call for tenders to get quotes from multiple suppliers (advanced)')
-            ], "Calls for Tenders",
-            help="Calls for tenders are used when you want to generate requests for quotations to several vendors for a given set of products.\n"
-                 "You can configure per product if you directly do a Request for Quotation "
-                 "to one vendor or if you want a Call for Tenders to compare offers from several vendors."),
-        'group_warning_purchase': fields.selection([
-            (0, 'All the products and the customers can be used in purchase orders'),
-            (1, 'An informative or blocking warning can be set on a product or a customer')
-            ], "Warning", implied_group='purchase.group_warning_purchase'),
-        'module_stock_dropshipping': fields.selection([
-            (0, 'Suppliers always deliver to your warehouse(s)'),
-            (1, "Allow suppliers to deliver directly to your customers")
-            ], "Dropshipping",
-            help='\nCreates the dropship Route and add more complex tests\n'
-                 '-This installs the module stock_dropshipping.'),
-        'group_manage_vendor_price': fields.selection([
-            (0, 'Manage vendor price on the product form'),
-            (1, 'Allow using and importing vendor pricelists')
-            ], "Vendor Price", 
-            implied_group="purchase.group_manage_vendor_price"),
-    }
+    group_product_variant = fields.Selection([
+        (0, "No variants on products"),
+        (1, 'Products can have several attributes, defining variants (Example: size, color,...)')
+        ], "Product Variants",
+        help='Work with product variant allows you to define some variant of the same products, an ease the product management in the ecommerce for example',
+        implied_group='product.group_product_variant')
+    group_uom = fields.Selection([
+        (0, 'Products have only one unit of measure (easier)'),
+        (1, 'Some products may be sold/puchased in different units of measure (advanced)')
+        ], "Units of Measure",
+        implied_group='product.group_uom',
+        help="""Allows you to select and maintain different units of measure for products.""")
+    group_costing_method = fields.Selection([
+        (0, 'Set a fixed cost price on each product'),
+        (1, "Use a 'Fixed', 'Real' or 'Average' price costing method")
+        ], "Costing Methods",
+        implied_group='stock_account.group_inventory_valuation',
+        help="""Allows you to compute product cost price based on average cost.""")
+    module_purchase_requisition = fields.Selection([
+        (0, 'Purchase propositions trigger draft purchase orders to a single supplier'),
+        (1, 'Allow using call for tenders to get quotes from multiple suppliers (advanced)')
+        ], "Calls for Tenders",
+        help="Calls for tenders are used when you want to generate requests for quotations to several vendors for a given set of products.\n"
+             "You can configure per product if you directly do a Request for Quotation "
+             "to one vendor or if you want a Call for Tenders to compare offers from several vendors.")
+    group_warning_purchase = fields.Selection([
+        (0, 'All the products and the customers can be used in purchase orders'),
+        (1, 'An informative or blocking warning can be set on a product or a customer')
+        ], "Warning", implied_group='purchase.group_warning_purchase')
+    module_stock_dropshipping = fields.Selection([
+        (0, 'Suppliers always deliver to your warehouse(s)'),
+        (1, "Allow suppliers to deliver directly to your customers")
+        ], "Dropshipping",
+        help='\nCreates the dropship Route and add more complex tests\n'
+             '-This installs the module stock_dropshipping.')
+    group_manage_vendor_price = fields.Selection([
+        (0, 'Manage vendor price on the product form'),
+        (1, 'Allow using and importing vendor pricelists')
+        ], "Vendor Price",
+        implied_group="purchase.group_manage_vendor_price")
 
 
-class account_config_settings(osv.osv_memory):
+class AccountConfigSettings(models.TransientModel):
     _inherit = 'account.config.settings'
-    _columns = {
-        'group_analytic_account_for_purchases': fields.boolean('Analytic accounting for purchases',
-            implied_group='purchase.group_analytic_accounting',
-            help="Allows you to specify an analytic account on purchase order lines."),
-    }
+    group_analytic_account_for_purchases = fields.Boolean('Analytic accounting for purchases',
+        implied_group='purchase.group_analytic_accounting',
+        help="Allows you to specify an analytic account on purchase order lines.")

--- a/addons/purchase/models/res_partner.py
+++ b/addons/purchase/models/res_partner.py
@@ -1,8 +1,9 @@
 # -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
-from openerp import api, fields, models
-from openerp.addons.base.res.res_partner import WARNING_MESSAGE, WARNING_HELP
+from odoo import api, fields, models
+from odoo.addons.base.res.res_partner import WARNING_MESSAGE, WARNING_HELP
+
 
 class res_partner(models.Model):
     _name = 'res.partner'

--- a/addons/purchase/models/stock.py
+++ b/addons/purchase/models/stock.py
@@ -1,20 +1,19 @@
 # -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
-from openerp import api
-from openerp.osv import fields, osv
-from openerp.tools.translate import _
-from openerp.exceptions import UserError
+from odoo import api, fields, models, _
+from odoo.exceptions import UserError
 
-class stock_picking(osv.osv):
+
+class StockPicking(models.Model):
     _inherit = 'stock.picking'
-    _columns = {
-        'purchase_id': fields.related('move_lines', 'purchase_line_id', 'order_id', string="Purchase Orders",
-            readonly=True, type="many2one", relation="purchase.order"),
-    }
 
-    def _prepare_values_extra_move(self, cr, uid, op, product, remaining_qty, context=None):
-        res = super(stock_picking, self)._prepare_values_extra_move(cr, uid, op, product, remaining_qty, context=context)
+    purchase_id = fields.Many2one('purchase.order', related='move_lines.purchase_line_id.order_id',
+        string="Purchase Orders", readonly=True)
+
+    @api.model
+    def _prepare_values_extra_move(self, op, product, remaining_qty):
+        res = super(StockPicking, self)._prepare_values_extra_move(op, product, remaining_qty)
         for m in op.linked_move_operation_ids:
             if m.move_id.purchase_line_id and m.move_id.product_id == product:
                 res['purchase_line_id'] = m.move_id.purchase_line_id.id
@@ -23,7 +22,7 @@ class stock_picking(osv.osv):
 
     @api.model
     def _create_backorder(self, backorder_moves=[]):
-        res = super(stock_picking, self)._create_backorder(backorder_moves)
+        res = super(StockPicking, self)._create_backorder(backorder_moves)
         for picking in self:
             if picking.picking_type_id.code == 'incoming':
                 backorder = self.search([('backorder_id', '=', picking.id)])
@@ -32,13 +31,12 @@ class stock_picking(osv.osv):
                     subtype_id=self.env.ref('mail.mt_note').id)
         return res
 
-class stock_move(osv.osv):
+
+class StockMove(models.Model):
     _inherit = 'stock.move'
-    _columns = {
-        'purchase_line_id': fields.many2one('purchase.order.line',
-            'Purchase Order Line', ondelete='set null', select=True,
-            readonly=True),
-    }
+
+    purchase_line_id = fields.Many2one('purchase.order.line',
+        'Purchase Order Line', ondelete='set null', index=True, readonly=True)
 
     @api.multi
     def get_price_unit(self):
@@ -56,95 +54,88 @@ class stock_move(osv.osv):
                 self.write({'price_unit': price_unit})
                 return price_unit
             return self.price_unit
-        return super(stock_move, self).get_price_unit()
+        return super(StockMove, self).get_price_unit()
 
-    def copy(self, cr, uid, id, default=None, context=None):
+    @api.multi
+    def copy(self, default=None):
+        self.ensure_one()
         default = default or {}
-        context = context or {}
         if not default.get('split_from'):
             #we don't want to propagate the link to the purchase order line except in case of move split
             default['purchase_line_id'] = False
-        return super(stock_move, self).copy(cr, uid, id, default, context)
+        return super(StockMove, self).copy(default)
 
 
-class stock_warehouse(osv.osv):
+class StockWarehouse(models.Model):
     _inherit = 'stock.warehouse'
-    _columns = {
-        'buy_to_resupply': fields.boolean('Purchase to resupply this warehouse',
-                                          help="When products are bought, they can be delivered to this warehouse"),
-        'buy_pull_id': fields.many2one('procurement.rule', 'Buy rule'),
-    }
-    _defaults = {
-        'buy_to_resupply': True,
-    }
-
-    def _get_buy_pull_rule(self, cr, uid, warehouse, context=None):
-        route_obj = self.pool.get('stock.location.route')
-        data_obj = self.pool.get('ir.model.data')
+
+    buy_to_resupply = fields.Boolean('Purchase to resupply this warehouse', default=True,
+                                     help="When products are bought, they can be delivered to this warehouse")
+    buy_pull_id = fields.Many2one('procurement.rule', 'Buy rule')
+
+    @api.multi
+    def _get_buy_pull_rule(self):
         try:
-            buy_route_id = data_obj.get_object_reference(cr, uid, 'purchase', 'route_warehouse0_buy')[1]
+            buy_route_id = self.env['ir.model.data'].get_object_reference('purchase', 'route_warehouse0_buy')[1]
         except:
-            buy_route_id = route_obj.search(cr, uid, [('name', 'like', _('Buy'))], context=context)
-            buy_route_id = buy_route_id and buy_route_id[0] or False
+            buy_route_id = self.env['stock.location.route'].search([('name', 'like', _('Buy'))])
+            buy_route_id = buy_route_id[0].id if buy_route_id else False
         if not buy_route_id:
-            raise UserError(_('Can\'t find any generic Buy route.'))
+            raise UserError(_("Can't find any generic Buy route."))
 
         return {
-            'name': warehouse._format_routename(_(' Buy')),
-            'location_id': warehouse.in_type_id.default_location_dest_id.id,
+            'name': self._format_routename(_(' Buy')),
+            'location_id': self.in_type_id.default_location_dest_id.id,
             'route_id': buy_route_id,
             'action': 'buy',
-            'picking_type_id': warehouse.in_type_id.id,
-            'warehouse_id': warehouse.id,
+            'picking_type_id': self.in_type_id.id,
+            'warehouse_id': self.id,
             'group_propagation_option': 'none',
         }
 
-    def create_routes(self, cr, uid, ids, context=None):
-        pull_obj = self.pool.get('procurement.rule')
-        res = super(stock_warehouse, self).create_routes(cr, uid, ids, context=context)
-        warehouse = self.browse(cr, uid, ids, context=context)[0]
-        if warehouse.buy_to_resupply:
-            buy_pull_vals = self._get_buy_pull_rule(cr, uid, warehouse, context=context)
-            buy_pull_id = pull_obj.create(cr, uid, buy_pull_vals, context=context)
-            res['buy_pull_id'] = buy_pull_id
+    @api.multi
+    def create_routes(self):
+        res = super(StockWarehouse, self).create_routes() # super applies ensure_one()
+        if self.buy_to_resupply:
+            buy_pull_vals = self._get_buy_pull_rule()
+            buy_pull = self.env['procurement.rule'].create(buy_pull_vals)
+            res['buy_pull_id'] = buy_pull.id
         return res
 
-    def write(self, cr, uid, ids, vals, context=None):
-        pull_obj = self.pool.get('procurement.rule')
-        if isinstance(ids, (int, long)):
-            ids = [ids]
-
+    @api.multi
+    def write(self, vals):
         if 'buy_to_resupply' in vals:
             if vals.get("buy_to_resupply"):
-                for warehouse in self.browse(cr, uid, ids, context=context):
+                for warehouse in self:
                     if not warehouse.buy_pull_id:
-                        buy_pull_vals = self._get_buy_pull_rule(cr, uid, warehouse, context=context)
-                        buy_pull_id = pull_obj.create(cr, uid, buy_pull_vals, context=context)
-                        vals['buy_pull_id'] = buy_pull_id
+                        buy_pull_vals = self._get_buy_pull_rule()
+                        buy_pull = self.env['procurement.rule'].create(buy_pull_vals)
+                        vals['buy_pull_id'] = buy_pull.id
             else:
-                for warehouse in self.browse(cr, uid, ids, context=context):
+                for warehouse in self:
                     if warehouse.buy_pull_id:
-                        buy_pull_id = pull_obj.unlink(cr, uid, warehouse.buy_pull_id.id, context=context)
-        return super(stock_warehouse, self).write(cr, uid, ids, vals, context=None)
+                        warehouse.buy_pull_id.unlink()
+        return super(StockWarehouse, self).write(vals)
 
     @api.multi
     def _get_all_routes(self):
-        routes = super(stock_warehouse, self).get_all_routes_for_wh()
+        routes = super(StockWarehouse, self).get_all_routes_for_wh()
         routes |= self.filtered(lambda self: self.buy_to_resupply and self.buy_pull_id and self.buy_pull_id.route_id).mapped('buy_pull_id').mapped('route_id')
         return routes
 
-    def _handle_renaming(self, cr, uid, ids, name, code, context=None):
-        res = super(stock_warehouse, self)._handle_renaming(cr, uid, ids, name, code, context=context)
-        warehouse = self.browse(cr, uid, ids[0], context=context)
-        pull_obj = self.pool.get('procurement.rule')
+    @api.multi
+    def _handle_renaming(self, name, code):
+        res = super(StockWarehouse, self)._handle_renaming(name, code)
+        warehouse = self[0]
         #change the buy procurement rule name
         if warehouse.buy_pull_id:
-            pull_obj.write(cr, uid, warehouse.buy_pull_id.id, {'name': warehouse.buy_pull_id.name.replace(warehouse.name, name, 1)}, context=context)
+            warehouse.buy_pull_id.write({'name': warehouse.buy_pull_id.name.replace(warehouse.name, name, 1)})
         return res
 
-    def change_route(self, cr, uid, ids, context=None):
-        res = super(stock_warehouse, self).change_route(cr, uid, ids, context=context)
-        for warehouse in self.browse(cr, uid, ids[0], context=context):
+    @api.multi
+    def change_route(self):
+        res = super(StockWarehouse, self).change_route()
+        for warehouse in self:
             if warehouse.in_type_id.default_location_dest_id != warehouse.buy_pull_id.location_id:
-                self.pool.get('procurement.rule').write(cr, uid, warehouse.buy_pull_id.id, {'location_id': warehouse.in_type_id.default_location_dest_id.id}, context=context)
+                warehouse.buy_pull_id.write({'location_id': warehouse.in_type_id.default_location_dest_id.id})
         return res
