PR: https://github.com/odoo/odoo/pull/42972

From: 4b3798d917481f15af6c4f836255ff6e97ceb0e4
From: RÃ©my Voet (ryv)
Date: 2020-01-08 15:43:14

Structural Changes: 1
Total Changes: 40

[REM] stock: remove dead code of stock move

- Remove the unused field call string_availability_info
on the stock.move model. It was used in version 11.0
in a form view, this form views has been merge and
this fields is now unused.
- Remove onchange_quantity function, because the product_qty
can't be change (_set_product_qty doesn't allow that) and
the product_id is required.

closes odoo/odoo#42972

Signed-off-by: Simon Lejeune (sle) <sle@openerp.com>

================================= pseudo patch: =================================

--- a/addons/stock/models/stock_move.py
+++ b/addons/stock/models/stock_move.py
@@ -149,9 +149,6 @@ class StockMove(models.Model):
     availability = fields.Float(
         'Forecasted Quantity', compute='_compute_product_availability',
         readonly=True, help='Quantity in stock that can still be reserved for this move')
-    string_availability_info = fields.Text(
-        'Availability', compute='_compute_string_qty_information',
-        readonly=True, help='Show various information on stock availability for this move')
     restrict_partner_id = fields.Many2one(
         'res.partner', 'Owner ', help="Technical field used to depict a restriction on the ownership of quants to consider when marking this move as 'done'",
         check_company=True)
@@ -357,30 +354,6 @@ class StockMove(models.Model):
                 total_availability = self.env['stock.quant']._get_available_quantity(move.product_id, move.location_id) if move.product_id else 0.0
                 move.availability = min(move.product_qty, total_availability)
 
-    def _compute_string_qty_information(self):
-        precision = self.env['decimal.precision'].precision_get('Product Unit of Measure')
-        void_moves = self.filtered(lambda move: move.state in ('draft', 'done', 'cancel') or move.location_id.usage != 'internal')
-        other_moves = self - void_moves
-        for move in void_moves:
-            move.string_availability_info = ''  # 'not applicable' or 'n/a' could work too
-        for move in other_moves:
-            total_available = min(move.product_qty, move.reserved_availability + move.availability)
-            total_available = move.product_id.uom_id._compute_quantity(total_available, move.product_uom, round=False)
-            total_available = float_round(total_available, precision_digits=precision)
-            info = str(total_available)
-            if self.user_has_groups('uom.group_uom'):
-                info += ' ' + move.product_uom.name
-            if move.reserved_availability:
-                if move.reserved_availability != total_available:
-                    # some of the available quantity is assigned and some are available but not reserved
-                    reserved_available = move.product_id.uom_id._compute_quantity(move.reserved_availability, move.product_uom, round=False)
-                    reserved_available = float_round(reserved_available, precision_digits=precision)
-                    info += _(' (%s reserved)') % str(reserved_available)
-                else:
-                    # all available quantity is assigned
-                    info += _(' (reserved)')
-            move.string_availability_info = info
-
     @api.constrains('product_uom')
     def _check_uom(self):
         moves_error = self.filtered(lambda move: move.product_id.uom_id.category_id != move.product_uom.category_id)
@@ -829,19 +802,6 @@ class StockMove(models.Model):
             else:
                 return moves_todo[-1].state or 'draft'
 
-    @api.onchange('product_id', 'product_qty')
-    def onchange_quantity(self):
-        if not self.product_id or self.product_qty < 0.0:
-            self.product_qty = 0.0
-        if self.product_qty < self._origin.product_qty:
-            warning_mess = {
-                'title': _('Quantity decreased!'),
-                'message' : _("By changing this quantity here, you accept the "
-                              "new quantity as complete: Odoo will not "
-                              "automatically generate a back order."),
-            }
-            return {'warning': warning_mess}
-
     @api.onchange('product_id')
     def onchange_product_id(self):
         product = self.product_id.with_context(lang=self.partner_id.lang or self.env.user.lang)
