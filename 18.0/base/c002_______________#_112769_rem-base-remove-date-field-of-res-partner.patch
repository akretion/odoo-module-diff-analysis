PR: https://github.com/odoo/odoo/pull/112769

From: 3d78dca8fa0c2da000572476abd1bbb946baac3c
From: RÃ©my Voet (ryv)
Date: 2023-11-24 07:57:45

Structural Changes: 1
Total Changes: 183

[REM] base: remove `date` field of `res.partner`

This field is only used in tests, but it still takes up space (because
of the index) and is prefetched for no reason.

Then remove it, but keep it in the `test_read_group` module test, and
move some tests there (`test_read_group` and the
`test_read_progress_bar.py` file). `test_groupby_date` and
`test_read_group_1` have been removed because the `test_read_group`
module already tests these cases (coverage remains the same).

Part-of: odoo/odoo#112769

================================= pseudo patch: =================================

--- a/odoo/addons/base/models/res_partner.py
+++ b/odoo/addons/base/models/res_partner.py
@@ -192,7 +192,6 @@ class Partner(models.Model):
 
     name = fields.Char(index=True, default_export_compatible=True)
     complete_name = fields.Char(compute='_compute_complete_name', store=True, index=True)
-    date = fields.Date(index=True)
     title = fields.Many2one('res.partner.title')
     parent_id = fields.Many2one('res.partner', string='Related Company', index=True)
     parent_name = fields.Char(related='parent_id.name', readonly=True, string='Parent name')

--- a/odoo/addons/base/tests/test_ir_actions.py
+++ b/odoo/addons/base/tests/test_ir_actions.py
@@ -458,7 +458,7 @@ ZeroDivisionError: division by zero""" % self.test_server_action.id
     def test_80_permission(self):
         self.action.write({
             'state': 'code',
-            'code': """record.write({'date': datetime.date.today()})""",
+            'code': """record.write({'name': str(datetime.date.today())})""",
         })
 
         user_demo = self.env.ref("base.user_demo")
@@ -469,7 +469,7 @@ ZeroDivisionError: division by zero""" % self.test_server_action.id
         self.test_partner.with_user(user_demo.id).check_access_rule("write")
 
         self_demo.with_context(self.context).run()
-        self.assertEqual(self.test_partner.date, date.today())
+        self.assertEqual(self.test_partner.name, str(date.today()))
 
     def test_90_webhook(self):
         self.action.write({

--- a/odoo/addons/base/tests/test_ir_filters.py
+++ b/odoo/addons/base/tests/test_ir_filters.py
@@ -277,25 +277,6 @@ class TestGlobalDefaults(FiltersCase):
         ])
 
 
-class TestReadGroup(TransactionCase):
-    """Test function read_group with groupby on a many2one field to a model
-    (in test, "user_id" to "res.users") which is ordered by an inherited not stored field (in
-    test, "name" inherited from "res.partners").
-    """
-    def test_read_group_1(self):
-        Users = self.env['res.users']
-        self.assertEqual(Users._order, "name, login", "Model res.users must be ordered by name, login")
-        self.assertFalse(Users._fields['name'].store, "Field name is not stored in res.users")
-
-        Filters = self.env['ir.filters']
-        filter_a = Filters.create(dict(name="Filter_A", model_id="ir.filters"))
-        filter_b = Filters.create(dict(name="Filter_B", model_id="ir.filters"))
-        filter_b.write(dict(user_id=False))
-
-        res = Filters.read_group([], ['name', 'user_id'], ['user_id'])
-        self.assertTrue(any(val['user_id'] == False for val in res), "At least one group must contain val['user_id'] == False.")
-
-
 @tagged('post_install', '-at_install', 'migration')
 class TestAllFilters(TransactionCase):
     def check_filter(self, name, model, domain, fields, groupby, order, context):

--- a/odoo/addons/base/tests/test_orm.py
+++ b/odoo/addons/base/tests/test_orm.py
@@ -156,64 +156,6 @@ class TestORM(TransactionCase):
         recs = partner.browse([0])
         self.assertFalse(recs.exists())
 
-    def test_groupby_date(self):
-        partners_data = dict(
-            A='2012-11-19',
-            B='2012-12-17',
-            C='2012-12-31',
-            D='2013-01-07',
-            E='2013-01-14',
-            F='2013-01-28',
-            G='2013-02-11',
-        )
-
-        partner_ids = []
-        partner_ids_by_day = defaultdict(list)
-        partner_ids_by_month = defaultdict(list)
-        partner_ids_by_year = defaultdict(list)
-
-        partners = self.env['res.partner']
-        for name, date in partners_data.items():
-            p = partners.create(dict(name=name, date=date))
-            partner_ids.append(p.id)
-            partner_ids_by_day[date].append(p.id)
-            partner_ids_by_month[date.rsplit('-', 1)[0]].append(p.id)
-            partner_ids_by_year[date.split('-', 1)[0]].append(p.id)
-
-        def read_group(interval):
-            domain = [('id', 'in', partner_ids)]
-            result = {}
-            for grp in partners.read_group(domain, ['date'], ['date:' + interval]):
-                result[grp['date:' + interval]] = partners.search(grp['__domain'])
-            return result
-
-        self.assertEqual(len(read_group('day')), len(partner_ids_by_day))
-        self.assertEqual(len(read_group('month')), len(partner_ids_by_month))
-        self.assertEqual(len(read_group('year')), len(partner_ids_by_year))
-
-        res = partners.read_group([('id', 'in', partner_ids)], ['date'],
-                                  ['date:month', 'date:day'], lazy=False)
-        self.assertEqual(len(res), len(partner_ids))
-
-        # combine groupby and orderby
-        months = ['February 2013', 'January 2013', 'December 2012', 'November 2012']
-        res = partners.read_group([('id', 'in', partner_ids)], ['date'],
-                                  groupby=['date:month'], orderby='date:month DESC')
-        self.assertEqual([item['date:month'] for item in res], months)
-
-        # order by date should reorder by date:month
-        res = partners.read_group([('id', 'in', partner_ids)], ['date'],
-                                  groupby=['date:month'], orderby='date DESC')
-        self.assertEqual([item['date:month'] for item in res], months)
-
-        # order by date should reorder by date:day
-        days = ['11 Feb 2013', '28 Jan 2013', '14 Jan 2013', '07 Jan 2013',
-                '31 Dec 2012', '17 Dec 2012', '19 Nov 2012']
-        res = partners.read_group([('id', 'in', partner_ids)], ['date'],
-                                  groupby=['date:month', 'date:day'],
-                                  orderby='date DESC', lazy=False)
-        self.assertEqual([item['date:day'] for item in res], days)
-
     def test_write_duplicate(self):
         p1 = self.env['res.partner'].create({'name': 'W'})
         (p1 + p1).write({'name': 'X'})

--- a/odoo/addons/base/tests/test_res_partner.py
+++ b/odoo/addons/base/tests/test_res_partner.py
@@ -292,107 +292,6 @@ class TestPartner(TransactionCase):
             "'Destination Contact' name should contain db ID in brackets"
         )
 
-    def test_read_group(self):
-        title_sir = self.env['res.partner.title'].create({'name': 'Sir...'})
-        title_lady = self.env['res.partner.title'].create({'name': 'Lady...'})
-        user_vals_list = [
-            {'name': 'Alice', 'login': 'alice', 'color': 1, 'function': 'Friend', 'date': '2015-03-28', 'title': title_lady.id},
-            {'name': 'Alice', 'login': 'alice2', 'color': 0, 'function': 'Friend', 'date': '2015-01-28', 'title': title_lady.id},
-            {'name': 'Bob', 'login': 'bob', 'color': 2, 'function': 'Friend', 'date': '2015-03-02', 'title': title_sir.id},
-            {'name': 'Eve', 'login': 'eve', 'color': 3, 'function': 'Eavesdropper', 'date': '2015-03-20', 'title': title_lady.id},
-            {'name': 'Nab', 'login': 'nab', 'color': -3, 'function': '5$ Wrench', 'date': '2014-09-10', 'title': title_sir.id},
-            {'name': 'Nab', 'login': 'nab-she', 'color': 6, 'function': '5$ Wrench', 'date': '2014-01-02', 'title': title_lady.id},
-        ]
-        res_users = self.env['res.users']
-        users = res_users.create(user_vals_list)
-        domain = [('id', 'in', users.ids)]
-
-        # group on local char field without domain and without active_test (-> empty WHERE clause)
-        groups_data = res_users.with_context(active_test=False).read_group([], fields=['login'], groupby=['login'], orderby='login DESC')
-        self.assertGreater(len(groups_data), 6, "Incorrect number of results when grouping on a field")
-
-        # group on local char field with limit
-        groups_data = res_users.read_group(domain, fields=['login'], groupby=['login'], orderby='login DESC', limit=3, offset=3)
-        self.assertEqual(len(groups_data), 3, "Incorrect number of results when grouping on a field with limit")
-        self.assertEqual([g['login'] for g in groups_data], ['bob', 'alice2', 'alice'], 'Result mismatch')
-
-        # group on inherited char field, aggregate on int field (second groupby ignored on purpose)
-        groups_data = res_users.read_group(domain, fields=['name', 'color', 'function'], groupby=['function', 'login'])
-        self.assertEqual(len(groups_data), 3, "Incorrect number of results when grouping on a field")
-        self.assertEqual(['5$ Wrench', 'Eavesdropper', 'Friend'], [g['function'] for g in groups_data], 'incorrect read_group order')
-        for group_data in groups_data:
-            self.assertIn('color', group_data, "Aggregated data for the column 'color' is not present in read_group return values")
-            self.assertEqual(group_data['color'], 3, "Incorrect sum for aggregated data for the column 'color'")
-
-        # group on inherited char field, reverse order
-        groups_data = res_users.read_group(domain, fields=['name', 'color'], groupby='name', orderby='name DESC')
-        self.assertEqual([g['name'] for g in groups_data], ['Nab', 'Eve', 'Bob', 'Alice'], 'Incorrect ordering of the list')
-
-        # group on int field, default ordering
-        groups_data = res_users.read_group(domain, fields=['color'], groupby='color')
-        self.assertEqual([g['color'] for g in groups_data], [-3, 0, 1, 2, 3, 6], 'Incorrect ordering of the list')
-
-        # multi group, second level is int field, should still be summed in first level grouping
-        groups_data = res_users.read_group(domain, fields=['name', 'color'], groupby=['name', 'color'], orderby='name DESC')
-        self.assertEqual([g['name'] for g in groups_data], ['Nab', 'Eve', 'Bob', 'Alice'], 'Incorrect ordering of the list')
-        self.assertEqual([g['color'] for g in groups_data], [3, 3, 2, 1], 'Incorrect ordering of the list')
-
-        # group on inherited char field, multiple orders with directions
-        groups_data = res_users.read_group(domain, fields=['name', 'color'], groupby='name', orderby='color DESC, name')
-        self.assertEqual(len(groups_data), 4, "Incorrect number of results when grouping on a field")
-        self.assertEqual([g['name'] for g in groups_data], ['Eve', 'Nab', 'Bob', 'Alice'], 'Incorrect ordering of the list')
-        self.assertEqual([g['name_count'] for g in groups_data], [1, 2, 1, 2], 'Incorrect number of results')
-
-        # group on inherited date column (res_partner.date) -> Year-Month, default ordering
-        groups_data = res_users.read_group(domain, fields=['function', 'color', 'date'], groupby=['date'])
-        self.assertEqual(len(groups_data), 4, "Incorrect number of results when grouping on a field")
-        self.assertEqual([g['date'] for g in groups_data], ['January 2014', 'September 2014', 'January 2015', 'March 2015'], 'Incorrect ordering of the list')
-        self.assertEqual([g['date_count'] for g in groups_data], [1, 1, 1, 3], 'Incorrect number of results')
-
-        # group on inherited date column (res_partner.date) specifying the :year -> Year default ordering
-        groups_data = res_users.read_group(domain, fields=['function', 'color', 'date'], groupby=['date:year'])
-        self.assertEqual(len(groups_data), 2, "Incorrect number of results when grouping on a field")
-        self.assertEqual([g['date:year'] for g in groups_data], ['2014', '2015'], 'Incorrect ordering of the list')
-        self.assertEqual([g['date_count'] for g in groups_data], [2, 4], 'Incorrect number of results')
-
-        # group on inherited date column (res_partner.date) -> Year-Month, custom order
-        groups_data = res_users.read_group(domain, fields=['function', 'color', 'date'], groupby=['date'], orderby='date DESC')
-        self.assertEqual(len(groups_data), 4, "Incorrect number of results when grouping on a field")
-        self.assertEqual([g['date'] for g in groups_data], ['March 2015', 'January 2015', 'September 2014', 'January 2014'], 'Incorrect ordering of the list')
-        self.assertEqual([g['date_count'] for g in groups_data], [3, 1, 1, 1], 'Incorrect number of results')
-
-        # group on inherited many2one (res_partner.title), default order
-        groups_data = res_users.read_group(domain, fields=['function', 'color', 'title'], groupby=['title'])
-        self.assertEqual(len(groups_data), 2, "Incorrect number of results when grouping on a field")
-        # m2o is returned as a (id, label) pair
-        self.assertEqual([g['title'] for g in groups_data], [(title_lady.id, 'Lady...'), (title_sir.id, 'Sir...')], 'Incorrect ordering of the list')
-        self.assertEqual([g['title_count'] for g in groups_data], [4, 2], 'Incorrect number of results')
-        self.assertEqual([g['color'] for g in groups_data], [10, -1], 'Incorrect aggregation of int column')
-
-        # group on inherited many2one (res_partner.title), reversed natural order
-        groups_data = res_users.read_group(domain, fields=['function', 'color', 'title'], groupby=['title'], orderby="title desc")
-        self.assertEqual(len(groups_data), 2, "Incorrect number of results when grouping on a field")
-        # m2o is returned as a (id, label) pair
-        self.assertEqual([(title_sir.id, 'Sir...'), (title_lady.id, 'Lady...')], [g['title'] for g in groups_data], 'Incorrect ordering of the list')
-        self.assertEqual([g['title_count'] for g in groups_data], [2, 4], 'Incorrect number of results')
-        self.assertEqual([g['color'] for g in groups_data], [-1, 10], 'Incorrect aggregation of int column')
-
-        # group on inherited many2one (res_partner.title), multiple orders with m2o in second position
-        groups_data = res_users.read_group(domain, fields=['function', 'color', 'title'], groupby=['title'], orderby="color desc, title desc")
-        self.assertEqual(len(groups_data), 2, "Incorrect number of results when grouping on a field")
-        # m2o is returned as a (id, label) pair
-        self.assertEqual([g['title'] for g in groups_data], [(title_lady.id, 'Lady...'), (title_sir.id, 'Sir...')], 'Incorrect ordering of the result')
-        self.assertEqual([g['title_count'] for g in groups_data], [4, 2], 'Incorrect number of results')
-        self.assertEqual([g['color'] for g in groups_data], [10, -1], 'Incorrect aggregation of int column')
-
-        # group on inherited many2one (res_partner.title), ordered by other inherited field (color)
-        groups_data = res_users.read_group(domain, fields=['function', 'color', 'title'], groupby=['title'], orderby='color')
-        self.assertEqual(len(groups_data), 2, "Incorrect number of results when grouping on a field")
-        # m2o is returned as a (id, label) pair
-        self.assertEqual([g['title'] for g in groups_data], [(title_sir.id, 'Sir...'), (title_lady.id, 'Lady...')], 'Incorrect ordering of the list')
-        self.assertEqual([g['title_count'] for g in groups_data], [2, 4], 'Incorrect number of results')
-        self.assertEqual([g['color'] for g in groups_data], [-1, 10], 'Incorrect aggregation of int column')
-
 
 @tagged('res_partner')
 class TestPartnerAddressCompany(TransactionCase):
