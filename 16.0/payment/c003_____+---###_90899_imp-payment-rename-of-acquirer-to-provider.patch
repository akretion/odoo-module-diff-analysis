PR: https://github.com/odoo/odoo/pull/90899

From: f7b8f07501315233c8208e99b311935815039a3a
From: Horacio Tellez
Date: 2022-09-09 11:38:08

Breaking data model changes scores: del:10 + add:1, change matches:
-    acquirer_ids = fields.Many2many(
+    provider_ids = fields.Many2many(
-    provider = fields.Selection(
-    acquirer_id = fields.Many2one(
-    provider = fields.Selection(related='acquirer_id.provider')
-    acquirer_ref = fields.Char(
-    acquirer_id = fields.Many2one(
-    provider = fields.Selection(related='acquirer_id.provider')
-    acquirer_reference = fields.Char(
-    payment_acquirer_onboarding_state = fields.Selection(

Total Changes: 1450

[IMP] payment: rename of acquirer to provider

Changing the name of model payment.acquirer to payment.provider
and everything that it touches. It is technically incorrect to
use the term "acquirer" for systems that only provide a service
of payment.
After this commit the model payment.acquirer and all related to
it will be renamed to payment.provider.

Task - 2842088

closes odoo/odoo#90899

Related: odoo/upgrade#3542
Related: odoo/documentation#1981
Related: odoo/enterprise#27131
Signed-off-by: Victor Feyens (vfe) <vfe@odoo.com>

================================= pseudo patch: =================================

--- a/addons/payment/models/__init__.py
+++ b/addons/payment/models/__init__.py
@@ -2,7 +2,7 @@
 
 from . import ir_http
 from . import ir_ui_view
-from . import payment_acquirer
+from . import payment_provider
 from . import payment_icon
 from . import payment_token
 from . import payment_transaction

--- a/addons/payment/models/ir_ui_view.py
+++ b/addons/payment/models/ir_ui_view.py
@@ -8,9 +8,9 @@ class IrUiView(models.Model):
     _inherit = 'ir.ui.view'
 
     @api.ondelete(at_uninstall=False)
-    def _unlink_if_not_referenced_by_acquirer(self):
-        referencing_acquirers_sudo = self.env['payment.acquirer'].sudo().search([
+    def _unlink_if_not_referenced_by_provider(self):
+        referencing_providers_sudo = self.env['payment.provider'].sudo().search([
             '|', ('redirect_form_view_id', 'in', self.ids), ('inline_form_view_id', 'in', self.ids)
         ])  # In sudo mode to allow non-admin users (e.g., Website designers) to read the view ids.
-        if referencing_acquirers_sudo:
-            raise UserError(_("You cannot delete a view that is used by a payment acquirer."))
+        if referencing_providers_sudo:
+            raise UserError(_("You cannot delete a view that is used by a payment provider."))

--- a/addons/payment/models/payment_icon.py
+++ b/addons/payment/models/payment_icon.py
@@ -9,9 +9,9 @@ class PaymentIcon(models.Model):
     _order = 'sequence, name'
 
     name = fields.Char(string="Name")
-    acquirer_ids = fields.Many2many(
-        string="Acquirers", comodel_name='payment.acquirer',
-        help="The list of acquirers supporting this payment icon")
+    provider_ids = fields.Many2many(
+        string="Providers", comodel_name='payment.provider',
+        help="The list of providers supporting this payment icon")
     image = fields.Image(
         string="Image", max_width=64, max_height=64,
         help="This field holds the image used for this payment icon, limited to 64x64 px")

--- a/addons/payment/models/payment_acquirer.py
+++ b/addons/payment/models/payment_provider.py
@@ -11,9 +11,9 @@ from odoo.osv import expression
 _logger = logging.getLogger(__name__)
 
 
-class PaymentAcquirer(models.Model):
-    _name = 'payment.acquirer'
-    _description = 'Payment Acquirer'
+class PaymentProvider(models.Model):
+    _name = 'payment.provider'
+    _description = 'Payment Provider'
     _order = 'module_state, state desc, sequence, name'
 
     def _valid_field_parameter(self, field, name):
@@ -22,18 +22,18 @@ class PaymentAcquirer(models.Model):
     # Configuration fields
     name = fields.Char(string="Name", required=True, translate=True)
     sequence = fields.Integer(string="Sequence", help="Define the display order")
-    provider = fields.Selection(
-        string="Provider", help="The Payment Service Provider to use with this acquirer",
+    code = fields.Selection(
+        string="Code", help="The Payment Service Code to use with this provider",
         selection=[('none', "No Provider Set")], default='none', required=True)
     state = fields.Selection(
         string="State",
         help="In test mode, a fake payment is processed through a test payment interface.\n"
-             "This mode is advised when setting up the acquirer.",
+             "This mode is advised when setting up the provider.",
         selection=[('disabled', "Disabled"), ('enabled', "Enabled"), ('test', "Test Mode")],
         default='disabled', required=True, copy=False)
     is_published = fields.Boolean(
         string="Published",
-        help="Whether the acquirer is visible on the website or not. Tokens remain functional but "
+        help="Whether the provider is visible on the website or not. Tokens remain functional but "
              "are only visible on manage forms.",
     )
     company_id = fields.Many2one(  # Indexed to speed-up ORM searches (from ir_rule or others)
@@ -49,7 +49,7 @@ class PaymentAcquirer(models.Model):
         string="Allow Saving Payment Methods",
         help="This controls whether customers can save their payment methods as payment tokens.\n"
              "A payment token is an anonymous link to the payment method details saved in the\n"
-             "acquirer's database, allowing the customer to reuse it for a next purchase.")
+             "provider's database, allowing the customer to reuse it for a next purchase.")
     capture_manually = fields.Boolean(
         string="Capture Amount Manually",
         help="Capture the amount from Odoo, when the delivery is completed.\n"
@@ -86,7 +86,7 @@ class PaymentAcquirer(models.Model):
     available_country_ids = fields.Many2many(
         string="Countries",
         comodel_name='res.country',
-        help="The countries in which this payment acquirer is available. Leave blank to make it "
+        help="The countries in which this payment provider is available. Leave blank to make it "
              "available in all countries.",
         relation='payment_country_rel',
         column1='payment_id',
@@ -94,7 +94,7 @@ class PaymentAcquirer(models.Model):
     )
     maximum_amount = fields.Monetary(
         string="Maximum Amount",
-        help="The maximum payment amount that this payment acquirer is available for. Leave blank "
+        help="The maximum payment amount that this payment provider is available for. Leave blank "
              "to make it available for any payment amount.",
         currency_field='main_currency_id',
     )
@@ -108,7 +108,7 @@ class PaymentAcquirer(models.Model):
 
     # Message fields
     display_as = fields.Char(
-        string="Displayed as", help="Description of the acquirer for customers",
+        string="Displayed as", help="Description of the provider for customers",
         translate=True)
     pre_msg = fields.Html(
         string="Help Message", help="The message displayed to explain and help the payment process",
@@ -178,26 +178,26 @@ class PaymentAcquirer(models.Model):
 
     @api.depends('state', 'module_state')
     def _compute_color(self):
-        """ Update the color of the kanban card based on the state of the acquirer.
+        """ Update the color of the kanban card based on the state of the provider.
 
         :return: None
         """
-        for acquirer in self:
-            if acquirer.module_id and not acquirer.module_state == 'installed':
-                acquirer.color = 4  # blue
-            elif acquirer.state == 'disabled':
-                acquirer.color = 3  # yellow
-            elif acquirer.state == 'test':
-                acquirer.color = 2  # orange
-            elif acquirer.state == 'enabled':
-                acquirer.color = 7  # green
-
-    @api.depends('provider')
+        for provider in self:
+            if provider.module_id and not provider.module_state == 'installed':
+                provider.color = 4  # blue
+            elif provider.state == 'disabled':
+                provider.color = 3  # yellow
+            elif provider.state == 'test':
+                provider.color = 2  # orange
+            elif provider.state == 'enabled':
+                provider.color = 7  # green
+
+    @api.depends('code')
     def _compute_view_configuration_fields(self):
         """ Compute view configuration fields based on the provider.
 
         By default, all fields are set to `True`.
-        For an acquirer to hide generic elements (pages, fields) in a view, it must override this
+        For a provider to hide generic elements (pages, fields) in a view, it must override this
         method and set their corresponding view configuration field to `False`.
 
         :return: None
@@ -217,7 +217,7 @@ class PaymentAcquirer(models.Model):
     def _compute_feature_support_fields(self):
         """ Compute the feature support fields.
 
-        For an acquirer to support one or more additional feature, it must override this method.
+        For an provider to support one or more additional feature, it must override this method.
 
         :return: None
         """
@@ -233,7 +233,7 @@ class PaymentAcquirer(models.Model):
 
     @api.onchange('state')
     def _onchange_state_switch_is_published(self):
-        """ Automatically publish or unpublish the acquirer depending on its state.
+        """ Automatically publish or unpublish the provider depending on its state.
 
         :return: None
         """
@@ -241,9 +241,9 @@ class PaymentAcquirer(models.Model):
 
     @api.onchange('state')
     def _onchange_state_warn_before_disabling_tokens(self):
-        """ Display a warning about the consequences of disabling an acquirer.
+        """ Display a warning about the consequences of disabling an provider.
 
-        Let the user know that tokens related to an acquirer get archived if it is disabled or if
+        Let the user know that tokens related to an provider get archived if it is disabled or if
         its state is changed from 'test' to 'enabled' and vice versa.
 
         :return: The warning message in a client action.
@@ -253,7 +253,7 @@ class PaymentAcquirer(models.Model):
 
         if self._origin.state in ('test', 'enabled') and self._origin.state != self.state:
             related_tokens = self.env['payment.token'].search(
-                [('acquirer_id', '=', self._origin.id)]
+                [('provider_id', '=', self._origin.id)]
             )
             if related_tokens:
                 return {
@@ -261,7 +261,7 @@ class PaymentAcquirer(models.Model):
                         'title': _("Warning"),
                         'message': _(
                             "This action will also archive %s tokens that are registered with this "
-                            "acquirer. Archiving tokens is irreversible.", len(related_tokens)
+                            "provider. Archiving tokens is irreversible.", len(related_tokens)
                         )
                     }
                 }
@@ -277,25 +277,25 @@ class PaymentAcquirer(models.Model):
 
         :return None
         """
-        for acquirer in self:
-            if any(not 0 <= fee < 100 for fee in (acquirer.fees_dom_var, acquirer.fees_int_var)):
+        for provider in self:
+            if any(not 0 <= fee < 100 for fee in (provider.fees_dom_var, provider.fees_int_var)):
                 raise ValidationError(_("Variable fees must always be positive and below 100%."))
 
     #=== CRUD METHODS ===#
 
     @api.model_create_multi
     def create(self, values_list):
-        acquirers = super().create(values_list)
-        acquirers._check_required_if_provider()
-        return acquirers
+        providers = super().create(values_list)
+        providers._check_required_if_provider()
+        return providers
 
     def write(self, values):
-        # Handle acquirer disabling.
+        # Handle provider disabling.
         if 'state' in values:
-            state_changed_acquirers = self.filtered(
-                lambda acq: acq.state not in ('disabled', values['state'])
-            )  # Don't handle acquirers being enabled or whose state is not updated.
-            state_changed_acquirers._handle_state_change()
+            state_changed_providers = self.filtered(
+                lambda p: p.state not in ('disabled', values['state'])
+            )  # Don't handle providers being enabled or whose state is not updated.
+            state_changed_providers._handle_state_change()
 
         result = super().write(values)
         self._check_required_if_provider()
@@ -303,23 +303,23 @@ class PaymentAcquirer(models.Model):
         return result
 
     def _check_required_if_provider(self):
-        """ Check that acquirer-specific required fields have been filled.
+        """ Check that provider-specific required fields have been filled.
 
         The fields that have the `required_if_provider="<provider>"` attribute are made required
-        for all payment.acquirer records with the `provider` field equal to <provider> and with the
+        for all payment.provider records with the `code` field equal to <provider> and with the
         `state` field equal to 'enabled' or 'test'.
-        Acquirer-specific views should make the form fields required under the same conditions.
+        Provider-specific views should make the form fields required under the same conditions.
 
         :return: None
-        :raise ValidationError: if an acquirer-specific required field is empty
+        :raise ValidationError: if a provider-specific required field is empty
         """
         field_names = []
-        enabled_acquirers = self.filtered(lambda acq: acq.state in ['enabled', 'test'])
+        enabled_providers = self.filtered(lambda p: p.state in ['enabled', 'test'])
         for name, field in self._fields.items():
             required_provider = getattr(field, 'required_if_provider', None)
             if required_provider and any(
-                required_provider == acquirer.provider and not acquirer[name]
-                for acquirer in enabled_acquirers
+                required_provider == provider.code and not provider[name]
+                for provider in enabled_providers
             ):
                 ir_field = self.env['ir.model.fields']._get(self._name, name)
                 field_names.append(ir_field.field_description)
@@ -329,16 +329,16 @@ class PaymentAcquirer(models.Model):
             )
 
     def _handle_state_change(self):
-        """ Archive all the payment tokens linked to these acquirers.
+        """ Archive all the payment tokens linked to these providers.
 
         :return: None
         """
-        self.env['payment.token'].search([('acquirer_id', 'in', self.ids)]).write({'active': False})
+        self.env['payment.token'].search([('provider_id', 'in', self.ids)]).write({'active': False})
 
     #=== ACTION METHODS ===#
 
     def button_immediate_install(self):
-        """ Install the acquirer's module and reload the page.
+        """ Install the provider's module and reload the page.
 
         Note: self.ensure_one()
 
@@ -353,40 +353,40 @@ class PaymentAcquirer(models.Model):
             }
 
     def action_toggle_is_published(self):
-        """ Toggle the acquirer's is_published state.
+        """ Toggle the provider's is_published state.
 
         :return: none
-        :raise UserError: If the acquirer is disabled.
+        :raise UserError: If the provider is disabled.
         """
         if self.state != 'disabled':
             self.is_published = not self.is_published
         else:
-            raise UserError(_("You cannot publish a disabled acquirer."))
+            raise UserError(_("You cannot publish a disabled provider."))
 
     #=== BUSINESS METHODS ===#
 
     @api.model
-    def _get_compatible_acquirers(
+    def _get_compatible_providers(
         self, company_id, partner_id, amount, currency_id=None, force_tokenization=False,
         is_express_checkout=False, is_validation=False, **kwargs
     ):
-        """ Select and return the acquirers matching the criteria.
+        """ Select and return the providers matching the criteria.
 
-        The base criteria are that acquirers must not be disabled, be in the company that is
+        The base criteria are that providers must not be disabled, be in the company that is
         provided, and support the country of the partner if it exists.
 
-        :param int company_id: The company to which acquirers must belong, as a `res.company` id
+        :param int company_id: The company to which providers must belong, as a `res.company` id
         :param int partner_id: The partner making the payment, as a `res.partner` id
         :param float amount: The amount to pay, `0` for validation transactions.
         :param int currency_id: The payment currency if known beforehand, as a `res.currency` id
-        :param bool force_tokenization: Whether only acquirers allowing tokenization can be matched
+        :param bool force_tokenization: Whether only providers allowing tokenization can be matched
         :param bool is_express_checkout: Whether the payment is made through express checkout.
         :param bool is_validation: Whether the operation is a validation
         :param dict kwargs: Optional data. This parameter is not used here
-        :return: The compatible acquirers
-        :rtype: recordset of `payment.acquirer`
+        :return: The compatible providers
+        :rtype: recordset of `payment.provider`
         """
-        # Compute the base domain for compatible acquirers
+        # Compute the base domain for compatible providers
         domain = ['&', ('state', 'in', ['enabled', 'test']), ('company_id', '=', company_id)]
 
         # Handle the is_published state.
@@ -427,8 +427,8 @@ class PaymentAcquirer(models.Model):
         if is_express_checkout:
             domain = expression.AND([domain, [('allow_express_checkout', '=', True)]])
 
-        compatible_acquirers = self.env['payment.acquirer'].search(domain)
-        return compatible_acquirers
+        compatible_providers = self.env['payment.provider'].search(domain)
+        return compatible_providers
 
     def _is_tokenization_required(self, **kwargs):
         """ Return whether tokenizing the transaction is required given its context.
@@ -445,7 +445,7 @@ class PaymentAcquirer(models.Model):
     def _should_build_inline_form(self, is_validation=False):
         """ Return whether the inline form should be instantiated if it exists.
 
-        For an acquirer to handle both direct payments and payment with redirection, it should
+        For a provider to handle both direct payments and payment with redirection, it should
         override this method and return whether the inline form should be instantiated (i.e. if the
         payment should be direct) based on the operation (online payment or validation).
 
@@ -465,7 +465,7 @@ class PaymentAcquirer(models.Model):
         of `fixed` and `variable` is taken either from the domestic (dom) or international (int)
         field depending on whether the country matches the company's country.
 
-        For an acquirer to base the computation on different variables, or to use a different
+        For a provider to base the computation on different variables, or to use a different
         formula, it must override this method and return the resulting fees as a float.
 
         :param float amount: The amount to pay for the transaction
@@ -490,7 +490,7 @@ class PaymentAcquirer(models.Model):
     def _get_validation_amount(self):
         """ Get the amount to transfer in a payment method validation operation.
 
-        For an acquirer to support tokenization, it must override this method and return the amount
+        For a provider to support tokenization, it must override this method and return the amount
         to be transferred in a payment method validation operation *if the validation amount is not
         null*.
 
@@ -505,7 +505,7 @@ class PaymentAcquirer(models.Model):
     def _get_validation_currency(self):
         """ Get the currency of the transfer in a payment method validation operation.
 
-        For an acquirer to support tokenization, it must override this method and return the
+        For a provider to support tokenization, it must override this method and return the
         currency to be used in a payment method validation operation *if the validation amount is
         not null*.
 
@@ -520,7 +520,7 @@ class PaymentAcquirer(models.Model):
     def _get_redirect_form_view(self, is_validation=False):
         """ Return the view of the template used to render the redirect form.
 
-        For an acquirer to return a different view depending on whether the operation is a
+        For a provider to return a different view depending on whether the operation is a
         validation, it must override this method and return the appropriate view.
 
         Note: self.ensure_one()
@@ -550,8 +550,8 @@ class PaymentAcquirer(models.Model):
         :param str provider_code: The code of the provider to setup.
         :return: None
         """
-        acquirers = self.search([('provider', '=', provider_code)])
-        acquirers.write({
+        providers = self.search([('provider', '=', provider_code)])
+        providers.write({
             'provider': 'none',
             'state': 'disabled',
         })
@@ -561,7 +561,7 @@ class PaymentAcquirer(models.Model):
         self.flush_model()
         self.invalidate_model()
         self.env.cr.execute("""
-            UPDATE payment_acquirer SET state = 'disabled'
+            UPDATE payment_provider SET state = 'disabled'
             WHERE state NOT IN ('test', 'disabled')
         """)
 
@@ -573,8 +573,8 @@ class PaymentAcquirer(models.Model):
         self.flush_model()
         self.invalidate_model()
         query = sql.SQL("""
-            UPDATE payment_acquirer
+            UPDATE payment_provider
             SET ({fields}) = ROW({vals})
-            WHERE provider = %s
+            WHERE code = %s
         """).format(fields=sql.SQL(','.join(fields)), vals=sql.SQL(', '.join(['NULL'] * len(fields))))
         self.env.cr.execute(query, (provider, ))

--- a/addons/payment/models/payment_token.py
+++ b/addons/payment/models/payment_token.py
@@ -11,18 +11,18 @@ class PaymentToken(models.Model):
     _order = 'partner_id, id desc'
     _description = 'Payment Token'
 
-    acquirer_id = fields.Many2one(
-        string="Acquirer Account", comodel_name='payment.acquirer', required=True)
-    provider = fields.Selection(related='acquirer_id.provider')
+    provider_id = fields.Many2one(
+        string="provider Account", comodel_name='payment.provider', required=True)
+    provider_code = fields.Selection(related='provider_id.code')
     payment_details = fields.Char(
         string="Payment Details", help="The clear part of the payment method's payment details.",
     )
     partner_id = fields.Many2one(string="Partner", comodel_name='res.partner', required=True)
     company_id = fields.Many2one(  # Indexed to speed-up ORM searches (from ir_rule or others)
-        related='acquirer_id.company_id', store=True, index=True)
-    acquirer_ref = fields.Char(
-        string="Acquirer Reference", help="The acquirer reference of the token of the transaction",
-        required=True)  # This is not the same thing as the acquirer reference of the transaction
+        related='provider_id.company_id', store=True, index=True)
+    provider_ref = fields.Char(
+        string="Provider Reference", help="The provider reference of the token of the transaction",
+        required=True)  # This is not the same thing as the provider reference of the transaction
     transaction_ids = fields.One2many(
         string="Payment Transactions", comodel_name='payment.transaction', inverse_name='token_id')
     verified = fields.Boolean(string="Verified")
@@ -33,27 +33,27 @@ class PaymentToken(models.Model):
     @api.model_create_multi
     def create(self, values_list):
         for values in values_list:
-            if 'acquirer_id' in values:
-                acquirer = self.env['payment.acquirer'].browse(values['acquirer_id'])
+            if 'provider_id' in values:
+                provider = self.env['payment.provider'].browse(values['provider_id'])
 
-                # Include acquirer-specific create values
-                values.update(self._get_specific_create_values(acquirer.provider, values))
+                # Include provider-specific create values
+                values.update(self._get_specific_create_values(provider.code, values))
             else:
                 pass  # Let psycopg warn about the missing required field
 
         return super().create(values_list)
 
     @api.model
-    def _get_specific_create_values(self, provider, values):
-        """ Complete the values of the `create` method with acquirer-specific values.
+    def _get_specific_create_values(self, provider_code, values):
+        """ Complete the values of the `create` method with provider-specific values.
 
-        For an acquirer to add its own create values, it must overwrite this method and return a
-        dict of values. Acquirer-specific values take precedence over those of the dict of generic
+        For a provider to add its own create values, it must overwrite this method and return a
+        dict of values. Provider-specific values take precedence over those of the dict of generic
         create values.
 
-        :param str provider: The provider of the acquirer managing the token
+        :param str provider_code: The code of the provider managing the token
         :param dict values: The original create values
-        :return: The dict of acquirer-specific create values
+        :return: The dict of provider-specific create values
         :rtype: dict
         """
         return dict()

--- a/addons/payment/models/payment_transaction.py
+++ b/addons/payment/models/payment_transaction.py
@@ -29,27 +29,27 @@ class PaymentTransaction(models.Model):
     def _lang_get(self):
         return self.env['res.lang'].get_installed()
 
-    acquirer_id = fields.Many2one(
-        string="Acquirer", comodel_name='payment.acquirer', readonly=True, required=True)
-    provider = fields.Selection(related='acquirer_id.provider')
+    provider_id = fields.Many2one(
+        string="Provider", comodel_name='payment.provider', readonly=True, required=True)
+    provider_code = fields.Selection(related='provider_id.code')
     company_id = fields.Many2one(  # Indexed to speed-up ORM searches (from ir_rule or others)
-        related='acquirer_id.company_id', store=True, index=True)
+        related='provider_id.company_id', store=True, index=True)
     reference = fields.Char(
         string="Reference", help="The internal reference of the transaction", readonly=True,
         required=True)  # Already has an index from the UNIQUE SQL constraint
-    acquirer_reference = fields.Char(
-        string="Acquirer Reference", help="The acquirer reference of the transaction",
-        readonly=True)  # This is not the same thing as the acquirer reference of the token
+    provider_reference = fields.Char(
+        string="Provider Reference", help="The provider reference of the transaction",
+        readonly=True)  # This is not the same thing as the provider reference of the token
     amount = fields.Monetary(
         string="Amount", currency_field='currency_id', readonly=True, required=True)
     currency_id = fields.Many2one(
         string="Currency", comodel_name='res.currency', readonly=True, required=True)
     fees = fields.Monetary(
         string="Fees", currency_field='currency_id',
-        help="The fees amount; set by the system as it depends on the acquirer", readonly=True)
+        help="The fees amount; set by the system as it depends on the provider", readonly=True)
     token_id = fields.Many2one(
         string="Payment Token", comodel_name='payment.token', readonly=True,
-        domain='[("acquirer_id", "=", "acquirer_id")]', ondelete='restrict')
+        domain='[("provider_id", "=", "provider_id")]', ondelete='restrict')
     state = fields.Selection(
         string="Status",
         selection=[('draft', "Draft"), ('pending', "Pending"), ('authorized', "Authorized"),
@@ -145,12 +145,12 @@ class PaymentTransaction(models.Model):
     def _check_state_authorized_supported(self):
         """ Check that authorization is supported for a transaction in the 'authorized' state. """
         illegal_authorize_state_txs = self.filtered(
-            lambda tx: tx.state == 'authorized' and not tx.acquirer_id.support_manual_capture
+            lambda tx: tx.state == 'authorized' and not tx.provider_id.support_manual_capture
         )
         if illegal_authorize_state_txs:
             raise ValidationError(_(
-                "Transaction authorization is not supported by the following payment acquirers: %s",
-                ', '.join(set(illegal_authorize_state_txs.mapped('acquirer_id.name')))
+                "Transaction authorization is not supported by the following payment providers: %s",
+                ', '.join(set(illegal_authorize_state_txs.mapped('provider_id.name')))
             ))
 
     @api.constrains('token_id')
@@ -164,10 +164,10 @@ class PaymentTransaction(models.Model):
     @api.model_create_multi
     def create(self, values_list):
         for values in values_list:
-            acquirer = self.env['payment.acquirer'].browse(values['acquirer_id'])
+            provider = self.env['payment.provider'].browse(values['provider_id'])
 
             if not values.get('reference'):
-                values['reference'] = self._compute_reference(acquirer.provider, **values)
+                values['reference'] = self._compute_reference(provider.code, **values)
 
             # Duplicate partner values
             partner = self.env['res.partner'].browse(values['partner_id'])
@@ -190,12 +190,12 @@ class PaymentTransaction(models.Model):
                 values['fees'] = 0
             else:
                 currency = self.env['res.currency'].browse(values.get('currency_id')).exists()
-                values['fees'] = acquirer._compute_fees(
+                values['fees'] = provider._compute_fees(
                     values.get('amount', 0), currency, partner.country_id,
                 )
 
-            # Include acquirer-specific create values
-            values.update(self._get_specific_create_values(acquirer.provider, values))
+            # Include provider-specific create values
+            values.update(self._get_specific_create_values(provider.code, values))
 
             # Generate the hash for the callback if one has be configured on the tx
             values['callback_hash'] = self._generate_callback_hash(
@@ -219,16 +219,16 @@ class PaymentTransaction(models.Model):
         return txs
 
     @api.model
-    def _get_specific_create_values(self, provider, values):
-        """ Complete the values of the `create` method with acquirer-specific values.
+    def _get_specific_create_values(self, provider_code, values):
+        """ Complete the values of the `create` method with provider-specific values.
 
-        For an acquirer to add its own create values, it must overwrite this method and return a
-        dict of values. Acquirer-specific values take precedence over those of the dict of generic
+        For a provider to add its own create values, it must overwrite this method and return a
+        dict of values. Provider-specific values take precedence over those of the dict of generic
         create values.
 
-        :param str provider: The provider of the acquirer that handled the transaction
+        :param str provider_code: The code of the provider that handled the transaction
         :param dict values: The original create values
-        :return: The dict of acquirer-specific create values
+        :return: The dict of provider-specific create values
         :rtype: dict
         """
         return dict()
@@ -268,7 +268,7 @@ class PaymentTransaction(models.Model):
 
         payment_utils.check_rights_on_recordset(self)
         for tx in self:
-            # In sudo mode because we need to be able to read on acquirer fields.
+            # In sudo mode because we need to be able to read on provider fields.
             tx.sudo()._send_capture_request()
 
     def action_void(self):
@@ -278,7 +278,7 @@ class PaymentTransaction(models.Model):
 
         payment_utils.check_rights_on_recordset(self)
         for tx in self:
-            # In sudo mode because we need to be able to read on acquirer fields.
+            # In sudo mode because we need to be able to read on provider fields.
             tx.sudo()._send_void_request()
 
     def action_refund(self, amount_to_refund=None):
@@ -296,7 +296,7 @@ class PaymentTransaction(models.Model):
     #=== BUSINESS METHODS - PAYMENT FLOW ===#
 
     @api.model
-    def _compute_reference(self, provider, prefix=None, separator='-', **kwargs):
+    def _compute_reference(self, provider_code, prefix=None, separator='-', **kwargs):
         """ Compute a unique reference for the transaction.
 
         The reference either corresponds to the prefix if no other transaction with that prefix
@@ -319,7 +319,7 @@ class PaymentTransaction(models.Model):
             the full reference will be 'INV1-INV2' (or similar) if no existing reference has the
             same prefix, or 'INV1-INV2-n' if n existing references have the same prefix.
 
-        :param str provider: The provider of the acquirer handling the transaction
+        :param str provider_code: The code of the provider handling the transaction
         :param str prefix: The custom prefix used to compute the full reference
         :param str separator: The custom separator used to separate the prefix from the suffix, and
                               passed to `_compute_reference_prefix` if it is called
@@ -333,7 +333,7 @@ class PaymentTransaction(models.Model):
             # Replace special characters by their ASCII alternative (é -> e ; ä -> a ; ...)
             prefix = unicodedata.normalize('NFKD', prefix).encode('ascii', 'ignore').decode('utf-8')
         if not prefix:  # Prefix not provided or voided above, compute it based on the kwargs
-            prefix = self.sudo()._compute_reference_prefix(provider, separator, **kwargs)
+            prefix = self.sudo()._compute_reference_prefix(provider_code, separator, **kwargs)
         if not prefix:  # Prefix not computed from the kwargs, fallback on time-based value
             prefix = payment_utils.singularize_reference_prefix()
 
@@ -372,12 +372,12 @@ class PaymentTransaction(models.Model):
         return reference
 
     @api.model
-    def _compute_reference_prefix(self, provider, separator, **values):
+    def _compute_reference_prefix(self, provider_code, separator, **values):
         """ Compute the reference prefix from the transaction values.
 
         Note: This method should be called in sudo mode to give access to documents (INV, SO, ...).
 
-        :param str provider: The provider of the acquirer handling the transaction
+        :param str provider_code: The code of the provider handling the transaction
         :param str separator: The custom separator used to separate data references
         :param dict values: The transaction values used to compute the reference prefix.
         :return: an empty string
@@ -409,13 +409,13 @@ class PaymentTransaction(models.Model):
 
         The returned dict contains the following entries:
             - tx_id: The transaction, as a `payment.transaction` id
-            - acquirer_id: The acquirer handling the transaction, as a `payment.acquirer` id
-            - provider: The provider of the acquirer
+            - provider_id: The provider handling the transaction, as a `payment.provider` id
+            - provider_code: The code of the provider
             - reference: The reference of the transaction
             - amount: The rounded amount of the transaction
             - currency_id: The currency of the transaction, as a res.currency id
             - partner_id: The partner making the transaction, as a res.partner id
-            - Additional acquirer-specific entries
+            - Additional provider-specific entries
 
         Note: self.ensure_one()
 
@@ -426,31 +426,31 @@ class PaymentTransaction(models.Model):
 
         processing_values = {
             'tx_id': self.id,
-            'acquirer_id': self.acquirer_id.id,
-            'provider': self.provider,
+            'provider_id': self.provider_id.id,
+            'provider_code': self.provider_code,
             'reference': self.reference,
             'amount': self.amount,
             'currency_id': self.currency_id.id,
             'partner_id': self.partner_id.id,
         }
 
-        # Complete generic processing values with acquirer-specific values
+        # Complete generic processing values with provider-specific values
         processing_values.update(self._get_specific_processing_values(processing_values))
         _logger.info(
-            "generic and acquirer-specific processing values for transaction with reference "
+            "generic and provider-specific processing values for transaction with reference "
             "%(ref)s:\n%(values)s",
             {'ref': self.reference, 'values': pprint.pformat(processing_values)},
         )
 
         # Render the html form for the redirect flow if available
         if self.operation in ('online_redirect', 'validation'):
-            redirect_form_view = self.acquirer_id._get_redirect_form_view(
+            redirect_form_view = self.provider_id._get_redirect_form_view(
                 is_validation=self.operation == 'validation'
             )
-            if redirect_form_view:  # Some acquirer don't need a redirect form
+            if redirect_form_view:  # Some provider don't need a redirect form
                 rendering_values = self._get_specific_rendering_values(processing_values)
                 _logger.info(
-                    "acquirer-specific rendering values for transaction with reference "
+                    "provider-specific rendering values for transaction with reference "
                     "%(ref)s:\n%(values)s",
                     {'ref': self.reference, 'values': pprint.pformat(rendering_values)},
                 )
@@ -460,36 +460,36 @@ class PaymentTransaction(models.Model):
         return processing_values
 
     def _get_specific_processing_values(self, processing_values):
-        """ Return a dict of acquirer-specific values used to process the transaction.
+        """ Return a dict of provider-specific values used to process the transaction.
 
-        For an acquirer to add its own processing values, it must overwrite this method and return a
-        dict of acquirer-specific values based on the generic values returned by this method.
-        Acquirer-specific values take precedence over those of the dict of generic processing
+        For a provider to add its own processing values, it must overwrite this method and return a
+        dict of provider-specific values based on the generic values returned by this method.
+        Provider-specific values take precedence over those of the dict of generic processing
         values.
 
         :param dict processing_values: The generic processing values of the transaction
-        :return: The dict of acquirer-specific processing values
+        :return: The dict of provider-specific processing values
         :rtype: dict
         """
         return dict()
 
     def _get_specific_rendering_values(self, processing_values):
-        """ Return a dict of acquirer-specific values used to render the redirect form.
+        """ Return a dict of provider-specific values used to render the redirect form.
 
-        For an acquirer to add its own rendering values, it must overwrite this method and return a
-        dict of acquirer-specific values based on the processing values (acquirer-specific
+        For a provider to add its own rendering values, it must overwrite this method and return a
+        dict of provider-specific values based on the processing values (provider-specific
         processing values included).
 
         :param dict processing_values: The processing values of the transaction
-        :return: The dict of acquirer-specific rendering values
+        :return: The dict of provider-specific rendering values
         :rtype: dict
         """
         return dict()
 
     def _send_payment_request(self):
-        """ Request the provider of the acquirer handling the transaction to execute the payment.
+        """ Request the provider handling the transaction to execute the payment.
 
-        For an acquirer to support tokenization, it must override this method and call it to log the
+        For a provider to support tokenization, it must override this method and call it to log the
         'sent' message, then request a money transfer to its provider.
 
         Note: self.ensure_one()
@@ -497,13 +497,13 @@ class PaymentTransaction(models.Model):
         :return: None
         """
         self.ensure_one()
-        self._ensure_acquirer_is_not_disabled()
+        self._ensure_provider_is_not_disabled()
         self._log_sent_message()
 
     def _send_refund_request(self, amount_to_refund=None, create_refund_transaction=True):
-        """ Request the provider of the acquirer handling the transaction to refund it.
+        """ Request the provider handling the transaction to refund it.
 
-        For an acquirer to support refunds, it must override this method and request a refund
+        For a provider to support refunds, it must override this method and request a refund
         to its provider.
 
         Note: self.ensure_one()
@@ -514,7 +514,7 @@ class PaymentTransaction(models.Model):
         :rtype: recordset of `payment.transaction`
         """
         self.ensure_one()
-        self._ensure_acquirer_is_not_disabled()
+        self._ensure_provider_is_not_disabled()
 
         if create_refund_transaction:
             refund_tx = self._create_refund_transaction(amount_to_refund=amount_to_refund)
@@ -534,8 +534,8 @@ class PaymentTransaction(models.Model):
         self.ensure_one()
 
         return self.create({
-            'acquirer_id': self.acquirer_id.id,
-            'reference': self._compute_reference(self.provider, prefix=f'R-{self.reference}'),
+            'provider_id': self.provider_id.id,
+            'reference': self._compute_reference(self.provider_code, prefix=f'R-{self.reference}'),
             'amount': -(amount_to_refund or self.amount),
             'currency_id': self.currency_id.id,
             'token_id': self.token_id.id,
@@ -546,9 +546,9 @@ class PaymentTransaction(models.Model):
         })
 
     def _send_capture_request(self):
-        """ Request the provider of the acquirer handling the transaction to capture it.
+        """ Request the provider handling the transaction to capture it.
 
-        For an acquirer to support authorization, it must override this method and request a capture
+        For a provider to support authorization, it must override this method and request a capture
         to its provider.
 
         Note: self.ensure_one()
@@ -556,12 +556,12 @@ class PaymentTransaction(models.Model):
         :return: None
         """
         self.ensure_one()
-        self._ensure_acquirer_is_not_disabled()
+        self._ensure_provider_is_not_disabled()
 
     def _send_void_request(self):
-        """ Request the provider of the acquirer handling the transaction to void it.
+        """ Request the provider handling the transaction to void it.
 
-        For an acquirer to support authorization, it must override this method and request the
+        For a provider to support authorization, it must override this method and request the
         transaction to be voided to its provider.
 
         Note: self.ensure_one()
@@ -569,40 +569,40 @@ class PaymentTransaction(models.Model):
         :return: None
         """
         self.ensure_one()
-        self._ensure_acquirer_is_not_disabled()
+        self._ensure_provider_is_not_disabled()
 
-    def _ensure_acquirer_is_not_disabled(self):
-        """ Ensure that the acquirer's state is not 'disabled' before sending a request to its
+    def _ensure_provider_is_not_disabled(self):
+        """ Ensure that the provider's state is not 'disabled' before sending a request to its
         provider.
 
         :return: None
-        :raise UserError: If the acquirer's state is 'disabled'.
+        :raise UserError: If the provider's state is 'disabled'.
         """
-        if self.acquirer_id.state == 'disabled':
+        if self.provider_id.state == 'disabled':
             raise UserError(_(
-                "Making a request to the provider is not possible because the acquirer is disabled."
+                "Making a request to the provider is not possible because the provider is disabled."
             ))
 
-    def _handle_notification_data(self, provider, notification_data):
+    def _handle_notification_data(self, provider_code, notification_data):
         """ Match the transaction with the notification data, update its state and return it.
 
-        :param str provider: The provider of the acquirer that handled the transaction
+        :param str provider_code: The code of the provider that handled the transaction
         :param dict notification_data: The notification data sent by the provider
         :return: The transaction
         :rtype: recordset of `payment.transaction`
         """
-        tx = self._get_tx_from_notification_data(provider, notification_data)
+        tx = self._get_tx_from_notification_data(provider_code, notification_data)
         tx._process_notification_data(notification_data)
         tx._execute_callback()
         return tx
 
-    def _get_tx_from_notification_data(self, provider, notification_data):
+    def _get_tx_from_notification_data(self, provider_code, notification_data):
         """ Find the transaction based on the notification data.
 
-        For an acquirer to handle transaction processing, it must overwrite this method and return
+        For a provider to handle transaction processing, it must overwrite this method and return
         the transaction matching the notification data.
 
-        :param str provider: The provider of the acquirer that handled the transaction
+        :param str provider_code: The code of the provider that handled the transaction
         :param dict notification_data: The notification data sent by the provider
         :return: The transaction if found
         :rtype: recordset of `payment.transaction`
@@ -610,12 +610,12 @@ class PaymentTransaction(models.Model):
         return self
 
     def _process_notification_data(self, notification_data):
-        """ Update the transaction state and the acquirer reference based on the notification data.
+        """ Update the transaction state and the provider reference based on the notification data.
 
         This method should normally never be called directly. The correct method to call upon
         receiving notification data is `_handle_notification_data`.
 
-        For an acquirer to handle transaction processing, it must overwrite this method and process
+        For a provider to handle transaction processing, it must overwrite this method and process
         the notification data.
 
         Note: self.ensure_one()
@@ -799,12 +799,12 @@ class PaymentTransaction(models.Model):
     def _get_post_processing_values(self):
         """ Return a dict of values used to display the status of the transaction.
 
-        For an acquirer to handle transaction status display, it must override this method and
-        return a dict of values. Acquirer-specific values take precedence over those of the dict of
+        For a provider to handle transaction status display, it must override this method and
+        return a dict of values. Provider-specific values take precedence over those of the dict of
         generic post-processing values.
 
         The returned dict contains the following entries:
-            - provider: The provider of the acquirer
+            - provider_code: The code of the provider
             - reference: The reference of the transaction
             - amount: The rounded amount of the transaction
             - currency_id: The currency of the transaction, as a res.currency id
@@ -812,7 +812,7 @@ class PaymentTransaction(models.Model):
             - state_message: The information message about the state
             - is_post_processed: Whether the transaction has already been post-processed
             - landing_route: The route the user is redirected to after the transaction
-            - Additional acquirer-specific entries
+            - Additional provider-specific entries
 
         Note: self.ensure_one()
 
@@ -822,7 +822,7 @@ class PaymentTransaction(models.Model):
         self.ensure_one()
 
         post_processing_values = {
-            'provider': self.provider,
+            'provider_code': self.provider_code,
             'reference': self.reference,
             'amount': self.amount,
             'currency_code': self.currency_id.name,
@@ -832,8 +832,8 @@ class PaymentTransaction(models.Model):
             'landing_route': self.landing_route,
         }
         _logger.debug(
-            "post-processing values of transaction with reference %s for acquirer with id %s:\n%s",
-            self.reference, self.acquirer_id.id, pprint.pformat(post_processing_values)
+            "post-processing values of transaction with reference %s for provider with id %s:\n%s",
+            self.reference, self.provider_id.id, pprint.pformat(post_processing_values)
         )  # DEBUG level because this can get spammy with transactions in non-final states
         return post_processing_values
 
@@ -904,7 +904,7 @@ class PaymentTransaction(models.Model):
     def _log_received_message(self):
         """ Log in the chatter of relevant documents that the transactions have been received.
 
-        A transaction is 'received' when a response is received from the provider of the acquirer
+        A transaction is 'received' when a response is received from the system of the provider
         handling the transaction.
 
         :return: None
@@ -941,30 +941,30 @@ class PaymentTransaction(models.Model):
         # Choose the message based on the payment flow
         if self.operation in ('online_redirect', 'online_direct'):
             message = _(
-                "A transaction with reference %(ref)s has been initiated (%(acq_name)s).",
-                ref=self.reference, acq_name=self.acquirer_id.name
+                "A transaction with reference %(ref)s has been initiated (%(provider_name)s).",
+                ref=self.reference, provider_name=self.provider_id.name
             )
         elif self.operation == 'refund':
             formatted_amount = format_amount(self.env, -self.amount, self.currency_id)
             message = _(
                 "A refund request of %(amount)s has been sent. The payment will be created soon. "
-                "Refund transaction reference: %(ref)s (%(acq_name)s).",
-                amount=formatted_amount, ref=self.reference, acq_name=self.acquirer_id.name
+                "Refund transaction reference: %(ref)s (%(provider_name)s).",
+                amount=formatted_amount, ref=self.reference, provider_name=self.provider_id.name
             )
         elif self.operation in ('online_token', 'offline'):
             message = _(
                 "A transaction with reference %(ref)s has been initiated using the payment method "
-                "%(token)s (%(acq_name)s).",
+                "%(token)s (%(provider_name)s).",
                 ref=self.reference,
                 token=self.token_id._build_display_name(),
-                acq_name=self.acquirer_id.name
+                provider_name=self.provider_id.name
             )
         else:  # 'validation'
             message = _(
                 "A transaction with reference %(ref)s has been initiated to save a new payment "
-                "method (%(acq_name)s)",
+                "method (%(provider_name)s)",
                 ref=self.reference,
-                acq_name=self.acquirer_id.name,
+                provider_name=self.provider_id.name,
             )
         return message
 
@@ -978,33 +978,39 @@ class PaymentTransaction(models.Model):
         formatted_amount = format_amount(self.env, self.amount, self.currency_id)
         if self.state == 'pending':
             message = _(
-                "The transaction with reference %(ref)s for %(amount)s is pending (%(acq_name)s).",
-                ref=self.reference, amount=formatted_amount, acq_name=self.acquirer_id.name
+                ("The transaction with reference %(ref)s for %(amount)s "
+                "is pending (%(provider_name)s)."),
+                ref=self.reference,
+                amount=formatted_amount,
+                provider_name=self.provider_id.name
             )
         elif self.state == 'authorized':
             message = _(
                 "The transaction with reference %(ref)s for %(amount)s has been authorized "
-                "(%(acq_name)s).", ref=self.reference, amount=formatted_amount,
-                acq_name=self.acquirer_id.name
+                "(%(provider_name)s).", ref=self.reference, amount=formatted_amount,
+                provider_name=self.provider_id.name
             )
         elif self.state == 'done':
             message = _(
                 "The transaction with reference %(ref)s for %(amount)s has been confirmed "
-                "(%(acq_name)s).", ref=self.reference, amount=formatted_amount,
-                acq_name=self.acquirer_id.name
+                "(%(provider_name)s).", ref=self.reference, amount=formatted_amount,
+                provider_name=self.provider_id.name
             )
         elif self.state == 'error':
             message = _(
                 "The transaction with reference %(ref)s for %(amount)s encountered an error"
-                " (%(acq_name)s).",
-                ref=self.reference, amount=formatted_amount, acq_name=self.acquirer_id.name
+                " (%(provider_name)s).",
+                ref=self.reference, amount=formatted_amount, provider_name=self.provider_id.name
             )
             if self.state_message:
                 message += "<br />" + _("Error: %s", self.state_message)
         else:
             message = _(
-                "The transaction with reference %(ref)s for %(amount)s is canceled (%(acq_name)s).",
-                ref=self.reference, amount=formatted_amount, acq_name=self.acquirer_id.name
+                ("The transaction with reference %(ref)s for %(amount)s is canceled "
+                "(%(provider_name)s)."),
+                ref=self.reference,
+                amount=formatted_amount,
+                provider_name=self.provider_id.name
             )
             if self.state_message:
                 message += "<br />" + _("Reason: %s", self.state_message)

--- a/addons/payment/models/res_company.py
+++ b/addons/payment/models/res_company.py
@@ -6,8 +6,8 @@ from odoo import api, fields, models
 class ResCompany(models.Model):
     _inherit = 'res.company'
 
-    payment_acquirer_onboarding_state = fields.Selection(
-        string="State of the onboarding payment acquirer step",
+    payment_provider_onboarding_state = fields.Selection(
+        string="State of the onboarding payment provider step",
         selection=[('not_done', "Not done"), ('just_done', "Just done"), ('done', "Done")],
         default='not_done')
     payment_onboarding_payment_method = fields.Selection(
@@ -20,7 +20,7 @@ class ResCompany(models.Model):
         ])
 
     def _run_payment_onboarding_step(self, menu_id):
-        """ Install the suggested payment modules and configure the acquirers.
+        """ Install the suggested payment modules and configure the providers.
 
         It's checked that the current company has a Chart of Account.
 
@@ -41,18 +41,18 @@ class ResCompany(models.Model):
         )
 
         # Configure Stripe
-        stripe_acquirer = new_env.ref('payment.payment_acquirer_stripe')
-        stripe_acquirer.journal_id = stripe_acquirer.journal_id or default_journal
-        if stripe_acquirer.state == 'disabled':  # The onboarding step has never been run
+        stripe_provider = new_env.ref('payment.payment_provider_stripe')
+        stripe_provider.journal_id = stripe_provider.journal_id or default_journal
+        if stripe_provider.state == 'disabled':  # The onboarding step has never been run
             # Configure PayPal
-            paypal_acquirer = new_env.ref('payment.payment_acquirer_paypal')
-            if not paypal_acquirer.paypal_email_account:
-                paypal_acquirer.paypal_email_account = new_env.user.email or new_env.company.email
-            if paypal_acquirer.state == 'disabled' and paypal_acquirer.paypal_email_account:
-                paypal_acquirer.state = 'enabled'
-            paypal_acquirer.journal_id = paypal_acquirer.journal_id or default_journal
+            paypal_provider = new_env.ref('payment.payment_provider_paypal')
+            if not paypal_provider.paypal_email_account:
+                paypal_provider.paypal_email_account = new_env.user.email or new_env.company.email
+            if paypal_provider.state == 'disabled' and paypal_provider.paypal_email_account:
+                paypal_provider.state = 'enabled'
+            paypal_provider.journal_id = paypal_provider.journal_id or default_journal
 
-        return stripe_acquirer.action_stripe_connect_account(menu_id=menu_id)
+        return stripe_provider.action_stripe_connect_account(menu_id=menu_id)
 
     def _install_modules(self, module_names):
         modules_sudo = self.env['ir.module.module'].sudo().search([('name', 'in', module_names)])
@@ -64,9 +64,9 @@ class ResCompany(models.Model):
 
         :return: None
         """
-        self.set_onboarding_step_done('payment_acquirer_onboarding_state')
+        self.set_onboarding_step_done('payment_provider_onboarding_state')
 
     def get_account_invoice_onboarding_steps_states_names(self):
         """ Override of account. """
         steps = super().get_account_invoice_onboarding_steps_states_names()
-        return steps + ['payment_acquirer_onboarding_state']
+        return steps + ['payment_provider_onboarding_state']
