PR: https://github.com/odoo/odoo/pull/164793

From: 31226b1a95242631a190d92e9ffb5ad97822bcbd
From: David Monnom (moda)
Date: 2024-05-27 11:48:27

Structural Changes: 5
Total Changes: 487

[REF] point_of_sale, pos_*: add related models in self order

*: pos_online_payment_self_order, pos_restaurant, pos_self_order,
pos_self_order_epson_printer, pos_self_order_sale, pos_self_order_stripe

Like in `point_of_sale` we introduce related_models in `pos_self_order`
to handle relation between models in the frontend.

This will allow to use the same frontend models in all pos related
models.

closes odoo/odoo#164793

Related: odoo/enterprise#62127
Signed-off-by: Joseph Caburnay (jcb) <jcb@odoo.com>

================================= pseudo patch: =================================

--- a/addons/pos_self_order/models/__init__.py
+++ b/addons/pos_self_order/models/__init__.py
@@ -11,3 +11,6 @@ from . import pos_self_order_custom_link
 from . import product_product
 from . import res_config_settings
 from . import pos_session
+from . import pos_load_mixin
+from . import account_tax
+from . import account_fiscal_position

--- a/None
+++ b/addons/pos_self_order/models/account_fiscal_position.py
@@ -0,0 +1,8 @@
+from odoo import models
+
+
+class AccountFiscalPosition(models.Model):
+    _inherit = 'account.fiscal.position'
+
+    def _load_pos_self_data(self, data):
+        return self._load_pos_data(data)

--- a/None
+++ b/addons/pos_self_order/models/account_tax.py
@@ -0,0 +1,24 @@
+from odoo import models
+
+
+class AccountTax(models.Model):
+    _inherit = 'account.tax'
+
+    def _load_pos_self_data(self, data):
+        domain = self._load_pos_self_data_domain(data)
+        tax_ids = self.search(domain)
+        taxes_list = []
+
+        for tax in tax_ids:
+            taxes_list.append(tax._prepare_dict_for_taxes_computation())
+
+        if data.get('pos.config') and len(data['pos.config']['data']) > 0:
+            product_fields = self.env['account.tax']._eval_taxes_computation_prepare_product_fields(taxes_list)
+            data['pos.config']['data'][0]['_product_default_values'] = self.env['account.tax']._eval_taxes_computation_prepare_product_default_values(
+                product_fields,
+            )
+
+        return {
+            'data': taxes_list,
+            'fields': self._load_pos_self_data_fields(data['pos.config']['data'][0]['id']),
+        }

--- a/addons/pos_self_order/models/pos_category.py
+++ b/addons/pos_self_order/models/pos_category.py
@@ -12,6 +12,12 @@ class PosCategory(models.Model):
     hour_until = fields.Float(string='Availability Until', default=24.0, help="The product will be available until this hour.")
     hour_after = fields.Float(string='Availability After', default=0.0, help="The product will be available after this hour.")
 
+    @api.model
+    def _load_pos_data_fields(self, config_id):
+        fields = super()._load_pos_data_fields(config_id)
+        fields += ['hour_until', 'hour_after']
+        return fields
+
     @api.constrains('hour_until', 'hour_after')
     def _check_hour(self):
         for category in self:

--- a/addons/pos_self_order/models/pos_config.py
+++ b/addons/pos_self_order/models/pos_config.py
@@ -1,15 +1,10 @@
-# -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
-
-import io
 import uuid
 import base64
 from os.path import join as opj
-from PIL import Image
 from typing import Optional, List, Dict
 from werkzeug.urls import url_quote
-from odoo.exceptions import UserError, ValidationError
-from odoo.tools import image_to_base64
+from odoo.exceptions import UserError, ValidationError, AccessError
 
 from odoo import api, fields, models, _, service
 from odoo.tools import file_open, split_every
@@ -18,16 +13,13 @@ from odoo.tools import file_open, split_every
 class PosConfig(models.Model):
     _inherit = "pos.config"
 
-    _ALLOWED_PAYMENT_METHODS = ['adyen', 'stripe']
-
     def _self_order_kiosk_default_languages(self):
         return self.env["res.lang"].get_installed()
 
     def _self_order_default_user(self):
         users = self.env["res.users"].search(['|', ('company_id', '=', self.env.company.id), ('company_id', '=', False)])
         for user in users:
-            if (user.sudo().has_group("point_of_sale.group_pos_user")
-                    or user.sudo().has_group("point_of_sale.group_pos_manager")):
+            if user.sudo().has_group("point_of_sale.group_pos_manager"):
                 return user
 
     status = fields.Selection(
@@ -127,11 +119,6 @@ class PosConfig(models.Model):
 
         return pos_config_ids
 
-    def _get_allowed_payment_methods(self):
-        if self.self_ordering_mode == 'kiosk':
-            return self.payment_method_ids.filtered(lambda p: p.use_payment_terminal in self._ALLOWED_PAYMENT_METHODS)
-        return []
-
     def write(self, vals):
         for record in self:
             if vals.get('self_ordering_mode') == 'kiosk' or (vals.get('pos_self_ordering_mode') == 'mobile' and vals.get('pos_self_ordering_service_mode') == 'counter'):
@@ -240,138 +227,38 @@ class PosConfig(models.Model):
             "target": "new",
         }
 
-    def _get_self_order_custom_links(self):
-        """
-        On the landing page of the app we can have a number of custom links
-        that are defined by the restaurant employee in the backend.
-        This function returns a list of dictionaries with the attributes of each link
-        that is available for the POS with id pos_config_id.
-        """
-        self.ensure_one()
-        return (
-            self.env["pos_self_order.custom_link"]
-            .search_read(
-                [
-                    "|",
-                    ("pos_config_ids", "in", [self.id]),
-                    ("pos_config_ids", "=", False),
-                ],
-                fields=["name", "url", "style"],
-                order="sequence",
-            )
-        )
-
-    def _get_available_products(self):
-        self.ensure_one()
-        combo_product_ids = self.env["product.product"].search([
-            ("detailed_type", "=", 'combo'),
-            *(
-                self.limit_categories
-                and self.iface_available_categ_ids
-                and [("pos_categ_ids", "in", self.iface_available_categ_ids.ids)]
-                or []
-            ),
-        ])
-        product_ids = combo_product_ids.combo_ids.combo_line_ids.product_id
-
-        available_product_ids = (
-            self.env["product.product"]
-            .search(
-                [
-                    ("id", "not in", product_ids.ids),
-                    ("available_in_pos", "=", True),
-                    ("self_order_available", "=", True),
-                    *(
-                        self.limit_categories
-                        and self.iface_available_categ_ids
-                        and [("pos_categ_ids", "in", self.iface_available_categ_ids.ids)]
-                        or []
-                    ),
-                ],
-            )
-        )
-
-        return product_ids + available_product_ids
-
-    def _get_kitchen_printer(self):
-        self.ensure_one()
-        printerData = {}
-        for printer in self.printer_ids:
-            printerData[printer.id] = {
-                "printer_type": printer.printer_type,
-                "proxy_ip": printer.proxy_ip,
-                "product_categories_ids": printer.product_categories_ids.ids,
+    def _load_self_data_models(self):
+        return ['pos.session', 'pos.order', 'pos.order.line', 'pos.payment', 'pos.payment.method', 'res.currency', 'pos.category', 'product.product', 'pos.combo', 'pos.combo.line',
+            'res.company', 'account.tax', 'pos.printer', 'res.country', 'product.pricelist', 'product.pricelist.item', 'account.fiscal.position', 'account.fiscal.position.tax',
+            'res.lang', 'product.attribute', 'product.attribute.custom.value', 'product.template.attribute.line', 'product.template.attribute.value',
+            'decimal.precision', 'uom.uom', 'pos.printer', 'pos_self_order.custom_link', 'restaurant.floor', 'restaurant.table']
+
+    def load_self_data(self):
+        # Init our first record, in case of self_order is pos_config
+        config_fields = self._load_pos_self_data_fields(self.id)
+        response = {
+            'pos.config': {
+                'data': self.env['pos.config'].search_read([('id', '=', self.id)], config_fields, load=False),
+                'fields': config_fields,
             }
-        return printerData
-
-    def _get_self_ordering_payment_methods_data(self, payment_methods):
-        excluded_fields = ['image']
-        payment_search_fields = self.env['pos.payment']._load_pos_data_fields(self.id)
-        filtered_fields = [field for field in payment_search_fields if field not in excluded_fields]
-        return payment_methods.read(filtered_fields)
-
-    def _get_self_ordering_data(self):
-        self.ensure_one()
-        payment_methods = self._get_self_ordering_payment_methods_data(self._get_allowed_payment_methods())
-        default_language = self.self_ordering_default_language_id.read(["code", "name", "iso_code", "flag_image_url"])
-
-        return {
-            "pos_config_id": self.id,
-            "pos_session": self.current_session_id.read(["id", "access_token"])[0] if self.current_session_id and self.current_session_id.state == 'opened' else False,
-            "has_paper": self.has_paper,
-            "company": {
-                **self.company_id.read(["name", "email", "website", "vat", "name", "phone", "point_of_sale_use_ticket_qr_code", "point_of_sale_ticket_unique_code"])[0],
-                "partner_id": [None, self.company_id.partner_id.contact_address],
-                "country": self.company_id.country_id.read(["vat_label"])[0],
-            },
-            "base_url": self.get_base_url(),
-            "custom_links": self._get_self_order_custom_links(),
-            "currency_id": self.currency_id.id,
-            "pos_payment_methods": payment_methods if self.self_ordering_mode == "kiosk" else [],
-            "currency_decimals": self.currency_id.decimal_places,
-            "pos_category": self._get_available_categories().read(["name", "sequence", "has_image", "hour_until", "hour_after", "parent_id"]),
-            "products": self._get_available_products()._get_self_order_data(self),
-            "combos": self._get_combos_data(),
-            "config": {
-                "iface_start_categ_id": self.iface_start_categ_id.id,
-                "iface_tax_included": self.iface_tax_included == "total",
-                "self_ordering_mode": self.self_ordering_mode,
-                "self_ordering_takeaway": self.self_ordering_takeaway,
-                "self_ordering_service_mode": self.self_ordering_service_mode,
-                "self_ordering_default_language_id": default_language[0] if default_language else [],
-                "self_ordering_available_language_ids":  self.self_ordering_available_language_ids.read(["code", "display_name", "iso_code", "flag_image_url"]),
-                "self_ordering_image_home_ids": self._get_self_ordering_attachment(self.self_ordering_image_home_ids),
-                "self_ordering_image_brand": self._get_self_ordering_image(self.self_ordering_image_brand),
-                "self_ordering_pay_after": self.self_ordering_pay_after,
-                "receipt_header": self.receipt_header,
-                "receipt_footer": self.receipt_footer,
-            },
-            "kitchen_printers": self._get_kitchen_printer(),
         }
+        self.env['pos.session']._load_pos_data_relations('pos.config', response)
+
+        # Classic data loading
+        for model in self._load_self_data_models():
+            try:
+                response[model] = self.env[model]._load_pos_self_data(response)
+                self.env['pos.session']._load_pos_data_relations(model, response)
+            except AccessError as e:
+                response[model] = {
+                    'data': [],
+                    'fields': self.env[model]._load_pos_self_data_fields(self.id),
+                    'error': e.args[0]
+                }
 
-    def _get_combos_data(self):
-        self.ensure_one()
-        combos = self.env["pos.combo"].search([])
-
-        return[{
-            'id': combo.id,
-            'name': combo.name,
-            'combo_line_ids': combo.combo_line_ids.read(['product_id', 'combo_price', 'lst_price', 'combo_id'])
-        } for combo in combos]
-
-
-    def _get_self_ordering_image(self, image):
-        image = Image.open(io.BytesIO(base64.b64decode(image))) if image else False
-        return image_to_base64(image, 'PNG').decode('utf-8') if image else False
+                self.env['pos.session']._load_pos_data_relations(model, response)
 
-    def _get_self_ordering_attachment(self, images):
-        encoded_images = []
-        for image in images:
-            encoded_images.append({
-                'id': image.id,
-                'data': image.sudo().datas.decode('utf-8'),
-            })
-        return encoded_images
+        return response
 
     def _split_qr_codes_list(self, floors: List[Dict], cols: int) -> List[Dict]:
         """
@@ -389,7 +276,7 @@ class PosConfig(models.Model):
 
     def _compute_self_ordering_url(self):
         for record in self:
-            record.self_ordering_url = self.get_base_url() + self._get_self_order_route()
+            record.self_ordering_url = record.get_base_url() + record._get_self_order_route()
 
     def action_close_kiosk_session(self):
         if self.current_session_id and self.current_session_id.order_ids:

--- a/None
+++ b/addons/pos_self_order/models/pos_load_mixin.py
@@ -0,0 +1,22 @@
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+from odoo import models, api
+
+
+class PosLoadMixin(models.AbstractModel):
+    _inherit = "pos.load.mixin"
+
+    @api.model
+    def _load_pos_self_data_domain(self, data):
+        return self._load_pos_data_domain(data)
+
+    @api.model
+    def _load_pos_self_data_fields(self, config_id):
+        return self._load_pos_data_fields(config_id)
+
+    def _load_pos_self_data(self, data):
+        domain = self._load_pos_self_data_domain(data)
+        fields = self._load_pos_self_data_fields(data['pos.config']['data'][0]['id'])
+        return {
+            'data': self.search_read(domain, fields, load=False),
+            'fields': fields,
+        }

--- a/addons/pos_self_order/models/pos_order.py
+++ b/addons/pos_self_order/models/pos_order.py
@@ -36,27 +36,9 @@ class PosOrder(models.Model):
 
     table_stand_number = fields.Char(string="Table Stand Number")
 
-    def _compute_tax_details(self):
-        self.ensure_one()
-        taxes = sum([line.tax_ids.with_company(self.company_id).compute_all(line.price_unit, quantity=line.qty, product=line.product_id)['taxes']
-               for line in self.lines], [])
-        tax_percetanges = {tax['id']: tax['amount'] for tax in self.env['account.tax'].search([]).read(['amount'])}
-        merged_tax_details = {}
-        for tax_obj in taxes:
-            tax_id = tax_obj['id']
-            if tax_id not in merged_tax_details:
-                merged_tax_details[tax_id] = {
-                    'tax': {
-                        'id': tax_id,
-                        'amount': tax_percetanges[tax_id]
-                    },
-                    'name': tax_obj['name'],
-                    'amount': 0.0,
-                    'base': 0.0,
-                }
-            merged_tax_details[tax_id]['amount'] += tax_obj['amount']
-            merged_tax_details[tax_id]['base'] += tax_obj['base']
-        return list(merged_tax_details.values())
+    @api.model
+    def _load_pos_self_data_domain(self, data):
+        return [('id', '=', False)]
 
     @api.model
     def sync_from_ui(self, orders):
@@ -84,56 +66,17 @@ class PosOrder(models.Model):
         order_ids = self.env['pos.order'].browse(server_ids)
         order_ids.state = 'cancel'
         self._send_notification(order_ids)
-
         return super().remove_from_ui(server_ids)
 
     def _send_notification(self, order_ids):
         for order in order_ids:
-            if order.access_token and order.state != 'draft':
-                order._notify('ORDER_STATE_CHANGED', {
-                    'access_token': order.access_token,
-                    'state': order.state
-                })
-            else:
-                order._notify('ORDER_CHANGED', {
-                    'order': order._export_for_self_order()
-                })
-
-    def _export_for_self_order(self) -> Dict:
-        self.ensure_one()
-
-        return {
-            "id": self.id,
-            "pos_config_id": self.config_id.id,
-            "takeaway": self.takeaway,
-            "pos_reference": self.pos_reference,
-            "access_token": self.access_token,
-            "table_stand_number": self.table_stand_number,
-            "state": self.state,
-            "date_order": str(self.date_order),
-            "amount_total": self.amount_total,
-            "amount_tax": self.amount_tax,
-            "lines": [
-                {
-                    "id": line.id,
-                    "price_subtotal": line.price_subtotal,
-                    "price_subtotal_incl": line.price_subtotal_incl,
-                    "product_id": line.product_id.id,
-                    "attribute_value_ids": line.attribute_value_ids.ids,
-                    "custom_attribute_value_ids": line.custom_attribute_value_ids.read(['id', 'name', 'custom_product_template_attribute_value_id', 'custom_value'], load=False),
-                    "uuid": line.uuid,
-                    "qty": line.qty,
-                    "customer_note": line.customer_note,
-                    "full_product_name": line.full_product_name,
-                }
-                for line in self.lines
-            ],
-            "payment_lines": [{
-                "name": payment.payment_method_id.name,
-                "amount": payment.amount
-            } for payment in self.payment_ids],
-            "tax_details": self._compute_tax_details(),
-        }
+            order._notify('ORDER_STATE_CHANGED', {
+                'pos.order': order.read(order._load_pos_self_data_fields(order.config_id.id), load=False),
+                'pos.order.line': order.lines.read(order._load_pos_self_data_fields(order.config_id.id), load=False),
+                'pos.payment': order.payment_ids.read(order.payment_ids._load_pos_data_fields(order.config_id.id), load=False),
+                'pos.payment.method': order.payment_ids.mapped('payment_method_id').read(self.env['pos.payment.method']._load_pos_data_fields(order.config_id.id), load=False),
+                'product.attribute.custom.value':  order.lines.custom_attribute_value_ids.read(order.lines.custom_attribute_value_ids._load_pos_data_fields(order.config_id.id), load=False),
+            })
 
     @api.model
     def get_standalone_self_order(self):

--- a/addons/pos_self_order/models/pos_payment_method.py
+++ b/addons/pos_self_order/models/pos_payment_method.py
@@ -1,4 +1,4 @@
-from odoo import models
+from odoo import models, api
 
 
 class PosPaymentMethod(models.Model):
@@ -7,3 +7,10 @@ class PosPaymentMethod(models.Model):
     # will be overridden.
     def _payment_request_from_kiosk(self, order):
         pass
+
+    @api.model
+    def _load_pos_self_data_domain(self, data):
+        if data['pos.config']['data'][0]['self_ordering_mode'] == 'kiosk':
+            return [('use_payment_terminal', 'in', ['adyen', 'stripe'])]
+        else:
+            [('id', '=', False)]

--- a/addons/pos_self_order/models/pos_restaurant.py
+++ b/addons/pos_self_order/models/pos_restaurant.py
@@ -17,14 +17,6 @@ class RestaurantTable(models.Model):
         default=lambda self: self._get_identifier(),
     )
 
-    def _get_self_order_data(self) -> Dict:
-        self.ensure_one()
-        return {
-            'name': self.name,
-            'identifier': self.identifier,
-            'floor_name': self.floor_id.name
-        }
-
     @staticmethod
     def _get_identifier():
         return uuid.uuid4().hex[:8]
@@ -34,3 +26,23 @@ class RestaurantTable(models.Model):
         tables = self.env["restaurant.table"].search([])
         for table in tables:
             table.identifier = self._get_identifier()
+
+    @api.model
+    def _load_pos_self_data_fields(self, config_id):
+        return ['name', 'identifier', 'floor_id']
+
+    @api.model
+    def _load_pos_self_data_domain(self, data):
+        return [('floor_id', 'in', [floor['id'] for floor in data['restaurant.floor']['data']])]
+
+
+class RestaurantFloor(models.Model):
+    _inherit = "restaurant.floor"
+
+    @api.model
+    def _load_pos_self_data_fields(self, config_id):
+        return ['name', 'table_ids']
+
+    @api.model
+    def _load_pos_self_data_domain(self, data):
+        return [('id', 'in', data['pos.config']['data'][0]['floor_ids'])]

--- a/addons/pos_self_order/models/pos_self_order_custom_link.py
+++ b/addons/pos_self_order/models/pos_self_order_custom_link.py
@@ -8,6 +8,7 @@ from markupsafe import escape
 
 class PosSelfOrderCustomLink(models.Model):
     _name = "pos_self_order.custom_link"
+    _inherit = "pos.load.mixin"
     _description = (
         "Custom links that the restaurant can configure to be displayed on the self order screen"
     )
@@ -37,6 +38,14 @@ class PosSelfOrderCustomLink(models.Model):
     link_html = fields.Html("Preview", compute="_compute_link_html", store=True, readonly=True)
     sequence = fields.Integer("Sequence", default=1)
 
+    @api.model
+    def _load_pos_self_data_domain(self, data):
+        return [('pos_config_ids', 'in', data['pos.config']['data'][0]['id'])]
+
+    @api.model
+    def _load_pos_self_data_fields(self, config_id):
+        return ['name', 'url', 'style', 'link_html', 'sequence']
+
     @api.depends("name", "style")
     def _compute_link_html(self):
         for link in self:

--- a/addons/pos_self_order/models/pos_session.py
+++ b/addons/pos_self_order/models/pos_session.py
@@ -29,6 +29,10 @@ class PosSession(models.Model):
 
         return sessions
 
+    @api.model
+    def _load_pos_self_data_domain(self, data):
+        return [('config_id', '=', data['pos.config']['data'][0]['id']), ('state', '=', 'opened')]
+
     def _load_pos_data(self, data):
         sessions = super()._load_pos_data(data)
         sessions['data'][0]['_self_ordering'] = (

--- a/addons/pos_self_order/models/product_product.py
+++ b/addons/pos_self_order/models/product_product.py
@@ -1,13 +1,7 @@
-# -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 from __future__ import annotations
-
-from typing import List, Dict, Optional
-
+from typing import List, Dict
 from odoo import api, models, fields
-from copy import deepcopy
-
-from odoo.addons.point_of_sale.models.pos_config import PosConfig
 
 
 class ProductTemplate(models.Model):
@@ -72,43 +66,6 @@ class ProductProduct(models.Model):
             if attributes_by_ptal_id.get(id) is not None
         ]
 
-    def _get_attributes(self, pos_config_sudo: PosConfig) -> List[Dict]:
-        self.ensure_one()
-
-        attributes = self.env.context.get("cached_attributes_by_ptal_id")
-
-        if attributes is None:
-            attributes = self.env["pos.session"]._get_attributes_by_ptal_id()
-            attributes = self._filter_applicable_attributes(attributes)
-        else:
-            # Performance trick to avoid unnecessary calls to _get_attributes_by_ptal_id()
-            # Needs to be deep-copied because attributes is potentially mutated
-            attributes = deepcopy(self._filter_applicable_attributes(attributes))
-
-        return self._add_price_info_to_attributes(
-            attributes,
-            pos_config_sudo,
-        )
-
-    def _add_price_info_to_attributes(
-        self, attributes: List[Dict], pos_config_sudo: PosConfig
-    ) -> List[Dict]:
-        """
-        Here we replace the price_extra of each attribute value with a price_extra
-        dictionary that includes the price with taxes included and the price with taxes excluded
-        """
-        self.ensure_one()
-        for attribute in attributes:
-            for value in attribute["values"]:
-                value.update(
-                    {
-                        "price_extra": self._get_price_info(
-                            pos_config_sudo, value.get("price_extra")
-                        )
-                    }
-                )
-        return attributes
-
     def _get_price_unit_after_fp(self, lst_price, currency, fiscal_position):
         self.ensure_one()
 
@@ -148,81 +105,6 @@ class ProductProduct(models.Model):
         else:
             return lst_price
 
-    # FIXME: this method should be verified about price computation (pricelist taxes....)
-    def _get_price_info(
-        self, pos_config: PosConfig, price: Optional[float] = None, qty: int = 1
-    ) -> Dict[str, float]:
-        self.ensure_one()
-        # if price == None it means that a price was not passed as a parameter, so we use the product's list price
-        # it could happen that a price was passed, but it was 0; in that case we want to use this 0 as the argument,
-        # and not the product's list price
-        if price is None:
-            price = pos_config.pricelist_id._get_product_price(
-                self, qty, currency=pos_config.currency_id
-            )
-
-        # Declare variables, will be the return values.
-        display_price_default = price
-        display_price_alternative = price
-
-        taxes_default = pos_config.default_fiscal_position_id.map_tax(self.taxes_id)
-        taxes_alternative = pos_config.takeaway_fp_id.map_tax(self.taxes_id)
-
-        price_unit_default = self._get_price_unit_after_fp(
-            price, pos_config.currency_id, pos_config.default_fiscal_position_id
-        )
-        price_unit_alternative = self._get_price_unit_after_fp(
-            price, pos_config.currency_id, pos_config.takeaway_fp_id
-        )
-
-        all_prices_default = taxes_default.compute_all(
-            price_unit_default, pos_config.currency_id, qty, product=self
-        )
-        all_prices_alternative = taxes_alternative.compute_all(
-            price_unit_alternative, pos_config.currency_id, qty, product=self
-        )
-
-        if self.combo_ids:
-            display_price_default = self.lst_price
-            display_price_alternative = self.lst_price
-        else:
-            if pos_config.iface_tax_included == 'total':
-                display_price_default = all_prices_default["total_included"]
-                display_price_alternative = all_prices_alternative["total_included"]
-            else:
-                display_price_default = all_prices_default["total_excluded"]
-                display_price_alternative = all_prices_alternative["total_excluded"]
-
-        return {
-            'display_price_default': display_price_default,
-            'display_price_alternative': display_price_alternative,
-        }
-
-    def _get_product_for_ui(self, pos_config):
-        self.ensure_one()
-        return {
-                "price_info": self._get_price_info(pos_config),
-                "has_image": bool(self.product_tmpl_id.image_128 or self.image_variant_128),
-                "attributes": self._get_attributes(pos_config),
-                "name": self._get_name(),
-                "id": self.id,
-                "description_self_order": self.description_self_order,
-                "pos_categ_ids": self.pos_categ_ids.read(["id", "name", "parent_id"]) or [{"id": 0, "name": "Uncategorised"}],
-                "pos_combo_ids": self.combo_ids.mapped("id") or False,
-                "is_pos_groupable": self.uom_id.is_pos_groupable,
-                "write_date": self.write_date.timestamp(),
-                "self_order_available": self.self_order_available,
-                "barcode": self.barcode,
-            }
-
-    def _get_self_order_data(self, pos_config: PosConfig) -> List[Dict]:
-        attributes_by_ptal_id = self.env["pos.session"]._get_attributes_by_ptal_id()
-        self = self.with_context(cached_attributes_by_ptal_id=attributes_by_ptal_id)
-        return [
-            product._get_product_for_ui(pos_config)
-            for product in self
-        ]
-
     def write(self, vals_list):
         res = super().write(vals_list)
         if 'self_order_available' in vals_list:
@@ -235,5 +117,5 @@ class ProductProduct(models.Model):
         for config in config_self:
             if config.current_session_id and config.access_token:
                 config._notify('PRODUCT_CHANGED', {
-                    'product': self._get_product_for_ui(config)
+                    'product.product': self.read(self._load_pos_self_data_fields(config.id), load=False)
                 })
