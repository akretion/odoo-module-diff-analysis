PR: https://github.com/odoo/odoo/pull/93135

From: 72c4972efd3f31bd86d100f160a530cc70400617
From: Julien Van Roy
Date: 2022-06-15 08:00:03

Structural Changes: 9
Total Changes: 2570

[ADD] {account_edi_ubl_cii,l10n_account_edi_ubl_cii_tests}: support common UBL and CII edi formats

This commit aims at unifying the UBL formats for invoices and credit notes.

Starting from the work of LAS, the module account_edi_ubl_cii contains the templates for UBL and CII,
and provides inheritance for UBL: UBL 2.0 < UBL 2.1 < UBL Bis 3.
It contains also the formats E-FFF, EHF3 (fully covered by Bis 3), NLCIUS, XRechnung (in UBL), Factur-x (the only one in CII).
All these formats are also improved to pass the ecosio validator and/or the country specific validator
(for Factur-x: the validator from the FNFE, and Chorus Pro).

Note that the xml files generated contain the pdf of the invoice/credit note encoded in base64.
An xml file alone imported in Odoo will thus automatically retrieve the pdf.

Before generating the xml files, we now also check a series of known constraints and possibly display
a warning on top of the move view if some are not enforced (the xml file is generated anyway but it might not be valid).

Tests were required: a new module was needed with dependency to the tested l10n: l10n_account_edi_ubl_cii_tests.
The prefix "l10n_" prevents runbot from launching the tests everytime.

The following modules are removed:
* account_edi_facturx
* account_edi_ubl
* account_edi_ubl_bis3
* l10n_no_edi
* l10n_nl_edi
* l10n_be_edi

Task: 2628093
See also: odoo/upgrade#3581

closes odoo/odoo#93135

Signed-off-by: Laurent Smet <las@odoo.com>

================================= pseudo patch: =================================

--- a/None
+++ b/addons/account_edi_ubl_cii/models/__init__.py
@@ -0,0 +1,12 @@
+# -*- coding: utf-8 -*-
+
+from . import account_edi_common
+from . import account_edi_format
+from . import account_edi_xml_cii_facturx
+from . import account_edi_xml_ubl_20
+from . import account_edi_xml_ubl_21
+from . import account_edi_xml_ubl_bis3
+from . import account_edi_xml_ubl_xrechnung
+from . import account_edi_xml_ubl_nlcius
+from . import account_edi_xml_ubl_efff
+from . import ir_actions_report

--- a/None
+++ b/addons/account_edi_ubl_cii/models/account_edi_common.py
@@ -0,0 +1,575 @@
+# -*- coding: utf-8 -*-
+
+from odoo import _, models
+from odoo.tools import float_repr
+from odoo.tests.common import Form
+from odoo.exceptions import UserError
+
+from zeep import Client
+
+# -------------------------------------------------------------------------
+# UNIT OF MEASURE
+# -------------------------------------------------------------------------
+UOM_TO_UNECE_CODE = {
+    'uom.product_uom_unit': 'C62',
+    'uom.product_uom_dozen': 'DZN',
+    'uom.product_uom_kgm': 'KGM',
+    'uom.product_uom_gram': 'GRM',
+    'uom.product_uom_day': 'DAY',
+    'uom.product_uom_hour': 'HUR',
+    'uom.product_uom_ton': 'TNE',
+    'uom.product_uom_meter': 'MTR',
+    'uom.product_uom_km': 'KTM',
+    'uom.product_uom_cm': 'CMT',
+    'uom.product_uom_litre': 'LTR',
+    'uom.product_uom_cubic_meter': 'MTQ',
+    'uom.product_uom_lb': 'LBR',
+    'uom.product_uom_oz': 'ONZ',
+    'uom.product_uom_inch': 'INH',
+    'uom.product_uom_foot': 'FOT',
+    'uom.product_uom_mile': 'SMI',
+    'uom.product_uom_floz': 'OZA',
+    'uom.product_uom_qt': 'QT',
+    'uom.product_uom_gal': 'GLL',
+    'uom.product_uom_cubic_inch': 'INQ',
+    'uom.product_uom_cubic_foot': 'FTQ',
+}
+
+# -------------------------------------------------------------------------
+# ELECTRONIC ADDRESS SCHEME (EAS), see https://docs.peppol.eu/poacc/billing/3.0/codelist/eas/
+# -------------------------------------------------------------------------
+COUNTRY_EAS = {
+    'HU': 9910,
+    'ES': 9920,
+    'AD': 9922,
+    'AL': 9923,
+    'BA': 9924,
+    'BE': 9925,
+    'BG': 9926,
+    'CH': 9927,
+    'CY': 9928,
+    'CZ': 9929,
+    'DE': 9930,
+    'EE': 9931,
+    'UK': 9932,
+    'GR': 9933,
+    'HR': 9934,
+    'IE': 9935,
+    'LI': 9936,
+    'LT': 9937,
+    'LU': 9938,
+    'LV': 9939,
+    'MC': 9940,
+    'ME': 9941,
+    'MK': 9942,
+    'MT': 9943,
+    'NL': 9944,
+    'PL': 9945,
+    'PT': 9946,
+    'RO': 9947,
+    'RS': 9948,
+    'SI': 9949,
+    'SK': 9950,
+    'SM': 9951,
+    'TR': 9952,
+    'VA': 9953,
+    'SE': 9955,
+    'FR': 9957,
+    'NO':'0192',
+}
+
+
+class AccountEdiCommon(models.AbstractModel):
+    _name = "account.edi.common"
+    _description = "Common functions for EDI documents: generate the data, the constraints, etc"
+
+    # -------------------------------------------------------------------------
+    # HELPERS
+    # -------------------------------------------------------------------------
+
+    def format_float(self, amount, precision_digits):
+        if amount is None:
+            return None
+        return float_repr(amount, precision_digits)
+
+    def _get_uom_unece_code(self, line):
+        """
+        list of codes: https://docs.peppol.eu/poacc/billing/3.0/codelist/UNECERec20/
+        or https://unece.org/fileadmin/DAM/cefact/recommendations/bkup_htm/add2c.htm (sorted by letter)
+        """
+        xmlid = line.product_uom_id.get_external_id()
+        if xmlid and line.product_uom_id.id in xmlid:
+            return UOM_TO_UNECE_CODE.get(xmlid[line.product_uom_id.id], 'C62')
+        return 'C62'
+
+    # -------------------------------------------------------------------------
+    # TAXES
+    # -------------------------------------------------------------------------
+
+    def _get_tax_unece_codes(self, invoice, tax):
+        """
+        Source: doc of Peppol (but the CEF norm is also used by factur-x, yet not detailed)
+        https://docs.peppol.eu/poacc/billing/3.0/syntax/ubl-invoice/cac-TaxTotal/cac-TaxSubtotal/cac-TaxCategory/cbc-TaxExemptionReasonCode/
+        https://docs.peppol.eu/poacc/billing/3.0/codelist/vatex/
+        https://docs.peppol.eu/poacc/billing/3.0/codelist/UNCL5305/
+        :returns: {
+            tax_category_code: str,
+            tax_exemption_reason_code: str,
+            tax_exemption_reason: str,
+        }
+        """
+        def create_dict(tax_category_code=None, tax_exemption_reason_code=None, tax_exemption_reason=None):
+            return {
+                'tax_category_code': tax_category_code,
+                'tax_exemption_reason_code': tax_exemption_reason_code,
+                'tax_exemption_reason': tax_exemption_reason,
+            }
+
+        supplier = invoice.company_id.partner_id.commercial_partner_id
+        customer = invoice.commercial_partner_id
+
+        # add Norway, Iceland, Liechtenstein
+        european_economic_area = self.env.ref('base.europe').country_ids.mapped('code') + ['NO', 'IS', 'LI']
+
+        if customer.country_id.code == 'ES':
+            if customer.zip[:2] in ('35', '38'):  # Canary
+                # [BR-IG-10]-A VAT breakdown (BG-23) with VAT Category code (BT-118) "IGIC" shall not have a VAT
+                # exemption reason code (BT-121) or VAT exemption reason text (BT-120).
+                return create_dict(tax_category_code='L')
+            if customer.zip[:2] in ('51', '52'):
+                return create_dict(tax_category_code='M')  # Ceuta & Mellila
+
+        # see: https://anskaffelser.dev/postaward/g3/spec/current/billing-3.0/norway/#_value_added_tax_norwegian_mva
+        if customer.country_id.code == 'NO':
+            if tax.amount == 25:
+                return create_dict(tax_category_code='S', tax_exemption_reason=_('Output VAT, regular rate'))
+            if tax.amount == 15:
+                return create_dict(tax_category_code='S', tax_exemption_reason=_('Output VAT, reduced rate, middle'))
+            if tax.amount == 11.11:
+                return create_dict(tax_category_code='S', tax_exemption_reason=_('Output VAT, reduced rate, raw fish'))
+            if tax.amount == 12:
+                return create_dict(tax_category_code='S', tax_exemption_reason=_('Output VAT, reduced rate, low'))
+
+        if supplier.country_id == customer.country_id:
+            if not tax or tax.amount == 0:
+                # in theory, you should indicate the precise law article
+                return create_dict(tax_category_code='E', tax_exemption_reason=_('Articles 226 items 11 to 15 Directive 2006/112/EN'))
+            else:
+                return create_dict(tax_category_code='S')  # standard VAT
+
+        if supplier.country_id.code in european_economic_area:
+            if tax.amount != 0:
+                # otherwise, the validator will complain because G and K code should be used with 0% tax
+                return create_dict(tax_category_code='S')
+            if customer.country_id.code not in european_economic_area:
+                return create_dict(
+                    tax_category_code='G',
+                    tax_exemption_reason_code='VATEX-EU-G',
+                    tax_exemption_reason=_('Export outside the EU'),
+                )
+            if customer.country_id.code in european_economic_area:
+                return create_dict(
+                    tax_category_code='K',
+                    tax_exemption_reason_code='VATEX-EU-IC',
+                    tax_exemption_reason=_('Intra-Community supply'),
+                )
+        return create_dict()
+
+    def _get_tax_category_list(self, invoice, taxes):
+        """ Full list: https://unece.org/fileadmin/DAM/trade/untdid/d16b/tred/tred5305.htm
+        Subset: https://docs.peppol.eu/poacc/billing/3.0/codelist/UNCL5305/
+
+        :param taxes:   account.tax records.
+        :return:        A list of values to fill the TaxCategory foreach template.
+        """
+        res = []
+        for tax in taxes:
+            tax_unece_codes = self._get_tax_unece_codes(invoice, tax)
+            res.append({
+                'id': tax_unece_codes.get('tax_category_code'),
+                'percent': tax.amount if tax.amount_type == 'percent' else False,
+                'name': tax_unece_codes.get('tax_exemption_reason'),
+                **tax_unece_codes,
+            })
+        return res
+
+    # -------------------------------------------------------------------------
+    # CONSTRAINTS
+    # -------------------------------------------------------------------------
+
+    def _check_required_fields(self, record, field_names, custom_warning_message=""):
+        """
+        This function check that a field exists on a record or dictionaries
+        returns a generic error message if it's not the case or a custom one if specified
+        """
+        if not record:
+            return custom_warning_message or _("The element %s is required on %s.", record, ', '.join(field_names))
+
+        if not isinstance(field_names, list):
+            field_names = [field_names]
+
+        has_values = any(record[field_name] for field_name in field_names)
+        # field is present
+        if has_values:
+            return
+
+        # field is not present
+        if custom_warning_message or isinstance(record, dict):
+            return custom_warning_message or _("The element %s is required on %s.", record, ', '.join(field_names))
+
+        display_field_names = record.fields_get(field_names)
+        if len(field_names) == 1:
+            display_field = f"'{display_field_names[field_names[0]]['string']}'"
+            return _("The field %s is required on %s.", display_field, record.display_name)
+        else:
+            display_fields = ', '.join(f"'{display_field_names[x]['string']}'" for x in display_field_names)
+            return _("At least one of the following fields %s is required on %s.", display_fields, record.display_name)
+
+    # -------------------------------------------------------------------------
+    # COMMON CONSTRAINTS
+    # -------------------------------------------------------------------------
+
+    def _invoice_constraints_common(self, invoice):
+        # check that there is a tax on each line
+        for line in invoice.invoice_line_ids.filtered(lambda x: not x.display_type):
+            if not line.tax_ids:
+                return {'tax_on_line': _("Each invoice line should have at least one tax.")}
+        return {}
+
+    # -------------------------------------------------------------------------
+    # Import invoice
+    # -------------------------------------------------------------------------
+
+    def _import_invoice(self, journal, filename, tree, existing_invoice=None):
+        move_type, qty_factor = self._get_import_document_amount_sign(filename, tree)
+        if not move_type or (existing_invoice and existing_invoice.move_type != move_type):
+            return
+
+        invoice = existing_invoice or self.env['account.move']
+        invoice_form = Form(invoice.with_context(
+            account_predictive_bills_disable_prediction=True,
+            default_move_type=move_type,
+            default_journal_id=journal.id,
+        ))
+        invoice_form, logs = self._import_fill_invoice_form(journal, tree, invoice_form, qty_factor)
+        invoice = invoice_form.save()
+        if invoice:
+            if logs:
+                body = _(
+                    "<strong>Format used to import the invoice: %s</strong> <p><li> %s </li></p>",
+                    str(self._description), "</li><li>".join(logs)
+                )
+            else:
+                body = _("<strong>Format used to import the invoice: %s</strong>", str(self._description))
+            invoice.with_context(no_new_invoice=True).message_post(body=body)
+
+        # === Import the embedded PDF in the xml if some are found ===
+
+        attachments = self.env['ir.attachment']
+        additional_docs = tree.findall('./{*}AdditionalDocumentReference')
+        for document in additional_docs:
+            attachment_name = document.find('{*}ID')
+            attachment_data = document.find('{*}Attachment/{*}EmbeddedDocumentBinaryObject')
+            if attachment_name is not None \
+                    and attachment_data is not None \
+                    and attachment_data.attrib.get('mimeCode') == 'application/pdf':
+                text = attachment_data.text
+                # Normalize the name of the file : some e-fff emitters put the full path of the file
+                # (Windows or Linux style) and/or the name of the xml instead of the pdf.
+                # Get only the filename with a pdf extension.
+                name = attachment_name.text.split('\\')[-1].split('/')[-1].split('.')[0] + '.pdf'
+                attachments |= self.env['ir.attachment'].create({
+                    'name': name,
+                    'res_id': invoice.id,
+                    'res_model': 'account.move',
+                    'datas': text + '=' * (len(text) % 3),  # Fix incorrect padding
+                    'type': 'binary',
+                    'mimetype': 'application/pdf',
+                })
+        if attachments:
+            invoice.with_context(no_new_invoice=True).message_post(attachment_ids=attachments.ids)
+
+        return invoice
+
+    def _import_fill_invoice_allowance_charge(self, tree, invoice_form, journal, qty_factor):
+        logs = []
+        if '{urn:oasis:names:specification:ubl:schema:xsd' in tree.tag:
+            is_ubl = True
+        elif '{urn:un:unece:uncefact:data:standard:' in tree.tag:
+            is_ubl = False
+        else:
+            return
+
+        xpath = './{*}AllowanceCharge' if is_ubl else './{*}SupplyChainTradeTransaction/{*}ApplicableHeaderTradeSettlement/{*}SpecifiedTradeAllowanceCharge'
+        allowance_charge_nodes = tree.findall(xpath)
+        for allow_el in allowance_charge_nodes:
+            with invoice_form.invoice_line_ids.new() as invoice_line_form:
+                invoice_line_form.sequence = 0  # be sure to put these lines above the 'real' invoice lines
+
+                charge_factor = -1  # factor is -1 for discount, 1 for charge
+                if is_ubl:
+                    charge_indicator_node = allow_el.find('./{*}ChargeIndicator')
+                else:
+                    charge_indicator_node = allow_el.find('./{*}ChargeIndicator/{*}Indicator')
+                if charge_indicator_node is not None:
+                    charge_factor = -1 if charge_indicator_node.text == 'false' else 1
+
+                name = ""
+                reason_code_node = allow_el.find('./{*}AllowanceChargeReasonCode' if is_ubl else './{*}ReasonCode')
+                if reason_code_node is not None:
+                    name += reason_code_node.text + " "
+                reason_node = allow_el.find('./{*}AllowanceChargeReason' if is_ubl else './{*}Reason')
+                if reason_node is not None:
+                    name += reason_node.text
+                invoice_line_form.name = name
+
+                amount_node = allow_el.find('./{*}Amount' if is_ubl else './{*}ActualAmount')
+                base_amount_node = allow_el.find('./{*}BaseAmount' if is_ubl else './{*}BasisAmount')
+                # Since there is no quantity associated for the allowance/charge on document level,
+                # if we have an invoice with negative amounts, the price was multiplied by -1 and not the quantity
+                # See the file in test_files: 'base-negative-inv-correction.xml' VS 'base-example.xml' for 'Insurance'
+                if base_amount_node is not None:
+                    invoice_line_form.price_unit = float(base_amount_node.text) * charge_factor * qty_factor
+                    percent_node = allow_el.find('./{*}MultiplierFactorNumeric' if is_ubl else './{*}CalculationPercent')
+                    if percent_node is not None:
+                        invoice_line_form.quantity = float(percent_node.text) / 100
+                elif amount_node is not None:
+                    invoice_line_form.price_unit = float(amount_node.text) * charge_factor * qty_factor
+
+                invoice_line_form.tax_ids.clear()  # clear the default taxes applied to the line
+                tax_xpath = './{*}TaxCategory/{*}Percent' if is_ubl else './{*}CategoryTradeTax/{*}RateApplicablePercent'
+                for tax_categ_percent_el in allow_el.findall(tax_xpath):
+                    tax = self.env['account.tax'].search([
+                        ('company_id', '=', journal.company_id.id),
+                        ('amount', '=', float(tax_categ_percent_el.text)),
+                        ('amount_type', '=', 'percent'),
+                        ('type_tax_use', '=', 'purchase'),
+                    ], limit=1)
+                    if tax:
+                        invoice_line_form.tax_ids.add(tax)
+                    else:
+                        logs.append(
+                            _("Could not retrieve the tax: %s %% for line '%s'.",
+                              float(tax_categ_percent_el.text),
+                              name)
+                        )
+        return logs
+
+    def _import_fill_invoice_down_payment(self, invoice_form, prepaid_node, qty_factor):
+        """
+        Creates a down payment line on the invoice at import if prepaid_node (TotalPrepaidAmount in CII,
+        PrepaidAmount in UBL) exists.
+        qty_factor -1 if the xml is labelled as an invoice but has negative amounts -> conversion into a credit note
+        needed, so we need this multiplier. Otherwise, qty_factor is 1.
+        """
+        if prepaid_node is not None and float(prepaid_node.text) != 0:
+            # create a section
+            with invoice_form.invoice_line_ids.new() as invoice_line_form:
+                invoice_line_form.sequence = 998
+                invoice_line_form.display_type = 'line_section'
+                invoice_line_form.name = _("Down Payments")
+                invoice_line_form.price_unit = 0
+                invoice_line_form.quantity = 0
+                invoice_line_form.account_id = self.env['account.account']
+            # create the line with the down payment
+            with invoice_form.invoice_line_ids.new() as invoice_line_form:
+                invoice_line_form.sequence = 999
+                invoice_line_form.name = _("Down Payment")
+                invoice_line_form.price_unit = float(prepaid_node.text)
+                invoice_line_form.quantity = qty_factor * -1
+                invoice_line_form.tax_ids.clear()
+
+    def _import_fill_invoice_line_values(self, tree, xpath_dict, invoice_line_form, qty_factor):
+        """
+        Read the xml invoice, extract the invoice line values, compute the odoo values
+        to fill an invoice line form: quantity, price_unit, discount, product_uom_id.
+
+        The way of computing invoice line is quite complicated:
+        https://docs.peppol.eu/poacc/billing/3.0/bis/#_calculation_on_line_level (same as in factur-x documentation)
+
+        line_net_subtotal = ( gross_unit_price - rebate ) * (billed_qty / basis_qty) - allow_charge_amount
+
+        with (UBL | CII):
+            * net_unit_price = 'Price/PriceAmount' | 'NetPriceProductTradePrice' (mandatory) (BT-146)
+            * gross_unit_price = 'GrossPriceProductTradePrice' | 'GrossPriceProductTradePrice' (optional) (BT-148)
+            * basis_qty = 'Price/BaseQuantity' | 'BasisQuantity' (optional, either below net_price node or
+                gross_price node) (BT-149)
+            * billed_qty = 'InvoicedQuantity' | 'BilledQuantity' (mandatory) (BT-129)
+            * allow_charge_amount = sum of 'AllowanceCharge' | 'SpecifiedTradeAllowanceCharge' (same level as Price)
+                ON THE LINE level (optional) (BT-136 / BT-141)
+            * line_net_subtotal = 'LineExtensionAmount' | 'LineTotalAmount' (mandatory) (BT-131)
+            * rebate = 'Price/AllowanceCharge' | 'AppliedTradeAllowanceCharge' below gross_price node ! (BT-147)
+                "item price discount" which is different from the usual allow_charge_amount
+                gross_unit_price (BT-148) - rebate (BT-147) = net_unit_price (BT-146)
+
+        In Odoo, we obtain:
+        (1) = price_unit  =  gross_price_unit / basis_qty  =  (net_price_unit + rebate) / basis_qty
+        (2) = quantity  =  billed_qty
+        (3) = discount (converted into a percentage)  =  100 * (1 - price_subtotal / (billed_qty * price_unit))
+        (4) = price_subtotal
+
+        Alternatively, we could also set: quantity = billed_qty/basis_qty
+
+        WARNING, the basis quantity parameter is annoying, for instance, an invoice with a line:
+            item A  | price per unit of measure/unit price: 30  | uom = 3 pieces | billed qty = 3 | rebate = 2  | untaxed total = 28
+        Indeed, 30 $ / 3 pieces = 10 $ / piece => 10 * 3 (billed quantity) - 2 (rebate) = 28
+
+        UBL ROUNDING: "the result of Item line net
+            amount = ((Item net price (BT-146)÷Item price base quantity (BT-149))×(Invoiced Quantity (BT-129))
+        must be rounded to two decimals, and the allowance/charge amounts are also rounded separately."
+        It is not possible to do it in Odoo.
+
+        :params tree
+        :params xpath_dict dict: {
+            'basis_qty': list of str,
+            'gross_price_unit': str,
+            'rebate': str,
+            'net_price_unit': str,
+            'billed_qty': str,
+            'allowance_charge': str, to be used in a findall !,
+            'allowance_charge_indicator': str, relative xpath from allowance_charge,
+            'allowance_charge_amount': str, relative xpath from allowance_charge,
+            'line_total_amount': str,
+        }
+        :params: invoice_line_form
+        :params: qty_factor
+        """
+        # basis_qty (optional)
+        basis_qty = 1
+        for xpath in xpath_dict['basis_qty']:
+            basis_quantity_node = tree.find(xpath)
+            if basis_quantity_node is not None:
+                basis_qty = float(basis_quantity_node.text)
+
+        # gross_price_unit (optional)
+        gross_price_unit = None
+        gross_price_unit_node = tree.find(xpath_dict['gross_price_unit'])
+        if gross_price_unit_node is not None:
+            gross_price_unit = float(gross_price_unit_node.text)
+
+        # rebate (optional)
+        # Discount. /!\ as no percent discount can be set on a line, need to infer the percentage
+        # from the amount of the actual amount of the discount (the allowance charge)
+        rebate = 0
+        rebate_node = tree.find(xpath_dict['rebate'])
+        net_price_unit_node = tree.find(xpath_dict['net_price_unit'])
+        if rebate_node is not None:
+            if net_price_unit_node is not None and gross_price_unit_node is not None:
+                rebate = float(gross_price_unit_node.text) - float(net_price_unit_node.text)
+            else:
+                rebate = float(rebate_node.text)
+
+        # net_price_unit (mandatory)
+        net_price_unit = None
+        if net_price_unit_node is not None:
+            net_price_unit = float(net_price_unit_node.text)
+
+        # billed_qty (mandatory)
+        billed_qty = 1
+        product_uom_id = None
+        quantity_node = tree.find(xpath_dict['billed_qty'])
+        if quantity_node is not None:
+            billed_qty = float(quantity_node.text)
+            uom_xml = quantity_node.attrib.get('unitCode')
+            if uom_xml:
+                uom_infered_xmlid = [
+                    odoo_xmlid for odoo_xmlid, uom_unece in UOM_TO_UNECE_CODE.items() if uom_unece == uom_xml
+                ]
+                if uom_infered_xmlid:
+                    product_uom_id = self.env.ref(uom_infered_xmlid[0], raise_if_not_found=False)
+
+        # allow_charge_amount
+        allow_charge_amount = 0  # if positive: it's a discount, if negative: it's a charge
+        allow_charge_nodes = tree.findall(xpath_dict['allowance_charge'])
+        for allow_charge_el in allow_charge_nodes:
+            charge_indicator = allow_charge_el.find(xpath_dict['allowance_charge_indicator'])
+            if charge_indicator.text and charge_indicator.text.lower() == 'false':
+                discount_factor = 1  # it's a discount
+            else:
+                discount_factor = -1  # it's a charge
+            amount = allow_charge_el.find(xpath_dict['allowance_charge_amount'])
+            if amount is not None:
+                allow_charge_amount += float(amount.text) * discount_factor
+
+        # line_net_subtotal (mandatory)
+        price_subtotal = None
+        line_total_amount_node = tree.find(xpath_dict['line_total_amount'])
+        if line_total_amount_node is not None:
+            price_subtotal = float(line_total_amount_node.text)
+
+        ####################################################
+        # Setting the values on the invoice_line_form
+        ####################################################
+
+        # quantity
+        invoice_line_form.quantity = billed_qty * qty_factor
+        if product_uom_id is not None:
+            invoice_line_form.product_uom_id = product_uom_id
+
+        # price_unit
+        if gross_price_unit is not None:
+            price_unit = gross_price_unit / basis_qty
+        elif net_price_unit is not None:
+            price_unit = (net_price_unit + rebate) / basis_qty
+        else:
+            raise UserError(_("No gross price nor net price found for line in xml"))
+        invoice_line_form.price_unit = price_unit
+
+        # discount
+        if billed_qty * price_unit != 0 and price_subtotal is not None:
+            invoice_line_form.discount = 100 * (1 - price_subtotal / (billed_qty * price_unit))
+
+        # Sometimes, the xml received is very bad: unit price = 0, qty = 1, but price_subtotal = -200
+        # for instance, when filling a down payment as an invoice line. The equation in the docstring is not
+        # respected, and the result will not be correct, so we just follow the simple rule below:
+        if net_price_unit == 0 and price_subtotal != net_price_unit * (billed_qty / basis_qty) - allow_charge_amount:
+            invoice_line_form.price_unit = price_subtotal / billed_qty
+
+    # -------------------------------------------------------------------------
+    # Check xml using the free API from Ph. Helger, don't abuse it !
+    # -------------------------------------------------------------------------
+
+    def _check_xml_ecosio(self, invoice, xml_content, ecosio_formats):
+        # see https://peppol.helger.com/public/locale-en_US/menuitem-validation-ws2
+        if not ecosio_formats:
+            return
+        soap_client = Client('https://peppol.helger.com/wsdvs?wsdl')
+        if invoice.move_type == 'out_invoice':
+            ecosio_format = ecosio_formats['invoice']
+        elif invoice.move_type == 'out_refund':
+            ecosio_format = ecosio_formats['credit_note']
+        else:
+            invoice.with_context(no_new_invoice=True).message_post(
+                body="ECOSIO: could not validate xml, formats only exist for invoice or credit notes"
+            )
+            return
+        if not ecosio_format:
+            return
+        response = soap_client.service.validate(xml_content, ecosio_format)
+
+        report = []
+        errors_cnt = 0
+        for item in response['Result']:
+            if item['artifactPath']:
+                report.append(
+                    "<li><font style='color:Blue;'><strong>" + item['artifactPath'] + "</strong></font></li>")
+            for detail in item['Item']:
+                if detail['errorLevel'] == 'WARN':
+                    errors_cnt += 1
+                    report.append(
+                        "<li><font style='color:Orange;'><strong>" + detail['errorText'] + "</strong></font></li>")
+                elif detail['errorLevel'] == 'ERROR':
+                    errors_cnt += 1
+                    report.append(
+                        "<li><font style='color:Tomato;'><strong>" + detail['errorText'] + "</strong></font></li>")
+
+        if errors_cnt == 0:
+            invoice.with_context(no_new_invoice=True).message_post(
+                body=f"<font style='color:Green;'><strong>ECOSIO: All clear for format {ecosio_format}!</strong></font>"
+            )
+        else:
+            invoice.with_context(no_new_invoice=True).message_post(
+                body=f"<font style='color:Tomato;'><strong>ECOSIO ERRORS/WARNINGS for format {ecosio_format}</strong></font>: <ul> "
+                     + "\n".join(report) + " </ul>"
+            )
+        return response

--- a/None
+++ b/addons/account_edi_ubl_cii/models/account_edi_format.py
@@ -0,0 +1,216 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from odoo import models, fields, _
+from odoo.tools import str2bool
+from odoo.addons.account_edi_ubl_cii.models.account_edi_common import COUNTRY_EAS
+
+import logging
+
+_logger = logging.getLogger(__name__)
+
+FORMAT_CODES = [
+    'facturx_1_0_05',
+    'ubl_bis3',
+    'ubl_de',
+    'nlcius_1',
+    'efff_1',
+    'ubl_2_1',
+]
+
+class AccountEdiFormat(models.Model):
+    _inherit = 'account.edi.format'
+
+    ####################################################
+    # Helpers
+    ####################################################
+
+    def _infer_xml_builder_from_tree(self, tree):
+        self.ensure_one()
+        ubl_version = tree.find('{*}UBLVersionID')
+        customization_id = tree.find('{*}CustomizationID')
+        if tree.tag == '{urn:un:unece:uncefact:data:standard:CrossIndustryInvoice:100}CrossIndustryInvoice':
+            return self.env['account.edi.xml.cii']
+        if customization_id is not None:
+            if 'xrechnung' in customization_id.text:
+                return self.env['account.edi.xml.ubl_de']
+            if customization_id.text == 'urn:cen.eu:en16931:2017#compliant#urn:fdc:peppol.eu:2017:poacc:billing:3.0':
+                return self.env['account.edi.xml.ubl_bis3']
+            if customization_id.text == 'urn:cen.eu:en16931:2017#compliant#urn:fdc:nen.nl:nlcius:v1.0':
+                return self.env['account.edi.xml.ubl_nl']
+        if ubl_version is not None:
+            if ubl_version.text == '2.0':
+                return self.env['account.edi.xml.ubl_20']
+            if ubl_version.text == '2.1':
+                return self.env['account.edi.xml.ubl_21']
+        return
+
+    def _get_xml_builder(self, company):
+        # see https://communaute.chorus-pro.gouv.fr/wp-content/uploads/2017/08/20170630_Solution-portail_Dossier_Specifications_Fournisseurs_Chorus_Facture_V.1.pdf
+        # page 45 -> ubl 2.1 for France seems also supported
+        if self.code == 'facturx_1_0_05':
+            return self.env['account.edi.xml.cii']
+        # if the company's country is not in the EAS mapping, nothing is generated
+        # 'NO' has to be present in COUNTRY_EAS
+        if self.code == 'ubl_bis3' and company.country_id.code in COUNTRY_EAS:
+            return self.env['account.edi.xml.ubl_bis3']
+        # the EDI option will only appear on the journal of dutch companies
+        if self.code == 'nlcius_1' and company.country_id.code == 'NL':
+            return self.env['account.edi.xml.ubl_nl']
+        # the EDI option will only appear on the journal of german companies
+        if self.code == 'ubl_de' and company.country_id.code == 'DE':
+            return self.env['account.edi.xml.ubl_de']
+        if self.code == 'efff_1' and company.country_id.code == 'BE':
+            return self.env['account.edi.xml.ubl_efff']
+
+    def _is_ubl_cii_available(self, company):
+        """
+        Returns a boolean indicating whether it is possible to generate an xml file using one of the formats from this
+        module or not
+        """
+        return self._get_xml_builder(company) is not None
+
+    ####################################################
+    # Export: Account.edi.format override
+    ####################################################
+
+    def _is_required_for_invoice(self, invoice):
+        # EXTENDS account_edi
+        self.ensure_one()
+        if self.code not in FORMAT_CODES:
+            return super()._is_required_for_invoice(invoice)
+
+        return self._is_ubl_cii_available(invoice.company_id) and invoice.move_type in ('out_invoice', 'out_refund')
+
+    def _is_compatible_with_journal(self, journal):
+        # EXTENDS account_edi
+        # the formats appear on the journal only if they are compatible (e.g. NLCIUS only appear for dutch companies)
+        self.ensure_one()
+        if self.code not in FORMAT_CODES:
+            return super()._is_compatible_with_journal(journal)
+        return self._is_ubl_cii_available(journal.company_id)
+
+    def _is_enabled_by_default_on_journal(self, journal):
+        # EXTENDS account_edi
+        # only facturx is enabled by default, the other formats aren't
+        self.ensure_one()
+        if self.code not in FORMAT_CODES:
+            return super()._is_enabled_by_default_on_journal(journal)
+        return self.code == 'facturx_1_0_05'
+
+    def _post_invoice_edi(self, invoices, test_mode=False):
+        # EXTENDS account_edi
+        self.ensure_one()
+
+        if self.code not in FORMAT_CODES:
+            return super()._post_invoice_edi(invoices)
+
+        res = {}
+        for invoice in invoices:
+            builder = self._get_xml_builder(invoice.company_id)
+            xml_content, errors = builder._export_invoice(invoice)
+
+            # DEBUG: send directly to the test platform (the one used by ecosio)
+            #response = self.env['account.edi.common']._check_xml_ecosio(invoice, xml_content, builder._export_invoice_ecosio_schematrons())
+
+            attachment_create_vals = {
+                'name': builder._export_invoice_filename(invoice),
+                'raw': xml_content,
+                'mimetype': 'application/xml',
+            }
+            # we don't want the Factur-X and E-FFF xml to appear in the attachment of the invoice when confirming it
+            # E-FFF will appear after the pdf is generated, Factur-X will never appear (it's contained in the PDF)
+            if self.code not in ['facturx_1_0_05', 'efff_1']:
+                attachment_create_vals.update({'res_id': invoice.id, 'res_model': 'account.move'})
+
+            attachment = self.env['ir.attachment'].create(attachment_create_vals)
+            res[invoice] = {
+                'success': True,
+                'attachment': attachment,
+            }
+            if errors:
+                res[invoice].update({
+                    'success': False,
+                    'error': _("Errors occured while creating the EDI document (format: %s). The receiver "
+                               "might refuse it.", builder._description)
+                             + '<p> <li>' + "</li> <li>".join(errors) + '</li> </p>',
+                    'blocking_level': 'info',
+                })
+
+        return res
+
+    def _is_embedding_to_invoice_pdf_needed(self):
+        # EXTENDS account_edi
+        self.ensure_one()
+
+        if self.code == 'facturx_1_0_05':
+            return True
+        return super()._is_embedding_to_invoice_pdf_needed()
+
+    def _prepare_invoice_report(self, pdf_writer, edi_document):
+        # EXTENDS account_edi
+        self.ensure_one()
+        if self.code != 'facturx_1_0_05':
+            return super()._prepare_invoice_report(pdf_writer, edi_document)
+        if not edi_document.attachment_id:
+            return
+
+        pdf_writer.embed_odoo_attachment(edi_document.attachment_id, subtype='text/xml')
+        if not pdf_writer.is_pdfa and str2bool(
+                self.env['ir.config_parameter'].sudo().get_param('edi.use_pdfa', 'False')):
+            try:
+                pdf_writer.convert_to_pdfa()
+            except Exception as e:
+                _logger.exception("Error while converting to PDF/A: %s", e)
+            metadata_template = self.env.ref('account_edi_ubl_cii.account_invoice_pdfa_3_facturx_metadata',
+                                             raise_if_not_found=False)
+            if metadata_template:
+                content = self.env['ir.qweb']._render('account_edi_ubl_cii.account_invoice_pdfa_3_facturx_metadata', {
+                    'title': edi_document.move_id.name,
+                    'date': fields.Date.context_today(self),
+                })
+                pdf_writer.add_file_metadata(content.encode())
+
+    ####################################################
+    # Import: Account.edi.format override
+    ####################################################
+
+    def _create_invoice_from_xml_tree(self, filename, tree, journal=None):
+        # EXTENDS account_edi
+        self.ensure_one()
+
+        if not journal:
+            # infer the journal
+            journal = self.env['account.journal'].search([
+                ('company_id', '=', self.env.company.id), ('type', '=', 'purchase')
+            ], limit=1)
+
+        if not self._is_ubl_cii_available(journal.company_id):
+            return super()._create_invoice_from_xml_tree(filename, tree, journal=journal)
+
+        # infer the xml builder
+        invoice_xml_builder = self._infer_xml_builder_from_tree(tree)
+
+        if invoice_xml_builder is not None:
+            invoice = invoice_xml_builder._import_invoice(journal, filename, tree)
+            if invoice:
+                return invoice
+
+        return super()._create_invoice_from_xml_tree(filename, tree, journal=journal)
+
+    def _update_invoice_from_xml_tree(self, filename, tree, invoice):
+        # EXTENDS account_edi
+        self.ensure_one()
+
+        if not self._is_ubl_cii_available(invoice.company_id):
+            return super()._update_invoice_from_xml_tree(filename, tree, invoice)
+
+        # infer the xml builder
+        invoice_xml_builder = self._infer_xml_builder_from_tree(tree)
+
+        if invoice_xml_builder is not None:
+            invoice = invoice_xml_builder._import_invoice(invoice.journal_id, filename, tree, invoice)
+            if invoice:
+                return invoice
+
+        return super()._update_invoice_from_xml_tree(filename, tree, invoice)

--- a/None
+++ b/addons/account_edi_ubl_cii/models/account_edi_xml_cii_facturx.py
@@ -0,0 +1,379 @@
+# -*- coding: utf-8 -*-
+from odoo import models, _
+from odoo.tools import DEFAULT_SERVER_DATE_FORMAT, float_repr, is_html_empty, html2plaintext, cleanup_xml_node
+from lxml import etree
+
+from datetime import datetime
+
+import logging
+
+_logger = logging.getLogger(__name__)
+
+DEFAULT_FACTURX_DATE_FORMAT = '%Y%m%d'
+
+
+class AccountEdiXmlCII(models.AbstractModel):
+    _name = "account.edi.xml.cii"
+    _inherit = 'account.edi.common'
+    _description = "Factur-x/XRechnung CII 2.2.0"
+
+    def _export_invoice_filename(self, invoice):
+        return "factur-x.xml"
+
+    def _export_invoice_ecosio_schematrons(self):
+        return {
+            'invoice': 'de.xrechnung:cii:2.2.0',
+            'credit_note': 'de.xrechnung:cii:2.2.0',
+        }
+
+    def _export_invoice_constraints(self, invoice, vals):
+        constraints = self._invoice_constraints_common(invoice)
+        constraints.update({
+            # [BR-08]-An Invoice shall contain the Seller postal address (BG-5).
+            # [BR-09]-The Seller postal address (BG-5) shall contain a Seller country code (BT-40).
+            'seller_postal_address': self._check_required_fields(
+                vals['record']['company_id']['partner_id']['commercial_partner_id'], 'country_id'
+            ),
+            # [BR-DE-9] The element "Buyer post code" (BT-53) must be transmitted. (only mandatory in Germany ?)
+            'buyer_postal_address': self._check_required_fields(
+                vals['record']['commercial_partner_id'], 'zip'
+            ),
+            # [BR-DE-4] The element "Seller post code" (BT-38) must be transmitted. (only mandatory in Germany ?)
+            'seller_post_code': self._check_required_fields(
+                vals['record']['company_id']['partner_id']['commercial_partner_id'], 'zip'
+            ),
+            # [BR-CO-26]-In order for the buyer to automatically identify a supplier, the Seller identifier (BT-29),
+            # the Seller legal registration identifier (BT-30) and/or the Seller VAT identifier (BT-31) shall be present.
+            'seller_identifier': self._check_required_fields(
+                vals['record']['company_id'], ['vat']  # 'siret'
+            ),
+            # [BR-DE-1] An Invoice must contain information on "PAYMENT INSTRUCTIONS" (BG-16)
+            # first check that a partner_bank_id exists, then check that there is an account number
+            'seller_payment_instructions_1': self._check_required_fields(
+                vals['record'], 'partner_bank_id'
+            ),
+            'seller_payment_instructions_2': self._check_required_fields(
+                vals['record']['partner_bank_id'], 'sanitized_acc_number',
+                _("The field 'Sanitized Account Number' is required on the Recipient Bank.")
+            ),
+            # [BR-DE-6] The element "Seller contact telephone number" (BT-42) must be transmitted.
+            'seller_phone': self._check_required_fields(
+                vals['record']['company_id']['partner_id']['commercial_partner_id'], ['phone', 'mobile'],
+            ),
+            # [BR-DE-7] The element "Seller contact email address" (BT-43) must be transmitted.
+            'seller_email': self._check_required_fields(
+                vals['record']['company_id'], 'email'
+            ),
+            # [BR-CO-04]-Each Invoice line (BG-25) shall be categorized with an Invoiced item VAT category code (BT-151).
+            'tax_invoice_line': self._check_required_tax(vals),
+            # [BR-IC-02]-An Invoice that contains an Invoice line (BG-25) where the Invoiced item VAT category code (BT-151)
+            # is "Intra-community supply" shall contain the Seller VAT Identifier (BT-31) or the Seller tax representative
+            # VAT identifier (BT-63) and the Buyer VAT identifier (BT-48).
+            'intracom_seller_vat': self._check_required_fields(vals['record']['company_id'], 'vat') if vals['intracom_delivery'] else None,
+            'intracom_buyer_vat': self._check_required_fields(vals['record']['commercial_partner_id'], 'vat') if vals['intracom_delivery'] else None,
+            # [BR-IG-05]-In an Invoice line (BG-25) where the Invoiced item VAT category code (BT-151) is "IGIC" the
+            # invoiced item VAT rate (BT-152) shall be greater than 0 (zero).
+            'igic_tax_rate': self._check_non_0_rate_tax(vals)
+                if vals['record']['commercial_partner_id']['country_id']['code'] == 'ES'
+                   and vals['record']['commercial_partner_id']['zip'][:2] in ['35', '38'] else None,
+        })
+        return constraints
+
+    def _check_required_tax(self, vals):
+        for line_vals in vals['invoice_line_vals_list']:
+            line = line_vals['line']
+            if not vals['tax_details']['invoice_line_tax_details'][line]['tax_details']:
+                return _("You should include at least one tax per invoice line. [BR-CO-04]-Each Invoice line (BG-25) "
+                         "shall be categorized with an Invoiced item VAT category code (BT-151).")
+
+    def _check_non_0_rate_tax(self, vals):
+        for line_vals in vals['invoice_line_vals_list']:
+            tax_rate_list = line_vals['line'].tax_ids.flatten_taxes_hierarchy().mapped("amount")
+            if not any([rate > 0 for rate in tax_rate_list]):
+                return _("When the Canary Island General Indirect Tax (IGIC) applies, the tax rate on "
+                         "each invoice line should be greater than 0.")
+
+    def _get_scheduled_delivery_time(self, invoice):
+        # don't create a bridge only to get line.sale_line_ids.order_id.picking_ids.date_done
+        # line.sale_line_ids.order_id.picking_ids.scheduled_date or line.sale_line_ids.order_id.commitment_date
+        return invoice.invoice_date
+
+    def _get_invoicing_period(self, invoice):
+        # get the Invoicing period (BG-14): a list of dates covered by the invoice
+        # don't create a bridge to get the date range from the timesheet_ids
+        return [invoice.invoice_date]
+
+    def _get_exchanged_document_vals(self, invoice):
+        return {
+            'id': invoice.name,
+            'type_code': '380' if invoice.move_type == 'out_invoice' else '381',
+            'issue_date_time': invoice.invoice_date,
+            'included_note': html2plaintext(invoice.narration) if invoice.narration else "",
+        }
+
+    def _export_invoice_vals(self, invoice):
+
+        def format_date(dt):
+            # Format the date in the Factur-x standard.
+            dt = dt or datetime.now()
+            return dt.strftime(DEFAULT_FACTURX_DATE_FORMAT)
+
+        def format_monetary(number, decimal_places=2):
+            # Facturx requires the monetary values to be rounded to 2 decimal values
+            return float_repr(number, decimal_places)
+
+        # Create file content.
+        tax_details = invoice._prepare_edi_tax_details(
+            grouping_key_generator=lambda tax_values: {
+                **self._get_tax_unece_codes(invoice, tax_values['tax_id']),
+                'amount': tax_values['tax_id'].amount,
+                'amount_type': tax_values['tax_id'].amount_type,
+            }
+        )
+
+        if 'siret' in invoice.company_id._fields and invoice.company_id.siret:
+            seller_siret = invoice.company_id.siret
+        else:
+            seller_siret = invoice.company_id.company_registry
+
+        buyer_siret = False
+        if 'siret' in invoice.commercial_partner_id._fields and invoice.commercial_partner_id.siret:
+            buyer_siret = invoice.commercial_partner_id.siret
+        template_values = {
+            **invoice._prepare_edi_vals_to_export(),
+            'tax_details': tax_details,
+            'format_date': format_date,
+            'format_monetary': format_monetary,
+            'is_html_empty': is_html_empty,
+            'scheduled_delivery_time': self._get_scheduled_delivery_time(invoice),
+            'intracom_delivery': False,
+            'ExchangedDocument_vals': self._get_exchanged_document_vals(invoice),
+            'seller_specified_legal_organization': seller_siret,
+            'buyer_specified_legal_organization': buyer_siret,
+            'ship_to_trade_party': invoice.partner_shipping_id if 'partner_shipping_id' in invoice._fields and invoice.partner_shipping_id
+                else invoice.commercial_partner_id,
+            # Chorus Pro fields
+            'buyer_reference': invoice.buyer_reference if 'buyer_reference' in invoice._fields else invoice.ref,
+            'purchase_order_reference': invoice.purchase_order_reference if 'purchase_order_reference' in invoice._fields
+                else invoice.payment_reference or invoice.name,
+            'contract_reference': invoice.contract_reference if 'contract_reference' in invoice._fields else '',
+        }
+
+        # data used for IncludedSupplyChainTradeLineItem / SpecifiedLineTradeSettlement
+        for line_vals in template_values['invoice_line_vals_list']:
+            line = line_vals['line']
+            line_vals['unece_uom_code'] = self._get_uom_unece_code(line)
+
+        # data used for ApplicableHeaderTradeSettlement / ApplicableTradeTax (at the end of the xml)
+        for tax_detail_vals in template_values['tax_details']['tax_details'].values():
+            # /!\ -0.0 == 0.0 in python but not in XSLT, so it can raise a fatal error when validating the XML
+            # if 0.0 is expected and -0.0 is given.
+            amount_currency = tax_detail_vals['tax_amount_currency']
+            tax_detail_vals['calculated_amount'] = template_values['balance_multiplicator'] * amount_currency \
+                if not invoice.currency_id.is_zero(amount_currency) else 0
+
+            if tax_detail_vals.get('tax_category_code') == 'K':
+                template_values['intracom_delivery'] = True
+            # [BR - IC - 11] - In an Invoice with a VAT breakdown (BG-23) where the VAT category code (BT-118) is
+            # "Intra-community supply" the Actual delivery date (BT-72) or the Invoicing period (BG-14) shall not be blank.
+            if tax_detail_vals.get('tax_category_code') == 'K' and not template_values['scheduled_delivery_time']:
+                date_range = self._get_invoicing_period(invoice)
+                template_values['billing_start'] = min(date_range)
+                template_values['billing_end'] = max(date_range)
+
+        # One of the difference between XRechnung and Facturx is the following. Submitting a Facturx to XRechnung
+        # validator raises a warning, but submitting a XRechnung to Facturx raises an error.
+        supplier = invoice.company_id.partner_id.commercial_partner_id
+        if supplier.country_id.code == 'DE':
+            template_values['document_context_id'] = "urn:cen.eu:en16931:2017#compliant#urn:xoev-de:kosit:standard:xrechnung_2.2"
+        else:
+            template_values['document_context_id'] = "urn:cen.eu:en16931:2017"
+
+        return template_values
+
+    def _export_invoice(self, invoice):
+        vals = self._export_invoice_vals(invoice)
+        errors = [constraint for constraint in self._export_invoice_constraints(invoice, vals).values() if constraint]
+        xml_content = self.env['ir.qweb']._render('account_edi_ubl_cii.account_invoice_facturx_export_22', vals)
+        return etree.tostring(cleanup_xml_node(xml_content)), set(errors)
+
+    # -------------------------------------------------------------------------
+    # IMPORT
+    # -------------------------------------------------------------------------
+
+    def _import_fill_invoice_form(self, journal, tree, invoice_form, qty_factor):
+
+        def _find_value(xpath, element=tree):
+            return self.env['account.edi.format']._find_value(xpath, element, tree.nsmap)
+
+        logs = []
+
+        if qty_factor == -1:
+            logs.append(_("The invoice has been converted into a credit note and the quantities have been reverted."))
+
+        # ==== partner_id ====
+
+        partner_type = invoice_form.journal_id.type == 'purchase' and 'SellerTradeParty' or 'BuyerTradeParty'
+        invoice_form.partner_id = self.env['account.edi.format']._retrieve_partner(
+            name=_find_value(f"//ram:{partner_type}/ram:Name"),
+            mail=_find_value(f"//ram:{partner_type}//ram:URIID[@schemeID='SMTP']"),
+            vat=_find_value(f"//ram:{partner_type}/ram:SpecifiedTaxRegistration/ram:ID"),
+        )
+        if not invoice_form.partner_id:
+            logs.append(_("Could not retrieve the vendor."))
+
+        # ==== currency_id ====
+
+        currency_code_node = tree.find('.//{*}InvoiceCurrencyCode')
+        if currency_code_node is not None:
+            currency = self.env['res.currency'].with_context(active_test=False).search([
+                ('name', '=', currency_code_node.text),
+            ], limit=1)
+            if currency:
+                if not currency.active:
+                    logs.append(_("The currency '%s' is not active.", currency.name))
+                invoice_form.currency_id = currency
+            else:
+                logs.append(_("Could not retrieve currency: %s. Did you enable the multicurrency option and "
+                              "activate the currency ?", currency_code_node.text))
+
+        # ==== Reference ====
+
+        ref_node = tree.find('./{*}ExchangedDocument/{*}ID')
+        if ref_node is not None:
+            invoice_form.ref = ref_node.text
+
+        # === Note/narration ====
+
+        narration = ""
+        note_node = tree.find('./{*}ExchangedDocument/{*}IncludedNote/{*}Content')
+        if note_node is not None:
+            narration += note_node.text + "\n"
+
+        payment_terms_node = tree.find('.//{*}SpecifiedTradePaymentTerms/{*}Description')
+        if payment_terms_node is not None:
+            narration += payment_terms_node.text + "\n"
+
+        invoice_form.narration = narration
+
+        # ==== payment_reference ====
+
+        payment_reference_node = tree.find('.//{*}BuyerOrderReferencedDocument/{*}IssuerAssignedID')
+        if payment_reference_node is not None:
+            invoice_form.payment_reference = payment_reference_node.text
+
+        # ==== invoice_date ====
+
+        invoice_date_node = tree.find('./{*}ExchangedDocument/{*}IssueDateTime/{*}DateTimeString')
+        if invoice_date_node is not None:
+            date_str = invoice_date_node.text
+            date_obj = datetime.strptime(date_str, DEFAULT_FACTURX_DATE_FORMAT)
+            invoice_form.invoice_date = date_obj.strftime(DEFAULT_SERVER_DATE_FORMAT)
+
+        # ==== invoice_date_due ====
+
+        invoice_date_due_node = tree.find('.//{*}SpecifiedTradePaymentTerms/{*}DueDateDateTime/{*}DateTimeString')
+        if invoice_date_due_node is not None:
+            date_str = invoice_date_due_node.text
+            date_obj = datetime.strptime(date_str, DEFAULT_FACTURX_DATE_FORMAT)
+            invoice_form.invoice_date_due = date_obj.strftime(DEFAULT_SERVER_DATE_FORMAT)
+
+        # ==== invoice_line_ids: AllowanceCharge (document level) ====
+
+        logs += self._import_fill_invoice_allowance_charge(tree, invoice_form, journal, qty_factor)
+
+        # ==== Down Payment (prepaid amount) ====
+
+        prepaid_node = tree.find('.//{*}ApplicableHeaderTradeSettlement/'
+                                 '{*}SpecifiedTradeSettlementHeaderMonetarySummation/{*}TotalPrepaidAmount')
+        self._import_fill_invoice_down_payment(invoice_form, prepaid_node, qty_factor)
+
+        # ==== invoice_line_ids ====
+
+        line_nodes = tree.findall('./{*}SupplyChainTradeTransaction/{*}IncludedSupplyChainTradeLineItem')
+        if line_nodes is not None:
+            for i, invl_el in enumerate(line_nodes):
+                with invoice_form.invoice_line_ids.new() as invoice_line_form:
+                    invoice_line_form.sequence = i
+                    invl_logs = self._import_fill_invoice_line_form(journal, invl_el, invoice_form, invoice_line_form, qty_factor)
+                    logs += invl_logs
+
+        return invoice_form, logs
+
+    def _import_fill_invoice_line_form(self, journal, tree, invoice_form, invoice_line_form, qty_factor):
+        logs = []
+
+        def _find_value(xpath, element=tree):
+            return self.env['account.edi.format']._find_value(xpath, element, tree.nsmap)
+
+        # Product.
+        name = _find_value('.//ram:SpecifiedTradeProduct/ram:Name', tree)
+        if name:
+            invoice_line_form.name = name
+        invoice_line_form.product_id = self.env['account.edi.format']._retrieve_product(
+            default_code=_find_value('.//ram:SpecifiedTradeProduct/ram:SellerAssignedID', tree),
+            name=_find_value('.//ram:SpecifiedTradeProduct/ram:Name', tree),
+            barcode=_find_value('.//ram:SpecifiedTradeProduct/ram:GlobalID', tree)
+        )
+
+        xpath_dict = {
+            'basis_qty': [
+                './{*}SpecifiedLineTradeAgreement/{*}GrossPriceProductTradePrice/{*}BasisQuantity',
+                './{*}SpecifiedLineTradeAgreement/{*}NetPriceProductTradePrice/{*}BasisQuantity'
+            ],
+            'gross_price_unit': './{*}SpecifiedLineTradeAgreement/{*}GrossPriceProductTradePrice/{*}ChargeAmount',
+            'rebate': './{*}SpecifiedLineTradeAgreement/{*}GrossPriceProductTradePrice/{*}AppliedTradeAllowanceCharge/{*}ActualAmount',
+            'net_price_unit': './{*}SpecifiedLineTradeAgreement/{*}NetPriceProductTradePrice/{*}ChargeAmount',
+            'billed_qty': './{*}SpecifiedLineTradeDelivery/{*}BilledQuantity',
+            'allowance_charge': './/{*}SpecifiedLineTradeSettlement/{*}SpecifiedTradeAllowanceCharge',
+            'allowance_charge_indicator': './{*}ChargeIndicator/{*}Indicator',  # below allowance_charge node
+            'allowance_charge_amount': './{*}ActualAmount',  # below allowance_charge node
+            'line_total_amount': './{*}SpecifiedLineTradeSettlement/{*}SpecifiedTradeSettlementLineMonetarySummation/{*}LineTotalAmount',
+        }
+        self._import_fill_invoice_line_values(tree, xpath_dict, invoice_line_form, qty_factor)
+
+        if not invoice_line_form.product_uom_id:
+            logs.append(
+                _("Could not retrieve the unit of measure for line with label '%s'. Did you install the inventory "
+                  "app and enabled the 'Units of Measure' option ?", invoice_line_form.name))
+
+        # Taxes
+        taxes = []
+        tax_nodes = tree.findall('.//{*}ApplicableTradeTax/{*}RateApplicablePercent')
+        for tax_node in tax_nodes:
+            tax = self.env['account.tax'].search([
+                ('company_id', '=', journal.company_id.id),
+                ('amount', '=', float(tax_node.text)),
+                ('amount_type', '=', 'percent'),
+                ('type_tax_use', '=', 'purchase'),
+            ], limit=1)
+            if tax:
+                taxes.append(tax)
+            else:
+                logs.append(_("Could not retrieve the tax: %s %% for line '%s'.", float(tax_node.text), invoice_line_form.name))
+
+        invoice_line_form.tax_ids.clear()
+        for tax in taxes:
+            invoice_line_form.tax_ids.add(tax)
+        return logs
+
+    # -------------------------------------------------------------------------
+    # IMPORT : helpers
+    # -------------------------------------------------------------------------
+
+    def _get_import_document_amount_sign(self, filename, tree):
+        """
+        In factur-x, an invoice has code 380 and a credit note has code 381. However, a credit note can be expressed
+        as an invoice with negative amounts. For this case, we need a factor to take the opposite of each quantity
+        in the invoice.
+        """
+        move_type_code = tree.find('.//{*}ExchangedDocument/{*}TypeCode')
+        if move_type_code is None:
+            return None, None
+        if move_type_code.text == '381':
+            return 'in_refund', 1
+        if move_type_code.text == '380':
+            amount_node = tree.find('.//{*}SpecifiedTradeSettlementHeaderMonetarySummation/{*}TaxBasisTotalAmount')
+            if amount_node is not None and float(amount_node.text) < 0:
+                return 'in_refund', -1
+            return 'in_invoice', 1

--- a/None
+++ b/addons/account_edi_ubl_cii/models/account_edi_xml_ubl_20.py
@@ -0,0 +1,706 @@
+# -*- coding: utf-8 -*-
+
+from odoo import models, _
+from odoo.osv import expression
+from odoo.tools import html2plaintext, cleanup_xml_node
+from lxml import etree
+
+
+class AccountEdiXmlUBL20(models.AbstractModel):
+    _name = "account.edi.xml.ubl_20"
+    _inherit = 'account.edi.common'
+    _description = "UBL 2.0"
+
+    # -------------------------------------------------------------------------
+    # EXPORT
+    # -------------------------------------------------------------------------
+
+    def _export_invoice_filename(self, invoice):
+        return f"{invoice.name.replace('/', '_')}_ubl_20.xml"
+
+    def _export_invoice_ecosio_schematrons(self):
+        return {
+            'invoice': 'org.oasis-open:invoice:2.0',
+            'credit_note': 'org.oasis-open:creditnote:2.0',
+        }
+
+    def _get_country_vals(self, country):
+        return {
+            'country': country,
+
+            'identification_code': country.code,
+            'name': country.name,
+        }
+
+    def _get_partner_party_identification_vals_list(self, partner):
+        return []
+
+    def _get_partner_address_vals(self, partner):
+        return {
+            'street_name': partner.street,
+            'additional_street_name': partner.street2,
+            'city_name': partner.city,
+            'postal_zone': partner.zip,
+            'country_subentity': partner.state_id.name,
+            'country_subentity_code': partner.state_id.code,
+            'country_vals': self._get_country_vals(partner.country_id),
+        }
+
+    def _get_partner_party_tax_scheme_vals_list(self, partner, role):
+        return [{
+            'registration_name': partner.name,
+            'company_id': partner.vat,
+            'registration_address_vals': self._get_partner_address_vals(partner),
+            'TaxScheme_vals': {},
+            'tax_scheme_id': 'VAT',
+        }]
+
+    def _get_partner_party_legal_entity_vals_list(self, partner):
+        commercial_partner = partner.commercial_partner_id
+
+        return [{
+            'commercial_partner': commercial_partner,
+
+            'registration_name': commercial_partner.name,
+            'company_id': commercial_partner.vat,
+            'registration_address_vals': self._get_partner_address_vals(commercial_partner),
+        }]
+
+    def _get_partner_contact_vals(self, partner):
+        return {
+            'id': partner.id,
+            'name': partner.name,
+            'telephone': partner.phone or partner.mobile,
+            'electronic_mail': partner.email,
+        }
+
+    def _get_partner_party_vals(self, partner, role):
+        return {
+            'partner': partner,
+            'party_identification_vals': self._get_partner_party_identification_vals_list(partner),
+            'party_name_vals': [{'name': partner.name}],
+            'postal_address_vals': self._get_partner_address_vals(partner),
+            'party_tax_scheme_vals': self._get_partner_party_tax_scheme_vals_list(partner, role),
+            'party_legal_entity_vals': self._get_partner_party_legal_entity_vals_list(partner),
+            'contact_vals': self._get_partner_contact_vals(partner),
+        }
+
+    def _get_invoice_period_vals_list(self, invoice):
+        """
+        For now, we cannot fill this data from an invoice
+        This corresponds to the 'delivery or invoice period'. For UBL Bis 3, in the case of intra-community supply,
+        the Actual delivery date (BT-72) or the Invoicing period (BG-14) should be present under the form:
+        {
+            'start_date': str,
+            'end_date': str,
+        }.
+        """
+        return []
+
+    def _get_delivery_vals_list(self, invoice):
+        # the data is optional, except for ubl bis3 (see the override, where we need to set a default delivery address)
+        if 'partner_shipping_id' in invoice._fields:
+            return [{
+                'actual_delivery_date': None,
+                'delivery_location_vals': {
+                    'delivery_address_vals': self._get_partner_address_vals(invoice.partner_shipping_id),
+                },
+            }]
+        else:
+            return []
+
+    def _get_bank_address_vals(self, bank):
+        return {
+            'street_name': bank.street,
+            'additional_street_name': bank.street2,
+            'city_name': bank.city,
+            'postal_zone': bank.zip,
+            'country_subentity': bank.state.name,
+            'country_subentity_code': bank.state.code,
+            'country_vals': self._get_country_vals(bank.country),
+        }
+
+    def _get_financial_institution_vals(self, bank):
+        return {
+            'bank': bank,
+            'id': bank.bic,
+            'id_attrs': {'schemeID': 'BIC'},
+            'name': bank.name,
+            'address_vals': self._get_bank_address_vals(bank),
+        }
+
+    def _get_financial_institution_branch_vals(self, bank):
+        return {
+            'bank': bank,
+            'id': bank.bic,
+            'id_attrs': {'schemeID': 'BIC'},
+            'financial_institution_vals': self._get_financial_institution_vals(bank),
+        }
+
+    def _get_financial_account_vals(self, partner_bank):
+        vals = {
+            'bank_account': partner_bank,
+            'id': partner_bank.acc_number.replace(' ', ''),
+        }
+
+        if partner_bank.bank_id:
+            vals['financial_institution_branch_vals'] = self._get_financial_institution_branch_vals(partner_bank.bank_id)
+
+        return vals
+
+    def _get_invoice_payment_means_vals_list(self, invoice):
+        vals = {
+            'payment_means_code': 30,
+            'payment_means_code_attrs': {'name': 'credit transfer'},
+            'payment_due_date': invoice.invoice_date_due or invoice.invoice_date,
+            'instruction_id': invoice.payment_reference,
+            'payment_id_vals': [invoice.payment_reference or invoice.name],
+        }
+
+        if invoice.partner_bank_id:
+            vals['payee_financial_account_vals'] = self._get_financial_account_vals(invoice.partner_bank_id)
+
+        return [vals]
+
+    def _get_invoice_payment_terms_vals_list(self, invoice):
+        payment_term = invoice.invoice_payment_term_id
+        if payment_term:
+            return [{'note_vals': [payment_term.name]}]
+        else:
+            return []
+
+    def _get_invoice_tax_totals_vals_list(self, invoice, taxes_vals):
+        balance_sign = -1 if invoice.is_inbound() else 1
+
+        return [{
+            'currency': invoice.currency_id,
+            'currency_dp': invoice.currency_id.decimal_places,
+            'tax_amount': balance_sign * taxes_vals['tax_amount_currency'],
+            'tax_subtotal_vals': [{
+                'currency': invoice.currency_id,
+                'currency_dp': invoice.currency_id.decimal_places,
+                'taxable_amount': balance_sign * vals['base_amount_currency'],
+                'tax_amount': balance_sign * vals['tax_amount_currency'],
+                'percent': vals['_tax_category_vals_']['percent'],
+                'tax_category_vals': vals['_tax_category_vals_'],
+            } for vals in taxes_vals['tax_details'].values()],
+        }]
+
+    def _get_invoice_line_item_vals(self, line, taxes_vals):
+        """ Method used to fill the cac:InvoiceLine/cac:Item node.
+        It provides information about what the product you are selling.
+
+        :param line:        An invoice line.
+        :param taxes_vals:  The tax details for the current invoice line.
+        :return:            A python dictionary.
+
+        """
+        product = line.product_id
+        taxes = line.tax_ids.flatten_taxes_hierarchy()
+        tax_category_vals_list = self._get_tax_category_list(line.move_id, taxes)
+        description = line.name and line.name.replace('\n', ', ')
+
+        return {
+            # Simple description about what you are selling.
+            'description': description,
+
+            # The name of the item.
+            'name': product.name,
+
+            # Identifier of the product.
+            'sellers_item_identification_vals': {'id': product.code},
+
+            # The main tax applied. Only one is allowed.
+            'classified_tax_category_vals': tax_category_vals_list,
+        }
+
+    def _get_document_allowance_charge_vals_list(self, invoice):
+        """
+        https://docs.peppol.eu/poacc/billing/3.0/bis/#_document_level_allowance_or_charge
+        The aim is to transform the ecotax/récupel into a charge at the document level.
+        Warning, as the charge is transformed into an allowance, we have to make sure no tax is created on the line
+        level, otherwise, the TaxInclusiveAmount, will be wrong.
+        """
+        vals_list = []
+        #for line in invoice.line_ids:
+        #    for tax in line.tax_ids:
+        #        if tax.amount_type == 'fixed':
+        #            total_amount += tax.amount
+        #            vals_list.append({
+        #                'charge_indicator': 'true',
+        #                'allowance_charge_reason_code': 'AEO',  # "Collection and recycling"
+        #                'allowance_charge_reason': 'Collection and recycling',
+        #                'amount': float(tax.amount),
+        #                'currency_name': line.currency_id.name,
+        #                'currency_dp': line.currency_id.decimal_places,
+        #            })
+        return vals_list
+
+    def _get_invoice_line_allowance_vals_list(self, line):
+        """ Method used to fill the cac:InvoiceLine>cac:AllowanceCharge node.
+
+        Allowances are distinguished from charges using the ChargeIndicator node with 'false' as value.
+
+        Note that allowance charges do not exist for credit notes in UBL 2.0, so if we apply discount in Odoo
+        the net price will not be consistent with the unit price, but we cannot do anything about it
+
+        :param line:    An invoice line.
+        :return:        A list of python dictionaries.
+        """
+        if not line.discount:
+            return []
+
+        # Price subtotal without discount:
+        net_price_subtotal = line.price_subtotal
+        # Price subtotal with discount:
+        if line.discount == 100.0:
+            gross_price_subtotal = 0.0
+        else:
+            gross_price_subtotal = line.currency_id.round(net_price_subtotal / (1.0 - (line.discount or 0.0) / 100.0))
+
+        allowance_vals = {
+            'currency_name': line.currency_id.name,
+            'currency_dp': line.currency_id.decimal_places,
+
+            # Must be 'false' since this method is for allowances.
+            'charge_indicator': 'false',
+
+            # A reason should be provided. In Odoo, we only manage discounts.
+            # Full code list is available here:
+            # https://docs.peppol.eu/poacc/billing/3.0/codelist/UNCL5189/
+            'allowance_charge_reason_code': 95,
+
+            # The discount should be provided as an amount.
+            'amount': gross_price_subtotal - net_price_subtotal,
+        }
+
+        return [allowance_vals]
+
+    def _get_invoice_line_price_vals(self, line):
+        """ Method used to fill the cac:InvoiceLine/cac:Price node.
+        It provides information about the price applied for the goods and services invoiced.
+
+        :param line:    An invoice line.
+        :return:        A python dictionary.
+        """
+        # Price subtotal without discount:
+        net_price_subtotal = line.price_subtotal
+        # Price subtotal with discount:
+        if line.discount == 100.0:
+            gross_price_subtotal = 0.0
+        else:
+            gross_price_subtotal = net_price_subtotal / (1.0 - (line.discount or 0.0) / 100.0)
+        # Price subtotal with discount / quantity:
+        gross_price_unit = line.currency_id.round((gross_price_subtotal / line.quantity) if line.quantity else 0.0)
+
+        uom = super()._get_uom_unece_code(line)
+
+        return {
+            'currency': line.currency_id,
+            'currency_dp': line.currency_id.decimal_places,
+
+            # The price of an item, exclusive of VAT, after subtracting item price discount.
+            'price_amount': gross_price_unit,
+
+            # The number of item units to which the price applies.
+            # setting to None -> the xml will not comprise the BaseQuantity (it's not mandatory)
+            'base_quantity': None,
+            'base_quantity_attrs': {'unitCode': uom},
+        }
+
+    def _get_invoice_line_vals(self, line, taxes_vals):
+        """ Method used to fill the cac:InvoiceLine node.
+        It provides information about the invoice line.
+
+        :param line:    An invoice line.
+        :return:        A python dictionary.
+        """
+        allowance_charge_vals_list = self._get_invoice_line_allowance_vals_list(line)
+
+        uom = super()._get_uom_unece_code(line)
+
+        return {
+            'currency': line.currency_id,
+            'currency_dp': line.currency_id.decimal_places,
+
+            # The requirement is the id has to be unique by invoice line.
+            'id': line.id,
+
+            'invoiced_quantity': line.quantity,
+            'invoiced_quantity_attrs': {'unitCode': uom},
+
+            'line_extension_amount': line.price_subtotal,
+
+            'allowance_charge_vals': allowance_charge_vals_list,
+            'tax_total_vals': self._get_invoice_tax_totals_vals_list(line.move_id, taxes_vals),
+            'item_vals': self._get_invoice_line_item_vals(line, taxes_vals),
+            'price_vals': self._get_invoice_line_price_vals(line),
+        }
+
+    def _export_invoice_vals(self, invoice):
+        def grouping_key_generator(tax_values):
+            tax = tax_values['tax_id']
+            tax_category_vals = self._get_tax_category_list(invoice, tax)[0]
+            return {
+                'tax_category_id': tax_category_vals['id'],
+                'tax_category_percent': tax_category_vals['percent'],
+                '_tax_category_vals_': tax_category_vals,
+            }
+
+        # Compute the tax details for the whole invoice and each invoice line separately.
+        taxes_vals = invoice._prepare_edi_tax_details(grouping_key_generator=grouping_key_generator)
+
+        # Compute values for invoice lines.
+        line_extension_amount = 0.0
+
+        invoice_lines = invoice.invoice_line_ids.filtered(lambda line: not line.display_type)
+        document_allowance_charge_vals_list = self._get_document_allowance_charge_vals_list(invoice)
+        invoice_line_vals_list = []
+        for line in invoice_lines:
+            line_taxes_vals = taxes_vals['invoice_line_tax_details'][line]
+            line_vals = self._get_invoice_line_vals(line, line_taxes_vals)
+            invoice_line_vals_list.append(line_vals)
+
+            line_extension_amount += line_vals['line_extension_amount']
+
+        # Compute the total allowance/charge amounts.
+        allowance_total_amount = 0.0
+        for allowance_charge_vals in document_allowance_charge_vals_list:
+            if allowance_charge_vals['charge_indicator'] == 'false':
+                allowance_total_amount += allowance_charge_vals['amount']
+
+        supplier = invoice.company_id.partner_id.commercial_partner_id
+        customer = invoice.commercial_partner_id
+
+        vals = {
+            'builder': self,
+            'invoice': invoice,
+            'supplier': supplier,
+            'customer': customer,
+
+            'taxes_vals': taxes_vals,
+
+            'format_float': self.format_float,
+            'AddressType_template': 'account_edi_ubl_cii.ubl_20_AddressType',
+            'ContactType_template': 'account_edi_ubl_cii.ubl_20_ContactType',
+            'PartyType_template': 'account_edi_ubl_cii.ubl_20_PartyType',
+            'PaymentMeansType_template': 'account_edi_ubl_cii.ubl_20_PaymentMeansType',
+            'TaxCategoryType_template': 'account_edi_ubl_cii.ubl_20_TaxCategoryType',
+            'TaxTotalType_template': 'account_edi_ubl_cii.ubl_20_TaxTotalType',
+            'AllowanceChargeType_template': 'account_edi_ubl_cii.ubl_20_AllowanceChargeType',
+            'InvoiceLineType_template': 'account_edi_ubl_cii.ubl_20_InvoiceLineType',
+            'InvoiceType_template': 'account_edi_ubl_cii.ubl_20_InvoiceType',
+
+            'vals': {
+                'ubl_version_id': 2.0,
+                'id': invoice.name,
+                'issue_date': invoice.invoice_date,
+                'due_date': invoice.invoice_date_due,
+                'note_vals': [html2plaintext(invoice.narration)] if invoice.narration else [],
+                'order_reference': invoice.invoice_origin,
+                'accounting_supplier_party_vals': {
+                    'party_vals': self._get_partner_party_vals(supplier, role='supplier'),
+                },
+                'accounting_customer_party_vals': {
+                    'party_vals': self._get_partner_party_vals(customer, role='customer'),
+                },
+                'invoice_period_vals_list': self._get_invoice_period_vals_list(invoice),
+                'delivery_vals_list': self._get_delivery_vals_list(invoice),
+                'payment_means_vals_list': self._get_invoice_payment_means_vals_list(invoice),
+                'payment_terms_vals': self._get_invoice_payment_terms_vals_list(invoice),
+                # allowances at the document level, the allowances on invoices (eg. discount) are on invoice_line_vals
+                'allowance_charge_vals': document_allowance_charge_vals_list,
+                'tax_total_vals': self._get_invoice_tax_totals_vals_list(invoice, taxes_vals),
+                'legal_monetary_total_vals': {
+                    'currency': invoice.currency_id,
+                    'currency_dp': invoice.currency_id.decimal_places,
+                    'line_extension_amount': line_extension_amount,
+                    'tax_exclusive_amount': invoice.amount_untaxed,
+                    'tax_inclusive_amount': invoice.amount_total,
+                    'allowance_total_amount': allowance_total_amount or None,
+                    'prepaid_amount': invoice.amount_total - invoice.amount_residual,
+                    'payable_amount': invoice.amount_residual,
+                },
+                'invoice_line_vals': invoice_line_vals_list,
+                'currency_dp': invoice.currency_id.decimal_places,  # currency decimal places
+            },
+        }
+
+        if invoice.move_type == 'out_invoice':
+            vals['main_template'] = 'account_edi_ubl_cii.ubl_20_Invoice'
+            vals['vals']['invoice_type_code'] = 380
+        else:
+            vals['main_template'] = 'account_edi_ubl_cii.ubl_20_CreditNote'
+            vals['vals']['credit_note_type_code'] = 381
+
+        return vals
+
+    def _export_invoice_constraints(self, invoice, vals):
+        constraints = self._invoice_constraints_common(invoice)
+        constraints.update({
+            'ubl20_supplier_name_required': self._check_required_fields(vals['supplier'], 'name'),
+            'ubl20_customer_name_required': self._check_required_fields(vals['customer'], 'name'),
+            'ubl20_commercial_customer_name_required': self._check_required_fields(vals['customer'].commercial_partner_id, 'name'),
+            'ubl20_invoice_name_required': self._check_required_fields(invoice, 'name'),
+            'ubl20_invoice_date_required': self._check_required_fields(invoice, 'invoice_date'),
+        })
+        return constraints
+
+    def _export_invoice(self, invoice):
+        vals = self._export_invoice_vals(invoice)
+        errors = [constraint for constraint in self._export_invoice_constraints(invoice, vals).values() if constraint]
+        xml_content = self.env['ir.qweb']._render(vals['main_template'], vals)
+        return etree.tostring(cleanup_xml_node(xml_content)), set(errors)
+
+    # -------------------------------------------------------------------------
+    # IMPORT
+    # -------------------------------------------------------------------------
+
+    def _import_fill_invoice_form(self, journal, tree, invoice_form, qty_factor):
+        logs = []
+
+        if qty_factor == -1:
+            logs.append(_("The invoice has been converted into a credit note and the quantities have been reverted."))
+
+        # ==== partner_id ====
+
+        partner = self._import_retrieve_info_from_map(
+            tree,
+            self._import_retrieve_partner_map(journal),
+        )
+        if partner:
+            invoice_form.partner_id = partner
+        else:
+            logs.append(_("Could not retrieve the vendor."))
+
+        # ==== currency_id ====
+
+        currency_code_node = tree.find('.//{*}DocumentCurrencyCode')
+        if currency_code_node is not None:
+            currency = self.env['res.currency'].with_context(active_test=False).search([
+                ('name', '=', currency_code_node.text),
+            ], limit=1)
+            if currency:
+                if not currency.active:
+                    logs.append(_("The currency '%s' is not active.", currency.name))
+                invoice_form.currency_id = currency
+            else:
+                logs.append(_("Could not retrieve currency: %s. Did you enable the multicurrency option "
+                              "and activate the currency ?", currency_code_node.text))
+
+        # ==== Reference ====
+
+        ref_node = tree.find('./{*}ID')
+        if ref_node is not None:
+            invoice_form.ref = ref_node.text
+
+        # === Note/narration ====
+
+        narration = ""
+        note_node = tree.find('./{*}Note')
+        if note_node is not None and note_node.text:
+            narration += note_node.text + "\n"
+
+        payment_terms_node = tree.find('./{*}PaymentTerms/{*}Note')  # e.g. 'Payment within 10 days, 2% discount'
+        if payment_terms_node is not None:
+            narration += payment_terms_node.text + "\n"
+
+        invoice_form.narration = narration
+
+        # ==== payment_reference ====
+
+        payment_reference_node = tree.find('./{*}PaymentMeans/{*}PaymentID')
+        if payment_reference_node is not None:
+            invoice_form.payment_reference = payment_reference_node.text
+
+        # ==== invoice_date ====
+
+        invoice_date_node = tree.find('./{*}IssueDate')
+        if invoice_date_node is not None:
+            invoice_form.invoice_date = invoice_date_node.text
+
+        # ==== invoice_date_due ====
+
+        for xpath in ('./{*}DueDate', './/{*}PaymentDueDate'):
+            invoice_date_due_node = tree.find(xpath)
+            if invoice_date_due_node is not None:
+                invoice_form.invoice_date_due = invoice_date_due_node.text
+                break
+
+        # ==== invoice_incoterm_id ====
+
+        incoterm_code_node = tree.find('./{*}TransportExecutionTerms/{*}DeliveryTerms/{*}ID')
+        if incoterm_code_node is not None:
+            incoterm = self.env['account.incoterms'].search([('code', '=', incoterm_code_node.text)], limit=1)
+            if incoterm:
+                invoice_form.invoice_incoterm_id = incoterm
+
+        # ==== invoice_line_ids: AllowanceCharge (document level) ====
+
+        logs += self._import_fill_invoice_allowance_charge(tree, invoice_form, journal, qty_factor)
+
+        # ==== Down Payment (prepaid amount) ====
+
+        prepaid_node = tree.find('./{*}LegalMonetaryTotal/{*}PrepaidAmount')
+        self._import_fill_invoice_down_payment(invoice_form, prepaid_node, qty_factor)
+
+        # ==== invoice_line_ids: InvoiceLine/CreditNoteLine ====
+
+        invoice_line_tag = 'InvoiceLine' if invoice_form.move_type == 'in_invoice' or qty_factor == -1 else 'CreditNoteLine'
+        for i, invl_el in enumerate(tree.findall('./{*}' + invoice_line_tag)):
+            with invoice_form.invoice_line_ids.new() as invoice_line_form:
+                invoice_line_form.sequence = i
+                invl_logs = self._import_fill_invoice_line_form(journal, invl_el, invoice_form, invoice_line_form, qty_factor)
+                logs += invl_logs
+
+        return invoice_form, logs
+
+    def _import_fill_invoice_line_form(self, journal, tree, invoice_form, invoice_line_form, qty_factor):
+        logs = []
+
+        # Product
+        product = self._import_retrieve_info_from_map(
+            tree,
+            self._import_retrieve_product_map(journal),
+        )
+        if product is not None:
+            invoice_line_form.product_id = product
+
+        # Name
+        name_node = tree.find('./{*}Item/{*}Description')
+        if name_node is not None:
+            invoice_line_form.name = name_node.text
+
+        xpath_dict = {
+            'basis_qty': [
+                './{*}Price/{*}BaseQuantity',
+            ],
+            'gross_price_unit': './{*}Price/{*}AllowanceCharge/{*}BaseAmount',
+            'rebate': './{*}Price/{*}AllowanceCharge/{*}Amount',
+            'net_price_unit': './{*}Price/{*}PriceAmount',
+            'billed_qty':  './{*}InvoicedQuantity' if invoice_form.move_type == 'in_invoice' or qty_factor == -1 else './{*}CreditedQuantity',
+            'allowance_charge': './/{*}AllowanceCharge',
+            'allowance_charge_indicator': './{*}ChargeIndicator',  # below allowance_charge node
+            'allowance_charge_amount': './{*}Amount',  # below allowance_charge node
+            'line_total_amount': './{*}LineExtensionAmount',
+        }
+        self._import_fill_invoice_line_values(tree, xpath_dict, invoice_line_form, qty_factor)
+
+        if not invoice_line_form.product_uom_id:
+            logs.append(
+                _("Could not retrieve the unit of measure for line with label '%s'. Did you install the inventory "
+                  "app and enabled the 'Units of Measure' option ?", invoice_line_form.name))
+
+        # Taxes
+        taxes = []
+
+        tax_nodes = tree.findall('.//{*}Item/{*}ClassifiedTaxCategory/{*}Percent')
+        if not tax_nodes:
+            for elem in tree.findall('.//{*}TaxTotal'):
+                tax_nodes += elem.findall('.//{*}TaxSubtotal/{*}Percent')
+
+        for tax_node in tax_nodes:
+            tax = self.env['account.tax'].search([
+                ('company_id', '=', journal.company_id.id),
+                ('amount', '=', float(tax_node.text)),
+                ('amount_type', '=', 'percent'),
+                ('type_tax_use', '=', 'purchase'),
+            ], limit=1)
+            if tax:
+                taxes.append(tax)
+            else:
+                logs.append(_("Could not retrieve the tax: %s %% for line '%s'.", float(tax_node.text), invoice_line_form.name))
+
+        invoice_line_form.tax_ids.clear()
+        for tax in taxes:
+            invoice_line_form.tax_ids.add(tax)
+        return logs
+
+    # -------------------------------------------------------------------------
+    # IMPORT : helpers
+    # -------------------------------------------------------------------------
+
+    def _get_import_document_amount_sign(self, filename, tree):
+        """
+        In UBL, an invoice has tag 'Invoice' and a credit note has tag 'CreditNote'. However, a credit note can be
+        expressed as an invoice with negative amounts. For this case, we need a factor to take the opposite
+        of each quantity in the invoice.
+        """
+        if tree.tag == '{urn:oasis:names:specification:ubl:schema:xsd:Invoice-2}Invoice':
+            amount_node = tree.find('.//{*}LegalMonetaryTotal/{*}TaxExclusiveAmount')
+            if amount_node is not None and float(amount_node.text) < 0:
+                return 'in_refund', -1
+            return 'in_invoice', 1
+        if tree.tag == '{urn:oasis:names:specification:ubl:schema:xsd:CreditNote-2}CreditNote':
+            return 'in_refund', 1
+        return None, None
+
+    def _import_retrieve_partner_map(self, company):
+
+        def with_vat(tree, extra_domain):
+            vat_node = tree.find('.//{*}AccountingSupplierParty/{*}Party//{*}CompanyID')
+            vat = None if vat_node is None else vat_node.text
+            return self.env['account.edi.format']._retrieve_partner_with_vat(vat, extra_domain)
+
+        def with_phone_mail(tree, extra_domain):
+            phone_node = tree.find('.//{*}AccountingSupplierParty/{*}Party//{*}Telephone')
+            mail_node = tree.find('.//{*}AccountingSupplierParty/{*}Party//{*}ElectronicMail')
+
+            phone = None if phone_node is None else phone_node.text
+            mail = None if mail_node is None else mail_node.text
+            return self.env['account.edi.format']._retrieve_partner_with_phone_mail(phone, mail, extra_domain)
+
+        def with_name(tree, extra_domain):
+            name_node = tree.find('.//{*}AccountingSupplierParty/{*}Party//{*}Name')
+            name = None if name_node is None else name_node.text
+            return self.env['account.edi.format']._retrieve_partner_with_name(name, extra_domain)
+
+        return {
+            10: lambda tree: with_vat(tree, [('company_id', '=', company.id)]),
+            20: lambda tree: with_vat(tree, []),
+            30: lambda tree: with_phone_mail(tree, [('company_id', '=', company.id)]),
+            40: lambda tree: with_phone_mail(tree, []),
+            50: lambda tree: with_name(tree, [('company_id', '=', company.id)]),
+            60: lambda tree: with_name(tree, []),
+        }
+
+    def _import_retrieve_product_map(self, company):
+
+        def with_code_barcode(tree, extra_domain):
+            domains = []
+
+            default_code_node = tree.find('./{*}Item/{*}SellersItemIdentification/{*}ID')
+            if default_code_node is not None:
+                domains.append([('default_code', '=', default_code_node.text)])
+
+            barcode_node = tree.find("./{*}Item/{*}StandardItemIdentification/{*}ID[@schemeID='0160']")
+            if barcode_node is not None:
+                domains.append([('barcode', '=', barcode_node.text)])
+
+            if not domains:
+                return None
+
+            return self.env['product.product'].search(extra_domain + expression.OR(domains), limit=1)
+
+        def with_name(tree, extra_domain):
+            name_node = tree.find('./{*}Item/{*}Name')
+
+            if name_node is None:
+                return None
+
+            return self.env['product.product'].search(extra_domain + [('name', 'ilike', name_node.text)], limit=1)
+
+        return {
+            10: lambda tree: with_code_barcode(tree, [('company_id', '=', company.id)]),
+            20: lambda tree: with_code_barcode(tree, []),
+            30: lambda tree: with_name(tree, [('company_id', '=', company.id)]),
+            40: lambda tree: with_name(tree, []),
+        }
+
+    def _import_retrieve_info_from_map(self, tree, import_method_map):
+        for key in sorted(import_method_map.keys()):
+            record = import_method_map[key](tree)
+            if record:
+                return record
+
+        return None

--- a/None
+++ b/addons/account_edi_ubl_cii/models/account_edi_xml_ubl_21.py
@@ -0,0 +1,37 @@
+# -*- coding: utf-8 -*-
+from odoo import models
+
+
+class AccountEdiXmlUBL21(models.AbstractModel):
+    _name = "account.edi.xml.ubl_21"
+    _inherit = 'account.edi.xml.ubl_20'
+    _description = "UBL 2.1"
+
+    # -------------------------------------------------------------------------
+    # EXPORT
+    # -------------------------------------------------------------------------
+
+    def _export_invoice_filename(self, invoice):
+        return f"{invoice.name.replace('/', '_')}_ubl_21.xml"
+
+    def _export_invoice_ecosio_schematrons(self):
+        return {
+            'invoice': 'org.oasis-open:invoice:2.1',
+            'credit_note': 'org.oasis-open:creditnote:2.1',
+        }
+
+    def _export_invoice_vals(self, invoice):
+        # EXTENDS account.edi.xml.ubl_20
+        vals = super()._export_invoice_vals(invoice)
+
+        vals.update({
+            'InvoiceType_template': 'account_edi_ubl_cii.ubl_21_InvoiceType',
+            'InvoiceLineType_template': 'account_edi_ubl_cii.ubl_21_InvoiceLineType',
+        })
+
+        vals['vals'].update({
+            'ubl_version_id': 2.1,
+            'buyer_reference': vals['customer'].commercial_partner_id.name,
+        })
+
+        return vals

--- a/None
+++ b/addons/account_edi_ubl_cii/models/account_edi_xml_ubl_bis3.py
@@ -0,0 +1,429 @@
+# -*- coding: utf-8 -*-
+
+from odoo import models, _
+from odoo.addons.account_edi_ubl_cii.models.account_edi_common import COUNTRY_EAS
+
+from stdnum.no import mva
+
+
+class AccountEdiXmlUBLBIS3(models.AbstractModel):
+    _name = "account.edi.xml.ubl_bis3"
+    _inherit = 'account.edi.xml.ubl_21'
+    _description = "UBL BIS Billing 3.0.12"
+
+    """
+    * Documentation of EHF Billing 3.0: https://anskaffelser.dev/postaward/g3/
+    * EHF 2.0 is no longer used:
+      https://anskaffelser.dev/postaward/g2/announcement/2019-11-14-removal-old-invoicing-specifications/
+    * Official doc for EHF Billing 3.0 is the OpenPeppol BIS 3 doc +
+      https://anskaffelser.dev/postaward/g3/spec/current/billing-3.0/norway/
+
+        "Based on work done in PEPPOL BIS Billing 3.0, Difi has included Norwegian rules in PEPPOL BIS Billing 3.0 and
+        does not see a need to implement a different CIUS targeting the Norwegian market. Implementation of EHF Billing
+        3.0 is therefore done by implementing PEPPOL BIS Billing 3.0 without extensions or extra rules."
+
+    Thus, EHF 3 and Bis 3 are actually the same format. The specific rules for NO defined in Bis 3 are added in Bis 3.
+    """
+
+    # -------------------------------------------------------------------------
+    # EXPORT
+    # -------------------------------------------------------------------------
+
+    def _export_invoice_filename(self, invoice):
+        return f"{invoice.name.replace('/', '_')}_ubl_bis3.xml"
+
+    def _export_invoice_ecosio_schematrons(self):
+        return {
+            'invoice': 'eu.peppol.bis3:invoice:3.13.0',
+            'credit_note': 'eu.peppol.bis3:creditnote:3.13.0',
+        }
+
+    def _get_country_vals(self, country):
+        # EXTENDS account.edi.xml.ubl_21
+        vals = super()._get_country_vals(country)
+
+        vals.pop('name', None)
+
+        return vals
+
+    def _get_partner_party_tax_scheme_vals_list(self, partner, role):
+        # EXTENDS account.edi.xml.ubl_21
+        vals_list = super()._get_partner_party_tax_scheme_vals_list(partner, role)
+
+        for vals in vals_list:
+            vals.pop('registration_name', None)
+            vals.pop('registration_address_vals', None)
+
+        # sources:
+        #  https://anskaffelser.dev/postaward/g3/spec/current/billing-3.0/norway/#_applying_foretaksregisteret
+        #  https://docs.peppol.eu/poacc/billing/3.0/bis/#national_rules (NO-R-002 (warning))
+        if partner.country_id.code == "NO" and role == 'supplier':
+            vals_list.append({
+                'company_id': "Foretaksregisteret",
+                'tax_scheme_id': "TAX",
+            })
+
+        return vals_list
+
+    def _get_partner_party_legal_entity_vals_list(self, partner):
+        # EXTENDS account.edi.xml.ubl_21
+        vals_list = super()._get_partner_party_legal_entity_vals_list(partner)
+
+        for vals in vals_list:
+            vals.pop('registration_address_vals', None)
+            if partner.country_code == 'NL':
+                endpoint = partner.l10n_nl_oin or partner.l10n_nl_kvk
+                scheme = '0190' if partner.l10n_nl_oin else '0106'
+                vals.update({
+                    'company_id': endpoint,
+                    'company_id_attrs': {'schemeID': scheme},
+                })
+
+        return vals_list
+
+    def _get_partner_contact_vals(self, partner):
+        # EXTENDS account.edi.xml.ubl_21
+        vals = super()._get_partner_contact_vals(partner)
+
+        vals.pop('id', None)
+
+        return vals
+
+    def _get_partner_party_vals(self, partner, role):
+        # EXTENDS account.edi.xml.ubl_21
+        vals = super()._get_partner_party_vals(partner, role)
+
+        vals['endpoint_id'] = partner.vat
+        vals['endpoint_id_attrs'] = {'schemeID': COUNTRY_EAS.get(partner.country_id.code)}
+
+        if partner.country_code == 'NO' and 'l10n_no_bronnoysund_number' in partner._fields:
+            vals.update({
+                'endpoint_id': partner.l10n_no_bronnoysund_number,
+                'endpoint_id_attrs': {'schemeID': '0192'},
+            })
+        # [BR-NL-1] Dutch supplier registration number ( AccountingSupplierParty/Party/PartyLegalEntity/CompanyID );
+        # With a Dutch supplier (NL), SchemeID may only contain 106 (Chamber of Commerce number) or 190 (OIN number).
+        # [BR-NL-10] At a Dutch supplier, for a Dutch customer ( AccountingCustomerParty ) the customer registration
+        # number must be filled with Chamber of Commerce or OIN. SchemeID may only contain 106 (Chamber of
+        # Commerce number) or 190 (OIN number).
+        if partner.country_code == 'NL' and 'l10n_nl_oin' in partner._fields:
+            if partner.l10n_nl_oin:
+                vals.update({
+                    'endpoint_id': partner.l10n_nl_oin,
+                    'endpoint_id_attrs': {'schemeID': '0190'},
+                })
+            elif partner.l10n_nl_kvk:
+                vals.update({
+                    'endpoint_id': partner.l10n_nl_kvk,
+                    'endpoint_id_attrs': {'schemeID': '0106'},
+                })
+
+        return vals
+
+    def _get_partner_party_identification_vals_list(self, partner):
+        # EXTENDS account.edi.xml.ubl_21
+        vals = super()._get_partner_party_identification_vals_list(partner)
+
+        if partner.country_code == 'NL':
+            endpoint = partner.l10n_nl_oin or partner.l10n_nl_kvk
+            vals.append({
+                'id': endpoint,
+            })
+        return vals
+
+    def _get_delivery_vals_list(self, invoice):
+        # EXTENDS account.edi.xml.ubl_21
+        supplier = invoice.company_id.partner_id.commercial_partner_id
+        customer = invoice.commercial_partner_id
+
+        economic_area = self.env.ref('base.europe').country_ids.mapped('code') + ['NO']
+        intracom_delivery = (customer.country_id.code in economic_area
+                             and supplier.country_id.code in economic_area
+                             and supplier.country_id != customer.country_id)
+
+        if not intracom_delivery:
+            return []
+
+        # [BR-IC-12]-In an Invoice with a VAT breakdown (BG-23) where the VAT category code (BT-118) is
+        # "Intra-community supply" the Deliver to country code (BT-80) shall not be blank.
+
+        # [BR-IC-11]-In an Invoice with a VAT breakdown (BG-23) where the VAT category code (BT-118) is
+        # "Intra-community supply" the Actual delivery date (BT-72) or the Invoicing period (BG-14)
+        # shall not be blank.
+
+        if 'partner_shipping_id' in invoice._fields:
+            partner_shipping = invoice.partner_shipping_id
+        else:
+            partner_shipping = customer
+
+        return [{
+            'actual_delivery_date': invoice.invoice_date,
+            'delivery_location_vals': {
+                'delivery_address_vals': self._get_partner_address_vals(partner_shipping),
+            },
+        }]
+
+    def _get_partner_address_vals(self, partner):
+        # EXTENDS account.edi.xml.ubl_21
+        vals = super()._get_partner_address_vals(partner)
+        # schematron/openpeppol/3.13.0/xslt/CEN-EN16931-UBL.xslt
+        # [UBL-CR-225]-A UBL invoice should not include the AccountingCustomerParty Party PostalAddress CountrySubentityCode
+        vals.pop('country_subentity_code', None)
+        return vals
+
+    def _get_financial_institution_branch_vals(self, bank):
+        # EXTENDS account.edi.xml.ubl_21
+        vals = super()._get_financial_institution_branch_vals(bank)
+        # schematron/openpeppol/3.13.0/xslt/CEN-EN16931-UBL.xslt
+        # [UBL-CR-664]-A UBL invoice should not include the FinancialInstitutionBranch FinancialInstitution
+        # xpath test: not(//cac:FinancialInstitution)
+        vals.pop('id_attrs', None)
+        vals.pop('financial_institution_vals', None)
+        return vals
+
+    def _get_invoice_payment_means_vals_list(self, invoice):
+        # EXTENDS account.edi.xml.ubl_21
+        vals_list = super()._get_invoice_payment_means_vals_list(invoice)
+
+        for vals in vals_list:
+            vals.pop('payment_due_date', None)
+            vals.pop('instruction_id', None)
+            if vals.get('payment_id_vals'):
+                vals['payment_id_vals'] = vals['payment_id_vals'][:1]
+
+        return vals_list
+
+    def _get_tax_category_list(self, invoice, taxes):
+        # EXTENDS account.edi.xml.ubl_21
+        vals_list = super()._get_tax_category_list(invoice, taxes)
+
+        for vals in vals_list:
+            vals.pop('name')
+            # [UBL-CR-601]-A UBL invoice should not include the InvoiceLine Item ClassifiedTaxCategory TaxExemptionReason
+            #vals.pop('tax_exemption_reason')
+
+        return vals_list
+
+    def _get_invoice_tax_totals_vals_list(self, invoice, taxes_vals):
+        # EXTENDS account.edi.xml.ubl_21
+        vals_list = super()._get_invoice_tax_totals_vals_list(invoice, taxes_vals)
+
+        for vals in vals_list:
+            vals['currency_dp'] = 2
+            for subtotal_vals in vals.get('tax_subtotal_vals', []):
+                subtotal_vals.pop('percent', None)
+                subtotal_vals['currency_dp'] = 2
+
+        return vals_list
+
+    def _get_invoice_line_allowance_vals_list(self, line):
+        # EXTENDS account.edi.xml.ubl_21
+        vals_list = super()._get_invoice_line_allowance_vals_list(line)
+
+        for vals in vals_list:
+            vals['currency_dp'] = 2
+
+        return vals_list
+
+    def _get_invoice_line_vals(self, line, taxes_vals):
+        # EXTENDS account.edi.xml.ubl_21
+        vals = super()._get_invoice_line_vals(line, taxes_vals)
+
+        vals.pop('tax_total_vals', None)
+
+        vals['currency_dp'] = 2
+        vals['price_vals']['currency_dp'] = 2
+
+        return vals
+
+    def _export_invoice_vals(self, invoice):
+        # EXTENDS account.edi.xml.ubl_21
+        vals = super()._export_invoice_vals(invoice)
+
+        vals['vals'].update({
+            'customization_id': 'urn:cen.eu:en16931:2017#compliant#urn:fdc:peppol.eu:2017:poacc:billing:3.0',
+            'profile_id': 'urn:fdc:peppol.eu:2017:poacc:billing:01:1.0',
+            'currency_dp': 2,
+        })
+        vals['vals']['legal_monetary_total_vals']['currency_dp'] = 2
+
+        # [NL-R-001] For suppliers in the Netherlands, if the document is a creditnote, the document MUST
+        # contain an invoice reference (cac:BillingReference/cac:InvoiceDocumentReference/cbc:ID)
+        if vals['supplier'].country_id.code == 'NL' and 'refund' in invoice.move_type:
+            vals['vals'].update({
+                'billing_reference_vals': {
+                    'id': invoice.ref,
+                    'issue_date': None,
+                }
+            })
+
+        return vals
+
+    def _export_invoice_constraints(self, invoice, vals):
+        # EXTENDS account.edi.xml.ubl_21
+        constraints = super()._export_invoice_constraints(invoice, vals)
+        constraints.update(
+            self._invoice_constraints_peppol_en16931_ubl(invoice, vals)
+        )
+        constraints.update(
+            self._invoice_constraints_cen_en16931_ubl(invoice, vals)
+        )
+
+        return constraints
+
+    def _invoice_constraints_cen_en16931_ubl(self, invoice, vals):
+        """
+        corresponds to the errors raised by ' schematron/openpeppol/3.13.0/xslt/CEN-EN16931-UBL.xslt' for invoices.
+        This xslt was obtained by transforming the corresponding sch
+        https://docs.peppol.eu/poacc/billing/3.0/files/CEN-EN16931-UBL.sch.
+        """
+        eu_countries = self.env.ref('base.europe').country_ids
+        intracom_delivery = (vals['customer'].country_id in eu_countries
+                             and vals['supplier'].country_id in eu_countries
+                             and vals['customer'].country_id != vals['supplier'].country_id)
+
+        constraints = {
+            # [BR-S-02]-An Invoice that contains an Invoice line (BG-25) where the Invoiced item VAT category code
+            # (BT-151) is "Standard rated" shall contain the Seller VAT Identifier (BT-31), the Seller tax registration
+            # identifier (BT-32) and/or the Seller tax representative VAT identifier (BT-63).
+            # ---
+            # [BR-CO-26]-In order for the buyer to automatically identify a supplier, the Seller identifier (BT-29),
+            # the Seller legal registration identifier (BT-30) and/or the Seller VAT identifier (BT-31) shall be present.
+            'cen_en16931_seller_vat_identifier': self._check_required_fields(
+                vals['supplier'], 'vat'  # this check is larger than the rules above
+            ),
+            # [BR-61]-If the Payment means type code (BT-81) means SEPA credit transfer, Local credit transfer or
+            # Non-SEPA international credit transfer, the Payment account identifier (BT-84) shall be present.
+            # note: Payment account identifier is <cac:PayeeFinancialAccount>
+            # note: no need to check account_number, because it's a required field for a partner_bank
+            'cen_en16931_payment_account_identifier': self._check_required_fields(
+                invoice, 'partner_bank_id'
+            ) if vals['vals']['payment_means_vals_list'][0]['payment_means_code'] in (30, 58) else None,
+            # [BR-62]-The Seller electronic address (BT-34) shall have a Scheme identifier.
+            # if this fails, it might just be a missing country when mapping the country to the EAS code
+            'cen_en16931_seller_EAS': self._check_required_fields(
+                vals['vals']['accounting_supplier_party_vals']['party_vals']['endpoint_id_attrs'], 'schemeID',
+                _("No Electronic Address Scheme (EAS) could be found for %s.", vals['customer'].name)
+            ),
+            # [BR-63]-The Buyer electronic address (BT-49) shall have a Scheme identifier.
+            # if this fails, it might just be a missing country when mapping the country to the EAS code
+            'cen_en16931_buyer_EAS': self._check_required_fields(
+                vals['vals']['accounting_customer_party_vals']['party_vals']['endpoint_id_attrs'], 'schemeID',
+                _("No Electronic Address Scheme (EAS) could be found for %s.", vals['customer'].name)
+            ),
+            # [BR-IC-12]-In an Invoice with a VAT breakdown (BG-23) where the VAT category code (BT-118) is
+            # "Intra-community supply" the Deliver to country code (BT-80) shall not be blank.
+            'cen_en16931_delivery_country_code': self._check_required_fields(
+                vals['vals']['delivery_vals_list'][0], 'delivery_location_vals',
+                _("For intracommunity supply, the delivery address should be included.")
+            ) if intracom_delivery else None,
+
+            # [BR-IC-11]-In an Invoice with a VAT breakdown (BG-23) where the VAT category code (BT-118) is
+            # "Intra-community supply" the Actual delivery date (BT-72) or the Invoicing period (BG-14)
+            # shall not be blank.
+            'cen_en16931_delivery_date_invoicing_period': self._check_required_fields(
+                vals['vals']['delivery_vals_list'][0], 'actual_delivery_date',
+                _("For intracommunity supply, the actual delivery date or the invoicing period should be included.")
+            ) and self._check_required_fields(
+                vals['vals']['invoice_period_vals_list'][0], ['start_date', 'end_date'],
+                _("For intracommunity supply, the actual delivery date or the invoicing period should be included.")
+            ) if intracom_delivery else None,
+        }
+
+        for line in invoice.line_ids:
+            if len(line.tax_ids) > 1:
+                # [UBL-SR-48]-Invoice lines shall have one and only one classified tax category.
+                constraints.update({'cen_en16931_tax_line': _("Each invoice line shall have one and only one tax.")})
+
+        return constraints
+
+    def _invoice_constraints_peppol_en16931_ubl(self, invoice, vals):
+        """
+        corresponds to the errors raised by 'schematron/openpeppol/3.13.0/xslt/PEPPOL-EN16931-UBL.xslt' for
+        invoices in ecosio. This xslt was obtained by transforming the corresponding sch
+        https://docs.peppol.eu/poacc/billing/3.0/files/PEPPOL-EN16931-UBL.sch.
+
+        The national rules (https://docs.peppol.eu/poacc/billing/3.0/bis/#national_rules) are included in this file.
+        They always refer to the supplier's country.
+        """
+        constraints = {
+            # PEPPOL-EN16931-R020: Seller electronic address MUST be provided
+            'peppol_en16931_ubl_seller_endpoint': self._check_required_fields(
+                vals['supplier'], 'vat'
+            ),
+            # PEPPOL-EN16931-R010: Buyer electronic address MUST be provided
+            'peppol_en16931_ubl_buyer_endpoint': self._check_required_fields(
+                vals['customer'], 'vat'
+            ),
+            # PEPPOL-EN16931-R003: A buyer reference or purchase order reference MUST be provided.
+            'peppol_en16931_ubl_buyer_ref_po_ref':
+                "A buyer reference or purchase order reference must be provided." if self._check_required_fields(
+                    vals['vals'], 'buyer_reference'
+                ) and self._check_required_fields(invoice, 'invoice_origin') else None,
+        }
+
+        if vals['supplier'].country_id.code == 'NL':
+            constraints.update({
+                # [NL-R-001] For suppliers in the Netherlands, if the document is a creditnote, the document MUST contain
+                # an invoice reference (cac:BillingReference/cac:InvoiceDocumentReference/cbc:ID)
+                'nl_r_001': self._check_required_fields(invoice, 'ref') if 'refund' in invoice.move_type else '',
+
+                # [NL-R-002] For suppliers in the Netherlands the supplier’s address (cac:AccountingSupplierParty/cac:Party
+                # /cac:PostalAddress) MUST contain street name (cbc:StreetName), city (cbc:CityName) and post code (cbc:PostalZone)
+                'nl_r_002_street': self._check_required_fields(vals['supplier'], 'street'),
+                'nl_r_002_zip': self._check_required_fields(vals['supplier'], 'zip'),
+                'nl_r_002_city': self._check_required_fields(vals['supplier'], 'city'),
+
+                # [NL-R-003] For suppliers in the Netherlands, the legal entity identifier MUST be either a
+                # KVK or OIN number (schemeID 0106 or 0190)
+                'nl_r_003': _(
+                    "The supplier %s must have a KVK or OIN number.",
+                    vals['supplier'].display_name
+                ) if 'l10n_nl_oin' not in vals['supplier']._fields or 'l10n_nl_kvk' not in vals['supplier']._fields else '',
+
+                # [NL-R-007] For suppliers in the Netherlands, the supplier MUST provide a means of payment
+                # (cac:PaymentMeans) if the payment is from customer to supplier
+                'nl_r_007': self._check_required_fields(invoice, 'partner_bank_id')
+            })
+
+            if vals['customer'].country_id.code == 'NL':
+                constraints.update({
+                    # [NL-R-004] For suppliers in the Netherlands, if the customer is in the Netherlands, the customer
+                    # address (cac:AccountingCustomerParty/cac:Party/cac:PostalAddress) MUST contain the street name
+                    # (cbc:StreetName), the city (cbc:CityName) and post code (cbc:PostalZone)
+                    'nl_r_004_street': self._check_required_fields(vals['customer'], 'street'),
+                    'nl_r_004_city': self._check_required_fields(vals['customer'], 'city'),
+                    'nl_r_004_zip': self._check_required_fields(vals['customer'], 'zip'),
+
+                    # [NL-R-005] For suppliers in the Netherlands, if the customer is in the Netherlands,
+                    # the customer’s legal entity identifier MUST be either a KVK or OIN number (schemeID 0106 or 0190)
+                    'nl_r_005': _(
+                        "The customer %s must have a KVK or OIN number.",
+                        vals['customer'].display_name
+                    ) if 'l10n_nl_oin' not in vals['customer']._fields or 'l10n_nl_kvk' not in vals['customer']._fields else '',
+                })
+
+        if vals['supplier'].country_id.code == 'NO':
+            vat = vals['supplier'].vat
+            constraints.update({
+                # NO-R-001: For Norwegian suppliers, a VAT number MUST be the country code prefix NO followed by a
+                # valid Norwegian organization number (nine numbers) followed by the letters MVA.
+                # Note: mva.is_valid("179728982MVA") is True while it lacks the NO prefix
+                'no_r_001': _(
+                    "The VAT number of the supplier does not seem to be valid. It should be of the form: NO179728982MVA."
+                ) if not mva.is_valid(vat) or len(vat) != 14 or vat[:2] != 'NO' or vat[-3:] != 'MVA' else "",
+
+                'no_supplier_bronnoysund': _(
+                    "The supplier %s must have a Bronnoysund company registry.",
+                    vals['supplier'].display_name
+                ) if 'l10n_no_bronnoysund_number' not in vals['supplier']._fields or not vals['supplier'].l10n_no_bronnoysund_number else "",
+            })
+        if vals['customer'].country_id.code == 'NO':
+            constraints.update({
+                'no_customer_bronnoysund': _(
+                    "The supplier %s must have a Bronnoysund company registry.",
+                    vals['customer'].display_name
+                ) if 'l10n_no_bronnoysund_number' not in vals['customer']._fields or not vals['customer'].l10n_no_bronnoysund_number else "",
+            })
+
+        return constraints

--- a/None
+++ b/addons/account_edi_ubl_cii/models/account_edi_xml_ubl_efff.py
@@ -0,0 +1,23 @@
+# -*- coding: utf-8 -*-
+
+from odoo import models
+
+import re
+
+
+class AccountEdiXmlUBLEFFF(models.AbstractModel):
+    _inherit = "account.edi.xml.ubl_20"
+    _name = 'account.edi.xml.ubl_efff'
+    _description = "E-FFF (BE)"
+
+    # -------------------------------------------------------------------------
+    # EXPORT
+    # -------------------------------------------------------------------------
+
+    def _export_invoice_filename(self, invoice):
+        # official naming convention
+        vat = invoice.company_id.partner_id.commercial_partner_id.vat
+        return 'efff_%s%s%s.xml' % (vat or '', '_' if vat else '', re.sub(r'[\W_]', '', invoice.name))
+
+    def _export_invoice_ecosio_schematrons(self):
+        return None

--- a/None
+++ b/addons/account_edi_ubl_cii/models/account_edi_xml_ubl_nlcius.py
@@ -0,0 +1,87 @@
+# -*- coding: utf-8 -*-
+
+from odoo import models
+
+
+class AccountEdiXmlUBLNL(models.AbstractModel):
+    _inherit = "account.edi.xml.ubl_bis3"
+    _name = 'account.edi.xml.ubl_nl'
+    _description = "SI-UBL 2.0 (NLCIUS)"
+
+    """
+    SI-UBL 2.0 (NLCIUS) and UBL Bis 3 are 2 different formats used in the Netherlands.
+    (source: https://github.com/peppolautoriteit-nl/publications/tree/master/NLCIUS-PEPPOLBIS-Differences)
+    NLCIUS defines a set of rules
+    (source: https://www.softwarepakketten.nl/wiki_uitleg/60&bronw=7/Nadere_specificaties_EN_16931_1_norm_voor_de_Europese_kernfactuur.htm)
+    Fortunately, some of these rules are already present in UBL Bis 3, but some are missing.
+
+    For instance, Bis 3 states that the customizationID should be
+    "urn:cen.eu:en16931:2017#compliant#urn:fdc:peppol.eu:2017:poacc:billing:3.0".
+    while in NLCIUS:
+    "urn:cen.eu:en16931:2017#compliant#urn:fdc:nen.nl:nlcius:v1.0".
+
+    Bis 3 and NLCIUS are thus incompatible. Hence, the two separate formats and the additional rules in this file.
+
+    The trick is to understand which rules are only NLCIUS specific and which are applied to the Bis 3 format.
+    """
+
+    # -------------------------------------------------------------------------
+    # EXPORT
+    # -------------------------------------------------------------------------
+
+    def _export_invoice_filename(self, invoice):
+        return f"{invoice.name.replace('/', '_')}_nlcius.xml"
+
+    def _export_invoice_ecosio_schematrons(self):
+        return {
+            'invoice': 'org.simplerinvoicing:invoice:2.0.3.3',
+            'credit_note': 'org.simplerinvoicing:creditnote:2.0.3.3',
+        }
+
+    def _get_tax_category_list(self, invoice, taxes):
+        # EXTENDS account.edi.xml.ubl_bis3
+        vals_list = super()._get_tax_category_list(invoice, taxes)
+        for tax in vals_list:
+            # [BR-NL-35] The use of a tax exemption reason code (cac:TaxTotal/cac:TaxSubtotal/cac:TaxCategory
+            # /cbc:TaxExemptionReasonCode) is not recommended
+            tax.pop('tax_exemption_reason_code')
+        return vals_list
+
+    def _get_partner_address_vals(self, partner):
+        # EXTENDS account.edi.xml.ubl_bis3
+        vals = super()._get_partner_address_vals(partner)
+        # [BR-NL-28] The use of a country subdivision (cac:AccountingCustomerParty/cac:Party/cac:PostalAddress
+        # /cbc:CountrySubentity) is not recommended
+        vals.pop('country_subentity')
+        return vals
+
+    def _get_invoice_line_allowance_vals_list(self, line):
+        # EXTENDS account.edi.xml.ubl_bis3
+        vals_list = super()._get_invoice_line_allowance_vals_list(line)
+        # [BR-NL-32] Use of Discount reason code ( AllowanceChargeReasonCode ) is not recommended.
+        # [BR-EN-34] Use of Charge reason code ( AllowanceChargeReasonCode ) is not recommended.
+        # Careful ! [BR-42]-Each Invoice line allowance (BG-27) shall have an Invoice line allowance reason (BT-139)
+        # or an Invoice line allowance reason code (BT-140).
+        for vals in vals_list:
+            if vals.get('allowance_charge_reason'):
+                vals.pop('allowance_charge_reason_code')
+        return vals_list
+
+    def _get_invoice_payment_means_vals_list(self, invoice):
+        # EXTENDS account.edi.xml.ubl_bis3
+        vals_list = super()._get_invoice_payment_means_vals_list(invoice)
+        # [BR-NL-29] The use of a payment means text (cac:PaymentMeans/cbc:PaymentMeansCode/@name) is not recommended
+        for vals in vals_list:
+            vals.pop('payment_means_code_attrs')
+        return vals_list
+
+    def _export_invoice_vals(self, invoice):
+        # EXTENDS account.edi.xml.ubl_bis3
+        vals = super()._export_invoice_vals(invoice)
+
+        vals['vals']['customization_id'] = 'urn:cen.eu:en16931:2017#compliant#urn:fdc:nen.nl:nlcius:v1.0'
+
+        # [BR-NL-24] Use of previous invoice date ( IssueDate ) is not recommended.
+        # vals['vals'].pop('issue_date')  # careful, this causes other errors from the validator...
+
+        return vals

--- a/None
+++ b/addons/account_edi_ubl_cii/models/account_edi_xml_ubl_xrechnung.py
@@ -0,0 +1,43 @@
+# -*- coding: utf-8 -*-
+from odoo import models
+
+
+class AccountEdiXmlUBLDE(models.AbstractModel):
+    _inherit = "account.edi.xml.ubl_bis3"
+    _name = 'account.edi.xml.ubl_de'
+    _description = "BIS3 DE (XRechnung)"
+
+    # -------------------------------------------------------------------------
+    # EXPORT
+    # -------------------------------------------------------------------------
+
+    def _export_invoice_filename(self, invoice):
+        return f"{invoice.name.replace('/', '_')}_ubl_de.xml"
+
+    def _export_invoice_ecosio_schematrons(self):
+        return {
+            'invoice': 'de.xrechnung:ubl-invoice:2.2.0',
+            'credit_note': 'de.xrechnung:ubl-creditnote:2.2.0',
+        }
+
+    def _export_invoice_vals(self, invoice):
+        # EXTENDS account.edi.xml.ubl_bis3
+        vals = super()._export_invoice_vals(invoice)
+
+        vals['vals'].update({
+            'customization_id': 'urn:cen.eu:en16931:2017#compliant#urn:xoev-de:kosit:standard:xrechnung_2.2#conformant#urn:xoev-de:kosit:extension:xrechnung_2.2',
+            'buyer_reference': invoice.commercial_partner_id.name,
+        })
+
+        return vals
+
+    def _export_invoice_constraints(self, invoice, vals):
+        # EXTENDS account.edi.xml.ubl_bis3
+        constraints = super()._export_invoice_constraints(invoice, vals)
+
+        constraints.update({
+            'bis3_de_supplier_telephone_required': self._check_required_fields(vals['supplier'], ['phone', 'mobile']),
+            'bis3_de_supplier_electronic_mail_required': self._check_required_fields(vals['supplier'], 'email'),
+        })
+
+        return constraints

--- a/None
+++ b/addons/account_edi_ubl_cii/models/ir_actions_report.py
@@ -0,0 +1,63 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from odoo import models
+from odoo.tools import cleanup_xml_node
+
+from lxml import etree
+import base64
+from xml.sax.saxutils import escape, quoteattr
+
+
+class IrActionsReport(models.Model):
+    _inherit = 'ir.actions.report'
+
+    def _add_pdf_into_invoice_xml(self, invoice, stream_data):
+        for edi_attachment in invoice.edi_document_ids.attachment_id:
+            old_xml = base64.b64decode(edi_attachment.with_context(bin_size=False).datas, validate=True)
+            tree = etree.fromstring(old_xml)
+            anchor_elements = tree.xpath("//*[local-name()='AccountingSupplierParty']")
+            additional_document_elements = tree.xpath("//*[local-name()='AdditionalDocumentReference']")
+            # with this clause, we ensure the xml are only postprocessed once (even when the invoice is reset to
+            # draft then validated again)
+            if anchor_elements and not additional_document_elements:
+                pdf_stream = stream_data['stream']
+                pdf_content_b64 = base64.b64encode(pdf_stream.getvalue()).decode()
+                pdf_name = '%s.pdf' % invoice.name.replace('/', '_')
+                to_inject = '''
+                    <cac:AdditionalDocumentReference
+                        xmlns="urn:oasis:names:specification:ubl:schema:xsd:Invoice-2"
+                        xmlns:cbc="urn:oasis:names:specification:ubl:schema:xsd:CommonBasicComponents-2"
+                        xmlns:cac="urn:oasis:names:specification:ubl:schema:xsd:CommonAggregateComponents-2">
+                        <cbc:ID>%s</cbc:ID>
+                        <cac:Attachment>
+                            <cbc:EmbeddedDocumentBinaryObject mimeCode="application/pdf" filename=%s>
+                                %s
+                            </cbc:EmbeddedDocumentBinaryObject>
+                        </cac:Attachment>
+                    </cac:AdditionalDocumentReference>
+                ''' % (escape(pdf_name), quoteattr(pdf_name), pdf_content_b64)
+
+                anchor_index = tree.index(anchor_elements[0])
+                tree.insert(anchor_index, etree.fromstring(to_inject))
+                new_xml = etree.tostring(cleanup_xml_node(tree))
+                edi_attachment.write({
+                    'res_model': 'account.move',
+                    'res_id': invoice.id,
+                    'datas': base64.b64encode(new_xml),
+                    'mimetype': 'application/xml',
+                })
+
+    def _render_qweb_pdf_prepare_streams(self, data, res_ids=None):
+        # EXTENDS base
+        # Add the pdf report in the XML as base64 string.
+        collected_streams = super()._render_qweb_pdf_prepare_streams(data, res_ids=res_ids)
+
+        if collected_streams \
+                and res_ids \
+                and self.report_name in ('account.report_invoice_with_payments', 'account.report_invoice'):
+            for res_id, stream_data in collected_streams.items():
+                invoice = self.env['account.move'].browse(res_id)
+                self._add_pdf_into_invoice_xml(invoice, stream_data)
+
+        return collected_streams
