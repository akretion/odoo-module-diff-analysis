PR: https://github.com/odoo/odoo/pull/163497

From: f7709de7ae6267457b0c32f69a0e89457d180f6f
From: Mohammad Abdulmoneim
Date: 2024-05-23 12:34:56

Structural Changes: 6
Total Changes: 50

[IMP] delivery: add criteria to filter shippping methods

This commit adds some fields to `delivery_carrier` model to enable users
to control shipping methods availability in backend or on eCommerce. The
new filters (fields) are: maximum weight, maximum volume, must have tags
and excluded tags. max weight and volume works as expected and are
determined based on the total weight or volume of the order. Must have
tags are a list of tags that must exist in at least one product in the
order. Excluded tags are a list of tags that none of the products
in the order could have any of them.

Task-3691489

closes odoo/odoo#163497

Signed-off-by: Arnold Moyaux (arm) <arm@odoo.com>

================================= pseudo patch: =================================

--- a/addons/delivery/models/delivery_carrier.py
+++ b/addons/delivery/models/delivery_carrier.py
@@ -64,6 +64,16 @@ class DeliveryCarrier(models.Model):
     zip_prefix_ids = fields.Many2many(
         'delivery.zip.prefix', 'delivery_zip_prefix_rel', 'carrier_id', 'zip_prefix_id', 'Zip Prefixes',
         help="Prefixes of zip codes that this carrier applies to. Note that regular expressions can be used to support countries with varying zip code lengths, i.e. '$' can be added to end of prefix to match the exact zip (e.g. '100$' will only match '100' and not '1000')")
+
+    max_weight = fields.Float('Max Weight', help="If the total weight of the order is over this weight, the method won't be available.")
+    weight_uom_name = fields.Char(string='Weight unit of measure label', compute='_compute_weight_uom_name')
+    max_volume = fields.Float('Max Volume', help="If the total volume of the order is over this volume, the method won't be available.")
+    volume_uom_name = fields.Char(string='Volume unit of measure label', compute='_compute_volume_uom_name')
+    must_have_tag_ids = fields.Many2many(string='Must Have Tags', comodel_name='product.tag', relation='product_tag_delivery_carrier_must_have_rel',
+                                         help="The method is available only if at least one product of the order has one of these tags.")
+    excluded_tag_ids = fields.Many2many(string='Excluded Tags', comodel_name='product.tag', relation='product_tag_delivery_carrier_excluded_rel',
+                                        help="The method is NOT available if at least one product of the order has one of these tags.")
+
     carrier_description = fields.Text(
         'Carrier Description', translate=True,
         help="A description of the delivery method that you want to communicate to your customers on the Sales Order and sales confirmation email."
@@ -98,6 +108,20 @@ class DeliveryCarrier(models.Model):
         ('shipping_insurance_is_percentage', 'CHECK(shipping_insurance >= 0 AND shipping_insurance <= 100)', "The shipping insurance must be a percentage between 0 and 100."),
     ]
 
+    @api.constrains('must_have_tag_ids', 'excluded_tag_ids')
+    def _check_tags(self):
+        for carrier in self:
+            if carrier.must_have_tag_ids & carrier.excluded_tag_ids:
+                raise UserError(_("Carrier %s cannot have the same tag in both Must Have Tags and Excluded Tags.") % carrier.name)
+
+    def _compute_weight_uom_name(self):
+        for carrier in self:
+            carrier.weight_uom_name = self.env['product.template']._get_weight_uom_name_from_ir_config_parameter()
+
+    def _compute_volume_uom_name(self):
+        for carrier in self:
+            carrier.volume_uom_name = self.env['product.template']._get_volume_uom_name_from_ir_config_parameter()
+
     @api.depends('delivery_type')
     def _compute_can_generate_return(self):
         for carrier in self:
@@ -132,7 +156,7 @@ class DeliveryCarrier(models.Model):
     def _is_available_for_order(self, order):
         self.ensure_one()
         order.ensure_one()
-        if not self._match_address(order.partner_shipping_id):
+        if not self._match(order.partner_shipping_id, order):
             return False
 
         if self.delivery_type == 'base_on_rule':
@@ -140,8 +164,12 @@ class DeliveryCarrier(models.Model):
 
         return True
 
-    def available_carriers(self, partner):
-        return self.filtered(lambda c: c._match_address(partner))
+    def available_carriers(self, partner, order):
+        return self.filtered(lambda c: c._match(partner, order))
+
+    def _match(self, partner, order):
+        self.ensure_one()
+        return self._match_address(partner) and self._match_must_have_tags(order) and self._match_excluded_tags(order) and self._match_weight(order) and self._match_volume(order)
 
     def _match_address(self, partner):
         self.ensure_one()
@@ -155,6 +183,22 @@ class DeliveryCarrier(models.Model):
                 return False
         return True
 
+    def _match_must_have_tags(self, order):
+        self.ensure_one()
+        return all(tag in order.order_line.product_id.all_product_tag_ids for tag in self.must_have_tag_ids)
+
+    def _match_excluded_tags(self, order):
+        self.ensure_one()
+        return not any(tag in order.order_line.product_id.all_product_tag_ids for tag in self.excluded_tag_ids)
+
+    def _match_weight(self, order):
+        self.ensure_one()
+        return not self.max_weight or sum(order_line.product_id.weight * order_line.product_qty for order_line in order.order_line) <= self.max_weight
+
+    def _match_volume(self, order):
+        self.ensure_one()
+        return not self.max_volume or sum(order_line.product_id.volume * order_line.product_qty for order_line in order.order_line) <= self.max_volume
+
     @api.onchange('integration_level')
     def _onchange_integration_level(self):
         if self.integration_level == 'rate':
