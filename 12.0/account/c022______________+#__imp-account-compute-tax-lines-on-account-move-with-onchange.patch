PR: https://github.com/odoo/odoo/pull/

From: d49ab568a2cc5231ac12267a9e74eaf16ca45f9e
From: Laurent Smet
Date: 2018-06-08 12:23:14

Structural Changes: 3
Total Changes: 150

[IMP] account: compute tax lines on account.move with onchange

Allow the user to set taxes on lines when creating manually a new journal entry, and tax lines will be computed automatically thanks to an onchange based on new unstored fields.

Was task: 33802
Was PR #19029

================================= pseudo patch: =================================

--- a/addons/account/models/account.py
+++ b/addons/account/models/account.py
@@ -885,6 +885,12 @@ class AccountTax(models.Model):
         default = dict(default or {}, name=_("%s (Copy)") % self.name)
         return super(AccountTax, self).copy(default=default)
 
+    @api.depends('name', 'type_tax_use')
+    def name_get(self):
+        if not self._context.get('append_type_to_tax_name'):
+            return super(AccountTax, self).name_get()
+        return [(tax.id, '%s (%s)' % (tax.name, tax.type_tax_use)) for tax in self]
+
     @api.model
     def _name_search(self, name, args=None, operator='ilike', limit=100, name_get_uid=None):
         """ Returns a list of tuples containing id, name, as internally it is called {def name_get}

--- a/addons/account/models/account_move.py
+++ b/addons/account/models/account_move.py
@@ -115,6 +115,142 @@ class AccountMove(models.Model):
     auto_reverse = fields.Boolean(string='Reverse Automatically', default=False, help='If this checkbox is ticked, this entry will be automatically reversed at the reversal date you defined.')
     reverse_date = fields.Date(string='Reversal Date', help='Date of the reverse accounting entry.')
     reverse_entry_id = fields.Many2one('account.move', String="Reverse entry", store=True, readonly=True)
+    tax_type_domain = fields.Char(store=False, help='Technical field used to have a dynamic taxes domain on the form view.')
+
+    @api.onchange('journal_id')
+    def _onchange_journal_id(self):
+        self.tax_type_domain = self.journal_id.type if self.journal_id.type in ('sale', 'purchase') else None
+
+    @api.onchange('line_ids')
+    def _onchange_line_ids(self):
+        '''Compute additional lines corresponding to the taxes set on the line_ids.
+
+        For example, add a line with 1000 debit and 15% tax, this onchange will add a new
+        line with 150 debit.
+        '''
+        def _str_to_list(string):
+            #remove heading and trailing brackets and return a list of int. This avoid calling safe_eval on untrusted field content
+            string = string[1:-1]
+            if string:
+                return [int(x) for x in string.split(',')]
+            return []
+
+        def _build_grouping_key(line):
+            #build a string containing all values used to create the tax line
+            return str(line.tax_ids.ids) + '-' + str(line.analytic_tag_ids.ids) + '-' + (line.analytic_account_id and str(line.analytic_account_id.id) or '')
+
+        def _parse_grouping_key(line):
+            # Retrieve values computed the last time this method has been run.
+            if not line.tax_line_grouping_key:
+                return {'tax_ids': [], 'tag_ids': [], 'analytic_account_id': False}
+            tax_str, tags_str, analytic_account_str = line.tax_line_grouping_key.split('-')
+            return {
+                'tax_ids': _str_to_list(tax_str),
+                'tag_ids': _str_to_list(tags_str),
+                'analytic_account_id': analytic_account_str and int(analytic_account_str) or False,
+            }
+
+        def _find_existing_tax_line(line_ids, tax, tag_ids, analytic_account_id):
+            if tax.analytic:
+                return line_ids.filtered(lambda x: x.tax_line_id == tax and x.analytic_tag_ids.ids == tag_ids and x.analytic_account_id.id == analytic_account_id)
+            return line_ids.filtered(lambda x: x.tax_line_id == tax)
+
+        def _get_lines_to_sum(line_ids, tax, tag_ids, analytic_account_id):
+            if tax.analytic:
+                return line_ids.filtered(lambda x: tax in x.tax_ids and x.analytic_tag_ids.ids == tag_ids and x.analytic_account_id.id == analytic_account_id)
+            return line_ids.filtered(lambda x: tax in x.tax_ids)
+
+        def _get_tax_account(tax, amount):
+            if tax.tax_exigibility == 'on_payment' and tax.cash_basis_account:
+                return tax.cash_basis_account
+            if tax.type_tax_use == 'purchase':
+                return tax.refund_account_id if amount < 0 else tax.account_id
+            return tax.refund_account_id if amount >= 0 else tax.account_id
+
+        # Cache the already computed tax to avoid useless recalculation.
+        processed_taxes = self.env['account.tax']
+
+        self.ensure_one()
+        for line in self.line_ids.filtered(lambda x: x.recompute_tax_line):
+            # Retrieve old field values.
+            parsed_key = _parse_grouping_key(line)
+
+            # Unmark the line.
+            line.recompute_tax_line = False
+
+            # Manage group of taxes.
+            group_taxes = line.tax_ids.filtered(lambda t: t.amount_type == 'group')
+            children_taxes = group_taxes.mapped('children_tax_ids')
+            if children_taxes:
+                line.tax_ids += children_taxes - line.tax_ids
+                # Because the taxes on the line changed, we need to recompute them.
+                processed_taxes -= children_taxes
+
+            # Get the taxes to process.
+            taxes = self.env['account.tax'].browse(parsed_key['tax_ids'])
+            taxes += line.tax_ids.filtered(lambda t: t not in taxes)
+            taxes += children_taxes.filtered(lambda t: t not in taxes)
+            to_process_taxes = (taxes - processed_taxes).filtered(lambda t: t.amount_type != 'group')
+            processed_taxes += to_process_taxes
+
+            # Process taxes.
+            for tax in to_process_taxes:
+                tax_line = _find_existing_tax_line(self.line_ids, tax, parsed_key['tag_ids'], parsed_key['analytic_account_id'])
+                lines_to_sum = _get_lines_to_sum(self.line_ids, tax, parsed_key['tag_ids'], parsed_key['analytic_account_id'])
+
+                if not lines_to_sum:
+                    # Drop tax line because the originator tax is no longer used.
+                    self.line_ids -= tax_line
+                    continue
+
+                balance = sum([l.balance for l in lines_to_sum])
+
+                # Compute the tax amount one by one.
+                quantity = len(lines_to_sum) if tax.amount_type == 'fixed' else 1
+                taxes_vals = tax.compute_all(balance,
+                    quantity=quantity, currency=line.currency_id, product=line.product_id, partner=line.partner_id)
+
+                if tax_line:
+                    # Update the existing tax_line.
+                    if balance:
+                        # Update the debit/credit amount according to the new balance.
+                        if taxes_vals.get('taxes'):
+                            amount = taxes_vals['taxes'][0]['amount']
+                            account = _get_tax_account(tax, amount) or line.account_id
+                            tax_line.debit = amount > 0 and amount or 0.0
+                            tax_line.credit = amount < 0 and -amount or 0.0
+                            tax_line.account_id = account
+                    else:
+                        # Reset debit/credit in case of the originator line is temporary set to 0 in both debit/credit.
+                        tax_line.debit = tax_line.credit = 0.0
+                elif taxes_vals.get('taxes'):
+                    # Create a new tax_line.
+
+                    amount = taxes_vals['taxes'][0]['amount']
+                    account = _get_tax_account(tax, amount) or line.account_id
+                    tax_vals = taxes_vals['taxes'][0]
+
+                    name = tax_vals['name']
+                    line_vals = {
+                        'account_id': account.id,
+                        'name': name,
+                        'tax_line_id': tax_vals['id'],
+                        'partner_id': line.partner_id.id,
+                        'debit': amount > 0 and amount or 0.0,
+                        'credit': amount < 0 and -amount or 0.0,
+                        'analytic_account_id': line.analytic_account_id.id if tax.analytic else False,
+                        'analytic_tag_ids': line.analytic_tag_ids.ids if tax.analytic else False,
+                        'move_id': self.id,
+                        'tax_exigible': tax.tax_exigibility == 'on_invoice',
+                        'company_id': self.company_id.id,
+                        'company_currency_id': self.company_id.currency_id.id,
+                    }
+                    # N.B. currency_id/amount_currency are not set because if we have two lines with the same tax
+                    # and different currencies, we have no idea which currency set on this line.
+                    self.env['account.move.line'].new(line_vals)
+
+            # Keep record of the values used as taxes the last time this method has been run.
+            line.tax_line_grouping_key = _build_grouping_key(line)
 
     @api.model
     def fields_view_get(self, view_id=None, view_type='form', toolbar=False, submenu=False):
@@ -304,6 +440,11 @@ class AccountMoveLine(models.Model):
     _description = "Journal Item"
     _order = "date desc, id desc"
 
+    @api.onchange('debit', 'credit', 'tax_ids', 'analytic_account_id', 'analytic_tag_ids')
+    def onchange_tax_ids_create_aml(self):
+        for line in self:
+            line.recompute_tax_line = True
+
     @api.model_cr
     def init(self):
         """ change index on partner_id to a multi-column index on (partner_id, ref), the new index will behave in the
@@ -484,6 +625,9 @@ class AccountMoveLine(models.Model):
     #Needed for setup, as a decoration attribute needs to know that for a tree view in one of the popups, and there's no way to reference directly a xml id from there
     is_unaffected_earnings_line = fields.Boolean(string="Is Unaffected Earnings Line", compute="_compute_is_unaffected_earnings_line", help="Tells whether or not this line belongs to an unaffected earnings account")
 
+    recompute_tax_line = fields.Boolean(store=False, help="Technical field used to know if the tax_ids field has been modified in the UI.")
+    tax_line_grouping_key = fields.Char(store=False, string='Old Taxes', help="Technical field used to store the old values of fields used to compute tax lines (in account.move form view) between the moment the user changed it and the moment the ORM reflects that change in its one2many")
+
     _sql_constraints = [
         ('credit_debit1', 'CHECK (credit*debit=0)', 'Wrong credit or debit value in accounting entry !'),
         ('credit_debit2', 'CHECK (credit+debit>=0)', 'Wrong credit or debit value in accounting entry !'),
