PR: https://github.com/odoo/odoo/pull/182259

From: 45b86c79439f6ba6b750bf8b96f0e23d2ba8af3c
From: Laurent Smet
Date: 2024-10-01 13:28:11

Breaking data model changes scores: del:4 + add:0, change matches:
-    tax_key = fields.Binary(compute='_compute_tax_key', exportable=False)
-    compute_all_tax = fields.Binary(compute='_compute_all_tax', exportable=False)
-    compute_all_tax_dirty = fields.Boolean(compute='_compute_all_tax')
-    total_tax_factor = fields.Float(compute='_compute_total_tax_factor')

Total Changes: 2915

[IMP] account,*: Fully manage the round globally

The creation of tax lines is made with 2 duplicated mechanisms:
_get_generation_dict_from_base_line is the method saying the granularity of your tax lines.
This method is used by everyone using the compute_taxes method.
Since V16, a custom similar mechanism has been duplicated on invoices in _compute_all_tax in account_move_line.py
=> We should have only one mechanism.

Then, another problem is the whole logic to compute the round_globally is wrong.

Instead of:
* compute the tax values per grouping key per tax repartition line per line
* aggregate the amounts
* round

we should:
* compute the tax values per tax and per line
* round
* dispatch the amounts to the repartition lines.

Let's take some examples:
Suppose 3 lines of:
price_unit = 33.33, tax = 10%
price_unit = 33.33, tax = 10%
price_unit = 33.34, tax = 10%

Using round_per_line, each line will compute 3.33 as tax so a total of 9.99.
Using round_globally, each line will respectively compute a tax amount of 3.333, 3.333, 3.334 so
a total of 10.0.
However, depending the current grouping key to compute the tax lines (each one corresponding to a
repartition line), the computation could be different.
Suppose the analytic checkbox is ticked on the tax and the base lines are:
price_unit = 33.33, tax = 10%, analytic_distribution = 100% on account_A
price_unit = 33.33, tax = 10%, analytic_distribution = 100% on account_B
price_unit = 33.34, tax = 10%, analytic_distribution = 100% on account_C

In this specific case, the total of taxes will be 3 x 3.33 = 9.99 because it will generate 3
tax lines, one for each analytic distribution.

Another problem is when dealing with price included taxes.
Suppose two lines:
price_unit = 21.53, tax = 21% incl
price_unit = 21.53, tax = 21% incl

Each line will compute a tax excluded amount of round(21.53 / 1.21) = 17.79
So the total untaxed amount is computed as 17.79 x 2 = 35.58.
However, since the tax is included in price, the untaxed amount should be
round(21.53 * 2 / 1.21) = 35.59
It means there is 0.01 that need to be distributed on invoice's journal items.

closes odoo/odoo#182259

Task-id: 3725705
X-original-commit: d0e7be7832672d476f1b289af52d3a425990d719
Related: odoo/enterprise#71159
Signed-off-by: Christophe Monniez (moc) <moc@odoo.com>
Signed-off-by: Laurent Smet (las) <las@odoo.com>

================================= pseudo patch: =================================

--- a/addons/account/models/account_move.py
+++ b/addons/account/models/account_move.py
@@ -16,7 +16,6 @@ from textwrap import shorten
 from odoo import api, fields, models, _, Command, SUPERUSER_ID, modules, tools
 from odoo.tools.sql import column_exists, create_column
 from odoo.addons.account.tools import format_structured_reference_iso
-from odoo.addons.base_import.models.base_import import FILE_TYPE_DICT
 from odoo.exceptions import UserError, ValidationError, AccessError, RedirectWarning
 from odoo.osv import expression
 from odoo.tools import (
@@ -1195,6 +1194,7 @@ class AccountMove(models.Model):
 
     @api.depends('invoice_payment_term_id', 'invoice_date', 'currency_id', 'amount_total_in_currency_signed', 'invoice_date_due')
     def _compute_needed_terms(self):
+        AccountTax = self.env['account.tax']
         for invoice in self.with_context(bin_size=False):
             is_draft = invoice.id != invoice._origin.id
             invoice.needed_terms = {}
@@ -1204,13 +1204,19 @@ class AccountMove(models.Model):
                 if invoice.invoice_payment_term_id:
                     if is_draft:
                         tax_amount_currency = 0.0
+                        tax_amount = tax_amount_currency
                         untaxed_amount_currency = 0.0
-                        for line in invoice.invoice_line_ids:
-                            untaxed_amount_currency += line.price_subtotal
-                            for tax_result in (line.compute_all_tax or {}).values():
-                                tax_amount_currency += -sign * tax_result.get('amount_currency', 0.0)
                         untaxed_amount = untaxed_amount_currency
-                        tax_amount = tax_amount_currency
+                        sign = invoice.direction_sign
+                        base_lines, _tax_lines = invoice._get_rounded_base_and_tax_lines(round_from_tax_lines=False)
+                        AccountTax._add_accounting_data_in_base_lines_tax_details(base_lines, invoice.company_id, include_caba_tags=invoice.always_tax_exigible)
+                        tax_results = AccountTax._prepare_tax_lines(base_lines, invoice.company_id)
+                        for base_line, to_update in tax_results['base_lines_to_update']:
+                            untaxed_amount_currency += sign * to_update['amount_currency']
+                            untaxed_amount += sign * to_update['balance']
+                        for tax_line_vals in tax_results['tax_lines_to_add']:
+                            tax_amount_currency += sign * tax_line_vals['amount_currency']
+                            tax_amount += sign * tax_line_vals['balance']
                     else:
                         tax_amount_currency = invoice.amount_tax * sign
                         tax_amount = invoice.amount_tax_signed
@@ -1372,6 +1378,158 @@ class AccountMove(models.Model):
             else:
                 move.invoice_payments_widget = False
 
+    def _prepare_product_base_line_for_taxes_computation(self, product_line):
+        """ Convert an account.move.line having display_type='product' into a base line for the taxes computation.
+
+        :param product_line: An account.move.line.
+        :return: A base line returned by '_prepare_base_line_for_taxes_computation'.
+        """
+        self.ensure_one()
+        is_invoice = self.is_invoice(include_receipts=True)
+        sign = self.direction_sign if is_invoice else 1
+        if is_invoice:
+            rate = self.invoice_currency_rate
+        else:
+            rate = (abs(product_line.amount_currency) / abs(product_line.balance)) if product_line.balance else 0.0
+
+        return self.env['account.tax']._prepare_base_line_for_taxes_computation(
+            product_line,
+            price_unit=product_line.price_unit if is_invoice else product_line.amount_currency,
+            quantity=product_line.quantity if is_invoice else 1.0,
+            discount=product_line.discount if is_invoice else 0.0,
+            rate=rate,
+            sign=sign,
+            special_mode=False if is_invoice else 'total_excluded',
+        )
+
+    def _prepare_epd_base_line_for_taxes_computation(self, epd_line):
+        """ Convert an account.move.line having display_type='epd' into a base line for the taxes computation.
+
+        :param epd_line: An account.move.line.
+        :return: A base line returned by '_prepare_base_line_for_taxes_computation'.
+        """
+        self.ensure_one()
+        sign = self.direction_sign
+        rate = self.invoice_currency_rate
+
+        return self.env['account.tax']._prepare_base_line_for_taxes_computation(
+            epd_line,
+            price_unit=sign * epd_line.amount_currency,
+            quantity=1.0,
+            sign=sign,
+            special_mode='total_excluded',
+            special_type='early_payment',
+
+            is_refund=self.move_type in ('out_refund', 'in_refund'),
+            rate=rate,
+        )
+
+    def _prepare_epd_base_lines_for_taxes_computation_from_base_lines(self, base_lines):
+        """ Anticipate the epd lines to be generated from the base lines passed as parameter.
+        When the record is in draft (not saved), the accounting items are not there so we can't
+        call '_prepare_epd_base_line_for_taxes_computation'.
+
+        :param base_lines: The base lines generated by '_prepare_product_base_line_for_taxes_computation'.
+        :return: A list of base lines representing the epd lines.
+        """
+        self.ensure_one()
+        aggregated_results = self._sync_dynamic_line_needed_values(base_lines.mapped('epd_needed'))
+        sign = self.direction_sign
+        rate = self.invoice_currency_rate
+        epd_lines = []
+        for grouping_key, values in aggregated_results.items():
+            all_values = {**grouping_key, **values}
+            epd_lines.append(self.env['account.tax']._prepare_base_line_for_taxes_computation(
+                all_values,
+                id=grouping_key,
+                tax_ids=self.env['account.tax'].browse(all_values['tax_ids'][0][2]),
+                price_unit=sign * values['amount_currency'],
+                quantity=1.0,
+                currency_id=self.currency_id,
+                sign=1,
+                special_mode='total_excluded',
+                special_type='early_payment',
+
+                partner_id=self.commercial_partner_id,
+                account_id=self.env['account.account'].browse(all_values['account_id']),
+                is_refund=self.move_type in ('out_refund', 'in_refund'),
+                rate=rate,
+            ))
+        return epd_lines
+
+    def _prepare_cash_rounding_base_line_for_taxes_computation(self, cash_rounding_line):
+        """ Convert an account.move.line having display_type='rounding' into a base line for the taxes computation.
+
+        :param cash_rounding_line: An account.move.line.
+        :return: A base line returned by '_prepare_base_line_for_taxes_computation'.
+        """
+        self.ensure_one()
+        sign = self.direction_sign
+        rate = self.invoice_currency_rate
+
+        return self.env['account.tax']._prepare_base_line_for_taxes_computation(
+            cash_rounding_line,
+            price_unit=sign * cash_rounding_line.amount_currency,
+            quantity=1.0,
+            sign=sign,
+            special_mode='total_excluded',
+            special_type='cash_rounding',
+
+            is_refund=self.move_type in ('out_refund', 'in_refund'),
+            rate=rate,
+        )
+
+    def _prepare_tax_line_for_taxes_computation(self, tax_line):
+        """ Convert an account.move.line having display_type='tax' into a tax line for the taxes computation.
+
+        :param tax_line: An account.move.line.
+        :return: A tax line returned by '_prepare_tax_line_for_taxes_computation'.
+        """
+        self.ensure_one()
+        return self.env['account.tax']._prepare_tax_line_for_taxes_computation(
+            tax_line,
+            sign=self.direction_sign,
+        )
+
+    def _get_rounded_base_and_tax_lines(self, round_from_tax_lines=True):
+        """ Small helper to extract the base and tax lines for the taxes computation from the current move.
+        The move could be stored or not and could have some features generating extra journal items acting as
+        base lines for the taxes computation (e.g. epd, rounding lines).
+
+        :param round_from_tax_lines:    Indicate if the manual tax amounts of tax journal items should be kept or not.
+                                        It only works when the move is stored.
+        :return:                        A tuple <base_lines, tax_lines> for the taxes computation.
+        """
+        self.ensure_one()
+        AccountTax = self.env['account.tax']
+        is_invoice = self.is_invoice(include_receipts=True)
+
+        if self.id or not is_invoice:
+            base_amls = self.line_ids.filtered(lambda line: line.display_type == 'product')
+        else:
+            base_amls = self.invoice_line_ids.filtered(lambda line: line.display_type == 'product')
+        base_lines = [self._prepare_product_base_line_for_taxes_computation(line) for line in base_amls]
+
+        tax_lines = []
+        if self.id:
+            # The move is stored so we can add the early payment discount lines directly to reduce the
+            # tax amount without touching the untaxed amount.
+            epd_amls = self.line_ids.filtered(lambda line: line.display_type == 'epd')
+            base_lines += [self._prepare_epd_base_line_for_taxes_computation(line) for line in epd_amls]
+            cash_rounding_amls = self.line_ids \
+                .filtered(lambda line: line.display_type == 'rounding' and not line.tax_repartition_line_id)
+            base_lines += [self._prepare_cash_rounding_base_line_for_taxes_computation(line) for line in cash_rounding_amls]
+            AccountTax._add_tax_details_in_base_lines(base_lines, self.company_id)
+            tax_amls = self.line_ids.filtered('tax_repartition_line_id')
+            tax_lines = [self._prepare_tax_line_for_taxes_computation(tax_line) for tax_line in tax_amls]
+            AccountTax._round_base_lines_tax_details(base_lines, self.company_id, tax_lines=tax_lines if round_from_tax_lines else [])
+        else:
+            # The move is not stored yet so the only thing we have is the invoice lines.
+            base_lines += self._prepare_epd_base_lines_for_taxes_computation_from_base_lines(base_amls)
+            AccountTax._add_tax_details_in_base_lines(base_lines, self.company_id)
+            AccountTax._round_base_lines_tax_details(base_lines, self.company_id)
+        return base_lines, tax_lines
+
     @api.depends_context('lang')
     @api.depends(
         'invoice_line_ids.currency_rate',
@@ -1389,82 +1547,19 @@ class AccountMove(models.Model):
         """
         for move in self:
             if move.is_invoice(include_receipts=True):
-                base_lines = move.invoice_line_ids.filtered(lambda line: line.display_type == 'product')
-                base_line_values_list = [line._convert_to_tax_base_line_dict() for line in base_lines]
-                sign = move.direction_sign
-                if move.id:
-                    # The invoice is stored so we can add the early payment discount lines directly to reduce the
-                    # tax amount without touching the untaxed amount.
-                    base_line_values_list += [
-                        {
-                            **line._convert_to_tax_base_line_dict(),
-                            'handle_price_include': False,
-                            'quantity': 1.0,
-                            'price_unit': sign * line.amount_currency,
-                        }
-                        for line in move.line_ids.filtered(lambda line: line.display_type == 'epd')
-                    ]
-
-                kwargs = {
-                    'base_lines': base_line_values_list,
-                    'company': move.company_id,
-                    'currency': move.currency_id or move.journal_id.currency_id or move.company_id.currency_id,
-                }
-
-                if move.id:
-                    kwargs['tax_lines'] = [
-                        line._convert_to_tax_line_dict()
-                        for line in move.line_ids.filtered(lambda line: line.display_type == 'tax')
-                    ]
-                else:
-                    # In case the invoice isn't yet stored, the early payment discount lines are not there. Then,
-                    # we need to simulate them.
-                    epd_aggregated_values = {}
-                    for base_line in base_lines:
-                        if not base_line.epd_needed:
-                            continue
-                        for grouping_dict, values in base_line.epd_needed.items():
-                            epd_values = epd_aggregated_values.setdefault(grouping_dict, {'price_subtotal': 0.0})
-                            epd_values['price_subtotal'] += values['price_subtotal']
-
-                    for grouping_dict, values in epd_aggregated_values.items():
-                        taxes = None
-                        if grouping_dict.get('tax_ids'):
-                            taxes = self.env['account.tax'].browse(grouping_dict['tax_ids'][0][2])
-
-                        kwargs['base_lines'].append(self.env['account.tax']._convert_to_tax_base_line_dict(
-                            grouping_dict,
-                            partner=move.partner_id,
-                            currency=move.currency_id,
-                            taxes=taxes,
-                            price_unit=values['price_subtotal'],
-                            quantity=1.0,
-                            account=self.env['account.account'].browse(grouping_dict['account_id']),
-                            analytic_distribution=values.get('analytic_distribution'),
-                            price_subtotal=values['price_subtotal'],
-                            is_refund=move.move_type in ('out_refund', 'in_refund'),
-                            handle_price_include=False,
-                        ))
-                move.tax_totals = self.env['account.tax']._prepare_tax_totals(**kwargs)
-                if move.invoice_cash_rounding_id:
-                    rounding_amount = move.invoice_cash_rounding_id.compute_difference(move.currency_id, move.tax_totals['amount_total'])
-                    totals = move.tax_totals
-                    totals['display_rounding'] = True
-                    if rounding_amount:
-                        if move.invoice_cash_rounding_id.strategy == 'add_invoice_line':
-                            totals['rounding_amount'] = rounding_amount
-                            totals['formatted_rounding_amount'] = formatLang(self.env, totals['rounding_amount'], currency_obj=move.currency_id)
-                        elif move.invoice_cash_rounding_id.strategy == 'biggest_tax':
-                            if totals['subtotals_order']:
-                                max_tax_group = max((
-                                    tax_group
-                                    for tax_groups in totals['groups_by_subtotal'].values()
-                                    for tax_group in tax_groups
-                                ), key=lambda tax_group: tax_group['tax_group_amount'])
-                                max_tax_group['tax_group_amount'] += rounding_amount
-                                max_tax_group['formatted_tax_group_amount'] = formatLang(self.env, max_tax_group['tax_group_amount'], currency_obj=move.currency_id)
-                        totals['amount_total'] += rounding_amount
-                        totals['formatted_amount_total'] = formatLang(self.env, totals['amount_total'], currency_obj=move.currency_id)
+                base_lines, _tax_lines = move._get_rounded_base_and_tax_lines()
+                move.tax_totals = self.env['account.tax']._get_tax_totals_summary(
+                    base_lines=base_lines,
+                    currency=move.currency_id,
+                    company=move.company_id,
+                    cash_rounding=move.invoice_cash_rounding_id,
+                )
+                move.tax_totals['display_in_company_currency'] = (
+                    move.company_id.display_invoice_tax_company_currency
+                    and move.company_currency_id != move.currency_id
+                    and move.tax_totals['has_tax_groups']
+                    and move.is_sale_document(include_receipts=True)
+                )
             else:
                 # Non-invoice moves don't support that field (because of multicurrency: all lines of the invoice share the same currency)
                 move.tax_totals = None
@@ -1624,7 +1719,7 @@ class AccountMove(models.Model):
                            move.move_type == 'out_invoice' and \
                            move.company_id.account_use_credit_limit
             if show_warning:
-                total_field = 'amount_total' if move.currency_id == move.company_currency_id else 'amount_total_company_currency'
+                total_field = 'total_amount_currency' if move.currency_id == move.company_currency_id else 'total_amount'
                 current_amount = move.tax_totals[total_field]
                 move.partner_credit_warning = self._build_credit_warning_message(
                     move,
@@ -1728,7 +1823,7 @@ class AccountMove(models.Model):
             values["id"] = moves._origin.id or 0
             # The amount total depends on the field line_ids and is calculated upon saving, we needed a way to get it even when the
             # invoices has not been saved yet.
-            values['amount_total'] = self.tax_totals.get('amount_total', 0)
+            values['amount_total'] = self.tax_totals.get('total_amount_currency', 0)
             casted_values = SQL(', ').join(
                 SQL("%s::%s", value, SQL.identifier(moves._fields[field_name].column_type[0]))
                 for field_name, value in values.items()
@@ -1949,15 +2044,15 @@ class AccountMove(models.Model):
                     continue
                 invoice_totals = move.tax_totals
 
-                for amount_by_group_list in invoice_totals['groups_by_subtotal'].values():
-                    for amount_by_group in amount_by_group_list:
-                        tax_lines = move.line_ids.filtered(lambda line: line.tax_group_id.id == amount_by_group['tax_group_id'])
+                for subtotal in invoice_totals['subtotals']:
+                    for tax_group in subtotal['tax_groups']:
+                        tax_lines = move.line_ids.filtered(lambda line: line.tax_group_id.id == tax_group['id'])
 
                         if tax_lines:
                             first_tax_line = tax_lines[0]
                             tax_group_old_amount = sum(tax_lines.mapped('amount_currency'))
                             sign = -1 if move.is_inbound() else 1
-                            delta_amount = tax_group_old_amount * sign - amount_by_group['tax_group_amount']
+                            delta_amount = tax_group_old_amount * sign - tax_group['tax_amount_currency']
 
                             if not move.currency_id.is_zero(delta_amount):
                                 first_tax_line.amount_currency -= delta_amount * sign
@@ -2594,6 +2689,183 @@ class AccountMove(models.Model):
             if invoice.state != 'posted':
                 invoice._recompute_cash_rounding_lines()
 
+    @api.model
+    def _sync_dynamic_line_needed_values(self, values_list):
+        res = {}
+        for computed_needed in values_list:
+            if computed_needed is False:
+                continue  # there was an invalidation, let's hope nothing needed to be changed...
+            for key, values in computed_needed.items():
+                if key not in res:
+                    res[key] = dict(values)
+                else:
+                    ignore = True
+                    for fname in res[key]:
+                        if self.env['account.move.line']._fields[fname].type == 'monetary':
+                            res[key][fname] += values[fname]
+                            if res[key][fname]:
+                                ignore = False
+                    if ignore:
+                        del res[key]
+
+        # Convert float values to their "ORM cache" one to prevent different rounding calculations
+        for key, values in res.items():
+            move_id = key.get('move_id')
+            if not move_id:
+                continue
+            record = self.env['account.move'].browse(move_id)
+            for fname, current_value in values.items():
+                field = self.env['account.move.line']._fields[fname]
+                if isinstance(current_value, float):
+                    values[fname] = field.convert_to_cache(current_value, record)
+
+        return res
+
+    @contextmanager
+    def _sync_tax_lines(self, container):
+        AccountTax = self.env['account.tax']
+        fake_base_line = AccountTax._prepare_base_line_for_taxes_computation(None)
+
+        def get_base_lines(move):
+            return move.line_ids.filtered(lambda line: line.display_type in ('product', 'epd', 'rounding', 'cogs'))
+
+        def get_tax_lines(move):
+            return move.line_ids.filtered('tax_repartition_line_id')
+
+        def get_value(record, field):
+            return self.env['account.move.line']._fields[field].convert_to_write(record[field], record)
+
+        def get_tax_line_tracked_fields(line):
+            return ('amount_currency', 'balance')
+
+        def get_base_line_tracked_fields(line):
+            grouping_key = AccountTax._prepare_base_line_grouping_key(fake_base_line)
+            if line.move_id.is_invoice(include_receipts=True):
+                extra_fields = ['price_unit', 'quantity', 'discount']
+            else:
+                extra_fields = ['amount_currency']
+            return list(grouping_key.keys()) + extra_fields
+
+        def field_has_changed(values, record, field):
+            return get_value(record, field) != values.get(record, {}).get(field)
+
+        def get_changed_lines(values, records, fields=None):
+            return (
+                record
+                for record in records
+                if record not in values
+                or any(field_has_changed(values, record, field) for field in values[record] if not fields or field in fields)
+            )
+
+        def any_field_has_changed(values, records, fields=None):
+            return any(record for record in get_changed_lines(values, records, fields))
+
+        def is_write_needed(line, values):
+            return any(
+                self.env['account.move.line']._fields[fname].convert_to_write(line[fname], self) != values[fname]
+                for fname in values
+            )
+
+        moves_values_before = {
+            move: {
+                field: get_value(move, field)
+                for field in ('currency_id', 'partner_id', 'move_type')
+            }
+            for move in container['records']
+            if move.state == 'draft'
+        }
+        base_lines_values_before = {
+            move: {
+                line: {
+                    field: get_value(line, field)
+                    for field in get_base_line_tracked_fields(line)
+                }
+                for line in get_base_lines(move)
+            }
+            for move in container['records']
+        }
+        tax_lines_values_before = {
+            move: {
+                line: {
+                    field: get_value(line, field)
+                    for field in get_tax_line_tracked_fields(line)
+                }
+                for line in get_tax_lines(move)
+            }
+            for move in container['records']
+        }
+        yield
+
+        to_delete = []
+        to_create = []
+        for move in container['records']:
+            if move.state != 'draft':
+                continue
+
+            tax_lines = get_tax_lines(move)
+            base_lines = get_base_lines(move)
+            move_tax_lines_values_before = tax_lines_values_before.get(move, {})
+            move_base_lines_values_before = base_lines_values_before.get(move, {})
+            if (
+                move.is_invoice(include_receipts=True)
+                and (
+                    field_has_changed(moves_values_before, move, 'currency_id')
+                    or field_has_changed(moves_values_before, move, 'move_type')
+                )
+            ):
+                # Changing the type of an invoice using 'switch to refund' feature or just changing the currency.
+                round_from_tax_lines = False
+            elif changed_lines := list(get_changed_lines(move_base_lines_values_before, base_lines)):
+                # A base line has been modified.
+                round_from_tax_lines = (
+                    # The changed lines don't affect the taxes.
+                    all(not line.tax_ids and not move_base_lines_values_before.get(line, {}).get('tax_ids') for line in changed_lines)
+                    # Keep the tax lines amounts if an amount has been manually computed.
+                    or any_field_has_changed(move_tax_lines_values_before, tax_lines)
+                )
+
+                # If the move has been created with all lines including the tax ones and the balance/amount_currency are provided on
+                # base lines, we don't need to recompute anything.
+                if (
+                    round_from_tax_lines
+                    and any(line[field] for line in changed_lines for field in ('amount_currency', 'balance'))
+                ):
+                    continue
+            elif any(line not in base_lines for line, values in move_base_lines_values_before.items() if values['tax_ids']):
+                # Removed a base line affecting the taxes.
+                round_from_tax_lines = any_field_has_changed(move_tax_lines_values_before, tax_lines)
+            else:
+                continue
+
+            base_lines_values, tax_lines_values = move._get_rounded_base_and_tax_lines(round_from_tax_lines=round_from_tax_lines)
+            AccountTax._add_accounting_data_in_base_lines_tax_details(base_lines_values, move.company_id, include_caba_tags=move.always_tax_exigible)
+            tax_results = AccountTax._prepare_tax_lines(base_lines_values, move.company_id, tax_lines=tax_lines_values)
+
+            for base_line, to_update in tax_results['base_lines_to_update']:
+                line = base_line['record']
+                if is_write_needed(line, to_update):
+                    line.write(to_update)
+
+            for tax_line_vals in tax_results['tax_lines_to_delete']:
+                to_delete.append(tax_line_vals['record'].id)
+
+            for tax_line_vals in tax_results['tax_lines_to_add']:
+                to_create.append({
+                    **tax_line_vals,
+                    'display_type': 'tax',
+                    'move_id': move.id,
+                })
+
+            for tax_line_vals, grouping_key, to_update in tax_results['tax_lines_to_update']:
+                line = tax_line_vals['record']
+                if is_write_needed(line, to_update):
+                    line.write(to_update)
+
+        if to_delete:
+            self.env['account.move.line'].browse(to_delete).with_context(dynamic_unlink=True).unlink()
+        if to_create:
+            self.env['account.move.line'].create(to_create)
+
     @contextmanager
     def _sync_dynamic_line(self, existing_key_fname, needed_vals_fname, needed_dirty_fname, line_type, container):
         def existing():
@@ -2602,37 +2874,9 @@ class AccountMove(models.Model):
                 for line in container['records'].line_ids
                 if line[existing_key_fname]
             }
-        def needed():
-            res = {}
-            for computed_needed in container['records'].mapped(needed_vals_fname):
-                if computed_needed is False:
-                    continue  # there was an invalidation, let's hope nothing needed to be changed...
-                for key, values in computed_needed.items():
-                    if key not in res:
-                        res[key] = dict(values)
-                    else:
-                        ignore = True
-                        for fname in res[key]:
-                            if self.env['account.move.line']._fields[fname].type == 'monetary':
-                                res[key][fname] += values[fname]
-                                if res[key][fname]:
-                                    ignore = False
-                        if ignore:
-                            del res[key]
-
-            # Convert float values to their "ORM cache" one to prevent different rounding calculations
-            for dict_key in res:
-                move_id = dict_key.get('move_id')
-                if not move_id:
-                    continue
-                record = self.env['account.move'].browse(move_id)
-                for fname, current_value in res[dict_key].items():
-                    field = self.env['account.move.line']._fields[fname]
-                    if isinstance(current_value, float):
-                        new_value = field.convert_to_cache(current_value, record)
-                        res[dict_key][fname] = new_value
 
-            return res
+        def needed():
+            return self._sync_dynamic_line_needed_values(container['records'].mapped(needed_vals_fname))
 
         def dirty():
             *path, dirty_fname = needed_dirty_fname.split('.')
@@ -2749,7 +2993,7 @@ class AccountMove(models.Model):
                 return
             def update_containers():
                 # Only invoice-like and journal entries in "auto tax mode" are synced
-                tax_container['records'] = container['records'].filtered(lambda m: (m.is_invoice(True) or m.line_ids.tax_ids and not m.tax_cash_basis_origin_move_id))
+                tax_container['records'] = container['records'].filtered(lambda m: m.is_invoice(True) or m.line_ids.tax_ids or m.line_ids.tax_repartition_line_id)
                 invoice_container['records'] = container['records'].filtered(lambda m: m.is_invoice(True))
                 misc_container['records'] = container['records'].filtered(lambda m: m.is_entry() and not m.tax_cash_basis_origin_move_id)
 
@@ -2772,13 +3016,7 @@ class AccountMove(models.Model):
                     line_type='discount',
                     container=invoice_container,
                 ))
-                stack.enter_context(self._sync_dynamic_line(
-                    existing_key_fname='tax_key',
-                    needed_vals_fname='line_ids.compute_all_tax',
-                    needed_dirty_fname='line_ids.compute_all_tax_dirty',
-                    line_type='tax',
-                    container=tax_container,
-                ))
+                stack.enter_context(self._sync_tax_lines(tax_container))
                 stack.enter_context(self._sync_dynamic_line(
                     existing_key_fname='epd_key',
                     needed_vals_fname='line_ids.epd_needed',
@@ -2961,7 +3199,6 @@ class AccountMove(models.Model):
                     skip_account_move_synchronization=True,
                 )).write(vals)
 
-
                 # Reset the name of draft moves when changing the journal.
                 # Protected against holes in the pre-validation checks.
                 if 'journal_id' in vals and 'name' not in vals:
@@ -3418,7 +3655,7 @@ class AccountMove(models.Model):
         # If we manipulate the equation to get the base from the total, we'll have base = total / ((1 - discount) * tax + 1)
         term = self.invoice_payment_term_id
         discount_percentage = term.discount_percentage if term.early_discount else 0
-        remaining_amount = self.quick_edit_total_amount - self.tax_totals['amount_total']
+        remaining_amount = self.quick_edit_total_amount - self.tax_totals['total_amount_currency']
 
         if (
                 discount_percentage
@@ -3494,12 +3731,14 @@ class AccountMove(models.Model):
         if not self.tax_totals or not amount_total:
             return
         totals = self.tax_totals
-        tax_amount_rounding_error = amount_total - totals['amount_total']
+        tax_amount_rounding_error = amount_total - totals['total_amount_currency']
         if not float_is_zero(tax_amount_rounding_error, precision_rounding=self.currency_id.rounding):
-            if _('Untaxed Amount') in totals['groups_by_subtotal']:
-                totals['groups_by_subtotal'][_('Untaxed Amount')][0]['tax_group_amount'] += tax_amount_rounding_error
-                totals['amount_total'] = amount_total
-                self.tax_totals = totals
+            for subtotal in totals['subtotals']:
+                if _('Untaxed Amount') == subtotal['name']:
+                    subtotal['tax_groups'][0]['tax_amount_currency'] += tax_amount_rounding_error
+                    totals['total_amount_currency'] = amount_total
+                    self.tax_totals = totals
+                    break
 
     # -------------------------------------------------------------------------
     # HASH
@@ -3881,91 +4120,114 @@ class AccountMove(models.Model):
     # BUSINESS METHODS
     # -------------------------------------------------------------------------
 
-    def _prepare_invoice_aggregated_taxes(self, filter_invl_to_apply=None, filter_tax_values_to_apply=None, grouping_key_generator=None, distribute_total_on_line=True):
+    def _prepare_invoice_aggregated_taxes(
+        self,
+        filter_invl_to_apply=None,
+        filter_tax_values_to_apply=None,
+        grouping_key_generator=None,
+        round_from_tax_lines=None,
+        postfix_function=None,
+    ):
+        """ This method is deprecated and will be removed in the next version.
+        Use the following pattern instead:
+
+        base_amls = self.line_ids.filtered(lambda x: x.display_type == 'product')
+        base_lines = [self._prepare_product_base_line_for_taxes_computation(x) for x in base_amls]
+        tax_amls = self.line_ids.filtered(lambda x: x.display_type == 'tax')
+        tax_lines = [self._prepare_tax_line_for_taxes_computation(x) for x in tax_amls]
+        AccountTax._add_tax_details_in_base_lines(base_lines, self.company_id)
+        AccountTax._round_base_lines_tax_details(base_lines, self.company_id, tax_lines=tax_lines)
+
+        def grouping_function(base_line, tax_data):
+            ...
+
+        base_lines_aggregated_values = self._aggregate_base_lines_tax_details(base_lines, grouping_function)
+        values_per_grouping_key = self._aggregate_base_lines_aggregated_values(base_lines_aggregated_values)
+        """
         self.ensure_one()
-        company = self.company_id
-        invoice_lines = self.line_ids.filtered(lambda x: x.display_type == 'product' and (not filter_invl_to_apply or filter_invl_to_apply(x)))
-
-        # Prepare the tax details for each line.
-        to_process = []
-        for invoice_line in invoice_lines:
-            base_line = invoice_line._convert_to_tax_base_line_dict()
-            tax_details_results = self.env['account.tax']._prepare_base_line_tax_details(base_line, company)
-            to_process.append((base_line, tax_details_results))
-
-        # Handle manually changed tax amounts (via quick-edit or journal entry manipulation):
-        # For each tax repartition line we compute the difference between the following 2 amounts
-        #     * Manual tax amount:
-        #       The sum of the amounts on the tax lines belonging to the tax repartition line.
-        #       These amounts may have been manually changed.
-        #     * Computed tax amount:
-        #       The sum of the amounts on the items in 'taxes_data' in 'to_process' belonging to the tax repartition line.
-        # This difference is then distributed evenly across the 'taxes_data' in 'to_process'
-        # such that the manual and computed tax amounts match.
-        # The updated tax information is later used by '_aggregate_taxes' to compute the right tax amounts (consistently on all levels).
-        tax_lines = self.line_ids.filtered(lambda x: x.display_type == 'tax')
-        sign = -1 if self.is_inbound(include_receipts=True) else 1
-
-        # Collect the tax_amount_currency/balance from tax lines.
-        current_tax_amount_per_rep_line = {}
-        for tax_line in tax_lines:
-            tax_rep_amounts = current_tax_amount_per_rep_line.setdefault(tax_line.tax_repartition_line_id.id, {
+        AccountTax = self.env['account.tax']
+        if round_from_tax_lines is None:
+            round_from_tax_lines = filter_tax_values_to_apply or filter_invl_to_apply
+
+        base_amls = self.line_ids.filtered(lambda x: x.display_type == 'product' and (not filter_invl_to_apply or filter_invl_to_apply(x)))
+        base_lines = [self._prepare_product_base_line_for_taxes_computation(x) for x in base_amls]
+        tax_amls = self.line_ids.filtered(lambda x: x.display_type == 'tax')
+        if round_from_tax_lines:
+            tax_lines = [self._prepare_tax_line_for_taxes_computation(x) for x in tax_amls]
+        else:
+            tax_lines = []
+        AccountTax._add_tax_details_in_base_lines(base_lines, self.company_id)
+        if postfix_function:
+            postfix_function(base_lines)
+        AccountTax._round_base_lines_tax_details(base_lines, self.company_id, tax_lines=tax_lines)
+
+        # Retro-compatibility with previous aggregator.
+        results = {
+            'base_amount_currency': 0.0,
+            'base_amount': 0.0,
+            'tax_amount_currency': 0.0,
+            'tax_amount': 0.0,
+            'tax_details_per_record': defaultdict(lambda: {
+                'base_amount_currency': 0.0,
+                'base_amount': 0.0,
                 'tax_amount_currency': 0.0,
                 'tax_amount': 0.0,
-            })
-            tax_rep_amounts['tax_amount_currency'] += sign * tax_line.amount_currency
-            tax_rep_amounts['tax_amount'] += sign * tax_line.balance
-
-        # Collect the computed tax_amount_currency/tax_amount from the taxes computation.
-        tax_details_per_rep_line = {}
-        for _base_line, tax_details_results in to_process:
-            for tax_data in tax_details_results['taxes_data']:
-                tax_rep = tax_data['tax_repartition_line']
-                tax_rep_amounts = tax_details_per_rep_line.setdefault(tax_rep.id, {
-                    'tax_amount_currency': 0.0,
-                    'tax_amount': 0.0,
-                    'distribute_on': [],
-                })
-                tax_rep_amounts['tax_amount_currency'] += tax_data['tax_amount_currency']
-                tax_rep_amounts['tax_amount'] += tax_data['tax_amount']
-                tax_rep_amounts['distribute_on'].append(tax_data)
-
-        # Dispatch the delta on tax_values.
-        for key, currency in (('tax_amount_currency', self.currency_id), ('tax_amount', self.company_currency_id)):
-            for tax_rep_id, computed_tax_rep_amounts in tax_details_per_rep_line.items():
-                current_tax_rep_amounts = current_tax_amount_per_rep_line.get(tax_rep_id, computed_tax_rep_amounts)
-                diff = current_tax_rep_amounts[key] - computed_tax_rep_amounts[key]
-                abs_diff = abs(diff)
-
-                if currency.is_zero(abs_diff):
-                    continue
-
-                diff_sign = -1 if diff < 0 else 1
-                nb_error = math.ceil(abs_diff / currency.rounding)
-                nb_cents_per_tax_values = math.floor(nb_error / len(computed_tax_rep_amounts['distribute_on']))
-                nb_extra_cent = nb_error % len(computed_tax_rep_amounts['distribute_on'])
-                for tax_data in computed_tax_rep_amounts['distribute_on']:
-
-                    if currency.is_zero(abs_diff):
-                        break
-
-                    nb_amount_curr_cent = nb_cents_per_tax_values
-                    if nb_extra_cent:
-                        nb_amount_curr_cent += 1
-                        nb_extra_cent -= 1
+            }),
+            'base_lines': base_lines,
+        }
 
-                    # We can have more than one cent to distribute on a single tax_values.
-                    abs_delta_to_add = min(abs_diff, currency.rounding * nb_amount_curr_cent)
-                    tax_data[key] += diff_sign * abs_delta_to_add
-                    abs_diff -= abs_delta_to_add
+        def total_grouping_function(base_line, tax_data):
+            return not filter_tax_values_to_apply or filter_tax_values_to_apply(base_line, tax_data)
+
+        # Report the total amounts.
+        base_lines_aggregated_values = AccountTax._aggregate_base_lines_tax_details(base_lines, total_grouping_function)
+        for base_line, aggregated_values in base_lines_aggregated_values:
+            record = base_line['record']
+            base_line_results = results['tax_details_per_record'][record]
+            base_line_results['base_line'] = base_line
+            for grouping_key, values in aggregated_values.items():
+                if grouping_key:
+                    for key in ('base_amount', 'base_amount_currency', 'tax_amount', 'tax_amount_currency'):
+                        base_line_results[key] += values[key]
+
+        values_per_grouping_key = AccountTax._aggregate_base_lines_aggregated_values(base_lines_aggregated_values)
+        for grouping_key, values in values_per_grouping_key.items():
+            if grouping_key:
+                for key in ('base_amount', 'base_amount_currency', 'tax_amount', 'tax_amount_currency'):
+                    results[key] += values[key]
+
+        # Same with the custom grouping_key passed as parameter.
+        def tax_details_grouping_function(base_line, tax_data):
+            if not total_grouping_function(base_line, tax_data):
+                return None
+            if grouping_key_generator:
+                grouping_key = grouping_key_generator(base_line, tax_data)
+                assert grouping_key is not None  # None must be kept for inner-grouping.
+                return grouping_key
+            return tax_data['tax']
+
+        base_lines_aggregated_values = AccountTax._aggregate_base_lines_tax_details(base_lines, tax_details_grouping_function)
+        for base_line, aggregated_values in base_lines_aggregated_values:
+            record = base_line['record']
+            base_line_results = results['tax_details_per_record'][record]
+            base_line_results['tax_details'] = tax_details = {}
+            for grouping_key, values in aggregated_values.items():
+                if not grouping_key:
+                    continue
+                if isinstance(grouping_key, dict):
+                    values.update(grouping_key)
+                tax_details[grouping_key] = values
+
+        values_per_grouping_key = AccountTax._aggregate_base_lines_aggregated_values(base_lines_aggregated_values)
+        results['tax_details'] = tax_details = {}
+        for grouping_key, values in values_per_grouping_key.items():
+            if not grouping_key:
+                continue
+            if isinstance(grouping_key, dict):
+                values.update(grouping_key)
+            tax_details[grouping_key] = values
 
-        return self.env['account.tax']._aggregate_taxes(
-            to_process,
-            company,
-            filter_tax_values_to_apply=filter_tax_values_to_apply,
-            grouping_key_generator=grouping_key_generator,
-            distribute_total_on_line=distribute_total_on_line,
-        )
+        return results
 
     def _get_invoice_counterpart_amls_for_early_payment_discount_per_payment_term_line(self):
         """ Helper to get the values to create the counterpart journal items on the register payment wizard and the
@@ -4013,29 +4275,21 @@ class AccountMove(models.Model):
 
         base_lines = [
             {
-                **x._convert_to_tax_base_line_dict(),
+                **self._prepare_product_base_line_for_taxes_computation(line),
                 'is_refund': True,
             }
-            for x in invoice_lines
+            for line in invoice_lines
         ]
         for base_line in base_lines:
-            base_line['taxes'] = base_line['taxes'].filtered(lambda t: t.amount_type != 'fixed')
+            base_line['tax_ids'] = base_line['tax_ids'].filtered(lambda t: t.amount_type != 'fixed')
 
             if early_pay_discount_computation == 'included':
                 remaining_part_to_consider = (100 - discount_percentage) / 100.0
                 base_line['price_unit'] *= remaining_part_to_consider
-
-        # Prepare the tax details for each line.
-        to_process = []
-        for base_line in base_lines:
-            tax_details_results = self.env['account.tax']._prepare_base_line_tax_details(base_line, company)
-            to_process.append((base_line, tax_details_results))
-
-        # Aggregate taxes.
-        def grouping_key_generator(base_line, tax_values):
-            return self.env['account.tax']._get_generation_dict_from_base_line(base_line, tax_values)
-
-        tax_details_with_epd = self.env['account.tax']._aggregate_taxes(to_process, company, grouping_key_generator=grouping_key_generator)
+        AccountTax = self.env['account.tax']
+        AccountTax._add_tax_details_in_base_lines(base_lines, self.company_id)
+        AccountTax._round_base_lines_tax_details(base_lines, self.company_id)
+        AccountTax._add_accounting_data_in_base_lines_tax_details(base_lines, self.company_id)
 
         if self.is_inbound(include_receipts=True):
             cash_discount_account = company.account_journal_early_pay_discount_loss_account_id
@@ -4050,14 +4304,15 @@ class AccountMove(models.Model):
             # Compute the base amounts.
             resulting_delta_base_details = {}
             resulting_delta_tax_details = {}
-            for base_line, tax_details_results in to_process:
+            for base_line in base_lines:
+                tax_details = base_line['tax_details']
                 invoice_line = base_line['record']
 
                 grouping_dict = {
-                    'tax_ids': [Command.set(base_line['taxes'].ids)],
-                    'tax_tag_ids': tax_details_results['base_tags'].ids,
-                    'partner_id': base_line['partner'].id,
-                    'currency_id': base_line['currency'].id,
+                    'tax_ids': [Command.set(base_line['tax_ids'].ids)],
+                    'tax_tag_ids': [Command.set(base_line['tax_tag_ids'].ids)],
+                    'partner_id': base_line['partner_id'].id,
+                    'currency_id': base_line['currency_id'].id,
                     'account_id': cash_discount_account.id,
                     'analytic_distribution': base_line['analytic_distribution'],
                 }
@@ -4067,9 +4322,9 @@ class AccountMove(models.Model):
                 })
 
                 amount_currency = self.currency_id\
-                    .round(self.direction_sign * tax_details_results['total_excluded'] - invoice_line.amount_currency)
+                    .round(self.direction_sign * tax_details['total_excluded_currency'] - invoice_line.amount_currency)
                 balance = self.company_currency_id\
-                    .round(amount_currency / base_line['rate'])
+                    .round(self.direction_sign * tax_details['total_excluded'] - invoice_line.balance)
 
                 base_detail['balance'] += balance
                 base_detail['amount_currency'] += amount_currency
@@ -4077,46 +4332,37 @@ class AccountMove(models.Model):
                 bases_details[frozendict(grouping_dict)] = base_detail
 
             # Compute the tax amounts.
-            for tax_detail in tax_details_with_epd['tax_details'].values():
-                tax_amount_without_epd = tax_amounts.get(tax_detail['tax_repartition_line_id'])
-                if not tax_amount_without_epd:
-                    continue
-
-                tax_amount_currency = self.currency_id\
-                    .round(self.direction_sign * tax_detail['tax_amount_currency'] - tax_amount_without_epd['amount_currency'])
-                tax_amount = self.company_currency_id\
-                    .round(self.direction_sign * tax_detail['tax_amount'] - tax_amount_without_epd['balance'])
-
-                if self.currency_id.is_zero(tax_amount_currency) and self.company_currency_id.is_zero(tax_amount):
-                    continue
-
-                resulting_delta_tax_details[tax_detail['tax_repartition_line_id']] = {
-                    **tax_detail,
-                    'amount_currency': tax_amount_currency,
-                    'balance': tax_amount,
-                }
+            tax_results = AccountTax._prepare_tax_lines(base_lines, self.company_id)
+            for tax_line_vals in tax_results['tax_lines_to_add']:
+                tax_amount_without_epd = tax_amounts.get(tax_line_vals['tax_repartition_line_id'])
+                if tax_amount_without_epd:
+                    resulting_delta_tax_details[tax_line_vals['tax_repartition_line_id']] = {
+                        **tax_line_vals,
+                        'amount_currency': tax_line_vals['amount_currency'] - tax_amount_without_epd['amount_currency'],
+                        'balance': tax_line_vals['balance'] - tax_amount_without_epd['balance'],
+                    }
 
             # Multiply the amount by the percentage
             percentage_paid = abs(payment_term_line.amount_residual_currency / self.amount_total)
-            for tax_detail in resulting_delta_tax_details.values():
-                tax_rep = self.env['account.tax.repartition.line'].browse(tax_detail['tax_repartition_line_id'])
+            for tax_line_vals in resulting_delta_tax_details.values():
+                tax_rep = self.env['account.tax.repartition.line'].browse(tax_line_vals['tax_repartition_line_id'])
                 tax = tax_rep.tax_id
 
                 grouping_dict = {
-                    'account_id': tax_detail['account_id'],
-                    'partner_id': tax_detail['partner_id'],
-                    'currency_id': tax_detail['currency_id'],
-                    'analytic_distribution': tax_detail['analytic_distribution'],
+                    'account_id': tax_line_vals['account_id'],
+                    'partner_id': tax_line_vals['partner_id'],
+                    'currency_id': tax_line_vals['currency_id'],
+                    'analytic_distribution': tax_line_vals['analytic_distribution'],
                     'tax_repartition_line_id': tax_rep.id,
-                    'tax_ids': tax_detail['tax_ids'],
-                    'tax_tag_ids': tax_detail['tax_tag_ids'],
-                    'group_tax_id': tax_detail['tax_id'] if tax_detail['tax_id'] != tax.id else None,
+                    'tax_ids': tax_line_vals['tax_ids'],
+                    'tax_tag_ids': tax_line_vals['tax_tag_ids'],
+                    'group_tax_id': tax_line_vals['group_tax_id'],
                 }
 
                 res['tax_lines'][payment_term_line][frozendict(grouping_dict)] = {
                     'name': _("Early Payment Discount (%s)", tax.name),
-                    'amount_currency': payment_term_line.currency_id.round(tax_detail['amount_currency'] * percentage_paid),
-                    'balance': payment_term_line.company_currency_id.round(tax_detail['balance'] * percentage_paid),
+                    'amount_currency': payment_term_line.currency_id.round(tax_line_vals['amount_currency'] * percentage_paid),
+                    'balance': payment_term_line.company_currency_id.round(tax_line_vals['balance'] * percentage_paid),
                 }
 
             for grouping_dict, base_detail in bases_details.items():

--- a/addons/account/models/account_move_line.py
+++ b/addons/account/models/account_move_line.py
@@ -371,9 +371,6 @@ class AccountMoveLine(models.Model):
         string='Tax calculation rounding method', readonly=True)
     # === Invoice sync fields === #
     term_key = fields.Binary(compute='_compute_term_key', exportable=False)
-    tax_key = fields.Binary(compute='_compute_tax_key', exportable=False)
-    compute_all_tax = fields.Binary(compute='_compute_all_tax', exportable=False)
-    compute_all_tax_dirty = fields.Boolean(compute='_compute_all_tax')
     epd_key = fields.Binary(compute='_compute_epd_key', exportable=False)
     epd_needed = fields.Binary(compute='_compute_epd_needed', exportable=False)
     epd_dirty = fields.Boolean(compute='_compute_epd_needed')
@@ -812,27 +809,20 @@ class AccountMoveLine(models.Model):
 
     @api.depends('quantity', 'discount', 'price_unit', 'tax_ids', 'currency_id')
     def _compute_totals(self):
+        """ Compute 'price_subtotal' / 'price_total' outside of `_sync_tax_lines` because those values must be visible for the
+        user on the UI with draft moves and the dynamic lines are synchronized only when saving the record.
+        """
+        AccountTax = self.env['account.tax']
         for line in self:
-            if line.display_type != 'product':
+            # TODO remove the need of cogs lines to have a price_subtotal/price_total
+            if line.display_type not in ('product', 'cogs'):
                 line.price_total = line.price_subtotal = False
-            # Compute 'price_subtotal'.
-            line_discount_price_unit = line.price_unit * (1 - (line.discount / 100.0))
-            subtotal = line.quantity * line_discount_price_unit
-
-            # Compute 'price_total'.
-            if line.tax_ids:
-                taxes_res = line.tax_ids.compute_all(
-                    line_discount_price_unit,
-                    quantity=line.quantity,
-                    currency=line.currency_id,
-                    product=line.product_id,
-                    partner=line.partner_id,
-                    is_refund=line.is_refund,
-                )
-                line.price_subtotal = taxes_res['total_excluded']
-                line.price_total = taxes_res['total_included']
-            else:
-                line.price_total = line.price_subtotal = subtotal
+                continue
+
+            base_line = line.move_id._prepare_product_base_line_for_taxes_computation(line)
+            AccountTax._add_tax_details_in_base_line(base_line, line.company_id)
+            line.price_subtotal = base_line['tax_details']['total_excluded_currency']
+            line.price_total = base_line['tax_details']['total_included_currency']
 
     @api.depends('product_id', 'product_uom_id')
     def _compute_price_unit(self):
@@ -888,80 +878,6 @@ class AccountMoveLine(models.Model):
 
         return tax_ids
 
-    @api.depends('tax_ids', 'currency_id', 'partner_id', 'account_id', 'group_tax_id', 'analytic_distribution')
-    def _compute_tax_key(self):
-        for line in self:
-            if line.tax_repartition_line_id:
-                line.tax_key = frozendict({
-                    'tax_repartition_line_id': line.tax_repartition_line_id.id,
-                    'group_tax_id': line.group_tax_id.id,
-                    'account_id': line.account_id.id,
-                    'currency_id': line.currency_id.id,
-                    'analytic_distribution': line.analytic_distribution,
-                    'tax_ids': [(6, 0, line.tax_ids.ids)],
-                    'tax_tag_ids': [(6, 0, line.tax_tag_ids.ids)],
-                    'partner_id': line.partner_id.id,
-                    'move_id': line.move_id.id,
-                    'display_type': line.display_type,
-                })
-            else:
-                line.tax_key = frozendict({'id': line.id})
-
-    @api.depends('tax_ids', 'currency_id', 'partner_id', 'analytic_distribution', 'balance', 'partner_id', 'move_id.partner_id', 'price_unit', 'quantity')
-    def _compute_all_tax(self):
-        for line in self:
-            if line.display_type == 'tax':
-                line.compute_all_tax = {}
-                line.compute_all_tax_dirty = False
-                continue
-            if line.display_type == 'product' and line.move_id.is_invoice(True):
-                sign = line.move_id.direction_sign
-                price_unit = line.price_unit * (1 - line.discount / 100)
-                handle_price_include = True
-                quantity = line.quantity
-            else:
-                sign = 1
-                price_unit = line.amount_currency
-                handle_price_include = False
-                quantity = 1
-            compute_all_currency = line.tax_ids.compute_all(
-                price_unit,
-                currency=line.currency_id,
-                quantity=quantity,
-                product=line.product_id,
-                partner=line.move_id.partner_id or line.partner_id,
-                is_refund=line.is_refund,
-                handle_price_include=handle_price_include,
-                include_caba_tags=line.move_id.always_tax_exigible,
-            )
-            rate = line.amount_currency / line.balance if line.balance else 1
-            line.compute_all_tax_dirty = True
-            line.compute_all_tax = {
-                frozendict({
-                    'tax_repartition_line_id': tax['tax_repartition_line_id'],
-                    'group_tax_id': tax['group'] and tax['group'].id or False,
-                    'account_id': tax['account_id'] or line.account_id.id,
-                    'currency_id': line.currency_id.id,
-                    'analytic_distribution': (tax['analytic'] or not tax['use_in_tax_closing']) and line.analytic_distribution,
-                    'tax_ids': [(6, 0, tax['tax_ids'])],
-                    'tax_tag_ids': [(6, 0, tax['tag_ids'])],
-                    'partner_id': line.move_id.partner_id.id or line.partner_id.id,
-                    'move_id': line.move_id.id,
-                    'display_type': line.display_type,
-                }): {
-                    'name': self.env._('%(tax_name)s (Discount)', tax_name=tax['name']) if line.display_type == 'epd' else tax['name'],
-                    'balance': sign * tax['amount'] / rate,
-                    'amount_currency': sign * tax['amount'],
-                    'tax_base_amount': sign * tax['base'] / rate * (-1 if line.tax_tag_invert else 1),
-                }
-                for tax in compute_all_currency['taxes']
-                if tax['amount']
-            }
-            if not line.tax_repartition_line_id:
-                line.compute_all_tax[frozendict({'id': line.id})] = {
-                    'tax_tag_ids': [(6, 0, compute_all_currency['base_tags'])],
-                }
-
     @api.depends('account_id', 'company_id')
     def _compute_discount_allocation_key(self):
         for line in self:
@@ -1031,6 +947,11 @@ class AccountMoveLine(models.Model):
 
     @api.depends('move_id.needed_terms', 'account_id', 'analytic_distribution', 'tax_ids', 'tax_tag_ids', 'company_id')
     def _compute_epd_needed(self):
+        # TODO: The computation of early payment is weird because based on the 'price_subtotal'
+        # that already have it's own taxes computation (by design because the sync_dynamic lines only
+        # work when saving the record).
+        # However, the early payment lines also have some taxes and the sync_dynamic_line will compute the tax lines based on
+        # product base lines + epd base lines that could lead to a different amount when using the round globally.
         for line in self:
             line.epd_dirty = True
             line.epd_needed = False
@@ -1049,19 +970,20 @@ class AccountMoveLine(models.Model):
                     'account_id': line.account_id.id,
                     'analytic_distribution': line.analytic_distribution,
                     'tax_ids': [Command.set(taxes.ids)],
-                    'tax_tag_ids': line.compute_all_tax[frozendict({'id': line.id})]['tax_tag_ids'],
                     'display_type': 'epd',
                 }),
                 {
                     'name': _("Early Payment Discount (%s)", discount_percentage_name),
                     'amount_currency': 0.0,
                     'balance': 0.0,
-                    'price_subtotal': 0.0,
                 },
             )
-            epd_needed_vals['amount_currency'] -= line.currency_id.round(line.amount_currency * percentage)
-            epd_needed_vals['balance'] -= line.currency_id.round(line.balance * percentage)
-            epd_needed_vals['price_subtotal'] -= line.currency_id.round(line.price_subtotal * percentage)
+            sign = line.move_id.direction_sign
+            rate = line.move_id.invoice_currency_rate
+            amount_currency = line.currency_id.round(sign * line.price_subtotal * percentage)
+            balance = line.company_currency_id.round(sign * line.price_subtotal * percentage / rate) if rate else 0.0
+            epd_needed_vals['amount_currency'] -= amount_currency
+            epd_needed_vals['balance'] -= balance
             epd_needed_vals = epd_needed.setdefault(
                 frozendict({
                     'move_id': line.move_id.id,
@@ -1072,13 +994,11 @@ class AccountMoveLine(models.Model):
                     'name': _("Early Payment Discount (%s)", discount_percentage_name),
                     'amount_currency': 0.0,
                     'balance': 0.0,
-                    'price_subtotal': 0.0,
                     'tax_ids': [Command.clear()],
                 },
             )
-            epd_needed_vals['amount_currency'] += line.currency_id.round(line.amount_currency * percentage)
-            epd_needed_vals['balance'] += line.currency_id.round(line.balance * percentage)
-            epd_needed_vals['price_subtotal'] += line.currency_id.round(line.price_subtotal * percentage)
+            epd_needed_vals['amount_currency'] += amount_currency
+            epd_needed_vals['balance'] += balance
             line.epd_needed = {k: frozendict(v) for k, v in epd_needed.items()}
 
     @api.depends('move_id.move_type', 'balance', 'tax_repartition_line_id', 'tax_ids')
@@ -1402,7 +1322,7 @@ class AccountMoveLine(models.Model):
     def check_field_access_rights(self, operation, field_names):
         result = super().check_field_access_rights(operation, field_names)
         if not field_names:
-            weirdos = ['term_key', 'tax_key', 'compute_all_tax', 'epd_key', 'epd_needed', 'discount_allocation_key', 'discount_allocation_needed']
+            weirdos = ['term_key', 'epd_key', 'epd_needed', 'discount_allocation_key', 'discount_allocation_needed']
             result = [fname for fname in result if fname not in weirdos]
         return result
 
@@ -1532,18 +1452,7 @@ class AccountMoveLine(models.Model):
         before = existing()
         yield
         after = existing()
-        for line in after:
-            if (
-                line.display_type == 'product'
-                and (not changed('amount_currency') or line not in before)
-            ):
-                amount_currency = line.move_id.direction_sign * line.currency_id.round(line.price_subtotal)
-                if line.amount_currency != amount_currency or line not in before:
-                    line.amount_currency = amount_currency
-                if line.currency_id == line.company_id.currency_id:
-                    line.balance = amount_currency
 
-        after = existing()
         for line in after:
             if (
                 (changed('amount_currency') or changed('currency_rate') or changed('move_type'))
@@ -1551,6 +1460,7 @@ class AccountMoveLine(models.Model):
             ):
                 balance = line.company_id.currency_id.round(line.amount_currency / line.currency_rate)
                 line.balance = balance
+
         # Since this method is called during the sync, inside of `create`/`write`, these fields
         # already have been computed and marked as so. But this method should re-trigger it since
         # it changes the dependencies.
@@ -3249,53 +3159,6 @@ class AccountMoveLine(models.Model):
             ('tax_ids.tax_exigibility', '!=', 'on_payment'), # So: exigible if at least one tax from tax_ids isn't on_payment
         ]
 
-    def _convert_to_tax_base_line_dict(self):
-        """ Convert the current record to a dictionary in order to use the generic taxes computation method
-        defined on account.tax.
-        :return: A python dictionary.
-        """
-        self.ensure_one()
-        is_invoice = self.move_id.is_invoice(include_receipts=True)
-        sign = -1 if self.move_id.is_inbound(include_receipts=True) else 1
-
-        return self.env['account.tax']._convert_to_tax_base_line_dict(
-            self,
-            partner=self.partner_id,
-            currency=self.currency_id,
-            product=self.product_id,
-            taxes=self.tax_ids,
-            price_unit=self.price_unit if is_invoice else self.amount_currency,
-            quantity=self.quantity if is_invoice else 1.0,
-            discount=self.discount if is_invoice else 0.0,
-            account=self.account_id,
-            analytic_distribution=self.analytic_distribution,
-            price_subtotal=sign * self.amount_currency,
-            is_refund=self.is_refund,
-            rate=(abs(self.amount_currency) / abs(self.balance)) if self.balance else 1.0
-        )
-
-    def _convert_to_tax_line_dict(self):
-        """ Convert the current record to a dictionary in order to use the generic taxes computation method
-        defined on account.tax.
-        :return: A python dictionary.
-        """
-        self.ensure_one()
-        sign = -1 if self.move_id.is_inbound(include_receipts=True) else 1
-
-        return self.env['account.tax']._convert_to_tax_line_dict(
-            self,
-            partner=self.partner_id,
-            currency=self.currency_id,
-            taxes=self.tax_ids,
-            tax_tags=self.tax_tag_ids,
-            tax_repartition_line=self.tax_repartition_line_id,
-            group_tax=self.group_tax_id,
-            account=self.account_id,
-            analytic_distribution=self.analytic_distribution,
-            tax_amount_currency=sign * self.amount_currency,
-            tax_amount=sign * self.balance,
-        )
-
     def _get_invoiced_qty_per_product(self):
         qties = defaultdict(float)
         for aml in self:

--- a/addons/account/models/account_tax.py
+++ b/addons/account/models/account_tax.py
@@ -3,7 +3,7 @@ from odoo import api, fields, models, _, Command
 from odoo.osv import expression
 from odoo.exceptions import UserError, ValidationError
 from odoo.tools import frozendict, groupby, split_every
-from odoo.tools.float_utils import float_round
+from odoo.tools.float_utils import float_repr, float_round, float_compare
 from odoo.tools.misc import clean_context, formatLang
 from odoo.tools.translate import html_translate
 
@@ -11,10 +11,10 @@ from collections import defaultdict
 from markupsafe import Markup
 
 import ast
+import copy
 import math
 import re
 
-
 TYPE_TAX_USE = [
     ('sale', 'Sales'),
     ('purchase', 'Purchases'),
@@ -195,7 +195,9 @@ class AccountTax(models.Model):
     is_used = fields.Boolean(string="Tax used", compute='_compute_is_used')
     repartition_lines_str = fields.Char(string="Repartition Lines", tracking=True, compute='_compute_repartition_lines_str')
     invoice_legal_notes = fields.Html(string="Legal Notes", help="Legal mentions that have to be printed on the invoices.")
-    total_tax_factor = fields.Float(compute='_compute_total_tax_factor')
+    # Technical field depicting if the tax has at least one repartition line with a percentage below 0.
+    # Used for the taxes computation to manage the reverse charge taxes having a repartition +100 -100.
+    has_negative_factor = fields.Boolean(compute='_compute_has_negative_factor')
 
     @api.constrains('company_id', 'name', 'type_tax_use', 'tax_scope', 'country_id')
     def _constrains_name(self):
@@ -441,9 +443,10 @@ class AccountTax(models.Model):
                 ]
 
     @api.depends('invoice_repartition_line_ids.factor', 'invoice_repartition_line_ids.repartition_type')
-    def _compute_total_tax_factor(self):
+    def _compute_has_negative_factor(self):
         for tax in self:
-            tax.total_tax_factor = sum(tax.invoice_repartition_line_ids.filtered(lambda x: x.repartition_type == 'tax').mapped('factor'))
+            tax_reps = tax.invoice_repartition_line_ids.filtered(lambda x: x.repartition_type == 'tax')
+            tax.has_negative_factor = bool(tax_reps.filtered(lambda tax_rep: tax_rep.factor < 0.0))
 
     @staticmethod
     def _parse_name_search(name):
@@ -516,6 +519,14 @@ class AccountTax(models.Model):
                     raise ValidationError(_("Invoice and credit note distribution should match (same percentages, in the same order)."))
                 index += 1
 
+            tax_reps = invoice_repartition_line_ids.filtered(lambda tax_rep: tax_rep.repartition_type == 'tax')
+            total_pos_factor = sum(tax_reps.filtered(lambda tax_rep: tax_rep.factor > 0.0).mapped('factor'))
+            if float_compare(total_pos_factor, 1.0, precision_digits=2):
+                raise ValidationError(_("Invoice and credit note distribution should have a total factor (+) equals to 100."))
+            total_neg_factor = sum(tax_reps.filtered(lambda tax_rep: tax_rep.factor < 0.0).mapped('factor'))
+            if total_neg_factor and float_compare(total_neg_factor, -1.0, precision_digits=2):
+                raise ValidationError(_("Invoice and credit note distribution should have a total factor (-) equals to 100."))
+
     @api.constrains('children_tax_ids', 'type_tax_use')
     def _check_children_scope(self):
         for tax in self:
@@ -790,7 +801,7 @@ class AccountTax(models.Model):
                 yield tax_after
 
         def add_extra_base(other_tax, sign):
-            tax_amount = taxes_data[tax.id]['tax_amount_factorized']
+            tax_amount = taxes_data[tax.id]['tax_amount']
             if 'tax_amount' not in taxes_data[other_tax.id]:
                 taxes_data[other_tax.id]['extra_base_for_tax'] += sign * tax_amount
             taxes_data[other_tax.id]['extra_base_for_base'] += sign * tax_amount
@@ -892,7 +903,7 @@ class AccountTax(models.Model):
         """
         self.ensure_one()
         if self.amount_type == 'percent':
-            total_percentage = sum(tax.total_tax_factor * tax.amount for tax in batch) / 100.0
+            total_percentage = sum(tax.amount for tax in batch) / 100.0
             to_price_excluded_factor = 1 / (1 + total_percentage) if total_percentage != -1 else 0.0
             return raw_base * to_price_excluded_factor * self.amount / 100.0
 
@@ -915,7 +926,7 @@ class AccountTax(models.Model):
             return raw_base * self.amount / 100.0
 
         if self.amount_type == 'division':
-            total_percentage = sum(tax.total_tax_factor * tax.amount for tax in batch) / 100.0
+            total_percentage = sum(tax.amount for tax in batch) / 100.0
             incl_base_multiplicator = 1.0 if total_percentage == 1.0 else 1 - total_percentage
             return raw_base * self.amount / 100.0 / incl_base_multiplicator
 
@@ -927,7 +938,6 @@ class AccountTax(models.Model):
         rounding_method='round_per_line',
         product=None,
         special_mode=False,
-        round_price_include=True,
     ):
         """ Compute the tax/base amounts for the current taxes.
 
@@ -948,15 +958,6 @@ class AccountTax(models.Model):
                             will give you the same as 100 without any special_mode.
                             Note: You can only expect accurate symmetrical taxes computation with not rounded price_unit
                             as input and 'round_globally' computation. Otherwise, it's not guaranteed.
-        :param round_price_include: Indicate if we want to force the rounding in price_include whatever the tax computation method.
-                                    In case you have 2 invoice lines of 21.53 with 21% price included taxes, the code will compute
-                                    21.53 / 1.21 * 2 ~= 35.59 as untaxed amount, 7.47 as tax amount and 40.06 as total amount.
-                                    However, for now, we decided we want to put the rounding into the tax amount instead of making
-                                    an adjustment on the untaxed amount because we want the untaxed amount being the sum of the price
-                                    excluded amount of each line. Here, 2 * round(21.53 / 1.21) = 35.58. So we are forced to put the
-                                    rounding on the tax instead to have 35.58 + 7.48 = 43.06 and then, round like the round_per_line
-                                    when the tax is price included.
-        :return:                    A python dictionary.
         :return: A dict containing:
             'evaluation_context':       The evaluation_context parameter.
             'taxes_data':               A list of dictionaries, one per tax containing:
@@ -967,13 +968,11 @@ class AccountTax(models.Model):
             'total_included':           The total with tax.
         """
         def add_tax_amount_to_results(tax, tax_amount):
-            tax_data = taxes_data[tax.id]
-            tax_data['tax_amount'] = tax_amount
-            taxes_data[tax.id]['tax_amount_factorized'] = tax_amount * tax.total_tax_factor
-            special_mode = evaluation_context['special_mode']
-            round_price_include = evaluation_context['round_price_include']
-            if rounding_method == 'round_per_line' or (not special_mode and tax_data['price_include'] and round_price_include):
-                taxes_data[tax.id]['tax_amount_factorized'] = float_round(taxes_data[tax.id]['tax_amount_factorized'], precision_rounding=precision_rounding)
+            taxes_data[tax.id]['tax_amount'] = tax_amount
+            if rounding_method == 'round_per_line':
+                taxes_data[tax.id]['tax_amount'] = float_round(taxes_data[tax.id]['tax_amount'], precision_rounding=precision_rounding)
+            if tax.has_negative_factor:
+                reverse_charge_taxes_data[tax.id]['tax_amount'] = -taxes_data[tax.id]['tax_amount']
             sorted_taxes._propagate_extra_taxes_base(tax, taxes_data, special_mode=special_mode)
 
         def eval_tax_amount(tax_amount_function, tax):
@@ -1008,12 +1007,18 @@ class AccountTax(models.Model):
         batching_results = self._batch_for_taxes_computation(special_mode=special_mode)
         sorted_taxes = batching_results['sorted_taxes']
         taxes_data = {}
+        reverse_charge_taxes_data = {}
         for tax in sorted_taxes:
             taxes_data[tax.id] = prepare_tax_extra_data(
                 tax,
                 group=batching_results['group_per_tax'].get(tax.id),
                 batch=batching_results['batch_per_tax'][tax.id],
             )
+            if tax.has_negative_factor:
+                reverse_charge_taxes_data[tax.id] = {
+                    **taxes_data[tax.id],
+                    'is_reverse_charge': True,
+                }
 
         raw_base = quantity * price_unit
         if rounding_method == 'round_per_line':
@@ -1025,7 +1030,6 @@ class AccountTax(models.Model):
             'quantity': quantity,
             'raw_base': raw_base,
             'special_mode': special_mode,
-            'round_price_include': round_price_include,
         }
 
         # Define the order in which the taxes must be evaluated.
@@ -1055,17 +1059,30 @@ class AccountTax(models.Model):
             if 'tax_amount' not in taxes_data[tax.id]:
                 continue
 
-            total_tax_amount = sum(taxes_data[other_tax.id]['tax_amount_factorized'] for other_tax in taxes_data[tax.id]['batch'])
+            total_tax_amount = sum(taxes_data[other_tax.id]['tax_amount'] for other_tax in taxes_data[tax.id]['batch'])
+            total_tax_amount += sum(
+                reverse_charge_taxes_data[other_tax.id]['tax_amount']
+                for other_tax in taxes_data[tax.id]['batch']
+                if other_tax.has_negative_factor
+            )
             base = raw_base + taxes_data[tax.id]['extra_base_for_base']
             if taxes_data[tax.id]['price_include'] and special_mode in (False, 'total_included'):
                 base -= total_tax_amount
             taxes_data[tax.id]['base'] = base
+            if tax.has_negative_factor:
+                reverse_charge_taxes_data[tax.id]['base'] = base
 
-        taxes_data_list = [tax_data for tax_data in taxes_data.values() if 'tax_amount' in tax_data]
+        taxes_data_list = []
+        for tax_data in taxes_data.values():
+            if 'tax_amount' in tax_data:
+                taxes_data_list.append(tax_data)
+                tax = tax_data['tax']
+                if tax.has_negative_factor:
+                    taxes_data_list.append(reverse_charge_taxes_data[tax.id])
 
         if taxes_data_list:
             total_excluded = taxes_data_list[0]['base']
-            tax_amount = sum(tax_data['tax_amount_factorized'] for tax_data in taxes_data_list)
+            tax_amount = sum(tax_data['tax_amount'] for tax_data in taxes_data_list)
             total_included = total_excluded + tax_amount
         else:
             total_included = total_excluded = raw_base
@@ -1078,16 +1095,12 @@ class AccountTax(models.Model):
                     'tax': tax_data['tax'],
                     'group': batching_results['group_per_tax'].get(tax_data['tax'].id) or self.env['account.tax'],
                     'batch': batching_results['batch_per_tax'][tax_data['tax'].id],
-                    'tax_amount_unfactorized': tax_data['tax_amount'],
-                    'tax_amount': tax_data['tax_amount_factorized'],
+                    'tax_amount': tax_data['tax_amount'],
                     'base_amount': tax_data['base'],
+                    'is_reverse_charge': tax_data.get('is_reverse_charge', False),
                 }
                 for tax_data in taxes_data_list
             ],
-            'tax_data_index': {
-                tax_data['tax'].id: index
-                for index, tax_data in enumerate(taxes_data_list)
-            },
         }
 
     # -------------------------------------------------------------------------
@@ -1126,7 +1139,6 @@ class AccountTax(models.Model):
             1.0,
             rounding_method='round_globally',
             product=product,
-            round_price_include=False,
         )
         price_unit = taxes_computation['total_excluded']
 
@@ -1137,73 +1149,1038 @@ class AccountTax(models.Model):
             rounding_method='round_globally',
             product=product,
             special_mode='total_excluded',
-            round_price_include=False,
         )
         delta = sum(x['tax_amount'] for x in taxes_computation['taxes_data'] if x['tax'].price_include)
         return price_unit + delta
 
     # -------------------------------------------------------------------------
-    # END HELPERS IN BOTH PYTHON/JAVASCRIPT (account_tax.js)
+    # GENERIC REPRESENTATION OF BUSINESS OBJECTS & METHODS
     # -------------------------------------------------------------------------
 
     @api.model
-    def _apply_taxes_computation_split_repartition_lines(
-        self,
-        taxes_data,
-        currency,
-        is_refund=False,
-        include_caba_tags=False,
-        rounding_method='round_per_line',
-    ):
+    def _get_base_line_field_value_from_record(self, record, field, extra_values, fallback):
+        """ Helper to extract a default value for a record or something looking like a record.
+
+        Suppose field is 'product_id' and fallback is 'self.env['product.product']'
+
+        if record is an account.move.line, the returned product_id will be `record.product_id._origin`.
+        if record is a dict, the returned product_id will be `record.get('product_id', fallback)`.
+
+        :param record:          A record or a dict or a falsy value.
+        :param field:           The name of the field to extract.
+        :param extra_values:    The extra kwargs passed in addition of 'record'.
+        :param fallback:        The value to return if not found in record or extra_values.
+        :return:                The field value corresponding to 'field'.
+        """
+        need_origin = isinstance(fallback, models.Model)
+        if field in extra_values:
+            value = extra_values[field] or fallback
+        elif isinstance(record, models.Model) and field in record._fields:
+            value = record[field]
+        else:
+            value = fallback
+        if need_origin:
+            value = value._origin
+        return value
+
+    @api.model
+    def _prepare_base_line_for_taxes_computation(self, record, **kwargs):
+        """ Convert any representation of a business object ('record') into a base line being a python
+        dictionary that will be used to use the generic helpers for the taxes computation.
+
+        The whole method is designed to ease the conversion from a business record.
+        For example, when passing either account.move.line, either sale.order.line or purchase.order.line,
+        providing explicitely a 'product_id' in kwargs is not necessary since all those records already have
+        an `product_id` field.
+
+        :param record:  A representation of a business object a.k.a a record or a dictionary.
+        :param kwargs:  The extra values to override some values that will be taken from the record.
+        :return:        A dictionary representing a base line.
+        """
+        def load(field, fallback):
+            return self._get_base_line_field_value_from_record(record, field, kwargs, fallback)
+
+        return {
+            **kwargs,
+            'record': record,
+            'id': load('id', 0),
+
+            # Basic fields:
+            'product_id': load('product_id', self.env['product.product']),
+            'tax_ids': load('tax_ids', self.env['account.tax']),
+            'price_unit': load('price_unit', 0.0),
+            'quantity': load('quantity', 0.0),
+            'discount': load('discount', 0.0),
+            'currency_id': load('currency_id', self.env['res.currency']),
+
+            # The special_mode for the taxes computation:
+            # - False for the normal behavior.
+            # - total_included to force all taxes to be price included.
+            # - total_excluded to force all taxes to be price excluded.
+            'special_mode': kwargs.get('special_mode', False),
+
+            # A special typing of base line for some custom behavior:
+            # - False for the normal behavior.
+            # - early_payment if the base line represent an early payment in mixed mode.
+            # - cash_rounding if the base line is a delta to round the business object for the cash rounding feature.
+            'special_type': kwargs.get('special_type', False),
+
+            # All computation are managing the foreign currency and the local one.
+            # This is the rate to be applied when generating the tax details (see '_add_tax_details_in_base_line').
+            'rate': load('rate', 1.0),
+
+            # ===== Accounting stuff =====
+
+            # The sign of the business object regarding its accounting balance.
+            'sign': load('sign', 1.0),
+
+            # If the document is a refund or not to know which repartition lines must be used.
+            'is_refund': load('is_refund', False),
+
+            # If the tags must be inverted or not.
+            'tax_tag_invert': load('tax_tag_invert', False),
+
+            # Extra fields for tax lines generation:
+            'partner_id': load('partner_id', self.env['res.partner']),
+            'account_id': load('account_id', self.env['account.account']),
+            'analytic_distribution': load('analytic_distribution', None),
+        }
+
+    @api.model
+    def _prepare_tax_line_for_taxes_computation(self, record, **kwargs):
+        """ Convert any representation of an accounting tax line ('record') into a python
+        dictionary that will be used to use by `_prepare_tax_lines` to detect which tax line
+        could be updated, the ones to be created and the ones to be deleted.
+        We can't use directly an account.move.line because this is also used by
+        - expense (to create the journal entry)
+        - the bank reconciliation widget (to generate the bank.rec.widget.line corresponding to tax lines)
+        All fields in this list are the same as the corresponding fields defined in account.move.line.
+
+        The mechanism is the same as '_prepare_base_line_for_taxes_computation'.
+
+        :param record:  A representation of a business object a.k.a a record or a dictionary.
+        :param kwargs:  The extra values to override some values that will be taken from the record.
+        :return:        A dictionary representing a tax line.
+        """
+        def load(field, fallback):
+            return self._get_base_line_field_value_from_record(record, field, kwargs, fallback)
+
+        return {
+            **kwargs,
+            'record': record,
+            'id': load('id', 0),
+            'tax_repartition_line_id': load('tax_repartition_line_id', self.env['account.tax.repartition.line']),
+            'group_tax_id': load('group_tax_id', self.env['account.tax']),
+            'tax_ids': load('tax_ids', self.env['account.tax']),
+            'tax_tag_ids': load('tax_tag_ids', self.env['account.account.tag']),
+            'currency_id': load('currency_id', self.env['res.currency']),
+            'partner_id': load('partner_id', self.env['res.partner']),
+            'account_id': load('account_id', self.env['account.account']),
+            'analytic_distribution': load('analytic_distribution', None),
+            'sign': load('sign', 1.0),
+            'amount_currency': load('amount_currency', 0.0),
+            'balance': load('balance', 0.0),
+        }
+
+    @api.model
+    def _add_tax_details_in_base_line(self, base_line, company, rounding_method=None):
+        """ Perform the taxes computation for the base line and add it to the base line under
+        the 'tax_details' key. Those values are rounded or not depending of the tax calculation method.
+        If you need to compute monetary fields with that, you probably need to call
+        '_round_base_lines_tax_details' after this method.
+
+        The added tax_details is a dictionary containing:
+        total_excluded_currency:    The total without tax expressed in foreign currency.
+        total_excluded:             The total without tax expressed in local currency.
+        total_included_currency:    The total tax included expressed in foreign currency.
+        total_included:             The total tax included expressed in local currency.
+        taxes_data:                 A list of python dictionary containing the taxes_data returned by '_get_tax_details' but
+                                    with the amounts expressed in both currencies:
+            tax_amount_currency         The tax amount expressed in foreign currency.
+            tax_amount                  The tax amount expressed in local currency.
+            base_amount_currency        The tax base amount expressed in foreign currency.
+            base_amount                 The tax base amount expressed in local currency.
+
+        :param base_line:       A base line generated by '_prepare_base_line_for_taxes_computation'.
+        :param company:         The company owning the base line.
+        :param rounding_method: The rounding method to be used. If not specified, it will be taken from the company.
+        """
+        price_unit_after_discount = base_line['price_unit'] * (1 - (base_line['discount'] / 100.0))
+        taxes_computation = base_line['tax_ids']._get_tax_details(
+            price_unit=price_unit_after_discount,
+            quantity=base_line['quantity'],
+            precision_rounding=base_line['currency_id'].rounding,
+            rounding_method=rounding_method or company.tax_calculation_rounding_method,
+            product=base_line['product_id'],
+            special_mode=base_line['special_mode'],
+        )
+        rate = base_line['rate']
+        tax_details = base_line['tax_details'] = {
+            'total_excluded_currency': taxes_computation['total_excluded'],
+            'total_excluded': taxes_computation['total_excluded'] / rate if rate else 0.0,
+            'total_included_currency': taxes_computation['total_included'],
+            'total_included': taxes_computation['total_included'] / rate if rate else 0.0,
+            'taxes_data': [],
+        }
+        if company.tax_calculation_rounding_method == 'round_per_line':
+            tax_details['total_excluded'] = company.currency_id.round(tax_details['total_excluded'])
+            tax_details['total_included'] = company.currency_id.round(tax_details['total_included'])
+        for tax_data in taxes_computation['taxes_data']:
+            tax_amount = tax_data['tax_amount'] / rate if rate else 0.0
+            base_amount = tax_data['base_amount'] / rate if rate else 0.0
+            if company.tax_calculation_rounding_method == 'round_per_line':
+                tax_amount = company.currency_id.round(tax_amount)
+                base_amount = company.currency_id.round(base_amount)
+            tax_details['taxes_data'].append({
+                **tax_data,
+                'tax_amount_currency': tax_data['tax_amount'],
+                'tax_amount': tax_amount,
+                'base_amount_currency': tax_data['base_amount'],
+                'base_amount': base_amount,
+            })
+
+    @api.model
+    def _add_tax_details_in_base_lines(self, base_lines, company):
+        """ Shortcut to call '_add_tax_details_in_base_line' on multiple base lines at once.
+
+        :param base_lines:  A list of base lines.
+        :param company:     The company owning the base lines.
+        """
+        for base_line in base_lines:
+            self._add_tax_details_in_base_line(base_line, company)
+
+    @api.model
+    def _round_base_lines_tax_details(self, base_lines, company, tax_lines=None):
+        """ Round the 'tax_details' added to base_lines with the '_add_accounting_data_to_base_line_tax_details'.
+        This method performs all the rounding and take care of rounding issues that could appear when using the
+        'round_globally' tax computation method, specially if some price included taxes are involved.
+
+        This method copy all float values in separated keys prefixed by 'raw_'.
+        In almost all countries, the round globally should be the tax computation method.
+        When there is an EDI, we need the raw amounts to be reported with more decimals (usually 6 to 8).
+        So if you need to report the price excluded amount for a single line, you need to use
+        'raw_total_excluded_currency' / 'raw_total_excluded' instead of 'total_excluded_currency' / 'total_excluded' because
+        the latest are rounded. In short, rounding yourself the amounts is probably a mistake and you are probably adding some
+        rounding issues in your code.
+
+        The rounding is made by aggregating the raw amounts per tax first.
+        Then we round the total amount per tax, same for each tax amount in each base lines.
+        Finally, we distribute the delta on each base lines.
+        The delta is available in 'delta_base_amount_currency' / 'delta_base_amount' in each base line.
+
+        Let's take an example using round globally.
+        Suppose two lines:
+        l1: price_unit = 21.53, tax = 21% incl
+        l2: price_unit = 21.53, tax = 21% incl
+
+        The raw_total_excluded is computed as 21.53 / 1.21 = 17.79338843
+        The total_excluded is computed as round(17.79338843) = 17.79
+        The total raw_base_amount for 21% incl is computed as 17.79338843 * 2 = 35.58677686
+        The total base_amount for 21% incl is round(35.58677686) = 35.59
+        The delta_base_amount is computed as 35.59 - 17.79 - 17.79 = 0.01 and will be added on l1.
+
+        For the tax amounts:
+        The raw_tax_amount is computed as 21.53 / 1.21 * 0.21 = 3.73661157
+        The tax_amount is computed as round(3.73661157) = 3.74
+        The total raw_tax_amount for 21% incl is computed as 3.73661157 * 2 = 7.473223141
+        The total tax_amount for 21% incl is computed as round(7.473223141) = 7.47
+        The delta amount for 21% incl is computed as 7.47 - 3.74 - 3.74 = -0.01 and will be added to the corresponding
+        tax_data in l1.
+
+        If l1 and l2 are invoice lines, the result will be:
+        l1: price_unit = 21.53, tax = 21% incl, price_subtotal = 17.79, price_total = 21.53, balance = 17.80
+        l2: price_unit = 21.53, tax = 21% incl, price_subtotal = 17.79, price_total = 21.53, balance = 17.79
+        To compute the tax lines, we use the tax details in base_line['tax_details']['taxes_data'] that contain
+        respectively 3.73 + 3.74 = 7.47.
+        Since the untaxed amount of the invoice is computed based on the accounting balance:
+        amount_untaxed = 17.80 + 17.79 = 35.59
+        amount_tax = 7.47
+        amount_total = 21.53 + 21.53 = 43.06
+
+        The amounts are globally correct because 35.59 * 0.21 = 7.4739 ~= 7.47.
+
+        :param base_lines:          A list of base lines generated using the '_prepare_base_line_for_taxes_computation' method.
+        :param company:             The company owning the base lines.
+        :param tax_lines:           A optional list of base lines generated using the '_prepare_tax_line_for_taxes_computation'
+                                    method. If specified, the tax amounts will be computed based on those existing tax lines.
+                                    It's used to keep the manual tax amounts set by the user.
+        """
+        total_per_tax = defaultdict(lambda: {
+            'base_amount_currency': 0.0,
+            'base_amount': 0.0,
+            'raw_base_amount_currency': 0.0,
+            'raw_base_amount': 0.0,
+            'tax_amount_currency': 0.0,
+            'tax_amount': 0.0,
+            'raw_tax_amount_currency': 0.0,
+            'raw_tax_amount': 0.0,
+            'base_lines': [],
+        })
+
+        for base_line in base_lines:
+            currency = base_line['currency_id']
+            tax_details = base_line['tax_details']
+            tax_details['delta_base_amount_currency'] = 0.0
+            tax_details['delta_base_amount'] = 0.0
+            tax_details['raw_total_excluded_currency'] = tax_details['total_excluded_currency']
+            tax_details['total_excluded_currency'] = currency.round(tax_details['total_excluded_currency'])
+            tax_details['raw_total_excluded'] = tax_details['total_excluded']
+            tax_details['total_excluded'] = company.currency_id.round(tax_details['total_excluded'])
+            tax_details['raw_total_included_currency'] = tax_details['total_included_currency']
+            tax_details['total_included_currency'] = currency.round(tax_details['total_included_currency'])
+            tax_details['raw_total_included'] = tax_details['total_included']
+            tax_details['total_included'] = company.currency_id.round(tax_details['total_included'])
+
+            for tax_data in tax_details['taxes_data']:
+                tax = tax_data['tax']
+
+                tax_data['raw_tax_amount_currency'] = tax_data['tax_amount_currency']
+                tax_data['tax_amount_currency'] = currency.round(tax_data['tax_amount_currency'])
+                tax_data['raw_tax_amount'] = tax_data['tax_amount']
+                tax_data['tax_amount'] = company.currency_id.round(tax_data['tax_amount'])
+                tax_data['raw_base_amount_currency'] = tax_data['base_amount_currency']
+                tax_data['base_amount_currency'] = currency.round(tax_data['base_amount_currency'])
+                tax_data['raw_base_amount'] = tax_data['base_amount']
+                tax_data['base_amount'] = company.currency_id.round(tax_data['base_amount'])
+
+                key = (tax, currency, base_line['is_refund'])
+                amounts = total_per_tax[key]
+                amounts['tax_amount_currency'] += tax_data['tax_amount_currency']
+                amounts['raw_tax_amount_currency'] += tax_data['raw_tax_amount_currency']
+                amounts['tax_amount'] += tax_data['tax_amount']
+                amounts['raw_tax_amount'] += tax_data['raw_tax_amount']
+                amounts['base_amount_currency'] += tax_data['base_amount_currency']
+                amounts['raw_base_amount_currency'] += tax_data['raw_base_amount_currency']
+                amounts['base_amount'] += tax_data['base_amount']
+                amounts['raw_base_amount'] += tax_data['raw_base_amount']
+                if not base_line['special_type']:
+                    amounts['base_lines'].append(base_line)
+
+        # Round 'total_per_tax'.
+        for (tax, currency, _is_refund), amounts in total_per_tax.items():
+            amounts['raw_tax_amount_currency'] = currency.round(amounts['raw_tax_amount_currency'])
+            amounts['raw_tax_amount'] = company.currency_id.round(amounts['raw_tax_amount'])
+            amounts['raw_base_amount_currency'] = currency.round(amounts['raw_base_amount_currency'])
+            amounts['raw_base_amount'] = company.currency_id.round(amounts['raw_base_amount'])
+
+        # If tax lines are provided, the totals will be aggregated according them.
+        if tax_lines:
+            manually_edited_tax_key = set()
+            for tax_line in tax_lines:
+                tax_rep = tax_line['tax_repartition_line_id']
+                sign = tax_line['sign']
+                tax = tax_rep.tax_id
+                currency = tax_line['currency_id']
+                key = (tax, currency, tax_rep.document_type == 'refund')
+
+                if key not in manually_edited_tax_key:
+                    total_per_tax[key]['raw_tax_amount_currency'] = 0.0
+                    total_per_tax[key]['raw_tax_amount'] = 0.0
+                    manually_edited_tax_key.add(key)
+                total_per_tax[key]['raw_tax_amount_currency'] += sign * tax_line['amount_currency']
+                total_per_tax[key]['raw_tax_amount'] += sign * tax_line['balance']
+
+        # Dispatch the delta accross the base lines.
+        for (tax, _currency, _is_refund), amounts in total_per_tax.items():
+            if not amounts['base_lines']:
+                continue
+
+            base_line = min(
+                amounts['base_lines'],
+                key=lambda base_line: base_line['tax_details']['total_included_currency'],
+            )
+            tax_details = base_line['tax_details']
+            index, tax_data = next((i, x) for i, x in enumerate(tax_details['taxes_data']) if x['tax'] == tax)
+            delta_base_amount_currency = amounts['raw_base_amount_currency'] - amounts['base_amount_currency']
+            delta_base_amount = amounts['raw_base_amount'] - amounts['base_amount']
+            if index == 0:
+                tax_details['delta_base_amount_currency'] += delta_base_amount_currency
+                tax_details['delta_base_amount'] += delta_base_amount
+            tax_data['base_amount_currency'] += delta_base_amount_currency
+            tax_data['base_amount'] += delta_base_amount
+            tax_data['tax_amount_currency'] += amounts['raw_tax_amount_currency'] - amounts['tax_amount_currency']
+            tax_data['tax_amount'] += amounts['raw_tax_amount'] - amounts['tax_amount']
+
+    @api.model
+    def _prepare_base_line_grouping_key(self, base_line):
+        """ Used by '_prepare_tax_lines' to build the accounting grouping key to generate the tax lines.
+        This method takes all relevant fields from the base line that will be used to build the grouping_key.
+
+        :param base_line: A base line generated by '_prepare_base_line_for_taxes_computation'.
+        :return: The grouping key to generate the tax line for a single base line.
+        """
+        return {
+            'partner_id': base_line['partner_id'].id,
+            'currency_id': base_line['currency_id'].id,
+            'analytic_distribution': base_line['analytic_distribution'],
+            'account_id': base_line['account_id'].id,
+            'tax_ids': [Command.set(base_line['tax_ids'].ids)],
+        }
+
+    @api.model
+    def _prepare_base_line_tax_repartition_grouping_key(self, base_line, base_line_grouping_key, tax_data, tax_rep_data):
+        """ Used by '_prepare_tax_lines' to build the accounting grouping key to generate the tax lines.
+        This method adds all relevant fields from a single tax data to the grouping key.
+
+        :param base_line:               A base line generated by '_prepare_base_line_for_taxes_computation'.
+        :param base_line_grouping_key:  The grouping key created by '_prepare_base_line_grouping_key'.
+        :param tax_data:                One of the tax data in base_line['tax_details']['taxes_data'].
+        :param tax_rep_data:            One of the tax repartition data in tax_data['tax_reps_data'].
+        :return: The grouping key to generate the tax line for tax repartition line.
+        """
+        tax = tax_data['tax']
+        tax_rep = tax_rep_data['tax_rep']
+        return {
+            **base_line_grouping_key,
+            'tax_repartition_line_id': tax_rep.id,
+            'partner_id': base_line['partner_id'].id,
+            'currency_id': base_line['currency_id'].id,
+            'group_tax_id': tax_data['group'].id,
+            'analytic_distribution': (
+                base_line_grouping_key['analytic_distribution']
+                if tax.analytic or not tax_rep.use_in_tax_closing
+                else {}
+            ),
+            'account_id': tax_rep_data['account'].id or base_line_grouping_key['account_id'],
+            'tax_ids': [Command.set(tax_rep_data['taxes'].ids)],
+            'tax_tag_ids': [Command.set(tax_rep_data['tax_tags'].ids)],
+        }
+
+    @api.model
+    def _prepare_tax_line_repartition_grouping_key(self, tax_line):
+        """ Used by '_prepare_tax_lines' to build the accounting grouping key to know if the tax line could be updated
+        or not when recomputing the tax lines.
+        Take care this method should remain consistent regarding the grouping key built from the base line.
+
+        :param tax_line: A tax line generated by '_prepare_tax_line_for_taxes_computation'.
+        :return: The grouping key for the tax line passed as parameter.
+        """
+        return {
+            'tax_repartition_line_id': tax_line['tax_repartition_line_id'].id,
+            'partner_id': tax_line['partner_id'].id,
+            'currency_id': tax_line['currency_id'].id,
+            'group_tax_id': tax_line['group_tax_id'].id,
+            'analytic_distribution': tax_line['analytic_distribution'],
+            'account_id': tax_line['account_id'].id,
+            'tax_ids': [Command.set(tax_line['tax_ids'].ids)],
+            'tax_tag_ids': [Command.set(tax_line['tax_tag_ids'].ids)],
+        }
+
+    @api.model
+    def _add_accounting_data_to_base_line_tax_details(self, base_line, company, include_caba_tags=False):
+        """ Add all informations about repartition lines to base_line['tax_details']['taxes_data'].
+
+        Considering a single tax_data, this method adds 'tax_reps_data', being a list of python dictionaries containing:
+            tax_rep:                The account.tax.repartition.line record.
+            tax_amount_currency:    The tax amount expressed in foreign currency.
+            tax_amount:             The tax amount expressed in local currency.
+            account:                The accounting account record to consider for this tax repartition line.
+            taxes:                  The taxes to be set on the tax line if the tax affects the base of subsequent taxes.
+            tax_tags:               The tags for the tax report.
+            grouping_key:           The grouping key used to generate this tax line.
+
+        This method also adds 'tax_tag_ids' to the base line containing the tags for the tax report.
+
+        :param base_line:               A base line generated by '_prepare_base_line_for_taxes_computation'.
+        :param company:                 The company owning the base line.
+        :param include_caba_tags:       Indicate if the cash basis tags need to be taken into account.
+        """
+        is_refund = base_line['is_refund']
+        currency = base_line['currency_id']
+        product = base_line['product_id']
+        company_currency = company.currency_id
         if is_refund:
             repartition_lines_field = 'refund_repartition_line_ids'
         else:
             repartition_lines_field = 'invoice_repartition_line_ids'
 
-        tax_rep_values_list = []
+        # Tags on the base line.
+        taxes_data = base_line['tax_details']['taxes_data']
+        base_line['tax_tag_ids'] = self.env['account.account.tag']
+        if product:
+            countries = {tax_data['tax'].country_id for tax_data in taxes_data}
+            countries.add(False)
+            base_line['tax_tag_ids'] |= product.sudo().account_tag_ids
+
         for tax_data in taxes_data:
             tax = tax_data['tax']
 
-            # Split naively by repartition line.
-            rep_lines = tax[repartition_lines_field].filtered(lambda x: x.repartition_type == 'tax')
-            repartition_line_amounts = [tax_data['tax_amount_unfactorized'] * line.factor for line in rep_lines]
-            if rounding_method == 'round_per_line':
-                repartition_line_amounts = [currency.round(x) for x in repartition_line_amounts]
-            total_repartition_line_amount = sum(repartition_line_amounts)
-
-            # Fix the rounding error caused by rounding.
-            total_error = tax_data['tax_amount'] - total_repartition_line_amount
-            error_sign = -1 if total_error < 0.0 else 1
-            total_error *= error_sign
-            for index, _amount in enumerate(repartition_line_amounts):
-                if not total_error:
-                    break
+            # Tags on the base line.
+            if not tax_data['is_reverse_charge'] and (include_caba_tags or tax.tax_exigibility == 'on_invoice'):
+                base_line['tax_tag_ids'] |= tax[repartition_lines_field].filtered(lambda x: x.repartition_type == 'base').tag_ids
 
-                # Don't allocate more than one currency unit.
-                # The error is smoothly dispatched on repartition lines.
-                # If you have 5 repartition lines and 0.03 to dispatch, three of them will take 0.01 instead of
-                # only one getting 0.03.
-                error = min(total_error, currency.rounding)
-                total_error -= error
-                repartition_line_amounts[index] += error_sign * error
+            # Compute repartition lines amounts.
+            if tax_data['is_reverse_charge']:
+                tax_reps = tax[repartition_lines_field].filtered(lambda x: x.repartition_type == 'tax' and x.factor < 0.0)
+                tax_rep_sign = -1.0
+            else:
+                tax_reps = tax[repartition_lines_field].filtered(lambda x: x.repartition_type == 'tax' and x.factor >= 0.0)
+                tax_rep_sign = 1.0
 
-            for rep_line, line_amount in zip(rep_lines, repartition_line_amounts):
+            total_tax_rep_amounts = {
+                'tax_amount_currency': 0.0,
+                'tax_amount': 0.0,
+            }
+            tax_reps_data = tax_data['tax_reps_data'] = []
+            for tax_rep in tax_reps:
+                tax_rep_data = {
+                    'tax_rep': tax_rep,
+                    'tax_amount_currency': currency.round(tax_data['tax_amount_currency'] * tax_rep.factor * tax_rep_sign),
+                    'tax_amount': currency.round(tax_data['tax_amount'] * tax_rep.factor * tax_rep_sign),
+                    'account': tax_rep._get_aml_target_tax_account(force_caba_exigibility=include_caba_tags) or base_line['account_id'],
+                }
+                total_tax_rep_amounts['tax_amount_currency'] += tax_rep_data['tax_amount_currency']
+                total_tax_rep_amounts['tax_amount'] += tax_rep_data['tax_amount']
+                tax_reps_data.append(tax_rep_data)
+
+            # Distribute the delta on the repartition lines.
+            sorted_tax_reps_data = sorted(
+                tax_reps_data,
+                key=lambda tax_rep: (-abs(tax_rep['tax_amount_currency']), -abs(tax_rep['tax_amount'])),
+            )
+            for field, field_currency in (('tax_amount_currency', currency), ('tax_amount', company_currency)):
+                total_error = tax_data[field] - total_tax_rep_amounts[field]
+                nb_of_errors = round(abs(total_error / field_currency.rounding))
+                if not nb_of_errors:
+                    continue
+
+                amount_to_distribute = total_error / nb_of_errors
+                for tax_rep in sorted_tax_reps_data[:nb_of_errors]:
+                    tax_rep[field] += amount_to_distribute
+
+        subsequent_taxes = self.env['account.tax']
+        subsequent_tags = self.env['account.account.tag']
+        for tax_data in reversed(taxes_data):
+            tax = tax_data['tax']
+
+            for tax_rep_data in tax_data['tax_reps_data']:
+                tax_rep = tax_rep_data['tax_rep']
+
+                # Compute subsequent taxes/tags.
+                tax_rep_data['taxes'] = self.env['account.tax']
+                tax_rep_data['tax_tags'] = self.env['account.account.tag']
+                if include_caba_tags or tax.tax_exigibility == 'on_invoice':
+                    tax_rep_data['tax_tags'] = tax_rep.tag_ids
+                if tax.include_base_amount:
+                    tax_rep_data['taxes'] |= subsequent_taxes
+                    tax_rep_data['tax_tags'] |= subsequent_tags
+
+                # Add the accounting grouping_key to create the tax lines.
+                base_line_grouping_key = self._prepare_base_line_grouping_key(base_line)
+                tax_rep_data['grouping_key'] = self._prepare_base_line_tax_repartition_grouping_key(
+                    base_line,
+                    base_line_grouping_key,
+                    tax_data,
+                    tax_rep_data,
+                )
+
+            if tax.is_base_affected:
+                subsequent_taxes |= tax
+                if include_caba_tags or tax.tax_exigibility == 'on_invoice':
+                    subsequent_tags |= tax[repartition_lines_field].filtered(lambda x: x.repartition_type == 'base').tag_ids
+
+    @api.model
+    def _add_accounting_data_in_base_lines_tax_details(self, base_lines, company, include_caba_tags=False):
+        """ Shortcut to call '_add_accounting_data_to_base_line_tax_details' on multiple base lines at once.
+
+        :param base_lines:          A list of base lines.
+        :param company:             The company owning the base lines.
+        :param include_caba_tags:   Indicate if the cash basis tags need to be taken into account.
+        """
+        for base_line in base_lines:
+            self._add_accounting_data_to_base_line_tax_details(base_line, company, include_caba_tags=include_caba_tags)
+
+    # -------------------------------------------------------------------------
+    # AGGREGATOR OF TAX DETAILS
+    # -------------------------------------------------------------------------
+
+    @api.model
+    def _aggregate_base_line_tax_details(self, base_line, grouping_function):
+        """ Aggregate the tax details for a single line according a custom grouping function passed as parameter.
+        This method is mainly use for EDI to report some data per line. Most of the time, having the amounts grouped
+        by tax is not enough because some details should be excluded, aggregated together or just moved into a separated section
+        having another grouping key.
+
+        In case the base_line has no tax, the detail is added under the 'None' grouping key.
+        It's needed when you need to add some tax details plus the total base amount at the same time.
+        So when iterating on the result of this method, take care of the 'None' grouping key.
+
+        Don't forget to call '_add_tax_details_in_base_lines' and '_round_base_lines_tax_details' before calling this method.
+
+        :param base_line:           A base line generated by '_prepare_base_line_for_taxes_computation'.
+        :param grouping_function:   A function taking <base_line, tax_data> as parameter and returning anything
+                                    that could be used as key in a dictionary.
+                                    Note: you must never return None (explanation in the docstring above).
+        :return: A mapping <grouping_key, amounts> where:
+            grouping_key                is the grouping_key returned by the 'grouping_function' or 'None'.
+            amounts                     is a dictionary containing:
+                base_amount_currency:       The base amount of this grouping key expressed in foreign currency.
+                base_amount:                The base amount of this grouping key expressed in local currency.
+                raw_base_amount_currency:   The base amount of this grouping key expressed in foreign currency before any rounding.
+                raw_base_amount:            The base amount of this grouping key expressed in local currency before any rounding.
+                tax_amount_currency:        The tax amount of this grouping key expressed in foreign currency.
+                tax_amount:                 The tax amount of this grouping key expressed in local currency.
+                raw_tax_amount_currency:    The tax amount of this grouping key expressed in foreign currency before any rounding.
+                raw_tax_amount:             The tax amount of this grouping key expressed in local currency before any rounding.
+                taxes_data:                 The subset of base_line['tax_details']['taxes_data'] aggregated under this grouping_key.
+        """
+        values_per_grouping_key = defaultdict(lambda: {
+            'base_amount_currency': 0.0,
+            'base_amount': 0.0,
+            'raw_base_amount_currency': 0.0,
+            'raw_base_amount': 0.0,
+            'tax_amount_currency': 0.0,
+            'tax_amount': 0.0,
+            'raw_tax_amount_currency': 0.0,
+            'raw_tax_amount': 0.0,
+            'taxes_data': [],
+        })
+
+        tax_details = base_line['tax_details']
+        taxes_data = tax_details['taxes_data']
+        for tax_data in taxes_data:
+            grouping_key = grouping_function(base_line, tax_data)
+            if isinstance(grouping_key, dict):
+                grouping_key = frozendict(grouping_key)
+            already_accounted = grouping_key in values_per_grouping_key
+            values = values_per_grouping_key[grouping_key]
+            values['grouping_key'] = grouping_key
+            values['taxes_data'].append(tax_data)
+
+            # Base amount.
+            if not already_accounted:
+                values['base_amount_currency'] += tax_data['base_amount_currency']
+                values['base_amount'] += tax_data['base_amount']
+                values['raw_base_amount_currency'] += tax_data['raw_base_amount_currency']
+                values['raw_base_amount'] += tax_data['raw_base_amount']
+
+            # Tax amount.
+            values['tax_amount_currency'] += tax_data['tax_amount_currency']
+            values['tax_amount'] += tax_data['tax_amount']
+            values['raw_tax_amount_currency'] += tax_data['raw_tax_amount_currency']
+            values['raw_tax_amount'] += tax_data['raw_tax_amount']
+
+        if not taxes_data:
+            values = values_per_grouping_key[None]
+            values['grouping_key'] = None
+            values['base_amount_currency'] += tax_details['total_excluded_currency']
+            values['base_amount'] += tax_details['total_excluded']
+            values['raw_base_amount_currency'] += tax_details['raw_total_excluded_currency']
+            values['raw_base_amount'] += tax_details['raw_total_excluded']
+
+        return values_per_grouping_key
+
+    @api.model
+    def _aggregate_base_lines_tax_details(self, base_lines, grouping_function):
+        """ Shortcut to call '_aggregate_base_line_tax_details' on multiple base lines at once.
+
+        :param base_lines:          A list of base lines.
+        :param grouping_function:   See '_aggregate_base_line_tax_details'.
+        :return                     A list of tuple <base_line, results> that associates the result of
+                                    '_aggregate_base_line_tax_details' for each base line independently.
+        """
+        return [
+            (base_line, self._aggregate_base_line_tax_details(base_line, grouping_function))
+            for base_line in base_lines
+        ]
+
+    @api.model
+    def _aggregate_base_lines_aggregated_values(self, base_lines_aggregated_values):
+        """ Aggregate the values returned by '_aggregate_base_lines_tax_details' for the whole document.
+        Most of the time, in EDI, you have to report unrounded amounts for each base line first and then,
+        you need to report all rounded amounts for the whole business document.
+
+        :param base_lines_aggregated_values:    The result of '_aggregate_base_lines_tax_details'.
+        :return: A mapping <grouping_key, amounts> where:
+            grouping_key                is the grouping_key returned by the 'grouping_function' or 'None'.
+            amounts                     is a dictionary containing:
+                base_amount_currency:       The base amount of this grouping key expressed in foreign currency.
+                base_amount:                The base amount of this grouping key expressed in local currency.
+                raw_base_amount_currency:   The base amount of this grouping key expressed in foreign currency before any rounding.
+                raw_base_amount:            The base amount of this grouping key expressed in local currency before any rounding.
+                tax_amount_currency:        The tax amount of this grouping key expressed in foreign currency.
+                tax_amount:                 The tax amount of this grouping key expressed in local currency.
+                raw_tax_amount_currency:    The tax amount of this grouping key expressed in foreign currency before any rounding.
+                raw_tax_amount:             The tax amount of this grouping key expressed in local currency before any rounding.
+                base_line_x_taxes_data:     A list of tuple <base_line, taxes_data> that associates for each base_line the
+                                            subset of base_line['tax_details']['taxes_data'] aggregated under this grouping_key.
+        """
+        default_float_fields = {
+            'base_amount_currency',
+            'base_amount',
+            'raw_base_amount_currency',
+            'raw_base_amount',
+            'tax_amount_currency',
+            'tax_amount',
+            'raw_tax_amount_currency',
+            'raw_tax_amount',
+        }
+        values_per_grouping_key = defaultdict(lambda: {
+            **dict.fromkeys(default_float_fields, 0.0),
+            'base_line_x_taxes_data': [],
+        })
+
+        for base_line, aggregated_values in base_lines_aggregated_values:
+            for grouping_key, values in aggregated_values.items():
+                agg_values = values_per_grouping_key[grouping_key]
+                for field in default_float_fields:
+                    agg_values[field] += values[field]
+                agg_values['grouping_key'] = grouping_key
 
-                # Tags.
-                if not include_caba_tags and tax.tax_exigibility == 'on_payment':
-                    rep_line_tags = self.env['account.account.tag']
+                agg_values['base_line_x_taxes_data'].append((base_line, values['taxes_data']))
+
+        return values_per_grouping_key
+
+    # -------------------------------------------------------------------------
+    # TAX TOTALS SUMMARY
+    # -------------------------------------------------------------------------
+
+    @api.model
+    def _get_tax_totals_summary(self, base_lines, currency, company, cash_rounding=None):
+        """ Compute the tax totals details for the business documents.
+
+        Don't forget to call '_add_tax_details_in_base_lines' and '_round_base_lines_tax_details' before calling this method.
+
+        :param base_lines:          A list of base lines generated using the '_prepare_base_line_for_taxes_computation' method.
+        :param currency:            The tax totals is only available when all base lines share the same currency.
+                                    Since the tax totals can be computed when there is no base line at all, a currency must be
+                                    specified explicitely for that case.
+        :param company:             The company owning the base lines.
+        :param cash_rounding:       A optional account.cash.rounding object. When specified, the delta base amount added
+                                    to perform the cash rounding is specified in the results.
+        :return: A dictionary containing:
+            currency_id:                            The id of the currency used.
+            currency_pd:                            The currency rounding (to be used js-side by the widget).
+            company_currency_id:                    The id of the company's currency used.
+            company_currency_pd:                    The company's currency rounding (to be used js-side by the widget).
+            has_tax_groups:                         Flag indicating if there is at least one involved tax group.
+            base_amount_currency:                   The untaxed amount expressed in foreign currency.
+            base_amount:                            The untaxed amount expressed in local currency.
+            tax_amount_currency:                    The tax amount expressed in foreign currency.
+            tax_amount:                             The tax amount expressed in local currency.
+            total_amount_currency:                  The total amount expressed in foreign currency.
+            total_amount:                           The total amount expressed in local currency.
+            cash_rounding_base_amount_currency:     The delta added by 'cash_rounding' expressed in foreign currency.
+                                                    If there is no amount added, the key is not in the result.
+            cash_rounding_base_amount:              The delta added by 'cash_rounding' expressed in local currency.
+                                                    If there is no amount added, the key is not in the result.
+            subtotals:                              A list of subtotal (like "Untaxed Amount"), each one being a python dictionary
+                                                    containing:
+                base_amount_currency:                   The base amount expressed in foreign currency.
+                base_amount:                            The base amount expressed in local currency.
+                tax_amount_currency:                    The tax amount expressed in foreign currency.
+                tax_amount:                             The tax amount expressed in local currency.
+                tax_groups:                             A list of python dictionary, one for each tax group, containing:
+                    id:                                     The id of the account.tax.group.
+                    group_name:                             The name of the group.
+                    group_label:                            The short label of the group to be displayed on POS receipt.
+                    involved_tax_ids:                       A list of the tax ids aggregated in this tax group.
+                    base_amount_currency:                   The base amount expressed in foreign currency.
+                    base_amount:                            The base amount expressed in local currency.
+                    tax_amount_currency:                    The tax amount expressed in foreign currency.
+                    tax_amount:                             The tax amount expressed in local currency.
+                    display_base_amount_currency:           The base amount to display expressed in foreign currency.
+                                                            The flat base amount and the amount to be displayed are sometimes different
+                                                            (e.g. division/fixed taxes).
+                    display_base_amount:                    The base amount to display expressed in local currency.
+                                                            The flat base amount and the amount to be displayed are sometimes different
+                                                            (e.g. division/fixed taxes).
+        """
+        tax_totals_summary = {
+            'currency_id': currency.id,
+            'currency_pd': currency.rounding,
+            'company_currency_id': company.currency_id.id,
+            'company_currency_pd': company.currency_id.rounding,
+            'has_tax_groups': False,
+            'subtotals': [],
+            'base_amount_currency': 0.0,
+            'base_amount': 0.0,
+            'tax_amount_currency': 0.0,
+            'tax_amount': 0.0,
+        }
+
+        # Global tax values.
+        def global_grouping_function(base_line, tax_data):
+            return True
+
+        base_lines_aggregated_values = self._aggregate_base_lines_tax_details(base_lines, global_grouping_function)
+        values_per_grouping_key = self._aggregate_base_lines_aggregated_values(base_lines_aggregated_values)
+        for grouping_key, values in values_per_grouping_key.items():
+            if grouping_key:
+                tax_totals_summary['has_tax_groups'] = True
+            for key in ('base_amount_currency', 'base_amount', 'tax_amount_currency', 'tax_amount'):
+                tax_totals_summary[key] += values[key]
+
+        # Subtotals.
+        untaxed_amount_subtotal_label = _("Untaxed Amount")
+        subtotals = defaultdict(lambda: {
+            'tax_groups': [],
+            'tax_amount_currency': 0.0,
+            'tax_amount': 0.0,
+            'base_amount_currency': 0.0,
+            'base_amount': 0.0,
+        })
+
+        def subtotal_grouping_function(base_line, tax_data):
+            return tax_data['tax'].tax_group_id.preceding_subtotal or untaxed_amount_subtotal_label
+
+        base_lines_aggregated_values = self._aggregate_base_lines_tax_details(base_lines, subtotal_grouping_function)
+        values_per_grouping_key = self._aggregate_base_lines_aggregated_values(base_lines_aggregated_values)
+        for preceding_subtotal, values in values_per_grouping_key.items():
+            preceding_subtotal = preceding_subtotal or untaxed_amount_subtotal_label
+            subtotal = subtotals[preceding_subtotal]
+            for key in ('base_amount_currency', 'base_amount', 'tax_amount_currency', 'tax_amount'):
+                subtotal[key] += values[key]
+
+        # Tax groups.
+        def tax_group_grouping_function(base_line, tax_data):
+            return tax_data['tax'].tax_group_id
+
+        base_lines_aggregated_values = self._aggregate_base_lines_tax_details(base_lines, tax_group_grouping_function)
+        values_per_grouping_key = self._aggregate_base_lines_aggregated_values(base_lines_aggregated_values)
+        sorted_total_per_tax_group = sorted(
+            [values for grouping_key, values in values_per_grouping_key.items() if grouping_key],
+            key=lambda values: (values['grouping_key'].sequence, values['grouping_key'].id),
+        )
+
+        encountered_base_amounts = set()
+        subtotals_order = {}
+        for order, values in enumerate(sorted_total_per_tax_group):
+            tax_group = values['grouping_key']
+
+            # Get all involved taxes in the tax group.
+            involved_taxes = self.env['account.tax']
+            for base_line, taxes_data in values['base_line_x_taxes_data']:
+                for tax_data in taxes_data:
+                    involved_taxes |= tax_data['tax']
+
+            # Compute the display base amounts.
+            display_base_amount = values['base_amount']
+            display_base_amount_currency = values['base_amount_currency']
+            if set(involved_taxes.mapped('amount_type')) == {'fixed'}:
+                display_base_amount = None
+                display_base_amount_currency = None
+            elif set(involved_taxes.mapped('amount_type')) == {'division'} and all(involved_taxes.mapped('price_include')):
+                for base_line, _taxes_data in values['base_line_x_taxes_data']:
+                    for tax_data in base_line['tax_details']['taxes_data']:
+                        if tax_data['tax'].amount_type == 'division':
+                            display_base_amount_currency += tax_data['tax_amount_currency']
+                            display_base_amount += tax_data['tax_amount']
+
+            if display_base_amount_currency is not None:
+                encountered_base_amounts.add(float_repr(display_base_amount_currency, currency.decimal_places))
+
+            # Order of the subtotals.
+            preceding_subtotal = tax_group.preceding_subtotal or untaxed_amount_subtotal_label
+            if preceding_subtotal not in subtotals_order:
+                subtotals_order[preceding_subtotal] = order
+
+            subtotals[preceding_subtotal]['tax_groups'].append({
+                'id': tax_group.id,
+                'involved_tax_ids': involved_taxes.ids,
+                'tax_amount_currency': values['tax_amount_currency'],
+                'tax_amount': values['tax_amount'],
+                'base_amount_currency': values['base_amount_currency'],
+                'base_amount': values['base_amount'],
+                'display_base_amount_currency': display_base_amount_currency,
+                'display_base_amount': display_base_amount,
+                'group_name': tax_group.name,
+                'group_label': tax_group.pos_receipt_label,
+            })
+
+        # Cash rounding
+        cash_rounding_lines = [base_line for base_line in base_lines if base_line['special_type'] == 'cash_rounding']
+        if cash_rounding_lines:
+            tax_totals_summary['cash_rounding_base_amount_currency'] = 0.0
+            tax_totals_summary['cash_rounding_base_amount'] = 0.0
+            for base_line in cash_rounding_lines:
+                tax_details = base_line['tax_details']
+                tax_totals_summary['cash_rounding_base_amount_currency'] += tax_details['total_excluded_currency']
+                tax_totals_summary['cash_rounding_base_amount'] += tax_details['total_excluded']
+        elif cash_rounding:
+            strategy = cash_rounding.strategy
+            cash_rounding_pd = cash_rounding.rounding
+            total_amount_currency = tax_totals_summary['base_amount_currency'] + tax_totals_summary['tax_amount_currency']
+            total_amount = tax_totals_summary['base_amount'] + tax_totals_summary['tax_amount']
+            expected_total_amount_currency = float_round(total_amount_currency, precision_rounding=cash_rounding_pd)
+            cash_rounding_base_amount_currency = expected_total_amount_currency - total_amount_currency
+            if not currency.is_zero(cash_rounding_base_amount_currency):
+                rate = abs(total_amount_currency / total_amount) if total_amount else 0.0
+                cash_rounding_base_amount = company.currency_id.round(cash_rounding_base_amount_currency / rate) if rate else 0.0
+                if strategy == 'add_invoice_line':
+                    tax_totals_summary['cash_rounding_base_amount_currency'] = cash_rounding_base_amount_currency
+                    tax_totals_summary['cash_rounding_base_amount'] = cash_rounding_base_amount
+                    tax_totals_summary['base_amount_currency'] += cash_rounding_base_amount_currency
+                    tax_totals_summary['base_amount'] += cash_rounding_base_amount
+                    subtotals[untaxed_amount_subtotal_label]['base_amount_currency'] += cash_rounding_base_amount_currency
+                    subtotals[untaxed_amount_subtotal_label]['base_amount'] += cash_rounding_base_amount
+                elif strategy == 'biggest_tax':
+                    max_subtotal, max_tax_group = max(
+                        [
+                            (subtotal, tax_group)
+                            for subtotal in subtotals.values()
+                            for tax_group in subtotal['tax_groups']
+                        ],
+                        key=lambda item: item[1]['tax_amount_currency'],
+                    )
+                    max_tax_group['tax_amount_currency'] += cash_rounding_base_amount_currency
+                    max_tax_group['tax_amount'] += cash_rounding_base_amount
+                    max_subtotal['tax_amount_currency'] += cash_rounding_base_amount_currency
+                    max_subtotal['tax_amount'] += cash_rounding_base_amount
+                    tax_totals_summary['tax_amount_currency'] += cash_rounding_base_amount_currency
+                    tax_totals_summary['tax_amount'] += cash_rounding_base_amount
+
+        # Misc.
+        ordered_subtotals = sorted(subtotals.items(), key=lambda item: subtotals_order.get(item[0], 0))
+        for subtotal_label, subtotal in ordered_subtotals:
+            subtotal['name'] = subtotal_label
+            tax_totals_summary['subtotals'].append(subtotal)
+
+        tax_totals_summary['same_tax_base'] = len(encountered_base_amounts) == 1
+
+        # Total amount.
+        tax_totals_summary['total_amount_currency'] = \
+            tax_totals_summary['base_amount_currency'] + tax_totals_summary['tax_amount_currency']
+        tax_totals_summary['total_amount'] = \
+            tax_totals_summary['base_amount'] + tax_totals_summary['tax_amount']
+
+        return tax_totals_summary
+
+    @api.model
+    def _exclude_tax_groups_from_tax_totals_summary(self, tax_totals, ids_to_exclude):
+        """ Helper to post-process the tax totals and wrap some tax groups into the base amount.
+        It's used in some localizations to exclude some taxes from the details.
+
+        :param tax_totals:          The tax totals generated by '_get_tax_totals_summary'.
+        :param ids_to_exclude:      The ids of the tax groups to exclude.
+        :return:                    A new tax totals without the excluded ids.
+        """
+        tax_totals = copy.deepcopy(tax_totals)
+        ids_to_exclude = set(ids_to_exclude)
+
+        subtotals = []
+        for subtotal in tax_totals['subtotals']:
+            tax_groups = []
+            for tax_group in subtotal['tax_groups']:
+                if tax_group['id'] in ids_to_exclude:
+                    subtotal['base_amount_currency'] += tax_group['tax_amount_currency']
+                    subtotal['base_amount'] += tax_group['tax_amount']
+                    subtotal['tax_amount_currency'] -= tax_group['tax_amount_currency']
+                    subtotal['tax_amount'] -= tax_group['tax_amount']
+                    tax_totals['base_amount_currency'] += tax_group['tax_amount_currency']
+                    tax_totals['base_amount'] += tax_group['tax_amount']
+                    tax_totals['tax_amount_currency'] -= tax_group['tax_amount_currency']
+                    tax_totals['tax_amount'] -= tax_group['tax_amount']
                 else:
-                    rep_line_tags = rep_line.tag_ids
+                    tax_groups.append(tax_group)
 
-                tax_rep_values = {
-                    **tax_data,
-                    'tax_amount': line_amount,
-                    'tax_repartition_line': rep_line,
-                    'tags': tax_data['tags'] | rep_line_tags,
-                }
-                tax_rep_values.pop('tax_amount_unfactorized')
-                tax_rep_values_list.append(tax_rep_values)
-        return tax_rep_values_list
+            if tax_groups:
+                subtotal['tax_groups'] = tax_groups
+                subtotals.append(subtotal)
+
+        tax_totals['subtotals'] = subtotals
+        return tax_totals
+
+    # -------------------------------------------------------------------------
+    # TAX LINES GENERATION
+    # -------------------------------------------------------------------------
+
+    @api.model
+    def _prepare_tax_lines(self, base_lines, company, tax_lines=None):
+        """ Prepare the tax journal items for the base lines.
+
+        After calling '_add_tax_details_in_base_lines', the tax details is there on base lines.
+        After calling '_round_base_lines_tax_details', the tax details is now rounded.
+        After calling '_add_accounting_data_in_base_lines_tax_details', each tax_data in the tax details
+        contains all accounting informations about the repartition lines.
+
+        When calling this method, all 'tax_reps_data' in each 'tax_data' will be aggregated all together
+        and rounded. The total tax amount will not change whatever the number of involved accounting
+        grouping keys.
+        The 'sign' value in base lines is very important for this method because that key decide the sign
+        of the 'amount_currency'/'balance' of the base lines/tax lines to be updated/created.
+
+        Don't forget to call '_add_tax_details_in_base_lines', '_round_base_lines_tax_details' and
+        '_add_accounting_data_in_base_lines_tax_details' before calling this method.
+
+        :param base_lines:          A list of base lines generated using the '_prepare_base_line_for_taxes_computation' method.
+        :param company:             The company owning the base lines.
+        :param tax_lines:           A optional list of base lines generated using the '_prepare_tax_line_for_taxes_computation'
+                                    method. If specified, this method will indicate which tax lines must be deleted or updated instead
+                                    of creating again all tax lines everytime.
+        :return: The base amounts for base lines and the full diff about tax lines as a dictionary containing:
+            tax_lines_to_add:       A list of values to be passed to account.move.line's create function.
+            tax_lines_to_delete:    The list of tax lines to be removed.
+            tax_lines_to_update:    A list of tuple <tax_line, grouping_key, amounts> where:
+                tax_line                is the tax line to be updated,
+                grouping_key            is the accounting grouping key matching the tax line and used to determine the tax line can be
+                                        updated instead of created again,
+                amounts                 is a dictionary containing the new values for 'tax_base_amount', 'amount_currency', 'balance'.
+            base_lines_to_update:   A list of tuple <base_line, amounts> where:
+                base_line               is the base line to be updated.
+                amounts                 is a dictionary containing the new values for 'tax_tag_ids', 'amount_currency', 'balance'.
+        """
+        tax_lines_mapping = defaultdict(lambda: {
+            'tax_base_amount': 0.0,
+            'amount_currency': 0.0,
+            'balance': 0.0,
+        })
+
+        base_lines_to_update = []
+        for base_line in base_lines:
+            sign = base_line['sign']
+            tax_tag_invert = base_line['tax_tag_invert']
+            tax_details = base_line['tax_details']
+            base_lines_to_update.append((
+                base_line,
+                {
+                    'tax_tag_ids': [Command.set(base_line['tax_tag_ids'].ids)],
+                    'amount_currency': sign * (tax_details['total_excluded_currency'] + tax_details.get('delta_base_amount_currency', 0.0)),
+                    'balance': sign * (tax_details['total_excluded'] + tax_details.get('delta_base_amount', 0.0)),
+                },
+            ))
+            for tax_data in tax_details['taxes_data']:
+                tax = tax_data['tax']
+                for tax_rep_data in tax_data['tax_reps_data']:
+                    grouping_key = frozendict(tax_rep_data['grouping_key'])
+                    tax_line = tax_lines_mapping[grouping_key]
+                    tax_line['name'] = tax.name
+                    tax_line['tax_base_amount'] += sign * tax_data['base_amount'] * (-1 if tax_tag_invert else 1)
+                    tax_line['amount_currency'] += sign * tax_rep_data['tax_amount_currency']
+                    tax_line['balance'] += sign * tax_rep_data['tax_amount']
+
+        # Remove tax lines having a zero amount.
+        tax_lines_mapping = {
+            k: v
+            for k, v in tax_lines_mapping.items()
+            if (
+                not self.env['res.currency'].browse(k['currency_id']).is_zero(v['amount_currency'])
+                or not company.currency_id.is_zero(v['balance'])
+            )
+        }
+
+        # Compute 'tax_lines_to_update' / 'tax_lines_to_delete' / 'tax_lines_to_add'.
+        tax_lines_to_update = []
+        tax_lines_to_delete = []
+        for tax_line in tax_lines or []:
+            grouping_key = frozendict(self._prepare_tax_line_repartition_grouping_key(tax_line))
+            if grouping_key in tax_lines_mapping and grouping_key not in tax_lines_to_update:
+                amounts = tax_lines_mapping.pop(grouping_key)
+                tax_lines_to_update.append((tax_line, grouping_key, amounts))
+            else:
+                tax_lines_to_delete.append(tax_line)
+        tax_lines_to_add = [{**grouping_key, **values} for grouping_key, values in tax_lines_mapping.items()]
+
+        return {
+            'tax_lines_to_add': tax_lines_to_add,
+            'tax_lines_to_delete': tax_lines_to_delete,
+            'tax_lines_to_update': tax_lines_to_update,
+            'base_lines_to_update': base_lines_to_update,
+        }
+
+    # -------------------------------------------------------------------------
+    # END HELPERS IN BOTH PYTHON/JAVASCRIPT (account_tax.js)
+    # -------------------------------------------------------------------------
 
     def flatten_taxes_hierarchy(self):
         # Flattens the taxes contained in this recordset, returning all the
@@ -1226,116 +2203,6 @@ class AccountTax(models.Model):
             .filtered(lambda x: x.repartition_type == repartition_type and x.document_type == document_type)\
             .mapped('tag_ids')
 
-    @api.model
-    def _prepare_base_line_tax_details(
-        self,
-        base_line,
-        company,
-        rounding_method=None,
-        include_caba_tags=False,
-    ):
-        # Prepare computation of python taxes (see the 'account_tax_python' module).
-        price_unit = base_line['price_unit'] * (1 - (base_line['discount'] / 100.0))
-        quantity = base_line['quantity']
-        product = base_line['product']
-
-        # Prepare the tax computation.
-        taxes = base_line['taxes']._origin
-        is_refund = base_line['is_refund']
-        if rounding_method is None:
-            rounding_method = company.tax_calculation_rounding_method
-        currency = base_line['currency'] or company.currency_id
-        if (force_price_include := base_line['extra_context'].get('force_price_include')) is not None:
-            special_mode = 'total_included' if force_price_include else 'total_excluded'
-        elif not base_line['handle_price_include']:
-            special_mode = 'total_excluded'
-        else:
-            special_mode = False
-
-        taxes_computation = taxes._get_tax_details(
-            price_unit,
-            quantity,
-            precision_rounding=currency.rounding,
-            rounding_method=rounding_method,
-            product=product,
-            special_mode=special_mode,
-        )
-        taxes_data = taxes_computation['taxes_data']
-
-        # Tags on the base line.
-        if is_refund:
-            repartition_lines_field = 'refund_repartition_line_ids'
-        else:
-            repartition_lines_field = 'invoice_repartition_line_ids'
-        base_tags = self.env['account.account.tag']
-        for tax_data in taxes_data:
-            tax = tax_data['tax']
-            if include_caba_tags or tax.tax_exigibility != 'on_payment':
-                base_tags |= tax[repartition_lines_field].filtered(lambda x: x.repartition_type == 'base').tag_ids
-        if product:
-            base_tags |= product.sudo().account_tag_ids
-
-        # Compute subsequent taxes/tags & 'display_base' for the tax totals.
-        subsequent_taxes = self.env['account.tax']
-        subsequent_tags = self.env['account.account.tag']
-        for tax_data in reversed(taxes_computation['taxes_data']):
-            tax = tax_data['tax']
-            batch = tax_data['batch']
-            batch_taxes_data = [
-                taxes_computation['taxes_data'][batch_tax_data_index]
-                for batch_tax in batch
-                if (batch_tax_data_index := taxes_computation['tax_data_index'].get(batch_tax.id)) is not None
-            ]
-
-            # Fill 'taxes' / 'tags'.
-            if 'taxes' not in tax_data:
-                for batch_tax_data in batch_taxes_data:
-                    batch_tax_data['taxes'] = subsequent_taxes if tax.include_base_amount else self.env['account.tax']
-                    batch_tax_data['tags'] = subsequent_tags if tax.include_base_amount else self.env['account.account.tag']
-            subsequent_taxes |= batch
-            if include_caba_tags or tax.tax_exigibility == 'on_invoice':
-                subsequent_tags |= tax[repartition_lines_field].filtered(lambda x: x.repartition_type == 'base').tag_ids
-
-            # Compute 'display_base'.
-            total_batch_amount = sum(batch_tax_data['tax_amount'] for batch_tax_data in batch_taxes_data)
-            if tax.amount_type == 'division' and tax.price_include:
-                tax_data['display_base'] = tax_data['base_amount'] + total_batch_amount
-            else:
-                tax_data['display_base'] = tax_data['base_amount']
-
-        # Repartition lines.
-        taxes_data = taxes._apply_taxes_computation_split_repartition_lines(
-            taxes_data,
-            currency,
-            is_refund=is_refund,
-            include_caba_tags=include_caba_tags,
-            rounding_method=rounding_method,
-        )
-
-        # Apply the rate.
-        for tax_data in taxes_data:
-            rate = base_line.get('rate') or 1.0
-            tax_data['display_base_amount_currency'] = tax_data['display_base']
-            tax_data['display_base_amount'] = tax_data['display_base_amount_currency'] / rate if rate else 0.0
-            tax_data['base_amount_currency'] = tax_data['base_amount']
-            tax_data['base_amount'] = tax_data['base_amount_currency'] / rate if rate else 0.0
-            tax_data['tax_amount_currency'] = tax_data['tax_amount']
-            tax_data['tax_amount'] = tax_data['tax_amount_currency'] / rate if rate else 0.0
-            if rounding_method == 'round_per_line':
-                tax_data['display_base_amount_currency'] = currency.round(tax_data['display_base_amount_currency'])
-                tax_data['display_base_amount'] = company.currency_id.round(tax_data['display_base_amount'])
-                tax_data['base_amount_currency'] = currency.round(tax_data['base_amount_currency'])
-                tax_data['base_amount'] = company.currency_id.round(tax_data['base_amount'])
-                tax_data['tax_amount_currency'] = currency.round(tax_data['tax_amount_currency'])
-                tax_data['tax_amount'] = company.currency_id.round(tax_data['tax_amount'])
-
-        return {
-            'base_tags': base_tags,
-            'total_excluded': taxes_computation['total_excluded'],
-            'total_included': taxes_computation['total_included'],
-            'taxes_data': taxes_data,
-        }
-
     def compute_all(self, price_unit, currency=None, quantity=1.0, product=None, partner=None, is_refund=False, handle_price_include=True, include_caba_tags=False, rounding_method=None):
         """Compute all information required to apply taxes (in self + their children in case of a tax group).
         We consider the sequence of the parent for group of taxes.
@@ -1384,63 +2251,61 @@ class AccountTax(models.Model):
 
         # Compute tax details for a single line.
         currency = currency or company.currency_id
-        base_line = self._convert_to_tax_base_line_dict(
+        if 'force_price_include' in self._context:
+            special_mode = 'total_included' if self._context['force_price_include'] else 'total_excluded'
+        elif not handle_price_include:
+            special_mode = 'total_excluded'
+        else:
+            special_mode = False
+        base_line = self._prepare_base_line_for_taxes_computation(
             None,
-            partner=partner,
-            currency=currency,
-            product=product,
-            taxes=self,
+            partner_id=partner,
+            currency_id=currency,
+            product_id=product,
+            tax_ids=self,
             price_unit=price_unit,
             quantity=quantity,
             is_refund=is_refund,
-            handle_price_include=handle_price_include,
-            extra_context={'force_price_include': self._context.get('force_price_include')},
-        )
-        results = self._prepare_base_line_tax_details(
-            base_line,
-            company,
-            rounding_method=rounding_method,
-            include_caba_tags=include_caba_tags,
-        )
-        taxes_data = results['taxes_data']
-        base_tags = results['base_tags']
-        total_excluded = results['total_excluded']
-        total_included = results['total_included']
-
-        total_void = total_excluded + sum(
-            tax_data['tax_amount_currency']
-            for tax_data in taxes_data
-            if not tax_data['tax_repartition_line'].account_id
+            special_mode=special_mode,
         )
+        self._add_tax_details_in_base_line(base_line, company, rounding_method=rounding_method)
+        self._add_accounting_data_to_base_line_tax_details(base_line, company, include_caba_tags=include_caba_tags)
+
+        tax_details = base_line['tax_details']
+        total_void = total_excluded = tax_details['total_excluded_currency']
+        total_included = tax_details['total_included_currency']
 
         # Convert to the 'old' compute_all api.
         taxes = []
-        for tax_data in taxes_data:
+        for tax_data in tax_details['taxes_data']:
             tax = tax_data['tax']
-            rep_line = tax_data['tax_repartition_line']
-            taxes.append({
-                'id': tax.id,
-                'name': partner and tax.with_context(lang=partner.lang).name or tax.name,
-                'amount': tax_data['tax_amount_currency'],
-                'base': tax_data['base_amount_currency'],
-                'sequence': tax.sequence,
-                'account_id': rep_line._get_aml_target_tax_account(force_caba_exigibility=include_caba_tags).id,
-                'analytic': tax.analytic,
-                'use_in_tax_closing': rep_line.use_in_tax_closing,
-                'price_include': tax_data['tax'].price_include,
-                'tax_exigibility': tax.tax_exigibility,
-                'tax_repartition_line_id': rep_line.id,
-                'group': tax_data['group'],
-                'tag_ids': tax_data['tags'].ids,
-                'tax_ids': tax_data['taxes'].ids,
-            })
+            for tax_rep_data in tax_data['tax_reps_data']:
+                rep_line = tax_rep_data['tax_rep']
+                taxes.append({
+                    'id': tax.id,
+                    'name': partner and tax.with_context(lang=partner.lang).name or tax.name,
+                    'amount': tax_rep_data['tax_amount_currency'],
+                    'base': tax_data['base_amount_currency'],
+                    'sequence': tax.sequence,
+                    'account_id': tax_rep_data['account'].id,
+                    'analytic': tax.analytic,
+                    'use_in_tax_closing': rep_line.use_in_tax_closing,
+                    'price_include': tax.price_include,
+                    'tax_exigibility': tax.tax_exigibility,
+                    'tax_repartition_line_id': rep_line.id,
+                    'group': tax_data['group'],
+                    'tag_ids': tax_rep_data['tax_tags'].ids,
+                    'tax_ids': tax_rep_data['taxes'].ids,
+                })
+                if not rep_line.account_id:
+                    total_void += tax_rep_data['tax_amount_currency']
 
         if self._context.get('round_base', True):
             total_excluded = currency.round(total_excluded)
             total_included = currency.round(total_included)
 
         return {
-            'base_tags': base_tags.ids,
+            'base_tags': base_line['tax_tag_ids'].ids,
             'taxes': taxes,
             'total_excluded': total_excluded,
             'total_included': total_included,
@@ -1459,555 +2324,6 @@ class AccountTax(models.Model):
             company = company.parent_id
         return taxes
 
-    @api.model
-    def _convert_to_tax_base_line_dict(
-            self, base_line,
-            partner=None, currency=None, product=None, taxes=None, price_unit=None, quantity=None,
-            discount=None, account=None, analytic_distribution=None, price_subtotal=None,
-            is_refund=False, rate=None,
-            handle_price_include=True,
-            extra_context=None,
-    ):
-        if product and product._name == 'product.template':
-            product = product.product_variant_id
-        return {
-            'record': base_line,
-            'partner': partner or self.env['res.partner'],
-            'currency': currency or self.env['res.currency'],
-            'product': product or self.env['product.product'],
-            'taxes': taxes or self.env['account.tax'],
-            'price_unit': price_unit or 0.0,
-            'quantity': quantity or 0.0,
-            'discount': discount or 0.0,
-            'account': account or self.env['account.account'],
-            'analytic_distribution': analytic_distribution,
-            'price_subtotal': price_subtotal or 0.0,
-            'is_refund': is_refund,
-            'rate': rate or 1.0,
-            'handle_price_include': handle_price_include,
-            'extra_context': extra_context or {},
-        }
-
-    @api.model
-    def _convert_to_tax_line_dict(
-            self, tax_line,
-            partner=None, currency=None, taxes=None, tax_tags=None, tax_repartition_line=None,
-            group_tax=None, account=None, analytic_distribution=None, tax_amount_currency=None, tax_amount=None,
-    ):
-        return {
-            'record': tax_line,
-            'partner': partner or self.env['res.partner'],
-            'currency': currency or self.env['res.currency'],
-            'taxes': taxes or self.env['account.tax'],
-            'tax_tags': tax_tags or self.env['account.account.tag'],
-            'tax_repartition_line': tax_repartition_line or self.env['account.tax.repartition.line'],
-            'group_tax': group_tax or self.env['account.tax'],
-            'account': account or self.env['account.account'],
-            'analytic_distribution': analytic_distribution,
-            'tax_amount_currency': tax_amount_currency or 0.0,
-            'tax_amount': tax_amount or 0.0,
-        }
-
-    @api.model
-    def _get_generation_dict_from_base_line(self, line_vals, tax_vals, force_caba_exigibility=False):
-        """ Take a tax results returned by the taxes computation method and return a dictionary representing the way
-        the tax amounts will be grouped together. To do so, the dictionary will be converted into a string key.
-        Then, the existing tax lines sharing the same key will be updated and the missing ones will be created.
-
-        :param line_vals:   A python dict returned by '_convert_to_tax_base_line_dict'.
-        :param tax_vals:    A python dict returned by 'compute_all' under the 'taxes' key.
-        :return:            A python dict.
-        """
-        tax_repartition_line = tax_vals['tax_repartition_line']
-        tax = tax_repartition_line.tax_id
-        tax_account = tax_repartition_line._get_aml_target_tax_account(force_caba_exigibility=force_caba_exigibility) or line_vals['account']
-        return {
-            'account_id': tax_account.id,
-            'currency_id': line_vals['currency'].id,
-            'partner_id': line_vals['partner'].id,
-            'tax_repartition_line_id': tax_repartition_line.id,
-            'tax_ids': [Command.set(tax_vals['taxes'].ids)],
-            'tax_tag_ids': [Command.set(tax_vals['tags'].ids)],
-            'tax_id': tax_vals['group'].id if tax_vals.get('group') else tax.id,
-            'analytic_distribution': line_vals['analytic_distribution'] if tax.analytic else {},
-        }
-
-    @api.model
-    def _get_generation_dict_from_tax_line(self, line_vals):
-        """ Turn the values corresponding to a tax line and convert it into a dictionary. The dictionary will be
-        converted into a string key. This allows updating the existing tax lines instead of creating new ones
-        everytime.
-
-        :param line_vals:   A python dict returned by '_convert_to_tax_line_dict'.
-        :return:            A python dict representing the grouping key used to update an existing tax line.
-        """
-        tax = line_vals['tax_repartition_line'].tax_id
-        return {
-            'account_id': line_vals['account'].id,
-            'currency_id': line_vals['currency'].id,
-            'partner_id': line_vals['partner'].id,
-            'tax_repartition_line_id': line_vals['tax_repartition_line'].id,
-            'tax_ids': [Command.set(line_vals['taxes'].ids)],
-            'tax_tag_ids': [Command.set(line_vals['tax_tags'].ids)],
-            'tax_id': (line_vals['group_tax'] or tax).id,
-            'analytic_distribution': line_vals['analytic_distribution'] if tax.analytic else {},
-        }
-
-    @api.model
-    def _aggregate_taxes(self, to_process, company, filter_tax_values_to_apply=None, grouping_key_generator=None, distribute_total_on_line=True):
-
-        def default_grouping_key_generator(base_line, tax_values):
-            return {'tax': tax_values['tax_repartition_line'].tax_id}
-
-        def accounting_grouping_key_generator(base_line, tax_values):
-            return self._get_generation_dict_from_base_line(base_line, tax_values)
-
-        results = {
-            'base_amount_currency': 0.0,
-            'base_amount': 0.0,
-            'display_base_amount_currency': 0.0,
-            'display_base_amount': 0.0,
-            'tax_amount_currency': defaultdict(lambda: 0.0),
-            'tax_amount': defaultdict(lambda: 0.0),
-            'tax_details': defaultdict(lambda: {
-                'base_amount_currency': 0.0,
-                'base_amount': 0.0,
-                'display_base_amount_currency': 0.0,
-                'display_base_amount': 0.0,
-                'tax_amount_currency': defaultdict(lambda: 0.0),
-                'tax_amount': defaultdict(lambda: 0.0),
-                'group_tax_details': [],
-                'records': set(),
-            }),
-            'tax_details_per_record': defaultdict(lambda: {
-                'base_amount_currency': 0.0,
-                'base_amount': 0.0,
-                'display_base_amount_currency': 0.0,
-                'display_base_amount': 0.0,
-                'tax_amount_currency': defaultdict(lambda: 0.0),
-                'tax_amount': defaultdict(lambda: 0.0),
-                'tax_details': defaultdict(lambda: {
-                    'base_amount_currency': 0.0,
-                    'base_amount': 0.0,
-                    'display_base_amount_currency': 0.0,
-                    'display_base_amount': 0.0,
-                    'tax_amount_currency': defaultdict(lambda: 0.0),
-                    'tax_amount': defaultdict(lambda: 0.0),
-                    'group_tax_details': [],
-                    'records': set(),
-                }),
-            }),
-        }
-
-        if not grouping_key_generator:
-            grouping_key_generator = default_grouping_key_generator
-
-        comp_currency = company.currency_id
-        round_tax = company.tax_calculation_rounding_method != 'round_globally'
-        if company.tax_calculation_rounding_method == 'round_globally' and distribute_total_on_line:
-            # Aggregate all amounts according the tax lines grouping key.
-            amount_per_tax_repartition_line_id = defaultdict(lambda: {
-                'tax_amount': 0.0,
-                'tax_amount_currency': 0.0,
-                'taxes_data': [],
-            })
-            for base_line, tax_details_results in to_process:
-                currency = base_line['currency'] or comp_currency
-                for tax_data in tax_details_results['taxes_data']:
-                    grouping_key = frozendict(self._get_generation_dict_from_base_line(base_line, tax_data))
-                    total_amounts = amount_per_tax_repartition_line_id[grouping_key]
-                    total_amounts['tax_amount_currency'] += tax_data['tax_amount_currency']
-                    total_amounts['tax_amount'] += tax_data['tax_amount']
-                    total_amounts['taxes_data'].append(tax_data)
-            # Round them like what the creation of tax lines would do.
-            for key, values in amount_per_tax_repartition_line_id.items():
-                currency = self.env['res.currency'].browse(key['currency_id']) or comp_currency
-                values['tax_amount_rounded'] = comp_currency.round(values['tax_amount'])
-                values['tax_amount_currency_rounded'] = currency.round(values['tax_amount_currency'])
-            # Dispatch the amount accross the tax values.
-            for key, values in amount_per_tax_repartition_line_id.items():
-                foreign_currency = self.env['res.currency'].browse(key['currency_id']) or comp_currency
-                for currency, amount_field in ((comp_currency, 'tax_amount'), (foreign_currency, 'tax_amount_currency')):
-                    raw_value = values[amount_field]
-                    rounded_value = values[f'{amount_field}_rounded']
-                    diff = rounded_value - raw_value
-                    abs_diff = abs(diff)
-                    diff_sign = -1 if diff < 0 else 1
-                    taxes_data = values['taxes_data']
-                    nb_error = math.ceil(abs_diff / currency.rounding)
-                    nb_cents_per_tax_values = math.floor(nb_error / len(taxes_data))
-                    nb_extra_cent = nb_error % len(taxes_data)
-                    for tax_data in taxes_data:
-                        if not abs_diff:
-                            break
-                        nb_amount_curr_cent = nb_cents_per_tax_values
-                        if nb_extra_cent:
-                            nb_amount_curr_cent += 1
-                            nb_extra_cent -= 1
-                        # We can have more than one cent to distribute on a single tax_values.
-                        abs_delta_to_add = min(abs_diff, currency.rounding * nb_amount_curr_cent)
-                        tax_data[amount_field] += diff_sign * abs_delta_to_add
-                        abs_diff -= abs_delta_to_add
-
-        for base_line, tax_details_results in to_process:
-            record = base_line['record']
-            currency = base_line['currency'] or comp_currency
-
-            record_results = results['tax_details_per_record'][record]
-
-            base_added = False
-            base_grouping_key_added = set()
-            for tax_data in tax_details_results['taxes_data']:
-                if filter_tax_values_to_apply and not filter_tax_values_to_apply(base_line, tax_data):
-                    continue
-
-                grouping_key = frozendict(grouping_key_generator(base_line, tax_data))
-                accounting_grouping_key = frozendict(accounting_grouping_key_generator(base_line, tax_data))
-                base_amount_currency = tax_data['base_amount_currency']
-                base_amount = tax_data['base_amount']
-                display_base_amount_currency = tax_data['display_base_amount_currency']
-                display_base_amount = tax_data['display_base_amount']
-
-                if round_tax:
-                    tax_data['base_amount_currency'] = currency.round(tax_data['base_amount_currency'])
-                    tax_data['base_amount'] = comp_currency.round(tax_data['base_amount'])
-                    tax_data['display_base_amount_currency'] = currency.round(tax_data['display_base_amount_currency'])
-                    tax_data['display_base_amount'] = comp_currency.round(tax_data['display_base_amount'])
-
-                # 'global' base.
-                if not base_added:
-                    base_added = True
-                    for sub_results in (results, record_results):
-                        sub_results['base_amount_currency'] += base_amount_currency
-                        sub_results['base_amount'] += base_amount
-                        sub_results['display_base_amount_currency'] += display_base_amount_currency
-                        sub_results['display_base_amount'] += display_base_amount
-                        sub_results['currency'] = currency
-
-                # 'local' base.
-                global_local_results = results['tax_details'][grouping_key]
-                record_local_results = record_results['tax_details'][grouping_key]
-                if grouping_key not in base_grouping_key_added:
-                    base_grouping_key_added.add(grouping_key)
-                    for sub_results in (global_local_results, record_local_results):
-                        sub_results.update(grouping_key)
-                        sub_results['base_amount_currency'] += base_amount_currency
-                        sub_results['base_amount'] += base_amount
-                        sub_results['display_base_amount_currency'] += display_base_amount_currency
-                        sub_results['display_base_amount'] += display_base_amount
-                        sub_results['currency'] = currency
-                        sub_results['records'].add(record)
-                        sub_results['group_tax_details'].append(tax_data)
-
-                # 'global'/'local' tax amount.
-                for sub_results in (results, record_results, global_local_results, record_local_results):
-                    sub_results['tax_amount_currency'][accounting_grouping_key] += tax_data['tax_amount_currency']
-                    sub_results['tax_amount'][accounting_grouping_key] += tax_data['tax_amount']
-                    sub_results['currency'] = currency
-
-            # Rounding of tax amounts for the line.
-            for sub_results in [record_results] + list(record_results['tax_details'].values()):
-                for currency, key in ((sub_results.get('currency'), 'tax_amount_currency'), (comp_currency, 'tax_amount')):
-                    if currency and round_tax:
-                        for grouping_key, amount in sub_results[key].items():
-                            sub_results[key][grouping_key] = currency.round(amount)
-
-            for sub_results in [record_results] + list(record_results['tax_details'].values()):
-                for key in ('tax_amount_currency', 'tax_amount'):
-                    sub_results[key] = sum(sub_results[key].values())
-
-        # Rounding of tax amounts.
-        for sub_results in [results] + list(results['tax_details'].values()):
-            for currency, key in ((sub_results.get('currency'), 'tax_amount_currency'), (comp_currency, 'tax_amount')):
-                if currency and round_tax:
-                    for grouping_key, amount in sub_results[key].items():
-                        sub_results[key][grouping_key] = currency.round(amount)
-
-        for sub_results in [results] + list(results['tax_details'].values()):
-            for key in ('tax_amount_currency', 'tax_amount'):
-                sub_results[key] = sum(sub_results[key].values())
-
-        return results
-
-    @api.model
-    def _compute_taxes(self, base_lines, company, tax_lines=None, include_caba_tags=False):
-        """ Generic method to compute the taxes for different business models.
-
-        :param base_lines: A list of python dictionaries created using the '_convert_to_tax_base_line_dict' method.
-        :param company: The company to consider.
-        :param tax_lines: A list of python dictionaries created using the '_convert_to_tax_line_dict' method.
-        :param include_caba_tags: Manage tags for taxes being exigible on_payment.
-        :return: A python dictionary containing:
-
-            The complete diff on tax lines if 'tax_lines' is passed as parameter:
-            * tax_lines_to_add:     To create new tax lines.
-            * tax_lines_to_delete:  To track the tax lines that are no longer used.
-            * tax_lines_to_update:  The values to update the existing tax lines.
-
-            * base_lines_to_update: The values to update the existing base lines:
-                * tax_tag_ids:          The tags related to taxes.
-                * price_subtotal:       The amount without tax.
-                * price_total:          The amount with taxes.
-
-            * totals:               A mapping for each involved currency to:
-                * amount_untaxed:       The base amount without tax.
-                * amount_tax:           The total tax amount.
-        """
-        res = {
-            'tax_lines_to_add': [],
-            'tax_lines_to_delete': [],
-            'tax_lines_to_update': [],
-            'base_lines_to_update': [],
-            'totals': defaultdict(lambda: {
-                'amount_untaxed': 0.0,
-                'amount_tax': 0.0,
-            }),
-        }
-
-        # =========================================================================================
-        # BASE LINES
-        # For each base line, populate 'base_lines_to_update'.
-        # Compute 'tax_base_amount'/'tax_amount' for each pair <base line, tax repartition line>
-        # using the grouping key generated by the '_get_generation_dict_from_base_line' method.
-        # =========================================================================================
-
-        # Prepare the tax details for each line.
-        to_process = []
-        for base_line in base_lines:
-            tax_details_results = self._prepare_base_line_tax_details(
-                base_line,
-                company,
-                include_caba_tags=include_caba_tags,
-            )
-            to_process.append((base_line, tax_details_results))
-
-        # Fill 'base_lines_to_update' and 'totals'.
-        for base_line, tax_details_results in to_process:
-            res['base_lines_to_update'].append((base_line, {
-                'tax_tag_ids': [Command.set(tax_details_results['base_tags'].ids)],
-                'price_subtotal': tax_details_results['total_excluded'],
-                'price_total': tax_details_results['total_included'],
-            }))
-
-            currency = base_line['currency'] or company.currency_id
-            res['totals'][currency]['amount_untaxed'] += tax_details_results['total_excluded']
-
-        # =========================================================================================
-        # TAX LINES
-        # Map each existing tax lines using the grouping key generated by the
-        # '_get_generation_dict_from_tax_line' method.
-        # Since everything is indexed using the grouping key, we are now able to decide if
-        # (1) we can reuse an existing tax line and update its amounts
-        # (2) some tax lines are no longer used and can be dropped
-        # (3) we need to create new tax lines
-        # =========================================================================================
-
-        # Track the existing tax lines using the grouping key.
-        existing_tax_line_map = {}
-        for line_vals in tax_lines or []:
-            grouping_key = frozendict(self._get_generation_dict_from_tax_line(line_vals))
-
-            # After a modification (e.g. changing the analytic account of the tax line), if two tax lines are sharing
-            # the same key, keep only one.
-            if grouping_key in existing_tax_line_map:
-                res['tax_lines_to_delete'].append(line_vals)
-            else:
-                existing_tax_line_map[grouping_key] = line_vals
-
-        def grouping_key_generator(base_line, tax_data):
-            return self._get_generation_dict_from_base_line(base_line, tax_data, force_caba_exigibility=include_caba_tags)
-
-        # Update/create the tax lines.
-        global_tax_details = self._aggregate_taxes(to_process, company, grouping_key_generator=grouping_key_generator)
-
-        for grouping_key, tax_data in global_tax_details['tax_details'].items():
-            if tax_data['currency_id']:
-                currency = self.env['res.currency'].browse(tax_data['currency_id'])
-                tax_amount = currency.round(tax_data['tax_amount_currency'])
-                res['totals'][currency]['amount_tax'] += tax_amount
-
-            if grouping_key in existing_tax_line_map:
-                # Update an existing tax line.
-                line_vals = existing_tax_line_map.pop(grouping_key)
-                res['tax_lines_to_update'].append((line_vals, tax_data))
-            else:
-                # Create a new tax line.
-                res['tax_lines_to_add'].append(tax_data)
-
-        for line_vals in existing_tax_line_map.values():
-            res['tax_lines_to_delete'].append(line_vals)
-
-        return res
-
-    @api.model
-    def _prepare_tax_totals(self, base_lines, currency, company, tax_lines=None):
-        """ Compute the tax totals details for the business documents.
-        :param base_lines:                      A list of python dictionaries created using the '_convert_to_tax_base_line_dict' method.
-        :param currency:                        The currency set on the business document.
-        :param company:                         The company to consider.
-        :param tax_lines:                       Optional list of python dictionaries created using the '_convert_to_tax_line_dict'
-                                                method. If specified, the taxes will be recomputed using them instead of
-                                                recomputing the taxes on the provided base lines.
-        :return: A dictionary in the following form:
-            {
-                'amount_total':                 The total amount to be displayed on the document, including every total
-                                                types.
-                'amount_untaxed':               The untaxed amount to be displayed on the document.
-                'formatted_amount_total':       Same as amount_total, but as a string formatted accordingly with
-                                                partner's locale.
-                'formatted_amount_untaxed':     Same as amount_untaxed, but as a string formatted accordingly with
-                                                partner's locale.
-                'groups_by_subtotals':          A dictionary formed liked {'subtotal': groups_data}
-                                                Where total_type is a subtotal name defined on a tax group, or the
-                                                default one: 'Untaxed Amount'.
-                                                And groups_data is a list of dict in the following form:
-                    {
-                        'tax_group_name':                           The name of the tax groups this total is made for.
-                        'tax_group_amount':                         The total tax amount in this tax group.
-                        'tax_group_base_amount':                    The base amount for this tax group.
-                        'formatted_tax_group_amount':               Same as tax_group_amount, but as a string formatted accordingly
-                                                                    with partner's locale.
-                        'formatted_tax_group_base_amount':          Same as tax_group_base_amount, but as a string formatted
-                                                                    accordingly with partner's locale.
-                        'tax_group_id':                             The id of the tax group corresponding to this dict.
-                        'tax_group_base_amount_company_currency':   OPTIONAL: the base amount of the tax group expressed in
-                                                                    the company currency when the parameter
-                                                                    is_company_currency_requested is True
-                        'tax_group_amount_company_currency':        OPTIONAL: the tax amount of the tax group expressed in
-                                                                    the company currency when the parameter
-                                                                    is_company_currency_requested is True
-                    }
-                'subtotals':                    A list of dictionaries in the following form, one for each subtotal in
-                                                'groups_by_subtotals' keys.
-                    {
-                        'name':                             The name of the subtotal
-                        'amount':                           The total amount for this subtotal, summing all the tax groups
-                                                            belonging to preceding subtotals and the base amount
-                        'formatted_amount':                 Same as amount, but as a string formatted accordingly with
-                                                            partner's locale.
-                        'amount_company_currency':          OPTIONAL: The total amount in company currency when the
-                                                            parameter is_company_currency_requested is True
-                    }
-                'subtotals_order':              A list of keys of `groups_by_subtotals` defining the order in which it needs
-                                                to be displayed
-            }
-        """
-        comp_curr = company.currency_id
-
-        # ==== Compute the taxes ====
-
-        # Round according the tax lines.
-        target_tax_details_by_tax = defaultdict(lambda: [0.0, 0.0])
-        for tax_line in tax_lines or []:
-            tax_id = tax_line['tax_repartition_line'].tax_id.id
-            target_tax_details_by_tax[tax_id][0] += tax_line['tax_amount']
-            target_tax_details_by_tax[tax_id][1] += tax_line['tax_amount_currency']
-
-        # Prepare the tax details for each line.
-        tax_details_by_tax = defaultdict(list)
-        to_process = []
-        for base_line in base_lines:
-            tax_details_results = self._prepare_base_line_tax_details(base_line, company)
-            to_process.append((base_line, tax_details_results))
-
-            # Add 'display_base'.
-            for tax_data in tax_details_results['taxes_data']:
-                tax = tax_data['tax']
-                tax_details_by_tax[tax.id].append(tax_data)
-                if tax.id in target_tax_details_by_tax:
-                    target_tax_details_by_tax[tax.id][0] -= tax_data['tax_amount']
-                    target_tax_details_by_tax[tax.id][1] -= tax_data['tax_amount_currency']
-
-        # Round according the tax lines.
-        for tax_id, _tax_amount in target_tax_details_by_tax.items():
-            if tax_id in tax_details_by_tax:
-                tax_details_by_tax[tax_id][-1]['tax_amount'] += target_tax_details_by_tax[tax_id][0]
-                tax_details_by_tax[tax_id][-1]['tax_amount_currency'] += target_tax_details_by_tax[tax_id][1]
-
-        # Compute the untaxed amounts.
-        amount_untaxed = 0.0
-        amount_untaxed_currency = 0.0
-        for base_line, tax_details_results in to_process:
-            amount_untaxed += comp_curr.round(tax_details_results['total_excluded'] / base_line['rate'])
-            amount_untaxed_currency += currency.round(tax_details_results['total_excluded'])
-
-        def grouping_key_generator(base_line, tax_data):
-            return {'tax_group': tax_data['tax'].tax_group_id}
-
-        global_tax_details = self._aggregate_taxes(to_process, company, grouping_key_generator=grouping_key_generator)
-        tax_group_details_list = sorted(
-            global_tax_details['tax_details'].values(),
-            key=lambda x: (x['tax_group'].sequence, x['tax_group'].id),
-        )
-
-        subtotal_order = {}
-        encountered_base_amounts = {amount_untaxed_currency}
-        groups_by_subtotal = defaultdict(list)
-        for tax_detail in tax_group_details_list:
-            tax_group = tax_detail['tax_group']
-            subtotal_title = tax_group.preceding_subtotal or _("Untaxed Amount")
-            sequence = tax_group.sequence
-
-            # Handle a manual edition of tax lines.
-            if tax_lines is not None:
-                matched_tax_lines = [
-                    x
-                    for x in tax_lines
-                    if x['tax_repartition_line'].tax_id.tax_group_id == tax_group
-                ]
-                if matched_tax_lines:
-                    tax_detail['tax_amount_currency'] = sum(x['tax_amount_currency'] for x in matched_tax_lines)
-                    tax_detail['tax_amount'] = sum(x['tax_amount'] for x in matched_tax_lines)
-
-            # Manage order of subtotals.
-            if subtotal_title not in subtotal_order:
-                subtotal_order[subtotal_title] = sequence
-
-            # Create the values for a single tax group.
-            groups_by_subtotal[subtotal_title].append({
-                'group_key': tax_group.id,
-                'tax_group_id': tax_group.id,
-                'tax_group_name': tax_group.name,
-                'tax_group_label': tax_group.pos_receipt_label,
-                'tax_group_amount': tax_detail['tax_amount_currency'],
-                'tax_group_amount_company_currency': tax_detail['tax_amount'],
-                'tax_group_base_amount': currency.round(tax_detail['display_base_amount_currency']),
-                'tax_group_base_amount_company_currency': company.currency_id.round(tax_detail['display_base_amount']),
-                'formatted_tax_group_amount': formatLang(self.env, tax_detail['tax_amount_currency'], currency_obj=currency),
-                'formatted_tax_group_base_amount': formatLang(self.env, tax_detail['display_base_amount_currency'], currency_obj=currency),
-                'display_formatted_tax_group_base_amount': not all(x['tax'].amount_type == 'fixed' for x in tax_detail['group_tax_details']),
-            })
-            encountered_base_amounts.add(currency.round(tax_detail['display_base_amount_currency']))
-
-        # Compute amounts.
-        subtotals = []
-        subtotals_order = sorted(subtotal_order.keys(), key=lambda k: subtotal_order[k])
-        amount_total_currency = amount_untaxed_currency
-        amount_total = amount_untaxed
-        for subtotal_title in subtotals_order:
-            subtotals.append({
-                'name': subtotal_title,
-                'amount': amount_total_currency,
-                'amount_company_currency': amount_total,
-                'formatted_amount': formatLang(self.env, amount_total_currency, currency_obj=currency),
-            })
-            amount_total_currency += sum(x['tax_group_amount'] for x in groups_by_subtotal[subtotal_title])
-            amount_total += sum(x['tax_group_amount_company_currency'] for x in groups_by_subtotal[subtotal_title])
-
-        results = {
-            'amount_untaxed': currency.round(amount_untaxed_currency),
-            'amount_total': currency.round(amount_total_currency),
-            'formatted_amount_total': formatLang(self.env, amount_total_currency, currency_obj=currency),
-            'formatted_amount_untaxed': formatLang(self.env, amount_untaxed_currency, currency_obj=currency),
-            'groups_by_subtotal': groups_by_subtotal,
-            'subtotals': subtotals,
-            'subtotals_order': subtotals_order,
-            'display_tax_base': len(encountered_base_amounts) != 1 or len(groups_by_subtotal) > 1,
-        }
-        if currency != comp_curr:
-            results['amount_total_company_currency'] = comp_curr.round(amount_total)
-        return results
-
     @api.model
     def _fix_tax_included_price(self, price, prod_taxes, line_taxes):
         """Subtract tax amount from price when corresponding "price included" taxes do not apply"""
@@ -2033,13 +2349,12 @@ class AccountTax(models.Model):
         This method tries to dispatch the amount of negative lines on positive ones with the same tax, resulting in
         a discount for these positive lines.
 
-        :param base_lines: A list of python dictionaries created using the '_convert_to_tax_base_line_dict' method.
+        :param base_lines: A list of python dictionaries created using the '_prepare_base_line_for_taxes_computation' method.
         :param sorting_criteria: Optional list of criteria to sort the candidate for a negative line
         :param additional_dispatching_method: Optional method to transfer additional information (like tax amounts).
                                               It takes as arguments:
                                                   - neg_base_line: the negative line being dispatched
                                                   - candidate: the positive line that will get discounted by neg_base_line
-                                                  - discount_to_distribute: the amount being transferred
                                                   - is_zero: if the neg_base_line is nulled by the candidate
 
         :return: A dictionary in the following form:
@@ -2049,15 +2364,53 @@ class AccountTax(models.Model):
                 'nulled_candidate_lines': list of previously positive lines that have been nulled (with the discount)
             }
         """
+        def dispatch_tax_amounts(neg_base_line, candidate, is_zero):
+            def get_tax_key(tax_data):
+                return frozendict({'tax': tax_data['tax'], 'is_reverse_charge': tax_data['is_reverse_charge']})
+
+            base_line_fields = (
+                'total_excluded_currency', 'raw_total_excluded_currency',
+                'total_excluded', 'raw_total_excluded',
+                'total_included_currency', 'raw_total_included_currency',
+                'total_included', 'raw_total_included',
+                'delta_base_amount_currency', 'delta_base_amount',
+            )
+            tax_data_fields = (
+                'base_amount_currency', 'base_amount', 'tax_amount_currency', 'tax_amount',
+                'raw_base_amount_currency', 'raw_base_amount', 'raw_tax_amount_currency', 'raw_tax_amount',
+            )
+
+            if is_zero:
+                for field in base_line_fields:
+                    candidate['tax_details'][field] += neg_base_line['tax_details'][field]
+                    neg_base_line['tax_details'][field] = 0.0
+            else:
+                for field in base_line_fields:
+                    neg_base_line['tax_details'][field] += candidate['tax_details'][field]
+                    candidate['tax_details'][field] = 0.0
+
+            for tax_data in neg_base_line['tax_details']['taxes_data']:
+                tax_key = get_tax_key(tax_data)
+                other_tax_data = next(x for x in candidate['tax_details']['taxes_data'] if get_tax_key(x) == tax_key)
+
+                if is_zero:
+                    for field in tax_data_fields:
+                        other_tax_data[field] += tax_data[field]
+                        tax_data[field] = 0.0
+                else:
+                    for field in tax_data_fields:
+                        tax_data[field] += other_tax_data[field]
+                        other_tax_data[field] = 0.0
+
         results = {
             'result_lines': [],
             'orphan_negative_lines': [],
             'nulled_candidate_lines': [],
         }
         for line in base_lines:
-            line['discount_amount'] = line['discount_amount_before_dispatching']
+            line.setdefault('discount_amount', line['discount_amount_before_dispatching'])
 
-            if line['currency'].compare_amounts(line['gross_price_subtotal'], 0) < 0.0:
+            if line['currency_id'].compare_amounts(line['gross_price_subtotal'], 0) < 0.0:
                 results['orphan_negative_lines'].append(line)
             else:
                 results['result_lines'].append(line)
@@ -2067,9 +2420,9 @@ class AccountTax(models.Model):
                 candidate
                 for candidate in results['result_lines']
                 if (
-                    neg_base_line['currency'] == candidate['currency']
-                    and neg_base_line['partner'] == candidate['partner']
-                    and neg_base_line['taxes'] == candidate['taxes']
+                    neg_base_line['currency_id'] == candidate['currency_id']
+                    and neg_base_line['partner_id'] == candidate['partner_id']
+                    and neg_base_line['tax_ids'] == candidate['tax_ids']
                 )
             ]
 
@@ -2081,19 +2434,22 @@ class AccountTax(models.Model):
                 net_price_subtotal = neg_base_line['gross_price_subtotal'] - neg_base_line['discount_amount']
                 other_net_price_subtotal = candidate['gross_price_subtotal'] - candidate['discount_amount']
                 discount_to_distribute = min(other_net_price_subtotal, -net_price_subtotal)
+                if candidate['currency_id'].is_zero(discount_to_distribute):
+                    continue
 
                 candidate['discount_amount'] += discount_to_distribute
                 neg_base_line['discount_amount'] -= discount_to_distribute
 
                 remaining_to_distribute = neg_base_line['gross_price_subtotal'] - neg_base_line['discount_amount']
-                is_zero = neg_base_line['currency'].is_zero(remaining_to_distribute)
+                is_zero = neg_base_line['currency_id'].is_zero(remaining_to_distribute)
 
+                dispatch_tax_amounts(neg_base_line, candidate, is_zero)
                 if additional_dispatching_method:
-                    additional_dispatching_method(neg_base_line=neg_base_line, candidate=candidate, discount_to_distribute=discount_to_distribute, is_zero=is_zero)
+                    additional_dispatching_method(neg_base_line, candidate, discount_to_distribute, is_zero)
 
                 # Check if there is something left on the other line.
                 remaining_amount = candidate['discount_amount'] - candidate['gross_price_subtotal']
-                if candidate['currency'].is_zero(remaining_amount):
+                if candidate['currency_id'].is_zero(remaining_amount):
                     results['result_lines'].remove(candidate)
                     results['nulled_candidate_lines'].append(candidate)
 
@@ -2111,13 +2467,13 @@ class AccountTax(models.Model):
         # - biggest amount
         def same_product(candidate, negative_line):
             return (
-                not candidate['product']
-                or not negative_line['product']
-                or candidate['product'] != negative_line['product']
+                not candidate['product_id']
+                or not negative_line['product_id']
+                or candidate['product_id'] != negative_line['product_id']
             )
 
         def same_price_subtotal(candidate, negative_line):
-            return candidate['currency'].compare_amounts(candidate['price_subtotal'], -negative_line['price_subtotal']) != 0
+            return candidate['currency_id'].compare_amounts(candidate['price_subtotal'], -negative_line['price_subtotal']) != 0
 
         def biggest_amount(candidate, negative_line):
             return -candidate['price_subtotal']
