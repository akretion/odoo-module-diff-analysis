PR: https://github.com/odoo/odoo/pull/109216

From: 53f9e5845f34beaed523a4c6e0e2e7dd1cfd9025
From: Adrien Guilliams (adgu)
Date: 2023-03-10 17:54:52

Structural Changes: 4
Total Changes: 304

[IMP] point_of_sale, pos_restaurant: Add cross-orders feature for point_of_sale and pos_restaurant

Currently the below use-cases are hardly supportable, though quite common:

Retail: Sell product in one shop and return it in another one
Restaurant: Managing payment when having multiple checkout desks,
 and multiple waiters (only taking orders)

This because currently:

PoS orders are only known by the cashier desk (pos.config) they were created from
One floor map can only be linked to one cashier desk at a time

More over, with the Self-Service coming along the way
(where kiosk orders must be accessible from a cashier desk),
this need must be supported.

For restaurant, floor plans can be linked to multipleÂ cashier desks,
ongoing orders are shared between trusted PoS config
(through floor plans for restaurant and according to
the setting "Trusted PoS config" for the retails),
and past orders can be accessible from any desks within a same DB.

closes odoo/odoo#109216

Related: odoo/upgrade#4393
Related: odoo/enterprise#37955
Signed-off-by: Trinh Jacky (trj) <trj@odoo.com>

================================= pseudo patch: =================================

--- a/addons/point_of_sale/models/pos_config.py
+++ b/addons/point_of_sale/models/pos_config.py
@@ -5,7 +5,7 @@ from datetime import datetime
 from uuid import uuid4
 import pytz
 
-from odoo import api, fields, models, tools, _
+from odoo import api, fields, models, _
 from odoo.exceptions import ValidationError, UserError
 
 
@@ -175,6 +175,9 @@ class PosConfig(models.Model):
     limited_partners_amount = fields.Integer(default=100)
     partner_load_background = fields.Boolean(default=True)
     auto_validate_terminal_payment = fields.Boolean(default=True, help="Automatically validates orders paid with a payment terminal.")
+    trusted_config_ids = fields.Many2many("pos.config", relation="pos_config_trust_relation", column1="is_trusting",
+                                          column2="is_trusted", string="Trusted Point of Sale Configurations",
+                                          domain="[('id', '!=', pos_config_id), ('module_pos_restaurant', '=', False)]")
 
     @api.depends('payment_method_ids')
     def _compute_cash_control(self):
@@ -364,6 +367,13 @@ class PosConfig(models.Model):
             if len(cash_method.journal_id.pos_payment_method_ids) > 1:
                 raise ValidationError(_("You cannot use the same journal on multiples cash payment methods."))
 
+    @api.constrains('trusted_config_ids')
+    def _check_trusted_config_ids_currency(self):
+        for config in self:
+            for trusted_config in config.trusted_config_ids:
+                if trusted_config.currency_id != config.currency_id:
+                    raise ValidationError(_("You cannot share open orders with configuration that does not use the same currency."))
+
     def name_get(self):
         result = []
         for config in self:
@@ -411,6 +421,12 @@ class PosConfig(models.Model):
             forbidden_fields = []
             for key in self._get_forbidden_change_fields():
                 if key in vals.keys():
+                    if key == 'use_pricelist' and vals[key]:
+                        continue
+                    if key == 'available_pricelist_ids':
+                        removed_pricelist = set(self.available_pricelist_ids.ids) - set(vals[key][0][2])
+                        if len(removed_pricelist) == 0:
+                            continue
                     field_name = self._fields[key].get_description(self.env)["string"]
                     forbidden_fields.append(field_name)
             if len(forbidden_fields) > 0:
@@ -703,3 +719,9 @@ class PosConfig(models.Model):
             'res_id': self.id,
             'context': {'pos_config_open_modal': True},
         }
+
+    def _add_trusted_config_id(self, config_id):
+        self.trusted_config_ids += config_id
+
+    def _remove_trusted_config_id(self, config_id):
+        self.trusted_config_ids -= config_id

--- a/addons/point_of_sale/models/pos_order.py
+++ b/addons/point_of_sale/models/pos_order.py
@@ -1,7 +1,7 @@
 # -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 import logging
-from datetime import timedelta
+from datetime import datetime
 from markupsafe import Markup
 from functools import partial
 from itertools import groupby
@@ -1004,14 +1004,213 @@ class PosOrder(models.Model):
         mail = self.env['mail.mail'].sudo().create(self._prepare_mail_values(name, client, ticket))
         mail.send()
 
+    def _get_order_lines(self, orders):
+        """Add pos_order_lines to the orders.
+
+        The function doesn't return anything but adds the results directly to the orders.
+
+        :param orders: orders for which the order_lines are to be requested.
+        :type orders: pos.order.
+        """
+        order_lines = self.env['pos.order.line'].search_read(
+                domain=[('order_id', 'in', [to['id'] for to in orders])],
+                fields=self._get_fields_for_order_line())
+
+        if order_lines != []:
+            self._get_pack_lot_lines(order_lines)
+
+        extended_order_lines = []
+        for order_line in order_lines:
+            extended_order_lines.append([0, 0, self._prepare_order_line(order_line)])
+
+        for order_id, order_lines in groupby(extended_order_lines, key=lambda x: x[2]['order_id']):
+            next(order for order in orders if order['id'] == order_id[0])['lines'] = list(order_lines)
+
+    def _get_pack_lot_lines(self, order_lines):
+        """Add pack_lot_lines to the order_lines.
+
+        The function doesn't return anything but adds the results directly to the order_lines.
+
+        :param order_lines: order_lines for which the pack_lot_lines are to be requested.
+        :type order_lines: pos.order.line.
+        """
+        pack_lots = self.env['pos.pack.operation.lot'].search_read(
+                domain=[('pos_order_line_id', 'in', [order_line['id'] for order_line in order_lines])],
+                fields=[
+                    'id',
+                    'lot_name',
+                    'pos_order_line_id'
+                    ])
+        for pack_lot in pack_lots:
+            pack_lot['order_line'] = pack_lot['pos_order_line_id'][0]
+            pack_lot['server_id'] = pack_lot['id']
+
+            del pack_lot['pos_order_line_id']
+            del pack_lot['id']
+
+        for order_line_id, pack_lot_ids in groupby(pack_lots, key=lambda x: x['order_line']):
+            next(order_line for order_line in order_lines if order_line['id'] == order_line_id)['pack_lot_ids'] = list(pack_lot_ids)
+
+    def _prepare_order_line(self, order_line):
+        """Method that will allow the cleaning of values to send the correct information.
+        :param order_line: order_line that will be cleaned.
+        :type order_line: pos.order.line.
+        :returns: dict -- dict representing the order line's values.
+        """
+        order_line["product_id"] = order_line["product_id"][0]
+        order_line["server_id"] = order_line["id"]
+
+        del order_line["id"]
+        if not "pack_lot_ids" in order_line:
+            order_line["pack_lot_ids"] = []
+        else:
+            order_line["pack_lot_ids"] = [[0, 0, lot] for lot in order_line["pack_lot_ids"]]
+        return order_line
+
+    def _get_fields_for_payment_lines(self):
+        return [
+            'id',
+            'amount',
+            'pos_order_id',
+            'payment_method_id',
+            'card_type',
+            'cardholder_name',
+            'transaction_id',
+            'payment_status'
+            ]
+
+    def _get_payments_lines_list(self, orders):
+        payment_lines = self.env['pos.payment'].search_read(
+                domain=[('pos_order_id', 'in', [po['id'] for po in orders])],
+                fields=self._get_fields_for_payment_lines())
+
+        extended_payment_lines = []
+        for payment_line in payment_lines:
+            payment_line['server_id'] = payment_line['id']
+            payment_line['payment_method_id'] = payment_line['payment_method_id'][0]
+
+            del payment_line['id']
+            extended_payment_lines.append([0, 0, payment_line])
+        return extended_payment_lines
+
+    def _get_payment_lines(self, orders):
+        """Add account_bank_statement_lines to the orders.
+
+        The function doesn't return anything but adds the results directly to the orders.
+
+        :param orders: orders for which the payment_lines are to be requested.
+        :type orders: pos.order.
+        """
+        extended_payment_lines = self._get_payments_lines_list(orders)
+        for order_id, payment_lines in groupby(extended_payment_lines, key=lambda x: x[2]['pos_order_id']):
+            next(order for order in orders if order['id'] == order_id[0])['statement_ids'] = list(payment_lines)
+
+    def _get_fields_for_draft_order(self):
+        return [
+            'id',
+            'pricelist_id',
+            'partner_id',
+            'sequence_number',
+            'session_id',
+            'pos_reference',
+            'create_uid',
+            'create_date',
+            'fiscal_position_id',
+            'to_invoice',
+            'access_token',
+            'ticket_code',
+        ]
+
+    @api.model
+    def get_draft_share_order_ids(self, config_id):
+        """Search for 'draft' orders that satisfy the given domain."""
+        config = self.env['pos.config'].browse(config_id)
+        default_domain = ['&', ('state', '=', 'draft'), '|', ('config_id', '=', config_id), ('config_id', 'in', config.trusted_config_ids.ids)]
+        orders = self.search_read(
+                domain=default_domain,
+                fields=self._get_fields_for_draft_order())
+
+        self._get_order_lines(orders)
+        self._get_payment_lines(orders)
+
+        self._prepare_order(orders)
+
+        return orders
+
+    def is_already_paid(self):
+        return self.state == "paid"
+
+    @api.model
+    def _prepare_order(self, orders):
+        timezone = pytz.timezone(self._context.get('tz') or self.env.user.tz or 'UTC')
+        for order in orders:
+            order['pos_session_id'] = order['session_id'][0]
+            order['uid'] = re.search(r"\d{5,}-\d{3,}-\d{4,}", order['pos_reference']).group(0)
+            order['name'] = order['pos_reference']
+            order['creation_date'] = order['create_date'].astimezone(timezone)
+            order['server_id'] = order['id']
+            if order['fiscal_position_id']:
+                order['fiscal_position_id'] = order['fiscal_position_id'][0]
+            if order['pricelist_id']:
+                order['pricelist_id'] = order['pricelist_id'][0]
+            if order['partner_id']:
+                order['partner_id'] = order['partner_id'][0]
+
+            if not 'lines' in order:
+                order['lines'] = []
+            if not 'statement_ids' in order:
+                order['statement_ids'] = []
+
+            del order['id']
+            del order['session_id']
+            del order['pos_reference']
+            del order['create_date']
+
+    @api.model
+    def remove_from_ui(self, server_ids):
+        """ Remove orders from the frontend PoS application
+
+        Remove orders from the server by id.
+        :param server_ids: list of the id's of orders to remove from the server.
+        :type server_ids: list.
+        :returns: list -- list of db-ids for the removed orders.
+        """
+        orders = self.search([('id', 'in', server_ids), ('state', '=', 'draft')])
+        orders.write({'state': 'cancel'})
+        # TODO Looks like delete cascade is a better solution.
+        orders.mapped('payment_ids').sudo().unlink()
+        orders.sudo().unlink()
+        return orders.ids
+
     @api.model
     def search_paid_order_ids(self, config_id, domain, limit, offset):
         """Search for 'paid' orders that satisfy the given domain, limit and offset."""
-        default_domain = ['&', ('config_id', '=', config_id), '!', '|', ('state', '=', 'draft'), ('state', '=', 'cancelled')]
-        real_domain = AND([domain, default_domain])
-        ids = self.search(AND([domain, default_domain]), limit=limit, offset=offset).ids
+        default_domain = [('state', '!=', 'draft'), ('state', '!=', 'cancelled')]
+        if domain == []:
+            real_domain = AND([[['config_id', '=', config_id]], default_domain])
+        else:
+            real_domain = AND([domain, default_domain])
+        orders = self.search(real_domain, limit=limit, offset=offset)
+        # We clean here the orders that does not have the same currency.
+        # As we cannot use currency_id in the domain (because it is not a stored field),
+        # we must do it after the search.
+        pos_config = self.env['pos.config'].browse(config_id)
+        orders.filtered(lambda order: order.currency_id == pos_config.currency_id)
+        orderlines = self.env['pos.order.line'].search(['|', ('refunded_orderline_id.order_id', 'in', orders.ids), ('order_id', 'in', orders.ids)])
+
+        # We will return to the frontend the ids and the date of their last modification
+        # so that it can compare to the last time it fetched the orders and can ask to fetch
+        # orders that are not up-to-date.
+        # The date of their last modification is either the last time one of its orderline has changed,
+        # or the last time a refunded orderline related to it has changed.
+        orders_info = defaultdict(lambda: datetime.min)
+        for orderline in orderlines:
+            key_order = orderline.order_id.id if orderline.order_id in orders \
+                            else orderline.refunded_orderline_id.order_id.id
+            if orders_info[key_order] < orderline.write_date:
+                orders_info[key_order] = orderline.write_date
         totalCount = self.search_count(real_domain)
-        return {'ids': ids, 'totalCount': totalCount}
+        return {'ordersInfo': list(orders_info.items()), 'totalCount': totalCount}
 
     def _export_for_ui(self, order):
         timezone = pytz.timezone(self._context.get('tz') or self.env.user.tz or 'UTC')
@@ -1044,10 +1243,18 @@ class PosOrder(models.Model):
 
     def _get_fields_for_order_line(self):
         """This function is here to be overriden"""
-        return []
-
-    def _prepare_order_line(self, order_line):
-        return order_line
+        fields = [
+            'id',
+            'discount',
+            'product_id',
+            'price_unit',
+            'order_id',
+            'qty',
+            'full_product_name',
+            'customer_note',
+            'price_extra',
+        ]
+        return fields
 
     def export_for_ui(self):
         """ Returns a list of dict with each item having similar signature as the return of

--- a/addons/point_of_sale/models/pos_session.py
+++ b/addons/point_of_sale/models/pos_session.py
@@ -1862,12 +1862,7 @@ class PosSession(models.Model):
         for pricelist in pricelists:
             pricelist['items'] = []
 
-        pricelist_by_id = {pricelist['id']: pricelist for pricelist in pricelists}
-        pricelist_item_domain = [('pricelist_id', 'in', [p['id'] for p in pricelists])]
-        for item in self.env['product.pricelist.item'].search_read(pricelist_item_domain, self._product_pricelist_item_fields()):
-            pricelist_by_id[item['pricelist_id'][0]]['items'].append(item)
-
-        return pricelists
+        return self._prepare_product_pricelists(pricelists)
 
     def _loader_params_product_category(self):
         return {'search_params': {'domain': [], 'fields': ['name', 'parent_id']}}
@@ -2082,6 +2077,43 @@ class PosSession(models.Model):
         else:
             return list(total_sold_per_user_per_category[0].items()), list(total_refund_per_user_per_category[0].items())
 
+    def get_pos_ui_product_pricelists_by_ids(self, pricelist_ids):
+        params = self._loader_params_product_pricelist()
+        params['search_params']['domain'] = [('id', 'in', pricelist_ids)]
+        pricelists = self.env['product.pricelist'].search_read(**params['search_params'])
+        for pricelist in pricelists:
+            if not self.config_id.use_pricelist:
+                self.config_id.use_pricelist = True
+            pricelist_id = self.env['product.pricelist'].browse(pricelist['id'])
+            self.config_id.available_pricelist_ids += pricelist_id
+            pricelist['items'] = []
+
+        return self._prepare_product_pricelists(pricelists)
+
+    def _prepare_product_pricelists(self, pricelists):
+        pricelist_by_id = {pricelist['id']: pricelist for pricelist in pricelists}
+        pricelist_item_domain = [('pricelist_id', 'in', [p['id'] for p in pricelists])]
+        for item in self.env['product.pricelist.item'].search_read(pricelist_item_domain, self._product_pricelist_item_fields()):
+            pricelist_by_id[item['pricelist_id'][0]]['items'].append(item)
+
+        return pricelists
+
+    def get_pos_ui_account_fiscal_positions_by_ids(self, fp_ids):
+        params = self._loader_params_account_fiscal_position()
+        params['search_params']['domain'] = [('id', 'in', fp_ids)]
+        fps = self.env['account.fiscal.position'].search_read(**params['search_params'])
+        fiscal_position_tax_ids = sum([fpos['tax_ids'] for fpos in fps], [])
+        fiscal_position_tax = self.env['account.fiscal.position.tax'].search_read([('id', 'in', fiscal_position_tax_ids)])
+        fiscal_position_by_id = {fpt['id']: fpt for fpt in fiscal_position_tax}
+        for fiscal_position in fps:
+            if not self.config_id.tax_regime_selection:
+                self.config_id.tax_regime_selection = True
+            fiscal_position_id = self.env['account.fiscal.position'].browse(fiscal_position['id'])
+            self.config_id.fiscal_position_ids += fiscal_position_id
+            fiscal_position['fiscal_position_taxes_by_id'] = {tax_id: fiscal_position_by_id[tax_id] for tax_id in fiscal_position['tax_ids']}
+
+        return fps
+
 class ProcurementGroup(models.Model):
     _inherit = 'procurement.group'
 

--- a/addons/point_of_sale/models/res_config_settings.py
+++ b/addons/point_of_sale/models/res_config_settings.py
@@ -105,6 +105,7 @@ class ResConfigSettings(models.TransientModel):
     pos_warehouse_id = fields.Many2one(related='pos_config_id.warehouse_id', readonly=False, string="Warehouse (PoS)")
     point_of_sale_use_ticket_qr_code = fields.Boolean(related='company_id.point_of_sale_use_ticket_qr_code', readonly=False)
     pos_auto_validate_terminal_payment = fields.Boolean(related='pos_config_id.auto_validate_terminal_payment', readonly=False, string="Automatically validates orders paid with a payment terminal.")
+    pos_trusted_config_ids = fields.Many2many(related='pos_config_id.trusted_config_ids', readonly=False)
     point_of_sale_ticket_unique_code = fields.Boolean(related='company_id.point_of_sale_ticket_unique_code', readonly=False)
 
     @api.model_create_multi
@@ -313,3 +314,13 @@ class ResConfigSettings(models.TransientModel):
                 res_config.pos_iface_customer_facing_display_via_proxy = False
             else:
                 res_config.pos_iface_customer_facing_display_via_proxy = res_config.pos_config_id.iface_customer_facing_display_via_proxy
+
+    @api.onchange('pos_trusted_config_ids')
+    def _onchange_trusted_config_ids(self):
+        for config in self:
+            removed_trusted_configs = set(config.pos_config_id.trusted_config_ids.ids) - set(config.pos_trusted_config_ids.ids)
+            for old in config.pos_config_id.trusted_config_ids:
+                if config.pos_config_id.id not in old.trusted_config_ids.ids:
+                    old._add_trusted_config_id(config.pos_config_id)
+                if old.id in removed_trusted_configs:
+                    old._remove_trusted_config_id(config.pos_config_id)
