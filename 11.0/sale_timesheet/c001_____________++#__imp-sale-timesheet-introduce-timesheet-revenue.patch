PR: https://github.com/odoo/odoo/pull/

From: 227f8ab116186f93967840274086b78ac67697f8
From: JÃ©rome Maes
Date: 2017-05-04 14:15:42

Structural Changes: 6
Total Changes: 193

[IMP] sale_timesheet: introduce timesheet revenue

This commit introduces the concept of timesheet
revenue, aka how much the timesheet bring back
money.
If the timesheet is not invoiced yet, the computed
revenue is theorical, based on the billable type
(if your product is Time and Material, or Fixed Price).

The formulae use at the timesheet line creation is

     If product on delivered quantity:
        timesheet hours * (SO Line Price) * (1- discount),
     elif product on ordered quantities & create task:
         min (
            timesheet hours * (SO Line unit price) * (1- discount),
            TOTAL SO - TOTAL INVOICED - sum(timesheet
                revenues with invoice_id=False)
         )
     else: (non billable case)
        0

When the timesheet is invoiced, the revenue is recomputed
based on the prorata of the invoice amount : prorata of
number of hours for 'time and material' product,
prorata of the theorical revenue for 'fixed price' product.

The timesheet revenue is expressed in the currency of the
company (Monetary field, based on the company_currency_id field
of account.analytic.line) to ease reporting.
This feature normally can handle multi currency (different currency
from SO, INV, and analytic account).

================================= pseudo patch: =================================

--- a/addons/sale_timesheet/models/__init__.py
+++ b/addons/sale_timesheet/models/__init__.py
@@ -2,6 +2,7 @@
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
 from . import account
+from . import account_invoice
 from . import hr
 from . import procurement
 from . import product

--- a/addons/sale_timesheet/models/account.py
+++ b/addons/sale_timesheet/models/account.py
@@ -1,28 +1,43 @@
 # -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
-from odoo import api, models
+from odoo.exceptions import UserError
+from odoo import api, fields, models, _
 
 
 class AccountAnalyticLine(models.Model):
     _inherit = 'account.analytic.line'
 
+    timesheet_invoice_type = fields.Selection([
+        ('billable_time', 'Billable Time'),
+        ('billable_fixed', 'Billable Fixed'),
+        ('non_billable', 'Non Billable')], string="Billable Type", readonly=True, copy=False)
+    timesheet_invoice_id = fields.Many2one('account.invoice', string="Invoice", readonly=True, copy=False, help="Invoice created from the timesheet")
+    timesheet_revenue = fields.Monetary("Revenue", default=0.0, readonly=True, currency_field='company_currency_id', copy=False)
+
     @api.model
     def create(self, values):
         if values.get('task_id'):
             task = self.env['project.task'].browse(values['task_id'])
             values['so_line'] = task.sale_line_id.id or values.get('so_line', False)
-        values.update(self._get_timesheet_cost(values))
+        values.update(self._get_timesheet_values(values))
+        values.update(self._get_timesheet_billing_values(values))
         return super(AccountAnalyticLine, self).create(values)
 
     @api.multi
     def write(self, values):
+        # prevent to update invoiced timesheets
+        if self.filtered(lambda timesheet: timesheet.timesheet_invoice_id):
+            if any([field_name in values for field_name in ['unit_amount', 'employee_id', 'task_id', 'timesheet_revenue', 'so_line', 'amount', 'date']]):
+                raise UserError(_('You can not modify already invoiced timesheets.'))
+
         so_lines = self.mapped('so_line')
         if values.get('task_id'):
             task = self.env['project.task'].browse(values['task_id'])
             values['so_line'] = task.sale_line_id.id or values.get('so_line', False)
         for line in self:
-            values.update(line._get_timesheet_cost(values))
+            values.update(line._get_timesheet_values(values))
+            values.update(line._get_timesheet_billing_values(values))
             super(AccountAnalyticLine, line).write(values)
 
         # Update delivered quantity on SO lines which are not linked to the analytic lines anymore
@@ -31,7 +46,8 @@ class AccountAnalyticLine(models.Model):
             so_lines.with_context(force_so_lines=so_lines).sudo()._compute_analytic()
         return True
 
-    def _get_timesheet_cost(self, values):
+    def _get_timesheet_values(self, values):
+        result = {}
         values = values if values is not None else {}
         if values.get('project_id') or self.project_id:
             if values.get('amount'):
@@ -55,12 +71,64 @@ class AccountAnalyticLine(models.Model):
             amount = -unit_amount * cost
             amount_converted = employee.currency_id.compute(amount, analytic_account.currency_id)
 
-            return {
+            result.update({
                 'amount': amount_converted,
                 'product_uom_id': uom.id,
                 'account_id': account_id,
-            }
-        return {}
+            })
+        return result
+
+    def _get_timesheet_billing_values(self, values):
+        """
+            If invoice on delivered quantity:
+                timesheet hours * (SO Line Price) * (1- discount),
+            elif invoice on ordered quantities & create task:
+                min (
+                    timesheet hours * (SO Line unit price) * (1- discount),
+                    TOTAL SO - TOTAL INVOICED - sum(timesheet revenues with invoice_id=False)
+                )
+            else:
+                0
+        """
+        result = {}
+        if self.env.context.get('create'):  # avoid bad loop
+            return result
+
+        unit_amount = values.get('unit_amount', 0.0) or self.unit_amount
+        billable_type = 'non_billable'
+        revenue = 0.0
+
+        # set the revenue and billable type according to the product and the SO line
+        so_line_id = values.get('so_line') or self.so_line.id
+        so_line = self.env['sale.order.line'].browse(so_line_id) if so_line_id else self.env['sale.order.line'].browse()
+        if so_line.product_id.type == 'service':
+            # find the analytic account to convert revenue into its currency
+            account_id = values.get('account_id') or self.account_id.id
+            analytic_account = self.env['account.analytic.account'].browse(account_id)
+            # calculate the revenue on the timesheet
+            if so_line.product_id.invoice_policy == 'delivery':
+                delivered_revenue = unit_amount * so_line.price_unit * (1-so_line.discount)
+                revenue = so_line.currency_id.compute(delivered_revenue, analytic_account.currency_id)  # amount from SO should be convert into analytic account currency
+                billable_type = 'billable_time'
+            elif so_line.product_id.invoice_policy == 'order' and so_line.product_id.track_service == 'task':
+                # compute the total revenue the SO since we are in fixed price
+                total_revenue_so = so_line.product_uom_qty * so_line.price_unit * (1-so_line.discount)
+                total_revenue_so = so_line.currency_id.compute(total_revenue_so, analytic_account.currency_id)
+                # compute the total revenue already existing (without the current timesheet line)
+                domain = [('so_line', '=', so_line.id)]
+                if self.ids:
+                    domain += [('id', 'not in', self.ids)]
+                analytic_lines = self.sudo().search(domain)
+                total_revenue_invoiced = sum(analytic_lines.mapped('timesheet_revenue'))
+                # compute (new) revenue of current timesheet line
+                revenue = min(
+                    so_line.currency_id.compute(unit_amount * (so_line.price_unit) * (1-so_line.discount), analytic_account.currency_id),
+                    total_revenue_so - total_revenue_invoiced
+                )
+                billable_type = 'billable_fixed'
+        result['timesheet_revenue'] = revenue
+        result['timesheet_invoice_type'] = billable_type
+        return result
 
     def _get_sale_order_line(self, vals=None):
         result = dict(vals or {})
@@ -81,6 +149,6 @@ class AccountAnalyticLine(models.Model):
                     'so_line': sol.id,
                     'product_id': sol.product_id.id,
                 })
-                result.update(self._get_timesheet_cost(result))
+                result.update(self._get_timesheet_values(result))
 
         return super(AccountAnalyticLine, self)._get_sale_order_line(vals=result)

--- a/None
+++ b/addons/sale_timesheet/models/account_invoice.py
@@ -0,0 +1,108 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from odoo import api, fields, models, _
+from odoo.tools.float_utils import float_round
+
+
+class AccountInvoice(models.Model):
+    _inherit = "account.invoice"
+
+    timesheet_ids = fields.One2many('account.analytic.line', 'timesheet_invoice_id', string='Timesheets', readonly=True, copy=False)
+    timesheet_count = fields.Integer("Number of timesheets", compute='_compute_timesheet_count')
+
+    @api.multi
+    @api.depends('timesheet_ids')
+    def _compute_timesheet_count(self):
+        timesheet_data = self.env['account.analytic.line'].read_group([('timesheet_invoice_id', 'in', self.ids)], ['timesheet_invoice_id'], ['timesheet_invoice_id'])
+        mapped_data = dict([(t['timesheet_invoice_id'][0], t['timesheet_invoice_id_count']) for t in timesheet_data])
+        for invoice in self:
+            invoice.timesheet_count = mapped_data.get(invoice.id, 0)
+
+    def action_view_timesheet(self):
+        self.ensure_one()
+        return {
+            'type': 'ir.actions.act_window',
+            'name': _('Timesheets'),
+            'domain': [('project_id', '!=', False)],
+            'res_model': 'account.analytic.line',
+            'view_id': False,
+            'view_mode': 'tree,form',
+            'view_type': 'form',
+            'help': _("""
+                <p class="oe_view_nocontent_create">
+                    Click to record timesheets.
+                </p><p>
+                    You can register and track your workings hours by project every
+                    day. Every time spent on a project will become a cost and can be re-invoiced to
+                    customers if required.
+                </p>
+            """),
+            'limit': 80,
+            'context': {
+                'default_project_id': self.id,
+                'search_default_project_id': [self.id]
+            }
+        }
+
+    @api.multi
+    def invoice_validate(self):
+        result = super(AccountInvoice, self).invoice_validate()
+
+        for invoice in self:
+            for invoice_line in invoice.invoice_line_ids.filtered(lambda line: line.product_id.type == 'service'):
+                uninvoiced_timesheet_lines = self.env['account.analytic.line'].sudo().search([
+                    ('so_line', 'in', invoice_line.sale_line_ids.ids),
+                    ('project_id', '!=', False),
+                    ('timesheet_invoice_id', '=', False),
+                    ('timesheet_invoice_type', 'in', ['billable_time', 'billable_fixed'])
+                ]).with_context(create=True)  # context key required to avoid loop
+
+                # NOTE JEM : changing quantity (or unit price) of invoice line does not impact the revenue calculation. (FP specs)
+                if uninvoiced_timesheet_lines:
+                    precision = invoice_line.currency_id.decimal_places
+                    # delivered : update revenue with the prorata of number of hours on the timesheet line
+                    if invoice_line.product_id.invoice_policy == 'delivery':
+                        invoiced_price_per_hour = float_round(invoice_line.price_subtotal / float(sum(uninvoiced_timesheet_lines.mapped('unit_amount'))), precision)
+                        # invoicing analytic lines of different currency
+                        total_revenue_per_currency = dict.fromkeys(uninvoiced_timesheet_lines.mapped('company_currency_id').ids, 0.0)
+                        for index, timesheet_line in enumerate(uninvoiced_timesheet_lines):
+                            if index+1 != len(uninvoiced_timesheet_lines):
+                                line_revenue = invoiced_price_per_hour * timesheet_line.unit_amount
+                                total_revenue_per_currency[timesheet_line.company_currency_id.id] += line_revenue
+                            else:  # last line: add the difference to avoid rounding problem
+                                total_revenue = sum([self.env['res.currency'].browse(currency_id).compute(amount, timesheet_line.company_currency_id) for currency_id, amount in total_revenue_per_currency.items()])
+                                line_revenue = invoice_line.price_subtotal - total_revenue
+                            timesheet_line.write({
+                                'timesheet_invoice_id': invoice.id,
+                                'timesheet_revenue': float_round(line_revenue, precision),
+                            })
+
+                    # ordered : update revenue with the prorata of theorical revenue
+                    elif invoice_line.product_id.invoice_policy == 'order':
+                        zero_timesheet_revenue = uninvoiced_timesheet_lines.filtered(lambda line: line.timesheet_revenue == 0.0)
+                        no_zero_timesheet_revenue = uninvoiced_timesheet_lines.filtered(lambda line: line.timesheet_revenue != 0.0)
+
+                        # timesheet with zero theorical revenue keep the same revenue, but become invoiced (invoice_id set)
+                        zero_timesheet_revenue.write({'timesheet_invoice_id': invoice.id})
+
+                        # invoicing analytic lines of different currency
+                        total_revenue_per_currency = dict.fromkeys(no_zero_timesheet_revenue.mapped('company_currency_id').ids, 0.0)
+
+                        for index, timesheet_line in enumerate(no_zero_timesheet_revenue):
+                            if index+1 != len(no_zero_timesheet_revenue):
+                                price_subtotal_inv = invoice_line.currency_id.compute(invoice_line.price_subtotal, timesheet_line.company_currency_id)
+                                price_subtotal_sol = timesheet_line.so_line.currency_id.compute(timesheet_line.so_line.price_subtotal, timesheet_line.company_currency_id)
+                                line_revenue = timesheet_line.timesheet_revenue * price_subtotal_inv / price_subtotal_sol
+                                total_revenue_per_currency[timesheet_line.company_currency_id.id] += line_revenue
+                            else:  # last line: add the difference to avoid rounding problem
+                                last_price_subtotal_inv = invoice_line.currency_id.compute(invoice_line.price_subtotal, timesheet_line.company_currency_id)
+                                total_revenue = sum([self.env['res.currency'].browse(currency_id).compute(amount, timesheet_line.company_currency_id) for currency_id, amount in total_revenue_per_currency.items()])
+                                line_revenue = last_price_subtotal_inv - total_revenue
+
+                            timesheet_line.write({
+                                'timesheet_invoice_id': invoice.id,
+                                'timesheet_revenue': float_round(line_revenue, precision),
+                            })
+
+        return result
