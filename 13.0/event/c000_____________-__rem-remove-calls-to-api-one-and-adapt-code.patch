PR: https://github.com/odoo/odoo/pull/

From: 9e71d57d11faf3fabd00b8a09188e9d4f9808c63
From: Adrian Torres
Date: 2019-07-05 09:04:45

Structural Changes: 2
Total Changes: 161

[REM] *: remove calls to `api.one` and adapt code

Adapt all code that was using `api.one` to recordset-style method and
remove any and all calls to `api.one` in preparation for its removal.

================================= pseudo patch: =================================

--- a/addons/event/models/event.py
+++ b/addons/event/models/event.py
@@ -215,21 +215,23 @@ class EventEvent(models.Model):
     def _tz_get(self):
         return [(x, x) for x in pytz.all_timezones]
 
-    @api.one
     @api.depends('date_tz', 'date_begin')
     def _compute_date_begin_tz(self):
-        if self.date_begin:
-            self.date_begin_located = format_datetime(self.env, self.date_begin, tz=self.date_tz, dt_format='medium')
-        else:
-            self.date_begin_located = False
+        for event in self:
+            if event.date_begin:
+                event.date_begin_located = format_datetime(
+                    self.env, event.date_begin, tz=event.date_tz, dt_format='medium')
+            else:
+                event.date_begin_located = False
 
-    @api.one
     @api.depends('date_tz', 'date_end')
     def _compute_date_end_tz(self):
-        if self.date_end:
-            self.date_end_located = format_datetime(self.env, self.date_end, tz=self.date_tz, dt_format='medium')
-        else:
-            self.date_end_located = False
+        for event in self:
+            if event.date_end:
+                event.date_end_located = format_datetime(
+                    self.env, event.date_end, tz=event.date_tz, dt_format='medium')
+            else:
+                event.date_end_located = False
 
     @api.onchange('is_online')
     def _onchange_is_online(self):
@@ -273,11 +275,11 @@ class EventEvent(models.Model):
         if any(event.seats_availability == 'limited' and event.seats_max and event.seats_available < 0 for event in self):
             raise ValidationError(_('No more available seats.'))
 
-    @api.one
     @api.constrains('date_begin', 'date_end')
     def _check_closing_date(self):
-        if self.date_end < self.date_begin:
-            raise ValidationError(_('The closing date cannot be earlier than the beginning date.'))
+        for event in self:
+            if event.date_end < event.date_begin:
+                raise ValidationError(_('The closing date cannot be earlier than the beginning date.'))
 
     @api.multi
     @api.depends('name', 'date_begin', 'date_end')
@@ -314,9 +316,8 @@ class EventEvent(models.Model):
         default = dict(default or {}, name=_("%s (copy)") % (self.name))
         return super(EventEvent, self).copy(default)
 
-    @api.one
     def button_draft(self):
-        self.state = 'draft'
+        self.write({'state': 'draft'})
 
     @api.multi
     def button_cancel(self):
@@ -325,18 +326,16 @@ class EventEvent(models.Model):
         self.registration_ids.write({'state': 'cancel'})
         self.state = 'cancel'
 
-    @api.one
     def button_done(self):
-        self.state = 'done'
+        self.write({'state': 'done'})
 
-    @api.one
     def button_confirm(self):
-        self.state = 'confirm'
+        self.write({'state': 'confirm'})
 
-    @api.one
     def mail_attendees(self, template_id, force_send=False, filter_func=lambda self: self.state != 'cancel'):
-        for attendee in self.registration_ids.filtered(filter_func):
-            self.env['mail.template'].browse(template_id).send_mail(attendee.id, force_send=force_send)
+        for event in self:
+            for attendee in event.registration_ids.filtered(filter_func):
+                self.env['mail.template'].browse(template_id).send_mail(attendee.id, force_send=force_send)
 
     @api.multi
     def _is_event_registrable(self):
@@ -396,11 +395,11 @@ class EventRegistration(models.Model):
     phone = fields.Char(string='Phone')
     name = fields.Char(string='Attendee Name', index=True)
 
-    @api.one
     @api.constrains('event_id', 'state')
     def _check_seats_limit(self):
-        if self.event_id.seats_availability == 'limited' and self.event_id.seats_max and self.event_id.seats_available < (1 if self.state == 'draft' else 0):
-            raise ValidationError(_('No more seats available for this event.'))
+        for registration in self:
+            if registration.event_id.seats_availability == 'limited' and registration.event_id.seats_max and registration.event_id.seats_available < (1 if registration.state == 'draft' else 0):
+                raise ValidationError(_('No more seats available for this event.'))
 
     @api.multi
     def _check_auto_confirmation(self):
@@ -437,33 +436,30 @@ class EventRegistration(models.Model):
         data.update({key: value for key, value in registration.items() if key in self._fields})
         return data
 
-    @api.one
     def do_draft(self):
-        self.state = 'draft'
+        self.write({'state': 'draft'})
 
-    @api.one
     def confirm_registration(self):
-        self.state = 'open'
+        self.write({'state': 'open'})
 
         # auto-trigger after_sub (on subscribe) mail schedulers, if needed
         onsubscribe_schedulers = self.event_id.event_mail_ids.filtered(
             lambda s: s.interval_type == 'after_sub')
         onsubscribe_schedulers.execute()
 
-    @api.one
     def button_reg_close(self):
         """ Close Registration """
-        today = fields.Datetime.now()
-        if self.event_id.date_begin <= today and self.event_id.state == 'confirm':
-            self.write({'state': 'done', 'date_closed': today})
-        elif self.event_id.state == 'draft':
-            raise UserError(_("You must wait the event confirmation before doing this action."))
-        else:
-            raise UserError(_("You must wait the event starting day before doing this action."))
+        for registration in self:
+            today = fields.Datetime.now()
+            if registration.event_id.date_begin <= today and registration.event_id.state == 'confirm':
+                registration.write({'state': 'done', 'date_closed': today})
+            elif registration.event_id.state == 'draft':
+                raise UserError(_("You must wait the event confirmation before doing this action."))
+            else:
+                raise UserError(_("You must wait the event starting day before doing this action."))
 
-    @api.one
     def button_reg_cancel(self):
-        self.state = 'cancel'
+        self.write({'state': 'cancel'})
 
     @api.onchange('partner_id')
     def _onchange_partner(self):

--- a/addons/event/models/event_mail.py
+++ b/addons/event/models/event_mail.py
@@ -76,47 +76,46 @@ class EventMailScheduler(models.Model):
     mail_sent = fields.Boolean('Mail Sent on Event')
     done = fields.Boolean('Sent', compute='_compute_done', store=True)
 
-    @api.one
     @api.depends('mail_sent', 'interval_type', 'event_id.registration_ids', 'mail_registration_ids')
     def _compute_done(self):
-        if self.interval_type in ['before_event', 'after_event']:
-            self.done = self.mail_sent
-        else:
-            self.done = len(self.mail_registration_ids) == len(self.event_id.registration_ids) and all(mail.mail_sent for mail in self.mail_registration_ids)
+        for mail in self:
+            if mail.interval_type in ['before_event', 'after_event']:
+                mail.done = mail.mail_sent
+            else:
+                mail.done = len(mail.mail_registration_ids) == len(mail.event_id.registration_ids) and all(mail.mail_sent for mail in mail.mail_registration_ids)
 
-    @api.one
     @api.depends('event_id.state', 'event_id.date_begin', 'interval_type', 'interval_unit', 'interval_nbr')
     def _compute_scheduled_date(self):
-        if self.event_id.state not in ['confirm', 'done']:
-            self.scheduled_date = False
-        else:
-            if self.interval_type == 'after_sub':
-                date, sign = self.event_id.create_date, 1
-            elif self.interval_type == 'before_event':
-                date, sign = self.event_id.date_begin, -1
+        for mail in self:
+            if mail.event_id.state not in ['confirm', 'done']:
+                mail.scheduled_date = False
             else:
-                date, sign = self.event_id.date_end, 1
-
-            self.scheduled_date = date + _INTERVALS[self.interval_unit](sign * self.interval_nbr)
+                if mail.interval_type == 'after_sub':
+                    date, sign = mail.event_id.create_date, 1
+                elif mail.interval_type == 'before_event':
+                    date, sign = mail.event_id.date_begin, -1
+                else:
+                    date, sign = mail.event_id.date_end, 1
+                mail.scheduled_date = date + _INTERVALS[mail.interval_unit](sign * mail.interval_nbr)
 
-    @api.one
     def execute(self):
-        now = fields.Datetime.now()
-        if self.interval_type == 'after_sub':
-            # update registration lines
-            lines = [
-                (0, 0, {'registration_id': registration.id})
-                for registration in (self.event_id.registration_ids - self.mapped('mail_registration_ids.registration_id'))
-            ]
-            if lines:
-                self.write({'mail_registration_ids': lines})
-            # execute scheduler on registrations
-            self.mail_registration_ids.filtered(lambda reg: reg.scheduled_date and reg.scheduled_date <= now).execute()
-        else:
-            # Do not send emails if the mailing was scheduled before the event but the event is over
-            if not self.mail_sent and (self.interval_type != 'before_event' or self.event_id.date_end > now):
-                self.event_id.mail_attendees(self.template_id.id)
-                self.write({'mail_sent': True})
+        for mail in self:
+            now = fields.Datetime.now()
+            if mail.interval_type == 'after_sub':
+                # update registration lines
+                lines = [
+                    (0, 0, {'registration_id': registration.id})
+                    for registration in (mail.event_id.registration_ids - mail.mapped('mail_registration_ids.registration_id'))
+                ]
+                if lines:
+                    mail.write({'mail_registration_ids': lines})
+                # execute scheduler on registrations
+                mail.mail_registration_ids.filtered(lambda reg: reg.scheduled_date and reg.scheduled_date <= now).execute()
+            else:
+                # Do not send emails if the mailing was scheduled before the event but the event is over
+                if not mail.mail_sent and (mail.interval_type != 'before_event' or mail.event_id.date_end > now):
+                    mail.event_id.mail_attendees(mail.template_id.id)
+                    mail.write({'mail_sent': True})
         return True
 
     @api.model
@@ -179,18 +178,18 @@ class EventMailRegistration(models.Model):
     scheduled_date = fields.Datetime('Scheduled Time', compute='_compute_scheduled_date', store=True)
     mail_sent = fields.Boolean('Mail Sent')
 
-    @api.one
     def execute(self):
-        if self.registration_id.state in ['open', 'done'] and not self.mail_sent:
-            self.scheduler_id.template_id.send_mail(self.registration_id.id)
-            self.write({'mail_sent': True})
+        for mail in self:
+            if mail.registration_id.state in ['open', 'done'] and not mail.mail_sent:
+                mail.scheduler_id.template_id.send_mail(mail.registration_id.id)
+                mail.write({'mail_sent': True})
 
-    @api.one
     @api.depends('registration_id', 'scheduler_id.interval_unit', 'scheduler_id.interval_type')
     def _compute_scheduled_date(self):
-        if self.registration_id:
-            date_open = self.registration_id.date_open
-            date_open_datetime = date_open or fields.Datetime.now()
-            self.scheduled_date = date_open_datetime + _INTERVALS[self.scheduler_id.interval_unit](self.scheduler_id.interval_nbr)
-        else:
-            self.scheduled_date = False
+        for mail in self:
+            if mail.registration_id:
+                date_open = mail.registration_id.date_open
+                date_open_datetime = date_open or fields.Datetime.now()
+                mail.scheduled_date = date_open_datetime + _INTERVALS[mail.scheduler_id.interval_unit](mail.scheduler_id.interval_nbr)
+            else:
+                mail.scheduled_date = False
