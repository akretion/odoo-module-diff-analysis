PR: https://github.com/odoo/odoo/pull/147048

From: 83a3aa640d69e57bf7f60cd36111a6f3be5aeb25
From: william-andre
Date: 2024-01-02 15:29:45

Structural Changes: 5
Total Changes: 112

[IMP] account: detect unexpected amounts and dates

Purpose
-------

Avoid errors and scam.

Implementation
--------------

Follow a standard distribution, taking into account between the last 10
or 30invoices.
These numbers have been chosen arbitrarily to have enough data to start
computing the distribution, but not keep too much history if the
distribution changes.

For unusual amounts, we show a warning if it goes outside 2 times the
standard deviation, as it the most used value. It is only recomputed on
save to avoid doing too many queries when changing invoice lines.
For unusual dates, we only show a warning if we invoice something
earlier than expected, with 2 standard deviation + wiggle room for 2
days to correct for the various number of days per month.

When something unusual is detected:
* on a form: display a banner on top
* on list: display the line with a warning decoration (on the invoice
  date or on the total amount depending on the warning)
* when posting: ask for confirmation in a wizard. The wizard allows to
  disable future warnings per partner.

Since the wizard for confirmation of batch posting is used, we took the
opportunity to rework it:
* use "Confirm" everywhere since it is the label of the button on the
  form view
* remove the "Journal Entry" when possible
* Improve the text explanation for the "force post" feature as well as
  the display to make it look less scary

The query count in `test_mass_convert_performances` was updated to
compute the (ormcache'd) default value for the new company dependent
fields.

task-3631864

closes odoo/odoo#147048

Related: odoo/enterprise#53523
Signed-off-by: Brice Bartoletti (bib) <bib@odoo.com>

================================= pseudo patch: =================================

--- a/addons/account/models/account_move.py
+++ b/addons/account/models/account_move.py
@@ -588,6 +588,9 @@ class AccountMove(models.Model):
     show_payment_term_details = fields.Boolean(compute="_compute_show_payment_term_details")
     show_discount_details = fields.Boolean(compute="_compute_show_payment_term_details")
 
+    abnormal_amount_warning = fields.Text(compute='_compute_abnormal_warnings')
+    abnormal_date_warning = fields.Text(compute='_compute_abnormal_warnings')
+
     _sql_constraints = [(
         'unique_name', "", "Another entry with the same name already exists.",
     )]
@@ -1609,6 +1612,102 @@ class AccountMove(models.Model):
     def _compute_incoterm_location(self):
         pass
 
+    @api.depends('partner_id', 'invoice_date', 'amount_total')
+    def _compute_abnormal_warnings(self):
+        """Assign warning fields based on historical data.
+
+        The last invoices (between 10 and 30) are used to compute the normal distribution.
+        If the amount or days between invoices of the current invoice falls outside of the boundaries
+        of the Bell curve, we warn the user.
+        """
+        if self.env.context.get('disable_abnormal_invoice_detection'):
+            draft_invoices = self.browse()
+        else:
+            draft_invoices = self.filtered(lambda m:
+                m.is_invoice()
+                and m.state == 'draft'
+                and m.amount_total
+                and not (m.partner_id.ignore_abnormal_invoice_date and m.partner_id.ignore_abnormal_invoice_amount)
+            )
+        other_moves = self - draft_invoices
+        other_moves.abnormal_amount_warning = False
+        other_moves.abnormal_date_warning = False
+        if not draft_invoices:
+            return
+        draft_invoices.flush_recordset(['invoice_date', 'date', 'amount_total', 'partner_id', 'move_type', 'company_id'])
+        today = fields.Date.context_today(self)
+        self.env.cr.execute("""
+            WITH previous_invoices AS (
+                  SELECT this.id,
+                         other.invoice_date,
+                         other.amount_total,
+                         LAG(other.invoice_date) OVER invoice - other.invoice_date AS date_diff
+                    FROM account_move this
+                    JOIN account_move other USING (partner_id, move_type, company_id, currency_id)
+                   WHERE other.state = 'posted'
+                     AND other.invoice_date <= COALESCE(this.invoice_date, this.date, %(today)s)
+                     AND this.id = ANY(%(move_ids)s)
+                     AND this.id != other.id
+                  WINDOW invoice AS (PARTITION BY this.id ORDER BY other.invoice_date DESC)
+            ), stats AS (
+                  SELECT id,
+                         MAX(invoice_date)          OVER invoice AS last_invoice_date,
+                         AVG(date_diff)             OVER invoice AS date_diff_mean,
+                         STDDEV_SAMP(date_diff)     OVER invoice AS date_diff_deviation,
+                         AVG(amount_total)          OVER invoice AS amount_mean,
+                         STDDEV_SAMP(amount_total)  OVER invoice AS amount_deviation,
+                         ROW_NUMBER()               OVER invoice AS row_number
+                    FROM previous_invoices
+                  WINDOW invoice AS (PARTITION BY id ORDER BY invoice_date DESC)
+            )
+              SELECT id, last_invoice_date, date_diff_mean, date_diff_deviation, amount_mean, amount_deviation
+                FROM stats
+               WHERE row_number BETWEEN 10 AND 30
+            ORDER BY row_number ASC
+        """, {
+            'today': today,
+            'move_ids': draft_invoices.ids,
+        })
+        result = {invoice: vals for invoice, *vals in self.env.cr.fetchall()}
+        for move in draft_invoices:
+            invoice_date = move.invoice_date or today
+            (
+                last_invoice_date, date_diff_mean, date_diff_deviation,
+                amount_mean, amount_deviation,
+            ) = result.get(move._origin.id, (invoice_date, 0, 10000000000, 0, 10000000000))
+
+            if date_diff_mean > 25:
+                # Correct for varying days per month and leap years
+                # If we have a recurring invoice every month, the mean will be ~30.5 days, and the deviation ~1 day.
+                # We need to add some wiggle room for the month of February otherwise it will trigger because 28 days is outside of the range
+                date_diff_deviation += 1
+
+            wiggle_room_date = 2 * date_diff_deviation
+            move.abnormal_date_warning = (
+                not move.partner_id.ignore_abnormal_invoice_date
+                and (invoice_date - last_invoice_date).days < int(date_diff_mean - wiggle_room_date)
+            ) and _(
+                "The billing frequency for %(partner_name)s appears unusual. Based on your historical data, "
+                "the expected next invoice date is not before %(expected_date)s (every %(mean)s (± %(wiggle)s) days).\n"
+                "Please verify if this date is accurate.",
+                partner_name=move.partner_id.display_name,
+                expected_date=format_date(self.env, fields.Date.add(last_invoice_date, days=int(date_diff_mean - wiggle_room_date))),
+                mean=int(date_diff_mean),
+                wiggle=int(wiggle_room_date),
+            )
+
+            wiggle_room_amount = 2 * amount_deviation
+            move.abnormal_amount_warning = (
+                not move.partner_id.ignore_abnormal_invoice_amount
+                and not (amount_mean - wiggle_room_amount <= move.amount_total <= amount_mean + wiggle_room_amount)
+            ) and _(
+                "The amount for %(partner_name)s appears unusual. Based your historical data, the expected amount is %(mean)s (± %(wiggle)s).\n"
+                "Please verify if this amount is accurate.",
+                partner_name=move.partner_id.display_name,
+                mean=move.currency_id.format(amount_mean),
+                wiggle=move.currency_id.format(wiggle_room_amount),
+            )
+
     # -------------------------------------------------------------------------
     # INVERSE METHODS
     # -------------------------------------------------------------------------
@@ -3976,9 +4075,18 @@ class AccountMove(models.Model):
 
     def action_post(self):
         moves_with_payments = self.filtered('payment_id')
-        other_moves = self - moves_with_payments
         if moves_with_payments:
             moves_with_payments.payment_id.action_post()
+        other_moves = self - moves_with_payments
+        if other_moves.filtered(lambda m: m.abnormal_amount_warning or m.abnormal_date_warning):
+            return {
+                'name': _("Confirm Entries"),
+                'type': 'ir.actions.act_window',
+                'res_model': 'validate.account.move',
+                'view_mode': 'form',
+                'context': {'default_move_ids': other_moves.ids},
+                'target': 'new',
+            }
         if other_moves:
             other_moves._post(soft=False)
         return False

--- a/addons/account/models/partner.py
+++ b/addons/account/models/partner.py
@@ -563,6 +563,8 @@ class ResPartner(models.Model):
     contract_ids = fields.One2many('account.analytic.account', 'partner_id', string='Partner Contracts', readonly=True)
     bank_account_count = fields.Integer(compute='_compute_bank_count', string="Bank")
     trust = fields.Selection([('good', 'Good Debtor'), ('normal', 'Normal Debtor'), ('bad', 'Bad Debtor')], string='Degree of trust you have in this debtor', default='normal', company_dependent=True)
+    ignore_abnormal_invoice_date = fields.Boolean(company_dependent=True)
+    ignore_abnormal_invoice_amount = fields.Boolean(company_dependent=True)
     invoice_warn = fields.Selection(WARNING_MESSAGE, 'Invoice', help=WARNING_HELP, default="no-message")
     invoice_warn_msg = fields.Text('Message for Invoice')
     # Computed fields to order the partners as suppliers/customers according to the
