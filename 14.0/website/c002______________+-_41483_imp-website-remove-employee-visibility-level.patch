PR: https://github.com/odoo/odoo/pull/41483

From: 361b711ffc46e4cc51179d2b1defa2421226c3e5
From: Jeremy Kersten
Date: 2019-12-06 09:48:05

Structural Changes: 4
Total Changes: 46

[IMP] website: remove employee visibility level

You can use has_group(employee) instead

+ fix enumerate_page: when you search a page with visibility constraints,
you never seen it even if force was set to True.

task-2091365 again

closes odoo/odoo#41483

X-original-commit: f1c7a34f0b8276895c18ca6c450a142f9a815e3b
Signed-off-by: Jérémy Kersten (jke) <jke@openerp.com>

================================= pseudo patch: =================================

--- a/addons/website/models/ir_ui_view.py
+++ b/addons/website/models/ir_ui_view.py
@@ -4,9 +4,8 @@
 import logging
 import werkzeug
 import uuid
-from itertools import groupby
 
-from odoo import api, fields, models, _
+from odoo import api, fields, models
 from odoo import tools
 from odoo.addons.http_routing.models.ir_http import url_for
 from odoo.osv import expression
@@ -25,9 +24,9 @@ class View(models.Model):
     page_ids = fields.One2many('website.page', 'view_id')
     first_page_id = fields.Many2one('website.page', string='Website Page', help='First page linked to this view', compute='_compute_first_page_id')
     track = fields.Boolean(string='Track', default=False, help="Allow to specify for one page of the website to be trackable or not")
-    visibility = fields.Selection([('', 'All'), ('connected', 'Connected'), ('restricted_group', 'Restricted Group'), ('password', 'With Password'), ('employee', 'Internal Users')], default='')
+    visibility = fields.Selection([('', 'All'), ('connected', 'Signed In'), ('restricted_group', 'Restricted Group'), ('password', 'With Password')], default='')
     visibility_group = fields.Many2one('res.groups')
-    visibility_password = fields.Char(groups='base.group_system')
+    visibility_password = fields.Char(groups='website.group_website_publisher')
 
     def _compute_first_page_id(self):
         for view in self:
@@ -314,22 +313,22 @@ class View(models.Model):
 
     def handle_visibility(self, do_raise=True):
         """ Check the visibility set on the main view and raise 403 if you should not have access.
-            Order is: Public, Connected, Has group, Password, Employee
-            An user type can see all previous type. So an employee can see password page withtout
-            know the password.
+            Order is: Public, Connected, Has group, Password
 
-            It only check the visibility on the main content, others views called stay available in
-            rpc or via other way.
+            It only check the visibility on the main content, others views called stay available in rpc.
         """
         error = False
         self = self.sudo()
         if self.visibility and not request.env.user.has_group('website.group_website_designer'):
-            if (self.visibility == 'connected' and request.website.is_public_user()) or \
-               (self.visibility == 'employee' and request.env.user.share) or \
-               (self.visibility == 'restricted_group' and request.env.user.share and self.visibility_group and
-                    request.env.user.id not in self.visibility_group.sudo().users.ids):
+            if (self.visibility == 'connected' and request.website.is_public_user()):
                 error = werkzeug.exceptions.Forbidden()
-            elif self.visibility == 'password' and request.env.user.share and (request.website.is_public_user() or self.id not in request.session.get('views_unlock', [])):
+            elif self.visibility == 'restricted_group' and self.visibility_group:
+                # special case, to avoid employee.user_ids
+                if (self.visibility_group.get_external_id() == 'base.group_user' and not request.env.user.share) or \
+                        request.env.user.id not in self.visibility_group.sudo().users.ids:
+                    error = werkzeug.exceptions.Forbidden()
+            elif self.visibility == 'password' and \
+                    (request.website.is_public_user() or self.id not in request.session.get('views_unlock', [])):
                 if self.sudo().visibility_password == request.params.get('visibility_password'):
                     request.session.setdefault('views_unlock', list()).append(self.id)
                 else:

--- a/addons/website/models/website.py
+++ b/addons/website/models/website.py
@@ -769,11 +769,14 @@ class Website(models.Model):
                     yield page
 
         # '/' already has a http.route & is in the routing_map so it will already have an entry in the xml
-        domain = [('url', '!=', '/'), ('visibility', '=', False)]
+        domain = [('url', '!=', '/')]
         if not force:
-            domain += [('website_indexed', '=', True)]
+            domain += [('website_indexed', '=', True), ('visibility', '=', False)]
             # is_visible
-            domain += [('website_published', '=', True), '|', ('date_publish', '=', False), ('date_publish', '<=', fields.Datetime.now())]
+            domain += [
+                ('website_published', '=', True), ('visibility', '=', False),
+                '|', ('date_publish', '=', False), ('date_publish', '<=', fields.Datetime.now())
+            ]
 
         if query_string:
             domain += [('url', 'like', query_string)]

--- a/addons/website/models/website_page.py
+++ b/addons/website/models/website_page.py
@@ -62,6 +62,16 @@ class Page(models.Model):
         """ Get identifier of this page view that may be used to render it """
         return self.view_id.id
 
+    def get_page_properties(self):
+        self.ensure_one()
+        res = self.read([
+            'id', 'name', 'url', 'website_published', 'website_indexed', 'date_publish',
+            'menu_ids', 'is_homepage', 'website_id', 'visibility', 'visibility_password', 'visibility_group'
+        ])[0]
+        if not res['visibility_group']:
+            res['visibility_group'] = self.env.ref('base.group_user').name_get()[0]
+        return res
+
     @api.model
     def save_page_info(self, website_id, data):
         website = self.env['website'].browse(website_id)
