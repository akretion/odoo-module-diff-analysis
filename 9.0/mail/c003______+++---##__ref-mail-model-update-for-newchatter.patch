PR: https://github.com/odoo/odoo/pull/

From: 88b8cd058713bfad2942f7e7434c34b6c1a6e7da
From: Thibault Delavall√©e
Date: 2015-08-21 10:11:56

Structural Changes: 24.8
Total Changes: 528

[REF] mail: model update for NewChatter

Main changes :
- mail.notification model is removed. People do not receive notifications
anymore. Instead two ways of following documents exist
  - using a channel; messages will be displayed on the channel itself
  in a near future commit
  - following with its partner; messages will all be considered as
  needaction, using a new m2m table. People should receive less
  needaction messages by following less records by themselves.
There is no more read / unread state anymore. Instead only needaction
messages are considered. Todo (Favorites) messages still exist, and are
stores on a new m2m table instead of using decorated notifciations.
- the main filter for documents is not message_unread anymore, but
message_needaction. A lot of views and filters have been updated
accordingly.
- the vote feature has been removed

================================= pseudo patch: =================================

--- a/addons/mail/models/mail_channel.py
+++ b/addons/mail/models/mail_channel.py
@@ -13,7 +13,7 @@ class ChannelPartner(models.Model):
 
     partner_id = fields.Many2one('res.partner', string='Recipient')
     channel_id = fields.Many2one('mail.channel', string='Channel')
-    seen_datetime = fields.Datetime('Last Seen Datetime')
+    seen_message_id = fields.Many2one('mail.message', string='Last Seen')
 
 
 class Channel(models.Model):
@@ -37,7 +37,7 @@ class Channel(models.Model):
         'Channel Type', default='channel')
     description = fields.Text('Description')
     uuid = fields.Char('UUID', size=50, select=True, default=lambda self: '%s' % uuid.uuid4())
-    email_send = fields.Boolean('Email Sent', default=True)  # True for mail.channel
+    email_send = fields.Boolean('Email Sent', default=True)
     # multi users channel
     channel_last_seen_partner_ids = fields.One2many('mail.channel.partner', 'channel_id', string='Last Seen')
     channel_partner_ids = fields.Many2many('res.partner', 'mail_channel_partner', 'channel_id', 'partner_id', string='Listeners')
@@ -70,8 +70,7 @@ class Channel(models.Model):
                                      "Use this field anywhere a small image is required.")
     alias_id = fields.Many2one(
         'mail.alias', 'Alias', ondelete="restrict", required=True,
-        help="The email address associated with this group. New emails received will automatically "
-             "create new topics.")
+        help="The email address associated with this group. New emails received will automatically create new topics.")
 
     @api.one
     @api.depends('image')
@@ -123,6 +122,10 @@ class Channel(models.Model):
             self._subscribe_users()
         return result
 
+    def _notify(self, message):
+        # DO SOMETHING USEFULL
+        return True
+
     def _subscribe_users(self):
         for mail_channel in self:
             mail_channel.write({'channel_partner_ids': [(4, pid) for pid in mail_channel.mapped('group_ids').mapped('users').mapped('partner_id').ids]})

--- a/addons/mail/models/mail_followers.py
+++ b/addons/mail/models/mail_followers.py
@@ -130,54 +130,3 @@ class Followers(models.Model):
         ('mail_followers_res_partner_res_model_id_uniq', 'unique(res_model,res_id,partner_id)', 'Error, a partner cannot follow twice the same object.'),
         ('mail_followers_res_channel_res_model_id_uniq', 'unique(res_model,res_id,channel_id)', 'Error, a channel cannot follow twice the same object.'),
     ]
-
-
-class Notification(models.Model):
-    """ Class holding notifications pushed to partners. Followers and partners
-    added in 'contacts to notify' receive notifications. """
-    _name = 'mail.notification'
-    _rec_name = 'partner_id'
-    _log_access = False
-    _description = 'Notifications'
-
-    partner_id = fields.Many2one('res.partner', string='Contact', ondelete='cascade', required=True, select=1)
-    is_read = fields.Boolean('Read', select=1, oldname='read')
-    starred = fields.Boolean('Starred', select=1, help='Starred message that goes into the todo mailbox')
-    message_id = fields.Many2one('mail.message', string='Message', ondelete='cascade', required=True, select=1)
-
-    def init(self, cr):
-        cr.execute('SELECT indexname FROM pg_indexes WHERE indexname = %s', ('mail_notification_partner_id_read_starred_message_id',))
-        if not cr.fetchone():
-            cr.execute('CREATE INDEX mail_notification_partner_id_read_starred_message_id ON mail_notification (partner_id, is_read, starred, message_id)')
-
-    @api.model
-    def _notify(self, message, recipients=None, force_send=False, user_signature=True):
-        """ Send by email the notification depending on the user preferences
-
-            :param list partners_to_notify: optional list of partner ids restricting
-                the notifications to process
-            :param bool force_send: if True, the generated mail.mail is
-                immediately sent after being created, as if the scheduler
-                was executed for this message only.
-            :param bool user_signature: if True, the generated mail.mail body is
-                the body of the related mail.message with the author's signature
-        """
-        # mail_notify_noemail (do not send email) or no partner_ids: do not send, return
-        if self.env.context.get('mail_notify_noemail'):
-            return True
-        if not recipients:
-            recipients = message.partner_ids
-
-        notifications = self.env['mail.notification'].sudo().search(
-            [('message_id', '=', message.id), ('partner_id', 'in', recipients.ids)])
-        notifications.write({'is_read': False})
-        new_notifications = self.env['mail.notification'].sudo()
-        for new_partner in recipients - notifications.mapped('partner_id'):
-            new_notifications |= self.env['mail.notification'].sudo().create({
-                'message_id': message.id,
-                'partner_id': new_partner.id,
-                'is_read': False})
-        new_recipients = new_notifications.mapped('partner_id')
-
-        # notify
-        new_recipients._notify(message, force_send=force_send, user_signature=user_signature)

--- a/addons/mail/models/mail_message.py
+++ b/addons/mail/models/mail_message.py
@@ -84,24 +84,20 @@ class Message(models.Model):
     author_avatar = fields.Binary("Author's avatar", related='author_id.image_small')
     # recipients
     partner_ids = fields.Many2many('res.partner', string='Recipients')
-    notified_partner_ids = fields.Many2many(
-        'res.partner', 'mail_notification',
-        'message_id', 'partner_id', 'Notified partners',
-        help='Partners that have a notification pushing this message in their mailboxes')
-    notification_ids = fields.One2many(
-        'mail.notification', 'message_id',
-        string='Notifications', auto_join=True,
-        help='Technical field holding the message notifications. Use notified_partner_ids to access notified partners.')
-    # chatter
-    to_read = fields.Boolean(
-        'To read', compute='_get_to_read', search='_search_to_read',
-        help='Current user has an unread notification linked to this message')
+    needaction_partner_ids = fields.Many2many(
+        'res.partner', 'mail_message_res_partner_needaction_rel', string='Need Action')
+    needaction = fields.Boolean(
+        'Need Action', compute='_get_needaction', search='_search_needaction',
+        help='Need Action')
+    channel_ids = fields.Many2many(
+        'mail.channel', 'mail_message_mail_channel_rel', string='Channels')
+    # user interface
+    starred_partner_ids = fields.Many2many(
+        'res.partner', 'mail_message_res_partner_starred_rel', string='Favorited By')
     starred = fields.Boolean(
         'Starred', compute='_get_starred', search='_search_starred',
         help='Current user has a starred notification linked to this message')
-    vote_user_ids = fields.Many2many(
-        'res.users', 'mail_vote', 'message_id', 'user_id', string='Votes',
-        help='Users that voted for this message')
+    # tracking
     tracking_value_ids = fields.One2many(
         'mail.tracking.value', 'mail_message_id',
         string='Tracking values',
@@ -115,55 +111,36 @@ class Message(models.Model):
     reply_to = fields.Char('Reply-To', help='Reply email address. Setting the reply_to bypasses the automatic thread creation.')
     mail_server_id = fields.Many2one('ir.mail_server', 'Outgoing mail server', readonly=1)
 
-    @api.depends('notification_ids')
-    def _get_to_read(self):
-        """ Compute if the message is unread by the current user. """
-        partner_id = self.env.user.partner_id.id
-        notifications = self.env['mail.notification'].sudo().search([
-            ('partner_id', '=', partner_id),
-            ('message_id', 'in', self.ids),
-            ('is_read', '=', False)])
+    @api.multi
+    def _get_needaction(self):
+        """ Need action on a mail.message = notified on my channel """
+        my_messages = self.sudo().filtered(lambda msg: self.env.user.partner_id in msg.needaction_partner_ids)
         for message in self:
-            message.to_read = message in notifications.mapped('message_id')
+            message.needaction = message in my_messages
 
-    def _search_to_read(self, operator, operand):
-        """ Search for messages to read by the current user. Condition is
-        inversed because we search unread message on a is_read column. """
-        return ['&', ('notification_ids.partner_id.user_ids', 'in', [self.env.uid]), ('notification_ids.is_read', operator, not operand)]
+    @api.model
+    def _search_needaction(self, operator, operand):
+        if operator == '=' and operand:
+            return [('needaction_partner_ids', 'in', self.env.user.partner_id.id)]
+        return [('needaction_partner_ids', 'not in', self.env.user.partner_id.id)]
 
-    @api.depends('notification_ids')
+    @api.depends('starred_partner_ids')
     def _get_starred(self):
         """ Compute if the message is starred by the current user. """
-        partner_id = self.env.user.partner_id.id
-        notifications = self.env['mail.notification'].sudo().search([
-            ('partner_id', '=', partner_id),
-            ('message_id', 'in', self.ids),
-            ('starred', '=', True)])
+        # TDE FIXME: use SQL
+        starred = self.sudo().filtered(lambda msg: self.env.user.partner_id in msg.starred_partner_ids)
         for message in self:
-            message.starred = message in notifications.mapped('message_id')
+            message.starred = message in starred
 
+    @api.model
     def _search_starred(self, operator, operand):
-        """ Search for starred messages by the current user."""
-        return ['&', ('notification_ids.partner_id.user_ids', 'in', [self.env.uid]), ('notification_ids.starred', operator, operand)]
+        if operator == '=' and operand:
+            return [('starred_partner_ids', 'in', [self.env.user.partner_id.id])]
+        return [('starred_partner_ids', 'not in', [self.env.user.partner_id.id])]
 
     @api.model
     def _needaction_domain_get(self):
-        return [('to_read', '=', True)]
-
-    #------------------------------------------------------
-    # Vote/Like
-    #------------------------------------------------------
-
-    @api.multi
-    def vote_toggle(self):
-        ''' Toggles vote. Performed using read to avoid access rights issues. '''
-        for message in self.sudo():
-            new_has_voted = not (self._uid in message.vote_user_ids.ids)
-            if new_has_voted:
-                self.browse(message.id).write({'vote_user_ids': [(4, self._uid)]})  # tde: todo with user access rights
-            else:
-                self.browse(message.id).write({'vote_user_ids': [(3, self._uid)]})  # tde: todo with user access rights
-        return new_has_voted or False
+        return [('needaction', '=', True)]
 
     #------------------------------------------------------
     # download an attachment
@@ -186,33 +163,19 @@ class Message(models.Model):
     #------------------------------------------------------
 
     @api.multi
-    def set_message_read(self, read, create_missing=True):
-        """ Set messages as (un)read. Technically, the notifications related
-            to uid are set to (un)read. If for some msg_ids there are missing
-            notifications (i.e. due to load more or thread parent fetching),
-            they are created.
+    def set_message_needaction(self, partner_ids=None):
+        if not partner_ids:
+            partner_ids = [self.env.user.partner_id.id]
+        return self.write({'needaction_partner_ids': [(4, pid) for pid in partner_ids]})
 
-            :param bool read: set notification as (un)read
-            :param bool create_missing: create notifications for missing entries
-                (i.e. when acting on displayed messages not notified)
-
-            :return number of message mark as read
-        """
-        notifications = self.env['mail.notification'].search([
-            ('partner_id', '=', self.env.user.partner_id.id),
-            ('message_id', 'in', self.ids),
-            ('is_read', '=', not read)])
-        notifications.write({'is_read': read})
-
-        # some messages do not have notifications: find which one, create notification, update read status
-        if len(notifications) < len(self) and create_missing:
-            for message in self - notifications.mapped('message_id'):
-                self.env['mail.notification'].create({'partner_id': self.env.user.partner_id.id, 'is_read': read, 'message_id': message.id})
-
-        return len(notifications)
+    @api.multi
+    def set_message_done(self, partner_ids=None):
+        if not partner_ids:
+            partner_ids = [self.env.user.partner_id.id]
+        return self.write({'needaction_partner_ids': [(3, pid) for pid in partner_ids]})
 
     @api.multi
-    def set_message_starred(self, starred, create_missing=True):
+    def set_message_starred(self, starred):
         """ Set messages as (un)starred. Technically, the notifications related
             to uid are set to (un)starred.
 
@@ -220,22 +183,10 @@ class Message(models.Model):
             :param bool create_missing: create notifications for missing entries
                 (i.e. when acting on displayed messages not notified)
         """
-        values = {'starred': starred}
         if starred:
-            values['is_read'] = False
-        notifications = self.env['mail.notification'].search([
-            ('partner_id', '=', self.env.user.partner_id.id),
-            ('message_id', 'in', self.ids),
-            ('starred', '=', not starred)])
-        notifications.write(values)
-
-        # some messages do not have notifications: find which one, create notification, update starred status
-        if len(notifications) < len(self) and create_missing:
-            values['partner_id'] = self.env.user.partner_id.id
-            for message in self - notifications.mapped('message_id'):
-                values['message_id'] = message.id
-                self.env['mail.notification'].create(values)
-
+            self.write({'starred_partner_ids': [(4, self.env.user.partner_id.id)]})
+        else:
+            self.write({'starred_partner_ids': [(3, self.env.user.partner_id.id)]})
         return starred
 
     #------------------------------------------------------
@@ -259,8 +210,8 @@ class Message(models.Model):
         for key, message in message_tree.iteritems():
             if message.author_id:
                 partners |= message.author_id
-            if message.subtype_id and message.notified_partner_ids:  # take notified people of message with a subtype
-                partners |= message.notified_partner_ids
+            if message.subtype_id and message.partner_ids:  # take notified people of message with a subtype
+                partners |= message.partner_ids
             elif not message.subtype_id and message.partner_ids:  # take specified people of message without a subtype (log)
                 partners |= message.partner_ids
             if message.attachment_ids:
@@ -298,7 +249,7 @@ class Message(models.Model):
                 author = (0, message.email_from)
             partner_ids = []
             if message.subtype_id:
-                partner_ids = [partner_tree[partner.id] for partner in message.notified_partner_ids
+                partner_ids = [partner_tree[partner.id] for partner in message.partner_ids
                                 if partner.id in partner_tree]
             else:
                 partner_ids = [partner_tree[partner.id] for partner in message.partner_ids
@@ -336,9 +287,6 @@ class Message(models.Model):
         is_private = False
         if not self.model or not self.res_id:
             is_private = True
-        # votes and favorites: res.users ids, no prefetching should be done
-        vote_nb = len(self.vote_user_ids)
-        has_voted = self._uid in [user.id for user in self.vote_user_ids]
 
         return {'id': self.id,
                 'message_type': self.message_type,
@@ -349,15 +297,13 @@ class Message(models.Model):
                 'record_name': self.record_name,
                 'subject': self.subject,
                 'date': self.date,
-                'to_read': self.to_read,
+                'needaction': self.needaction,
                 'parent_id': parent_id,
                 'is_private': is_private,
                 'author_id': False,
                 'author_avatar': self.author_avatar,
                 'is_author': False,
                 'partner_ids': [],
-                'vote_nb': vote_nb,
-                'has_voted': has_voted,
                 'is_favorite': self.starred,
                 'attachment_ids': [],
                 'tracking_value_ids': [],
@@ -498,17 +444,6 @@ class Message(models.Model):
 
         return {'nb_read': nb_read, 'threads': parent_list}
 
-    @api.multi
-    def get_like_names(self, limit=10):
-        """ Return the people list who liked this message. """
-        self.ensure_one()
-        voter_names = [voter.name for voter in self.vote_user_ids[:limit]]
-        if len(self.vote_user_ids) > limit:
-            voter_names.append(_("and %s others like this") % (len(self.vote_user_ids) - limit))
-        return voter_names
-    # compat
-    get_likers_list = get_like_names
-
     #------------------------------------------------------
     # mail_message internals
     #------------------------------------------------------
@@ -536,14 +471,17 @@ class Message(models.Model):
 
     @api.model
     def _search(self, args, offset=0, limit=None, order=None, count=False, access_rights_uid=None):
-        """ Override that adds specific access rights of mail.message, to remove ids uid could not see according to our custom rules. Please refer to check_access_rule for more details about those rules.
+        """ Override that adds specific access rights of mail.message, to remove
+        ids uid could not see according to our custom rules. Please refer to
+        check_access_rule for more details about those rules.
 
-            Non employees users see only message with subtype (aka do not see
-            internal logs).
+        Non employees users see only message with subtype (aka do not see
+        internal logs).
 
         After having received ids of a classic search, keep only:
         - if author_id == pid, uid is the author, OR
-        - a notification (id, pid) exists, uid has been notified, OR
+        - uid belongs to a notified channel, OR
+        - uid is in the specified recipients, OR
         - uid have read access to the related document is model, res_id
         - otherwise: remove the id
         """
@@ -565,26 +503,36 @@ class Message(models.Model):
             return ids
 
         pid = self.env.user.partner_id.id
-        author_ids, partner_ids, allowed_ids = set([]), set([]), set([])
+        author_ids, partner_ids, channel_ids, allowed_ids = set([]), set([]), set([]), set([])
         model_ids = {}
 
         # check read access rights before checking the actual rules on the given ids
         super(Message, self.sudo(access_rights_uid or self._uid)).check_access_rights('read')
 
-        self._cr.execute("""SELECT DISTINCT m.id, m.model, m.res_id, m.author_id, n.partner_id
-            FROM "%s" m LEFT JOIN "mail_notification" n
-            ON n.message_id=m.id AND n.partner_id = (%%s)
-            WHERE m.id = ANY (%%s)""" % self._table, (pid, ids,))
-        for id, rmod, rid, author_id, partner_id in self._cr.fetchall():
+        self._cr.execute("""SELECT DISTINCT m.id, m.model, m.res_id, m.author_id, partner_rel.res_partner_id, channel_partner.channel_id as channel_id
+            FROM "%s" m
+            LEFT JOIN "mail_message_res_partner_rel" partner_rel
+            ON partner_rel.mail_message_id = m.id AND partner_rel.res_partner_id = (%%s)
+            LEFT JOIN "mail_message_mail_channel_rel" channel_rel
+            ON channel_rel.mail_message_id = m.id
+            LEFT JOIN "mail_channel" channel
+            ON channel.id = channel_rel.mail_channel_id
+            LEFT JOIN "mail_channel_partner" channel_partner
+            ON channel_partner.channel_id = channel.id AND channel_partner.partner_id = (%%s)
+            WHERE m.id = ANY (%%s)""" % self._table, (pid, pid, ids,))
+        for id, rmod, rid, author_id, partner_id, channel_id in self._cr.fetchall():
             if author_id == pid:
                 author_ids.add(id)
             elif partner_id == pid:
                 partner_ids.add(id)
+            elif channel_id:
+                channel_ids.add(id)
             elif rmod and rid:
                 model_ids.setdefault(rmod, {}).setdefault(rid, set()).add(id)
 
         allowed_ids = self._find_allowed_doc_ids(model_ids)
-        final_ids = author_ids | partner_ids | allowed_ids
+
+        final_ids = author_ids | partner_ids | channel_ids | allowed_ids
 
         if count:
             return len(final_ids)
@@ -597,14 +545,15 @@ class Message(models.Model):
     def check_access_rule(self, operation):
         """ Access rules of mail.message:
             - read: if
-                - author_id == pid, uid is the author, OR
-                - mail_notification (id, pid) exists, uid has been notified, OR
+                - author_id == pid, uid is the author OR
+                - uid is in the recipients (partner_ids) OR
+                - uid is member of a listern channel (channel_ids.partner_ids) OR
                 - uid have read access to the related document if model, res_id
                 - otherwise: raise
             - create: if
-                - no model, no res_id, I create a private message OR
+                - no model, no res_id (private message) OR
                 - pid in message_follower_ids if model, res_id OR
-                - mail_notification (parent_id.id, pid) exists, uid has been notified of the parent, OR
+                - uid can read the parent OR
                 - uid have write or create access on the related document if model, res_id, OR
                 - otherwise: raise
             - write: if
@@ -643,21 +592,33 @@ class Message(models.Model):
                     _('The requested operation cannot be completed due to security restrictions. Please contact your system administrator.\n\n(Document type: %s, Operation: %s)') %
                     (self._description, operation))
 
-        Notification = self.env['mail.notification']
-        Followers = self.env['mail.followers']
-        partner_id = self.env.user.partner_id.id
-
         # Read mail_message.ids to have their values
         message_values = dict((res_id, {}) for res_id in self.ids)
-        self._cr.execute('SELECT DISTINCT id, model, res_id, author_id, parent_id FROM "%s" WHERE id = ANY (%%s)' % self._table, (self.ids,))
-        for mid, rmod, rid, author_id, parent_id in self._cr.fetchall():
-            message_values[mid] = {'model': rmod, 'res_id': rid, 'author_id': author_id, 'parent_id': parent_id}
 
-        # Author condition (READ, WRITE, CREATE (private)) -> could become an ir.rule ?
+        if operation == 'read':
+            self._cr.execute("""SELECT DISTINCT m.id, m.model, m.res_id, m.author_id, m.parent_id, partner_rel.res_partner_id, channel_partner.channel_id as channel_id
+                FROM "%s" m
+                LEFT JOIN "mail_message_res_partner_rel" partner_rel
+                ON partner_rel.mail_message_id = m.id AND partner_rel.res_partner_id = (%%s)
+                LEFT JOIN "mail_message_mail_channel_rel" channel_rel
+                ON channel_rel.mail_message_id = m.id
+                LEFT JOIN "mail_channel" channel
+                ON channel.id = channel_rel.mail_channel_id
+                LEFT JOIN "mail_channel_partner" channel_partner
+                ON channel_partner.channel_id = channel.id AND channel_partner.partner_id = (%%s)
+                WHERE m.id = ANY (%%s)""" % self._table, (self.env.user.partner_id.id, self.env.user.partner_id.id, self.ids,))
+            for mid, rmod, rid, author_id, parent_id, partner_id, channel_id in self._cr.fetchall():
+                message_values[mid] = {'model': rmod, 'res_id': rid, 'author_id': author_id, 'parent_id': parent_id, 'partner_id': partner_id, 'channel_id': channel_id}
+        else:
+            self._cr.execute("""SELECT DISTINCT id, model, res_id, author_id, parent_id FROM "%s" WHERE id = ANY (%%s)""" % self._table, (self.ids,))
+            for mid, rmod, rid, author_id, parent_id in self._cr.fetchall():
+                message_values[mid] = {'model': rmod, 'res_id': rid, 'author_id': author_id, 'parent_id': parent_id}
+
+        # Author condition (READ, WRITE, CREATE (private))
         author_ids = []
         if operation == 'read' or operation == 'write':
             author_ids = [mid for mid, message in message_values.iteritems()
-                          if message.get('author_id') and message.get('author_id') == partner_id]
+                          if message.get('author_id') and message.get('author_id') == self.env.user.partner_id.id]
         elif operation == 'create':
             author_ids = [mid for mid, message in message_values.iteritems()
                           if not message.get('model') and not message.get('res_id')]
@@ -665,10 +626,20 @@ class Message(models.Model):
         # Parent condition, for create (check for received notifications for the created message parent)
         notified_ids = []
         if operation == 'create':
+            # TDE: probably clean me
             parent_ids = [message.get('parent_id') for mid, message in message_values.iteritems()
                           if message.get('parent_id')]
-            notifications = Notification.sudo().search([('message_id.id', 'in', parent_ids), ('partner_id', '=', partner_id)])
-            not_parent_ids = [notif.message_id.id for notif in notifications]
+            self._cr.execute("""SELECT DISTINCT m.id FROM "%s" m
+                LEFT JOIN "mail_message_res_partner_rel" partner_rel
+                ON partner_rel.mail_message_id = m.id AND partner_rel.res_partner_id = (%%s)
+                LEFT JOIN "mail_message_mail_channel_rel" channel_rel
+                ON channel_rel.mail_message_id = m.id
+                LEFT JOIN "mail_channel" channel
+                ON channel.id = channel_rel.mail_channel_id
+                LEFT JOIN "mail_channel_partner" channel_partner
+                ON channel_partner.channel_id = channel.id AND channel_partner.partner_id = (%%s)
+                WHERE m.id = ANY (%%s)""" % self._table, (self.env.user.partner_id.id, self.env.user.partner_id.id, parent_ids,))
+            not_parent_ids = [mid[0] for mid in self._cr.fetchall()]
             notified_ids += [mid for mid, message in message_values.iteritems()
                              if message.get('parent_id') in not_parent_ids]
 
@@ -676,16 +647,14 @@ class Message(models.Model):
         other_ids = set(self.ids).difference(set(author_ids), set(notified_ids))
         model_record_ids = _generate_model_record_ids(message_values, other_ids)
         if operation == 'read':
-            notifications = Notification.sudo().search([
-                ('partner_id', '=', partner_id),
-                ('message_id', 'in', self.ids)])
-            notified_ids = [notification.message_id.id for notification in notifications]
+            notified_ids = [mid for mid, message in message_values.iteritems() if message.get('partner_id') or message.get('channel_id')]
         elif operation == 'create':
             for doc_model, doc_ids in model_record_ids.items():
-                followers = Followers.sudo().search([
+                followers = self.env['mail.followers'].sudo().search([
                     ('res_model', '=', doc_model),
                     ('res_id', 'in', list(doc_ids)),
-                    ('partner_id', '=', partner_id)])
+                    ('partner_id', '=', self.env.user.partner_id.id),
+                    ])
                 fol_mids = [follower.res_id for follower in followers]
                 notified_ids += [mid for mid, message in message_values.iteritems()
                                  if message.get('model') == doc_model and message.get('res_id') in fol_mids]
@@ -746,7 +715,9 @@ class Message(models.Model):
 
     @api.model
     def create(self, values):
-        default_starred = self.env.context.get('default_starred')
+        # coming from mail.js that does not have pid in its values
+        if self.env.context.get('default_starred'):
+            self = self.with_context({'default_starred_partner_ids': [(4, self.env.user.partner_id.id)]})
 
         if 'email_from' not in values:  # needed to compute reply_to
             values['email_from'] = self._get_default_from()
@@ -761,14 +732,6 @@ class Message(models.Model):
 
         message._notify(force_send=self.env.context.get('mail_notify_force_send', True),
                         user_signature=self.env.context.get('mail_notify_user_signature', True))
-        # TDE FIXME: handle default_starred. Why not setting an inv on starred ?
-        # Because starred will call set_message_starred, that looks for notifications.
-        # When creating a new mail_message, it will create a notification to a message
-        # that does not exist, leading to an error (key not existing). Also this
-        # this means unread notifications will be created, yet we can not assure
-        # this is what we want.
-        if default_starred:
-            message.set_message_starred(True)
         return message
 
     @api.multi
@@ -797,8 +760,8 @@ class Message(models.Model):
         """ Add the related record followers to the destination partner_ids if is not a private message.
             Call mail_notification.notify to manage the email sending
         """
-        self.ensure_one()  # tde: not sure, just for testinh, will see
-        partners_to_notify = self.env['res.partner']
+        # TDE CHECK: add partners / channels as arguments to be able to notify a message with / without computation ??
+        self.ensure_one()  # tde: not sure, just for testing, will see
 
         # all followers of the mail.message document have to be added as partners and notified
         # and filter to employees only if the subtype is internal
@@ -807,31 +770,34 @@ class Message(models.Model):
                 ('res_model', '=', self.model),
                 ('res_id', '=', self.res_id)
             ]).filtered(lambda fol: self.subtype_id in fol.subtype_ids)
-            if self.subtype_id.internal:
-                followers.filtered(lambda fol: fol.partner_id.user_ids and fol.partner_id.user_ids[0].has_group('base.group_user'))
-            partners_to_notify |= followers.mapped('partner_id')
-
-        # remove me from notified partners, unless the message is written on my own wall
-        if self.subtype_id and self.author_id and self.model == "res.partner" and self.res_id == self.author_id.id:
-            partners_to_notify |= self.author_id
-        elif self.author_id:
-            partners_to_notify -= self.author_id
-
-        # all partner_ids of the mail.message have to be notified regardless of the above (even the author if explicitly added!)
-        partners_to_notify |= self.partner_ids
-
-        # notify
-        self.env['mail.notification']._notify(self, recipients=partners_to_notify, force_send=force_send, user_signature=user_signature)
+            # if self.subtype_id.internal:
+            #     followers.filtered(lambda fol: fol.partner_id.user_ids and fol.partner_id.user_ids[0].has_group('base.group_user'))
+            channels = self.channel_ids | followers.mapped('channel_id')
+            partners = self.partner_ids | followers.mapped('partner_id')
+        else:
+            channels = self.channel_ids
+            partners = self.partner_ids
+
+        # remove me from notified partners
+        if self.author_id:
+            partners = partners - self.author_id
+
+        # notify partners
+        # TDE TODO: model-dependant ? (like customer -> always email ?)
+        email_channels = channels.filtered(lambda channel: channel.email_send)
+        self.env['res.partner'].sudo().search([
+            '|',
+            ('id', 'in', partners.ids),
+            ('channel_ids', 'in', email_channels.ids),
+            ('notify_email', '!=', 'none')]
+        )._notify(self, force_send=force_send, user_signature=user_signature)  # TDE: clean those parameters
+        # notify partners and channels
+        channels._notify(self)
 
         # An error appear when a user receive a notification without notifying
         # the parent message -> add a read notification for the parent
         if self.parent_id:
-            # all notified_partner_ids of the mail.message have to be notified for the parented messages
-            partners_to_parent_notify = self.notified_partner_ids - self.parent_id.notified_partner_ids
             self.parent_id.invalidate_cache()  # avoid access rights issues, as notifications are used for access
-            Notification = self.env['mail.notification'].sudo()
-            for partner in partners_to_parent_notify:
-                Notification.create({
-                    'message_id': self.parent_id.id,
-                    'partner_id': partner.id,
-                    'is_read': True})
+
+        # update message
+        return self.write({'channel_ids': [(6, 0, channels.ids)], 'needaction_partner_ids': [(6, 0, partners.ids)]})

--- a/addons/mail/models/mail_thread.py
+++ b/addons/mail/models/mail_thread.py
@@ -82,11 +82,17 @@ class MailThread(models.AbstractModel):
         help="Messages and communication history")
     message_last_post = fields.Datetime('Last Message Date', help='Date of the last message posted on the record.')
     message_unread = fields.Boolean(
-        'Unread Messages', compute='_get_message_unread', search='_search_message_unread',
+        'Unread Messages', compute='_get_message_unread',
         help="If checked new messages require your attention.")
     message_unread_counter = fields.Integer(
-        'Unread Messages', compute='_get_message_unread',
+        'Unread Messages Counter', compute='_get_message_unread',
         help="Number of unread messages")
+    message_needaction = fields.Boolean(
+        'Need Action', compute='_get_message_needaction', search='_search_message_needaction',
+        help="If checked new messages require your attention.")
+    message_needaction_counter = fields.Integer(
+        'Need Action Counter', compute='_get_message_needaction',
+        help="Number of needaction messages")
 
     @api.one
     @api.depends('message_follower_ids')
@@ -100,6 +106,8 @@ class MailThread(models.AbstractModel):
 
         Do not use with operator 'not in'. Use instead message_is_followers
         """
+        # TOFIX make it work with not in
+        assert operator != "not in", "Do not search message_follower_ids with 'not in'"
         followers = self.env['mail.followers'].sudo().search([
             ('res_model', '=', self._name),
             ('partner_id', operator, operand)])
@@ -111,6 +119,8 @@ class MailThread(models.AbstractModel):
 
         Do not use with operator 'not in'. Use instead message_is_followers
         """
+        # TOFIX make it work with not in
+        assert operator != "not in", "Do not search message_follower_ids with 'not in'"
         followers = self.env['mail.followers'].sudo().search([
             ('res_model', '=', self._name),
             ('channel_id', operator, operand)])
@@ -133,10 +143,12 @@ class MailThread(models.AbstractModel):
         res = dict((res_id, 0) for res_id in self.ids)
 
         # search for unread messages, directly in SQL to improve performances
-        self._cr.execute(""" SELECT m.res_id FROM mail_message m
-                             RIGHT JOIN mail_notification n
-                             ON (n.message_id = m.id AND n.partner_id = %s AND (n.is_read = False or n.is_read IS NULL))
-                             WHERE m.model = %s AND m.res_id in %s""",
+        self._cr.execute(""" SELECT msg.res_id FROM mail_message msg
+                             RIGHT JOIN mail_message_mail_channel_rel rel
+                             ON rel.mail_message_id = msg.id
+                             RIGHT JOIN mail_channel_partner cp
+                             ON (cp.channel_id = rel.mail_channel_id AND cp.partner_id = %s AND (cp.seen_message_id < msg.id))
+                             WHERE msg.model = %s AND msg.res_id in %s""",
                          (self.env.user.partner_id.id, self._name, tuple(self.ids),))
         for result in self._cr.fetchall():
             res[result[0]] += 1
@@ -145,9 +157,26 @@ class MailThread(models.AbstractModel):
             record.message_unread_counter = res.get(record.id, 0)
             record.message_unread = bool(record.message_unread_counter)
 
+    @api.multi
+    def _get_message_needaction(self):
+        res = dict((res_id, 0) for res_id in self.ids)
+
+        # search for unread messages, directly in SQL to improve performances
+        self._cr.execute(""" SELECT msg.res_id FROM mail_message msg
+                             RIGHT JOIN mail_message_res_partner_needaction_rel rel
+                             ON rel.mail_message_id = msg.id AND rel.res_partner_id = %s
+                             WHERE msg.model = %s AND msg.res_id in %s""",
+                         (self.env.user.partner_id.id, self._name, tuple(self.ids),))
+        for result in self._cr.fetchall():
+            res[result[0]] += 1
+
+        for record in self:
+            record.message_needaction_counter = res.get(record.id, 0)
+            record.message_needaction = bool(record.message_unread_counter)
+
     @api.model
-    def _search_message_unread(self, operator, operand):
-        return [('message_ids.to_read', operator, operand)]
+    def _search_message_needaction(self, operator, operand):
+        return [('message_ids.needaction', operator, operand)]
 
     # ------------------------------------------------------
     # CRUD overrides for automatic subscription and logging
@@ -418,7 +447,7 @@ class MailThread(models.AbstractModel):
     @api.model
     def _needaction_domain_get(self):
         if self._needaction:
-            return [('message_unread', '=', True)]
+            return [('message_needaction', '=', True)]
         return []
 
     @api.model
@@ -1080,8 +1109,9 @@ class MailThread(models.AbstractModel):
         model = self._context.get('thread_model') or self._name
         RecordModel = self.env[model]
         fields = RecordModel.fields_get()
-        if 'name' in fields and not data.get('name'):
-            data['name'] = msg_dict.get('subject', '')
+        name_field = RecordModel._rec_name or 'name'
+        if name_field in fields and not data.get('name'):
+            data[name_field] = msg_dict.get('subject', '')
         res = RecordModel.create(data)
         return res.id
 
@@ -1665,37 +1695,17 @@ class MailThread(models.AbstractModel):
 
     @api.multi
     def _message_auto_subscribe_notify(self, partner_ids):
-        """ Send notifications to the partners automatically subscribed to the thread
-            Override this method if a custom behavior is needed about partners
-            that should be notified or messages that should be sent
-        """
-        # find first email message, set it as unread for auto_subscribe fields for them to have a notification
+        """ Notify newly subscribed followers of the last posted message. """
         if not partner_ids:
             return
         for record_id in self.ids:
-            # TDE FIXME: is sudo necessary / a goot option ?
-            MailMessage = self.env['mail.message'].sudo()
-            messages = MailMessage.search([
+            messages = self.env['mail.message'].sudo().search([
                 ('model', '=', self._name),
                 ('res_id', '=', record_id),
-                ('message_type', '=', 'email')], limit=1)
-            if not messages:
-                messages = MailMessage.search([
-                    ('model', '=', self._name),
-                    ('res_id', '=', record_id)], limit=1)
+                ('subtype_id', '!=', False),
+                ('subtype_id.internal', '=', False)], limit=1)
             if messages:
-                message = messages[0]
-                notification_obj = self.env['mail.notification']
-                partners = self.env['res.partner'].sudo().browse(partner_ids)
-                notification_obj._notify(message, recipients=partners)
-                if message.parent_id:
-                    partner_ids_to_parent_notify = set(partner_ids).difference(partner.id for partner in message.parent_id.notified_partner_ids)
-                    for partner_id in partner_ids_to_parent_notify:
-                        notification_obj.create({
-                            'message_id': message.parent_id.id,
-                            'partner_id': partner_id,
-                            'is_read': True,
-                        })
+                messages.write({'needaction_partner_ids': [(4, pid) for pid in partner_ids]})
 
     @api.multi
     def message_auto_subscribe(self, updated_fields, values=None):
@@ -1777,31 +1787,9 @@ class MailThread(models.AbstractModel):
     # ------------------------------------------------------
 
     @api.multi
-    def message_mark_as_unread(self):
-        """ Set as unread. """
-        partner_id = self.env.user.partner_id.id
-        self._cr.execute('''
-            UPDATE mail_notification SET
-                is_read=false
-            WHERE
-                message_id IN (SELECT id from mail_message where res_id=any(%s) and model=%s limit 1) and
-                partner_id = %s
-        ''', (self.ids, self._name, partner_id))
-        self.env['mail.notification'].invalidate_cache(['is_read'])
-        return True
-
-    @api.multi
-    def message_mark_as_read(self):
-        """ Set as read. """
-        partner_id = self.env.user.partner_id.id
-        self._cr.execute('''
-            UPDATE mail_notification SET
-                is_read=true
-            WHERE
-                message_id IN (SELECT id FROM mail_message WHERE res_id=ANY(%s) AND model=%s) AND
-                partner_id = %s
-        ''', (self.ids, self._name, partner_id))
-        self.env['mail.notification'].invalidate_cache(['is_read'])
+    def message_set_read(self):
+        # Nothing done here currently. Will be implemented with the final
+        # slack modeling.
         return True
 
     @api.multi

--- a/addons/mail/models/res_partner.py
+++ b/addons/mail/models/res_partner.py
@@ -24,6 +24,7 @@ class Partner(models.Model):
     opt_out = fields.Boolean(
         'Opt-Out', help="If opt-out is checked, this contact has refused to receive emails for mass mailing and marketing campaign. "
                         "Filter 'Available for Mass Mailing' allows users to filter the partners when performing mass mailing.")
+    channel_ids = fields.Many2many('mail.channel', 'mail_channel_partner', 'partner_id', 'channel_id', string='Channels')
 
     @api.multi
     def message_get_suggested_recipients(self):
@@ -36,6 +37,11 @@ class Partner(models.Model):
     def message_get_default_recipients(self):
         return dict((res_id, {'partner_ids': [res_id], 'email_to': False, 'email_cc': False}) for res_id in self.ids)
 
+    @api.multi
+    def _notify(self, message, force_send=False, user_signature=True):
+        email_recipients = self.get_partners_to_email(message, self)
+        return email_recipients._notify_email(message, force_send=force_send, user_signature=user_signature)
+
     def get_partners_to_email(self, message, recipients):
         """ Return the list of partners to notify, based on their preferences.
 
@@ -148,22 +154,3 @@ class Partner(models.Model):
                 getattr(threading.currentThread(), 'testing', False)):
             emails.send()
         return True
-
-    @api.multi
-    def _notify(self, message, force_send=False, user_signature=True):
-        """ Send by email the notification depending on the user preferences
-
-            :param list partners_to_notify: optional list of partner ids restricting
-                the notifications to process
-            :param bool force_send: if True, the generated mail.mail is
-                immediately sent after being created, as if the scheduler
-                was executed for this message only.
-            :param bool user_signature: if True, the generated mail.mail body is
-                the body of the related mail.message with the author's signature
-        """
-        if self.ids:
-            recipients = self
-        else:
-            recipients = message.notified_partner_ids
-        email_recipients = self.get_partners_to_email(message, recipients)
-        email_recipients._notify_email(message, force_send=force_send, user_signature=user_signature)

--- a/addons/mail/models/res_users.py
+++ b/addons/mail/models/res_users.py
@@ -10,6 +10,8 @@ class Users(models.Model):
         - make a new user follow itself
         - add a welcome message
         - add suggestion preference
+        - if adding groups to an user, check mail.channels linked to this user
+          group, and the user. This is done by overriding the write method.
     """
     _name = 'res.users'
     _inherit = ['res.users']
@@ -18,6 +20,7 @@ class Users(models.Model):
     alias_id = fields.Many2one('mail.alias', 'Alias', ondelete="restrict", required=True,
             help="Email address internally associated with this user. Incoming "\
                  "emails will appear in the user's notifications.", copy=False, auto_join=True)
+    chatter_needaction_auto = fields.Boolean('Automatically set needaction as Read')
 
     def __init__(self, pool, cr):
         """ Override of __init__ to add access rights on notification_email_send
@@ -34,10 +37,8 @@ class Users(models.Model):
         return init_res
 
     def _auto_init(self, cr, context=None):
-        """ Installation hook: aliases, partner following themselves """
-        # create aliases for all users and avoid constraint errors
-        return self.pool.get('mail.alias').migrate_to_alias(cr, self._name, self._table, super(Users, self)._auto_init,
-            self._name, self._columns['alias_id'], 'login', alias_force_key='id', context=context)
+        """ Installation hook: aliases """
+        return self.pool.get('mail.alias').migrate_to_alias(cr, self._name, self._table, super(Users, self)._auto_init, self._name, self._columns['alias_id'], 'login', alias_force_key='id', context=context)
 
     @api.model
     def create(self, values):
