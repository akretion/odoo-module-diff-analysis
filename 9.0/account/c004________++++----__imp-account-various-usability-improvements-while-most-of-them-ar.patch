PR: https://github.com/odoo/odoo/pull/

From: 0b3e01c13fb485f223d8cb9585266384b7b46d66
From: qdp-odoo
Date: 2015-07-14 19:48:23

Structural Changes: 41
Total Changes: 75

[IMP] account*: various usability improvements. While most of them are simple renaming, it also includes the following field removals:
   - [REM] account_budget: removal of field 'validating _user_id' on account.crossovered.budget, which is now replaced by inheritance with mail.thread
   - [REM] account_budget: removal of field 'code' of account.crossovered.budget, which was not used and redondant with its name
   - [REM] account_asset: removal of field 'note' of account.asset.category, which was not used and redondant with its name
   - [REM] account: removal of field 'to_check' of account.move, which was redondant with state == 'draft'
   - [REM] account_voucher: removal of field 'audit' of account.voucher, which was a fields.related on move_id.to_check

================================= pseudo patch: =================================

--- a/addons/account/models/account.py
+++ b/addons/account/models/account.py
@@ -5,7 +5,6 @@ import math
 
 from openerp.osv import expression
 from openerp.tools.float_utils import float_round as round
-from openerp.tools.safe_eval import safe_eval as eval
 from openerp.tools import DEFAULT_SERVER_DATETIME_FORMAT
 from openerp.exceptions import UserError
 from openerp import api, fields, models, _
@@ -108,14 +107,14 @@ class AccountAccount(models.Model):
     last_time_entries_checked = fields.Datetime(string='Latest Invoices & Payments Matching Date', readonly=True, copy=False,
         help='Last time the invoices & payments matching was performed on this account. It is set either if there\'s not at least '\
         'an unreconciled debit and an unreconciled credit Or if you click the "Done" button.')
-    reconcile = fields.Boolean(string='Allow Invoices & Payments Matching', default=False,
+    reconcile = fields.Boolean(string='Reconciliation of Entries', default=False,
         help="Check this box if this account allows invoices & payments matching of journal items.")
     tax_ids = fields.Many2many('account.tax', 'account_account_tax_default_rel',
         'account_id', 'tax_id', string='Default Taxes')
     note = fields.Text('Internal Notes')
     company_id = fields.Many2one('res.company', string='Company', required=True,
         default=lambda self: self.env['res.company']._company_default_get('account.account'))
-    tag_ids = fields.Many2many('account.account.tag', 'account_account_account_tag', string='Account tag', help="Optional tags you may want to assign for custom reporting")
+    tag_ids = fields.Many2many('account.account.tag', 'account_account_account_tag', string='Tags', help="Optional tags you may want to assign for custom reporting")
 
     _sql_constraints = [
         ('code_company_uniq', 'unique (code,company_id)', 'The code of the account must be unique per company !')
@@ -190,7 +189,7 @@ class AccountJournal(models.Model):
         return self.env.ref('account.account_payment_method_manual_out')
 
     name = fields.Char(string='Journal Name', required=True)
-    code = fields.Char(string='Short Name', size=5, required=True, help="The code will be displayed on reports.")
+    code = fields.Char(string='Sequence Prefix', size=5, required=True, help="The journal entries of this journal will be named using this prefix.")
     type = fields.Selection([
             ('sale', 'Sale'),
             ('purchase', 'Purchase'),
@@ -203,8 +202,8 @@ class AccountJournal(models.Model):
         " Select 'Cash' or 'Bank' for journals that are used in customer or vendor payments."\
         " Select 'General' for miscellaneous operations journals."\
         " Select 'Opening/Closing Situation' for entries generated for new fiscal years.")
-    type_control_ids = fields.Many2many('account.account.type', 'account_journal_type_rel', 'journal_id', 'type_id', string='Account Types Allowed (empty for no control)')
-    account_control_ids = fields.Many2many('account.account', 'account_account_type_rel', 'journal_id', 'account_id', string='Accounts Allowed (empty for no control)',
+    type_control_ids = fields.Many2many('account.account.type', 'account_journal_type_rel', 'journal_id', 'type_id', string='Account Types Allowed')
+    account_control_ids = fields.Many2many('account.account', 'account_account_type_rel', 'journal_id', 'account_id', string='Accounts Allowed',
         domain=[('deprecated', '=', False)])
     default_credit_account_id = fields.Many2one('account.account', string='Default Credit Account',
         domain=[('deprecated', '=', False)], help="It acts as a default account for credit amount")
@@ -229,11 +228,11 @@ class AccountJournal(models.Model):
     refund_sequence = fields.Boolean(string='Dedicated Refund Sequence', help="Check this box if you don't want to share the same sequence for invoices and refunds made from this journal")
 
     inbound_payment_method_ids = fields.Many2many('account.payment.method', 'account_journal_inbound_payment_method_rel', 'journal_id', 'inbound_payment_method',
-        domain=[('payment_type', '=', 'inbound')], string='Inbound Payment Methods', default=lambda self: self._default_inbound_payment_methods(),
+        domain=[('payment_type', '=', 'inbound')], string='Debit Methods', default=lambda self: self._default_inbound_payment_methods(),
         help="Means of payment for collecting money. Odoo modules offer various payments handling facilities, "
              "but you can always use the 'Manual' payment method in order to manage payments outside of the software.")
     outbound_payment_method_ids = fields.Many2many('account.payment.method', 'account_journal_outbound_payment_method_rel', 'journal_id', 'outbound_payment_method',
-        domain=[('payment_type', '=', 'outbound')], string='Outbound Payment Methods', default=lambda self: self._default_outbound_payment_methods(),
+        domain=[('payment_type', '=', 'outbound')], string='Payment Methods', default=lambda self: self._default_outbound_payment_methods(),
         help="Means of payment for sending money. Odoo modules offer various payments handling facilities, "
              "but you can always use the 'Manual' payment method in order to manage payments outside of the software.")
     at_least_one_inbound = fields.Boolean(compute='_methods_compute', store=True)
@@ -445,13 +444,13 @@ class AccountTax(models.Model):
         help="Account that will be set on invoice tax lines for invoices. Leave empty to use the expense account.", oldname='account_collected_id')
     refund_account_id = fields.Many2one('account.account', domain=[('deprecated', '=', False)], string='Tax Account on Refunds', ondelete='restrict',
         help="Account that will be set on invoice tax lines for refunds. Leave empty to use the expense account.", oldname='account_paid_id')
-    description = fields.Char(string='Text on Invoices')
+    description = fields.Char(string='Label on Invoices')
     price_include = fields.Boolean(string='Included in Price', default=False,
         help="Check this if the price you use on the product and invoices includes this tax.")
-    include_base_amount = fields.Boolean(string='Affect Subsequent Taxes', default=False,
+    include_base_amount = fields.Boolean(string='Affect Base of Subsequent Taxes', default=False,
         help="If set, taxes which are computed after this one will be computed based on the price tax included.")
-    analytic = fields.Boolean(string="Analytic Cost", help="If set, the amount computed by this tax will be assigned to the same analytic account as the invoice line (if any)")
-    tag_ids = fields.Many2many('account.account.tag', 'account_tax_account_tag', string='Account tag', help="Optional tags you may want to assign for custom reporting")
+    analytic = fields.Boolean(string="Include in Analytic Cost", help="If set, the amount computed by this tax will be assigned to the same analytic account as the invoice line (if any)")
+    tag_ids = fields.Many2many('account.account.tag', 'account_tax_account_tag', string='Tags', help="Optional tags you may want to assign for custom reporting")
 
     _sql_constraints = [
         ('name_company_uniq', 'unique(name, company_id)', 'Tax names must be unique !'),

--- a/addons/account/models/account_bank_statement.py
+++ b/addons/account/models/account_bank_statement.py
@@ -331,7 +331,7 @@ class AccountBankStatementLine(models.Model):
     _order = "statement_id desc, sequence"
     _inherit = ['ir.needaction_mixin']
 
-    name = fields.Char(string='Communication', required=True)
+    name = fields.Char(string='Memo', required=True)
     date = fields.Date(required=True, default=lambda self: self._context.get('date', fields.Date.context_today(self)))
     amount = fields.Monetary(digits=0, currency_field='journal_currency_id')
     journal_currency_id = fields.Many2one('res.currency', related='journal_id.currency_id',

--- a/addons/account/models/account_invoice.py
+++ b/addons/account/models/account_invoice.py
@@ -112,10 +112,10 @@ class AccountInvoice(models.Model):
             domain = [('journal_id.type', 'in', ('bank', 'cash')), ('account_id', '=', self.account_id.id), ('partner_id', '=', self.partner_id.id), ('reconciled', '=', False), ('amount_residual', '!=', 0.0)]
             if self.type in ('out_invoice', 'in_refund'):
                 domain.extend([('credit', '>', 0), ('debit', '=', 0)])
-                type_payment = _('Outstanding credit from %s')
+                type_payment = _('Outstanding credits')
             else:
                 domain.extend([('credit', '=', 0), ('debit', '>', 0)])
-                type_payment = _('Outstanding debit from %s')
+                type_payment = _('Outstanding debits')
             info = {'title': '', 'outstanding': True, 'content': [], 'invoice_id': self.id}
             lines = self.env['account.move.line'].search(domain)
             if len(lines) != 0:
@@ -133,7 +133,7 @@ class AccountInvoice(models.Model):
                         'position': self.currency_id.position,
                         'digits': [69, self.currency_id.decimal_places],
                     })
-                info['title'] = type_payment % line.partner_id.name
+                info['title'] = type_payment
                 self.outstanding_credits_debits_widget = json.dumps(info)
                 self.has_outstanding = True
 
@@ -1198,7 +1198,7 @@ class AccountPaymentTerm(models.Model):
 
     name = fields.Char(string='Payment Term', translate=True, required=True)
     active = fields.Boolean(default=True, help="If the active field is set to False, it will allow you to hide the payment term without removing it.")
-    note = fields.Text(string='Description', translate=True)
+    note = fields.Text(string='Description on the Invoice', translate=True)
     line_ids = fields.One2many('account.payment.term.line', 'payment_id', string='Terms', copy=True)
     company_id = fields.Many2one('res.company', string='Company', required=True, default=lambda self: self.env.user.company_id)
 
@@ -1248,9 +1248,9 @@ class AccountPaymentTermLine(models.Model):
             ('balance', 'Balance'),
             ('percent', 'Percent'),
             ('fixed', 'Fixed Amount')
-        ], string='Computation', required=True, default='balance',
+        ], string='Type', required=True, default='balance',
         help="Select here the kind of valuation related to this payment term line.")
-    value_amount = fields.Float(string='Amount To Pay', digits=dp.get_precision('Payment Term'), help="For percent enter a ratio between 0-100.")
+    value_amount = fields.Float(string='Value', digits=dp.get_precision('Payment Term'), help="For percent enter a ratio between 0-100.")
     days = fields.Integer(string='Number of Days', required=True, default=30, help="Number of days to add before computing the day of the month.")
     days2 = fields.Integer(string='Day of the Month', required=True, default='0',
         help="Day of the month \n\n Set : \n1)-1 for the last day of the current month. \n2) 0 for net days\n3) A positive number for the specific day of the next month.\n\nExample : if Date=15/01, Number of Days=22, Day of Month=-1, then the due date is 28/02.")

--- a/addons/account/models/account_move.py
+++ b/addons/account/models/account_move.py
@@ -64,10 +64,15 @@ class AccountMove(models.Model):
     def _compute_currency(self):
         self.currency_id = self.company_id.currency_id or self.env.user.company_id.currency_id
 
+    @api.multi
+    def _get_default_journal(self):
+        if self.env.context.get('default_journal_type'):
+            return self.env['account.journal'].search([('type', '=', self.env.context['default_journal_type'])], limit=1).id
+
     name = fields.Char(string='Number', required=True, copy=False, default='/')
-    ref = fields.Char(string='Partner Reference', copy=False)
+    ref = fields.Char(string='Reference', copy=False)
     date = fields.Date(required=True, states={'posted': [('readonly', True)]}, index=True, default=fields.Date.context_today)
-    journal_id = fields.Many2one('account.journal', string='Journal', required=True, states={'posted': [('readonly', True)]})
+    journal_id = fields.Many2one('account.journal', string='Journal', required=True, states={'posted': [('readonly', True)]}, default=_get_default_journal)
     currency_id = fields.Many2one('res.currency', compute='_compute_currency', store=True)
     rate_diff_partial_rec_id = fields.Many2one('account.partial.reconcile', string='Exchange Rate Entry of', help="Technical field used to keep track of the origin of journal entries created in case of fluctuation of the currency exchange rate. This is needed when cancelling the source: it will post the inverse journal entry to cancel that part too.")
     state = fields.Selection([('draft', 'Unposted'), ('posted', 'Posted')], string='Status',
@@ -86,7 +91,6 @@ class AccountMove(models.Model):
         default=lambda self: self.env.user.company_id)
     matched_percentage = fields.Float('Percentage Matched', compute='_compute_matched_percentage', digits=0, store=True, readonly=True, help="Technical field used in cash basis method")
     statement_line_id = fields.Many2one('account.bank.statement.line', string='Bank statement line reconciled with this entry', copy=False, readonly=True)
-    to_check = fields.Boolean('To Review', help='Check this box if you are unsure of that journal entry and if you want to note it as \'to be reviewed\' by an accounting expert.')
 
     @api.model
     def create(self, vals):
@@ -187,6 +191,7 @@ class AccountMove(models.Model):
     @api.multi
     def reverse_moves(self, date=None, journal_id=None):
         date = date or fields.Date.today()
+        reversed_moves = self.env['account.move']
         for ac_move in self:
             reversed_move = ac_move.copy(default={'date': date,
                 'journal_id': journal_id.id if journal_id else ac_move.journal_id.id,
@@ -197,8 +202,11 @@ class AccountMove(models.Model):
                     'credit': acm_line.debit,
                     'amount_currency': -acm_line.amount_currency
                     })
-            reversed_move._post_validate()
-            reversed_move.post()
+            reversed_moves |= reversed_move
+        if reversed_moves:
+            reversed_moves._post_validate()
+            reversed_moves.post()
+            return [x.id for x in reversed_moves]
         return True
 
 
@@ -233,7 +241,7 @@ class AccountMoveLine(models.Model):
             #we can only check the amount in company currency
             reconciled = False
             digits_rounding_precision = line.company_id.currency_id.rounding
-            if float_is_zero(amount, digits_rounding_precision):
+            if float_is_zero(amount, digits_rounding_precision) and (line.debit or line.credit):
                 reconciled = True
             line.reconciled = reconciled
 

--- a/addons/account/models/chart_template.py
+++ b/addons/account/models/chart_template.py
@@ -173,10 +173,10 @@ class AccountChartTemplate(models.Model):
                     default_account = acc_template_ref.get(self.expense_currency_exchange_account_id.id)
             return default_account
 
-        journals = [{'name': _('Customer Invoices'), 'type': 'sale', 'code': _('INV'), 'favorite': True},
-                    {'name': _('Vendor Bills'), 'type': 'purchase', 'code': _('EXJ'), 'favorite': True},
-                    {'name': _('Exchange Rate Journal'), 'type': 'general', 'code': _('EXCH'), 'favorite': False},
-                    {'name': _('Miscellaneous Journal'), 'type': 'general', 'code': _('MISC'), 'favorite': False},]
+        journals = [{'name': _('Customer Invoices'), 'type': 'sale', 'code': _('INV'), 'favorite': True, 'sequence': 5},
+                    {'name': _('Vendor Bills'), 'type': 'purchase', 'code': _('EXJ'), 'favorite': True, 'sequence': 6},
+                    {'name': _('Miscellaneous Operations'), 'type': 'general', 'code': _('MISC'), 'favorite': False, 'sequence': 7},
+                    {'name': _('Exchange Difference'), 'type': 'general', 'code': _('EXCH'), 'favorite': False, 'sequence': 9},]
         if journals_dict != None:
             journals.extend(journals_dict)
 

--- a/addons/account/models/partner.py
+++ b/addons/account/models/partner.py
@@ -23,7 +23,7 @@ class AccountFiscalPosition(models.Model):
     account_ids = fields.One2many('account.fiscal.position.account', 'position_id', string='Account Mapping', copy=True)
     tax_ids = fields.One2many('account.fiscal.position.tax', 'position_id', string='Tax Mapping', copy=True)
     note = fields.Text('Notes')
-    auto_apply = fields.Boolean(string='Automatic', help="Apply automatically this fiscal position.")
+    auto_apply = fields.Boolean(string='Detect Automatically', help="Apply automatically this fiscal position.")
     vat_required = fields.Boolean(string='VAT required', help="Apply only if partner has a VAT number.")
     country_id = fields.Many2one('res.country', string='Countries',
         help="Apply only if delivery or invoicing country match.")
@@ -143,8 +143,8 @@ class AccountFiscalPositionTax(models.Model):
 
     position_id = fields.Many2one('account.fiscal.position', string='Fiscal Position',
         required=True, ondelete='cascade')
-    tax_src_id = fields.Many2one('account.tax', string='Tax Source', required=True)
-    tax_dest_id = fields.Many2one('account.tax', string='Replacement Tax')
+    tax_src_id = fields.Many2one('account.tax', string='Tax on Product', required=True)
+    tax_dest_id = fields.Many2one('account.tax', string='Tax to Apply')
 
     _sql_constraints = [
         ('tax_src_dest_uniq',
@@ -160,9 +160,9 @@ class AccountFiscalPositionAccount(models.Model):
 
     position_id = fields.Many2one('account.fiscal.position', string='Fiscal Position',
         required=True, ondelete='cascade')
-    account_src_id = fields.Many2one('account.account', string='Account Source',
+    account_src_id = fields.Many2one('account.account', string='Account on Product',
         domain=[('deprecated', '=', False)], required=True)
-    account_dest_id = fields.Many2one('account.account', string='Account Destination',
+    account_dest_id = fields.Many2one('account.account', string='Account to Use Instead',
         domain=[('deprecated', '=', False)], required=True)
 
     _sql_constraints = [
