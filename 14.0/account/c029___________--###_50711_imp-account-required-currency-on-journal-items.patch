PR: https://github.com/odoo/odoo/pull/50711

From: 419d4bbee04763367fef675a01dc73afa9758b2f
From: Laurent Smet
Date: 2020-08-13 11:48:06

Structural Changes: 7
Total Changes: 547

[IMP] account, *: Required currency on journal items

closes odoo/odoo#50711

Task: 1930680
Related: odoo/enterprise#10394
Related: odoo/upgrade#1147
Signed-off-by: Cedric Snauwaert (csn) <csn@openerp.com>

================================= pseudo patch: =================================

--- a/addons/account/models/account_bank_statement.py
+++ b/addons/account/models/account_bank_statement.py
@@ -566,23 +566,18 @@ class AccountBankStatementLine(models.Model):
                 balance = self.amount_currency
             else:
                 amount_currency = self.amount
-                balance = journal_currency._convert(amount_currency, journal.company_id.currency_id, journal.company_id, self.date)
+                balance = journal_currency._convert(amount_currency, company_currency, journal.company_id, self.date)
         elif self.foreign_currency_id and not journal_currency:
-            if self.foreign_currency_id == company_currency:
-                amount_currency = 0.0
-                balance = self.amount
-                currency_id = False
-            else:
-                amount_currency = self.amount_currency
-                balance = self.amount
-                currency_id = self.foreign_currency_id.id
+            amount_currency = self.amount_currency
+            balance = self.amount
+            currency_id = self.foreign_currency_id.id
         elif not self.foreign_currency_id and journal_currency:
             currency_id = journal_currency.id
             amount_currency = self.amount
             balance = journal_currency._convert(amount_currency, journal.company_id.currency_id, journal.company_id, self.date)
         else:
-            currency_id = False
-            amount_currency = 0.0
+            currency_id = company_currency.id
+            amount_currency = self.amount
             balance = self.amount
 
         return {
@@ -685,8 +680,8 @@ class AccountBankStatementLine(models.Model):
             amount_currency = amounts[journal_currency.id]
             currency_id = journal_currency.id
         else:
-            amount_currency = 0.0
-            currency_id = False
+            amount_currency = amounts[company_currency.id]
+            currency_id = company_currency.id
 
         return {
             **counterpart_vals,
@@ -695,8 +690,8 @@ class AccountBankStatementLine(models.Model):
             'partner_id': self.partner_id.id,
             'currency_id': currency_id,
             'account_id': counterpart_vals.get('account_id', move_line.account_id.id if move_line else False),
-            'debit': balance if balance > 0 else 0.0,
-            'credit': -balance if balance < 0 else 0.0,
+            'debit': balance if balance > 0.0 else 0.0,
+            'credit': -balance if balance < 0.0 else 0.0,
             'amount_currency': amount_currency,
         }
 
@@ -718,6 +713,12 @@ class AccountBankStatementLine(models.Model):
 
         liquidity_line_vals = self._prepare_liquidity_move_line_vals()
 
+        # Ensure the counterpart will have a balance exactly equals to the amount in journal currency.
+        # This avoid some rounding issues when the currency rate between two currencies is not symmetrical.
+        # E.g:
+        # A.convert(amount_a, B) = amount_b
+        # B.convert(amount_b, A) = amount_c != amount_a
+
         counterpart_vals = {
             'name': self.payment_ref,
             'account_id': counterpart_account_id,
@@ -772,15 +773,12 @@ class AccountBankStatementLine(models.Model):
                 st_line.is_reconciled = True
 
             # Compute residual amount
-            st_line_currency = suspense_lines.currency_id or suspense_lines.company_currency_id
-            balance_field, residual_field = ('amount_currency', 'amount_residual_currency') if suspense_lines.currency_id else ('balance', 'amount_residual')
-
             if st_line.to_check:
                 st_line.amount_residual = -st_line.amount_currency if st_line.foreign_currency_id else -st_line.amount
             elif suspense_lines.account_id.reconcile:
-                st_line.amount_residual = sum(suspense_lines.mapped(residual_field))
+                st_line.amount_residual = sum(suspense_lines.mapped('amount_residual_currency'))
             else:
-                st_line.amount_residual = sum(suspense_lines.mapped(balance_field))
+                st_line.amount_residual = sum(suspense_lines.mapped('amount_currency'))
 
     # -------------------------------------------------------------------------
     # CONSTRAINT METHODS
@@ -921,14 +919,13 @@ class AccountBankStatementLine(models.Model):
                             'foreign_currency_id': False,
                         })
 
-                    elif not suspense_lines.currency_id and st_line.foreign_currency_id == company_currency:
+                    elif not journal_currency and suspense_lines.currency_id == company_currency:
 
-                        # The suspense line has no foreign currency because the foreign currency set on the
-                        # statement line is the same as the company one. In that case, don't erase the
-                        # 'foreign_currency_id' field.
+                        # Don't set a specific foreign currency on the statement line.
 
                         st_line_vals_to_write.update({
-                            'amount_currency': -suspense_lines.balance,
+                            'amount_currency': 0.0,
+                            'foreign_currency_id': False,
                         })
 
                     else:
@@ -1121,7 +1118,7 @@ class AccountBankStatementLine(models.Model):
                 'name': '%s: %s' % (self.payment_ref, _('Open Balance')),
                 'account_id': open_balance_account.id,
                 'balance': -total_balance,
-                'currency_id': False,
+                'currency_id': self.company_currency_id.id,
             })
         else:
             open_balance_vals = None

--- a/addons/account/models/account_move.py
+++ b/addons/account/models/account_move.py
@@ -418,18 +418,15 @@ class AccountMove(models.Model):
 
     @api.onchange('date', 'currency_id')
     def _onchange_currency(self):
-        if not self.currency_id:
-            return
-        if self.is_invoice(include_receipts=True):
-            company_currency = self.company_id.currency_id
-            has_foreign_currency = self.currency_id and self.currency_id != company_currency
+        currency = self.currency_id or self.company_id.currency_id
 
+        if self.is_invoice(include_receipts=True):
             for line in self._get_lines_onchange_currency():
-                new_currency = has_foreign_currency and self.currency_id
-                line.currency_id = new_currency
+                line.currency_id = currency
                 line._onchange_currency()
         else:
-            self.line_ids._onchange_currency()
+            for line in self.line_ids:
+                line._onchange_currency()
 
         self._recompute_dynamic_lines(recompute_tax_base_amount=True)
 
@@ -548,25 +545,18 @@ class AccountMove(models.Model):
                 handle_price_include = True
                 sign = -1 if move.is_inbound() else 1
                 quantity = base_line.quantity
-                if base_line.currency_id:
-                    price_unit_foreign_curr = sign * base_line.price_unit * (1 - (base_line.discount / 100.0))
-                    price_unit_comp_curr = base_line.currency_id._convert(price_unit_foreign_curr, move.company_id.currency_id, move.company_id, move.date)
-                else:
-                    price_unit_foreign_curr = 0.0
-                    price_unit_comp_curr = sign * base_line.price_unit * (1 - (base_line.discount / 100.0))
-                tax_type = 'sale' if move.move_type.startswith('out_') else 'purchase'
                 is_refund = move.move_type in ('out_refund', 'in_refund')
+                price_unit_wo_discount = sign * base_line.price_unit * (1 - (base_line.discount / 100.0))
             else:
                 handle_price_include = False
                 quantity = 1.0
-                price_unit_foreign_curr = base_line.amount_currency
-                price_unit_comp_curr = base_line.balance
                 tax_type = base_line.tax_ids[0].type_tax_use if base_line.tax_ids else None
                 is_refund = (tax_type == 'sale' and base_line.debit) or (tax_type == 'purchase' and base_line.credit)
+                price_unit_wo_discount = base_line.balance
 
             balance_taxes_res = base_line.tax_ids._origin.compute_all(
-                price_unit_comp_curr,
-                currency=base_line.company_currency_id,
+                price_unit_wo_discount,
+                currency=base_line.currency_id,
                 quantity=quantity,
                 product=base_line.product_id,
                 partner=base_line.partner_id,
@@ -583,36 +573,6 @@ class AccountMove(models.Model):
                     for tax_res in balance_taxes_res['taxes']:
                         tax_res['tag_ids'] = base_line._revert_signed_tags(self.env['account.account.tag'].browse(tax_res['tag_ids'])).ids
 
-            if base_line.currency_id:
-                # Multi-currencies mode: Taxes are computed both in company's currency / foreign currency.
-                amount_currency_taxes_res = base_line.tax_ids._origin.compute_all(
-                    price_unit_foreign_curr,
-                    currency=base_line.currency_id,
-                    quantity=quantity,
-                    product=base_line.product_id,
-                    partner=base_line.partner_id,
-                    is_refund=is_refund,
-                    handle_price_include=handle_price_include,
-                )
-
-                if move.move_type == 'entry':
-                    repartition_field = is_refund and 'refund_repartition_line_ids' or 'invoice_repartition_line_ids'
-                    repartition_tags = base_line.tax_ids.mapped(repartition_field).filtered(lambda x: x.repartition_type == 'base').tag_ids
-                    tags_need_inversion = (tax_type == 'sale' and not is_refund) or (tax_type == 'purchase' and is_refund)
-                    if tags_need_inversion:
-                        balance_taxes_res['base_tags'] = base_line._revert_signed_tags(repartition_tags).ids
-                        for tax_res in balance_taxes_res['taxes']:
-                            tax_res['tag_ids'] = base_line._revert_signed_tags(self.env['account.account.tag'].browse(tax_res['tag_ids'])).ids
-
-                for b_tax_res, ac_tax_res in zip(balance_taxes_res['taxes'], amount_currency_taxes_res['taxes']):
-                    tax = self.env['account.tax'].browse(b_tax_res['id'])
-                    b_tax_res['amount_currency'] = ac_tax_res['amount']
-
-                    # A tax having a fixed amount must be converted into the company currency when dealing with a
-                    # foreign currency.
-                    if tax.amount_type == 'fixed':
-                        b_tax_res['amount'] = base_line.currency_id._convert(b_tax_res['amount'], move.company_id.currency_id, move.company_id, move.date)
-
             return balance_taxes_res
 
         taxes_map = {}
@@ -629,8 +589,7 @@ class AccountMove(models.Model):
             else:
                 taxes_map[grouping_key] = {
                     'tax_line': line,
-                    'balance': 0.0,
-                    'amount_currency': 0.0,
+                    'amount': 0.0,
                     'tax_base_amount': 0.0,
                     'grouping_dict': False,
                 }
@@ -661,56 +620,66 @@ class AccountMove(models.Model):
 
                 taxes_map_entry = taxes_map.setdefault(grouping_key, {
                     'tax_line': None,
-                    'balance': 0.0,
-                    'amount_currency': 0.0,
+                    'amount': 0.0,
                     'tax_base_amount': 0.0,
                     'grouping_dict': False,
                 })
-                taxes_map_entry['balance'] += tax_vals['amount']
-                taxes_map_entry['amount_currency'] += tax_vals.get('amount_currency', 0.0)
+                taxes_map_entry['amount'] += tax_vals['amount']
                 taxes_map_entry['tax_base_amount'] += tax_vals['base']
                 taxes_map_entry['grouping_dict'] = grouping_dict
             line.tax_exigible = tax_exigible
 
         # ==== Process taxes_map ====
         for taxes_map_entry in taxes_map.values():
+            # The tax line is no longer used in any base lines, drop it.
+            if taxes_map_entry['tax_line'] and not taxes_map_entry['grouping_dict']:
+                self.line_ids -= taxes_map_entry['tax_line']
+                continue
+
+            currency = self.env['res.currency'].browse(taxes_map_entry['grouping_dict']['currency_id'])
+
             # Don't create tax lines with zero balance.
-            if self.currency_id.is_zero(taxes_map_entry['balance']) and self.currency_id.is_zero(taxes_map_entry['amount_currency']):
-                taxes_map_entry['grouping_dict'] = False
+            if currency.is_zero(taxes_map_entry['amount']):
+                if taxes_map_entry['tax_line']:
+                    self.line_ids -= taxes_map_entry['tax_line']
+                continue
 
-            tax_line = taxes_map_entry['tax_line']
-            tax_base_amount = -taxes_map_entry['tax_base_amount'] if self.is_inbound() else taxes_map_entry['tax_base_amount']
+            tax_base_amount = (-1 if self.is_inbound() else 1) * taxes_map_entry['tax_base_amount']
 
-            if not tax_line and not taxes_map_entry['grouping_dict']:
+            # Recompute only the tax_base_amount.
+            if taxes_map_entry['tax_line'] and recompute_tax_base_amount:
+                taxes_map_entry['tax_line'].tax_base_amount = tax_base_amount
                 continue
-            elif tax_line and recompute_tax_base_amount:
-                tax_line.tax_base_amount = tax_base_amount
-            elif tax_line and not taxes_map_entry['grouping_dict']:
-                # The tax line is no longer used, drop it.
-                self.line_ids -= tax_line
-            elif tax_line:
-                tax_line.update({
-                    'amount_currency': taxes_map_entry['amount_currency'],
-                    'debit': taxes_map_entry['balance'] > 0.0 and taxes_map_entry['balance'] or 0.0,
-                    'credit': taxes_map_entry['balance'] < 0.0 and -taxes_map_entry['balance'] or 0.0,
-                    'tax_base_amount': tax_base_amount,
-                })
+
+            balance = currency._convert(
+                taxes_map_entry['amount'],
+                self.journal_id.company_id.currency_id,
+                self.journal_id.company_id,
+                self.date or fields.Date.context_today(self),
+            )
+            to_write_on_line = {
+                'amount_currency': taxes_map_entry['amount'],
+                'currency_id': taxes_map_entry['grouping_dict']['currency_id'],
+                'debit': balance > 0.0 and balance or 0.0,
+                'credit': balance < 0.0 and -balance or 0.0,
+                'tax_base_amount': tax_base_amount,
+            }
+
+            if taxes_map_entry['tax_line']:
+                # Update an existing tax line.
+                taxes_map_entry['tax_line'].update(to_write_on_line)
             else:
                 create_method = in_draft_mode and self.env['account.move.line'].new or self.env['account.move.line'].create
                 tax_repartition_line_id = taxes_map_entry['grouping_dict']['tax_repartition_line_id']
                 tax_repartition_line = self.env['account.tax.repartition.line'].browse(tax_repartition_line_id)
                 tax = tax_repartition_line.invoice_tax_id or tax_repartition_line.refund_tax_id
-                tax_line = create_method({
+                taxes_map_entry['tax_line'] = create_method({
+                    **to_write_on_line,
                     'name': tax.name,
                     'move_id': self.id,
                     'partner_id': line.partner_id.id,
                     'company_id': line.company_id.id,
                     'company_currency_id': line.company_currency_id.id,
-                    'quantity': 1.0,
-                    'date_maturity': False,
-                    'amount_currency': taxes_map_entry['amount_currency'],
-                    'debit': taxes_map_entry['balance'] > 0.0 and taxes_map_entry['balance'] or 0.0,
-                    'credit': taxes_map_entry['balance'] < 0.0 and -taxes_map_entry['balance'] or 0.0,
                     'tax_base_amount': tax_base_amount,
                     'exclude_from_invoice_tab': True,
                     'tax_exigible': tax.tax_exigibility == 'on_invoice',
@@ -718,8 +687,7 @@ class AccountMove(models.Model):
                 })
 
             if in_draft_mode:
-                tax_line._onchange_amount_currency()
-                tax_line._onchange_balance()
+                taxes_map_entry['tax_line'].update(taxes_map_entry['tax_line']._get_fields_onchange_balance())
 
     def _recompute_cash_rounding_lines(self):
         ''' Handle the cash rounding feature on invoices.
@@ -737,18 +705,17 @@ class AccountMove(models.Model):
         self.ensure_one()
         in_draft_mode = self != self._origin
 
-        def _compute_cash_rounding(self, total_balance, total_amount_currency):
+        def _compute_cash_rounding(self, total_amount_currency):
             ''' Compute the amount differences due to the cash rounding.
             :param self:                    The current account.move record.
-            :param total_balance:           The invoice's total in company's currency.
             :param total_amount_currency:   The invoice's total in invoice's currency.
             :return:                        The amount differences both in company's currency & invoice's currency.
             '''
+            difference = self.invoice_cash_rounding_id.compute_difference(self.currency_id, total_amount_currency)
             if self.currency_id == self.company_id.currency_id:
-                diff_balance = self.invoice_cash_rounding_id.compute_difference(self.currency_id, total_balance)
-                diff_amount_currency = 0.0
+                diff_amount_currency = diff_balance = difference
             else:
-                diff_amount_currency = self.invoice_cash_rounding_id.compute_difference(self.currency_id, total_amount_currency)
+                diff_amount_currency = difference
                 diff_balance = self.currency_id._convert(diff_amount_currency, self.company_id.currency_id, self.company_id, self.date)
             return diff_balance, diff_amount_currency
 
@@ -767,7 +734,7 @@ class AccountMove(models.Model):
                 'amount_currency': diff_amount_currency,
                 'partner_id': self.partner_id.id,
                 'move_id': self.id,
-                'currency_id': self.currency_id if self.currency_id != self.company_id.currency_id else False,
+                'currency_id': self.currency_id,
                 'company_id': self.company_id.id,
                 'company_currency_id': self.company_id.currency_id.id,
                 'is_rounding_line': True,
@@ -815,8 +782,7 @@ class AccountMove(models.Model):
                 cash_rounding_line = create_method(rounding_line_vals)
 
             if in_draft_mode:
-                cash_rounding_line._onchange_amount_currency()
-                cash_rounding_line._onchange_balance()
+                cash_rounding_line.update(cash_rounding_line._get_fields_onchange_balance())
 
         existing_cash_rounding_line = self.line_ids.filtered(lambda line: line.is_rounding_line)
 
@@ -835,10 +801,9 @@ class AccountMove(models.Model):
 
         others_lines = self.line_ids.filtered(lambda line: line.account_id.user_type_id.type not in ('receivable', 'payable'))
         others_lines -= existing_cash_rounding_line
-        total_balance = sum(others_lines.mapped('balance'))
         total_amount_currency = sum(others_lines.mapped('amount_currency'))
 
-        diff_balance, diff_amount_currency = _compute_cash_rounding(self, total_balance, total_amount_currency)
+        diff_balance, diff_amount_currency = _compute_cash_rounding(self, total_amount_currency)
 
         # The invoice is already rounded.
         if self.currency_id.is_zero(diff_balance) and self.currency_id.is_zero(diff_amount_currency):
@@ -898,13 +863,13 @@ class AccountMove(models.Model):
             '''
             if self.invoice_payment_term_id:
                 to_compute = self.invoice_payment_term_id.compute(total_balance, date_ref=date, currency=self.currency_id)
-                if self.currency_id != self.company_id.currency_id:
+                if self.currency_id == self.company_id.currency_id:
+                    # Single-currency.
+                    return [(b[0], b[1], b[1]) for b in to_compute]
+                else:
                     # Multi-currencies.
                     to_compute_currency = self.invoice_payment_term_id.compute(total_amount_currency, date_ref=date, currency=self.currency_id)
                     return [(b[0], b[1], ac[1]) for b, ac in zip(to_compute, to_compute_currency)]
-                else:
-                    # Single-currency.
-                    return [(b[0], b[1], 0.0) for b in to_compute]
             else:
                 return [(fields.Date.to_string(date), total_balance, total_amount_currency)]
 
@@ -946,15 +911,14 @@ class AccountMove(models.Model):
                         'amount_currency': -amount_currency,
                         'date_maturity': date_maturity,
                         'move_id': self.id,
-                        'currency_id': self.currency_id.id if self.currency_id != self.company_id.currency_id else False,
+                        'currency_id': self.currency_id.id,
                         'account_id': account.id,
                         'partner_id': self.commercial_partner_id.id,
                         'exclude_from_invoice_tab': True,
                     })
                 new_terms_lines += candidate
                 if in_draft_mode:
-                    candidate._onchange_amount_currency()
-                    candidate._onchange_balance()
+                    candidate.update(candidate._get_fields_onchange_balance())
             return new_terms_lines
 
         existing_terms_lines = self.line_ids.filtered(lambda line: line.account_id.user_type_id.type in ('receivable', 'payable'))
@@ -1330,17 +1294,12 @@ class AccountMove(models.Model):
                 domain.append(('balance', '>', 0.0))
                 payments_widget_vals['title'] = _('Outstanding debits')
 
-            if move.currency_id == move.company_currency_id:
-                currency = False
-            else:
-                currency = move.currency_id
-
             for line in self.env['account.move.line'].search(domain):
 
-                if currency and line.currency_id == currency:
+                if line.currency_id == move.currency_id:
                     # Same foreign currency.
                     amount = abs(line.amount_residual_currency)
-                elif currency:
+                else:
                     # Different foreign currencies.
                     amount = move.company_currency_id._convert(
                         abs(line.amount_residual),
@@ -1348,9 +1307,6 @@ class AccountMove(models.Model):
                         move.company_id,
                         line.date,
                     )
-                else:
-                    # Company's currency.
-                    amount = abs(line.amount_residual)
 
                 if move.currency_id.is_zero(amount):
                     continue
@@ -1610,7 +1566,6 @@ class AccountMove(models.Model):
         '''
         self.ensure_one()
 
-        line_currency = self.currency_id if self.currency_id != self.company_id.currency_id else False
         for line in self.line_ids:
             # Do something only on invoice lines.
             if line.exclude_from_invoice_tab:
@@ -1634,7 +1589,7 @@ class AccountMove(models.Model):
             line.partner_id = self.partner_id
             line.date = self.date
             line.recompute_tax_line = True
-            line.currency_id = line_currency
+            line.currency_id = self.currency_id
 
 
         self.line_ids._onchange_price_subtotal()
@@ -1678,6 +1633,8 @@ class AccountMove(models.Model):
                 vals['date'] = vals['invoice_date']
 
             ctx_vals = {'default_move_type': vals.get('move_type') or self._context.get('default_move_type')}
+            if vals.get('currency_id'):
+                ctx_vals['default_currency_id'] = vals['currency_id']
             if vals.get('journal_id'):
                 ctx_vals['default_journal_id'] = vals['journal_id']
                 # reorder the companies in the context so that the company of the journal
@@ -2769,15 +2726,15 @@ class AccountMoveLine(models.Model):
     amount_currency = fields.Monetary(string='Amount in Currency', store=True, copy=True,
         help="The amount expressed in an optional other currency if it is a multi-currency entry.")
     price_subtotal = fields.Monetary(string='Subtotal', store=True, readonly=True,
-        currency_field='always_set_currency_id')
+        currency_field='currency_id')
     price_total = fields.Monetary(string='Total', store=True, readonly=True,
-        currency_field='always_set_currency_id')
+        currency_field='currency_id')
     reconciled = fields.Boolean(compute='_compute_amount_residual', store=True)
     blocked = fields.Boolean(string='No Follow-up', default=False,
         help="You can check this box to mark this journal item as a litigation with the associated partner")
     date_maturity = fields.Date(string='Due Date', index=True, tracking=True,
         help="This field is used for payable and receivable journal entries. You can put the limit date for the payment of this line.")
-    currency_id = fields.Many2one('res.currency', string='Currency')
+    currency_id = fields.Many2one('res.currency', string='Currency', required=True)
     partner_id = fields.Many2one('res.partner', string='Partner', ondelete='restrict')
     product_uom_id = fields.Many2one('uom.uom', string='Unit of Measure', domain="[('category_id', '=', product_uom_category_id)]")
     product_id = fields.Many2one('product.product', string='Product')
@@ -2849,9 +2806,6 @@ class AccountMoveLine(models.Model):
     ], default=False, help="Technical field for UX purpose.")
     is_rounding_line = fields.Boolean(help="Technical field used to retrieve the cash rounding line.")
     exclude_from_invoice_tab = fields.Boolean(help="Technical field used to exclude some lines from the invoice_line_ids tab in the form view.")
-    always_set_currency_id = fields.Many2one('res.currency', string='Foreign Currency',
-        compute='_compute_always_set_currency_id',
-        help="Technical field used to compute the monetary field. As currency_id is not a required field, we need to use either the foreign currency, either the company one.")
 
     _sql_constraints = [
         (
@@ -2872,21 +2826,25 @@ class AccountMoveLine(models.Model):
         (
             'check_amount_currency_balance_sign',
             '''CHECK(
-                currency_id IS NULL
-                OR
-                company_currency_id IS NULL
-                OR
                 (
                     (currency_id != company_currency_id)
                     AND
                     (
-                        (balance > 0 AND amount_currency > 0)
-                        OR (balance <= 0 AND amount_currency <= 0)
-                        OR (balance >= 0 AND amount_currency >= 0)
+                        (debit - credit <= 0 AND amount_currency <= 0)
+                        OR
+                        (debit - credit >= 0 AND amount_currency >= 0)
                     )
                 )
+                OR
+                (
+                    currency_id = company_currency_id
+                    AND
+                    ROUND(debit - credit - amount_currency, 2) = 0
+                )                
             )''',
-            "The amount expressed in the secondary currency must be positive when account is debited and negative when account is credited. Moreover, the currency field has to be left empty when the amount is expressed in the company currency."
+            "The amount expressed in the secondary currency must be positive when account is debited and negative when "
+            "account is credited. If the currency is the same as the one from the company, this amount must strictly "
+            "be equal to the balance."
         ),
     ]
 
@@ -3108,30 +3066,22 @@ class AccountMoveLine(models.Model):
             sign = -1
         else:
             sign = 1
-        price_subtotal *= sign
 
-        if currency and currency != company.currency_id:
-            # Multi-currencies.
-            balance = currency._convert(price_subtotal, company.currency_id, company, date)
-            return {
-                'amount_currency': price_subtotal,
-                'debit': balance > 0.0 and balance or 0.0,
-                'credit': balance < 0.0 and -balance or 0.0,
-            }
-        else:
-            # Single-currency.
-            return {
-                'amount_currency': 0.0,
-                'debit': price_subtotal > 0.0 and price_subtotal or 0.0,
-                'credit': price_subtotal < 0.0 and -price_subtotal or 0.0,
-            }
+        amount_currency = price_subtotal * sign
+        balance = currency._convert(amount_currency, company.currency_id, company, date)
+        return {
+            'amount_currency': amount_currency,
+            'currency_id': currency.id,
+            'debit': balance > 0.0 and balance or 0.0,
+            'credit': balance < 0.0 and -balance or 0.0,
+        }
 
-    def _get_fields_onchange_balance(self, quantity=None, discount=None, balance=None, move_type=None, currency=None, taxes=None, price_subtotal=None):
+    def _get_fields_onchange_balance(self, quantity=None, discount=None, amount_currency=None, move_type=None, currency=None, taxes=None, price_subtotal=None):
         self.ensure_one()
         return self._get_fields_onchange_balance_model(
             quantity=quantity or self.quantity,
             discount=discount or self.discount,
-            balance=balance or self.balance,
+            amount_currency=amount_currency or self.amount_currency,
             move_type=move_type or self.move_id.move_type,
             currency=currency or self.currency_id or self.move_id.currency_id,
             taxes=taxes or self.tax_ids,
@@ -3139,7 +3089,7 @@ class AccountMoveLine(models.Model):
         )
 
     @api.model
-    def _get_fields_onchange_balance_model(self, quantity, discount, balance, move_type, currency, taxes, price_subtotal):
+    def _get_fields_onchange_balance_model(self, quantity, discount, amount_currency, move_type, currency, taxes, price_subtotal):
         ''' This method is used to recompute the values of 'quantity', 'discount', 'price_unit' due to a change made
         in some accounting fields such as 'balance'.
 
@@ -3148,7 +3098,7 @@ class AccountMoveLine(models.Model):
 
         :param quantity:        The current quantity.
         :param discount:        The current discount.
-        :param balance:         The new balance.
+        :param amount_currency: The new balance in line's currency.
         :param move_type:       The type of the move.
         :param currency:        The currency.
         :param taxes:           The applied taxes.
@@ -3161,14 +3111,14 @@ class AccountMoveLine(models.Model):
             sign = -1
         else:
             sign = 1
-        balance *= sign
+        amount_currency *= sign
 
         # Avoid rounding issue when dealing with price included taxes. For example, when the price_unit is 2300.0 and
         # a 5.5% price included tax is applied on it, a balance of 2300.0 / 1.055 = 2180.094 ~ 2180.09 is computed.
         # However, when triggering the inverse, 2180.09 + (2180.09 * 0.055) = 2180.09 + 119.90 = 2299.99 is computed.
         # To avoid that, set the price_subtotal at the balance if the difference between them looks like a rounding
         # issue.
-        if currency.is_zero(balance - price_subtotal):
+        if currency.is_zero(amount_currency - price_subtotal):
             return {}
 
         taxes = taxes.flatten_taxes_hierarchy()
@@ -3188,25 +3138,25 @@ class AccountMoveLine(models.Model):
             # 220           | 10% incl, 5%  |                   | 200               | 230
             # 20            |               | 10% incl          | 20                | 20
             # 10            |               | 5%                | 10                | 10
-            taxes_res = taxes._origin.compute_all(balance, currency=currency, handle_price_include=False)
+            taxes_res = taxes._origin.compute_all(amount_currency, currency=currency, handle_price_include=False)
             for tax_res in taxes_res['taxes']:
                 tax = self.env['account.tax'].browse(tax_res['id'])
                 if tax.price_include:
-                    balance += tax_res['amount']
+                    amount_currency += tax_res['amount']
 
         discount_factor = 1 - (discount / 100.0)
-        if balance and discount_factor:
+        if amount_currency and discount_factor:
             # discount != 100%
             vals = {
                 'quantity': quantity or 1.0,
-                'price_unit': balance / discount_factor / (quantity or 1.0),
+                'price_unit': amount_currency / discount_factor / (quantity or 1.0),
             }
-        elif balance and not discount_factor:
+        elif amount_currency and not discount_factor:
             # discount == 100%
             vals = {
                 'quantity': quantity or 1.0,
                 'discount': 0.0,
-                'price_unit': balance / (quantity or 1.0),
+                'price_unit': amount_currency / (quantity or 1.0),
             }
         elif not discount_factor:
             # balance of line is 0, but discount  == 100% so we display the normal unit_price
@@ -3261,8 +3211,8 @@ class AccountMoveLine(models.Model):
                 line.price_unit = line._get_price_total_and_subtotal()['price_subtotal']
                 line.tax_ids = line.move_id.fiscal_position_id.map_tax(line.tax_ids._origin, partner=line.move_id.partner_id)
                 accounting_vals = line._get_fields_onchange_subtotal(price_subtotal=line.price_unit, currency=line.move_id.company_currency_id)
-                balance = accounting_vals['debit'] - accounting_vals['credit']
-                line.price_unit = line._get_fields_onchange_balance(balance=balance).get('price_unit', line.price_unit)
+                amount_currency = accounting_vals['amount_currency']
+                line.price_unit = line._get_fields_onchange_balance(amount_currency=amount_currency).get('price_unit', line.price_unit)
 
             # Convert the unit price to the invoice's currency.
             company = line.move_id.company_id
@@ -3278,8 +3228,8 @@ class AccountMoveLine(models.Model):
         if taxes and self.move_id.fiscal_position_id:
             price_subtotal = self._get_price_total_and_subtotal(price_unit=price_unit, taxes=taxes)['price_subtotal']
             accounting_vals = self._get_fields_onchange_subtotal(price_subtotal=price_subtotal, currency=self.move_id.company_currency_id)
-            balance = accounting_vals['debit'] - accounting_vals['credit']
-            price_unit = self._get_fields_onchange_balance(balance=balance).get('price_unit', price_unit)
+            amount_currency = accounting_vals['amount_currency']
+            price_unit = self._get_fields_onchange_balance(amount_currency=amount_currency).get('price_unit', price_unit)
 
         # Convert the unit price to the invoice's currency.
         company = self.move_id.company_id
@@ -3300,12 +3250,13 @@ class AccountMoveLine(models.Model):
 
     def _onchange_balance(self):
         for line in self:
-            if line.currency_id:
+            if line.currency_id == line.move_id.company_id.currency_id:
+                line.amount_currency = line.balance
+            else:
                 continue
             if not line.move_id.is_invoice(include_receipts=True):
                 continue
             line.update(line._get_fields_onchange_balance())
-            line.update(line._get_price_total_and_subtotal())
 
     @api.onchange('debit')
     def _onchange_debit(self):
@@ -3322,14 +3273,15 @@ class AccountMoveLine(models.Model):
     @api.onchange('amount_currency')
     def _onchange_amount_currency(self):
         for line in self:
-            if not line.currency_id:
-                continue
+            company = line.move_id.company_id
+            balance = line.currency_id._convert(line.amount_currency, company.currency_id, company, line.move_id.date)
+            line.debit = balance if balance > 0.0 else 0.0
+            line.credit = -balance if balance < 0.0 else 0.0
+
             if not line.move_id.is_invoice(include_receipts=True):
-                line._recompute_debit_credit_from_amount_currency()
                 continue
-            line.update(line._get_fields_onchange_balance(
-                balance=line.amount_currency,
-            ))
+
+            line.update(line._get_fields_onchange_balance())
             line.update(line._get_price_total_and_subtotal())
 
     @api.onchange('quantity', 'discount', 'price_unit', 'tax_ids')
@@ -3344,21 +3296,15 @@ class AccountMoveLine(models.Model):
     @api.onchange('currency_id')
     def _onchange_currency(self):
         for line in self:
+            company = line.move_id.company_id
+
             if line.move_id.is_invoice(include_receipts=True):
                 line._onchange_price_subtotal()
             elif not line.move_id.reversed_entry_id:
-                line._recompute_debit_credit_from_amount_currency()
+                balance = line.currency_id._convert(line.amount_currency, company.currency_id, company, line.move_id.date or fields.Date.context_today(line))
+                line.debit = balance if balance > 0.0 else 0.0
+                line.credit = -balance if balance < 0.0 else 0.0
 
-    def _recompute_debit_credit_from_amount_currency(self):
-        for line in self:
-            # Recompute the debit/credit based on amount_currency/currency_id and date.
-
-            company_currency = line.account_id.company_id.currency_id
-            balance = line.amount_currency
-            if line.currency_id and company_currency and line.currency_id != company_currency:
-                balance = line.currency_id._convert(balance, company_currency, line.account_id.company_id, line.move_id.date or fields.Date.context_today(self))
-                line.debit = balance > 0 and balance or 0.0
-                line.credit = balance < 0 and -balance or 0.0
     # -------------------------------------------------------------------------
     # COMPUTE METHODS
     # -------------------------------------------------------------------------
@@ -3373,11 +3319,6 @@ class AccountMoveLine(models.Model):
             else:
                 record.matching_number = None
 
-    @api.depends('currency_id')
-    def _compute_always_set_currency_id(self):
-        for line in self:
-            line.always_set_currency_id = line.currency_id or line.company_currency_id
-
     @api.depends('debit', 'credit')
     def _compute_balance(self):
         for line in self:
@@ -3571,6 +3512,18 @@ class AccountMoveLine(models.Model):
             move = self.env['account.move'].browse(vals['move_id'])
             vals.setdefault('company_currency_id', move.company_id.currency_id.id) # important to bypass the ORM limitation where monetary fields are not rounded; more info in the commit message
 
+            # Ensure balance == amount_currency in case of missing currency or same currency as the one from the
+            # company.
+            currency_id = vals.get('currency_id') or move.company_id.currency_id.id
+            if currency_id == move.company_id.currency_id.id:
+                balance = vals.get('debit', 0.0) - vals.get('credit', 0.0)
+                vals.update({
+                    'currency_id': currency_id,
+                    'amount_currency': balance,
+                })
+            else:
+                vals['amount_currency'] = vals.get('amount_currency', 0.0)
+
             if move.is_invoice(include_receipts=True):
                 currency = move.currency_id
                 partner = self.env['res.partner'].browse(vals.get('partner_id'))
@@ -3583,10 +3536,6 @@ class AccountMoveLine(models.Model):
                 # in onchange and in create/write. So, if something changed in accounting [resp. business] fields,
                 # business [resp. accounting] fields are recomputed.
                 if any(vals.get(field) for field in ACCOUNTING_FIELDS):
-                    if vals.get('currency_id'):
-                        balance = vals.get('amount_currency', 0.0)
-                    else:
-                        balance = vals.get('debit', 0.0) - vals.get('credit', 0.0)
                     price_subtotal = self._get_price_total_and_subtotal_model(
                         vals.get('price_unit', 0.0),
                         vals.get('quantity', 0.0),
@@ -3600,7 +3549,7 @@ class AccountMoveLine(models.Model):
                     vals.update(self._get_fields_onchange_balance_model(
                         vals.get('quantity', 0.0),
                         vals.get('discount', 0.0),
-                        balance,
+                        vals['amount_currency'],
                         move.move_type,
                         currency,
                         taxes,
@@ -3759,6 +3708,14 @@ class AccountMoveLine(models.Model):
             if not cleaned_vals:
                 continue
 
+            # Auto-fill amount_currency if working in single-currency.
+            if 'currency_id' not in cleaned_vals \
+                and line.currency_id == line.company_currency_id \
+                and any(field_name in cleaned_vals for field_name in ('debit', 'credit')):
+                cleaned_vals.update({
+                    'amount_currency': vals.get('debit', 0.0) - vals.get('credit', 0.0),
+                })
+
             result |= super(AccountMoveLine, line).write(cleaned_vals)
 
             if not line.move_id.is_invoice(include_receipts=True):
@@ -3769,12 +3726,8 @@ class AccountMoveLine(models.Model):
             # in onchange and in create/write. So, if something changed in accounting [resp. business] fields,
             # business [resp. accounting] fields are recomputed.
             if any(field in cleaned_vals for field in ACCOUNTING_FIELDS):
-                balance = line.currency_id and line.amount_currency or line.debit - line.credit
                 price_subtotal = line._get_price_total_and_subtotal().get('price_subtotal', 0.0)
-                to_write = line._get_fields_onchange_balance(
-                    balance=balance,
-                    price_subtotal=price_subtotal,
-                )
+                to_write = line._get_fields_onchange_balance(price_subtotal=price_subtotal)
                 to_write.update(line._get_price_total_and_subtotal(
                     price_unit=to_write.get('price_unit', line.price_unit),
                     quantity=to_write.get('quantity', line.quantity),
@@ -4413,97 +4366,6 @@ class AccountMoveLine(models.Model):
 
         return results
 
-    def _create_writeoff(self, writeoff_vals):
-        """ Create a writeoff move per journal for the account.move.lines in self. If debit/credit is not specified in vals,
-            the writeoff amount will be computed as the sum of amount_residual of the given recordset.
-            :param writeoff_vals: list of dicts containing values suitable for account_move_line.create(). The data in vals will
-                be processed to create bot writeoff account.move.line and their enclosing account.move.
-        """
-        def compute_writeoff_counterpart_vals(values):
-            line_values = values.copy()
-            line_values['debit'], line_values['credit'] = line_values['credit'], line_values['debit']
-            if 'amount_currency' in values:
-                line_values['amount_currency'] = -line_values['amount_currency']
-            return line_values
-        # Group writeoff_vals by journals
-        writeoff_dict = {}
-        for val in writeoff_vals:
-            journal_id = val.get('journal_id', False)
-            if not writeoff_dict.get(journal_id, False):
-                writeoff_dict[journal_id] = [val]
-            else:
-                writeoff_dict[journal_id].append(val)
-
-        partner_id = self.env['res.partner']._find_accounting_partner(self[0].partner_id).id
-        company_currency = self[0].account_id.company_id.currency_id
-        writeoff_currency = self[0].account_id.currency_id or company_currency
-        line_to_reconcile = self.env['account.move.line']
-        # Iterate and create one writeoff by journal
-        writeoff_moves = self.env['account.move']
-        for journal_id, lines in writeoff_dict.items():
-            total = 0
-            total_currency = 0
-            writeoff_lines = []
-            date = fields.Date.context_today(self)
-            for vals in lines:
-                # Check and complete vals
-                if 'account_id' not in vals or 'journal_id' not in vals:
-                    raise UserError(_("It is mandatory to specify an account and a journal to create a write-off."))
-                if ('debit' in vals) ^ ('credit' in vals):
-                    raise UserError(_("Either pass both debit and credit or none."))
-                if 'date' not in vals:
-                    vals['date'] = self._context.get('date_p') or fields.Date.context_today(self)
-                vals['date'] = fields.Date.to_date(vals['date'])
-                if vals['date'] and vals['date'] < date:
-                    date = vals['date']
-                if 'name' not in vals:
-                    vals['name'] = self._context.get('comment') or _('Write-Off')
-                if 'analytic_account_id' not in vals:
-                    vals['analytic_account_id'] = self.env.context.get('analytic_id', False)
-                #compute the writeoff amount if not given
-                if 'credit' not in vals and 'debit' not in vals:
-                    amount = sum([r.amount_residual for r in self])
-                    vals['credit'] = amount > 0 and amount or 0.0
-                    vals['debit'] = amount < 0 and abs(amount) or 0.0
-                vals['partner_id'] = partner_id
-                total += vals['debit']-vals['credit']
-                if 'amount_currency' not in vals and writeoff_currency != company_currency:
-                    vals['currency_id'] = writeoff_currency.id
-                    sign = 1 if vals['debit'] > 0 else -1
-                    vals['amount_currency'] = sign * abs(sum([r.amount_residual_currency for r in self]))
-                    total_currency += vals['amount_currency']
-
-                writeoff_lines.append(compute_writeoff_counterpart_vals(vals))
-
-            # Create balance line
-            writeoff_lines.append({
-                'name': _('Write-Off'),
-                'debit': total > 0 and total or 0.0,
-                'credit': total < 0 and -total or 0.0,
-                'amount_currency': total_currency,
-                'currency_id': total_currency and writeoff_currency.id or False,
-                'journal_id': journal_id,
-                'account_id': self[0].account_id.id,
-                'partner_id': partner_id
-                })
-
-            # Create the move
-            writeoff_move = self.env['account.move'].create({
-                'journal_id': journal_id,
-                'date': date,
-                'state': 'draft',
-                'line_ids': [(0, 0, line) for line in writeoff_lines],
-            })
-            writeoff_moves += writeoff_move
-            line_to_reconcile += writeoff_move.line_ids.filtered(lambda r: r.account_id == self[0].account_id).sorted(key='id')[-1:]
-
-        #post all the writeoff moves at once
-        if writeoff_moves:
-            writeoff_moves._post()
-
-        # Return the writeoff move.line which is to be reconciled
-        return line_to_reconcile
-
     def remove_move_reconcile(self):
         """ Undo a reconciliation """
         (self.matched_debit_ids + self.matched_credit_ids).unlink()

--- a/addons/account/models/account_partial_reconcile.py
+++ b/addons/account/models/account_partial_reconcile.py
@@ -371,8 +371,6 @@ class AccountPartialReconcile(models.Model):
         # reconciliation.
         # ==========================================================================
 
-        balance_field = 'balance' if move_values['currency'] == move.company_id.currency_id else 'amount_currency'
-
         for line in move_values['to_process_lines']:
             if line.tax_repartition_line_id:
                 # Tax line.
@@ -381,7 +379,7 @@ class AccountPartialReconcile(models.Model):
                     account=line.tax_repartition_line_id.account_id,
                 )
                 residual_amount_per_group.setdefault(grouping_key, 0.0)
-                residual_amount_per_group[grouping_key] += line[balance_field]
+                residual_amount_per_group[grouping_key] += line['amount_currency']
 
             elif line.tax_ids:
                 # Base line.
@@ -390,7 +388,7 @@ class AccountPartialReconcile(models.Model):
                     account=line.company_id.account_cash_basis_base_account_id,
                 )
                 residual_amount_per_group.setdefault(grouping_key, 0.0)
-                residual_amount_per_group[grouping_key] += line[balance_field]
+                residual_amount_per_group[grouping_key] += line['amount_currency']
 
         # ==========================================================================
         # Part 2:
@@ -419,7 +417,7 @@ class AccountPartialReconcile(models.Model):
                 # we are not able to ensure the full coverage of the balance.
                 return
 
-            residual_amount_per_group[grouping_key] -= line[balance_field]
+            residual_amount_per_group[grouping_key] -= line['amount_currency']
 
         # ==========================================================================
         # Part 3:
@@ -439,20 +437,13 @@ class AccountPartialReconcile(models.Model):
         for grouping_key, aggregated_vals in partial_lines_to_create.items():
             line_vals = aggregated_vals['vals']
 
-            if move_values['currency'] == move.company_id.currency_id:
-                balance = residual_amount_per_group[grouping_key]
-                line_vals.update({
-                    'debit': balance if balance > 0.0 else 0.0,
-                    'credit': -balance if balance < 0.0 else 0.0,
-                })
-            else:
-                amount_currency = residual_amount_per_group[grouping_key]
-                balance = partial_values['payment_rate'] and amount_currency / partial_values['payment_rate'] or 0.0
-                line_vals.update({
-                    'debit': balance if balance > 0.0 else 0.0,
-                    'credit': -balance if balance < 0.0 else 0.0,
-                    'amount_currency': amount_currency,
-                })
+            amount_currency = residual_amount_per_group[grouping_key]
+            balance = partial_values['payment_rate'] and amount_currency / partial_values['payment_rate'] or 0.0
+            line_vals.update({
+                'debit': balance if balance > 0.0 else 0.0,
+                'credit': -balance if balance < 0.0 else 0.0,
+                'amount_currency': amount_currency,
+            })
 
     def _create_tax_cash_basis_moves(self):
         ''' Create the tax cash basis journal entries.
@@ -493,14 +484,9 @@ class AccountPartialReconcile(models.Model):
                     # that is actually paid by the current partial.
                     # ==========================================================================
 
-                    if move_values['currency'] == move.company_id.currency_id:
-                        # Percentage expressed in the company's currency.
-                        balance = line.company_currency_id.round(line.balance * partial_values['percentage'])
-                        amount_currency = 0.0
-                    else:
-                        # Percentage expressed in the foreign currency.
-                        amount_currency = line.currency_id.round(line.amount_currency * partial_values['percentage'])
-                        balance = partial_values['payment_rate'] and amount_currency / partial_values['payment_rate'] or 0.0
+                    # Percentage expressed in the foreign currency.
+                    amount_currency = line.currency_id.round(line.amount_currency * partial_values['percentage'])
+                    balance = partial_values['payment_rate'] and amount_currency / partial_values['payment_rate'] or 0.0
 
                     # ==========================================================================
                     # Prepare the mirror cash basis journal item of the current line.
@@ -568,10 +554,7 @@ class AccountPartialReconcile(models.Model):
                     line_vals = aggregated_vals['vals']
                     line_vals['sequence'] = sequence
 
-                    if move_values['currency'] == move.company_id.currency_id:
-                        pending_cash_basis_lines.append((grouping_key, line_vals['debit'] - line_vals['credit']))
-                    else:
-                        pending_cash_basis_lines.append((grouping_key, line_vals['amount_currency']))
+                    pending_cash_basis_lines.append((grouping_key, line_vals['amount_currency']))
 
                     if 'tax_repartition_line_id' in line_vals:
                         # Tax line.

--- a/addons/account/models/account_payment.py
+++ b/addons/account/models/account_payment.py
@@ -191,21 +191,11 @@ class AccountPayment(models.Model):
             counterpart_amount = 0.0
             write_off_amount = 0.0
 
-        # Manage currency.
-        if self.currency_id == self.company_id.currency_id:
-            # Single-currency.
-            balance = counterpart_amount
-            counterpart_amount_currency = 0.0
-            write_off_balance = write_off_amount
-            write_off_amount_currency = 0.0
-            currency_id = False
-        else:
-            # Multi-currencies.
-            balance = self.currency_id._convert(counterpart_amount, self.company_id.currency_id, self.company_id, self.date)
-            counterpart_amount_currency = counterpart_amount
-            write_off_balance = self.currency_id._convert(write_off_amount, self.company_id.currency_id, self.company_id, self.date)
-            write_off_amount_currency = write_off_amount
-            currency_id = self.currency_id.id
+        balance = self.currency_id._convert(counterpart_amount, self.company_id.currency_id, self.company_id, self.date)
+        counterpart_amount_currency = counterpart_amount
+        write_off_balance = self.currency_id._convert(write_off_amount, self.company_id.currency_id, self.company_id, self.date)
+        write_off_amount_currency = write_off_amount
+        currency_id = self.currency_id.id
 
         if self.is_internal_transfer:
             if self.payment_type == 'inbound':
@@ -630,17 +620,17 @@ class AccountPayment(models.Model):
                 else:
                     partner_type = 'supplier'
 
-                liquidity_amount = liquidity_lines.amount_currency if liquidity_lines.currency_id else liquidity_lines.balance
+                liquidity_amount = liquidity_lines.amount_currency
 
                 move_vals_to_write.update({
-                    'currency_id': liquidity_lines.currency_id.id or liquidity_lines.company_currency_id.id,
+                    'currency_id': liquidity_lines.currency_id.id,
                     'partner_id': liquidity_lines.partner_id.id,
                 })
                 payment_vals_to_write.update({
                     'amount': abs(liquidity_amount),
                     'payment_type': 'inbound' if liquidity_amount > 0.0 else 'outbound',
                     'partner_type': partner_type,
-                    'currency_id': liquidity_lines.currency_id.id or liquidity_lines.company_currency_id.id,
+                    'currency_id': liquidity_lines.currency_id.id,
                     'destination_account_id': counterpart_lines.account_id.id,
                     'partner_id': liquidity_lines.partner_id.id,
                 })
@@ -668,9 +658,8 @@ class AccountPayment(models.Model):
             # This allows to create a new payment with custom 'line_ids'.
 
             if writeoff_lines:
-                writeoff_amount_field = 'balance' if pay.currency_id == pay.company_id.currency_id else 'amount_currency'
-                writeoff_amount = sum(writeoff_lines.mapped(writeoff_amount_field))
-                counterpart_amount = counterpart_lines[writeoff_amount_field]
+                writeoff_amount = sum(writeoff_lines.mapped('amount_currency'))
+                counterpart_amount = counterpart_lines['amount_currency']
                 if writeoff_amount > 0.0 and counterpart_amount > 0.0:
                     sign = 1
                 else:
