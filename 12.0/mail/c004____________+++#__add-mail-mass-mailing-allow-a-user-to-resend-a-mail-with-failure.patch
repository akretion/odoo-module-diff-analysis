PR: https://github.com/odoo/odoo/pull/

From: 133eeb1bbf52e9a9ee58f83be8e7f0aba3c6d1ad
From: XavierDo
Date: 2018-06-07 09:46:28

Structural Changes: 9
Total Changes: 198

[ADD] mail, mass_mailing: allow a user to resend a mail with failures

When a mail is in failure state, a red envelope appears next to the message
in a thread but it was difficult to send the mail again.
This tasks will allow users to send mail again easily, or mark notification
as cancelled if the user want to ignore this failure.
A notification will appear in sender systray while mail are in failure.

Task: #46158
PR: #24628

================================= pseudo patch: =================================

--- a/addons/mail/models/mail_mail.py
+++ b/addons/mail/models/mail_mail.py
@@ -123,7 +123,7 @@ class MailMail(models.Model):
         return res
 
     @api.multi
-    def _postprocess_sent_message(self, mail_sent=True):
+    def _postprocess_sent_message(self, success_pids, failure_reason=False, failure_type='NONE'):
         """Perform any post-processing necessary after sending ``mail``
         successfully, including deleting it completely along with its
         attachment if the ``auto_delete`` flag of the mail was set.
@@ -131,20 +131,29 @@ class MailMail(models.Model):
 
         :return: True
         """
-        mail_message_notif_ids = [mail.mail_message_id.id for mail in self if mail.notification]
-        if mail_message_notif_ids:
+        notif_mails_ids = [mail.id for mail in self if mail.notification]
+        if notif_mails_ids:
             notifications = self.env['mail.notification'].search([
-                ('mail_message_id', 'in', mail_message_notif_ids),
-                ('is_email', '=', True)])
-            if notifications and mail_sent:
-                notifications.write({
+                ('is_email', '=', True),
+                ('mail_id', 'in', notif_mails_ids),
+                ('email_status', 'not in', ('sent', 'canceled'))
+            ])
+            if notifications:
+                #find all notification linked to a failure
+                failed = self.env['mail.notification']
+                if failure_type != 'NONE':
+                    failed = notifications.filtered(lambda notif: notif.res_partner_id not in success_pids)
+                    failed.write({
+                        'email_status': 'exception',
+                        'failure_type': failure_type,
+                        'failure_reason': failure_reason,
+                    })
+                    messages = notifications.mapped('mail_message_id').filtered(lambda m: m.res_id and m.model)
+                    messages._notify_failure_update()  # notify user that we have a failure
+                (notifications - failed).write({
                     'email_status': 'sent',
                 })
-            elif notifications:
-                notifications.write({
-                    'email_status': 'exception',
-                })
-        if mail_sent:
+        if failure_type in ('NONE', 'RECIPIENT'):  # if we have another error, we want to keep the mail.
             mail_to_delete_ids = [mail.id for mail in self if mail.auto_delete]
             self.browse(mail_to_delete_ids).sudo().unlink()
         return True
@@ -225,7 +234,9 @@ class MailMail(models.Model):
                     # exceptions, it is encapsulated into an Odoo MailDeliveryException
                     raise MailDeliveryException(_('Unable to connect to SMTP Server'), exc)
                 else:
-                    self.browse(batch_ids).write({'state': 'exception', 'failure_reason': exc})
+                    batch = self.browse(batch_ids)
+                    batch.write({'state': 'exception', 'failure_reason': exc})
+                    batch._postprocess_sent_message(success_pids=[], failure_type="SMTP")
             else:
                 self.browse(batch_ids)._send(
                     auto_commit=auto_commit,
@@ -242,13 +253,16 @@ class MailMail(models.Model):
     def _send(self, auto_commit=False, raise_exception=False, smtp_session=None):
         IrMailServer = self.env['ir.mail_server']
         for mail_id in self.ids:
+            success_pids = []
+            failure_type = 'NONE'
+            processing_pid = None
+            mail = None
             try:
                 mail = self.browse(mail_id)
                 if mail.state != 'outgoing':
                     if mail.state != 'exception' and mail.auto_delete:
                         mail.sudo().unlink()
                     continue
-
                 # load attachment binary data with a separate read(), as prefetching all
                 # `datas` (binary field) could bloat the browse cache, triggerring
                 # soft/hard mem limits with temporary data.
@@ -260,7 +274,10 @@ class MailMail(models.Model):
                 if mail.email_to:
                     email_list.append(mail._send_prepare_values())
                 for partner in mail.recipient_ids:
-                    email_list.append(mail._send_prepare_values(partner=partner))
+                    values = mail._send_prepare_values(partner=partner)
+                    values['partner_id'] = partner
+                    email_list.append(values)
+
 
                 # headers
                 headers = {}
@@ -285,8 +302,6 @@ class MailMail(models.Model):
                     'state': 'exception',
                     'failure_reason': _('Error without exception. Probably due do sending an email without computed recipients.'),
                 })
-                mail_sent = False
-
                 # build an RFC2822 email.message.Message object and send it without queuing
                 res = None
                 for email in email_list:
@@ -305,11 +320,16 @@ class MailMail(models.Model):
                         subtype='html',
                         subtype_alternative='plain',
                         headers=headers)
+                    processing_pid = email.pop("partner_id", None)
                     try:
                         res = IrMailServer.send_email(
                             msg, mail_server_id=mail.mail_server_id.id, smtp_session=smtp_session)
+                        if processing_pid:
+                            success_pids.append(processing_pid)
+                        processing_pid = None
                     except AssertionError as error:
                         if str(error) == IrMailServer.NO_VALID_RECIPIENT:
+                            failure_type = "RECIPIENT"
                             # No valid recipient found for this particular
                             # mail item -> ignore error to avoid blocking
                             # delivery to next recipients, if any. If this is
@@ -318,21 +338,19 @@ class MailMail(models.Model):
                                          mail.message_id, email.get('email_to'))
                         else:
                             raise
-                if res:
+                if res:  # mail has been sent at least once, no major exception occured
                     mail.write({'state': 'sent', 'message_id': res, 'failure_reason': False})
-                    mail_sent = True
-
-                # /!\ can't use mail.state here, as mail.refresh() will cause an error
-                # see revid:odo@openerp.com-20120622152536-42b2s28lvdv3odyr in 6.1
-                if mail_sent:
                     _logger.info('Mail with ID %r and Message-Id %r successfully sent', mail.id, mail.message_id)
-                mail._postprocess_sent_message(mail_sent=mail_sent)
+                    # /!\ can't use mail.state here, as mail.refresh() will cause an error
+                    # see revid:odo@openerp.com-20120622152536-42b2s28lvdv3odyr in 6.1
+                mail._postprocess_sent_message(success_pids=success_pids, failure_type=failure_type)
             except MemoryError:
                 # prevent catching transient MemoryErrors, bubble up to notify user or abort cron job
                 # instead of marking the mail as failed
                 _logger.exception(
                     'MemoryError while processing mail with ID %r and Msg-Id %r. Consider raising the --limit-memory-hard startup option',
                     mail.id, mail.message_id)
+                # mail status will stay on ongoing since transaction will be rollback
                 raise
             except psycopg2.Error:
                 # If an error with the database occurs, chances are that the cursor is unusable.
@@ -344,7 +362,7 @@ class MailMail(models.Model):
                 failure_reason = tools.ustr(e)
                 _logger.exception('failed sending mail (id: %s) due to %s', mail.id, failure_reason)
                 mail.write({'state': 'exception', 'failure_reason': failure_reason})
-                mail._postprocess_sent_message(mail_sent=False)
+                mail._postprocess_sent_message(success_pids=success_pids, failure_reason=failure_reason, failure_type='UNKNOWN')
                 if raise_exception:
                     if isinstance(e, AssertionError):
                         # get the args of the original error, wrap into a value and throw a MailDeliveryException

--- a/addons/mail/models/mail_message.py
+++ b/addons/mail/models/mail_message.py
@@ -4,11 +4,13 @@
 import logging
 import re
 
+from operator import itemgetter
 from email.utils import formataddr
 
 from odoo import _, api, fields, models, modules, SUPERUSER_ID, tools
 from odoo.exceptions import UserError, AccessError
 from odoo.osv import expression
+from odoo.tools import groupby
 
 _logger = logging.getLogger(__name__)
 _image_dataurl = re.compile(r'(data:image/[a-z]+?);base64,([a-z0-9+/\n]{3,}=*)\n*([\'"])', re.I)
@@ -81,6 +83,9 @@ class Message(models.Model):
     needaction = fields.Boolean(
         'Need Action', compute='_get_needaction', search='_search_needaction',
         help='Need Action')
+    has_error = fields.Boolean(
+        'Has error', compute='_compute_has_error', search='_search_has_error',
+        help='Has error')
     channel_ids = fields.Many2many(
         'mail.channel', 'mail_message_mail_channel_rel', string='Channels')
     # notifications
@@ -114,6 +119,9 @@ class Message(models.Model):
         ('rejected', 'Rejected')], string="Moderation Status", index=True)
     moderator_id = fields.Many2one('res.users', string="Moderated By", index=True)
     need_moderation = fields.Boolean('Need moderation', compute='_compute_need_moderation', search='_search_need_moderation')
+    #keep notification layout informations to be able to generate mail again
+    layout = fields.Char('Layout', copy=False)  # xml id of layout
+    layout_values = fields.Char('Notification values', copy=False)
 
     @api.multi
     def _get_needaction(self):
@@ -131,6 +139,20 @@ class Message(models.Model):
             return ['&', ('notification_ids.res_partner_id', '=', self.env.user.partner_id.id), ('notification_ids.is_read', '=', False)]
         return ['&', ('notification_ids.res_partner_id', '=', self.env.user.partner_id.id), ('notification_ids.is_read', '=', True)]
 
+    @api.multi
+    def _compute_has_error(self):
+        error_from_notification = self.env['mail.notification'].sudo().search([
+            ('mail_message_id', 'in', self.ids),
+            ('email_status', 'in', ('bounce', 'exception'))]).mapped('mail_message_id')
+        for message in self:
+            message.has_error = message in error_from_notification
+
+    @api.multi
+    def _search_has_error(self, operator, operand):
+        if operator == '=' and operand:
+            return [('notification_ids.email_status', 'in', ('bounce', 'exception'))]
+        return ['!', ('notification_ids.email_status', 'in', ('bounce', 'exception'))]  # this wont work and will be equivalent to "not in" beacause of orm restrictions. Dont use "has_error = False"
+
     @api.depends('starred_partner_ids')
     def _get_starred(self):
         """ Compute if the message is starred by the current user. """
@@ -350,7 +372,7 @@ class Message(models.Model):
                                 if partner.id in partner_tree]
 
             customer_email_data = []
-            for notification in message.notification_ids.filtered(lambda notif: notif.res_partner_id.partner_share and notif.res_partner_id.active):
+            for notification in message.notification_ids.filtered(lambda notif: notif.email_status in ('bounce', 'exception', 'canceled') or (notif.res_partner_id.partner_share and notif.res_partner_id.active)):
                 customer_email_data.append((partner_tree[notification.res_partner_id.id][0], partner_tree[notification.res_partner_id.id][1], notification.email_status))
 
             attachment_ids = []
@@ -375,6 +397,11 @@ class Message(models.Model):
 
         return True
 
+    @api.multi
+    def message_fetch_failed(self):
+        messages = self.search([('has_error', '=', True), ('author_id.id', '=', self.env.user.partner_id.id), ('res_id', '!=', 0), ('model', '!=', False)])
+        return messages._format_mail_failures()
+
     @api.model
     def message_fetch(self, domain, limit=20):
         return self.search(domain, limit=limit).message_format()
@@ -461,6 +488,37 @@ class Message(models.Model):
                 message['module_icon'] = modules.module.get_module_icon(self.env[message['model']]._original_module)
         return message_values
 
+    @api.multi
+    def _format_mail_failures(self):
+        """
+        A shorter message to notify a failure update
+        """
+        failures_infos = []
+        # for each channel, build the information header and include the logged partner information
+        for message in self:
+            info = {
+                'message_id': message.id,
+                'record_name': message.record_name,
+                'model_name': self.env['ir.model']._get(message.model).display_name,
+                'uuid': message.message_id,
+                'res_id': message.res_id,
+                'model': message.model,
+                'last_message_date': message.date,
+                'module_icon': '/mail/static/src/img/smiley/mailfailure.jpg',
+                'notifications': dict((notif.res_partner_id.id, (notif.email_status, notif.res_partner_id.name)) for notif in message.notification_ids)
+            }
+            failures_infos.append(info)
+        return failures_infos
+
+    @api.multi
+    def _notify_failure_update(self):
+        authors = {}
+        for author, author_messages in groupby(self, itemgetter('author_id')):
+            self.env['bus.bus'].sendone(
+                (self._cr.dbname, 'res.partner', author.id),
+                {'type': 'mail_failure', 'elements': self.env['mail.message'].concat(*author_messages)._format_mail_failures()}
+            )
+
     #------------------------------------------------------
     # mail_message internals
     #------------------------------------------------------
@@ -939,8 +997,16 @@ class Message(models.Model):
         # remove author from notified partners
         if not self._context.get('mail_notify_author', False) and self_sudo.author_id:
             partners_sudo = partners_sudo - self_sudo.author_id
-        # update message, with maybe custom values
+            
+        # list channels and partner by notification type
+        email_channels = channels_sudo.filtered(lambda channel: channel.email_send)
+        notif_partners = partners_sudo.filtered(lambda partner: 'inbox' in partner.mapped('user_ids.notification_type'))
+        email_partner = partners_sudo - notif_partners
+
+        #update message, with maybe custom values
         message_values = {}
+        if email_partner:
+            message_values = {'layout': layout, 'layout_values': repr(values)}
         if channels_sudo:
             message_values['channel_ids'] = [(6, 0, channels_sudo.ids)]
         if partners_sudo:
@@ -953,13 +1019,10 @@ class Message(models.Model):
         # notify partners and channels
         # those methods are called as SUPERUSER because portal users posting messages
         # have no access to partner model. Maybe propagating a real uid could be necessary.
-        email_channels = channels_sudo.filtered(lambda channel: channel.email_send)
-        notif_partners = partners_sudo.filtered(lambda partner: 'inbox' in partner.mapped('user_ids.notification_type'))
-
-        if email_channels or partners_sudo - notif_partners:
+        if email_channels or email_partner:
             partners_sudo.search([
                 '|',
-                ('id', 'in', (partners_sudo - notif_partners).ids),
+                ('id', 'in', (email_partner).ids),
                 ('channel_ids', 'in', email_channels.ids),
                 ('email', '!=', self_sudo.author_id.email or self_sudo.email_from),
             ])._notify(self, layout=layout, force_send=force_send, send_after_commit=send_after_commit, values=values)

--- a/addons/mail/models/mail_notification.py
+++ b/addons/mail/models/mail_notification.py
@@ -20,11 +20,35 @@ class Notification(models.Model):
         ('ready', 'Ready to Send'),
         ('sent', 'Sent'),
         ('bounce', 'Bounced'),
-        ('exception', 'Exception')], 'Email Status',
+        ('exception', 'Exception'),
+        ('canceled', 'Canceled')], 'Email Status',
         default='ready', index=True)
+    mail_id = fields.Many2one('mail.mail', 'Mail', index=True)
+    # it would be technically possible to find notification from mail without adding a mail_id field on notification,
+    # comparing partner_ids and message_ids, but this will involve to search notifications one by one since we want to match
+    # bot value. Working with set inclusion, we could have a notif matching message from mail 1 and partner from mail 2, we dont want that.
+    # The solution would be to iterate over mail or to filter mail after search,... or add a mail_id field on notification to KISS
+    failure_type = fields.Selection(selection=[
+            ("NONE", "No error"),
+            ("SMTP", "Error while connecting to smtp server"),
+            ("RECIPIENT", "Invalid email adress"),
+            ("BOUNCE", "Email address not found"),
+            ("UNKNOWN", "Unknown error occured"),
+            ], default='NONE', string='Failure type')
+    failure_reason = fields.Text('Failure reason', copy=False)
 
     @api.model_cr
     def init(self):
         self._cr.execute('SELECT indexname FROM pg_indexes WHERE indexname = %s', ('mail_notification_res_partner_id_is_read_email_status_mail_message_id',))
         if not self._cr.fetchone():
             self._cr.execute('CREATE INDEX mail_notification_res_partner_id_is_read_email_status_mail_message_id ON mail_message_res_partner_needaction_rel (res_partner_id, is_read, email_status, mail_message_id)')
+
+    @api.multi
+    def format_failure_reason(self):
+        self.ensure_one()
+        if self.failure_type != 'UNKNOWN':
+            return dict(type(self).failure_type.selection).get(self.failure_type)
+        else:
+            return "Unknow error occured: %s" % (self.failure_reason)
+
+

--- a/addons/mail/models/mail_thread.py
+++ b/addons/mail/models/mail_thread.py
@@ -102,6 +102,12 @@ class MailThread(models.AbstractModel):
     message_needaction_counter = fields.Integer(
         'Number of Actions', compute='_get_message_needaction',
         help="Number of messages which requires an action")
+    message_has_error = fields.Boolean(
+        'Message Delivery error', compute='_compute_message_has_error', search='_search_message_has_error',
+        help="If checked, some messages have a delivery error.")
+    message_has_error_counter = fields.Integer(
+        'Number of error', compute='_compute_message_has_error',
+        help="Number of messages with delivery error")
 
     @api.one
     @api.depends('message_follower_ids')
@@ -208,6 +214,26 @@ class MailThread(models.AbstractModel):
     def _search_message_needaction(self, operator, operand):
         return [('message_ids.needaction', operator, operand)]
 
+    @api.multi
+    def _compute_message_has_error(self):
+        self._cr.execute(""" SELECT msg.res_id, COUNT(msg.res_id) FROM mail_message msg
+                             RIGHT JOIN mail_message_res_partner_needaction_rel rel
+                             ON rel.mail_message_id = msg.id AND rel.email_status in ('exception','bounce')
+                             WHERE msg.author_id = %s AND msg.model = %s AND msg.res_id in %s
+                             GROUP BY msg.res_id""",
+                         (self.env.user.partner_id.id, self._name, tuple(self.ids),))
+        res = dict()
+        for result in self._cr.fetchall():
+            res[result[0]] = result[1]
+
+        for record in self:
+            record.message_has_error_counter = res.get(record.id, 0)
+            record.message_has_error = bool(record.message_has_error_counter)
+
+    @api.model
+    def _search_message_has_error(self, operator, operand):
+        return [('message_ids.has_error', operator, operand)]
+
     # ------------------------------------------------------
     # CRUD overrides for automatic subscription and logging
     # ------------------------------------------------------

--- a/addons/mail/models/res_partner.py
+++ b/addons/mail/models/res_partner.py
@@ -140,6 +140,7 @@ class Partner(models.Model):
                 ('mail_message_id', '=', email.mail_message_id.id),
                 ('res_partner_id', 'in', email.recipient_ids.ids)])
             notifications.write({
+                'mail_id': email.id,
                 'is_email': True,
                 'is_read': True,  # handle by email discards Inbox notification
                 'email_status': 'ready',
