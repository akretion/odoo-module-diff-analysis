PR: https://github.com/odoo/odoo/pull/74096

From: a46c9b0f21e2f8bd42b4f7dff09ac4f8f806f7cc
From: Pierre Masereel
Date: 2021-08-23 12:26:24

Structural Changes: 11
Total Changes: 184

[IMP] point_of_sale,pos_sale: Sale Order integration

Since now, there was no possibilities to pay a Sale Order in a point of
sale without re-encoding every lines of the sale order in a pos order.

So we've now added the possibility to choose a sale order from the point
of sale, and apply a down payment or settle the selected order. You
still get the possibility to invoice it, and the stock is correctly
managed.

The SO is then updated accordingly to what have been done throught the
POS.

closes odoo/odoo#74096

Task-id: 2500902
Signed-off-by: pimodoo <pimodoo@users.noreply.github.com>

================================= pseudo patch: =================================

--- a/addons/pos_sale/models/__init__.py
+++ b/addons/pos_sale/models/__init__.py
@@ -5,3 +5,4 @@ from . import pos_config
 from . import pos_order
 from . import crm_team
 from . import pos_session
+from . import sale_order

--- a/addons/pos_sale/models/pos_config.py
+++ b/addons/pos_sale/models/pos_config.py
@@ -12,6 +12,9 @@ class PosConfig(models.Model):
     crm_team_id = fields.Many2one(
         'crm.team', string="Sales Team", ondelete="set null",
         help="This Point of sale's sales will be related to this Sales Team.")
+    down_payment_product_id = fields.Many2one('product.product',
+        string="Down Payment Product",
+        help="This product will be used as down payment on a sale order.")
 
     @api.onchange('company_id')
     def _get_default_pos_team(self):

--- a/addons/pos_sale/models/pos_order.py
+++ b/addons/pos_sale/models/pos_order.py
@@ -1,7 +1,8 @@
 # -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
-from odoo import api, fields, models
+from odoo import api, fields, models, _
+from odoo.tools import float_compare, float_is_zero
 
 
 class PosOrder(models.Model):
@@ -9,6 +10,11 @@ class PosOrder(models.Model):
 
     currency_rate = fields.Float(compute='_compute_currency_rate', store=True, digits=0, readonly=True)
     crm_team_id = fields.Many2one('crm.team', string="Sales Team", ondelete="set null")
+    sale_order_count = fields.Integer(string='Sale Order Count', compute='_count_sale_order', readonly=True, groups="sales_team.group_sale_salesman")
+
+    def _count_sale_order(self):
+        for order in self:
+            order.sale_order_count = len(order.lines.mapped('sale_order_origin_id'))
 
     @api.model
     def _complete_values_from_session(self, session, values):
@@ -26,3 +32,91 @@ class PosOrder(models.Model):
         invoice_vals = super(PosOrder, self)._prepare_invoice_vals()
         invoice_vals['team_id'] = self.crm_team_id
         return invoice_vals
+
+    @api.model
+    def create_from_ui(self, orders, draft=False):
+        order_ids = super(PosOrder, self).create_from_ui(orders, draft)
+        for order in self.sudo().browse([o['id'] for o in order_ids]):
+            for line in order.lines.filtered(lambda l: l.product_id == order.config_id.down_payment_product_id and l.qty > 0 and l.sale_order_origin_id):
+                sale_lines = line.sale_order_origin_id.order_line
+                sale_line = self.env['sale.order.line'].create({
+                    'order_id': line.sale_order_origin_id.id,
+                    'product_id': line.product_id.id,
+                    'price_unit': line.price_unit,
+                    'product_uom_qty': 0,
+                    'tax_id': [(6, 0, line.tax_ids.ids)],
+                    'is_downpayment': True,
+                    'discount': line.discount,
+                    'sequence': sale_lines and sale_lines[-1].sequence + 1 or 10,
+                })
+                sale_line._compute_tax_id()
+                line.sale_order_line_id = sale_line
+
+            so_lines = order.lines.mapped('sale_order_line_id')
+
+            # confirm the unconfirmed sale orders that are linked to the sale order lines
+            sale_orders = so_lines.mapped('order_id')
+            for sale_order in sale_orders.filtered(lambda so: so.state in ['draft', 'sent']):
+                sale_order.action_confirm()
+
+            # update the demand qty in the stock moves related to the sale order line
+            # flush the qty_delivered to make sure the updated qty_delivered is used when
+            # updating the demand value
+            so_lines.flush(['qty_delivered'])
+            # track the waiting pickings
+            waiting_picking_ids = set()
+            for so_line in so_lines:
+                for stock_move in so_line.move_ids:
+                    picking = stock_move.picking_id
+                    if not picking.state in ['waiting', 'confirmed', 'assigned']:
+                        continue
+                    new_qty = so_line.product_uom_qty - so_line.qty_delivered
+                    if float_compare(new_qty, 0, precision_rounding=stock_move.product_uom.rounding) <= 0:
+                        new_qty = 0
+                    stock_move.product_uom_qty = so_line.product_uom._compute_quantity(new_qty, stock_move.product_uom, False)
+                    waiting_picking_ids.add(picking.id)
+
+            def is_product_uom_qty_zero(move):
+                return float_is_zero(move.product_uom_qty, precision_rounding=move.product_uom.rounding)
+
+            # cancel the waiting pickings if each product_uom_qty of move is zero
+            for picking in self.env['stock.picking'].browse(waiting_picking_ids):
+                if all(is_product_uom_qty_zero(move) for move in picking.move_lines):
+                    picking.action_cancel()
+
+        return order_ids
+
+    def action_view_sale_order(self):
+        self.ensure_one()
+        linked_orders = self.lines.mapped('sale_order_origin_id')
+        return {
+            'type': 'ir.actions.act_window',
+            'name': _('Linked Sale Orders'),
+            'res_model': 'sale.order',
+            'view_mode': 'tree,form',
+            'domain': [('id', 'in', linked_orders.ids)],
+        }
+
+
+class PosOrderLine(models.Model):
+    _inherit = 'pos.order.line'
+
+    sale_order_origin_id = fields.Many2one('sale.order', string="Linked Sale Order")
+    sale_order_line_id = fields.Many2one('sale.order.line', string="Source Sale Order Line")
+    down_payment_details = fields.Text(string="Down Payment Details")
+
+    def _export_for_ui(self, orderline):
+        result = super()._export_for_ui(orderline)
+        # NOTE We are not exporting 'sale_order_line_id' because it is being used in any views in the POS App.
+        result['down_payment_details'] = bool(orderline.down_payment_details) and orderline.down_payment_details
+        result['sale_order_origin_id'] = bool(orderline.sale_order_origin_id) and orderline.sale_order_origin_id.read(fields=['name'])[0]
+        return result
+
+    def _order_line_fields(self, line, session_id):
+        result = super()._order_line_fields(line, session_id)
+        vals = result[2]
+        if vals.get('sale_order_origin_id', False):
+            vals['sale_order_origin_id'] = vals['sale_order_origin_id']['id']
+        if vals.get('sale_order_line_id', False):
+            vals['sale_order_line_id'] = vals['sale_order_line_id']['id']
+        return result

--- a/None
+++ b/addons/pos_sale/models/sale_order.py
@@ -0,0 +1,84 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from odoo import api, fields, models, _
+
+
+class SaleOrder(models.Model):
+    _inherit = 'sale.order'
+
+    pos_order_line_ids = fields.One2many('pos.order.line', 'sale_order_origin_id', string="Order lines Transfered to Point of Sale", readonly=True, groups="point_of_sale.group_pos_user")
+    pos_order_count = fields.Integer(string='Pos Order Count', compute='_count_pos_order', readonly=True, groups="point_of_sale.group_pos_user")
+
+    def _count_pos_order(self):
+        for order in self:
+            linked_orders = order.pos_order_line_ids.mapped('order_id')
+            order.pos_order_count = len(linked_orders)
+
+    def action_view_pos_order(self):
+        self.ensure_one()
+        linked_orders = self.pos_order_line_ids.mapped('order_id')
+        return {
+            'type': 'ir.actions.act_window',
+            'name': _('Linked POS Orders'),
+            'res_model': 'pos.order',
+            'view_mode': 'tree,form',
+            'domain': [('id', 'in', linked_orders.ids)],
+        }
+
+class SaleOrderLine(models.Model):
+    _inherit = 'sale.order.line'
+
+    pos_order_line_ids = fields.One2many('pos.order.line', 'sale_order_line_id', string="Order lines Transfered to Point of Sale", readonly=True, groups="point_of_sale.group_pos_user")
+
+    @api.depends('pos_order_line_ids.qty')
+    def _compute_qty_delivered(self):
+        super()._compute_qty_delivered()
+        for sale_line in self:
+            sale_line.qty_delivered += sum([self._convert_qty(sale_line, pos_line.qty, 'p2s') for pos_line in sale_line.pos_order_line_ids if sale_line.product_id.type != 'service'], 0)
+
+    @api.depends('pos_order_line_ids.qty')
+    def _get_invoice_qty(self):
+        super()._get_invoice_qty()
+        for sale_line in self:
+            sale_line.qty_invoiced += sum([self._convert_qty(sale_line, pos_line.qty, 'p2s') for pos_line in sale_line.pos_order_line_ids], 0)
+
+    def read_converted(self):
+        field_names = ["product_id", "price_unit", "product_uom_qty", "tax_id", "qty_delivered", "qty_invoiced", "discount", "qty_to_invoice", "price_total"]
+        results = []
+        for sale_line in self:
+            if sale_line.product_type:
+                product_uom = sale_line.product_id.uom_id
+                sale_line_uom = sale_line.product_uom
+                item = sale_line.read(field_names)[0]
+                if sale_line.product_id.tracking != 'none':
+                    item['lot_names'] = sale_line.move_ids.move_line_ids.lot_id.mapped('name')
+                if product_uom == sale_line_uom:
+                    results.append(item)
+                    continue
+                item['product_uom_qty'] = self._convert_qty(sale_line, item['product_uom_qty'], 's2p')
+                item['qty_delivered'] = self._convert_qty(sale_line, item['qty_delivered'], 's2p')
+                item['qty_invoiced'] = self._convert_qty(sale_line, item['qty_invoiced'], 's2p')
+                item['qty_to_invoice'] = self._convert_qty(sale_line, item['qty_to_invoice'], 's2p')
+                item['price_unit'] = sale_line_uom._compute_price(item['price_unit'], product_uom)
+                results.append(item)
+
+            elif sale_line.display_type == 'line_note':
+                if results:
+                    results[-1]['customer_note'] = sale_line.name
+
+        return results
+
+    @api.model
+    def _convert_qty(self, sale_line, qty, direction):
+        """Converts the given QTY based on the given SALE_LINE and DIR.
+
+        if DIR='s2p': convert from sale line uom to product uom
+        if DIR='p2s': convert from product uom to sale line uom
+        """
+        product_uom = sale_line.product_id.uom_id
+        sale_line_uom = sale_line.product_uom
+        if direction == 's2p':
+            return sale_line_uom._compute_quantity(qty, product_uom, False)
+        elif direction == 'p2s':
+            return product_uom._compute_quantity(qty, sale_line_uom, False)
