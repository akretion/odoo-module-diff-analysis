PR: https://github.com/odoo/odoo/pull/

From: b4af54f9c23b65abe50dde3dfb397510ec2fcee4
From: jem-odoo
Date: 2018-08-13 15:32:22

Structural Changes: 5
Total Changes: 226

[IMP] sale_timesheet: billing time at employee rate

When a project become billable, the employee can now timesheet
on a same task, at different rate.
The project should be linked to a SO, and the mapping between
the employee and the SO line will be done using 2 mecanisms:

1/ task rate: the SO line set on the task is chosen for any employee
timesheeting on the task.

2/ employee rate: a map exists on the project, matching employee
with an SO line from the SO of the project. If the employee is not in
the map, the fallback will be the SO from the task, or the one from
the project.
This makes the SO line on the task always visible.

The billable type of a project depends on if the map is filled
or not. There is 2 ways of making a project billable:
- project is created from SO confirmation (depending of product
configuration)
- through the wizard "Create Sales Order": a SO will be created
and the project will be associated to it.

The subtask should follow the configuration of its parent
project (and not parent task).

Task #34703
Closes #26111

================================= pseudo patch: =================================

--- a/addons/sale_timesheet/models/__init__.py
+++ b/addons/sale_timesheet/models/__init__.py
@@ -6,3 +6,4 @@ from . import account_invoice
 from . import product
 from . import project
 from . import sale_order
+from . import project_sale_line_employee_map

--- a/addons/sale_timesheet/models/account.py
+++ b/addons/sale_timesheet/models/account.py
@@ -1,7 +1,8 @@
 # -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
-from odoo.exceptions import UserError
+from odoo.exceptions import UserError, ValidationError
+
 from odoo import api, fields, models, _
 from odoo.osv import expression
 
@@ -36,6 +37,23 @@ class AccountAnalyticLine(models.Model):
                         invoice_type = 'billable_fixed'
                 timesheet.timesheet_invoice_type = invoice_type
 
+    @api.onchange('employee_id')
+    def _onchange_task_id_employee_id(self):
+        if self.project_id:  # timesheet only
+            if self.task_id.billable_type == 'task_rate':
+                self.so_line = self.task_id.sale_line_id
+            elif self.task_id.billable_type == 'employee_rate':
+                self.so_line = self._timesheet_determine_sale_line(self.task_id, self.employee_id)
+            else:
+                self.so_line = False
+
+    @api.constrains('so_line', 'project_id')
+    def _check_sale_line_in_project_map(self):
+        for timesheet in self:
+            if timesheet.project_id and timesheet.so_line:  # billed timesheet
+                if timesheet.so_line not in timesheet.project_id.mapped('sale_line_employee_ids.sale_line_id') | timesheet.task_id.sale_line_id | timesheet.project_id.sale_line_id:
+                    raise ValidationError(_("This timesheet line cannot be billed: there is no Sale Order Item defined on the task, nor on the project. Please define one to save your timesheet line."))
+
     @api.multi
     def write(self, values):
         # prevent to update invoiced timesheets if one line is of type delivery
@@ -48,8 +66,40 @@ class AccountAnalyticLine(models.Model):
     @api.model
     def _timesheet_preprocess(self, values):
         values = super(AccountAnalyticLine, self)._timesheet_preprocess(values)
-        # task implies so line
-        if 'task_id' in values:
+        # task implies so line (at create)
+        if 'task_id' in values and not values.get('so_line') and values.get('employee_id'):
             task = self.env['project.task'].sudo().browse(values['task_id'])
-            values['so_line'] = task.sale_line_id.id or values.get('so_line', False)
+            employee = self.env['hr.employee'].sudo().browse(values['employee_id'])
+            values['so_line'] = self._timesheet_determine_sale_line(task, employee).id
         return values
+
+    @api.multi
+    def _timesheet_postprocess_values(self, values):
+        result = super(AccountAnalyticLine, self)._timesheet_postprocess_values(values)
+        # (re)compute the sale line
+        if any([field_name in values for field_name in ['task_id', 'employee_id']]):
+            for timesheet in self:
+                result[timesheet.id].update({
+                    'so_line': timesheet._timesheet_determine_sale_line(timesheet.task_id, timesheet.employee_id).id,
+                })
+        return result
+
+    @api.model
+    def _timesheet_determine_sale_line(self, task, employee):
+        """ Deduce the SO line associated to the timesheet line:
+            1/ timesheet on task rate: the so line will be the one from the task
+            2/ timesheet on employee rate task: find the SO line in the map of the project (even for subtask), or fallback on the SO line of the task, or fallback
+                on the one on the project
+            NOTE: this have to be consistent with `_compute_billable_type` on project.task.
+        """
+        if task.billable_type != 'no':
+            if task.billable_type == 'employee_rate':
+                map_entry = self.env['project.sale.line.employee.map'].search([('project_id', '=', task.project_id.id), ('employee_id', '=', employee.id)])
+                if map_entry:
+                    return map_entry.sale_line_id
+                if task.sale_line_id:
+                    return task.sale_line_id
+                return task.project_id.sale_line_id
+            elif task.billable_type == 'task_rate':
+                return task.sale_line_id
+        return self.env['sale.order.line']

--- a/addons/sale_timesheet/models/product.py
+++ b/addons/sale_timesheet/models/product.py
@@ -24,10 +24,10 @@ class ProductTemplate(models.Model):
     ], string="Service Tracking", default="no",
        help="On Sales order confirmation, this product can generate a project and/or task. From those, you can track the service you are selling.")
     project_id = fields.Many2one(
-        'project.project', 'Project', company_dependent=True, domain=[('sale_line_id', '=', False)],
+        'project.project', 'Project', company_dependent=True, domain=[('billable_type', '=', 'no')],
         help='Select a non billable project on which tasks can be created. This setting must be set for each company.')
     project_template_id = fields.Many2one(
-        'project.project', 'Project Template', company_dependent=True, domain=[('sale_line_id', '=', False)], copy=True,
+        'project.project', 'Project Template', company_dependent=True, domain=[('billable_type', '=', 'no')], copy=True,
         help='Select a non billable project to be the skeleton of the new created project when selling the current product. Its stages and tasks will be duplicated.')
 
     @api.depends('invoice_policy', 'service_type')

--- a/addons/sale_timesheet/models/project.py
+++ b/addons/sale_timesheet/models/project.py
@@ -8,18 +8,52 @@ from odoo.exceptions import ValidationError
 class Project(models.Model):
     _inherit = 'project.project'
 
-    sale_line_id = fields.Many2one('sale.order.line', 'Sales Order Line', domain=[('is_expense', '=', False)], readonly=True, help="Sale order line from which the project has been created. Used for tracability.")
+    sale_line_id = fields.Many2one('sale.order.line', 'Sales Order Item', domain="[('is_expense', '=', False), ('order_id', '=', sale_order_id), ('state', 'in', ['sale', 'done'])]", copy=False, help="Sale order line from which the project has been created. Used for tracability.")
+    sale_order_id = fields.Many2one('sale.order', 'Sales Order', domain="[('partner_id', '=', partner_id)]", readonly=True, copy=False)
     billable_type = fields.Selection([
         ('task_rate', 'At Task Rate'),
+        ('employee_rate', 'At Employee Rate'),
         ('no', 'No Billable')
-    ], string="Billable Type", default='no', required=True, help='Billable type implies:\n'
+    ], string="Billable Type", compute='_compute_billable_type', compute_sudo=True, store=True,
+        help='Billable type implies:\n'
         ' - At task rate: each time spend on a task is billed at task rate.\n'
+        ' - At employee rate: each employee log time billed at his rate.\n'
         ' - No Billable: track time without invoicing it')
+    sale_line_employee_ids = fields.One2many('project.sale.line.employee.map', 'project_id', "Sale line/Employee map", copy=False)
 
     _sql_constraints = [
-        ('sale_line_required_task_rate', "CHECK((billable_type='task_rate' AND sale_line_id IS NOT NULL) OR (billable_type != 'task_rate'))", "The project should be linked to a sale order item, as it is billed at task rate."),
+        ('sale_order_required_if_sale_line', "CHECK((sale_line_id IS NOT NULL AND sale_order_id IS NOT NULL) OR (sale_line_id IS NULL))", 'The Project should be linked to a Sale Order to select an Sale Order Items.'),
     ]
 
+    @api.depends('sale_order_id', 'sale_line_id', 'sale_line_employee_ids')
+    def _compute_billable_type(self):
+        for project in self:
+            billable_type = 'no'
+            if project.sale_order_id:
+                if project.sale_line_employee_ids:
+                    billable_type = 'employee_rate'
+                else:
+                    billable_type = 'task_rate'
+            project.billable_type = billable_type
+
+    @api.onchange('sale_line_employee_ids', 'billable_type')
+    def _onchange_sale_line_employee_ids(self):
+        if self.billable_type == 'task_rate':
+            if self.sale_line_employee_ids:
+                self.billable_type = 'employee_rate'
+        else:
+            if self.billable_type == 'no':
+                self.sale_line_employee_ids = False
+
+    @api.constrains('sale_line_id', 'billable_type')
+    def _check_sale_line_type(self):
+        for project in self:
+            if project.billable_type == 'task_rate':
+                if project.sale_line_id and not project.sale_line_id.is_service:
+                    raise ValidationError(_("A billable project should be linked to a Sales Order Item having a Service product."))
+                if project.sale_line_id and project.sale_line_id.is_expense:
+                    raise ValidationError(_("A billable project should be linked to a Sales Order Item that does not come from an expense or a vendor bill."))
+
     @api.multi
     def action_view_timesheet(self):
         self.ensure_one()
@@ -62,6 +96,19 @@ class Project(models.Model):
         }
         return action
 
+    @api.multi
+    def action_make_billable(self):
+        return {
+            "type": 'ir.actions.act_window',
+            "res_model": 'project.create.sale.order',
+            "views": [[False, "form"]],
+            "target": 'new',
+            "context": {
+                'active_id': self.id,
+                'active_model': 'project.project',
+            },
+        }
+
 
 class ProjectTask(models.Model):
     _inherit = "project.task"
@@ -81,32 +128,61 @@ class ProjectTask(models.Model):
         sale_line_id = False
         if self._context.get('default_parent_id'):
             parent_task = self.env['project.task'].browse(self._context['default_parent_id'])
-            if parent_task.project_id.billable_type != 'no':
-                sale_line_id = parent_task.sale_line_id.id
+            sale_line_id = parent_task.sale_line_id.id
         if not sale_line_id and self._context.get('default_project_id'):
             project = self.env['project.project'].browse(self.env.context['default_project_id'])
             if project.billable_type != 'no':
-                return project.sale_line_id
+                sale_line_id = project.sale_line_id.id
         return sale_line_id
 
-    sale_line_id = fields.Many2one('sale.order.line', 'Sales Order Item', default=_default_sale_line_id, domain="[('is_service', '=', True), ('order_partner_id', '=', partner_id), ('is_expense', '=', False)]")
-    sale_order_id = fields.Many2one('sale.order', 'Sales Order', related='sale_line_id.order_id', store=True, readonly=True)
+    sale_line_id = fields.Many2one('sale.order.line', 'Sales Order Item', default=_default_sale_line_id, domain="[('is_service', '=', True), ('order_partner_id', '=', partner_id), ('is_expense', '=', False), ('state', 'in', ['sale', 'done'])]")
+    sale_order_id = fields.Many2one('sale.order', 'Sales Order', compute='_compute_sale_order_id', compute_sudo=True, store=True, readonly=True)
     billable_type = fields.Selection([
         ('task_rate', 'At Task Rate'),
+        ('employee_rate', 'At Employee Rate'),
         ('no', 'No Billable')
-    ], string="Billable Type", default='no', required=True, readonly=True)
+    ], string="Billable Type", compute='_compute_billable_type', compute_sudo=True, store=True)
+    is_project_map_empty = fields.Boolean("Is Project map empty", compute='_compute_is_project_map_empty')
 
-    _sql_constraints = [
-        ('sale_line_required_task_rate', "CHECK((billable_type='task_rate' AND sale_line_id IS NOT NULL) OR (billable_type != 'task_rate'))", "The task should be linked to a sale order item, as it is billed at task rate."),
-    ]
+    @api.multi
+    @api.depends('sale_line_id', 'project_id', 'billable_type')
+    def _compute_sale_order_id(self):
+        for task in self:
+            if task.billable_type == 'task_rate':
+                task.sale_order_id = task.sale_line_id.order_id or task.project_id.sale_order_id
+            elif task.billable_type == 'employee_rate':
+                task.sale_order_id = task.project_id.sale_order_id
+            elif task.billable_type == 'no':
+                task.sale_order_id = False
+
+    @api.multi
+    @api.depends('project_id.billable_type', 'sale_line_id')
+    def _compute_billable_type(self):
+        for task in self:
+            billable_type = 'no'
+            if task.project_id.billable_type == 'employee_rate':
+                billable_type = task.project_id.billable_type
+            elif (task.project_id.billable_type in ['task_rate', 'no'] and task.sale_line_id):  # create a task in global project (non billable)
+                billable_type = 'task_rate'
+            task.billable_type = billable_type
+
+    @api.depends('project_id.sale_line_employee_ids')
+    def _compute_is_project_map_empty(self):
+        for task in self:
+            task.is_project_map_empty = not bool(task.project_id.sale_line_employee_ids)
 
     @api.onchange('project_id')
     def _onchange_project(self):
         result = super(ProjectTask, self)._onchange_project()
-        if self.project_id:
-            self.sale_line_id = self.project_id.sale_line_id
-            if not self.partner_id:
-                self.partner_id = self.sale_line_id.order_partner_id
+        self.sale_line_id = self.project_id.sale_line_id
+        if not self.parent_id and not self.partner_id:
+            self.partner_id = self.sale_line_id.order_partner_id
+        # set domain on SO: on non billable project, all SOL of customer, otherwise the one from the SO
+        result = result or {}
+        domain = [('is_service', '=', True), ('is_expense', '=', False), ('order_partner_id', '=', self.partner_id.id), ('state', 'in', ['sale', 'done'])]
+        if self.project_id.sale_order_id:
+            domain += [('sale_order_id', '=', self.project_id.sale_order_id.id)]
+        result.setdefault('domain', {})['sale_line_id'] = domain
         return result
 
     @api.onchange('partner_id')
@@ -124,33 +200,12 @@ class ProjectTask(models.Model):
                 if not task.sale_line_id.is_service or task.sale_line_id.is_expense:
                     raise ValidationError(_('You cannot link the order item %s - %s to this task because it is a re-invoiced expense.' % (task.sale_line_id.order_id.id, task.sale_line_id.product_id.name)))
 
-    @api.multi
-    @api.constrains('billable_type', 'sale_line_id')
-    def _check_billable_type(self):
-        for task in self:
-            if task.sale_line_id and task.billable_type == 'no':
-                raise ValidationError(_("A billable task should be linked to a sale order item."))
-
-    @api.model
-    def create(self, values):
-        # sub task has the same so line than their parent
-        parent_id = values['parent_id'] if 'parent_id' in values else self.env.context.get('default_parent_id')
-        if parent_id:
-            values['sale_line_id'] = self.env['project.task'].browse(parent_id).sudo().sale_line_id.id
-
-        # determine billable type from the project
-        project_id = values['project_id'] if values.get('project_id') else self.env.context.get('default_project_id')
-        if not values.get('billable_type') and project_id:
-            values['billable_type'] = self.env['project.project'].browse(project_id).billable_type
-        return super(ProjectTask, self).create(values)
-
     @api.multi
     def write(self, values):
-        # changing the project forces the billable type
         if values.get('project_id'):
-            values['billable_type'] = self.env['project.project'].browse(values['project_id']).billable_type
-        else:
-            values['billable_type'] = 'no'
+            project_dest = self.env['project.project'].browse(values['project_id'])
+            if project_dest.billable_type == 'employee_rate':
+                values['sale_line_id'] = False
         return super(ProjectTask, self).write(values)
 
     @api.multi
@@ -188,7 +243,7 @@ class ProjectTask(models.Model):
             "type": "ir.actions.act_window",
             "res_model": "sale.order",
             "views": [[False, "form"]],
-            "res_id": self.sale_line_id.order_id.id,
+            "res_id": self.sale_order_id.id,
             "context": {"create": False, "show_sale": True},
         }
 

--- a/None
+++ b/addons/sale_timesheet/models/project_sale_line_employee_map.py
@@ -0,0 +1,23 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from odoo import api, fields, models
+
+
+class ProjectProductEmployeeMap(models.Model):
+    _name = 'project.sale.line.employee.map'
+
+    @api.model
+    def _default_project_id(self):
+        if self._context.get('active_id'):
+            return self._context['active_id']
+        return False
+
+    project_id = fields.Many2one('project.project', "Project", domain=[('billable_type', '!=', 'no')], required=True, default=_default_project_id)
+    employee_id = fields.Many2one('hr.employee', "Employee", required=True)
+    sale_line_id = fields.Many2one('sale.order.line', "Sale Order Item", domain=[('is_service', '=', True)], required=True)
+    price_unit = fields.Float(related='sale_line_id.price_unit', readonly=True)
+
+    _sql_constraints = [
+        ('uniq_map_sale_line_employee_per_project', 'UNIQUE(project_id,employee_id)', 'You can only map one employee with sale order item per project.'),
+    ]

--- a/addons/sale_timesheet/models/sale_order.py
+++ b/addons/sale_timesheet/models/sale_order.py
@@ -222,7 +222,7 @@ class SaleOrderLine(models.Model):
             'analytic_account_id': account.id,
             'partner_id': self.order_id.partner_id.id,
             'sale_line_id': self.id,
-            'billable_type': 'task_rate',
+            'sale_order_id': self.order_id.id,
         }
         if self.product_id.project_template_id:
             values['name'] = "%s - %s" % (values['name'], self.product_id.project_template_id.name)
@@ -254,7 +254,6 @@ class SaleOrderLine(models.Model):
             'sale_line_id': self.id,
             'company_id': self.company_id.id,
             'user_id': False,  # force non assigned task, as created as sudo()
-            'billable_type': 'task_rate',
         }
 
     @api.multi
