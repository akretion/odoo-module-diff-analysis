PR: https://github.com/odoo/odoo/pull/122907

From: 42087c6fa1851174b045aefaf679114b314efcf9
From: vlst
Date: 2023-06-21 11:45:50

Structural Changes: 2
Total Changes: 85

[IMP] point_of_sale: Allow products to be part of multiple pos categories

Currently, a product can only be part of one `pos_category`.
This PR changes the relationship between the `product` and the `pos_category` from a `One2many` to a `Many2many`.

closes odoo/odoo#122907

Task: 3138825
Related: odoo/enterprise#41791
Related: odoo/upgrade#4739
Signed-off-by: Joseph Caburnay (jcb) <jcb@odoo.com>

================================= pseudo patch: =================================

--- a/addons/point_of_sale/models/pos_category.py
+++ b/addons/point_of_sale/models/pos_category.py
@@ -1,5 +1,8 @@
 # -*- coding: utf-8 -*-
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from typing import List, Tuple
+
 from odoo import api, fields, models, _
 from odoo.exceptions import ValidationError, UserError
 
@@ -24,14 +27,13 @@ class PosCategory(models.Model):
     # field to determine whether a pos.category has an image or not.
     has_image = fields.Boolean(compute='_compute_has_image')
 
-    def name_get(self):
-        def get_names(cat):
-            res = []
-            while cat:
-                res.append(cat.name)
-                cat = cat.parent_id
-            return res
-        return [(cat.id, " / ".join(reversed(get_names(cat)))) for cat in self if cat.name]
+    def _get_hierarchy(self) -> List[str]:
+        """ Returns a list representing the hierarchy of the categories. """
+        self.ensure_one()
+        return (self.parent_id._get_hierarchy() if self.parent_id else []) + [self.name]
+
+    def name_get(self) -> List[Tuple[int, str]]:
+        return [(category.id, " / ".join(category._get_hierarchy())) for category in self if category.name]
 
     @api.ondelete(at_uninstall=False)
     def _unlink_except_session_open(self):

--- a/addons/point_of_sale/models/pos_config.py
+++ b/addons/point_of_sale/models/pos_config.py
@@ -654,7 +654,10 @@ class PosConfig(models.Model):
                         t.available_in_pos
                     AND t.sale_ok
                     AND (t.company_id=%(company_id)s OR t.company_id IS NULL)
-                    AND %(available_categ_ids)s IS NULL OR t.pos_categ_id=ANY(%(available_categ_ids)s)
+                    AND (%(available_categ_ids)s IS NULL OR EXISTS (
+                        SELECT 1 FROM pos_category_product_template_rel
+                        WHERE product_template_id = t.id
+                        AND pos_category_id = ANY(%(available_categ_ids)s)))
                 )    OR p.id=%(tip_product_id)s
              ORDER BY t.priority DESC,
                       t.detailed_type DESC,

--- a/addons/point_of_sale/models/pos_session.py
+++ b/addons/point_of_sale/models/pos_session.py
@@ -1913,7 +1913,7 @@ class PosSession(models.Model):
             ('company_id', '=', self.config_id.company_id.id), ('company_id', '=', False)
         ]
         if self.config_id.limit_categories and self.config_id.iface_available_categ_ids:
-            domain = AND([domain, [('pos_categ_id', 'in', self.config_id.iface_available_categ_ids.ids)]])
+            domain = AND([domain, [('pos_categ_ids', 'in', self.config_id.iface_available_categ_ids.ids)]])
         if self.config_id.iface_tipproduct:
             domain = OR([domain, [('id', '=', self.config_id.tip_product_id.id)]])
 
@@ -1921,7 +1921,7 @@ class PosSession(models.Model):
             'search_params': {
                 'domain': domain,
                 'fields': [
-                    'display_name', 'lst_price', 'standard_price', 'categ_id', 'pos_categ_id', 'taxes_id', 'barcode',
+                    'display_name', 'lst_price', 'standard_price', 'categ_id', 'pos_categ_ids', 'taxes_id', 'barcode',
                     'default_code', 'to_weight', 'uom_id', 'description_sale', 'description', 'product_tmpl_id', 'tracking',
                     'write_date', 'available_in_pos', 'attribute_line_ids', 'active', 'image_128'
                 ],
@@ -2049,42 +2049,6 @@ class PosSession(models.Model):
 
         return amount
 
-    def get_total_sold_refund_per_category(self, group_by_user_id=None):
-        total_sold_per_user_per_category = {}
-        total_refund_per_user_per_category = {}
-
-        for order in self.order_ids:
-            if group_by_user_id:
-                user_id = order.user_id.id
-            else:
-                # use a user_id of 0 to keep the logic between with user group and without user group the same
-                user_id = 0
-
-            if user_id not in total_sold_per_user_per_category:
-                total_sold_per_user_per_category[user_id] = {}
-                total_refund_per_user_per_category[user_id] = {}
-
-            total_sold_per_category = total_sold_per_user_per_category[user_id]
-            total_refund_per_category = total_refund_per_user_per_category[user_id]
-
-            for line in order.lines:
-                key = line.product_id.pos_categ_id.name or "None"
-                if line.qty >= 0:
-                    if key in total_sold_per_category:
-                        total_sold_per_category[key] += line.price_subtotal_incl
-                    else:
-                        total_sold_per_category[key] = line.price_subtotal_incl
-                else:
-                    if key in total_refund_per_category:
-                        total_refund_per_category[key] += line.price_subtotal_incl
-                    else:
-                        total_refund_per_category[key] = line.price_subtotal_incl
-
-        if group_by_user_id or not total_sold_per_user_per_category:
-            return list(total_sold_per_user_per_category.items()), list(total_refund_per_user_per_category.items())
-        else:
-            return list(total_sold_per_user_per_category[0].items()), list(total_refund_per_user_per_category[0].items())
-
     def get_pos_ui_product_pricelists_by_ids(self, pricelist_ids):
         params = self._loader_params_product_pricelist()
         params['search_params']['domain'] = [('id', 'in', pricelist_ids)]

--- a/addons/point_of_sale/models/product.py
+++ b/addons/point_of_sale/models/product.py
@@ -12,7 +12,7 @@ class ProductTemplate(models.Model):
 
     available_in_pos = fields.Boolean(string='Available in POS', help='Check if you want this product to appear in the Point of Sale.', default=False)
     to_weight = fields.Boolean(string='To Weigh With Scale', help="Check if the product should be weighted using the hardware scale integration.")
-    pos_categ_id = fields.Many2one(
+    pos_categ_ids = fields.Many2many(
         'pos.category', string='Point of Sale Category',
         help="Category used in the Point of Sale.")
 

--- a/addons/point_of_sale/models/report_sale_details.py
+++ b/addons/point_of_sale/models/report_sale_details.py
@@ -272,11 +272,12 @@ class ReportSaleDetails(models.AbstractModel):
         }
 
     def _get_products_and_taxes_dict(self, line, products, taxes, currency):
-        key1 = line.product_id.product_tmpl_id.pos_categ_id.name
         key2 = (line.product_id, line.price_unit, line.discount)
-        products.setdefault(key1, {})
-        products[key1].setdefault(key2, 0.0)
-        products[key1][key2] += line.qty
+        keys1 = line.product_id.product_tmpl_id.pos_categ_ids.mapped("name")
+        for key1 in keys1:
+            products.setdefault(key1, {})
+            products[key1].setdefault(key2, 0.0)
+            products[key1][key2] += line.qty
 
         if line.tax_ids_after_fiscal_position:
             line_taxes = line.tax_ids_after_fiscal_position.sudo().compute_all(line.price_unit * (1-(line.discount or 0.0)/100.0), currency, line.qty, product=line.product_id, partner=line.order_id.partner_id or False)
@@ -293,17 +294,20 @@ class ReportSaleDetails(models.AbstractModel):
     def _get_total_and_qty_per_category(self, categories):
         all_qty = 0
         all_total = 0
+        total = lambda product: (product['quantity'] * product['price_unit']) * (100 - product['discount']) / 100
         for category_dict in categories:
             qty_cat = 0
             total_cat = 0
             for product in category_dict['products']:
                 qty_cat += product['quantity']
-                total_cat += (product['quantity'] * product['price_unit']) * (100 - product['discount']) / 100
-                product['total_paid'] = (product['quantity'] * product['price_unit']) * (100 - product['discount']) / 100
+                product['total_paid'] = total(product)
+                total_cat += product['total_paid']
             category_dict['total'] = total_cat
             category_dict['qty'] = qty_cat
-            all_qty += qty_cat
-            all_total += total_cat
+        # IMPROVEMENT: It would be better if the `products` are grouped by pos.order.line.id.
+        unique_products = list({tuple(sorted(product.items())): product for category in categories for product in category['products']}.values())
+        all_qty = sum([product['quantity'] for product in unique_products])
+        all_total = sum([total(product) for product in unique_products])
 
         return categories, {'total': all_total, 'qty': all_qty}
 
