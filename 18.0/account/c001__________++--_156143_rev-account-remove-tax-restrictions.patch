PR: https://github.com/odoo/odoo/pull/156143

From: 38e89fd3500dee697bd7764877628597b9bb8c4c
From: Antoine Boonen
Date: 2024-03-01 22:20:29

Structural Changes: 6
Total Changes: 102

[REV] account: Remove tax restrictions.

Problem
---------
Due to commit 8d77045b46a1b4a9d7fffd1111e53749d51d81e2, restrictions
were added to taxes that were used in transactions. However, this
behavior worsens user experience; users that would like to modify a tax
would have to duplicate it, update the duplicated version and modify
the tax usage where necessary.

For such reason, this process is being reverted (we keep the tracking of
the modification).

The tracking of repartition lines now also includes the sequence of the
lines since it is not restricted anymore.

Furthermore, `_message_log_repartition_lines` has been updated to log
messages when new repartition lines are added or repartition lines are
removed. It also has been update to track changes of lines by comparing
their position in the tax (rel. sequence) and not their IDs. Doing so
allows to remove unnecessary logging when, for example, users remove a
repartition line and immediately add a new one similar to the one
deleted. It also allows to not log reordering event of two similar lines.

original-commit: 8d77045b46a1b4a9d7fffd1111e53749d51d81e2
task-3450002

closes odoo/odoo#156143

X-original-commit: f98dc05a03c98b237b0b5ced7add79f0da577cc8
Signed-off-by: John Laterre (jol) <jol@odoo.com>
Signed-off-by: Antoine Boonen (aboo) <aboo@odoo.com>

================================= pseudo patch: =================================

--- a/addons/account/models/account_tax.py
+++ b/addons/account/models/account_tax.py
@@ -95,10 +95,10 @@ class AccountTax(models.Model):
           help="This dummy field lets us use another search method on the field 'name'."
                "This allows more freedom on how to search the 'name' compared to 'filter_domain'."
                "See '_search_name' and '_parse_name_search' for why this is not possible with 'filter_domain'.")
-    type_tax_use = fields.Selection(TYPE_TAX_USE, string='Tax Type', required=True, default="sale",
+    type_tax_use = fields.Selection(TYPE_TAX_USE, string='Tax Type', required=True, default="sale", tracking=True,
         help="Determines where the tax is selectable. Note: 'None' means a tax can't be used by itself, however it can still be used in a group. 'adjustment' is used to perform tax adjustment.")
     tax_scope = fields.Selection([('service', 'Services'), ('consu', 'Goods')], string="Tax Scope", help="Restrict the use of taxes to a type of product.")
-    amount_type = fields.Selection(default='percent', string="Tax Computation", required=True,
+    amount_type = fields.Selection(default='percent', string="Tax Computation", required=True, tracking=True,
         selection=[('group', 'Group of Taxes'), ('fixed', 'Fixed'), ('percent', 'Percentage of Price'), ('division', 'Percentage of Price Tax Included')],
         help="""
     - Group of Taxes: The tax is a set of sub taxes.
@@ -121,7 +121,7 @@ class AccountTax(models.Model):
     amount = fields.Float(required=True, digits=(16, 4), default=0.0, tracking=True)
     description = fields.Char(string='Description', translate=True)
     invoice_label = fields.Char(string='Label on Invoices', translate=True)
-    price_include = fields.Boolean(string='Included in Price', default=False,
+    price_include = fields.Boolean(string='Included in Price', default=False, tracking=True,
         help="Check this if the price you use on the product and invoices includes this tax.")
     include_base_amount = fields.Boolean(string='Affect Base of Subsequent Taxes', default=False, tracking=True,
         help="If set, taxes with a higher sequence than this one will be affected by it, provided they accept it.")
@@ -213,12 +213,6 @@ class AccountTax(models.Model):
             if record.tax_group_id.country_id and record.tax_group_id.country_id != record.country_id:
                 raise ValidationError(_("The tax group must have the same country_id as the tax using it."))
 
-    @api.constrains('amount_type', 'type_tax_use', 'price_include', 'include_base_amount')
-    def _constrains_fields_after_tax_is_used(self):
-        for tax in self:
-            if tax.is_used:
-                raise ValidationError(_("This tax has been used in transactions. For that reason, it is forbidden to modify this field."))
-
     @api.depends('company_id')
     def _compute_country_id(self):
         for tax in self:
@@ -292,42 +286,55 @@ class AccountTax(models.Model):
         for tax in self:
             tax.is_used = tax.id in used_taxes
 
-    @api.depends('repartition_line_ids.account_id', 'repartition_line_ids.factor_percent', 'repartition_line_ids.use_in_tax_closing', 'repartition_line_ids.tag_ids')
+    @api.depends('repartition_line_ids.account_id', 'repartition_line_ids.sequence', 'repartition_line_ids.factor_percent', 'repartition_line_ids.use_in_tax_closing', 'repartition_line_ids.tag_ids')
     def _compute_repartition_lines_str(self):
         for tax in self:
             repartition_lines_str = tax.repartition_lines_str or ""
             if tax.is_used:
-                for repartition_line in tax.repartition_line_ids:
-                    repartition_line_info = {
-                        _('id'): repartition_line.id,
+                repartition_line_info = {}
+                invoice_sequence = 0
+                refund_sequence = 0
+                for repartition_line in tax.repartition_line_ids.sorted(key=lambda r: (r.document_type, r.sequence)):
+                    # Clean sequence numbers to avoid unnecessary logging when complex
+                    # operations are executed such as:
+                    #   1. Create a invoice repartition line with a factor of 50%
+                    #   2. Delete the invoice line above
+                    #   3. Update the last refund repartition line factor to 50%
+                    sequence = (invoice_sequence := invoice_sequence + 1) if repartition_line.document_type == 'invoice' else (refund_sequence := refund_sequence + 1)
+                    repartition_line_info[(repartition_line.document_type, sequence)] = {
                         _('Factor Percent'): repartition_line.factor_percent,
-                        _('Account'): repartition_line.account_id.name or _('None'),
+                        _('Account'): repartition_line.account_id.display_name or _('None'),
                         _('Tax Grids'): repartition_line.tag_ids.mapped('name') or _('None'),
                         _('Use in tax closing'): _('True') if repartition_line.use_in_tax_closing else _('False'),
                     }
-                    repartition_lines_str += str(repartition_line_info) + '//'
-                repartition_lines_str = repartition_lines_str.strip('//')
+                repartition_lines_str = str(repartition_line_info)
             tax.repartition_lines_str = repartition_lines_str
 
-    def _message_log_repartition_lines(self, old_value_str, new_value_str):
+    def _message_log_repartition_lines(self, old_values_str, new_values_str):
         self.ensure_one()
         if not self.is_used:
             return
 
-        old_values = old_value_str.split('//')
-        new_values = new_value_str.split('//')
+        old_line_values_dict = ast.literal_eval(old_values_str)
+        new_line_values_dict = ast.literal_eval(new_values_str)
+
+        # Categorize the lines that were added/removed/modified
+        modified_lines = [
+            (line, old_line_values_dict[line], new_line_values_dict[line])
+            for line in old_line_values_dict.keys() & new_line_values_dict.keys()
+        ]
+        added_and_deleted_lines = [
+            (line, _('Removed'), old_line_values_dict[line]) if line in old_line_values_dict else (line, _('New'), new_line_values_dict[line])
+            for line in old_line_values_dict.keys() ^ new_line_values_dict.keys()
+        ]
 
-        kwargs = {}
-        for old_value, new_value in zip(old_values, new_values):
-            if old_value != new_value:
-                old_value = ast.literal_eval(old_value)
-                new_value = ast.literal_eval(new_value)
-                diff_keys = [key for key in old_value if old_value[key] != new_value[key]]
-                repartition_line = self.env['account.tax.repartition.line'].search([('id', '=', new_value['id'])])
+        for (document_type, sequence), old_value, new_value in modified_lines:
+            diff_keys = [key for key in old_value if old_value[key] != new_value[key]]
+            if diff_keys:
                 body = Markup("<b>{type}</b> {rep} {seq}:<ul class='mb-0 ps-4'>{changes}</ul>").format(
-                    type=repartition_line.document_type.capitalize(),
+                    type=document_type.capitalize(),
                     rep=_('repartition line'),
-                    seq=repartition_line.sequence + 1,
+                    seq=sequence,
                     changes=Markup().join(
                         [Markup("""
                             <li>
@@ -335,12 +342,31 @@ class AccountTax(models.Model):
                                 <i class='o-mail-Message-trackingSeparator fa fa-long-arrow-right mx-1 text-600'/>
                                 <span class='o-mail-Message-trackingNew me-1 fw-bold text-info'>{new}</span>
                                 <span class='o-mail-Message-trackingField ms-1 fst-italic text-muted'>({diff})</span>
-                            </li>""").format(old=old_value[diff_key], new=new_value[diff_key], diff=diff_key)
+                            </li>
+                        """).format(old=old_value[diff_key], new=new_value[diff_key], diff=diff_key)
                         for diff_key in diff_keys]
                     )
                 )
-                kwargs['body'] = body
-                super()._message_log(**kwargs)
+                super()._message_log(body=body)
+
+        for (document_type, sequence), operation, value in added_and_deleted_lines:
+            body = Markup("<b>{op} {type}</b> {rep} {seq}:<ul class='mb-0 ps-4'>{changes}</ul>").format(
+                op=operation,
+                type=document_type.capitalize(),
+                rep=_('repartition line'),
+                seq=sequence,
+                changes=Markup().join(
+                    [Markup("""
+                        <li>
+                            <span class='o-mail-Message-trackingNew me-1 fw-bold text-info'>{value}</span>
+                            <span class='o-mail-Message-trackingField ms-1 fst-italic text-muted'>({diff})</span>
+                        </li>
+                    """).format(value=value[key], diff=key)
+                    for key in value]
+                )
+            )
+            super()._message_log(body=body)
+        return
 
     def _message_log(self, **kwargs):
         # OVERRIDE _message_log
@@ -1986,20 +2012,6 @@ class AccountTaxRepartitionLine(models.Model):
 
     tag_ids_domain = fields.Binary(string="tag domain", help="Dynamic domain used for the tag that can be set on tax", compute="_compute_tag_ids_domain")
 
-    @api.model_create_multi
-    def create(self, vals):
-        tax_ids = {tax_id for line in vals if (tax_id := line.get('tax_id'))}
-        taxes = self.env['account.tax'].browse(tax_ids)
-        for tax in taxes.filtered('is_used'):
-            raise ValidationError(_("The tax named %s has already been used, you cannot add nor delete its tax repartition lines.", tax.name))
-        return super().create(vals)
-
-    @api.ondelete(at_uninstall=False)
-    def _check_tax_use(self):
-        for repartition_line in self:
-            if repartition_line.tax_id.is_used:
-                raise ValidationError(_("The tax named %s has already been used, you cannot add nor delete its tax repartition lines.", repartition_line.tax_id.name))
-
     @api.depends('company_id.multi_vat_foreign_country_ids', 'company_id.account_fiscal_country_id')
     def _compute_tag_ids_domain(self):
         for rep_line in self:
