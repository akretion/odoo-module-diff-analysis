PR: https://github.com/odoo/odoo/pull/

From: baa4dde1bb246f571d07de95511e9e2aeceea235
From: Arnaud Joset
Date: 2021-02-26 07:42:24

Structural Changes: 9
Total Changes: 380

[MOV] hr_work_entry_holidays: move to community.

Before this commit, the module dependencies: hr_holidays and hr_work_entry were already defined in community.
As they could be integrated with some community applications, like hr_attendance or hr_holidays, it is more coherent to move them to community.

Taskid: 2222790

================================= pseudo patch: =================================

--- a/None
+++ b/addons/hr_work_entry_holidays/models/__init__.py
@@ -0,0 +1,5 @@
+# -*- coding: utf-8 -*-
+
+from . import hr_contract
+from . import hr_leave
+from . import hr_work_entry

--- a/None
+++ b/addons/hr_work_entry_holidays/models/hr_contract.py
@@ -0,0 +1,73 @@
+# -*- coding:utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+import pytz
+
+from datetime import date
+from odoo import api, models
+
+
+class HrContract(models.Model):
+    _inherit = 'hr.contract'
+    _description = 'Employee Contract'
+
+    @api.constrains('date_start', 'date_end', 'state')
+    def _check_contracts(self):
+        self._get_leaves()._check_contracts()
+
+    def _get_leaves(self):
+        return self.env['hr.leave'].search([
+            ('employee_id', 'in', self.mapped('employee_id.id')),
+            ('date_from', '<=', max([end or date.max for end in self.mapped('date_end')])),
+            ('date_to', '>=', min(self.mapped('date_start'))),
+        ])
+
+    # override to add work_entry_type from leave
+    def _get_leave_work_entry_type(self, leave):
+        if leave.holiday_id:
+            return leave.holiday_id.holiday_status_id.work_entry_type_id
+        else:
+            return leave.work_entry_type_id
+
+    # YTI TODO: Master remove the method (deprecated)
+    def _get_more_vals_leave(self, leave):
+        return [('leave_id', leave.holiday_id and leave.holiday_id.id)]
+
+    def _get_more_vals_leave_interval(self, interval, leaves):
+        result = super()._get_more_vals_leave_interval(interval, leaves)
+        for leave in leaves:
+            if interval[0] >= leave[0] and interval[1] <= leave[1]:
+                result.append(('leave_id', leave[2].holiday_id.id))
+        return result
+
+    def _get_bypassing_work_entry_type(self):
+        return self.env['hr.work.entry.type']
+
+    def _get_interval_leave_work_entry_type(self, interval, leaves):
+        # returns the work entry time related to the leave that
+        # includes the whole interval.
+        # Overriden in hr_work_entry_contract_holiday to select the
+        # global time off first (eg: Public Holiday > Home Working)
+        interval_start = interval[0].astimezone(pytz.utc).replace(tzinfo=None)
+        interval_stop = interval[1].astimezone(pytz.utc).replace(tzinfo=None)
+        including_rcleaves = [l[2] for l in leaves if l[2] and interval_start >= l[2].date_from and interval_stop <= l[2].date_to]
+        including_global_rcleaves = [l for l in including_rcleaves if not l.holiday_id]
+        including_holiday_rcleaves = [l for l in including_rcleaves if l.holiday_id]
+        rc_leave = False
+
+        # Example: In CP200: Long term sick > Public Holidays (which is global)
+        bypassing_work_entry_types = self._get_bypassing_work_entry_type()
+        if bypassing_work_entry_types:
+            bypassing_rc_leave = [l for l in including_holiday_rcleaves if l.holiday_id.holiday_status_id.work_entry_type_id in bypassing_work_entry_types]
+        else:
+            bypassing_rc_leave = []
+
+        if bypassing_rc_leave:
+            rc_leave = bypassing_rc_leave[0]
+        elif including_global_rcleaves:
+            rc_leave = including_global_rcleaves[0]
+        elif including_holiday_rcleaves:
+            rc_leave = including_holiday_rcleaves[0]
+        if rc_leave:
+            return self._get_leave_work_entry_type_dates(rc_leave, interval_start, interval_stop)
+        return self.env.ref('hr_work_entry_contract.work_entry_type_leave')

--- a/None
+++ b/addons/hr_work_entry_holidays/models/hr_leave.py
@@ -0,0 +1,210 @@
+# -*- coding:utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from collections import defaultdict
+from datetime import datetime, date
+
+from odoo import api, fields, models, _
+from odoo.exceptions import ValidationError
+
+
+class HrLeaveType(models.Model):
+    _inherit = 'hr.leave.type'
+
+    work_entry_type_id = fields.Many2one('hr.work.entry.type', string='Work Entry Type')
+
+
+class HrLeave(models.Model):
+    _inherit = 'hr.leave'
+
+    def _create_resource_leave(self):
+        """
+        Add a resource leave in calendars of contracts running at the same period.
+        This is needed in order to compute the correct number of hours/days of the leave
+        according to the contract's calender.
+        """
+        resource_leaves = super(HrLeave, self)._create_resource_leave()
+        for resource_leave in resource_leaves:
+            resource_leave.work_entry_type_id = resource_leave.holiday_id.holiday_status_id.work_entry_type_id.id
+
+        resource_leave_values = []
+
+        for leave in self.filtered(lambda l: l.employee_id):
+
+            contract = leave.employee_id.sudo()._get_contracts(leave.date_from, leave.date_to, states=['open'])
+            if contract and contract.resource_calendar_id != leave.employee_id.resource_calendar_id:
+                resource_leave_values += [{
+                    'name': leave.name,
+                    'holiday_id': leave.id,
+                    'resource_id': leave.employee_id.resource_id.id,
+                    'work_entry_type_id': leave.holiday_status_id.work_entry_type_id.id,
+                    'time_type': leave.holiday_status_id.time_type,
+                    'date_from': max(leave.date_from, datetime.combine(contract.date_start, datetime.min.time())),
+                    'date_to': min(leave.date_to, datetime.combine(contract.date_end or date.max, datetime.max.time())),
+                    'calendar_id': contract.resource_calendar_id.id,
+                }]
+
+        return resource_leaves | self.env['resource.calendar.leaves'].create(resource_leave_values)
+
+    @api.constrains('date_from', 'date_to')
+    def _check_contracts(self):
+        """
+            A leave cannot be set across multiple contracts.
+            Note: a leave can be across multiple contracts despite this constraint.
+            It happens if a leave is correctly created (not accross multiple contracts) but
+            contracts are later modifed/created in the middle of the leave.
+        """
+        for holiday in self.filtered('employee_id'):
+            domain = [
+                ('employee_id', '=', holiday.employee_id.id),
+                ('date_start', '<=', holiday.date_to),
+                '|',
+                ('state', 'not in', ['draft', 'cancel']),
+                '&',
+                ('state', '=', 'draft'),
+                ('kanban_state', '=', 'done'),
+                '|',
+                    ('date_end', '>=', holiday.date_from),
+                    '&',
+                        ('date_end', '=', False),
+                        ('state', '!=', 'close')
+            ]
+            nbr_contracts = self.env['hr.contract'].sudo().search_count(domain)
+            if nbr_contracts > 1:
+                contracts = self.env['hr.contract'].sudo().search(domain)
+                raise ValidationError(_('A leave cannot be set across multiple contracts.') + '\n' + ', '.join(contracts.mapped('name')))
+
+    def _cancel_work_entry_conflict(self):
+        """
+        Creates a leave work entry for each hr.leave in self.
+        Check overlapping work entries with self.
+        Work entries completely included in a leave are archived.
+        e.g.:
+            |----- work entry ----|---- work entry ----|
+                |------------------- hr.leave ---------------|
+                                    ||
+                                    vv
+            |----* work entry ****|
+                |************ work entry leave --------------|
+        """
+        if not self:
+            return
+
+        # 1. Create a work entry for each leave
+        work_entries_vals_list = []
+        for leave in self:
+            contracts = leave.employee_id.sudo()._get_contracts(leave.date_from, leave.date_to, states=['open', 'close'])
+            for contract in contracts:
+                # Generate only if it has aleady been generated
+                if leave.date_to >= contract.date_generated_from and leave.date_from <= contract.date_generated_to:
+                    work_entries_vals_list += contracts._get_work_entries_values(leave.date_from, leave.date_to)
+
+        new_leave_work_entries = self.env['hr.work.entry'].create(work_entries_vals_list)
+
+        if new_leave_work_entries:
+            # 2. Fetch overlapping work entries, grouped by employees
+            start = min(self.mapped('date_from'), default=False)
+            stop = max(self.mapped('date_to'), default=False)
+            work_entry_groups = self.env['hr.work.entry'].read_group([
+                ('date_start', '<', stop),
+                ('date_stop', '>', start),
+                ('employee_id', 'in', self.employee_id.ids),
+            ], ['work_entry_ids:array_agg(id)', 'employee_id'], ['employee_id', 'date_start', 'date_stop'], lazy=False)
+            work_entries_by_employee = defaultdict(lambda: self.env['hr.work.entry'])
+            for group in work_entry_groups:
+                employee_id = group.get('employee_id')[0]
+                work_entries_by_employee[employee_id] |= self.env['hr.work.entry'].browse(group.get('work_entry_ids'))
+
+            # 3. Archive work entries included in leaves
+            included = self.env['hr.work.entry']
+            overlappping = self.env['hr.work.entry']
+            for work_entries in work_entries_by_employee.values():
+                # Work entries for this employee
+                new_employee_work_entries = work_entries & new_leave_work_entries
+                previous_employee_work_entries = work_entries - new_leave_work_entries
+
+                # Build intervals from work entries
+                leave_intervals = new_employee_work_entries._to_intervals()
+                conflicts_intervals = previous_employee_work_entries._to_intervals()
+
+                # Compute intervals completely outside any leave
+                # Intervals are outside, but associated records are overlapping.
+                outside_intervals = conflicts_intervals - leave_intervals
+
+                overlappping |= self.env['hr.work.entry']._from_intervals(outside_intervals)
+                included |= previous_employee_work_entries - overlappping
+            overlappping.write({'leave_id': False})
+            included.write({'active': False})
+
+    def write(self, vals):
+        if not self:
+            return True
+        skip_check = not bool({'employee_id', 'state', 'date_from', 'date_to'} & vals.keys())
+
+        start = min(self.mapped('date_from') + [fields.Datetime.from_string(vals.get('date_from', False)) or datetime.max])
+        stop = max(self.mapped('date_to') + [fields.Datetime.from_string(vals.get('date_to', False)) or datetime.min])
+        with self.env['hr.work.entry']._error_checking(start=start, stop=stop, skip=skip_check):
+            return super().write(vals)
+
+    @api.model_create_multi
+    def create(self, vals_list):
+        start_dates = [v.get('date_from') for v in vals_list if v.get('date_from')]
+        stop_dates = [v.get('date_to') for v in vals_list if v.get('date_to')]
+        if any(vals.get('holiday_type', 'employee') == 'employee' and not vals.get('employee_id', False) for vals in vals_list):
+            raise ValidationError(_("There is no employee set on the time off. Please make sure you're logged in the correct company."))
+        with self.env['hr.work.entry']._error_checking(start=min(start_dates, default=False), stop=max(stop_dates, default=False)):
+            return super().create(vals_list)
+
+    def action_confirm(self):
+        start = min(self.mapped('date_from'), default=False)
+        stop = max(self.mapped('date_to'), default=False)
+        with self.env['hr.work.entry']._error_checking(start=start, stop=stop):
+            return super().action_confirm()
+
+    def action_validate(self):
+        super(HrLeave, self).action_validate()
+        self.sudo()._cancel_work_entry_conflict()  # delete preexisting conflicting work_entries
+        return True
+
+    def action_refuse(self):
+        """
+        Override to archive linked work entries and recreate attendance work entries
+        where the refused leave was.
+        """
+        res = super(HrLeave, self).action_refuse()
+        work_entries = self.env['hr.work.entry'].sudo().search([('leave_id', 'in', self.ids)])
+
+        work_entries.write({'active': False})
+        # Re-create attendance work entries
+        vals_list = []
+        for work_entry in work_entries:
+            vals_list += work_entry.contract_id._get_work_entries_values(work_entry.date_start, work_entry.date_stop)
+        self.env['hr.work.entry'].create(vals_list)
+        return res
+
+    def _get_number_of_days(self, date_from, date_to, employee_id):
+        """ If an employee is currently working full time but requests a leave next month
+            where he has a new contract working only 3 days/week. This should be taken into
+            account when computing the number of days for the leave (2 weeks leave = 6 days).
+            Override this method to get number of days according to the contract's calendar
+            at the time of the leave.
+        """
+        days = super(HrLeave, self)._get_number_of_days(date_from, date_to, employee_id)
+        if employee_id:
+            employee = self.env['hr.employee'].browse(employee_id)
+            # Use sudo otherwise base users can't compute number of days
+            contracts = employee.sudo()._get_contracts(date_from, date_to, states=['open'])
+            contracts |= employee.sudo()._get_incoming_contracts(date_from, date_to)
+            calendar = contracts[:1].resource_calendar_id if contracts else None # Note: if len(contracts)>1, the leave creation will crash because of unicity constaint
+            return employee._get_work_days_data_batch(date_from, date_to, calendar=calendar)[employee.id]
+
+        return days
+
+    def _get_calendar(self):
+        self.ensure_one()
+        if self.date_from and self.date_to:
+            contracts = self.employee_id.sudo()._get_contracts(self.date_from, self.date_to, states=['open'])
+            contracts |= self.employee_id.sudo()._get_incoming_contracts(self.date_from, self.date_to)
+            contract_calendar = contracts[:1].resource_calendar_id if contracts else None
+            return contract_calendar or self.employee_id.resource_calendar_id or self.env.company.resource_calendar_id
+        return super()._get_calendar()

--- a/None
+++ b/addons/hr_work_entry_holidays/models/hr_work_entry.py
@@ -0,0 +1,92 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from odoo import api, fields, models
+
+
+class HrWorkEntry(models.Model):
+    _inherit = 'hr.work.entry'
+
+    leave_id = fields.Many2one('hr.leave', string='Time Off')
+    leave_state = fields.Selection(related='leave_id.state')
+
+    def _get_duration(self, date_start, date_stop):
+        if not date_start or not date_stop:
+            return 0
+        if not self.work_entry_type_id and self.leave_id:
+            calendar = self.contract_id.resource_calendar_id
+            employee = self.contract_id.employee_id
+            contract_data = employee._get_work_days_data_batch(
+                date_start, date_stop, compute_leaves=False, calendar=calendar)[employee.id]
+            return contract_data.get('hours', 0)
+        return super()._get_duration(date_start, date_stop)
+
+    def write(self, vals):
+        if 'state' in vals and vals['state'] == 'cancelled':
+            self.mapped('leave_id').filtered(lambda l: l.state != 'refuse').action_refuse()
+        return super().write(vals)
+
+    def _reset_conflicting_state(self):
+        super()._reset_conflicting_state()
+        attendances = self.filtered(lambda w: w.work_entry_type_id and not w.work_entry_type_id.is_leave)
+        attendances.write({'leave_id': False})
+
+    def _check_if_error(self):
+        res = super()._check_if_error()
+        conflict_with_leaves = self._compute_conflicts_leaves_to_approve()
+        return res or conflict_with_leaves
+
+    def _compute_conflicts_leaves_to_approve(self):
+        if not self:
+            return False
+
+        self.flush(['date_start', 'date_stop', 'employee_id'])
+        self.env['hr.leave'].flush(['date_from', 'date_to', 'state', 'employee_id'])
+
+        query = """
+            SELECT
+                b.id AS work_entry_id,
+                l.id AS leave_id
+            FROM hr_work_entry b
+            INNER JOIN hr_leave l ON b.employee_id = l.employee_id
+            WHERE
+                b.active = TRUE AND
+                b.id IN %s AND
+                l.date_from < b.date_stop AND
+                l.date_to > b.date_start AND
+                l.state IN ('confirm', 'validate1');
+        """
+        self.env.cr.execute(query, [tuple(self.ids)])
+        conflicts = self.env.cr.dictfetchall()
+        for res in conflicts:
+            self.browse(res.get('work_entry_id')).write({
+                'state': 'conflict',
+                'leave_id': res.get('leave_id')
+            })
+        return bool(conflicts)
+
+    def action_approve_leave(self):
+        self.ensure_one()
+        if self.leave_id:
+            # Already confirmed once
+            if self.leave_id.state == 'validate1':
+                self.leave_id.action_validate()
+            # Still in confirmed state
+            else:
+                self.leave_id.action_approve()
+                # If double validation, still have to validate it again
+                if self.leave_id.validation_type == 'both':
+                    self.leave_id.action_validate()
+
+    def action_refuse_leave(self):
+        self.ensure_one()
+        leave_sudo = self.leave_id.sudo()
+        if leave_sudo:
+            leave_sudo.action_refuse()
+
+
+class HrWorkEntryType(models.Model):
+    _inherit = 'hr.work.entry.type'
+    _description = 'HR Work Entry Type'
+
+    leave_type_ids = fields.One2many('hr.leave.type', 'work_entry_type_id', string='Time Off Type')
