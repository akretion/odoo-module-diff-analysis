PR: https://github.com/odoo/odoo/pull/51141

From: b2f8170d88239b5eaf04f1e3c0dcef613b78fedc
From: Joseph Caburnay
Date: 2020-07-17 10:00:04

Structural Changes: 5
Total Changes: 94

[IMP] point_of_sale,pos_*: allow users to manage orders in the pos frontend

We now allow invoicing of finalized orders in an open session in this first
iteration of order management in the pos frontend. Additionally, receipt
reprinting is also introduced. With this feature, we can now reprint the
receipt of old orders.

closes odoo/odoo#51141

Task-id: 1981354
Related: odoo/enterprise#11690
Related: odoo/upgrade#1472
Signed-off-by: pimodoo <pimodoo@users.noreply.github.com>

================================= pseudo patch: =================================

--- a/addons/point_of_sale/models/pos_config.py
+++ b/addons/point_of_sale/models/pos_config.py
@@ -201,7 +201,7 @@ class PosConfig(models.Model):
     module_pos_discount = fields.Boolean("Global Discounts")
     module_pos_loyalty = fields.Boolean("Loyalty Program")
     module_pos_mercury = fields.Boolean(string="Integrated Card Payments")
-    module_pos_reprint = fields.Boolean(string="Reprint Receipt")
+    manage_orders = fields.Boolean(string="Manage Orders")
     is_posbox = fields.Boolean("PosBox")
     is_header_or_footer = fields.Boolean("Header & Footer")
     module_pos_hr = fields.Boolean(help="Show employee login screen")
@@ -217,6 +217,7 @@ class PosConfig(models.Model):
     cash_rounding = fields.Boolean(string="Cash Rounding")
     only_round_cash_method = fields.Boolean(string="Only apply rounding on cash")
     has_active_session = fields.Boolean(compute='_compute_current_session')
+    show_allow_invoicing_alert = fields.Boolean(compute="_compute_show_allow_invoicing_alert")
 
     @api.depends('use_pricelist', 'available_pricelist_ids')
     def _compute_allowed_pricelist_ids(self):
@@ -260,6 +261,14 @@ class PosConfig(models.Model):
             pos_config.current_session_id = session and session[0].id or False
             pos_config.current_session_state = session and session[0].state or False
 
+    @api.depends('module_account', 'manage_orders')
+    def _compute_show_allow_invoicing_alert(self):
+        for pos_config in self:
+            if not pos_config.manage_orders:
+                pos_config.show_allow_invoicing_alert = False
+            else:
+                pos_config.show_allow_invoicing_alert = not pos_config.module_account
+
     @api.depends('session_ids')
     def _compute_last_session(self):
         PosSession = self.env['pos.session']

--- a/addons/point_of_sale/models/pos_order.py
+++ b/addons/point_of_sale/models/pos_order.py
@@ -177,6 +177,7 @@ class PosOrder(models.Model):
                 'amount': -pos_order['amount_return'],
                 'payment_date': fields.Date.context_today(self),
                 'payment_method_id': cash_payment_method.id,
+                'is_change': True,
             }
             order.add_payment(return_payment_vals)
 
@@ -253,7 +254,6 @@ class PosOrder(models.Model):
     to_invoice = fields.Boolean('To invoice')
     is_invoiced = fields.Boolean('Is Invoiced', compute='_compute_is_invoiced')
 
-
     @api.depends('account_move')
     def _compute_is_invoiced(self):
         for order in self:
@@ -572,6 +572,48 @@ class PosOrder(models.Model):
         orders.sudo().unlink()
         return orders.ids
 
+    @api.model
+    def search_paid_order_ids(self, config_id, domain, limit, offset):
+        """Search for 'paid' orders that satisfy the given domain, limit and offset."""
+        default_domain = ['&', ('config_id', '=', config_id), '!', '|', ('state', '=', 'draft'), ('state', '=', 'cancelled')]
+        real_domain = AND([domain, default_domain])
+        ids = self.search(AND([domain, default_domain]), limit=limit, offset=offset).ids
+        totalCount = self.search_count(real_domain)
+        return {'ids': ids, 'totalCount': totalCount}
+
+    def _export_for_ui(self, order):
+        timezone = pytz.timezone(self._context.get('tz') or self.env.user.tz or 'UTC')
+        return {
+            'lines': [[0, 0, line] for line in order.lines.export_for_ui()],
+            'statement_ids': [[0, 0, payment] for payment in order.payment_ids.export_for_ui()],
+            'name': order.pos_reference,
+            'uid': order.pos_reference[6:],
+            'amount_paid': order.amount_paid,
+            'amount_total': order.amount_total,
+            'amount_tax': order.amount_tax,
+            'amount_return': order.amount_return,
+            'pos_session_id': order.session_id.id,
+            'is_session_closed': order.session_id.state == 'closed',
+            'pricelist_id': order.pricelist_id.id,
+            'partner_id': order.partner_id.id,
+            'user_id': order.user_id.id,
+            'sequence_number': order.sequence_number,
+            'creation_date': order.date_order.astimezone(timezone),
+            'fiscal_position_id': order.fiscal_position_id.id,
+            'to_invoice': order.to_invoice,
+            'state': order.state,
+            'account_move': order.account_move.id,
+            'id': order.id,
+        }
+
+    def export_for_ui(self):
+        """ Returns a list of dict with each item having similar signature as the return of
+            `export_as_JSON` of models.Order. This is useful for back-and-forth communication
+            between the pos frontend and backend.
+        """
+        return self.mapped(self._export_for_ui) if self else []
+
+
 class PosOrderLine(models.Model):
     _name = "pos.order.line"
     _description = "Point of Sale Order Lines"
@@ -702,6 +744,22 @@ class PosOrderLine(models.Model):
         for line in self:
             line.tax_ids_after_fiscal_position = line.order_id.fiscal_position_id.map_tax(line.tax_ids, line.product_id, line.order_id.partner_id)
 
+    def _export_for_ui(self, orderline):
+        return {
+            'qty': orderline.qty,
+            'price_unit': orderline.price_unit,
+            'price_subtotal': orderline.price_subtotal,
+            'price_subtotal_incl': orderline.price_subtotal_incl,
+            'product_id': orderline.product_id.id,
+            'discount': orderline.discount,
+            'tax_ids': [[6, False, orderline.tax_ids.mapped(lambda tax: tax.id)]],
+            'id': orderline.id,
+            'pack_lot_ids': [[0, 0, lot] for lot in orderline.pack_lot_ids.export_for_ui()],
+        }
+
+    def export_for_ui(self):
+        return self.mapped(self._export_for_ui) if self else []
+
 
 class PosOrderLineLot(models.Model):
     _name = "pos.pack.operation.lot"
@@ -713,6 +771,13 @@ class PosOrderLineLot(models.Model):
     lot_name = fields.Char('Lot Name')
     product_id = fields.Many2one('product.product', related='pos_order_line_id.product_id', readonly=False)
 
+    def _export_for_ui(self, lot):
+        return {
+            'lot_name': lot.lot_name,
+        }
+
+    def export_for_ui(self):
+        return self.mapped(self._export_for_ui) if self else []
 
 class ReportSaleDetails(models.AbstractModel):
 

--- a/addons/point_of_sale/models/pos_payment.py
+++ b/addons/point_of_sale/models/pos_payment.py
@@ -27,6 +27,8 @@ class PosPayment(models.Model):
     card_type = fields.Char('Type of card used')
     transaction_id = fields.Char('Payment Transaction ID')
     payment_status = fields.Char('Payment Status')
+    ticket = fields.Char('Payment Receipt Info')
+    is_change = fields.Boolean(string='Is this payment change?', default=False)
 
     @api.model
     def name_get(self):
@@ -37,3 +39,17 @@ class PosPayment(models.Model):
             else:
                 res.append((payment.id, formatLang(self.env, payment.amount, currency_obj=payment.currency_id)))
         return res
+
+    def _export_for_ui(self, payment):
+        return {
+            'payment_method_id': payment.payment_method_id.id,
+            'amount': payment.amount,
+            'payment_status': payment.payment_status,
+            'card_type': payment.card_type,
+            'transaction_id': payment.transaction_id,
+            'ticket': payment.ticket,
+            'is_change': payment.is_change,
+        }
+
+    def export_for_ui(self):
+        return self.mapped(self._export_for_ui) if self else []
