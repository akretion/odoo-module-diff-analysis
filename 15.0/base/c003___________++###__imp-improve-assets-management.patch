PR: https://github.com/odoo/odoo/pull/

From: 8cc066173dfb61bd95b8e1f0716f71f4e251810a
From: Julien Mougenot
Date: 2021-03-31 11:57:17

Structural Changes: 7
Total Changes: 624

[IMP] *: Improve assets management

This commit changes the way assets are declared in Odoo modules.

Before: assets were declared in template files. Template bundles were
generated from primary templates, so technically any qweb template could
have been called as an asset bundle, with the 't-call-assets' directive.

Being standard qweb templates, they had access to standard HTML tags
(script, link, with or without raw scripts or style definition), qweb
directives (t-call, t-raw, etc.) and could be inherited by other
templates.

Now: assets are defined in the module's manifest and generated by the
't-call-assets' directive.

More information on the new system can be found on the updated user
documentation (see the "JavaScript Reference" section).

Task: 2352566

Co-authored-by: Bruno Boi <boi@odoo.com>
Co-authored-by: Julien Mougenot <jum@odoo.com>
Co-authored-by: Lucas Perais <lpe@odoo.com>
Co-authored-by: Mathieu Duckerts-Antoine <dam@odoo.com>
Co-authored-by: Raphael Collet <rco@odoo.com>
Co-authored-by: Simon Genin <ges@odoo.com>

================================= pseudo patch: =================================

--- a/odoo/addons/base/__manifest__.py
+++ b/odoo/addons/base/__manifest__.py
@@ -28,6 +28,7 @@ The kernel of Odoo, needed for all installation.
         'views/res_config_views.xml',
         'data/res.country.state.csv',
         'views/ir_actions_views.xml',
+        'views/ir_asset_views.xml',
         'views/ir_config_parameter_views.xml',
         'views/ir_cron_views.xml',
         'views/ir_cron_trigger_views.xml',

--- a/odoo/addons/base/models/__init__.py
+++ b/odoo/addons/base/models/__init__.py
@@ -8,6 +8,7 @@ from . import ir_model
 from . import ir_sequence
 from . import ir_ui_menu
 from . import ir_ui_view
+from . import ir_asset
 from . import ir_actions
 from . import ir_actions_report
 from . import ir_attachment

--- a/odoo/addons/base/models/assetsbundle.py
+++ b/odoo/addons/base/models/assetsbundle.py
@@ -122,6 +122,7 @@ class AssetsBundle(object):
         self.user_direction = self.env['res.lang']._lang_get(
             self.env.context.get('lang') or self.env.user.lang
         ).direction
+        # asset-wide html "media" attribute
         for f in files:
             if css:
                 if f['atype'] == 'text/sass':
@@ -154,7 +155,7 @@ class AssetsBundle(object):
                     ["type", "text/css"],
                     ["rel", "stylesheet"],
                     ["href", href],
-                    ['data-asset-xmlid', self.name],
+                    ['data-asset-bundle', self.name],
                     ['data-asset-version', self.version],
                 ])
                 response.append(("link", attr, None))
@@ -171,7 +172,7 @@ class AssetsBundle(object):
                 ["defer", "defer" if defer_load or lazy_load else None],
                 ["type", "text/javascript"],
                 ["data-src" if lazy_load else "src", src],
-                ['data-asset-xmlid', self.name],
+                ['data-asset-bundle', self.name],
                 ['data-asset-version', self.version],
             ])
             response.append(("script", attr, None))
@@ -343,7 +344,7 @@ class AssetsBundle(object):
             channel = (self.env.registry.db_name, 'bundle_changed')
             message = (self.name, self.version)
             self.env['bus.bus'].sendone(channel, message)
-            _logger.debug('Asset Changed:  xml_id: %s -- version: %s' % message)
+            _logger.debug('Asset Changed: bundle: %s -- version: %s', message, message)
 
         return attachment
 
@@ -822,14 +823,14 @@ class JavascriptAsset(WebAsset):
             return ("script", OrderedDict([
                 ["type", "text/javascript"],
                 ["src", self.html_url],
-                ['data-asset-xmlid', self.bundle.name],
+                ['data-asset-bundle', self.bundle.name],
                 ['data-asset-version', self.bundle.version],
             ]), None)
         else:
             return ("script", OrderedDict([
                 ["type", "text/javascript"],
                 ["charset", "utf-8"],
-                ['data-asset-xmlid', self.bundle.name],
+                ['data-asset-bundle', self.bundle.name],
                 ['data-asset-version', self.bundle.version],
             ]), self.with_header())
 
@@ -927,7 +928,7 @@ class StylesheetAsset(WebAsset):
                 ["rel", "stylesheet"],
                 ["href", self.html_url],
                 ["media", escape(to_text(self.media)) if self.media else None],
-                ['data-asset-xmlid', self.bundle.name],
+                ['data-asset-bundle', self.bundle.name],
                 ['data-asset-version', self.bundle.version],
             ])
             return ("link", attr, None)
@@ -935,7 +936,7 @@ class StylesheetAsset(WebAsset):
             attr = OrderedDict([
                 ["type", "text/css"],
                 ["media", escape(to_text(self.media)) if self.media else None],
-                ['data-asset-xmlid', self.bundle.name],
+                ['data-asset-bundle', self.bundle.name],
                 ['data-asset-version', self.bundle.version],
             ])
             return ("style", attr, self.with_header())

--- a/None
+++ b/odoo/addons/base/models/ir_asset.py
@@ -0,0 +1,425 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+import os
+
+from glob import glob
+from logging import getLogger
+from werkzeug import urls
+
+import odoo
+from odoo.tools import misc
+from odoo import tools
+from odoo.addons import __path__ as ADDONS_PATH
+from odoo import api, fields, http, models
+
+_logger = getLogger(__name__)
+
+SCRIPT_EXTENSIONS = ('js',)
+STYLE_EXTENSIONS = ('css', 'scss', 'sass', 'less')
+TEMPLATE_EXTENSIONS = ('xml',)
+DEFAULT_SEQUENCE = 16
+
+# Directives are stored in variables for ease of use and syntax checks.
+APPEND_DIRECTIVE = 'append'
+PREPEND_DIRECTIVE = 'prepend'
+AFTER_DIRECTIVE = 'after'
+BEFORE_DIRECTIVE = 'before'
+REMOVE_DIRECTIVE = 'remove'
+REPLACE_DIRECTIVE = 'replace'
+INCLUDE_DIRECTIVE = 'include'
+# Those are the directives used with a 'target' argument/field.
+DIRECTIVES_WITH_TARGET = [AFTER_DIRECTIVE, BEFORE_DIRECTIVE, REPLACE_DIRECTIVE]
+WILDCARD_CHARACTERS = {'*', "?", "[", "]"}
+
+
+def fs2web(path):
+    """Converts a file system path to a web path"""
+    return '/'.join(os.path.split(path))
+
+def can_aggregate(url):
+    parsed = urls.url_parse(url)
+    return not parsed.scheme and not parsed.netloc and not url.startswith('/web/content')
+
+def is_wildcard_glob(path):
+    """Determine whether a path is a wildcarded glob eg: "/web/file[14].*"
+    or a genuine single file path "/web/myfile.scss"""
+    return not WILDCARD_CHARACTERS.isdisjoint(path)
+
+
+class IrAsset(models.Model):
+    """This model contributes to two things:
+
+        1. It provides a function returning a list of all file paths declared
+        in a given list of addons (see _get_addon_paths);
+
+        2. It allows to create 'ir.asset' records to add additional directives
+        to certain bundles.
+    """
+    _name = 'ir.asset'
+    _description = 'Asset'
+    _order = 'sequence, id'
+
+    @api.model_create_multi
+    def create(self, vals_list):
+        self.clear_caches()
+        return super().create(vals_list)
+
+    def write(self, values):
+        self.clear_caches()
+        return super().write(values)
+
+    def unlink(self):
+        self.clear_caches()
+        return super().unlink()
+
+    name = fields.Char(string='Name', required=True)
+    bundle = fields.Char(string='Bundle name', required=True)
+    directive = fields.Selection(string='Directive', selection=[
+        (APPEND_DIRECTIVE, 'Append'),
+        (PREPEND_DIRECTIVE, 'Prepend'),
+        (AFTER_DIRECTIVE, 'After'),
+        (BEFORE_DIRECTIVE, 'Before'),
+        (REMOVE_DIRECTIVE, 'Remove'),
+        (REPLACE_DIRECTIVE, 'Replace'),
+        (INCLUDE_DIRECTIVE, 'Include')], default=APPEND_DIRECTIVE)
+    glob = fields.Char(string='Path', required=True)
+    target = fields.Char(string='Target')
+    active = fields.Boolean(string='active', default=True)
+    sequence = fields.Integer(string="Sequence", default=DEFAULT_SEQUENCE, required=True)
+
+    def _get_asset_paths(self, bundle, addons=None, css=False, js=False, xml=False):
+        """
+        Fetches all asset file paths from a given list of addons matching a
+        certain bundle. The returned list is composed of tuples containing the
+        file path [1], the first addon calling it [0] and the bundle name.
+        Asset loading is performed as follows:
+
+        1. All 'ir.asset' records matching the given bundle and with a sequence
+        strictly less than 16 are applied.
+
+        3. The manifests of the given addons are checked for assets declaration
+        for the given bundle. If any, they are read sequentially and their
+        operations are applied to the current list.
+
+        4. After all manifests have been parsed, the remaining 'ir.asset'
+        records matching the bundle are also applied to the current list.
+
+        :param bundle: name of the bundle from which to fetch the file paths
+        :param addons: list of addon names as strings. The files returned will
+            only be contained in the given addons.
+        :param css: boolean: whether or not to include style files
+        :param js: boolean: whether or not to include script files
+        :param xml: boolean: whether or not to include template files
+        :returns: the list of tuples (path, addon, bundle)
+        """
+        installed = self._get_installed_addons_list()
+        if addons is None:
+            addons = self._get_active_addons_list()
+
+        asset_paths = AssetPaths()
+        self._fill_asset_paths(bundle, addons, installed, css, js, xml, asset_paths, [])
+        return asset_paths.list
+
+    def _fill_asset_paths(self, bundle, addons, installed, css, js, xml, asset_paths, seen):
+        """
+        Fills the given AssetPaths instance by applying the operations found in
+        the matching bundle of the given addons manifests.
+        See `_get_asset_paths` for more information.
+
+        :param bundle: name of the bundle from which to fetch the file paths
+        :param addons: list of addon names as strings
+        :param css: boolean: whether or not to include style files
+        :param js: boolean: whether or not to include script files
+        :param xml: boolean: whether or not to include template files
+        :param asset_paths: the AssetPath object to fill
+        :param seen: a list of bundles already checked to avoid circularity
+        """
+        if bundle in seen:
+            raise Exception("Circular assets bundle declaration: %s" % " > ".join(seen + [bundle]))
+
+        manifest_cache = http.addons_manifest
+        exts = []
+        if js:
+            exts += SCRIPT_EXTENSIONS
+        if css:
+            exts += STYLE_EXTENSIONS
+        if xml:
+            exts += TEMPLATE_EXTENSIONS
+
+        # this index is used for prepending: files are inserted at the beginning
+        # of the CURRENT bundle.
+        bundle_start_index = len(asset_paths.list)
+
+        def process_path(directive, target, path_def):
+            """
+            This sub function is meant to take a directive and a set of
+            arguments and apply them to the current asset_paths list
+            accordingly.
+
+            It is nested inside `_get_asset_paths` since we need the current
+            list of addons, extensions, asset_paths and manifest_cache.
+
+            :param directive: string
+            :param target: string or None or False
+            :param path_def: string
+            """
+            if directive == INCLUDE_DIRECTIVE:
+                # recursively call this function for each INCLUDE_DIRECTIVE directive.
+                self._fill_asset_paths(path_def, addons, installed, css, js, xml, asset_paths, seen + [bundle])
+                return
+
+            addon, paths = self._get_paths(path_def, installed, exts)
+
+            # retrieve target index when it applies
+            if directive in DIRECTIVES_WITH_TARGET:
+                _, target_paths = self._get_paths(target, installed, exts)
+                if not target_paths and target.rpartition('.')[2] not in exts:
+                    # nothing to do: the extension of the target is wrong
+                    return
+                target_to_index = len(target_paths) and target_paths[0] or target
+                target_index = asset_paths.index(target_to_index, addon, bundle)
+
+            if directive == APPEND_DIRECTIVE:
+                asset_paths.append(paths, addon, bundle)
+            elif directive == PREPEND_DIRECTIVE:
+                asset_paths.insert(paths, addon, bundle, bundle_start_index)
+            elif directive == AFTER_DIRECTIVE:
+                asset_paths.insert(paths, addon, bundle, target_index + 1)
+            elif directive == BEFORE_DIRECTIVE:
+                asset_paths.insert(paths, addon, bundle, target_index)
+            elif directive == REMOVE_DIRECTIVE:
+                asset_paths.remove(paths, addon, bundle, path_def)
+            elif directive == REPLACE_DIRECTIVE:
+                asset_paths.insert(paths, addon, bundle, target_index)
+                asset_paths.remove(target_paths, addon, bundle)
+            else:
+                # this should never happen
+                raise ValueError("Unexpected directive")
+
+        # 1. Process the first sequence of 'ir.asset' records
+        assets = self._get_related_assets([('bundle', '=', bundle)]).filtered('active')
+        for asset in assets.filtered(lambda a: a.sequence < DEFAULT_SEQUENCE):
+            process_path(asset.directive, asset.target, asset.glob)
+
+        # 2. Process all addons' manifests.
+        for addon in self._topological_sort(tuple(addons)):
+            manifest = manifest_cache.get(addon)
+            if not manifest:
+                continue
+            manifest_assets = manifest.get('assets', {})
+            for command in manifest_assets.get(bundle, []):
+                if isinstance(command, str):
+                    # Default directive: append
+                    directive, target, path_def = APPEND_DIRECTIVE, None, command
+                elif command[0] in DIRECTIVES_WITH_TARGET:
+                    directive, target, path_def = command
+                else:
+                    directive, path_def = command
+                    target = None
+                process_path(directive, target, path_def)
+
+        # 3. Process the rest of 'ir.asset' records
+        for asset in assets.filtered(lambda a: a.sequence >= DEFAULT_SEQUENCE):
+            process_path(asset.directive, asset.target, asset.glob)
+
+    def _get_related_assets(self, domain):
+        """
+        Returns a set of assets matching the domain, regardless of their
+        active state. This method can be overridden to filter the results.
+        :param domain: search domain
+        :returns: ir.asset recordset
+        """
+        return self.with_context(active_test=False).sudo().search(domain, order='sequence, id')
+
+    def _get_related_bundle(self, target_path_def, root_bundle):
+        """
+        Returns the first bundle directly defining a glob matching the target
+        path. This is useful when generating an 'ir.asset' record to override
+        a specific asset and target the right bundle, i.e. the first one
+        defining the target path.
+
+        :param target_path_def: string: path to match.
+        :root_bundle: string: bundle from which to initiate the search.
+        :returns: the first matching bundle or None
+        """
+        ext = target_path_def.split('.')[-1]
+        installed = self._get_installed_addons_list()
+        target_path = self._get_paths(target_path_def, installed)[1][0]
+
+        css = ext in STYLE_EXTENSIONS
+        js = ext in SCRIPT_EXTENSIONS
+        xml = ext in TEMPLATE_EXTENSIONS
+
+        asset_paths = self._get_asset_paths(root_bundle, css=css, js=js, xml=xml)
+
+        for path, _, bundle in asset_paths:
+            if path == target_path:
+                return bundle
+
+        return root_bundle
+
+    def _get_active_addons_list(self):
+        """Can be overridden to filter the returned list of active modules."""
+        return self._get_installed_addons_list()
+
+    @api.model
+    @tools.ormcache('addons_tuple')
+    def _topological_sort(self, addons_tuple):
+        """Returns a list of sorted modules name accord to the spec in ir.module.module
+        that is, application desc, sequence, name then topologically sorted"""
+        IrModule = self.env['ir.module.module']
+
+        def mapper(addon):
+            manif = http.addons_manifest.get(addon, {})
+            from_terp = IrModule.get_values_from_terp(manif)
+            from_terp['name'] = addon
+            from_terp['depends'] = manif.get('depends', ['base'])
+            return from_terp
+
+        manifs = map(mapper, addons_tuple)
+
+        def sort_key(manif):
+            return (not manif['application'], int(manif['sequence']), manif['name'])
+
+        manifs = sorted(manifs, key=sort_key)
+
+        return misc.topological_sort({manif['name']: manif['depends'] for manif in manifs})
+
+    @api.model
+    @tools.ormcache_context(keys='install_module')
+    def _get_installed_addons_list(self):
+        """
+        Returns the list of all installed addons.
+        :returns: string[]: list of module names
+        """
+        # Main source: the current registry list
+        # Second source of modules: server wide modules
+        # Third source: the currently loading module from the context (similar to ir_ui_view)
+        return self.env.registry._init_modules | set(odoo.conf.server_wide_modules or []) | set(self.env.context.get('install_module', []))
+
+    def _get_paths(self, path_def, installed, extensions=None):
+        """
+        Returns a list of file paths matching a given glob (path_def) as well as
+        the addon targetted by the path definition. If no file matches that glob,
+        the path definition is returned as is. This is either because the glob is
+        not correctly written or because it points to an URL.
+
+        :param path_def: the definition (glob) of file paths to match
+        :param installed: the list of installed addons
+        :param extensions: a list of extensions that found files must match
+        :returns: a tuple: the addon targetted by the path definition [0] and the
+            list of glob files matching the definition [1] (or the glob itself if
+            none). Note that these paths are filtered on the given `extensions`.
+        """
+        paths = []
+        path_url = fs2web(path_def)
+        path_parts = [part for part in path_url.split('/') if part]
+        addon = path_parts[0]
+        addon_manifest = http.addons_manifest.get(addon)
+
+        safe_path = True
+        if addon_manifest:
+            if addon not in installed:
+                # Assert that the path is in the installed addons
+                raise Exception("Unallowed to fetch files from addon %s" % addon)
+            addons_path = os.path.join(addon_manifest['addons_path'], '')[:-1]
+            full_path = os.path.normpath(os.path.join(addons_path, *path_parts))
+
+            # first security layer: forbid escape from the current addon
+            # "/mymodule/../myothermodule" is forbidden
+            # the condition after the or is to further guarantee that we won't access
+            # a directory that happens to be named like an addon (web....)
+            if addon not in full_path or addons_path not in full_path:
+                addon = None
+                safe_path = False
+            else:
+                paths = [
+                    path for path in sorted(glob(full_path, recursive=True))
+                ]
+
+            # second security layer: do we have the right to access the files
+            # that are grabbed by the glob ?
+            # In particular we don't want to expose data in xmls of the module
+            def is_safe_path(path):
+                try:
+                    misc.file_path(path, SCRIPT_EXTENSIONS + STYLE_EXTENSIONS + TEMPLATE_EXTENSIONS)
+                except (ValueError, FileNotFoundError):
+                    return False
+                if path.rpartition('.')[2] in TEMPLATE_EXTENSIONS:
+                    # Forbid xml to leak
+                    return ("%s/static/" % addon) in path
+                return True
+
+            len_paths = len(paths)
+            paths = list(filter(is_safe_path, paths))
+            safe_path = safe_path and len_paths == len(paths)
+
+            # When fetching template file paths, we need the full paths since xml
+            # files are read from the file system. But web assets (scripts and
+            # stylesheets) must be loaded using relative paths, hence the trimming
+            # for non-xml file paths.
+            paths = [path if path.split('.')[-1] in TEMPLATE_EXTENSIONS else path[len(addons_path):] for path in paths]
+
+        else:
+            addon = None
+
+        if not paths and (not can_aggregate(path_url) or (safe_path and not is_wildcard_glob(path_url))):
+            # No file matching the path; the path_def could be a url.
+            paths = [path_url]
+
+        if not paths:
+            msg = f'IrAsset: the path "{path_def}" did not resolve to anything.'
+            if not safe_path:
+                msg += " It may be due to security reasons."
+            _logger.warning(msg)
+        # Paths are filtered on the extensions (if any).
+        return addon, [
+            path
+            for path in paths
+            if not extensions or path.split('.')[-1] in extensions
+        ]
+
+class AssetPaths:
+    """ A list of asset paths (path, addon, bundle) with efficient operations. """
+    def __init__(self):
+        self.list = []
+        self.memo = set()
+
+    def index(self, path, addon, bundle):
+        """Returns the index of the given path in the current assets list."""
+        if path not in self.memo:
+            self._raise_not_found(path, bundle)
+        for index, asset in enumerate(self.list):
+            if asset[0] == path:
+                return index
+
+    def append(self, paths, addon, bundle):
+        """Appends the given paths to the current list."""
+        for path in paths:
+            if path not in self.memo:
+                self.list.append((path, addon, bundle))
+                self.memo.add(path)
+
+    def insert(self, paths, addon, bundle, index):
+        """Inserts the given paths to the current list at the given position."""
+        to_insert = []
+        for path in paths:
+            if path not in self.memo:
+                to_insert.append((path, addon, bundle))
+                self.memo.add(path)
+        self.list[index:index] = to_insert
+
+    def remove(self, paths, addon, bundle, glob=None):
+        """Removes the given paths from the current list."""
+        paths = {path for path in paths if path in self.memo}
+        if paths:
+            self.list[:] = [asset for asset in self.list if asset[0] not in paths]
+            self.memo.difference_update(paths)
+            return
+
+        if glob:
+            self._raise_not_found(glob, bundle)
+
+    def _raise_not_found(self, path, bundle):
+        raise ValueError("File %s not found in bundle %s" % (path, bundle))

--- a/odoo/addons/base/models/ir_module.py
+++ b/odoo/addons/base/models/ir_module.py
@@ -148,6 +148,7 @@ STATES = [
     ('to install', 'To be installed'),
 ]
 
+
 class Module(models.Model):
     _name = "ir.module.module"
     _rec_name = "shortdesc"

--- a/odoo/addons/base/models/ir_qweb.py
+++ b/odoo/addons/base/models/ir_qweb.py
@@ -9,7 +9,6 @@ from time import time
 
 from lxml import html
 from lxml import etree
-from werkzeug import urls
 
 from odoo import api, models, tools
 from odoo.tools.safe_eval import assert_valid_codeobj, _BUILTINS, _SAFE_OPCODES
@@ -19,6 +18,7 @@ from odoo.modules.module import get_resource_path
 
 from odoo.addons.base.models.qweb import QWeb, Contextifier
 from odoo.addons.base.models.assetsbundle import AssetsBundle
+from odoo.addons.base.models.ir_asset import can_aggregate, STYLE_EXTENSIONS, SCRIPT_EXTENSIONS
 
 _logger = logging.getLogger(__name__)
 
@@ -159,7 +159,7 @@ class IrQWeb(models.AbstractModel, QWeb):
         if len(el):
             raise SyntaxError("t-call-assets cannot contain children nodes")
 
-        # nodes = self._get_asset_nodes(xmlid, options, css=css, js=js, debug=values.get('debug'), async=async, values=values)
+        # nodes = self._get_asset_nodes(bundle, options, css=css, js=js, debug=values.get('debug'), async=async, values=values)
         #
         # for index, (tagName, t_attrs, content) in enumerate(nodes):
         #     if index:
@@ -216,7 +216,7 @@ class IrQWeb(models.AbstractModel, QWeb):
                         ast.keyword('async_load', self._get_attr_bool(el.get('async_load', False))),
                         ast.keyword('defer_load', self._get_attr_bool(el.get('defer_load', False))),
                         ast.keyword('lazy_load', self._get_attr_bool(el.get('lazy_load', False))),
-                        ast.keyword('values', ast.Name(id='values', ctx=ast.Load())),
+                        ast.keyword('media', ast.Constant(el.get('media'))),
                     ],
                     starargs=None, kwargs=None
                 )
@@ -281,92 +281,89 @@ class IrQWeb(models.AbstractModel, QWeb):
 
     # method called by computing code
 
-    def get_asset_bundle(self, xmlid, files, env=None, css=True, js=True):
-        return AssetsBundle(xmlid, files, env=env, css=css, js=js)
+    def get_asset_bundle(self, bundle_name, files, env=None, css=True, js=True):
+        return AssetsBundle(bundle_name, files, env=env, css=css, js=js)
 
-    def _get_asset_nodes(self, xmlid, options, css=True, js=True, debug=False, async_load=False, defer_load=False, lazy_load=False, values=None):
+    def _get_asset_nodes(self, bundle, options, css=True, js=True, debug=False, async_load=False, defer_load=False, lazy_load=False, media=None):
         """Generates asset nodes.
         If debug=assets, the assets will be regenerated when a file which composes them has been modified.
         Else, the assets will be generated only once and then stored in cache.
         """
         if debug and 'assets' in debug:
-            return self._generate_asset_nodes(xmlid, options, css, js, debug, async_load, defer_load, lazy_load, values)
+            return self._generate_asset_nodes(bundle, options, css, js, debug, async_load, defer_load, lazy_load, media)
         else:
-            return self._generate_asset_nodes_cache(xmlid, options, css, js, debug, async_load, defer_load, lazy_load, values)
+            return self._generate_asset_nodes_cache(bundle, options, css, js, debug, async_load, defer_load, lazy_load, media)
 
     @tools.conditional(
         # in non-xml-debug mode we want assets to be cached forever, and the admin can force a cache clear
         # by restarting the server after updating the source code (or using the "Clear server cache" in debug tools)
         'xml' not in tools.config['dev_mode'],
-        tools.ormcache_context('xmlid', 'options.get("lang", "en_US")', 'css', 'js', 'debug', 'async_load', 'defer_load', 'lazy_load', keys=("website_id",)),
+        tools.ormcache_context('bundle', 'options.get("lang", "en_US")', 'css', 'js', 'debug', 'async_load', 'defer_load', 'lazy_load', keys=("website_id",)),
     )
-    def _generate_asset_nodes_cache(self, xmlid, options, css=True, js=True, debug=False, async_load=False, defer_load=False, lazy_load=False, values=None):
-        return self._generate_asset_nodes(xmlid, options, css, js, debug, async_load, defer_load, lazy_load, values)
-
-    def _generate_asset_nodes(self, xmlid, options, css=True, js=True, debug=False, async_load=False, defer_load=False, lazy_load=False, values=None):
-        files, remains = self._get_asset_content(xmlid, options)
-        asset = self.get_asset_bundle(xmlid, files, env=self.env, css=css, js=js)
-        remains = [node for node in remains if (css and node[0] == 'link') or (js and node[0] != 'link')]
+    def _generate_asset_nodes_cache(self, bundle, options, css=True, js=True, debug=False, async_load=False, defer_load=False, lazy_load=False, media=None):
+        return self._generate_asset_nodes(bundle, options, css, js, debug, async_load, defer_load, lazy_load, media)
+
+    def _generate_asset_nodes(self, bundle, options, css=True, js=True, debug=False, async_load=False, defer_load=False, lazy_load=False, media=None):
+        nodeAttrs = None
+        if css and media:
+            nodeAttrs = {
+                'media': media,
+            }
+        files, remains = self._get_asset_content(bundle, options, nodeAttrs)
+        asset = self.get_asset_bundle(bundle, files, env=self.env, css=css, js=js)
+        remains = [node for node in remains if (css and node[0] == 'link') or (js and node[0] == 'script')]
         return remains + asset.to_node(css=css, js=js, debug=debug, async_load=async_load, defer_load=defer_load, lazy_load=lazy_load)
 
-    def _get_asset_link_urls(self, xmlid, options):
-        asset_nodes = self._get_asset_nodes(xmlid, options, js=False)
+    def _get_asset_link_urls(self, bundle, options):
+        asset_nodes = self._get_asset_nodes(bundle, options, js=False)
         return [node[1]['href'] for node in asset_nodes if node[0] == 'link']
 
-    @tools.ormcache_context('xmlid', 'options.get("lang", "en_US")', keys=("website_id",))
-    def _get_asset_content(self, xmlid, options):
+    @tools.ormcache_context('bundle', 'options.get("lang", "en_US")', keys=("website_id",))
+    def _get_asset_content(self, bundle, options, nodeAttrs=None):
         options = dict(options,
             inherit_branding=False, inherit_branding_auto=False,
             edit_translations=False, translatable=False,
             rendering_bundle=True)
 
         options['website_id'] = self.env.context.get('website_id')
-        IrQweb = self.env['ir.qweb'].with_context(options)
-
-        def can_aggregate(url):
-            return not urls.url_parse(url).scheme and not urls.url_parse(url).netloc and not url.startswith('/web/assets')
 
-        # TODO: This helper can be used by any template that wants to embedd the backend.
-        #       It is currently necessary because the ir.ui.view bundle inheritance does not
-        #       match the module dependency graph.
-        def get_modules_order():
-            if request:
-                from odoo.addons.web.controllers.main import module_boot
-                return json.dumps(module_boot())
-            return '[]'
-        template = IrQweb._render(xmlid, {"get_modules_order": get_modules_order})
+        asset_paths = self.env['ir.asset']._get_asset_paths(bundle=bundle, css=True, js=True)
 
         files = []
         remains = []
-        for el in html.fragments_fromstring(template):
-            if isinstance(el, html.HtmlElement):
-                href = el.get('href', '')
-                src = el.get('src', '')
-                atype = el.get('type')
-                media = el.get('media')
-
-                if can_aggregate(href) and (el.tag == 'style' or (el.tag == 'link' and el.get('rel') == 'stylesheet')):
-                    if href.endswith('.sass'):
-                        atype = 'text/sass'
-                    elif href.endswith('.scss'):
-                        atype = 'text/scss'
-                    elif href.endswith('.less'):
-                        atype = 'text/less'
-                    if atype not in ('text/less', 'text/scss', 'text/sass'):
-                        atype = 'text/css'
-                    path = [segment for segment in href.split('/') if segment]
-                    filename = get_resource_path(*path) if path else None
-                    files.append({'atype': atype, 'url': href, 'filename': filename, 'content': el.text, 'media': media})
-                elif can_aggregate(src) and el.tag == 'script':
-                    atype = 'text/javascript'
-                    path = [segment for segment in src.split('/') if segment]
-                    filename = get_resource_path(*path) if path else None
-                    files.append({'atype': atype, 'url': src, 'filename': filename, 'content': el.text, 'media': media})
-                else:
-                    remains.append((el.tag, OrderedDict(el.attrib), el.text))
+        for path, *_ in asset_paths:
+            ext = path.split('.')[-1]
+            is_js = ext in SCRIPT_EXTENSIONS
+            is_css = ext in STYLE_EXTENSIONS
+            if not is_js and not is_css:
+                continue
+
+            mimetype = 'text/javascript' if is_js else 'text/%s' % ext
+            if can_aggregate(path):
+                segments = [segment for segment in path.split('/') if segment]
+                files.append({
+                    'atype': mimetype,
+                    'url': path,
+                    'filename': get_resource_path(*segments) if segments else None,
+                    'content': '',
+                    'media': nodeAttrs and nodeAttrs.get('media'),
+                })
             else:
-                # the other cases are ignored
-                pass
+                if is_js:
+                    tag = 'script'
+                    attributes = {
+                        "type": mimetype,
+                        "src": path,
+                    }
+                else:
+                    tag = 'link'
+                    attributes = {
+                        "type": mimetype,
+                        "rel": "stylesheet",
+                        "href": path,
+                        'media': nodeAttrs and nodeAttrs.get('media'),
+                    }
+                remains.append((tag, attributes, ''))
 
         return (files, remains)
 

--- a/odoo/addons/base/security/ir.model.access.csv
+++ b/odoo/addons/base/security/ir.model.access.csv
@@ -78,6 +78,7 @@
 "access_res_users_apikeys_description_employee","API key wizard employees","model_res_users_apikeys_description","group_user",1,0,1,0
 "access_res_users_apikeys_description_portal","API key wizard","model_res_users_apikeys_description","group_portal",1,0,1,0
 "access_res_users_apikeys_show_employee","API key result employees","model_res_users_apikeys_show","group_user",1,0,1,0
+"access_ir_asset_group_system","ir_asset_group_system","model_ir_asset","group_system",1,1,1,1
 "access_ir_actions_group_system","ir_actions_group_system","model_ir_actions_actions","group_system",1,1,1,1
 "access_ir_actions_act_window_system","ir_actions_act_window_system","model_ir_actions_act_window","group_system",1,1,1,1
 "access_ir_actions_act_window_close_group_system","ir_actions_act_window_close_group_system","model_ir_actions_act_window_close","group_system",1,1,1,1

--- a/None
+++ b/odoo/addons/base/views/ir_asset_views.xml
@@ -0,0 +1,61 @@
+<?xml version="1.0" encoding="utf-8"?>
+<odoo>
+    <record id="asset_view_form" model="ir.ui.view">
+        <field name="model">ir.asset</field>
+        <field name="arch" type="xml">
+            <form string="Assets">
+                <sheet>
+                    <group>
+                        <group>
+                            <field name="name"/>
+                            <field name="bundle"/>
+                            <field name="directive"/>
+                            <field name="sequence"/>
+                            <field name="active" widget="boolean_toggle"/>
+                        </group>
+                        <group>
+                            <field name="target" attrs="{ 'invisible': [('directive', '!=', 'replace')] }"/>
+                            <field name="glob"/>
+                        </group>
+                    </group>
+                </sheet>
+            </form>
+        </field>
+    </record>
+
+    <record id="asset_view_tree" model="ir.ui.view">
+        <field name="model">ir.asset</field>
+        <field name="arch" type="xml">
+            <tree string="Assets">
+                <field name="name"/>
+                <field name="bundle"/>
+                <field name="sequence"/>
+                <field name="active"/>
+            </tree>
+        </field>
+    </record>
+
+    <record id="asset_view_search" model="ir.ui.view">
+        <field name="model">ir.asset</field>
+        <field name="arch" type="xml">
+            <search string="Assets">
+                <field name="name"/>
+                <field name="bundle"/>
+                <field name="directive"/>
+                <field name="sequence"/>
+                <field name="glob"/>
+                <filter string="Active" name="active" domain="[('active', '=', True)]"/>
+            </search>
+        </field>
+    </record>
+
+    <record id="action_asset" model="ir.actions.act_window">
+        <field name="name">Assets</field>
+        <field name="type">ir.actions.act_window</field>
+        <field name="res_model">ir.asset</field>
+        <field name="view_id" ref="asset_view_tree"/>
+        <field name="context">{'search_default_active': 1}</field>
+    </record>
+
+    <menuitem action="action_asset" id="menu_action_asset" parent="base.next_id_9"/>
+</odoo>
