PR: https://github.com/odoo/odoo/pull/

From: c5cac922801f511d679c959cd56f1035ef117d70
From: Thibault Libioulle
Date: 2021-06-01 10:01:37

Structural Changes: 25
Total Changes: 295

[IMP] project: add project updates and milestones

This commit adds project updates in project to take in stock the current
status of the project : which task or milestone changed in the past 30
days.

The project manager is able to add a status on the project update, and
edit the description of the update. There is also a chatter in which
he/she can discuss some points with other project users.

The description is build with informations retrieved from mail tracking
values or from project.* models. Those informations are collected in a
dict and rendered in a template to ease the inheritence in further
modules needs.

Following commits will add behaviour to handle those updates and
milestones in the various views. See PR for further information.

PR : #68899

task-2393768

================================= pseudo patch: =================================

--- a/addons/project/models/__init__.py
+++ b/addons/project/models/__init__.py
@@ -2,8 +2,10 @@
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
 from . import analytic_account
+from . import project_milestone
 from . import project_task_recurrence
 from . import project
+from . import project_update
 from . import res_config_settings
 from . import res_partner
 from . import digest

--- a/addons/project/models/project.py
+++ b/addons/project/models/project.py
@@ -12,6 +12,7 @@ from odoo.tools.misc import format_date, get_lang
 from odoo.osv.expression import OR
 
 from .project_task_recurrence import DAYS, WEEKS
+from .project_update import STATUS_COLOR
 
 class ProjectTaskType(models.Model):
     _name = 'project.task.type'
@@ -248,6 +249,18 @@ class Project(models.Model):
         ('quarterly', 'Quarterly'),
         ('yearly', 'Yearly')], 'Rating Frequency', required=True, default='monthly')
 
+    update_ids = fields.One2many('project.update', 'project_id')
+    last_update_id = fields.Many2one('project.update', string='Last Update')
+    last_update_status = fields.Selection(selection=[
+        ('on_track', 'On Track'),
+        ('at_risk', 'At Risk'),
+        ('off_track', 'Off Track'),
+        ('on_hold', 'On Hold')
+    ], default='on_track', compute='_compute_last_update_status', store=True)
+    last_update_color = fields.Integer(compute='_compute_last_update_color')
+    milestone_ids = fields.One2many('project.milestone', 'project_id')
+    milestone_count = fields.Integer(compute='_compute_milestone_count')
+
     _sql_constraints = [
         ('project_date_greater', 'check(date >= date_start)', 'Error! Project start date must be before project end date.')
     ]
@@ -300,6 +313,23 @@ class Project(models.Model):
         for project in self:
             project.rating_request_deadline = fields.datetime.now() + timedelta(days=periods.get(project.rating_status_period, 0))
 
+    @api.depends('last_update_id.status')
+    def _compute_last_update_status(self):
+        for project in self:
+            project.last_update_status = project.last_update_id.status or 'on_track'
+
+    @api.depends('last_update_status')
+    def _compute_last_update_color(self):
+        for project in self:
+            project.last_update_color = STATUS_COLOR[project.last_update_status]
+
+    @api.depends('milestone_ids')
+    def _compute_milestone_count(self):
+        read_group = self.env['project.milestone'].read_group([('project_id', 'in', self.ids)], ['project_id'], ['project_id'])
+        mapped_count = {group['project_id'][0]: group['project_id_count'] for group in read_group}
+        for project in self:
+            project.milestone_count = mapped_count.get(project.id, 0)
+
     @api.model
     def _map_tasks_default_valeus(self, task, project):
         """ get the default value for the copied task on project duplication """
@@ -468,6 +498,24 @@ class Project(models.Model):
         action_context['search_default_project_id'] = self.id
         return dict(action, context=action_context)
 
+    def _get_tasks_analysis_counts(self, created=False, updated=False):
+        tasks = self.env['project.task'].search([('display_project_id', '=', self.id)])
+        open_tasks_count = created_tasks_count = updated_tasks_count = 0
+        tasks_count = len(tasks)
+        thirty_days_ago = datetime.combine(fields.Date.context_today(self) + timedelta(days=-30), datetime.min.time())
+        for t in tasks:
+            if not t.stage_id.fold and not t.stage_id.is_closed:
+                open_tasks_count += 1
+            if created and t.create_date > thirty_days_ago:
+                created_tasks_count += 1
+            if updated and t.write_date > thirty_days_ago:
+                updated_tasks_count += 1
+        return dict(
+            open_tasks_count=open_tasks_count,
+            created_tasks_count=created_tasks_count,
+            updated_tasks_count=updated_tasks_count,
+            tasks_count=tasks_count
+        )
     # ---------------------------------------------------
     #  Business Methods
     # ---------------------------------------------------

--- a/None
+++ b/addons/project/models/project_milestone.py
@@ -0,0 +1,50 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from odoo import api, fields, models
+
+class ProjectMilestone(models.Model):
+    _name = 'project.milestone'
+    _description = "Project Milestone"
+    _inherit = ['mail.thread']
+    _order = 'deadline, is_reached desc, name'
+
+    def _get_default_project_id(self):
+        return self.env.context.get('default_project_id') or self.env.context.get('active_id')
+
+    name = fields.Char(required=True)
+    project_id = fields.Many2one('project.project', required=True, default=_get_default_project_id)
+    deadline = fields.Date(tracking=True)
+    is_reached = fields.Boolean(string="Reached", default=False)
+    reached_date = fields.Date(compute='_compute_reached_date', store=True)
+
+    # computed non-stored fields
+    is_deadline_exceeded = fields.Boolean(compute="_compute_is_deadline_exceeded")
+    is_deadline_future = fields.Boolean(compute="_compute_is_deadline_future")
+
+    @api.depends('is_reached')
+    def _compute_reached_date(self):
+        for ms in self:
+            ms.reached_date = ms.is_reached and fields.Date.context_today(self)
+
+    @api.depends('is_reached', 'deadline')
+    def _compute_is_deadline_exceeded(self):
+        today = fields.Date.context_today(self)
+        for ms in self:
+            ms.is_deadline_exceeded = not ms.is_reached and ms.deadline and ms.deadline < today
+
+    @api.depends('deadline')
+    def _compute_is_deadline_future(self):
+        for ms in self:
+            ms.is_deadline_future = ms.deadline and ms.deadline > fields.Date.context_today(self)
+
+    @api.model
+    def _get_fields_to_export(self):
+        return ['id', 'name', 'deadline', 'is_reached', 'reached_date', 'is_deadline_exceeded', 'is_deadline_future']
+
+    def _get_data(self):
+        self.ensure_one()
+        return {field: self[field] for field in self._get_fields_to_export()}
+
+    def _get_data_list(self):
+        return [ms._get_data() for ms in self]

--- a/None
+++ b/addons/project/models/project_update.py
@@ -0,0 +1,195 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from datetime import timedelta
+from dateutil.relativedelta import relativedelta
+from werkzeug.urls import url_encode
+
+from odoo import api, fields, models
+
+STATUS_COLOR = {
+    'on_track': 10,  # green
+    'at_risk': 2,  # orange
+    'off_track': 1,  # red
+    'on_hold': 4,  # light blue
+}
+
+class ProjectUpdate(models.Model):
+    _name = 'project.update'
+    _description = 'Project Update'
+    _order = 'create_date desc'
+    _inherit = ['mail.thread.cc', 'mail.activity.mixin']
+
+    def default_get(self, fields):
+        result = super().default_get(fields)
+        if 'project_id' in fields and not result.get('project_id'):
+            result['project_id'] = self.env.context.get('active_id')
+        if result.get('project_id'):
+            project = self.env['project.project'].browse(result['project_id'])
+            if 'progress' in fields and not result.get('progress'):
+                result['progress'] = project.last_update_id.progress
+            if 'description' in fields and not result.get('description'):
+                result['description'] = self._build_description(project)
+            if 'status' in fields and not result.get('status'):
+                result['status'] = project.last_update_status
+        return result
+
+    name = fields.Char("Title", required=True, tracking=True)
+    status = fields.Selection(selection=[
+        ('on_track', 'On Track'),
+        ('at_risk', 'At Risk'),
+        ('off_track', 'Off Track'),
+        ('on_hold', 'On Hold')
+    ], required=True, tracking=True)
+    color = fields.Integer(compute='_compute_color')
+    progress = fields.Integer(tracking=True)
+    progress_percentage = fields.Float(compute='_compute_progress_percentage')
+    user_id = fields.Many2one('res.users', string='Author', required=True, default=lambda self: self.env.user)
+    description = fields.Html()
+    date = fields.Date(default=fields.Date.context_today, tracking=True)
+    project_id = fields.Many2one('project.project', required=True)
+
+    @api.depends('status')
+    def _compute_color(self):
+        for update in self:
+            update.color = STATUS_COLOR[update.status]
+
+    @api.depends('progress')
+    def _compute_progress_percentage(self):
+        for u in self:
+            u.progress_percentage = u.progress / 100
+
+    # ---------------------------------
+    # ORM Override
+    # ---------------------------------
+    @api.model
+    def create(self, vals):
+        update = super().create(vals)
+        update.project_id.last_update_id = update
+        return update
+
+    # ---------------------------------
+    # Build default description
+    # ---------------------------------
+    @api.model
+    def _build_description(self, project):
+        template = self.env.ref('project.project_update_default_description')
+        return template._render(self._get_template_values(project), engine='ir.qweb')
+
+    @api.model
+    def _get_template_values(self, project):
+        return {
+            'user': self.env.user,
+            'project': project,
+            'tasks': self._get_tasks_values(project),
+            'milestones': self._get_milestone_values(project)
+        }
+
+    @api.model
+    def _get_tasks_values(self, project):
+        counts = project._get_tasks_analysis_counts(created=True)
+        return {
+            'open_tasks': counts['open_tasks_count'],
+            'total_tasks': counts['tasks_count'],
+            'created_tasks': counts['created_tasks_count'],
+            'closed_tasks': self._get_last_stage_changes(project=project),
+            'action': {
+                'url_default': '/web#' + url_encode({
+                    'menu_id': self.env.ref('project.menu_projects').id,
+                    'action': self.env.ref('project.action_project_task_burndown_chart_report').id,
+                    'active_id': project.id
+                }),
+                'name': 'action_burndown_open_tasks',
+            }
+        }
+
+    @api.model
+    def _get_last_stage_changes(self, project):
+        query = """
+            SELECT DISTINCT pt.id as task_id
+                  FROM mail_message mm
+            INNER JOIN mail_tracking_value mtv
+                    ON mm.id = mtv.mail_message_id
+            INNER JOIN ir_model_fields imf
+                    ON mtv.field = imf.id
+                   AND imf.model = 'project.task'
+                   AND imf.name = 'stage_id'
+            INNER JOIN project_task_type new_stage
+                    ON mtv.new_value_integer = new_stage.id
+            INNER JOIN project_task pt
+                    ON mm.res_id = pt.id
+                   AND pt.stage_id = new_stage.id
+                 WHERE mm.model = 'project.task'
+                   AND mm.message_type = 'notification'
+                   AND pt.display_project_id = %(project_id)s
+                   AND (new_stage.fold OR new_stage.is_closed)
+                   AND mm.date > (now() at time zone 'utc')::date - '1 month'::interval
+                   AND pt.active
+        """
+        self.env.cr.execute(query, {'project_id': project.id})
+        task_ids = [res['task_id'] for res in self.env.cr.dictfetchall()]
+        return self.env['project.task'].search_count([('id', 'in', task_ids)])
+
+    @api.model
+    def _get_milestone_values(self, project):
+        Milestone = self.env['project.milestone']
+        list_milestones = Milestone.search(
+            [('project_id', '=', project.id),
+             '|', ('deadline', '<', fields.Date.context_today(self) + relativedelta(years=1)), ('deadline', '=', False)])._get_data_list()
+        updated_milestones = self._get_last_updated_milestone(project)
+        created_milestones = Milestone.search(
+            [('project_id', '=', project.id),
+             ('create_date', '>', fields.Datetime.now() + timedelta(days=-30))])._get_data_list()
+        return {
+            'show_section': (list_milestones or updated_milestones or created_milestones) and True or False,
+            'list': list_milestones,
+            'updated': updated_milestones,
+            'created': created_milestones,
+        }
+
+    @api.model
+    def _get_last_updated_milestone(self, project):
+        query = """
+            SELECT DISTINCT pm.id as milestone_id,
+                            pm.deadline as deadline,
+                            FIRST_VALUE(old_value_datetime::date) OVER w_partition as old_value,
+                            pm.deadline as new_value
+                       FROM mail_message mm
+                 INNER JOIN mail_tracking_value mtv
+                         ON mm.id = mtv.mail_message_id
+                 INNER JOIN ir_model_fields imf
+                         ON mtv.field = imf.id
+                        AND imf.model = 'project.milestone'
+                        AND imf.name = 'deadline'
+                 INNER JOIN project_milestone pm
+                         ON mm.res_id = pm.id
+                      WHERE mm.model = 'project.milestone'
+                        AND mm.message_type = 'notification'
+                        AND pm.project_id = %(project_id)s
+                        AND mm.date > (now() at time zone 'utc')::date - '1 month'::interval
+                     WINDOW w_partition AS (
+                             PARTITION BY pm.id
+                             ORDER BY mm.date ASC
+                            )
+                   ORDER BY pm.deadline ASC;
+        """
+        self.env.cr.execute(query, {'project_id': project.id})
+        results = self.env.cr.dictfetchall()
+        mapped_result = {res['milestone_id']: {'new_value': res['new_value'], 'old_value': res['old_value']} for res in results}
+        milestones = self.env['project.milestone'].search([('id', 'in', list(mapped_result.keys()))])
+        return [{
+            **milestone._get_data(),
+            'new_value': mapped_result[milestone.id]['new_value'],
+            'old_value': mapped_result[milestone.id]['old_value'],
+        } for milestone in milestones]
+
+    def action_burndown_open_tasks(self):
+        if not self.id or not self.project_id:
+            return False
+        action = self.env['ir.actions.act_window']._for_xml_id('project.action_project_task_burndown_chart_report')
+        context = {
+            'active_id': self.project_id.id,
+            'search_default_project_id': self.project_id.id,
+            'graph_mode': 'bar',
+        }
+        return dict(action, context=context)
