PR: https://github.com/odoo/odoo/pull/

From: 60aa9ffd018647eb2627f8095040f52cb82694e5
From: ThanhDodeurOdoo
Date: 2018-08-13 07:11:53

Structural Changes: 4
Total Changes: 94

[IMP] base,mail,web: attachments adaptation for documents

This commit is the counter-part of an enteprise commit introducing
the Documents app.

Here is a summary of what has been done:
  - tweak unlink of ir_attachment to prevent unlink recursivity
    (when attachments are attached to ir_attachments)
  - improve ir_attachment kanban view
  - add several arguments to binary_content controller:
    - 'force_ext': to force the extension in the filename, base on
      mimetype
    - 'share_token' and 'share_id': to autorize download from a
      share link
  - add 'thumbnail' field on ir_attachment to optimize Kanban view
  - add 'upper_limit' argument to image to allow to bypass the
    500*500 size limit
  - DocumentViewer now handles text files

More information available on task 1853490

Co-authored-by: Pierre Paridans <app@odoo.com>
Co-authored-by: sri-odoo <sri@odoo.com>
Co-authored-by: ThanhDodeurOdoo <tso@odoo.com>

================================= pseudo patch: =================================

--- a/odoo/addons/base/models/ir_attachment.py
+++ b/odoo/addons/base/models/ir_attachment.py
@@ -6,14 +6,16 @@ import itertools
 import logging
 import mimetypes
 import os
+import io
 import re
 from collections import defaultdict
 import uuid
 
-from odoo import api, fields, models, tools, SUPERUSER_ID, _
+from odoo import api, fields, models, tools, SUPERUSER_ID, exceptions, _
 from odoo.exceptions import AccessError, ValidationError
 from odoo.tools import config, human_size, ustr, html_escape
 from odoo.tools.mimetypes import guess_mimetype
+from odoo.tools import crop_image, image_resize_image
 
 _logger = logging.getLogger(__name__)
 
@@ -42,6 +44,14 @@ class IrAttachment(models.Model):
                 record = self.env[attachment.res_model].browse(attachment.res_id)
                 attachment.res_name = record.display_name
 
+    @api.depends('res_model')
+    def _compute_res_model_name(self):
+        for record in self:
+            if record.res_model:
+                model = self.env['ir.model'].search([('model', '=', record.res_model)], limit=1)
+                if model:
+                    record.res_model_name = model[0].name
+
     @api.model
     def _storage(self):
         return self.env['ir.config_parameter'].sudo().get_param('ir_attachment.location', 'file')
@@ -272,15 +282,16 @@ class IrAttachment(models.Model):
         """
         return ['base.group_system']
 
-    name = fields.Char('Attachment Name', required=True)
-    datas_fname = fields.Char('File Name')
+    name = fields.Char('Name', required=True)
+    datas_fname = fields.Char('Filename')
     description = fields.Text('Description')
     res_name = fields.Char('Resource Name', compute='_compute_res_name', store=True)
     res_model = fields.Char('Resource Model', readonly=True, help="The database object this attachment will be attached to.")
+    res_model_name = fields.Char(compute='_compute_res_model_name', store=True, index=True)
     res_field = fields.Char('Resource Field', readonly=True)
     res_id = fields.Integer('Resource ID', readonly=True, help="The record id this is attached to.")
     create_date = fields.Datetime('Date Created', readonly=True)
-    create_uid = fields.Many2one('res.users', string='Owner', readonly=True)
+    create_uid = fields.Many2one('res.users', readonly=True)
     company_id = fields.Many2one('res.company', string='Company', change_default=True,
                                  default=lambda self: self.env['res.company']._company_default_get('ir.attachment'))
     type = fields.Selection([('url', 'URL'), ('binary', 'File')],
@@ -300,6 +311,18 @@ class IrAttachment(models.Model):
     checksum = fields.Char("Checksum/SHA1", size=40, index=True, readonly=True)
     mimetype = fields.Char('Mime Type', readonly=True)
     index_content = fields.Text('Indexed Content', readonly=True, prefetch=False)
+    active = fields.Boolean(default=True, string="Active", oldname='archived')
+    thumbnail = fields.Binary(compute='_get_thumbnail', store=True, string="")
+
+    @api.depends('mimetype', 'file_size', 'checksum')
+    def _get_thumbnail(self):
+        for record in self:
+            if record.mimetype:
+                if re.match('image.*(gif|jpeg|jpg|png)', record.mimetype):
+                    if not record.thumbnail:
+                        temp_image = crop_image(record.datas, type='center', size=(100, 100), ratio=(1, 1))
+                        record.thumbnail = image_resize_image(base64_source=temp_image, size=(100, 100),
+                                                              encoding='base64', filetype='PNG')
 
     @api.model_cr_context
     def _auto_init(self):
@@ -438,6 +461,8 @@ class IrAttachment(models.Model):
 
     @api.multi
     def unlink(self):
+        if not self:
+            return True
         self.check('unlink')
 
         # First delete in the database, *then* in the filesystem if the
@@ -472,3 +497,31 @@ class IrAttachment(models.Model):
     @api.model
     def action_get(self):
         return self.env['ir.actions.act_window'].for_xml_id('base', 'action_attachment')
+
+    @api.model
+    def upload_attachment(self, attachments, custom_values=None):
+        """
+        directly uploads attachments.
+
+        :param attachments: array of dictionaries representing attachment data:
+                            eg: [{'name': 'doc.zip', 'data': 'data:application/zip;base64,R0lGODdhAQBADs='}]
+        :param custom_values: additional values for the attachment create dictionary.
+        :return: the ids of the new attachments.
+        """
+        if not custom_values:
+            custom_values = {}
+        ids = []
+        for attachment in attachments:
+            data = attachment['data']
+            raw_name = attachment['name']
+            values = {
+                'mimetype': data[data.find(':') + 1:data.find(';')],
+                'name': raw_name[:raw_name.rfind('.')],
+                'datas': data[data.find(',') + 1:],
+                'datas_fname': raw_name,
+            }
+
+            values.update(custom_values)
+            created_attachment = self.env['ir.attachment'].create(values)
+            ids.append(created_attachment.id)
+        return ids

--- a/odoo/addons/base/models/ir_http.py
+++ b/odoo/addons/base/models/ir_http.py
@@ -23,6 +23,7 @@ from odoo.exceptions import AccessDenied, AccessError
 from odoo.http import request, STATIC_CACHE, content_disposition
 from odoo.tools import pycompat, consteq
 from odoo.tools.mimetypes import guess_mimetype
+from ast import literal_eval
 from odoo.modules.module import get_resource_path, get_module_path
 
 _logger = logging.getLogger(__name__)
@@ -246,7 +247,7 @@ class IrHttp(models.AbstractModel):
     def binary_content(cls, xmlid=None, model='ir.attachment', id=None, field='datas',
                        unique=False, filename=None, filename_field='datas_fname', download=False,
                        mimetype=None, default_mimetype='application/octet-stream',
-                       access_token=None, env=None):
+                       access_token=None, share_id=None, share_token=None, force_ext=False, env=None):
         """ Get file, attachment or downloadable content
 
         If the ``xmlid`` and ``id`` parameter is omitted, fetches the default value for the
@@ -262,9 +263,13 @@ class IrHttp(models.AbstractModel):
         :param str filename_field: if not create an filename with model-id-field
         :param bool download: apply headers to download the file
         :param str mimetype: mintype of the field (for headers)
+        :param share_id: the id of the documents.share that contains the attachment
+        :param share_token: the token of the documents.share that contains the attachment
         :param str default_mimetype: default mintype if no mintype found
         :param str access_token: optional token for unauthenticated access
                                  only available  for ir.attachment
+        :param bool force_ext: if true, adds the extension to the filename
+                                that corresponds to the mimetype
         :param Environment env: by default use request.env
         :returns: (status, headers, content)
         """
@@ -277,6 +282,24 @@ class IrHttp(models.AbstractModel):
             obj = env[model].sudo().browse(int(id))
             if not consteq(obj.access_token, access_token):
                 return (403, [], None)
+        elif id and share_id and share_token:
+            share = env['documents.share'].sudo().browse(int(share_id))
+            if share:
+                if share.state == 'expired':
+                    return (403, [], None)
+                if not consteq(share.access_token, share_token):
+                    return (403, [], None)
+                elif share.type == 'ids' and (id in share.attachment_ids.ids):
+                    obj = env[model].sudo().browse(int(id))
+                elif share.type == 'domain':
+                    obj = env[model].sudo().browse(int(id))
+                    share_domain = []
+                    if share.domain:
+                        share_domain = literal_eval(share.domain)
+                    domain = [['folder_id', '=', share.folder_id.id]] + share_domain
+                    attachments_check = http.request.env['ir.attachment'].sudo().search(domain)
+                    if obj not in attachments_check:
+                        return (403, [], None)
         elif id and model in env.registry:
             obj = env[model].browse(int(id))
 
@@ -338,6 +361,14 @@ class IrHttp(models.AbstractModel):
             if not mimetype:
                 mimetype = guess_mimetype(base64.b64decode(content), default=default_mimetype)
 
+        if force_ext and (mimetype != default_mimetype):
+            dot_index = filename.rfind('.')
+            if dot_index > -1:
+                if mimetypes.guess_extension(mimetype) != filename[dot_index:]:
+                    filename = filename[:dot_index] + mimetypes.guess_extension(mimetype)
+            else:
+                filename = filename + mimetypes.guess_extension(mimetype)
+
         headers += [('Content-Type', mimetype), ('X-Content-Type-Options', 'nosniff')]
 
         # cache
