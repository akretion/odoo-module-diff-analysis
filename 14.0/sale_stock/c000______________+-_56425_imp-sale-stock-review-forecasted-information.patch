PR: https://github.com/odoo/odoo/pull/56425

From: 5e5de2b2b64fd8cb259e72fc1a97dc754da871ad
From: RÃ©my Voet (ryv)
Date: 2020-09-11 09:18:09

Structural Changes: 5
Total Changes: 72

[IMP] (sale_)stock: review forecasted information

Remove the json_forecast of the sale order line,
it was a duplicate of information with the qty_at_date_widget.
But improve this one:
- Use the forecasted move information in case of confirmed SO.
- Change the icon (i) to chart.
- Link to the forcasted change to target new forcasted report
(Unfortunately we loose the feature to see components product forcasted
of a kit)
- Change information print in the popover in case of confirmed SO.

Also refactor the json_forcasted of `stock.move` into multiple fields
to avoid to dump/loads for other model who needed the forcasted data.

task-2324039

closes odoo/odoo#56425

Related: odoo/enterprise#13063
Signed-off-by: Arnold Moyaux <amoyaux@users.noreply.github.com>

================================= pseudo patch: =================================

--- a/addons/sale_stock/models/sale_order.py
+++ b/addons/sale_stock/models/sale_order.py
@@ -267,47 +267,65 @@ class SaleOrderLine(models.Model):
     route_id = fields.Many2one('stock.location.route', string='Route', domain=[('sale_selectable', '=', True)], ondelete='restrict', check_company=True)
     move_ids = fields.One2many('stock.move', 'sale_line_id', string='Stock Moves')
     product_type = fields.Selection(related='product_id.type')
-    virtual_available_at_date = fields.Float(compute='_compute_qty_at_date')
+    virtual_available_at_date = fields.Float(compute='_compute_qty_at_date', digits='Product Unit of Measure')
     scheduled_date = fields.Datetime(compute='_compute_qty_at_date')
+    forecast_expected_date = fields.Datetime(compute='_compute_qty_at_date')
     free_qty_today = fields.Float(compute='_compute_qty_at_date')
     qty_available_today = fields.Float(compute='_compute_qty_at_date')
     warehouse_id = fields.Many2one(related='order_id.warehouse_id')
-    qty_to_deliver = fields.Float(compute='_compute_qty_to_deliver')
+    qty_to_deliver = fields.Float(compute='_compute_qty_to_deliver', digits='Product Unit of Measure')
     is_mto = fields.Boolean(compute='_compute_is_mto')
     display_qty_widget = fields.Boolean(compute='_compute_qty_to_deliver')
     json_forecast = fields.Char('JSON data for the forecast widget', compute='_compute_json_forecast')
 
-    @api.depends('product_id', 'product_uom_qty', 'qty_delivered', 'state')
+    @api.depends('product_type', 'product_uom_qty', 'qty_delivered', 'state', 'move_ids')
     def _compute_qty_to_deliver(self):
         """Compute the visibility of the inventory widget."""
         for line in self:
             line.qty_to_deliver = line.product_uom_qty - line.qty_delivered
-            if line.state == 'draft' and line.product_type == 'product' and line.qty_to_deliver > 0:
-                line.display_qty_widget = True
+            if line.state in ('draft', 'sent', 'sale') and line.product_type == 'product' and line.qty_to_deliver > 0:
+                if line.state == 'sale' and not line.move_ids:
+                    line.display_qty_widget = False
+                else:
+                    line.display_qty_widget = True
             else:
                 line.display_qty_widget = False
 
-    @api.depends('product_id', 'customer_lead', 'product_uom_qty', 'product_uom', 'order_id.commitment_date')
+    @api.depends(
+        'product_id', 'customer_lead', 'product_uom_qty', 'product_uom', 'order_id.commitment_date',
+        'move_ids', 'move_ids.forecast_expected_date', 'move_ids.forecast_availability')
     def _compute_qty_at_date(self):
         """ Compute the quantity forecasted of product at delivery date. There are
         two cases:
          1. The quotation has a commitment_date, we take it as delivery date
          2. The quotation hasn't commitment_date, we compute the estimated delivery
             date based on lead time"""
+        treated = self.browse()
+        # If the state is already in sale the picking is created and a simple forecasted quantity isn't enough
+        # Then used the forecasted data of the related stock.move
+        for line in self.filtered(lambda l: l.state == 'sale'):
+            if not line.display_qty_widget:
+                continue
+            moves = line.move_ids
+            line.forecast_expected_date = max(moves.filtered("forecast_expected_date").mapped("forecast_expected_date"), default=False)
+            line.qty_available_today = 0
+            line.virtual_available_at_date = 0
+            for move in moves:
+                line.qty_available_today += move.product_uom._compute_quantity(move.reserved_availability, line.product_uom)
+                line.virtual_available_at_date += move.product_id.uom_id._compute_quantity(move.forecast_availability, line.product_uom)
+            line.scheduled_date = line.order_id.commitment_date or line._expected_date()
+            line.free_qty_today = False
+            treated |= line
+
         qty_processed_per_product = defaultdict(lambda: 0)
         grouped_lines = defaultdict(lambda: self.env['sale.order.line'])
         # We first loop over the SO lines to group them by warehouse and schedule
         # date in order to batch the read of the quantities computed field.
-        for line in self:
+        for line in self.filtered(lambda l: l.state in ('draft', 'sent')):
             if not (line.product_id and line.display_qty_widget):
                 continue
-            if line.order_id.commitment_date:
-                date = line.order_id.commitment_date
-            else:
-                date = line._expected_date()
-            grouped_lines[(line.warehouse_id.id, date)] |= line
+            grouped_lines[(line.warehouse_id.id, line.order_id.commitment_date or line._expected_date())] |= line
 
-        treated = self.browse()
         for (warehouse, scheduled_date), lines in grouped_lines.items():
             product_qties = lines.mapped('product_id').with_context(to_date=scheduled_date, warehouse=warehouse).read([
                 'qty_available',
@@ -324,6 +342,7 @@ class SaleOrderLine(models.Model):
                 line.qty_available_today = qty_available_today - qty_processed_per_product[line.product_id.id]
                 line.free_qty_today = free_qty_today - qty_processed_per_product[line.product_id.id]
                 line.virtual_available_at_date = virtual_available_at_date - qty_processed_per_product[line.product_id.id]
+                line.forecast_expected_date = False
                 if line.product_uom and line.product_id.uom_id and line.product_uom != line.product_id.uom_id:
                     line.qty_available_today = line.product_id.uom_id._compute_quantity(line.qty_available_today, line.product_uom)
                     line.free_qty_today = line.product_id.uom_id._compute_quantity(line.free_qty_today, line.product_uom)
@@ -333,6 +352,7 @@ class SaleOrderLine(models.Model):
         remaining = (self - treated)
         remaining.virtual_available_at_date = False
         remaining.scheduled_date = False
+        remaining.forecast_expected_date = False
         remaining.free_qty_today = False
         remaining.qty_available_today = False
 
@@ -366,31 +386,7 @@ class SaleOrderLine(models.Model):
     @api.depends('move_ids', 'order_id.expected_date', 'qty_delivered')
     def _compute_json_forecast(self):
         self.json_forecast = False
-        if not any(self._ids):
-            # onchange
-            return
-        # compute
-        precision = self.env['decimal.precision'].precision_get('Product Unit of Measure')
-        for so_line in self:
-            if any(move.state == 'done' for move in so_line.move_ids) or not so_line.move_ids.picking_id:
-                qty_delivered = float_repr(so_line.qty_delivered, precision)
-                so_line.json_forecast = json.dumps({'reservedAvailability': qty_delivered})
-            else:
-                # For waiting deliveries, take the info from the report line.
-                delivery = so_line.move_ids.picking_id.filtered(lambda picking: picking.state in ['confirmed', 'waiting'])
-                if delivery.exists():
-                    moves_to_process = so_line.move_ids.filtered(lambda move: move.id in delivery.move_lines.ids and move.state not in ['cancel', 'done'])
-                    if moves_to_process.exists():
-                        so_line.json_forecast = moves_to_process[0].json_forecast
-                else:
-                    # For assigned deliveries, take the delivery's date.
-                    delivery = so_line.move_ids.picking_id.filtered(lambda picking: picking.state == 'assigned')
-                    if delivery.exists():
-                        date_expected = delivery.scheduled_date
-                        so_line.json_forecast = json.dumps({
-                            'expectedDate': format_date(self.env, date_expected),
-                            'isLate': date_expected > so_line.order_id.expected_date,
-                        })
+        # TODO: remove this fields in master -> computation done in _compute_qty_at_date
 
     @api.depends('product_id')
     def _compute_qty_delivered_method(self):
