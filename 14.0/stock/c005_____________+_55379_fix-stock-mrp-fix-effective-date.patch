PR: https://github.com/odoo/odoo/pull/55379

From: 8d62eacfff5f94f692661c221c7b43f39bd3b891
From: RÃ©my Voet (ryv)
Date: 2020-08-18 07:48:27

Structural Changes: 3
Total Changes: 58

[FIX] *stock*, mrp: fix effective_date

- Avoid to truncate the hour/min/sec in the computation of the
effective date which is related to the `date_done`
of the first incoming picking.
- With manufacturing in 3-step (pbm_sam), the store picking
had a source document == "New". It was the case because
the `_get_move_finished_values` was call before the create
and the name is set only on create.
To fix this issue, during the `create` set the origin of all move.
- To avoid to maintain old views unused,
remove unused view of stock move.
- The computation of the products_availability json is too expensive
to be in tree view (2.5 times long with it) of picking.
It will be hard to optimize because the half the time
is due to _get_report_lines method - already in batch (on 80 records).
- Review buttons of the replenishment list to be more Odooer.
- In some cases the delay alert date was wrongly compute:
  - If we new dest_move_ids of a existant move, the delay alert date
    won't be compute.
  - If the state (to done) and the date are save in same write call
    the alert date of next move won't be reset.
To avoids these issues, refactor the alert date to be a compute stored
fields.
- To avoid any confusion between date expected in the replenishement
(in date) and the purchase order receipt date (datetime),
we put the receipt date at the middle of the day.
Also  On-Time Delivery Rate computation counts
only when date are bigger effective date trunced to date.
Also used the timezone of the company by default (if not user timezone)

task-2246665

closes odoo/odoo#55379

Related: odoo/upgrade#1586
Related: odoo/enterprise#12309
Signed-off-by: Arnold Moyaux <amoyaux@users.noreply.github.com>

================================= pseudo patch: =================================

--- a/addons/stock/models/stock_move.py
+++ b/addons/stock/models/stock_move.py
@@ -133,7 +133,7 @@ class StockMove(models.Model):
     propagate_cancel = fields.Boolean(
         'Propagate cancel and split', default=True,
         help='If checked, when this move is cancelled, cancel the linked move too')
-    delay_alert_date = fields.Datetime('Delay Alert Date', help='Process at this date to be on time')
+    delay_alert_date = fields.Datetime('Delay Alert Date', help='Process at this date to be on time', compute="_compute_delay_alert_date", store=True)
     picking_type_id = fields.Many2one('stock.picking.type', 'Operation Type', check_company=True)
     inventory_id = fields.Many2one('stock.inventory', 'Inventory', check_company=True)
     move_line_ids = fields.One2many('stock.move.line', 'move_id')
@@ -290,6 +290,19 @@ class StockMove(models.Model):
             return self.move_line_nosuggest_ids
         return self.move_line_ids
 
+    @api.depends('move_orig_ids.date', 'move_orig_ids.state', 'state', 'date')
+    def _compute_delay_alert_date(self):
+        for move in self:
+            if move.state in ('done', 'cancel'):
+                move.delay_alert_date = False
+                continue
+            prev_moves = move.move_orig_ids.filtered(lambda m: m.state not in ('done', 'cancel') and m.date)
+            prev_max_date = max(prev_moves.mapped("date"), default=False)
+            if prev_max_date and prev_max_date > move.date:
+                move.delay_alert_date = prev_max_date
+            else:
+                move.delay_alert_date = False
+
     @api.depends('move_line_ids.qty_done', 'move_line_ids.product_uom_id', 'move_line_nosuggest_ids.qty_done', 'picking_type_id')
     def _quantity_done_compute(self):
         """ This field represents the sum of the move lines `qty_done`. It allows the user to know
@@ -514,11 +527,6 @@ class StockMove(models.Model):
                 # When editing the initial demand, directly run again action assign on receipt moves.
                 receipt_moves_to_reassign |= move_to_unreserve.filtered(lambda m: m.location_id.usage == 'supplier')
                 receipt_moves_to_reassign |= (self - move_to_unreserve).filtered(lambda m: m.location_id.usage == 'supplier' and m.state in ('partially_available', 'assigned'))
-        # Handle alert date about the scheduled date
-        if vals.get('date'):
-            new_date = fields.Datetime.to_datetime(vals.get('date'))
-            for move in self:
-                move._delay_alert_check(new_date)
         res = super(StockMove, self).write(vals)
         if 'date_deadline' in vals:
             self._set_date_deadline()
@@ -562,41 +570,6 @@ class StockMove(models.Model):
             odoobot_id = self.env['ir.model.data'].xmlid_to_res_id("base.partner_root")
             doc.message_post(body=msg, author_id=odoobot_id, subject=msg_subject)
 
-    def _delay_alert_check(self, new_date=None):
-        """Set an alert on late moves by using the `delay_alert_date` field.
-        The alert is always on the move that cannot be done because its preceding moves are late.
-
-        :param new_date: the new expected date, to set when calling this method before `create` or `write`
-        :param new_date: datetime, optional
-        """
-        self.ensure_one()
-        if self.state in ('done', 'cancel'):
-            return
-
-        if new_date is None:
-            new_date = self.date
-
-        # Check if `self` is scheduled after the next moves. If so, the next moves are late.
-        next_moves = self.move_dest_ids.filtered(lambda move: move.state != 'cancel')
-        next_nondone_moves = next_moves.filtered(lambda move: move.state != 'done')
-        next_moves_dates = next_moves.mapped('date')
-        if next_moves_dates:
-            next_moves_date = min(next_moves_dates)
-            if new_date > next_moves_date:
-                next_nondone_moves.write({'delay_alert_date': new_date})
-            else:
-                next_nondone_moves.write({'delay_alert_date': False})
-
-        # Check if `self` is scheduled before the previous moves. If so, `self` if late.
-        previous_moves = self.move_orig_ids.filtered(lambda move: move.state != 'cancel')
-        previous_moves_dates = previous_moves.mapped('date')
-        if previous_moves_dates:
-            previous_moves_date = max(previous_moves_dates)
-            if new_date < previous_moves_date:
-                self.write({'delay_alert_date': previous_moves_date})
-            else:
-                self.write({'delay_alert_date': False})
-
     def action_show_details(self):
         """ Returns an action that will open a form view (in a popup) allowing to work on all the
         move lines of a particular move. This form view is used when "show operations" is not
@@ -1362,7 +1335,6 @@ class StockMove(models.Model):
         self.write({
             'state': 'cancel',
             'move_orig_ids': [(5, 0, 0)],
-            'delay_alert_date': False,
             'procure_method': 'make_to_stock',
         })
         return True
@@ -1469,7 +1441,7 @@ class StockMove(models.Model):
             if len(result_package.quant_ids.filtered(lambda q: not float_is_zero(abs(q.quantity) + abs(q.reserved_quantity), precision_rounding=q.product_uom_id.rounding)).mapped('location_id')) > 1:
                 raise UserError(_('You cannot move the same package content more than once in the same transfer or split the same package into two location.'))
         picking = moves_todo.mapped('picking_id')
-        moves_todo.write({'state': 'done', 'date': fields.Datetime.now(), 'delay_alert_date': False})
+        moves_todo.write({'state': 'done', 'date': fields.Datetime.now()})
 
         move_dests_per_company = defaultdict(lambda: self.env['stock.move'])
         for move_dest in moves_todo.move_dest_ids:
