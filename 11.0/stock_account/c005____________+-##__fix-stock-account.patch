PR: https://github.com/odoo/odoo/pull/

From: b27b86955ff16fb905f9c57a990bc77ae5c5245d
From: Simon Lejeune
Date: 2017-09-25 13:34:55

Structural Changes: 6
Total Changes: 205

[FIX] stock_account

This commit fixes:
- an expected singleton in vacuum, as `_get_in_domain` should be called
  on the move we are looping on, not the whole recordset
- some entries were posted for non valuated stock moves
- the depends for the stock value where not correct and the value was
  not recomputed when it should
- there was a mismatch between `get_price_unit` and `_get_price_unit`,
  we rename all these method into the private one
- the valuation fields were copied on copied move. this proved to be
  problmatic when creating extra move
- in the `_fifo_vacuum` method, when looking for candidates, filter on
  available ones

We also refactore the way the valuation is implemented. Indeed, before
this commit, the valuation of a product was the sum of all the sum
fields of the valuated stock moves associated to the given product. This
proved to be the wrong approach when dealing with done stock move
edition and negative stock. Let's say you sold 20 items you do not have,
we'll post an entry with the estimated price and later, when we correct
this entry after receiving new products, updating the value was
complicated. We moved out from this approach by never editing the value
(it is the value at which the stock move was initially valuated) but
updating the remaining value: a negative stock move has a negative
remaining value, every time we compensate it we increase the value. Once
the remaining quantity is null, we wipe the remaining value. We adapted
the code according to this new principle, especially the code posting
the correction entry (that should compensate the negative remaiing
value).

A mechanism was not correctly implemented: increasing the quantity of a
done out move should re-run the fifo lookup. We extract the `_run_fifo`
method into a model method and add to it an optional quantity argument.
This allows to run the method from the write on a done stock move.

We also raise a blocking error if the valuation is 0, it means that the
user has not correctly set its master data.

We add a bunch of tests for all these usecases and complete some older
ones to check the total of account entries.

================================= pseudo patch: =================================

--- a/addons/stock_account/models/product.py
+++ b/addons/stock_account/models/product.py
@@ -159,6 +159,7 @@ class ProductProduct(models.Model):
         return candidates
 
     @api.multi
+    @api.depends('stock_move_ids.product_qty', 'stock_move_ids.state')
     def _compute_stock_value(self):
         for product in self:
             if product.cost_method in ['standard', 'average']:
@@ -167,7 +168,7 @@ class ProductProduct(models.Model):
                 StockMove = self.env['stock.move']
                 domain = [('product_id', '=', product.id)] + StockMove._get_all_base_domain()
                 moves = StockMove.search(domain)
-                product.stock_value = sum(moves.mapped('value'))
+                product.stock_value = sum(moves.mapped('remaining_value'))
 
     @api.multi
     def action_open_product_moves(self):

--- a/addons/stock_account/models/stock.py
+++ b/addons/stock_account/models/stock.py
@@ -59,23 +59,36 @@ class StockMoveLine(models.Model):
             # We need to update the `value`, `remaining_value` and `remaining_qty` on the linked
             # stock move.
             moves_to_update = {}
-            for move_line in self.filtered(lambda ml: ml.state == 'done'):
+            for move_line in self.filtered(lambda ml: ml.state == 'done' and (ml.move_id._is_in() or ml.move_id._is_out())):
                 moves_to_update[move_line.move_id] = vals['qty_done'] - move_line.qty_done
 
             for move_id, qty_difference in moves_to_update.items():
-                # more/less units are available, update `value`, `remaining_value` and
+                # more/less units are available, update `remaining_value` and
                 # `remaining_qty` on the linked stock move.
-                move_vals = {
-                    'value': move_id.value + qty_difference * move_id.price_unit,
-                    'remaining_value': move_id.remaining_value + qty_difference * move_id.price_unit,
-                    'remaining_qty': move_id.remaining_qty + qty_difference,
-                }
+                move_vals = {'remaining_qty': move_id.remaining_qty + qty_difference}
+                if move_id.product_id.cost_method in ['standard', 'average']:
+                    correction_value = qty_difference * move_id.product_id.standard_price
+                else:
+                    # FIFO handling
+                    if move_id._is_in():
+                        correction_value = qty_difference * move_id.price_unit
+                    elif move_id._is_out() and qty_difference > 0:
+                        # send more, run fifo again
+                        correction_value = self.env['stock.move']._run_fifo(move_id, quantity=qty_difference)
+                    elif move_id._is_out() and qty_difference < 0:
+                        # return, value at last fifo price
+                        correction_value = qty_difference * move_id.product_id.standard_price
+                remaining_value = move_id.remaining_value + correction_value
+                if move_id._is_out():
+                    move_vals['remaining_value'] = remaining_value if remaining_value < 0 else 0
+                else:
+                    move_vals['remaining_value'] = remaining_value
                 move_id.write(move_vals)
+
                 if move_id.product_id.valuation == 'real_time':
-                    if move_id.product_id.cost_method == 'standard':
-                        move_id.with_context(force_valuation_amount=qty_difference * move_id.product_id.standard_price)._account_entry_move()
-                    else:
-                        move_id.with_context(force_valuation_amount=qty_difference*move_id.price_unit)._account_entry_move()
+                    move_id.with_context(force_valuation_amount=correction_value)._account_entry_move()
+                if qty_difference > 0:
+                    move_id.product_price_update_before_done(forced_qty=qty_difference)
         return super(StockMoveLine, self).write(vals)
 
 
@@ -84,9 +97,9 @@ class StockMove(models.Model):
 
     to_refund = fields.Boolean(string="To Refund (update SO/PO)", copy=False,
                                help='Trigger a decrease of the delivered/received quantity in the associated Sale Order/Purchase Order')
-    value = fields.Float()
-    remaining_qty = fields.Float()
-    remaining_value = fields.Float()
+    value = fields.Float(copy=False)
+    remaining_qty = fields.Float(copy=False)
+    remaining_value = fields.Float(copy=False)
     account_move_ids = fields.One2many('account.move', 'stock_move_id')
 
     @api.multi
@@ -99,7 +112,7 @@ class StockMove(models.Model):
         action_data['domain'] = [('id', 'in', self.account_move_ids.ids)]
         return action_data
 
-    def get_price_unit(self):
+    def _get_price_unit(self):
         """ Returns the unit price to store on the quant """
         return self.price_unit or self.product_id.standard_price
 
@@ -148,13 +161,68 @@ class StockMove(models.Model):
         """
         return self.location_id.company_id.id == self.company_id.id and not self.location_dest_id.company_id
 
+    @api.model
+    def _run_fifo(self, move, quantity=None):
+        move.ensure_one()
+        # Find back incoming stock moves (called candidates here) to value this move.
+        qty_to_take_on_candidates = quantity or move.product_qty
+        candidates = move.product_id._get_fifo_candidates_in_move()
+        new_standard_price = 0
+        tmp_value = 0  # to accumulate the value taken on the candidates
+        for candidate in candidates:
+            new_standard_price = candidate.price_unit
+            if candidate.remaining_qty <= qty_to_take_on_candidates:
+                qty_taken_on_candidate = candidate.remaining_qty
+            else:
+                qty_taken_on_candidate = qty_to_take_on_candidates
+
+            # As applying a landed cost do not update the unit price, naivelly doing
+            # something like qty_taken_on_candidate * candidate.price_unit won't make
+            # the additional value brought by the landed cost go away.
+            candidate_price_unit = candidate.remaining_value / candidate.remaining_qty
+            value_taken_on_candidate = qty_taken_on_candidate * candidate_price_unit
+            candidate_vals = {
+                'remaining_qty': candidate.remaining_qty - qty_taken_on_candidate,
+                'remaining_value': candidate.remaining_value - value_taken_on_candidate,
+            }
+            candidate.write(candidate_vals)
+
+            qty_to_take_on_candidates -= qty_taken_on_candidate
+            tmp_value += value_taken_on_candidate
+            if qty_to_take_on_candidates == 0:
+                break
+
+        # Update the standard price with the price of the last used candidate, if any.
+        if new_standard_price:
+            move.product_id.standard_price = new_standard_price
+
+        # If there's still quantity to value but we're out of candidates, we fall in the
+        # negative stock use case. We chose to value the out move at the price of the
+        # last out and a correction entry will be made once `_fifo_vacuum` is called.
+        if qty_to_take_on_candidates == 0:
+            move.write({
+                'value': -tmp_value,  # outgoing move are valued negatively
+                'price_unit': -tmp_value / move.product_qty,
+            })
+        elif qty_to_take_on_candidates > 0:
+            last_fifo_price = new_standard_price or move.product_id.standard_price
+            negative_stock_value = last_fifo_price * -qty_to_take_on_candidates
+            vals = {
+                'remaining_qty': -qty_to_take_on_candidates,
+                'remaining_value': negative_stock_value,
+                'value': -tmp_value + negative_stock_value,
+                'price_unit': (-tmp_value + negative_stock_value) / move.product_qty,
+            }
+            move.write(vals)
+        return tmp_value
+
     def _action_done(self):
         self.product_price_update_before_done()
         res = super(StockMove, self)._action_done()
         for move in res:
             if move._is_in():
                 if move.product_id.cost_method in ['fifo', 'average']:
-                    price_unit = move.price_unit or move.get_price_unit()
+                    price_unit = move.price_unit or move._get_price_unit()
                     value = price_unit * move.product_qty
                     vals = {
                         'price_unit': price_unit,
@@ -171,52 +239,7 @@ class StockMove(models.Model):
                     })
             elif move._is_out():
                 if move.product_id.cost_method == 'fifo':
-                    # Find back incoming stock moves (called candidates here) to value this move.
-                    qty_to_take_on_candidates = move.product_qty
-                    candidates = move.product_id._get_fifo_candidates_in_move()
-                    new_standard_price = 0
-                    tmp_value = 0  # to accumulate the value taken on the candidates
-                    for candidate in candidates:
-                        new_standard_price = candidate.price_unit
-                        if candidate.remaining_qty <= qty_to_take_on_candidates:
-                            qty_taken_on_candidate = candidate.remaining_qty
-                        else:
-                            qty_taken_on_candidate = qty_to_take_on_candidates
-
-                        value_taken_on_candidate = qty_taken_on_candidate * candidate.price_unit
-                        candidate_vals = {
-                            'remaining_qty': candidate.remaining_qty - qty_taken_on_candidate,
-                            'remaining_value': candidate.remaining_value - value_taken_on_candidate,
-                        }
-                        candidate.write(candidate_vals)
-
-                        qty_to_take_on_candidates -= qty_taken_on_candidate
-                        tmp_value += value_taken_on_candidate
-                        if qty_to_take_on_candidates == 0:
-                            break
-
-                    # Update the standard price with the price of the last used candidate, if any.
-                    if new_standard_price:
-                        move.product_id.standard_price = new_standard_price
-
-                    # If there's still quantity to value but we're out of candidates, we fall in the
-                    # negative stock use case. We chose to value the out move at the price of the
-                    # last out and a correction entry will be made once `_fifo_vacuum` is called.
-                    if qty_to_take_on_candidates == 0:
-                        move.write({
-                            'value': -tmp_value,  # outgoing move are valued negatively
-                            'price_unit': -tmp_value / move.product_qty,
-                        })
-                    elif qty_to_take_on_candidates > 0:
-                        last_fifo_price = new_standard_price or move.product_id.standard_price
-                        negative_stock_value = last_fifo_price * -qty_to_take_on_candidates
-                        vals = {
-                            'remaining_qty': -qty_to_take_on_candidates,
-                            'remaining_value': negative_stock_value,
-                            'value': -tmp_value + negative_stock_value,
-                            'price_unit': (-tmp_value + negative_stock_value) / move.product_qty,
-                        }
-                        move.write(vals)
+                    self.env['stock.move']._run_fifo(move)
                 elif move.product_id.cost_method in ['standard', 'average']:
                     curr_rounding = move.company_id.currency_id.rounding
                     value = -float_round(move.product_id.standard_price * move.product_qty, precision_rounding=curr_rounding)
@@ -224,12 +247,12 @@ class StockMove(models.Model):
                         'value': value,
                         'price_unit': value / move.product_qty,
                     })
-        for move in res.filtered(lambda m: m.product_id.valuation == 'real_time'):
+        for move in res.filtered(lambda m: m.product_id.valuation == 'real_time' and (m._is_in() or m._is_out())):
             move._account_entry_move()
         return res
 
     @api.multi
-    def product_price_update_before_done(self):
+    def product_price_update_before_done(self, forced_qty=None):
         tmpl_dict = defaultdict(lambda: 0.0)
         # adapt standard price on incomming moves if the product cost_method is 'average'
         std_price_update = {}
@@ -237,11 +260,12 @@ class StockMove(models.Model):
             product_tot_qty_available = move.product_id.qty_available + tmpl_dict[move.product_id.id]
 
             if product_tot_qty_available == 0:
-                new_std_price = move.get_price_unit()
+                new_std_price = move._get_price_unit()
             else:
                 # Get the standard price
                 amount_unit = std_price_update.get((move.company_id.id, move.product_id.id)) or move.product_id.standard_price
-                new_std_price = ((amount_unit * product_tot_qty_available) + (move.get_price_unit() * move.product_qty)) / (product_tot_qty_available + move.product_qty)
+                qty = forced_qty or move.product_qty
+                new_std_price = ((amount_unit * product_tot_qty_available) + (move._get_price_unit() * qty)) / (product_tot_qty_available + move.product_qty)
 
             tmpl_dict[move.product_id.id] += move.product_qty
             # Write the standard price, as SUPERUSER_ID because a warehouse manager may not have the right to write on products
@@ -252,19 +276,19 @@ class StockMove(models.Model):
     def _fifo_vacuum(self):
         """ Every moves that need to be fixed are identifiable by having a negative `remaining_qty`.
         """
-        # FIXME: sort by date (does filtered lose the order?)
         for move in self.filtered(lambda m: (m._is_in() or m._is_out()) and m.remaining_qty < 0):
             domain = [
+                ('remaining_qty', '>', 0),
                 '|',
                     ('date', '>', move.date),
                     '&',
                         ('date', '=', move.date),
                         ('id', '>', move.id)
             ]
-            domain += self._get_in_domain()
+            domain += move._get_in_domain()
             candidates = self.search(domain, order='date, id')
             if not candidates:
-                return
+                continue
             qty_to_take_on_candidates = abs(move.remaining_qty)
             tmp_value = 0
             for candidate in candidates:
@@ -285,8 +309,27 @@ class StockMove(models.Model):
                 if qty_to_take_on_candidates == 0:
                     break
 
-            corrected_value = move.remaining_value + tmp_value
+            remaining_value_before_vacuum = move.remaining_value
+
+            # If `remaining_qty` should be updated to 0, we wipe `remaining_value`. If it was set
+            # it was only used to infer the correction entry anyway.
+            new_remaining_qty = -qty_to_take_on_candidates
+            new_remaining_value = 0 if not new_remaining_qty else move.remaining_value + tmp_value
+            move.write({
+                'remaining_value': new_remaining_value,
+                'remaining_qty': new_remaining_qty,
+            })
+
             if move.product_id.valuation == 'real_time':
+                # If `move.remaining_value` is negative, it means that we initially valued this move at
+                # an estimated price *and* posted an entry. `tmp_value` is the real value we took to
+                # compensate and should always be positive, but if the remaining value is still negative
+                # we have to take care to not overvalue by decreasing the correction entry by what's
+                # already been posted.
+                corrected_value = tmp_value
+                if remaining_value_before_vacuum < 0:
+                    corrected_value += remaining_value_before_vacuum
+
                 if move._is_in():
                     # If we just compensated an IN move that has a negative remaining
                     # quantity, it means the move has returned more items than it received.
@@ -297,21 +340,6 @@ class StockMove(models.Model):
                 else:
                     move.with_context(force_valuation_amount=corrected_value)._account_entry_move()
 
-            if qty_to_take_on_candidates == 0:
-                move.write({
-                    'value': move.value - corrected_value,
-                    'remaining_value': 0,
-                    'remaining_qty': 0,
-                })
-            elif qty_to_take_on_candidates > 0:
-                # It's possible that `remaining_value` is equals to 0 even if the move needs to be
-                # compensated (negative stock for the first ever out in FIFO).
-                move.write({
-                    'value': move.value - corrected_value,
-                    'remaining_value': 0 if not move.remaining_value else move.remaining_value + corrected_value,
-                    'remaining_qty': -qty_to_take_on_candidates,
-                })
-
     @api.multi
     def _get_accounting_data_for_valuation(self):
         """ Return the accounts and journal to use to post Journal Entries for
@@ -361,9 +389,7 @@ class StockMove(models.Model):
 
         # check that all data is correct
         if self.company_id.currency_id.is_zero(debit_value):
-            if self.product_id.cost_method == 'standard':
-                raise UserError(_("The found valuation amount for product %s is zero. Which means there is probably a configuration error. Check the costing method and the standard price") % (self.product_id.name,))
-            return []
+            raise UserError(_("The found valuation amount for product %s is zero. Which means there is probably a configuration error. Check the costing method and the standard price") % (self.product_id.name,))
         credit_value = debit_value
 
         if self.product_id.cost_method == 'average' and self.company_id.anglo_saxon_accounting:
