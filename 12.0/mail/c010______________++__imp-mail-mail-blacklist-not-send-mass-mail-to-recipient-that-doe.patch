PR: https://github.com/odoo/odoo/pull/

From: 98ce81cac51793dbab45e8f305a2086b9095aead
From: David Beguin
Date: 2018-08-10 15:46:08

Structural Changes: 4
Total Changes: 98

[IMP] mail - mail.blacklist: Not send mass_mail to recipient that does't want to

Purpose
=======
Improve mailing subscription to be more compliant with the European GDPR law.
Keep a list of people who does not want to receive promotional emails
(or mass mailing in general) anymore.

Specifications
===========
This commit is regrouping some main changes on mass mailing.
- Added blacklist : Avoid sending mass mailing to blacklisted recipient
  (blacklisted = email address that doens't want to receive mass mailing anymore)

Detailed implementation
===================
Mail :
- Add Blacklist mechanism in mail module (NOT in mass-mailing) :
  as we can send mass-mail without the mass-mailing module
- Unicity in email -> To avoid error in import, override the create and return
  the existing record if any, else, create the record normally.
- Blacklisting is done by email address and is cross model.
  Will apply to model that inherit the blacklist.mixin.
- field 'is_blacklisted' -> computed : check if email is in blacklist
  + search method to be able to filter on is_blacklisted
- When a email address is blacklisted, it will never get mass mailings anymore.
  Even if the email address is added to another mailing lists
- Avoid sending notification to blacklisted recipients when sending email
  in mass mail mode. If the recipient is blacklisted, we should not even send a
  notification in the recipient's chatter for an email that he won't even
  receive.
- When a email address is blacklisted, it can still get 'normal' mailings.
- The blacklist shoud be accessible in
  Mass Mailing / Configuration / Blacklist
  and Settings / Technical / Email / Blacklist
  -> Renaming Settings / Technical / White / Black List config menu item
     into Channel Moderation to avoid confusion with Mass Mail Blacklist
- Add indexes to the blacklist table (on email) to make it fast for access for
  the different use cases
- _primary_email : attribute that must be overriden to specify which field must
  be used as email in the blacklist mechanism.
- Filtering the blacklisted recipient in mail composer :
  done in mail._get mail value()
  In case of real mass mailing, we need the statistics to be computed in order
  to know how many recipients were ignored in the mail.
  So we cannot avoid sending mail but instead flag the mail as canceled.

Task ID 33224

================================= pseudo patch: =================================

--- a/addons/mail/models/__init__.py
+++ b/addons/mail/models/__init__.py
@@ -10,6 +10,7 @@ from . import mail_message
 from . import mail_activity
 from . import mail_mail
 from . import mail_thread
+from . import mail_blacklist
 from . import mail_channel
 from . import mail_template
 from . import mail_shortcode

--- a/None
+++ b/addons/mail/models/mail_blacklist.py
@@ -0,0 +1,97 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from odoo import api, fields, models, _
+from odoo.exceptions import UserError
+from odoo.tools.pycompat import izip
+
+
+class MailBlackList(models.Model):
+    """ Model of blacklisted email addresses to stop sending emails."""
+    _name = 'mail.blacklist'
+    _inherit = ['mail.thread']
+    _description = 'Mail Blacklist'
+    _rec_name = 'email'
+
+    email = fields.Char(string='Email Address', required=True, index=True, help='This field is case insensitive.',
+                        track_visibility=True)
+    active = fields.Boolean(default=True, track_visibility=True)
+
+    _sql_constraints = [
+        ('unique_email', 'unique (email)', 'Email address already exists!')
+    ]
+
+    @api.model_create_multi
+    def create(self, values):
+        """ To avoid crash during import due to unique email, return the existing records if any """
+        sql = '''SELECT id, email FROM mail_blacklist
+                WHERE LOWER(email) = any (array[%s])
+                ''' % (', '.join(['%s'] * len(values)))
+        params = [value['email'].lower() for value in values]
+        self._cr.execute(sql, params)
+        records = self._cr.fetchall()
+
+        bl_ids = bl_emails = []
+        if records:
+            bl_ids, bl_emails = list(izip(*records))
+        non_blacklisted_records = [value for value in values if value['email'] not in bl_emails]
+
+        # TODO DBE Fixme : reorder ids according to incoming ids.
+        results = super(MailBlackList, self).create(non_blacklisted_records)
+        return self.env['mail.blacklist'].browse(bl_ids) | results
+
+    def _add(self, email):
+        record = self.env["mail.blacklist"].with_context(active_test=False).search([('email', '=', email)])
+        if len(record) > 0:
+            record.write({'active': True})
+        else:
+            record = self.create({'email': email})
+        return record
+
+    def _remove(self, email):
+        record = self.env["mail.blacklist"].with_context(active_test=False).search([('email', '=', email)])
+        if len(record) > 0:
+            record.write({'active': False})
+        else:
+            raise UserError(_('This email does not belong to the blacklist.'))
+
+
+class MailBlackListMixin(models.AbstractModel):
+    """ Mixin that is inherited by all model with opt out.
+        USAGE : the field '_primary_email' must be overridden in the model that inherit the mixin
+        and must contain the email field of the model.
+        """
+    _name = 'mail.blacklist.mixin'
+    _description = 'Mail Blacklist mixin'
+    _primary_email = ['email']
+
+    # Note : is_blacklisted sould only be used for display. As the compute is not depending on the blacklist,
+    # once read, it won't be re-computed again if the blacklist is modified in the same request.
+    is_blacklisted = fields.Boolean(string='Blacklist', compute="_compute_is_blacklisted", compute_sudo=True,
+        store=False, search="_search_is_blacklisted", groups="base.group_user",
+        help="If the email address is on the blacklist, the contact won't receive mass mailing anymore, from any list")
+
+    @api.model
+    def _search_is_blacklisted(self, operator, value):
+        if not hasattr(self.env[self._name], "_primary_email"):
+            raise UserError(_('Invalid primary email field on model %s') % self._name)
+        [email_field] = self._primary_email
+        join_condition = 'INNER' if value else 'RIGHT'
+        where_clause = '' if value else ' where b.id is null'
+        blacklisted_sql = '''SELECT a.id FROM mail_blacklist b 
+            %s JOIN %s a 
+            ON b.email = a.%s AND b.active = True%s''' % (join_condition, self._table, email_field, where_clause)
+        self._cr.execute(blacklisted_sql)
+        res = self._cr.fetchall()
+        if not res:
+            return [(0, '=', 1)]
+        return [('id', 'in', [r[0] for r in res])]
+
+    @api.depends(lambda self: self._primary_email)
+    def _compute_is_blacklisted(self):
+        [email_field] = self._primary_email
+        # TODO : Should remove the sudo as compute_sudo defined on methods.
+        # But if user doesn't have access to mail.blacklist, doen't work without sudo().
+        blacklist = self.env['mail.blacklist'].sudo().search([('email', 'in', self.mapped(email_field))]).mapped('email')
+        for record in self:
+            record.is_blacklisted = record[email_field] in blacklist
