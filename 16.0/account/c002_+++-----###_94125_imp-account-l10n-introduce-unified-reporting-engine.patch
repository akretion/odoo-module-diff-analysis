PR: https://github.com/odoo/odoo/pull/94125

From: b7232b14b7f2423241b24b4eef1300f1a1b425cf
From: oco-odoo
Date: 2022-08-25 17:56:55

Breaking data model changes score: 46, change matches:
-    tax_report_line_ids = fields.Many2many(string="Tax Report Lines", comodel_name='account.tax.report.line', relation='account_tax_report_line_tags_rel', help="The tax report lines using this tag")
+    line_ids = fields.One2many(string="Lines", comodel_name='account.report.line', inverse_name='report_id')
+    column_ids = fields.One2many(string="Columns", comodel_name='account.report.column', inverse_name='report_id')
+    variant_report_ids = fields.One2many(string="Variants", comodel_name='account.report', inverse_name='root_report_id')
+    expression_ids = fields.One2many(string="Expressions", comodel_name='account.report.expression', inverse_name='report_line_id')
+    children_ids = fields.One2many(string="Child Lines", comodel_name='account.report.line', inverse_name='parent_id')
-    name = fields.Char(required=True)
-    amount = fields.Float(required=True, default=0.0)
-    date = fields.Date(required=True, default=fields.Date.context_today)
-    tax_report_line_id = fields.Many2one(
-    tax_report_id = fields.Many2one(related='tax_report_line_id.report_id')
-    tax_report_country_id = fields.Many2one(related='tax_report_id.country_id')
-    company_id = fields.Many2one(
-    foreign_vat_fiscal_position_id = fields.Many2one(
-    name = fields.Char(string="Name", required=True, help="Name of this tax report")
-    country_id = fields.Many2one(string="Country", comodel_name='res.country', required=True, default=lambda x: x.env.company.country_id.id, help="Country for which this report is available.")
-    line_ids = fields.One2many(string="Report Lines", comodel_name='account.tax.report.line', inverse_name='report_id', help="Content of this tax report")
-    root_line_ids = fields.One2many(string="Root Report Lines", comodel_name='account.tax.report.line', inverse_name='report_id', domain=[('parent_id', '=', None)], help="Subset of line_ids, containing the lines at the root of the report.")
-    name = fields.Char(
-    report_action_id = fields.Many2one(
-    children_line_ids = fields.One2many(
-    parent_id = fields.Many2one(
-    sequence = fields.Integer(
-    parent_path = fields.Char(index=True, unaccent=False)
-    report_id = fields.Many2one(
-    tag_name = fields.Char(
-    code = fields.Char(
-    formula = fields.Char(
-    carry_over_condition_method = fields.Selection(
-    carry_over_destination_line_id = fields.Many2one(
-    carryover_line_ids = fields.One2many(
-    is_carryover_persistent = fields.Boolean(
-    is_carryover_used_in_balance = fields.Boolean(
-    tag_ids = fields.Many2many(string="Financial Tags", relation='account_tax_repartition_financial_tags', comodel_name='account.account.tag', copy=True, help="Additional tags that will be assigned by this repartition line for use in financial reports")
-    plus_report_line_ids = fields.Many2many(string="Plus Tax Report Lines", relation='account_tax_repartition_plus_report_line', comodel_name='account.tax.report.line', copy=True, help="Tax report lines whose '+' tag will be assigned to move lines by this repartition line")
-    minus_report_line_ids = fields.Many2many(string="Minus Report Lines", relation='account_tax_repartition_minus_report_line', comodel_name='account.tax.report.line', copy=True, help="Tax report lines whose '-' tag will be assigned to move lines by this repartition line")
+    plus_report_expression_ids = fields.Many2many(string="Plus Tax Report Expressions", relation='account_tax_rep_template_plus', comodel_name='account.report.expression', copy=True, help="Tax report expressions whose '+' tag will be assigned to move lines by this repartition line")
+    minus_report_expression_ids = fields.Many2many(string="Minus Report Expressions", relation='account_tax_rep_template_minus', comodel_name='account.report.expression', copy=True, help="Tax report expressions whose '-' tag will be assigned to move lines by this repartition line")

Total Changes: 1341

[IMP] account, l10n_*: Introduce unified reporting engine

This commit adapts account's model to the new report engine introduced for v16, and updates the data files accordingly.

account.report model is now declared in community, together with the other models used by the reporting. This is done so that the tax tags can properly be created by the tax report and used on tax templates. All the actual computation logic stays in enterprise.

See enterprise commit for full details.

Task 2524389

Part-of: odoo/odoo#94125

================================= pseudo patch: =================================

--- a/addons/account/models/__init__.py
+++ b/addons/account/models/__init__.py
@@ -7,8 +7,6 @@ from . import account_account_tag
 from . import account_account
 from . import account_journal
 from . import account_tax
-from . import account_tax_carryover_line
-from . import account_tax_report
 from . import account_reconcile_model
 from . import account_payment_term
 from . import account_move
@@ -34,3 +32,4 @@ from . import ir_actions_report
 from . import res_currency
 from . import res_bank
 from . import mail_thread
+from . import account_report

--- a/addons/account/models/account_account_tag.py
+++ b/addons/account/models/account_account_tag.py
@@ -1,6 +1,7 @@
 # -*- coding: utf-8 -*-
 from odoo import api, fields, models, _
 from odoo.exceptions import ValidationError
+from odoo import osv
 
 
 class AccountAccountTag(models.Model):
@@ -11,7 +12,6 @@ class AccountAccountTag(models.Model):
     applicability = fields.Selection([('accounts', 'Accounts'), ('taxes', 'Taxes'), ('products', 'Products')], required=True, default='accounts')
     color = fields.Integer('Color Index')
     active = fields.Boolean(default=True, help="Set active to false to hide the Account Tag without removing it.")
-    tax_report_line_ids = fields.Many2many(string="Tax Report Lines", comodel_name='account.tax.report.line', relation='account_tax_report_line_tags_rel', help="The tax report lines using this tag")
     tax_negate = fields.Boolean(string="Negate Tax Balance", help="Check this box to negate the absolute value of the balance of the lines associated with this tag in tax report computation.")
     country_id = fields.Many2one(string="Country", comodel_name='res.country', help="Country for which this tag is available, when applied on taxes.")
 
@@ -20,5 +20,33 @@ class AccountAccountTag(models.Model):
         """ Returns all the tax tags corresponding to the tag name given in parameter
         in the specified country.
         """
+        domain = self._get_tax_tags_domain(tag_name, country_id)
+        return self.env['account.account.tag'].search(domain)
+
+    @api.model
+    def _get_tax_tags_domain(self, tag_name, country_id, sign=None):
+        """ Returns a domain to search for all the tax tags corresponding to the tag name given in parameter
+        in the specified country.
+        """
         escaped_tag_name = tag_name.replace('\\', '\\\\').replace('%', '\%').replace('_', '\_')
-        return self.env['account.account.tag'].search([('name', '=like', '_' + escaped_tag_name), ('country_id', '=', country_id), ('applicability', '=', 'taxes')])
+        return [
+            ('name', '=like', (sign or '_') + escaped_tag_name),
+            ('country_id', '=', country_id),
+            ('applicability', '=', 'taxes')
+        ]
+
+    def _get_related_tax_report_expressions(self):
+        if not self:
+            return self.env['account.report.expression']
+
+        or_domains = []
+        for record in self:
+            expr_domain = [
+                '&',
+                ('report_line_id.report_id.country_id', '=', record.country_id.id),
+                ('formula', '=', record.name[1:]),
+            ]
+            or_domains.append(expr_domain)
+
+        domain = osv.expression.AND([[('engine', '=', 'tax_tags')], osv.expression.OR(or_domains)])
+        return self.env['account.report.expression'].search(domain)

--- a/addons/account/models/account_move_line.py
+++ b/addons/account/models/account_move_line.py
@@ -750,17 +750,15 @@ class AccountMoveLine(models.Model):
             for tag in record.tax_tag_ids:
                 tag_amount = (record.tax_tag_invert and -1 or 1) * (tag.tax_negate and -1 or 1) * record.balance
 
-                if tag.tax_report_line_ids:
-                    #Then, the tag comes from a report line, and hence has a + or - sign (also in its name)
-                    for report_line in tag.tax_report_line_ids:
-                        audit_str += separator if audit_str else ''
-                        audit_str += report_line.tag_name + ': ' + formatLang(self.env, tag_amount, currency_obj=currency)
+                if tag.applicability == 'taxes' and tag.name[0] in {'+', '-'}:
+                    # Then, the tag comes from a report expression, and hence has a + or - sign (also in its name)
+                    tag_name = tag.name[1:]
                 else:
                     # Then, it's a financial tag (sign is always +, and never shown in tag name)
-                    audit_str += separator if audit_str else ''
-                    audit_str += tag.name + ': ' + formatLang(self.env, tag_amount, currency_obj=currency)
+                    tag_name = tag.name
 
-            record.tax_audit = audit_str
+                audit_str += separator if audit_str else ''
+                audit_str += tag_name + ': ' + formatLang(self.env, tag_amount, currency_obj=currency)
 
     @api.depends('product_id')
     def _compute_product_uom_id(self):
@@ -2339,78 +2337,6 @@ class AccountMoveLine(models.Model):
     # MISC
     # -------------------------------------------------------------------------
 
-    @api.model
-    def _query_get(self, domain=None):
-        self.check_access_rights('read')
-
-        context = dict(self._context or {})
-        domain = domain or []
-        if not isinstance(domain, (list, tuple)):
-            domain = ast.literal_eval(domain)
-
-        date_field = 'date'
-        if context.get('aged_balance'):
-            date_field = 'date_maturity'
-        if context.get('date_to'):
-            domain += [(date_field, '<=', context['date_to'])]
-        if context.get('date_from'):
-            if not context.get('strict_range'):
-                domain += ['|', (date_field, '>=', context['date_from']), ('account_id.include_initial_balance', '=', True)]
-            elif context.get('initial_bal'):
-                domain += [(date_field, '<', context['date_from'])]
-            else:
-                domain += [(date_field, '>=', context['date_from'])]
-
-        if context.get('journal_ids'):
-            domain += [('journal_id', 'in', context['journal_ids'])]
-
-        state = context.get('state')
-        if state and state.lower() != 'all':
-            domain += [('parent_state', '=', state)]
-
-        if context.get('company_id'):
-            domain += [('company_id', '=', context['company_id'])]
-        elif context.get('allowed_company_ids'):
-            domain += [('company_id', 'in', self.env.companies.ids)]
-        else:
-            domain += [('company_id', '=', self.env.company.id)]
-
-        if context.get('reconcile_date'):
-            domain += ['|', ('reconciled', '=', False), '|', ('matched_debit_ids.max_date', '>', context['reconcile_date']), ('matched_credit_ids.max_date', '>', context['reconcile_date'])]
-
-        if context.get('account_tag_ids'):
-            domain += [('account_id.tag_ids', 'in', context['account_tag_ids'].ids)]
-
-        if context.get('account_ids'):
-            domain += [('account_id', 'in', context['account_ids'].ids)]
-
-        if context.get('analytic_tag_ids'):
-            domain += [('analytic_tag_ids', 'in', context['analytic_tag_ids'].ids)]
-
-        if context.get('analytic_account_ids'):
-            domain += [('analytic_account_id', 'in', context['analytic_account_ids'].ids)]
-
-        if context.get('partner_ids'):
-            domain += [('partner_id', 'in', context['partner_ids'].ids)]
-
-        if context.get('partner_categories'):
-            domain += [('partner_id.category_id', 'in', context['partner_categories'].ids)]
-
-        where_clause = ""
-        where_clause_params = []
-        tables = ''
-        if domain:
-            domain.append(('display_type', 'not in', ('line_section', 'line_note')))
-            domain.append(('parent_state', '!=', 'cancel'))
-
-            query = self._where_calc(domain)
-
-            # Wrap the query with 'company_id IN (...)' to avoid bypassing company access rights.
-            self._apply_ir_rules(query)
-
-            tables, where_clause, where_clause_params = query.get_sql()
-        return tables, where_clause, where_clause_params
-
     def _reconciled_lines(self):
         ids = []
         for aml in self.filtered('account_id.reconcile'):

--- a/None
+++ b/addons/account/models/account_report.py
@@ -0,0 +1,647 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+import re
+from collections import defaultdict
+
+from odoo import models, fields, api, _, osv
+from odoo.exceptions import ValidationError, UserError
+
+FIGURE_TYPE_SELECTION_VALUES = [
+    ('monetary', "Monetary"),
+    ('percentage', "Percentage"),
+    ('integer', "Integer"),
+    ('float', "Float"),
+    ('date', "Date"),
+    ('datetime', "Datetime"),
+    ('none', "No Formatting"),
+]
+
+DOMAIN_REGEX = re.compile(r'(-?sum)\((.*)\)')
+
+class AccountReport(models.Model):
+    _name = "account.report"
+    _description = "Accounting Report"
+
+    #  CORE ==========================================================================================================================================
+
+    name = fields.Char(string="Name", required=True, translate=True)
+    line_ids = fields.One2many(string="Lines", comodel_name='account.report.line', inverse_name='report_id')
+    column_ids = fields.One2many(string="Columns", comodel_name='account.report.column', inverse_name='report_id')
+    root_report_id = fields.Many2one(string="Root Report", comodel_name='account.report')
+    variant_report_ids = fields.One2many(string="Variants", comodel_name='account.report', inverse_name='root_report_id')
+    chart_template_id = fields.Many2one(string="Chart of Accounts", comodel_name='account.chart.template')
+    country_id = fields.Many2one(string="Country", comodel_name='res.country')
+    only_tax_exigible = fields.Boolean(string="Only Tax Exigible Lines")
+    caret_options_initializer = fields.Char(string="Caret Options Initializer", required=True, default='_caret_options_initializer_default')
+    availability_condition = fields.Selection(
+        string="Availability",
+        selection=[('country', "Country Matches"), ('coa', "Chart of Accounts Matches"), ('always', "Always")],
+        compute='_compute_default_availability_condition', readonly=False, store=True,
+    )
+    load_more_limit = fields.Integer(string="Load More Limit")
+    search_bar = fields.Boolean(string="Search Bar")
+
+    default_opening_date_filter = fields.Selection(
+        string="Default Opening",
+        selection=[
+            ('this_year', "This Year"),
+            ('this_quarter', "This Quarter"),
+            ('this_month', "This Month"),
+            ('today', "Today"),
+            ('last_month', "Last Month"),
+            ('last_quarter', "Last Quarter"),
+            ('last_year', "Last Year"),
+        ],
+        compute=lambda x: x._compute_report_option_filter('default_opening_date_filter', 'last_month'),
+        readonly=False, store=True, depends=['root_report_id'],
+    )
+
+    #  FILTERS =======================================================================================================================================
+    # Those fields control the display of menus on the report
+
+    filter_multi_company = fields.Selection(
+        string="Multi-Company",
+        selection=[('disabled', "Disabled"), ('selector', "Use Company Selector"), ('tax_units', "Use Tax Units")],
+        compute=lambda x: x._compute_report_option_filter('filter_multi_company', 'disabled'), readonly=False, store=True, depends=['root_report_id'],
+    )
+    filter_date_range = fields.Boolean(
+        string="Date Range",
+        compute=lambda x: x._compute_report_option_filter('filter_date_range', True), readonly=False, store=True, depends=['root_report_id'],
+    )
+    filter_show_draft = fields.Boolean(
+        string="Draft Entries",
+        compute=lambda x: x._compute_report_option_filter('filter_show_draft', True), readonly=False, store=True, depends=['root_report_id'],
+    )
+    filter_unreconciled = fields.Boolean(
+        string="Unreconciled Entries",
+        compute=lambda x: x._compute_report_option_filter('filter_unreconciled', False), readonly=False, store=True, depends=['root_report_id'],
+    )
+    filter_unfold_all = fields.Boolean(
+        string="Unfold All",
+        compute=lambda x: x._compute_report_option_filter('filter_unfold_all'), readonly=False, store=True, depends=['root_report_id'],
+    )
+    filter_period_comparison = fields.Boolean(
+        string="Period Comparison",
+        compute=lambda x: x._compute_report_option_filter('filter_period_comparison', True), readonly=False, store=True, depends=['root_report_id'],
+    )
+    filter_growth_comparison = fields.Boolean(
+        string="Growth Comparison",
+        compute=lambda x: x._compute_report_option_filter('filter_growth_comparison', True), readonly=False, store=True, depends=['root_report_id'],
+    )
+    filter_journals = fields.Boolean(
+        string="Journals",
+        compute=lambda x: x._compute_report_option_filter('filter_journals'), readonly=False, store=True, depends=['root_report_id'],
+    )
+    filter_analytic = fields.Boolean(
+        string="Filter Analytic",
+        compute=lambda x: x._compute_report_option_filter('filter_analytic'), readonly=False, store=True, depends=['root_report_id'],
+    )
+    filter_hierarchy = fields.Selection(
+        string="Account Groups",
+        selection=[('by_default', "Enabled by Default"), ('optional', "Optional"), ('never', "Never")],
+        compute=lambda x: x._compute_report_option_filter('filter_hierarchy', 'never'), readonly=False, store=True, depends=['root_report_id'],
+    )
+    filter_account_type = fields.Boolean(
+        string="Account Types",
+        compute=lambda x: x._compute_report_option_filter('filter_account_type'), readonly=False, store=True, depends=['root_report_id'],
+    )
+    filter_partner = fields.Boolean(
+        string="Partners",
+        compute=lambda x: x._compute_report_option_filter('filter_partner'), readonly=False, store=True, depends=['root_report_id'],
+    )
+    filter_fiscal_position = fields.Boolean(
+        string="Filter Multivat",
+        compute=lambda x: x._compute_report_option_filter('filter_fiscal_position'), readonly=False, store=True, depends=['root_report_id'],
+    )
+
+    #  CUSTOM REPORTS ================================================================================================================================
+    # Those fields allow case-by-case fine-tuning or the engine, for custom reports
+
+    dynamic_lines_generator = fields.Char(string="Dynamic Lines Generator")
+    custom_options_initializer = fields.Char(
+        string="Custom Options Initializer",
+        compute=lambda x: x._compute_report_option_filter('custom_options_initializer'), readonly=False, store=True, depends=['root_report_id'],
+    )
+    custom_line_postprocessor = fields.Char(string="Custom Line Postprocessor")
+    custom_groupby_line_completer = fields.Char(string="Custom Groupby Line Completer")
+    custom_unfold_all_batch_data_generator = fields.Char(string="Custom Unfold All Batch Data Generator")
+
+    def _compute_report_option_filter(self, field_name, default_value=False):
+        # We don't depend on the different filter fields on the root report, as we don't want a manual change on it to be reflected on all the reports
+        # using it as their root (would create confusion). The root report filters are only used as some kind of default values.
+        for report in self:
+            if report.root_report_id:
+                report[field_name] = report.root_report_id[field_name]
+            else:
+                report[field_name] = default_value
+
+    @api.depends('root_report_id', 'country_id')
+    def _compute_default_availability_condition(self):
+        for report in self:
+            if report.root_report_id:
+                report.availability_condition = 'country'
+            else:
+                report.availability_condition = 'always'
+
+    @api.constrains('root_report_id')
+    def _validate_root_report_id(self):
+        for report in self:
+            if report.root_report_id.root_report_id:
+                raise ValidationError(_("Only a report without a root report of its own can be selected as root report."))
+
+    def write(self, vals):
+        # Overridden so that changing the country of a report also creates new tax tags if necessary, or updates the country
+        # of existing tags, if they aren't shared with another report.
+        if 'country_id' in vals:
+            impacted_reports = self.filtered(lambda x: x.country_id.id != vals['country_id'])
+            tax_tags_expressions = impacted_reports.line_ids.expression_ids.filtered(lambda x: x.engine == 'tax_tags')
+
+            for expression in tax_tags_expressions:
+                tax_tags = self.env['account.account.tag']._get_tax_tags(expression.formula, expression.report_line_id.report_id.country_id.id)
+                tag_reports = tax_tags._get_related_tax_report_expressions().report_line_id.report_id
+
+                if all(report in self for report in tag_reports):
+                    # Only reports in self are using these tags; let's change their country
+                    tax_tags.write({'country_id': vals['country_id']})
+                else:
+                    # Another report uses these tags as well; let's keep them and create new tags in the target country
+                    # if they don't exist yet.
+                    existing_tax_tags = self.env['account.account.tag']._get_tax_tags(expression.formula, vals['country_id'])
+                    if not existing_tax_tags:
+                        tag_vals = self.env['account.report.expression']._get_tags_create_vals(expression.formula, vals['country_id'])
+                        self.env['account.account.tag'].create(tag_vals)
+
+        return super().write(vals)
+
+    def copy(self, default=None):
+        '''Copy the whole financial report hierarchy by duplicating each line recursively.
+
+        :param default: Default values.
+        :return: The copied account.report record.
+        '''
+        self.ensure_one()
+        if default is None:
+            default = {}
+        default['name'] = self._get_copied_name()
+        copied_report = super().copy(default=default)
+        code_mapping = {}
+        for line in self.line_ids.filtered(lambda x: not x.parent_id):
+            line._copy_hierarchy(code_mapping, report=self, copied_report=copied_report)
+        return copied_report
+
+    def _get_copied_name(self):
+        '''Return a copied name of the account.report record by adding the suffix (copy) at the end
+        until the name is unique.
+
+        :return: an unique name for the copied account.report
+        '''
+        self.ensure_one()
+        name = self.name + ' ' + _('(copy)')
+        while self.search_count([('name', '=', name)]) > 0:
+            name += ' ' + _('(copy)')
+        return name
+
+    @api.depends('name', 'country_id')
+    def name_get(self):
+        result = []
+        for report in self:
+            result.append((report.id, report.name + (f' ({report.country_id.code})' if report.country_id else '')))
+        return result
+
+
+class AccountReportLine(models.Model):
+    _name = "account.report.line"
+    _description = "Accounting Report Line"
+    _order = 'sequence, id'
+
+    name = fields.Char(string="Name", translate=True, required=True)
+    expression_ids = fields.One2many(string="Expressions", comodel_name='account.report.expression', inverse_name='report_line_id')
+    report_id = fields.Many2one(
+        string="Parent Report",
+        comodel_name='account.report',
+        compute='_compute_report_id',
+        store=True,
+        readonly=False,
+        required=True,
+        recursive=True,
+        precompute=True,
+        ondelete='cascade'
+    )
+    hierarchy_level = fields.Integer(
+        string="Level",
+        compute='_compute_hierarchy_level',
+        store=True,
+        readonly=False,
+        recursive=True,
+        required=True,
+        precompute=True,
+    )
+    parent_id = fields.Many2one(string="Parent Line", comodel_name='account.report.line', ondelete='set null')
+    children_ids = fields.One2many(string="Child Lines", comodel_name='account.report.line', inverse_name='parent_id')
+    groupby = fields.Char(string="Group By")
+    sequence = fields.Integer(string="Sequence")
+    code = fields.Char(string="Code")
+    foldable = fields.Boolean(string="Foldable", help="By default, we always unfold the lines that can be. If this is checked; the line won't be unfolded by default, and a folding button will be displayed")
+    print_on_new_page = fields.Boolean('Print On New Page', help='When checked this line and everything after it will be printed on a new page.')
+    action_id = fields.Many2one(string="Action", comodel_name='ir.actions.actions')
+    hide_if_zero = fields.Boolean(string="Hide if Zero", help="This line and its children will be hidden when all of their columns are at 0.")
+    domain_formula = fields.Char(string="Domain Formula Shortcut", help="Internal field to shorten expression_ids creation for the domain engine", inverse='_inverse_domain_formula', store=False)
+    account_codes_formula = fields.Char(string="Account Codes Formula Shortcut", help="Internal field to shorten expression_ids creation for the account_codes engine", inverse='_inverse_account_codes_formula', store=False)
+    aggregation_formula = fields.Char(string="Aggregation Formula Shortcut", help="Internal field to shorten expression_ids creation for the aggregation engine", inverse='_inverse_aggregation_formula', store=False)
+
+    _sql_constraints = [
+        ('code_uniq', 'unique (code)', "A report line with the same code already exists."),
+    ]
+
+    @api.depends('parent_id.hierarchy_level')
+    def _compute_hierarchy_level(self):
+        for report_line in self:
+            if report_line.parent_id:
+                report_line.hierarchy_level = report_line.parent_id.hierarchy_level + 2
+            else:
+                report_line.hierarchy_level = 1
+
+    @api.depends('parent_id.report_id')
+    def _compute_report_id(self):
+        for report_line in self:
+            if report_line.parent_id:
+                report_line.report_id = report_line.parent_id.report_id
+
+    @api.constrains('parent_id')
+    def _validate_groupby_no_child(self):
+        for report_line in self:
+            if report_line.parent_id.groupby:
+                raise ValidationError(_("A line cannot have both children and a groupby value (line '%s').", report_line.parent_id.name))
+
+    @api.constrains('expression_ids', 'groupby')
+    def _validate_formula(self):
+        for expression in self.expression_ids:
+            if expression.engine == 'aggregation' and expression.report_line_id.groupby:
+                raise ValidationError(_(
+                    "Groupby feature isn't supported by aggregation engine. Please remove the groupby value on '%s'",
+                    expression.report_line_id.display_name,
+                ))
+
+    def _copy_hierarchy(self, code_mapping, report=None, copied_report=None, parent=None):
+        ''' Copy the whole hierarchy from this line by copying each line children recursively and adapting the
+        formulas with the new copied codes.
+
+        :param report: The financial report that triggered the duplicate.
+        :param copied_report: The copy of the report.
+        :param parent: The parent line in the hierarchy (a copy of the original parent line).
+        :param code_mapping: A dictionary keeping track of mapping old_code -> new_code
+        '''
+        self.ensure_one()
+
+        # If the line points to the old report, replace with the new one.
+        # Otherwise, cut the link to another financial report.
+        report_id = None
+        if report and copied_report and self.report_id.id == report.id:
+            report_id = copied_report.id
+
+        copied_line = self.copy({
+            'report_id': report_id,
+            'parent_id': parent and parent.id,
+            'code': self.code and self._get_copied_code(),
+        })
+
+        # Keep track of old_code -> new_code in a mutable dict
+        if self.code:
+            code_mapping[self.code] = copied_line.code
+
+        # Copy children
+        for line in self.children_ids:
+            line._copy_hierarchy(parent=copied_line, code_mapping=code_mapping)
+
+        # Update aggregation expressions, so that they use the copied lines
+        for expression in self.expression_ids:
+            copy_defaults = {'report_line_id': copied_line.id}
+
+            if expression.engine == 'aggregation':
+                copied_formula = f" {expression.formula} " # Add spaces so that the lookahead/lookbehind of the regex can work (we can't do a | in those)
+                for old_code, new_code in code_mapping.items():
+                    copied_formula = re.sub(f"(?<=\\W){old_code}(?=\\W)", new_code, copied_formula)
+                copy_defaults['formula'] = copied_formula.strip() # Remove the spaces introduced for lookahead/lookbehind
+
+            expression.copy(copy_defaults)
+
+    def _get_copied_code(self):
+        '''Look for an unique copied code.
+
+        :return: an unique code for the copied account.report.line
+        '''
+        self.ensure_one()
+        code = self.code + '_COPY'
+        while self.search_count([('code', '=', code)]) > 0:
+            code += '_COPY'
+        return code
+
+    def _inverse_domain_formula(self):
+        self._create_report_expression(engine='domain')
+
+    def _inverse_aggregation_formula(self):
+        self._create_report_expression(engine='aggregation')
+
+    def _inverse_account_codes_formula(self):
+        self._create_report_expression(engine='account_codes')
+
+    def _create_report_expression(self, engine):
+        # create account.report.expression for each report line based on the formula provided to each
+        # engine-related field. This makes xmls a bit shorter
+        vals_list = []
+        for report_line in self:
+            if report_line.expression_ids:
+                continue
+
+            if engine == 'domain' and report_line.domain_formula:
+                subformula, formula = DOMAIN_REGEX.match(report_line.domain_formula or '').groups()
+            elif engine == 'account_codes' and report_line.account_codes_formula:
+                subformula, formula = None, report_line.account_codes_formula
+            elif engine == 'aggregation' and report_line.aggregation_formula:
+                subformula, formula = None, report_line.aggregation_formula
+            else:
+                continue
+
+            vals = {
+                'report_line_id': report_line.id,
+                'label': 'balance',
+                'engine': engine,
+                'formula': formula,
+                'subformula': subformula
+            }
+            vals_list.append(vals)
+
+        if vals_list:
+            self.env['account.report.expression'].create(vals_list)
+
+
+class AccountReportExpression(models.Model):
+    _name = "account.report.expression"
+    _description = "Accounting Report Expression"
+    _rec_name = 'report_line_name'
+
+    report_line_id = fields.Many2one(string="Report Line", comodel_name='account.report.line', required=True, ondelete='cascade')
+    report_line_name = fields.Char(string="Report Line Name", related="report_line_id.name")
+    label = fields.Char(string="Label", required=True)
+    engine = fields.Selection(
+        string="Computation Engine",
+        selection=[
+            ('domain', "Odoo Domain"),
+            ('tax_tags', "Tax Tags"),
+            ('aggregation', "Aggregate Other Formulas"),
+            ('account_codes', "Prefix of Account Codes"),
+            ('external', "External Value"),
+            ('custom', "Custom Python Function"),
+        ],
+        required=True
+    )
+    formula = fields.Char(string="Formula", required=True)
+    subformula = fields.Char(string="Subformula")
+    date_scope = fields.Selection(
+        string="Date Scope",
+        selection=[
+            ('from_beginning', 'From the very start'),
+            ('from_fiscalyear', 'From the start of the fiscal year'),
+            ('to_beginning_of_fiscalyear', 'At the beginning of the fiscal year'),
+            ('to_beginning_of_period', 'At the beginning of the period'),
+            ('normal', 'According to each type of account'),
+            ('strict_range', 'Strictly on the given dates'),
+            ('previous_tax_period', "From previous tax period")
+        ],
+        required=True,
+        default='strict_range',
+    )
+    figure_type = fields.Selection(string="Figure Type", selection=FIGURE_TYPE_SELECTION_VALUES)
+    green_on_positive = fields.Boolean(string="Is Growth Good when Positive", default=True)
+    blank_if_zero = fields.Boolean(string="Blank if Zero")
+    auditable = fields.Boolean(string="Auditable", store=True, readonly=False, compute='_compute_auditable')
+
+    # Carryover fields
+    carryover_target = fields.Char(
+        string="Carry Over To",
+        help="Formula in the form line_code.expression_label. This allows setting the target of the carryover for this expression "
+             "(on a _carryover_*-labeled expression), in case it is different from the parent line. 'custom' is also allowed as value"
+             " in case the carryover destination requires more complex logic."
+    )
+
+    @api.depends('engine')
+    def _compute_auditable(self):
+        auditable_engines = self._get_auditable_engines()
+        for expression in self:
+            expression.auditable = expression.engine in auditable_engines
+
+    def _get_auditable_engines(self):
+        return {'tax_tags', 'domain', 'account_codes', 'external', 'aggregation'}
+
+    @api.model_create_multi
+    def create(self, vals_list):
+        # Overridden so that we create the corresponding account.account.tag objects when instantiating an expression
+        # with engine 'tax_tags'.
+        result = super().create(vals_list)
+
+        for expression in result:
+            tag_name = expression.formula if expression.engine == 'tax_tags' else None
+            if tag_name:
+                country = expression.report_line_id.report_id.country_id
+                existing_tags = self.env['account.account.tag']._get_tax_tags(tag_name, country.id)
+
+                if not existing_tags:
+                    tag_vals = self._get_tags_create_vals(tag_name, country.id)
+                    self.env['account.account.tag'].create(tag_vals)
+
+        return result
+
+    def write(self, vals):
+        if 'formula' not in vals:
+            return super().write(vals)
+
+        tax_tags_expressions = self.filtered(lambda x: x.engine == 'tax_tags')
+        former_formulas_by_country = defaultdict(lambda: [])
+        for expr in tax_tags_expressions:
+            former_formulas_by_country[expr.report_line_id.report_id.country_id].append(expr.formula)
+
+        result = super().write(vals)
+
+        for country, former_formulas_list in former_formulas_by_country.items():
+            for former_formula in former_formulas_list:
+                new_tax_tags = self.env['account.account.tag']._get_tax_tags(vals['formula'], country.id)
+
+                if not new_tax_tags:
+                    # If new tags already exist, nothing to do ; else, we must create them or update existing tags.
+                    former_tax_tags = self.env['account.account.tag']._get_tax_tags(former_formula, country.id)
+
+                    if former_tax_tags and all(tag_expr in self for tag_expr in former_tax_tags._get_related_tax_report_expressions()):
+                        # If we're changing the formula of all the expressions using that tag, rename the tag
+                        positive_tags, negative_tags = former_tax_tags.sorted(lambda x: x.tax_negate)
+                        positive_tags.name, negative_tags.name = f"+{vals['formula']}", f"-{vals['formula']}"
+                    else:
+                        # Else, create a new tag. Its the compute functions will make sure it is properly linked to the expressions
+                        tag_vals = self.env['account.report.expression']._get_tags_create_vals(vals['formula'], country.id)
+                        self.env['account.account.tag'].create(tag_vals)
+
+        return result
+
+    def name_get(self):
+        return [(expr.id, f'{expr.report_line_name} [{expr.label}]') for expr in self]
+
+    def _expand_aggregations(self):
+        """Return self and its full aggregation expression dependency"""
+        result = self
+
+        to_expand = self.filtered(lambda x: x.engine == 'aggregation')
+        while to_expand:
+            domains = []
+
+            for candidate_expr in to_expand:
+                labels_by_code = candidate_expr._get_aggregation_terms_details()
+
+                cross_report_domain = []
+                if candidate_expr.subformula != 'cross_report':
+                    cross_report_domain = [('report_line_id.report_id', '=', candidate_expr.report_line_id.report_id.id)]
+
+                for line_code, expr_labels in labels_by_code.items():
+                    dependency_domain = [('report_line_id.code', '=', line_code), ('label', 'in', tuple(expr_labels))] + cross_report_domain
+                    domains.append(dependency_domain)
+
+            sub_expressions = self.env['account.report.expression'].search(osv.expression.OR(domains))
+            to_expand = sub_expressions.filtered(lambda x: x.engine == 'aggregation' and x not in result)
+            result |= sub_expressions
+
+        return result
+
+    def _get_aggregation_terms_details(self):
+        """ Computes the details of each aggregation expression in self, and returns them in the form of a single dict aggregating all the results.
+
+        Example of aggregation details:
+        formula 'A.balance + B.balance + A.other'
+        will return: {'A': {'balance', 'other'}, 'B': {'balance'}}
+        """
+        totals_by_code = defaultdict(set)
+        for expression in self:
+            if expression.engine != 'aggregation':
+                raise UserError(_("Cannot get aggregation details from a line not using 'aggregation' engine"))
+
+            expression_terms = re.split('[-+/*]', re.sub(r'[\s()]', '', expression.formula))
+            for term in expression_terms:
+                if term: # term might be empty if the formula contains a negative term
+                    line_code, total_name = term.split('.')
+                    totals_by_code[line_code].add(total_name)
+
+        return totals_by_code
+
+    def _get_matching_tags(self):
+        """ Returns all the signed account.account.tags records whose name matches any of the formulas of the tax_tags expressions contained in self.
+        """
+        tag_expressions = self.filtered(lambda x: x.engine == 'tax_tags')
+        if not tag_expressions:
+            return self.env['account.account.tag']
+
+        or_domains = []
+        for tag_expression in tag_expressions:
+            country = tag_expression.report_line_id.report_id.country_id
+            or_domains.append(self.env['account.account.tag']._get_tax_tags_domain(tag_expression.formula, country.id))
+
+        return self.env['account.account.tag'].search(osv.expression.OR(or_domains))
+
+    @api.model
+    def _get_tags_create_vals(self, tag_name, country_id):
+        minus_tag_vals = {
+          'name': '-' + tag_name,
+          'applicability': 'taxes',
+          'tax_negate': True,
+          'country_id': country_id,
+        }
+        plus_tag_vals = {
+          'name': '+' + tag_name,
+          'applicability': 'taxes',
+          'tax_negate': False,
+          'country_id': country_id,
+        }
+        return [(minus_tag_vals), (plus_tag_vals)]
+
+    def _get_carryover_target_expression(self, options):
+        self.ensure_one()
+
+        if self.carryover_target:
+            line_code, expr_label = self.carryover_target.split('.')
+            return self.env['account.report.expression'].search([
+                ('report_line_id.code', '=', line_code),
+                ('label', '=', expr_label),
+                ('report_line_id.report_id', '=', self.report_line_id.report_id.id),
+            ])
+
+        main_expr_label = re.sub("^_carryover_", '', self.label)
+        target_label = '_applied_carryover_%s' % main_expr_label
+        auto_chosen_target = self.report_line_id.expression_ids.filtered(lambda x: x.label == target_label)
+
+        if not auto_chosen_target:
+            raise UserError(_("Could not determine carryover target automatically for expression %s.", self.label))
+
+        return auto_chosen_target
+
+    def action_view_carryover_lines(self, options):
+        date_from, date_to, dummy = self.report_line_id.report_id._get_date_bounds_info(options, self.date_scope)
+
+        return {
+            'type': 'ir.actions.act_window',
+            'name': _('Carryover lines for: %s', self.report_line_name),
+            'res_model': 'account.report.external.value',
+            'views': [(self.env.ref('account_reports.account_report_external_value_tree').id, 'list')],
+            'domain': [
+                ('target_report_expression_id', '=', self.id),
+                ('date', '>=', date_from),
+                ('date', '<=', date_to),
+            ],
+        }
+
+
+class AccountReportColumn(models.Model):
+    _name = "account.report.column"
+    _description = "Accounting Report Column"
+    _order = 'sequence, id'
+
+    name = fields.Char(string="Name", translate=True, required=True)
+    expression_label = fields.Char(string="Expression Label", required=True)
+    sequence = fields.Integer(string="Sequence")
+    report_id = fields.Many2one(string="Report", comodel_name='account.report')
+    sortable = fields.Boolean(string="Sortable")
+    figure_type = fields.Selection(string="Figure Type", selection=FIGURE_TYPE_SELECTION_VALUES, default="monetary", required=True)
+    blank_if_zero = fields.Boolean(string="Blank if Zero", default=True)
+    custom_audit_action_id = fields.Many2one(string="Custom Audit Action", comodel_name="ir.actions.act_window")
+
+
+class AccountReportExternalValue(models.Model):
+    _name = "account.report.external.value"
+    _description = 'Accounting Report External Value'
+    _check_company_auto = True
+    _order = 'date, id'
+
+    name = fields.Char(required=True)
+    value = fields.Float(required=True)
+    date = fields.Date(required=True)
+
+    target_report_expression_id = fields.Many2one(string="Target Expression", comodel_name="account.report.expression", required=True)
+    target_report_line_id = fields.Many2one(string="Target Line", related="target_report_expression_id.report_line_id")
+    target_report_expression_label = fields.Char(string="Target Expression Label", related="target_report_expression_id.label")
+    report_country_id = fields.Many2one(string="Country", related='target_report_line_id.report_id.country_id')
+
+    company_id = fields.Many2one(string='Company', comodel_name='res.company', required=True, default=lambda self: self.env.company)
+
+    foreign_vat_fiscal_position_id = fields.Many2one(
+        string="Fiscal position",
+        comodel_name='account.fiscal.position',
+        domain="[('company_id', '=', company_id), ('country_id', '=', report_country_id), ('foreign_vat', '!=', False)]",
+        check_company=True,
+        help="The foreign fiscal position for which this external value is made.",
+    )
+
+    # Carryover fields
+    carryover_origin_expression_label = fields.Char(string="Origin Expression Label")
+    carryover_origin_report_line_id = fields.Many2one(string="Origin Line", comodel_name='account.report.line')
+
+    @api.constrains('foreign_vat_fiscal_position_id', 'target_report_expression_id')
+    def _check_fiscal_position(self):
+        for record in self:
+            if record.foreign_vat_fiscal_position_id and record.foreign_vat_fiscal_position_id.country_id != record.report_country_id:
+                raise ValidationError(_("The country set on the the foreign VAT fiscal position must match the one set on the report."))

--- a/addons/account/models/account_tax_carryover_line.py
+++ b/None
@@ -1,36 +0,0 @@
-from odoo import api, fields, models, _
-
-from odoo.exceptions import ValidationError
-
-
-class AccountTaxCarryoverLine(models.Model):
-    _name = 'account.tax.carryover.line'
-    _description = 'Tax carryover line'
-
-    name = fields.Char(required=True)
-    amount = fields.Float(required=True, default=0.0)
-    date = fields.Date(required=True, default=fields.Date.context_today)
-    tax_report_line_id = fields.Many2one(
-        comodel_name='account.tax.report.line',
-        string="Tax report line",
-    )
-    tax_report_id = fields.Many2one(related='tax_report_line_id.report_id')
-    tax_report_country_id = fields.Many2one(related='tax_report_id.country_id')
-    company_id = fields.Many2one(
-        comodel_name='res.company', string='Company',
-        required=True,
-        default=lambda self: self.env.company,
-    )
-    foreign_vat_fiscal_position_id = fields.Many2one(
-        comodel_name='account.fiscal.position',
-        string="Fiscal position",
-        help="The foreign fiscal position for which this carryover is made.",
-        domain="[('company_id', '=', company_id), "
-               "('country_id', '=', tax_report_country_id), "
-               "('foreign_vat', '!=', False)]",
-    )
-
-    @api.constrains('foreign_vat_fiscal_position_id')
-    def _check_fiscal_position(self):
-        if self.foreign_vat_fiscal_position_id and not self.foreign_vat_fiscal_position_id.country_id == self.tax_report_country_id:
-            raise ValidationError(_("The country of the fiscal position must be this report line's report country."))

--- a/addons/account/models/account_tax_report.py
+++ b/None
@@ -1,462 +0,0 @@
-# -*- coding: utf-8 -*-
-from odoo import api, fields, models, _
-from odoo.exceptions import ValidationError
-from odoo.osv import expression
-
-
-class AccountTaxReport(models.Model):
-    _name = "account.tax.report"
-    _description = 'Account Tax Report'
-    _order = 'country_id, name'
-
-    name = fields.Char(string="Name", required=True, help="Name of this tax report")
-    country_id = fields.Many2one(string="Country", comodel_name='res.country', required=True, default=lambda x: x.env.company.country_id.id, help="Country for which this report is available.")
-    line_ids = fields.One2many(string="Report Lines", comodel_name='account.tax.report.line', inverse_name='report_id', help="Content of this tax report")
-    root_line_ids = fields.One2many(string="Root Report Lines", comodel_name='account.tax.report.line', inverse_name='report_id', domain=[('parent_id', '=', None)], help="Subset of line_ids, containing the lines at the root of the report.")
-
-    def write(self, vals):
-        # Overridden so that we change the country _id of the existing tags
-        # when writing the country_id of the report, or create new tags
-        # for the new country if the tags are shared with some other report.
-
-        if 'country_id' in vals:
-            tags_cache = {}
-            for record in self.filtered(lambda x: x.country_id.id != vals['country_id']):
-                for line in record.line_ids:
-                    if line.tag_ids:
-                        #The tags for this country may have been created by a previous line in this loop
-                        cache_key = (vals['country_id'], line.tag_name)
-                        if cache_key not in tags_cache:
-                            tags_cache[cache_key] = self.env['account.account.tag']._get_tax_tags(line.tag_name, vals['country_id'])
-
-                        new_tags = tags_cache[cache_key]
-
-                        if new_tags:
-                            line._remove_tags_used_only_by_self()
-                            line.write({'tag_ids': [(6, 0, new_tags.ids)]})
-
-                        elif line.mapped('tag_ids.tax_report_line_ids.report_id').filtered(lambda x: x not in self):
-                            line._remove_tags_used_only_by_self()
-                            line.write({'tag_ids': [(5, 0, 0)] + line._get_tags_create_vals(line.tag_name, vals['country_id'])})
-                            tags_cache[cache_key] = line.tag_ids
-
-                        else:
-                            line.tag_ids.write({'country_id': vals['country_id']})
-
-        return super(AccountTaxReport, self).write(vals)
-
-    def copy(self, default=None):
-        # Overridden from regular copy, since the ORM does not manage
-        # the copy of the lines hierarchy properly (all the parent_id fields
-        # need to be reassigned to the corresponding copies).
-
-        copy_default = {k:v for k, v in default.items() if k != 'line_ids'} if default else None
-        copied_report = super(AccountTaxReport, self).copy(default=copy_default) #This copies the report without its lines
-
-        lines_map = {} # maps original lines to their copies (using ids)
-        for line in self.get_lines_in_hierarchy():
-            copy = line.copy({'parent_id': lines_map.get(line.parent_id.id, None), 'report_id': copied_report.id})
-            lines_map[line.id] = copy.id
-
-        return copied_report
-
-    def get_lines_in_hierarchy(self):
-        """ Returns an interator to the lines of this tax report, were parent lines
-        ar all directly followed by their children.
-        """
-        self.ensure_one()
-        lines_to_treat = list(self.line_ids.filtered(lambda x: not x.parent_id)) # Used as a stack, whose index 0 is the top
-        while lines_to_treat:
-            to_yield = lines_to_treat[0]
-            lines_to_treat = list(to_yield.children_line_ids) + lines_to_treat[1:]
-            yield to_yield
-
-    def get_checks_to_perform(self, amounts, carried_over):
-        """ To override in localizations
-        If value is a float, it will be formatted with format_value
-        The line is not displayed if it is falsy (0, 0.0, False, ...)
-        :param amounts: the mapping dictionary between codes and values
-        :param carried_over: the mapping dictionary between codes and whether they are carried over
-        :return: iterable of tuple (name, value)
-        """
-        self.ensure_one()
-        return []
-
-    def validate_country_id(self):
-        for record in self:
-            if any(line.tag_ids.mapped('country_id') != record.country_id for line in record.line_ids):
-                raise ValidationError(_("The tags associated with tax report line objects should all have the same country set as the tax report containing these lines."))
-
-
-class AccountTaxReportLine(models.Model):
-    _name = "account.tax.report.line"
-    _description = 'Account Tax Report Line'
-    _order = 'sequence, id'
-    _parent_store = True
-
-    name = fields.Char(
-        string="Name",
-        required=True,
-        help="Complete name for this report line, to be used in report.",
-    )
-    tag_ids = fields.Many2many(
-        string="Tags",
-        comodel_name="account.account.tag",
-        relation="account_tax_report_line_tags_rel",
-        help="Tax tags populating this line",
-    )
-    report_action_id = fields.Many2one(
-        string="Report Action",
-        comodel_name="ir.actions.act_window",
-        help="The optional action to call when clicking on this line in accounting reports.",
-    )
-    children_line_ids = fields.One2many(
-        string="Children Lines",
-        comodel_name="account.tax.report.line",
-        inverse_name="parent_id",
-        help="Lines that should be rendered as children of this one",
-    )
-    parent_id = fields.Many2one(
-        string="Parent Line",
-        comodel_name="account.tax.report.line"
-    )
-    sequence = fields.Integer(
-        string="Sequence",
-        required=True,
-        help="Sequence determining the order of the lines in the report (smaller ones come first). "
-             "This order is applied locally per section "
-             "(so, children of the same line are always rendered one after the other).",
-    )
-    parent_path = fields.Char(index=True, unaccent=False)
-    report_id = fields.Many2one(
-        string="Tax Report",
-        comodel_name="account.tax.report",
-        compute='_compute_report_id',
-        required=True,
-        store=True,
-        readonly=False,
-        recursive=True,
-        ondelete="cascade",
-        help="The parent tax report of this line",
-    )
-
-    # helper to create tags (positive and negative) on report line creation
-    tag_name = fields.Char(
-        string="Tag Name",
-        help="Short name for the tax grid corresponding to this report line. "
-             "Leave empty if this report line should not correspond to any such grid.",
-    )
-
-    # fields used in specific localization reports,
-    # where a report line isn't simply the given by the sum of account.move.line with selected tags
-    code = fields.Char(
-        string="Code", help="Optional unique code to refer to this line in total formulas"
-    )
-    formula = fields.Char(
-        string="Formula",
-        help="Python expression used to compute the value of a total line. "
-             "This field is mutually exclusive with tag_name, setting it turns the line to a total line. "
-             "Tax report line codes can be used as variables in this expression "
-             "to refer to the balance of the corresponding lines in the report. "
-             "A formula cannot refer to another line using a formula.",
-    )
-
-    # fields used to carry over amounts between periods
-
-    # The selection should be filled in localizations using the system
-    carry_over_condition_method = fields.Selection(
-        selection=[
-            ('no_negative_amount_carry_over_condition', 'No negative amount'),
-            ('always_carry_over_and_set_to_0', 'Always carry over and set to 0'),
-        ],
-        string="Method",
-        help="The method used to determine if this line should be carried over."
-    )
-    carry_over_destination_line_id = fields.Many2one(
-        string="Destination",
-        comodel_name="account.tax.report.line",
-        domain="[('report_id', '=', report_id)]",
-        help="The line to which the value of this line will be carried over to if needed."
-             " If left empty the line will carry over to itself."
-    )
-    carryover_line_ids = fields.One2many(
-        string="Carryover lines",
-        comodel_name='account.tax.carryover.line',
-        inverse_name='tax_report_line_id',
-    )
-    is_carryover_persistent = fields.Boolean(
-        string="Persistent",
-        help="Defines how this report line creates carry over lines when performing tax closing. "
-             "If true, the amounts carried over will always be added on top of each other: "
-             "for example, a report line with a balance of 10 with an existing carryover of 50 "
-             "will add an additional 10 to it when doing the closing, making a total carryover of 60. "
-             "If false, the total carried over amount will be forced to the total of this report line: "
-             "a report line with a balance of 10 with an existing carryover of 50 will create a new "
-             "carryover line of -40, so that the total carryover becomes 10.",
-        default=True,
-    )
-    is_carryover_used_in_balance = fields.Boolean(
-        string="Used in line balance",
-        help="If set, the carryover amount for this line will be used when calculating its balance in the report. "
-             "This means that the carryover could affect other lines if they are using this one in their computation."
-    )
-
-    @api.depends('parent_id.report_id')
-    def _compute_report_id(self):
-        for record in self:
-            record.report_id = record.parent_id.report_id
-
-    @api.model_create_multi
-    def create(self, vals_list):
-        for vals in vals_list:
-            if not vals.get('report_id'):  # computed but required in db
-                vals['report_id'] = self.browse(vals['parent_id']).report_id.id
-            # Manage tags
-            tag_name = vals.get('tag_name', '')
-            if tag_name:
-                report = self.env['account.tax.report'].browse(vals['report_id'])
-                country = report.country_id
-
-                existing_tags = self.env['account.account.tag']._get_tax_tags(tag_name, country.id)
-
-                if existing_tags:
-                    # We connect the new report line to the already existing tags
-                    vals['tag_ids'] = [(6, 0, existing_tags.ids)]
-                else:
-                    # We create new ones
-                    vals['tag_ids'] = self._get_tags_create_vals(tag_name, country.id)
-
-        return super().create(vals_list)
-
-    @api.model
-    def _get_tags_create_vals(self, tag_name, country_id):
-        minus_tag_vals = {
-          'name': '-' + tag_name,
-          'applicability': 'taxes',
-          'tax_negate': True,
-          'country_id': country_id,
-        }
-        plus_tag_vals = {
-          'name': '+' + tag_name,
-          'applicability': 'taxes',
-          'tax_negate': False,
-          'country_id': country_id,
-        }
-        return [(0, 0, minus_tag_vals), (0, 0, plus_tag_vals)]
-
-    def write(self, vals):
-        # If tag_name was set, but not tag_ids, we postpone the write of
-        # tag_name, and perform it only after having generated/retrieved the tags.
-        # Otherwise, tag_name and tags' name would not match, breaking
-        # _validate_tags constaint.
-        postponed_vals = {}
-
-        if 'tag_name' in vals and 'tag_ids' not in vals:
-            postponed_vals = {'tag_name': vals.pop('tag_name')}
-            tag_name_postponed = postponed_vals['tag_name']
-            # if tag_name is posponed then we also postpone formula to avoid
-            # breaking _validate_formula constraint
-            if 'formula' in vals:
-                postponed_vals['formula'] = vals.pop('formula')
-
-        rslt = super(AccountTaxReportLine, self).write(vals)
-
-        if postponed_vals:
-            # If tag_name modification has been postponed,
-            # we need to search for existing tags corresponding to the new tag name
-            # (or create them if they don't exist yet) and assign them to the records
-
-            records_by_country = {}
-            for record in self.filtered(lambda x: x.tag_name != tag_name_postponed):
-                records_by_country[record.report_id.country_id.id] = records_by_country.get(record.report_id.country_id.id, self.env['account.tax.report.line']) + record
-
-            for country_id, records in records_by_country.items():
-                if tag_name_postponed:
-                    record_tag_names = records.mapped('tag_name')
-                    if len(record_tag_names) == 1 and record_tag_names[0]:
-                        # If all the records already have the same tag_name before writing,
-                        # we simply want to change the name of the existing tags
-                        to_update = records.mapped('tag_ids.tax_report_line_ids')
-                        tags_to_update = to_update.mapped('tag_ids')
-                        minus_child_tags = tags_to_update.filtered(lambda x: x.tax_negate)
-                        minus_child_tags.write({'name': '-' + tag_name_postponed})
-                        plus_child_tags = tags_to_update.filtered(lambda x: not x.tax_negate)
-                        plus_child_tags.write({'name': '+' + tag_name_postponed})
-                        super(AccountTaxReportLine, to_update).write(postponed_vals)
-
-                    else:
-                        existing_tags = self.env['account.account.tag']._get_tax_tags(tag_name_postponed, country_id)
-                        records_to_link = records
-                        tags_to_remove = self.env['account.account.tag']
-
-                        if not existing_tags and records_to_link:
-                            # If the tag does not exist yet, we first create it by
-                            # linking it to the first report line of the record set
-                            first_record = records_to_link[0]
-                            tags_to_remove += first_record.tag_ids
-                            first_record.write({**postponed_vals, 'tag_ids': [(5, 0, 0)] + self._get_tags_create_vals(tag_name_postponed, country_id)})
-                            existing_tags = first_record.tag_ids
-                            records_to_link -= first_record
-
-                        # All the lines sharing their tags must always be synchronized,
-                        tags_to_remove += records_to_link.mapped('tag_ids')
-                        records_to_link = tags_to_remove.mapped('tax_report_line_ids')
-                        tags_to_remove.mapped('tax_report_line_ids')._remove_tags_used_only_by_self()
-                        records_to_link.write({**postponed_vals, 'tag_ids': [(2, tag.id) for tag in tags_to_remove] + [(6, 0, existing_tags.ids)]})
-
-                else:
-                    # tag_name was set empty, so we remove the tags on current lines
-                    # If some tags are still referenced by other report lines,
-                    # we keep them ; else, we delete them from DB
-                    line_tags = records.mapped('tag_ids')
-                    other_lines_same_tag = line_tags.mapped('tax_report_line_ids').filtered(lambda x: x not in records)
-                    if not other_lines_same_tag:
-                        self._delete_tags_from_taxes(line_tags.ids)
-                    orm_cmd_code = other_lines_same_tag and 3 or 2
-                    records.write({**postponed_vals, 'tag_ids': [(orm_cmd_code, tag.id) for tag in line_tags]})
-
-        return rslt
-
-    def unlink(self):
-        self._remove_tags_used_only_by_self()
-        children = self.mapped('children_line_ids')
-        if children:
-            children.unlink()
-        return super(AccountTaxReportLine, self).unlink()
-
-    def _remove_tags_used_only_by_self(self):
-        """ Deletes and removes from taxes and move lines all the
-        tags from the provided tax report lines that are not linked
-        to any other tax report lines.
-        """
-        all_tags = self.mapped('tag_ids')
-        tags_to_unlink = all_tags.filtered(lambda x: not (x.tax_report_line_ids - self))
-        self.write({'tag_ids': [(3, tag.id, 0) for tag in tags_to_unlink]})
-        self._delete_tags_from_taxes(tags_to_unlink.ids)
-
-    @api.model
-    def _delete_tags_from_taxes(self, tag_ids_to_delete):
-        """ Based on a list of tag ids, removes them first from the
-        repartition lines they are linked to, then deletes them
-        from the account move lines, and finally unlink them.
-        """
-        if not tag_ids_to_delete:
-            # Nothing to do, then!
-            return
-
-        self.env.cr.execute("""
-            delete from account_account_tag_account_tax_repartition_line_rel
-            where account_account_tag_id in %(tag_ids_to_delete)s;
-
-            delete from account_account_tag_account_move_line_rel
-            where account_account_tag_id in %(tag_ids_to_delete)s;
-        """, {'tag_ids_to_delete': tuple(tag_ids_to_delete)})
-
-        self.env['account.move.line'].invalidate_model(['tax_tag_ids'])
-        self.env['account.tax.repartition.line'].invalidate_model(['tag_ids'])
-
-        self.env['account.account.tag'].browse(tag_ids_to_delete).unlink()
-
-    @api.constrains('formula', 'tag_name')
-    def _validate_formula(self):
-        for record in self:
-            if record.formula and record.tag_name:
-                raise ValidationError(_("Tag name and formula are mutually exclusive, they should not be set together on the same tax report line."))
-
-    @api.constrains('tag_name', 'tag_ids')
-    def _validate_tags(self):
-        for record in self.filtered(lambda x: x.tag_ids):
-            neg_tags = record.tag_ids.filtered(lambda x: x.tax_negate)
-            pos_tags = record.tag_ids.filtered(lambda x: not x.tax_negate)
-
-            if (len(neg_tags) != 1 or len(pos_tags) != 1):
-                raise ValidationError(_("If tags are defined for a tax report line, only two are allowed on it: a positive and a negative one."))
-
-            if neg_tags.name != '-'+record.tag_name or pos_tags.name != '+'+record.tag_name:
-                raise ValidationError(_("The tags linked to a tax report line should always match its tag name."))
-
-    def action_view_carryover_lines(self, options):
-        ''' Action when clicking on the "View carryover lines" in the carryover info popup.
-        Takes into account the report options, to get the correct lines depending on the current
-        company/companies.
-
-        :return:    An action showing the account.tax.carryover.lines for the current tax report line.
-        '''
-        self.ensure_one()
-
-        target = self._get_carryover_destination_line(options)
-        domain = target._get_carryover_lines_domain(options)
-        carryover_lines = self.env['account.tax.carryover.line'].search(domain)
-
-        return {
-            'type': 'ir.actions.act_window',
-            'name': _('Carryover Lines For %s', target.name),
-            'res_model': 'account.tax.carryover.line',
-            'view_type': 'list',
-            'view_mode': 'list',
-            'views': [[self.env.ref('account.account_tax_carryover_line_tree').id, 'list'],
-                      [False, 'form']],
-            'domain': [('id', 'in', carryover_lines.ids)],
-        }
-
-    def _get_carryover_bounds(self, options, line_amount, carried_over_amount):
-        """
-        Check if the line will be carried over, by checking the condition method set on the line.
-        Do not override this method, but instead set your condition methods on each lines.
-        :param options: The options of the reports
-        :param line_amount: The amount on the line
-        :param carried_over_amount: The amount carried over for this line
-        :return: A tuple containing the lower and upper bounds from which the line will be carried over.
-        E.g. (0, 42) : Lines which value is below 0 or above 42 will be carried over.
-        E.g. (0, None) : Only lines which value is below 0 will be carried over.
-        E.g. None : This line will never be carried over.
-        """
-        self.ensure_one()
-        # Carry over is disabled by default, but if there is a carry over condition  method on the line we are
-        # calling it first. That way we can have a default carryover condition for the whole report (carryover_bounds)
-        # and specialized condition for specific lines if needed
-        if self.carry_over_condition_method:
-            condition_method = getattr(self, self.carry_over_condition_method, False)
-            if condition_method:
-                return condition_method(options, line_amount, carried_over_amount)
-
-        return None
-
-    def _get_carryover_lines_domain(self, options):
-        """
-        :param options: The report options
-        :return: The domain that can be used to search for carryover lines for this tax report line.
-        Using this domain instead of directly accessing the lines ensure that we only pick the ones related to the
-        companies affecting the tax report.
-        """
-        self.ensure_one()
-        domain = [('tax_report_line_id', '=', self.id)]
-
-        if options.get('multi_company'):
-            company_ids = [company['id'] for company in options['multi_company']]
-            domain = expression.AND([domain, [('company_id', 'in', company_ids)]])
-        else:
-            domain = expression.AND([domain, [('company_id', '=', self.env.company.id)]])
-
-        return domain
-
-    def no_negative_amount_carry_over_condition(self, options, line_amount, carried_over_amount):
-        # The bounds are (0, None).
-        # Lines below 0 will be set to 0 and reduce the balance of the carryover.
-        # Lines above 0 will never be carried over
-        return (0, None)
-
-    def always_carry_over_and_set_to_0(self, options, line_amount, carried_over_amount):
-        # The bounds are (0, 0).
-        # Lines below 0 will be set to 0 and reduce the balance of the carryover.
-        # Lines above 0 will be set to 0 and increase the balance of the carryover.
-        return (0, 0)
-
-    def _get_carryover_destination_line(self, options):
-        """
-        Return the destination line for the carryover for this tax report line.
-        :param options: The options of the tax report.
-        :return: The line on which we'll carryover this tax report line when closing the tax period.
-        """
-        self.ensure_one()
-        return self.carry_over_destination_line_id or self

--- a/addons/account/models/chart_template.py
+++ b/addons/account/models/chart_template.py
@@ -1,7 +1,7 @@
 # -*- coding: utf-8 -*-
 
 from odoo.exceptions import AccessError
-from odoo import api, fields, models, _
+from odoo import api, fields, models, Command, _, osv
 from odoo import SUPERUSER_ID
 from odoo.exceptions import UserError, ValidationError
 from odoo.http import request
@@ -1232,27 +1232,19 @@ class AccountTaxRepartitionLineTemplate(models.Model):
     account_id = fields.Many2one(string="Account", comodel_name='account.account.template', help="Account on which to post the tax amount")
     invoice_tax_id = fields.Many2one(comodel_name='account.tax.template', help="The tax set to apply this distribution on invoices. Mutually exclusive with refund_tax_id")
     refund_tax_id = fields.Many2one(comodel_name='account.tax.template', help="The tax set to apply this distribution on refund invoices. Mutually exclusive with invoice_tax_id")
-    tag_ids = fields.Many2many(string="Financial Tags", relation='account_tax_repartition_financial_tags', comodel_name='account.account.tag', copy=True, help="Additional tags that will be assigned by this repartition line for use in financial reports")
+    tag_ids = fields.Many2many(string="Financial Tags", relation='account_tax_repartition_financial_tags', comodel_name='account.account.tag', copy=True, help="Additional tags that will be assigned by this repartition line for use in domains")
     use_in_tax_closing = fields.Boolean(string="Tax Closing Entry")
 
+
     # These last two fields are helpers used to ease the declaration of account.account.tag objects in XML.
-    # They are directly linked to account.tax.report.line objects, which create corresponding + and - tags
+    # They are directly linked to account.tax.report.expression objects, which create corresponding + and - tags
     # at creation. This way, we avoid declaring + and - separately every time.
-    plus_report_line_ids = fields.Many2many(string="Plus Tax Report Lines", relation='account_tax_repartition_plus_report_line', comodel_name='account.tax.report.line', copy=True, help="Tax report lines whose '+' tag will be assigned to move lines by this repartition line")
-    minus_report_line_ids = fields.Many2many(string="Minus Report Lines", relation='account_tax_repartition_minus_report_line', comodel_name='account.tax.report.line', copy=True, help="Tax report lines whose '-' tag will be assigned to move lines by this repartition line")
+    plus_report_expression_ids = fields.Many2many(string="Plus Tax Report Expressions", relation='account_tax_rep_template_plus', comodel_name='account.report.expression', copy=True, help="Tax report expressions whose '+' tag will be assigned to move lines by this repartition line")
+    minus_report_expression_ids = fields.Many2many(string="Minus Report Expressions", relation='account_tax_rep_template_minus', comodel_name='account.report.expression', copy=True, help="Tax report expressions whose '-' tag will be assigned to move lines by this repartition line")
 
     @api.model_create_multi
     def create(self, vals_list):
         for vals in vals_list:
-            if vals.get('plus_report_line_ids'):
-                vals['plus_report_line_ids'] = self._convert_tag_syntax_to_orm(vals['plus_report_line_ids'])
-
-            if vals.get('minus_report_line_ids'):
-                vals['minus_report_line_ids'] = self._convert_tag_syntax_to_orm(vals['minus_report_line_ids'])
-
-            if vals.get('tag_ids'):
-                vals['tag_ids'] = self._convert_tag_syntax_to_orm(vals['tag_ids'])
-
             if vals.get('use_in_tax_closing') is None:
                 vals['use_in_tax_closing'] = False
                 if vals.get('account_id'):
@@ -1262,40 +1254,26 @@ class AccountTaxRepartitionLineTemplate(models.Model):
 
         return super().create(vals_list)
 
-    @api.model
-    def _convert_tag_syntax_to_orm(self, tags_list):
-        """ Repartition lines give the possibility to directly give
-        a list of ids to create for tags instead of a list of ORM commands.
-
-        This function checks that tags_list uses this syntactic sugar and returns
-        an ORM-compliant version of it if it does.
-        """
-        if tags_list and all(isinstance(elem, int) for elem in tags_list):
-            return [(6, False, tags_list)]
-        return tags_list
-
     @api.constrains('invoice_tax_id', 'refund_tax_id')
     def validate_tax_template_link(self):
         for record in self:
             if record.invoice_tax_id and record.refund_tax_id:
                 raise ValidationError(_("Tax distribution line templates should apply to either invoices or refunds, not both at the same time. invoice_tax_id and refund_tax_id should not be set together."))
 
-    @api.constrains('plus_report_line_ids', 'minus_report_line_ids')
-    def validate_tags(self):
-        all_tax_rep_lines = self.mapped('plus_report_line_ids') + self.mapped('minus_report_line_ids')
-        lines_without_tag = all_tax_rep_lines.filtered(lambda x: not x.tag_name)
-        if lines_without_tag:
-            raise ValidationError(_("The following tax report lines are used in some tax distribution template though they don't generate any tag: %s . This probably means you forgot to set a tag_name on these lines.", str(lines_without_tag.mapped('name'))))
+    @api.constrains('plus_report_expression_ids', 'minus_report_expression_ids')
+    def _validate_report_expressions(self):
+        for record in self:
+            all_engines = set((record.plus_report_expression_ids + record.minus_report_expression_ids).mapped('engine'))
+            if all_engines and all_engines != {'tax_tags'}:
+                raise ValidationError(_("Only 'tax_tags' expressions can be linked to a tax repartition line template."))
 
     def get_repartition_line_create_vals(self, company):
-        rslt = [(5, 0, 0)]
+        rslt = [Command.clear()]
         for record in self:
-            tags_to_add = record._get_tags_to_add()
-
-            rslt.append((0, 0, {
+            rslt.append(Command.create({
                 'factor_percent': record.factor_percent,
                 'repartition_type': record.repartition_type,
-                'tag_ids': [(6, 0, tags_to_add.ids)],
+                'tag_ids': [Command.set(record._get_tags_to_add().ids)],
                 'company_id': company.id,
                 'use_in_tax_closing': record.use_in_tax_closing
             }))
@@ -1329,13 +1307,18 @@ class AccountTaxRepartitionLineTemplate(models.Model):
 
     def _get_tags_to_add(self):
         self.ensure_one()
-        tags_to_add = self.env["account.account.tag"]
-        tags_to_add += self.plus_report_line_ids.mapped("tag_ids").filtered(lambda x: not x.tax_negate)
-        tags_to_add += self.minus_report_line_ids.mapped("tag_ids").filtered(lambda x: x.tax_negate)
-        tags_to_add += self.tag_ids
-        return tags_to_add
+        tags_to_add = self.tag_ids
 
-# Fiscal Position Templates
+        domains = []
+        for sign, report_expressions in (('+', self.plus_report_expression_ids), ('-', self.minus_report_expression_ids)):
+            for report_expression in report_expressions:
+                country = report_expression.report_line_id.report_id.country_id
+                domains.append(self.env['account.account.tag']._get_tax_tags_domain(report_expression.formula, country.id, sign=sign))
+
+        if domains:
+            tags_to_add |= self.env['account.account.tag'].search(osv.expression.OR(domains))
+
+        return tags_to_add
 
 class AccountFiscalPositionTemplate(models.Model):
     _name = 'account.fiscal.position.template'

--- a/addons/account/models/partner.py
+++ b/addons/account/models/partner.py
@@ -304,7 +304,11 @@ class ResPartner(models.Model):
 
     @api.depends_context('company')
     def _credit_debit_get(self):
-        tables, where_clause, where_params = self.env['account.move.line'].with_context(state='posted', company_id=self.env.company.id)._query_get()
+        tables, where_clause, where_params = self.env['account.move.line']._where_calc([
+            ('parent_state', '=', 'posted'),
+            ('company_id', '=', self.env.company.id)
+        ]).get_sql()
+
         where_params = [tuple(self.ids)] + where_params
         if where_clause:
             where_clause = 'AND ' + where_clause
