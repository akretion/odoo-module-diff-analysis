PR: https://github.com/odoo/odoo/pull/124182

From: b4cb36ed8083539cace6435674a69f78e9131d70
From: Thibault Delavall√©e
Date: 2023-10-06 06:13:55

Structural Changes: 1
Total Changes: 89

[REF] mail: remove 'sequence' on tracking value, use insert order

PURPOSE

Simplify 'mail.tracking.value' model and code. Remove unnecessary fields and
computation. Make code easier to handle and more batch-enabled.

SPECIFICATIONS

Remove 'tracking_sequence' on tracking values in DB. Consider insertion order
should be done accordingly and display them based on ID DESC. Sequence is now
used only for order records to insert in DB. Feature is still the same (order
based on sequence) but without having to store the sequence itself. It was
never updated anyway.

Task-3345979 (Mail: Simplify tracking model)

Part-of: odoo/odoo#124182

================================= pseudo patch: =================================

--- a/addons/mail/models/mail_tracking_value.py
+++ b/addons/mail/models/mail_tracking_value.py
@@ -10,7 +10,7 @@ class MailTracking(models.Model):
     _name = 'mail.tracking.value'
     _description = 'Mail Tracking Value'
     _rec_name = 'field'
-    _order = 'tracking_sequence asc'
+    _order = 'id DESC'
 
     field = fields.Many2one('ir.model.fields', required=True, readonly=True, index=True, ondelete='cascade')
     field_desc = fields.Char('Field Description', required=True, readonly=True)
@@ -36,8 +36,6 @@ class MailTracking(models.Model):
 
     mail_message_id = fields.Many2one('mail.message', 'Message ID', required=True, index=True, ondelete='cascade')
 
-    tracking_sequence = fields.Integer('Tracking field sequence', readonly=True, default=100)
-
     @api.depends('mail_message_id', 'field')
     def _compute_field_groups(self):
         for tracking in self:
@@ -46,7 +44,7 @@ class MailTracking(models.Model):
             tracking.field_groups = field.groups if field else 'base.group_system'
 
     @api.model
-    def _create_tracking_values(self, initial_value, new_value, col_name, col_info, tracking_sequence, record):
+    def _create_tracking_values(self, initial_value, new_value, col_name, col_info, record):
         """ Prepare values to create a mail.tracking.value. It prepares old and
         new value according to the field type.
 
@@ -56,8 +54,6 @@ class MailTracking(models.Model):
           date, datetime, ...;
         :param str col_name: technical field name, column name (e.g. 'user_id);
         :param dict col_info: result of fields_get(col_name);
-        :param int tracking_sequence: sequence used for ordering tracking
-          value display;
         :param <record> record: record on which tracking is performed, used for
           related computation e.g. finding currency of monetary fields;
 
@@ -67,7 +63,7 @@ class MailTracking(models.Model):
         if not field:
             raise ValueError(f'Unknown field {col_name} on model {record._name}')
 
-        values = {'field': field.id, 'field_desc': col_info['string'], 'field_type': col_info['type'], 'tracking_sequence': tracking_sequence}
+        values = {'field': field.id, 'field_desc': col_info['string'], 'field_type': col_info['type']}
 
         if col_info['type'] in {'integer', 'float', 'char', 'text', 'datetime', 'monetary'}:
             values.update({
@@ -110,11 +106,21 @@ class MailTracking(models.Model):
 
     def _tracking_value_format(self):
         """ Return structure and formatted data structure to be used by chatter
-        to display tracking values.
+        to display tracking values. Order it according to asked display, aka
+        ascending sequence (and field name).
 
         :return list: for each tracking value in self, their formatted display
           values given as a dict;
         """
+        if not self:
+            return []
+        field_models = self.field.mapped('model')
+        if len(set(field_models)) != 1:
+            raise ValueError('All tracking value should belong to the same model.')
+        TrackedModel = self.env[field_models[0]]
+        tracked_fields = TrackedModel.fields_get(self.field.mapped('name'), attributes={'string', 'type'})
+        fields_sequence_map = dict(TrackedModel._mail_track_order_fields(tracked_fields))
+
         formatted = []
         for tracking in self:
             formatted.append({
@@ -131,6 +137,10 @@ class MailTracking(models.Model):
                     'value': tracking._format_display_value(new=False)[0],
                 },
             })
+        formatted.sort(
+            key=lambda info: (fields_sequence_map[info['fieldName']], info['fieldName']),
+            reverse=False,
+        )
         return formatted
 
     def _format_display_value(self, new=True):

--- a/addons/mail/models/models.py
+++ b/addons/mail/models/models.py
@@ -81,39 +81,60 @@ class BaseModel(models.AbstractModel):
           fields;
 
         :return: a tuple (changes, tracking_value_ids) where
-          changes: set of updated column names;
+          changes: set of updated column names; contains onchange tracked fields
+          that changed;
           tracking_value_ids: a list of ORM (0, 0, values) commands to create
           ``mail.tracking.value`` records;
 
         Override this method on a specific model to implement model-specific
         behavior. Also consider inheriting from ``mail.thread``. """
         self.ensure_one()
-        changes = set()  # contains onchange tracked fields that changed
+        updated = set()
         tracking_value_ids = []
 
-        # generate tracked_values data structure: {'col_name': {col_info, new_value, old_value}}
-        for col_name, col_info in tracked_fields.items():
+        fields_track_info = self._mail_track_order_fields(tracked_fields)
+        for col_name, _sequence in fields_track_info:
             if col_name not in initial_values:
                 continue
-            initial_value = initial_values[col_name]
-            new_value = self[col_name]
-
-            if new_value != initial_value and (new_value or initial_value):  # because browse null != False
-                tracking_sequence = getattr(self._fields[col_name], 'tracking',
-                                            getattr(self._fields[col_name], 'track_sequence', 100))  # backward compatibility with old parameter name
-                if tracking_sequence is True:
-                    tracking_sequence = 100
-                tracking = self.env['mail.tracking.value']._create_tracking_values(
+            initial_value, new_value = initial_values[col_name], self[col_name]
+            if new_value == initial_value or (not new_value and not initial_value):  # because browse null != False
+                continue
+
+            updated.add(col_name)
+            tracking_value_ids.append(
+                [0, 0, self.env['mail.tracking.value']._create_tracking_values(
                     initial_value, new_value,
-                    col_name, col_info,
-                    tracking_sequence,
+                    col_name, tracked_fields[col_name],
                     self
-                )
-                if tracking:
-                    tracking_value_ids.append([0, 0, tracking])
-                changes.add(col_name)
-
-        return changes, tracking_value_ids
+                )])
+
+        return updated, tracking_value_ids
+
+    def _mail_track_order_fields(self, tracked_fields):
+        """ Order tracking, based on sequence found on field definition. When
+        having several identical sequences, field name is used. """
+        fields_track_info = [
+            (col_name, self._mail_track_get_field_sequence(col_name))
+            for col_name in tracked_fields.keys()
+        ]
+        # sorting: sequence ASC, name ASC (higher sequence -> displayed last, then
+        # order by name). Model order being id DESC (aka: first insert -> last
+        # displayed) insert should be done by descending sequence then descending
+        # name.
+        fields_track_info.sort(key=lambda item: (item[1], item[0]), reverse=True)
+        return fields_track_info
+
+    def _mail_track_get_field_sequence(self, fname):
+        """ Find tracking sequence of a given field, given their name. Current
+        parameter 'tracking' should be an integer, but attributes with True
+        are still supported; old naming 'track_sequence' also. """
+        sequence = getattr(
+            self._fields[fname], 'tracking',
+            getattr(self._fields[fname], 'track_sequence', 100)
+        )
+        if sequence is True:
+            sequence = 100
+        return sequence
 
     def _message_get_default_recipients(self):
         """ Generic implementation for finding default recipient to mail on
