PR: https://github.com/odoo/odoo/pull/65871

From: 9f9c4bb7e40233e633f97c60fb00ae191e9077af
From: Benoit Socias
Date: 2021-09-03 06:59:33

Structural Changes: 2
Total Changes: 207

[IMP] website(_*): replace search callbacks by a mixin

Before this commit the `_search_get_detail` result contained callback
functions to handle special behavior during fetching and rendering.

After this commit a `website.searchable.mixin` is introduced that must
be inherited by models that participate in website-based searches.
Custom behavior previously achieved with callbacks is now achieved by
overloading methods of this mixin.

task-2379555
https://github.com/odoo/odoo/pull/65871

Part-of: odoo/odoo#65871

================================= pseudo patch: =================================

--- a/addons/website/models/mixins.py
+++ b/addons/website/models/mixins.py
@@ -2,11 +2,14 @@
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
 import logging
+import re
 
 from odoo import api, fields, models, _
+from odoo.addons.website.tools import text_from_html
 from odoo.http import request
 from odoo.osv import expression
 from odoo.exceptions import AccessError
+from odoo.tools import escape_psql
 from odoo.tools.json import scriptsafe as json_safe
 
 logger = logging.getLogger(__name__)
@@ -252,3 +255,85 @@ class WebsitePublishedMultiMixin(WebsitePublishedMixin):
             return (['!'] if value is False else []) + expression.AND([is_published, on_current_website])
         else:  # should be in the backend, return things that are published anywhere
             return is_published
+
+
+class WebsiteSearchableMixin(models.AbstractModel):
+    """Mixin to be inherited by all models that need to searchable through website"""
+    _name = 'website.searchable.mixin'
+    _description = 'Website Searchable Mixin'
+
+    @api.model
+    def _search_build_domain(self, domain_list, search, fields, extra=None):
+        """
+        Builds a search domain AND-combining a base domain with partial matches of each term in
+        the search expression in any of the fields.
+
+        :param domain_list: base domain list combined in the search expression
+        :param search: search expression string
+        :param fields: list of field names to match the terms of the search expression with
+        :param extra: function that returns an additional subdomain for a search term
+
+        :return: domain limited to the matches of the search expression
+        """
+        domains = domain_list.copy()
+        if search:
+            for search_term in search.split(' '):
+                subdomains = [[(field, 'ilike', escape_psql(search_term))] for field in fields]
+                if extra:
+                    subdomains.append(extra(self.env, search_term))
+                domains.append(expression.OR(subdomains))
+        return expression.AND(domains)
+
+    @api.model
+    def _search_get_detail(self, website, order, options):
+        """
+        Returns indications on how to perform the searches
+
+        :param website: website within which the search is done
+        :param order: order in which the results are to be returned
+        :param options: search options
+
+        :return: search detail as expected in elements of the result of website._search_get_details()
+            These elements contain the following fields:
+            - model: name of the searched model
+            - base_domain: list of domains within which to perform the search
+            - search_fields: fields within which the search term must be found
+            - fetch_fields: fields from which data must be fetched
+            - mapping: mapping from the results towards the structure used in rendering templates.
+                The mapping is a dict that associates the rendering name of each field
+                to a dict containing the 'name' of the field in the results list and the 'type'
+                that must be used for rendering the value
+            - icon: name of the icon to use if there is no image
+
+        This method must be implemented by all models that inherit this mixin.
+        """
+        raise NotImplementedError()
+
+    @api.model
+    def _search_fetch(self, search_detail, search, limit, order):
+        fields = search_detail['search_fields']
+        base_domain = search_detail['base_domain']
+        domain = self._search_build_domain(base_domain, search, fields, search_detail.get('search_extra'))
+        model = self.sudo() if search_detail.get('requires_sudo') else self
+        results = model.search(
+            domain,
+            limit=limit,
+            order=search_detail.get('order', order)
+        )
+        count = model.search_count(domain)
+        return results, count
+
+    def _search_render_results(self, fetch_fields, mapping, icon, limit):
+        results_data = self.read(fetch_fields)[:limit]
+        for result in results_data:
+            result['_fa'] = icon
+            result['_mapping'] = mapping
+        html_fields = [config['name'] for config in mapping.values() if config.get('html')]
+        if html_fields:
+            for result, data in zip(self, results_data):
+                for html_field in html_fields:
+                    if data[html_field]:
+                        text = text_from_html(data[html_field])
+                        text = re.sub('\\s+', ' ', text).strip()
+                        data[html_field] = text
+        return results_data

--- a/addons/website/models/website.py
+++ b/addons/website/models/website.py
@@ -1483,19 +1483,7 @@ class Website(models.Model):
         :param order: order in which the results are to be returned
         :param options: search options
 
-        :return list of objects with:
-            - model: name of the searched model
-            - base_domain: domain within which to perform the search
-            - search_fields: fields within which the search term must be found
-            - secondary_search_fields: optionally performs a second search
-            - filter_function: optionally filters obtained results
-            - fetch_fields: fields from which data must be fetched
-            - patch_data_function: optionally sets additional fields for rendering
-            - mapping: mapping from the results towards the structure used in rendering templates.
-                The mapping is a dict that associates the rendering name of each field
-                to a dict containing the 'name' of the field in the results list and the 'type'
-                that must be used for rendering the value
-            - icon: name of the icon to use if there is no image
+        :return: list of search details obtained from the `website.searchable.mixin`'s `_search_get_detail()`
         """
         result = []
         if search_type in ['pages', 'all']:
@@ -1554,36 +1542,11 @@ class Website(models.Model):
         total_count = 0
         for search_detail in search_details:
             model = self.env[search_detail['model']]
-            fields = search_detail['search_fields']
-            base_domain = search_detail['base_domain']
-            domain = self._search_build_domain(base_domain, search, fields, search_detail.get('search_extra'))
-            if search_detail.get('requires_sudo'):
-                model = model.sudo()
-            results = model.search(
-                domain,
-                limit=limit,
-                order=search_detail.get('order', order)
-            )
-            if search:
-                base_results = results
-                secondary_fields = search_detail.get('secondary_search_fields')
-                if secondary_fields:
-                    domain = self._search_build_domain(base_domain, search, secondary_fields)
-                    results = model.search(
-                        domain,
-                        limit=limit,
-                        order=search_detail.get('order', order)
-                    )
-                    results = results.union(base_results)
-                filter_function = search_detail.get('filter_function')
-                if filter_function:
-                    results = results.filtered(lambda result: filter_function(search, result, base_results, results))
+            results, count = model._search_fetch(search_detail, search, limit, order)
             search_detail['results'] = results
-            count = model.search_count(domain)
             total_count += count
             search_detail['count'] = count
             all_results.append(search_detail)
-
         return total_count, all_results
 
     def _search_render_results(self, search_details, limit):
@@ -1599,23 +1562,9 @@ class Website(models.Model):
         for search_detail in search_details:
             fields = search_detail['fetch_fields']
             results = search_detail['results']
-            results_data = results.read(fields)[:limit]
             icon = search_detail['icon']
             mapping = search_detail['mapping']
-            for result in results_data:
-                result['_fa'] = icon
-                result['_mapping'] = mapping
-            html_fields = [config['name'] for config in mapping.values() if config.get('html')]
-            patch_function = search_detail.get('patch_data_function')
-            if patch_function or html_fields:
-                for result, data in zip(results, results_data):
-                    for html_field in html_fields:
-                        if data[html_field]:
-                            text = self._search_text_from_html(data[html_field])
-                            text = re.sub('\\s+', ' ', text).strip()
-                            data[html_field] = text
-                    if patch_function:
-                        patch_function(result, data)
+            results_data = results._search_render_results(fields, mapping, icon, limit)
             search_detail['results_data'] = results_data
         return search_details
 

--- a/addons/website/models/website_page.py
+++ b/addons/website/models/website_page.py
@@ -4,6 +4,7 @@
 import re
 
 from odoo.addons.http_routing.models.ir_http import slugify
+from odoo.addons.website.tools import text_from_html
 from odoo import api, fields, models
 from odoo.tools.safe_eval import safe_eval
 
@@ -11,7 +12,10 @@ from odoo.tools.safe_eval import safe_eval
 class Page(models.Model):
     _name = 'website.page'
     _inherits = {'ir.ui.view': 'view_id'}
-    _inherit = 'website.published.multi.mixin'
+    _inherit = [
+        'website.published.multi.mixin',
+        'website.searchable.mixin',
+    ]
     _description = 'Page'
     _order = 'website_id'
 
@@ -57,14 +61,16 @@ class Page(models.Model):
                 not page.date_publish or page.date_publish < fields.Datetime.now()
             )
 
-    def _is_most_specific_page(self, page_to_test):
-        '''This will test if page_to_test is the most specific page in self.'''
-        pages_for_url = self.sorted(key=lambda p: not p.website_id).filtered(lambda page: page.url == page_to_test.url)
-
-        # this works because pages are _order'ed by website_id
-        most_specific_page = pages_for_url[0]
-
-        return most_specific_page == page_to_test
+    def _get_most_specific_pages(self):
+        ''' Returns the most specific pages in self. '''
+        ids = []
+        previous_page = None
+        # Iterate a single time on the whole list sorted on specific-website first.
+        for page in self.sorted(key=lambda p: (p.url, not p.website_id)):
+            if not previous_page or page.url != previous_page.url:
+                ids.append(page.id)
+            previous_page = page
+        return self.filtered(lambda page: page.id in ids)
 
     def get_page_properties(self):
         self.ensure_one()
@@ -233,15 +239,6 @@ class Page(models.Model):
 
     @api.model
     def _search_get_detail(self, website, order, options):
-        """
-        Returns indications on how to perform the searches
-
-        :param website: website within which the search is done
-        :param order: order in which the results are to be returned
-        :param options: search options
-
-        :return search detail as expected in elements of the result of website._search_get_details()
-        """
         with_description = options['displayDescription']
         # Read access on website.page requires sudo.
         requires_sudo = True
@@ -250,36 +247,42 @@ class Page(models.Model):
             # Rule must be reinforced because of sudo.
             domain.append([('website_published', '=', True)])
 
+        search_fields = ['name', 'url']
         fetch_fields = ['id', 'name', 'url']
         mapping = {
             'name': {'name': 'name', 'type': 'text', 'match': True},
             'website_url': {'name': 'url', 'type': 'text'},
         }
         if with_description:
+            search_fields.append('view_id.arch_db')
             fetch_fields.append('arch')
             mapping['description'] = {'name': 'arch', 'type': 'text', 'html': True, 'match': True}
-        def filter_page(search, page, base_pages, all_pages):
-            if not all_pages._is_most_specific_page(page):
-                return False
-            if page in base_pages:
-                return True
-            text = '%s %s' % (page.name, page.url)
-            if with_description:
-                text = '%s %s' % (text, website._search_text_from_html(page.arch))
-            pattern = '|'.join([re.escape(search_term) for search_term in search.split()])
-            return re.findall('(%s)' % pattern, text, flags=re.I) if pattern else False
         return {
             'model': 'website.page',
             'base_domain': domain,
             'requires_sudo': requires_sudo,
-            'search_fields': ['name', 'url'],
-            'secondary_search_fields': ['name', 'url', 'view_id.arch_db'] if with_description else None,
-            'filter_function': filter_page,
+            'search_fields': search_fields,
             'fetch_fields': fetch_fields,
             'mapping': mapping,
             'icon': 'fa-file-o',
         }
 
+    @api.model
+    def _search_fetch(self, search_detail, search, limit, order):
+        with_description = 'description' in search_detail['mapping']
+        results, count = super()._search_fetch(search_detail, search, limit, order)
+        def filter_page(search, page, all_pages):
+            # Search might have matched words in the xml tags and parameters therefore we make
+            # sure the terms actually appear inside the text.
+            text = '%s %s %s' % (page.name, page.url, text_from_html(page.arch))
+            pattern = '|'.join([re.escape(search_term) for search_term in search.split()])
+            return re.findall('(%s)' % pattern, text, flags=re.I) if pattern else False
+        if 'url' not in order:
+            results = results._get_most_specific_pages()
+        if search and with_description:
+            results = results.filtered(lambda result: filter_page(search, result, results))
+        return results, count
+
 
 # this is just a dummy function to be used as ormcache key
 def _cached_response():
