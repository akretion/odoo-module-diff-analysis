PR: https://github.com/odoo/odoo/pull/

From: be9461bf8b196b140be6b49227de0c69412a2f6c
From: David Beguin
Date: 2019-07-15 08:16:43

Structural Changes: 8
Total Changes: 120

[IMP] gamification, survey : apply badge on certification survey

This commit allow gaining a badge at the end of a certification survey if succeeded.
The badge can be configured on the survey if the certification mode is activated.

The badge is linked directly to the survey and not the challenge,
because it makes more sense to configure directly the reward on the survey and
not the way to gain this reward. As the way is always the same.
Only one badge can be set on the certification survey.
Only the name, description, image and badge level can be configured.
The rest of badge configuration is automatically set to correspond to the use case.
When a badge is configured on a certification survey, the needed challange, goal
and challenge line are autogenerated.

The badge is available on the user's profile page if he gained it.

Once the badge is configured on the survey, he cannot be changed
(remove + create new one), only modified (badge attributes edition).
The only way to remove the badge is to uncheck 'certification_give_badge'.

When removing the badge from the certification survey, all the autogenerated
records (at badge creation) are deleted to avoid ghost records (as they have
no purpose outside of this context). If the badge is owned by someone, the badge
is only archived. If nobody owns the badge, the badge is deleted.

Survey users now have the right to create badges but not challenges or goals.
All the autogenerated records are handled in sudo, to allow the survey user
to configure a badge on their survey.

Note : To avoid having to rewrite the complete context in an xpath expression
only to display the certification badge on the user's profile page,
the default website_published value of the certification badge is defined
directly in the survey module even if survey does not depend of website.
This attribute will be ignored until website module is installed.

Task ID : 1935136
Closes PR #31486

================================= pseudo patch: =================================

--- a/addons/survey/models/__init__.py
+++ b/addons/survey/models/__init__.py
@@ -5,3 +5,5 @@ from . import ir_autovacuum
 from . import survey_survey
 from . import survey_question
 from . import survey_user
+from . import badge
+from . import challenge

--- a/None
+++ b/addons/survey/models/badge.py
@@ -0,0 +1,16 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from odoo import api, fields, models
+
+
+class GamificationBadge(models.Model):
+    _inherit = 'gamification.badge'
+
+    survey_ids = fields.One2many('survey.survey', 'certification_badge_id', 'Survey Ids')
+    survey_id = fields.Many2one('survey.survey', 'Survey', compute='_compute_survey_id', store=True)
+
+    @api.depends('survey_ids.certification_badge_id')
+    def _compute_survey_id(self):
+        for badge in self:
+            badge.survey_id = badge.survey_ids[0] if badge.survey_ids else None

--- a/None
+++ b/addons/survey/models/challenge.py
@@ -0,0 +1,10 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from odoo import models, fields
+
+
+class Challenge(models.Model):
+    _inherit = 'gamification.challenge'
+
+    category = fields.Selection(selection_add=[('certification', 'Certifications')])

--- a/addons/survey/models/survey_survey.py
+++ b/addons/survey/models/survey_survey.py
@@ -94,11 +94,26 @@ class Survey(models.Model):
         domain="[('model', '=', 'survey.user_input')]",
         help="Automated email sent to the user when he succeeds the certification, containing his certification document.")
 
+    # Certification badge
+    #   certification_badge_id_dummy is used to have two different behaviours in the form view :
+    #   - If the certification badge is not set, show certification_badge_id and only display create option in the m2o
+    #   - If the certification badge is set, show certification_badge_id_dummy in 'no create' mode.
+    #       So it can be edited but not removed or replaced.
+    certification_give_badge = fields.Boolean('Give Badge')
+    certification_badge_id = fields.Many2one('gamification.badge', 'Certification Badge')
+    certification_badge_id_dummy = fields.Many2one(related='certification_badge_id', string='Certification Badge ')
+
     _sql_constraints = [
         ('access_token_unique', 'unique(access_token)', 'Access token should be unique'),
-        ('certificate_check', "CHECK( scoring_type!='no_scoring' OR certificate=False )", 'You can only create certifications for surveys that have a scoring mechanism.'),
-        ('time_limit_check', "CHECK( (is_time_limited=False) OR (time_limit is not null AND time_limit > 0) )", 'The time limit needs to be a positive number if the survey is time limited.'),
-        ('attempts_limit_check', "CHECK( (is_attempts_limited=False) OR (attempts_limit is not null AND attempts_limit > 0) )", 'The attempts limit needs to be a positive number if the survey has a limited number of attempts.')
+        ('certificate_check', "CHECK( scoring_type!='no_scoring' OR certificate=False )",
+            'You can only create certifications for surveys that have a scoring mechanism.'),
+        ('time_limit_check', "CHECK( (is_time_limited=False) OR (time_limit is not null AND time_limit > 0) )",
+            'The time limit needs to be a positive number if the survey is time limited.'),
+        ('attempts_limit_check', "CHECK( (is_attempts_limited=False) OR (attempts_limit is not null AND attempts_limit > 0) )",
+            'The attempts limit needs to be a positive number if the survey has a limited number of attempts.'),
+        ('badge_uniq', 'unique (certification_badge_id)', "The badge for each survey should be unique!"),
+        ('give_badge_check', "CHECK(certification_give_badge=False OR (certification_give_badge=True AND certification_badge_id is not null))",
+            'Certification badge must be configured if Give Badge is set.'),
     ]
 
     @api.multi
@@ -181,6 +196,25 @@ class Survey(models.Model):
         selection = self.env['survey.survey'].fields_get(allfields=['state'])['state']['selection']
         return [s[0] for s in selection]
 
+    @api.onchange('users_login_required', 'certificate')
+    def _onchange_set_certification_give_badge(self):
+        if not self.users_login_required or not self.certificate:
+            self.certification_give_badge = False
+
+    # CRUD
+    @api.model
+    def create(self, vals):
+        survey = super(Survey, self).create(vals)
+        if vals.get('certification_give_badge'):
+            survey.sudo()._create_certification_badge_trigger()
+        return survey
+
+    def write(self, vals):
+        result = super(Survey, self).write(vals)
+        if 'certification_give_badge' in vals:
+            return self.sudo()._handle_certification_badges(vals)
+        return result
+
     # Public methods #
     def copy_data(self, default=None):
         title = _("%s (copy)") % (self.title)
@@ -435,6 +469,58 @@ class Survey(models.Model):
 
         return result
 
+    @api.multi
+    def _create_certification_badge_trigger(self):
+        self.ensure_one()
+        goal = self.env['gamification.goal.definition'].create({
+            'name': self.title,
+            'description': "%s certification passed" % self.title,
+            'domain': "['&', ('survey_id', '=', %s), ('quizz_passed', '=', True)]" % self.id,
+            'computation_mode': 'count',
+            'display_mode': 'boolean',
+            'model_id': self.env.ref('survey.model_survey_user_input').id,
+            'condition': 'higher',
+            'batch_mode': True,
+            'batch_distinctive_field': self.env.ref('survey.field_survey_user_input__partner_id').id,
+            'batch_user_expression': 'user.partner_id.id'
+        })
+        challenge = self.env['gamification.challenge'].create({
+            'name': _('%s challenge certificate' % self.title),
+            'reward_id': self.certification_badge_id.id,
+            'state': 'inprogress',
+            'period': 'once',
+            'category': 'certification',
+            'reward_realtime': True,
+            'report_message_frequency': 'never',
+            'user_domain': [('karma', '>', 0)],
+            'visibility_mode': 'personal'
+        })
+        self.env['gamification.challenge.line'].create({
+            'definition_id': goal.id,
+            'challenge_id': challenge.id,
+            'target_goal': 1
+        })
+
+    @api.multi
+    def _handle_certification_badges(self, vals):
+        if vals.get('certification_give_badge'):
+            # If badge already set on records, reactivate the ones that are not active.
+            surveys_with_badge = self.filtered(lambda survey: survey.certification_badge_id
+                                                                 and not survey.certification_badge_id.active)
+            surveys_with_badge.mapped('certification_badge_id').write({'active': True})
+            # (re-)create challenge and goal
+            for survey in self:
+                survey._create_certification_badge_trigger()
+        else:
+            # if badge with owner : archive them, else delete everything (badge, challenge, goal)
+            badges = self.mapped('certification_badge_id')
+            challenges_to_delete = self.env['gamification.challenge'].search([('reward_id', 'in', badges.ids)])
+            goals_to_delete = challenges_to_delete.mapped('line_ids').mapped('definition_id')
+            badges.write({'active': False})
+            # delete all challenges and goals because not needed anymore (challenge lines are deleted in cascade)
+            challenges_to_delete.unlink()
+            goals_to_delete.unlink()
+
     # Actions
 
     @api.multi
