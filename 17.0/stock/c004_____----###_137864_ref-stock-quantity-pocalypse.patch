PR: https://github.com/odoo/odoo/pull/137864

From: 7dda6bb92715ea25b2818a62fec5e646f3678b81
From: Arnold Moyaux
Date: 2023-10-25 18:10:54

Breaking data model changes score: 16.8, change matches:
-    move_line_nosuggest_ids = fields.One2many('stock.move.line', 'move_id', domain=['|', ('reserved_qty', '=', 0.0), ('qty_done', '!=', 0.0)])
-    reserved_availability = fields.Float(
-    quantity_done = fields.Float(
-    show_reserved_availability = fields.Boolean('From Supplier', compute='_compute_show_reserved_availability')
-    product_packaging_qty = fields.Float(
-    product_packaging_qty_done = fields.Float(
-    from_immediate_transfer = fields.Boolean(related="picking_id.immediate_transfer")
+    product_packaging_qty = fields.Float(string="Reserved Packaging Quantity", compute='_compute_product_packaging_qty')
-    reserved_qty = fields.Float(
-    reserved_uom_qty = fields.Float(
-    qty_done = fields.Float('Done', digits='Product Unit of Measure', copy=False,
-    is_initial_demand_editable = fields.Boolean(related='move_id.is_initial_demand_editable')
-    product_packaging_qty = fields.Float(
-    product_packaging_qty_done = fields.Float(
+    product_packaging_qty = fields.Float(string="Reserved Packaging Quantity", compute='_compute_product_packaging_qty')
-    move_line_nosuggest_ids = fields.One2many(
-    show_validate = fields.Boolean(
-    immediate_transfer = fields.Boolean(default=True)

Total Changes: 1310

[REF] stock: quantity pocalypse

The rational is:
Currently we have 2 columns. One for reservation, the other
for quantity picked.

However in real time, either you follow the reservation and everything
goes well. Otherwise you pick something else. In the case where you
pick somewhere else than reserved, you would like to modify the
reservation to have something similar and free the quantity you
didn't pick and expect the system to not suggest the ones you took.

In other hand, we always want to have the reserve quantity similar to
the done.

On top, having two columns could be confusing for the end user.

The cons:
*The qty_done column could be use during the picking, to
remember if something has been pick or still to pick.
* For some flow (put in pack), it's easier to write a part of the quantity to pack
and still want to reserve the full amount of product.

We goes back and choose a ligther interface over complex feature.

Changes:
Qty done and reserved qty are merged into a single column.
A new checkbox on the move exists to mark it as picked or not
Since the reservation always follow the quantity, it's now possible
to have more reserved quantity than stock. However the system will
never propose it and the inventory showing reserved > quantity should
be a warning.
The system should never modify a move that has been picked. We don't
want to overide the user action.

Regression:
Not able to pick a single stock.move.line

closes odoo/odoo#137864

Related: odoo/enterprise#48709
Related: odoo/upgrade#5310
Signed-off-by: Arnold Moyaux (arm) <arm@odoo.com>

================================= pseudo patch: =================================

--- a/addons/stock/models/product.py
+++ b/addons/stock/models/product.py
@@ -117,7 +117,7 @@ class Product(models.Model):
             if product.barcode:
                 product.valid_ean = check_barcode_encoding(product.barcode.rjust(14, '0'), 'gtin14')
 
-    @api.depends('stock_move_ids.product_qty', 'stock_move_ids.state')
+    @api.depends('stock_move_ids.product_qty', 'stock_move_ids.state', 'stock_move_ids.quantity')
     @api.depends_context(
         'lot_id', 'owner_id', 'package_id', 'from_date', 'to_date',
         'location', 'warehouse',

--- a/addons/stock/models/stock_location.py
+++ b/addons/stock/models/stock_location.py
@@ -100,7 +100,7 @@ class Location(models.Model):
     _sql_constraints = [('barcode_company_uniq', 'unique (barcode,company_id)', 'The barcode for a location must be unique per company!'),
                         ('inventory_freq_nonneg', 'check(cyclic_inventory_frequency >= 0)', 'The inventory frequency (days) for a location must be non-negative')]
 
-    @api.depends('outgoing_move_line_ids.reserved_qty', 'incoming_move_line_ids.reserved_qty',
+    @api.depends('outgoing_move_line_ids.quantity_product_uom', 'incoming_move_line_ids.quantity_product_uom',
                  'outgoing_move_line_ids.state', 'incoming_move_line_ids.state',
                  'outgoing_move_line_ids.product_id.weight', 'outgoing_move_line_ids.product_id.weight',
                  'quant_ids.quantity', 'quant_ids.product_id.weight')
@@ -116,9 +116,9 @@ class Location(models.Model):
                 location.net_weight += quant.product_id.weight * quant.quantity
             location.forecast_weight = location.net_weight
             for line in incoming_move_lines:
-                location.forecast_weight += line.product_id.weight * line.reserved_qty
+                location.forecast_weight += line.product_id.weight * line.quantity_product_uom
             for line in outgoing_move_lines:
-                location.forecast_weight -= line.product_id.weight * line.reserved_qty
+                location.forecast_weight -= line.product_id.weight * line.quantity_product_uom
 
     @api.depends('name', 'location_id.complete_name', 'usage')
     def _compute_complete_name(self):
@@ -207,7 +207,7 @@ class Location(models.Model):
                               for f in {'usage', 'scrap_location'}))
             reserved_quantities = self.env['stock.move.line'].search_count([
                 ('location_id', 'in', modified_locations.ids),
-                ('reserved_qty', '>', 0),
+                ('quantity', '>', 0),
             ])
             if reserved_quantities:
                 raise UserError(_(
@@ -312,17 +312,16 @@ class Location(models.Model):
                         ('product_id', '=', product.id),
                         ('location_dest_id', 'in', locations.ids),
                         ('state', 'not in', ['draft', 'done', 'cancel'])
-                    ], ['location_dest_id'], ['reserved_qty:array_agg', 'qty_done:array_agg', 'product_uom_id:recordset'])
+                    ], ['location_dest_id'], ['quantity:array_agg', 'product_uom_id:recordset'])
                     quant_data = self.env['stock.quant']._read_group([
                         ('product_id', '=', product.id),
                         ('location_id', 'in', locations.ids),
                     ], ['location_id'], ['quantity:sum'])
 
                     qty_by_location.update({location.id: quantity_sum for location, quantity_sum in quant_data})
-                    for location_dest, reserved_qty_list, qty_done_list, uoms in move_line_data:
-                        qty_done = sum(max(ml_uom._compute_quantity(float(qty), product.uom_id), float(qty_reserved))
-                                    for qty_reserved, qty, ml_uom in zip(reserved_qty_list, qty_done_list, uoms))
-                        qty_by_location[location_dest.id] += qty_done
+                    for location_dest, quantity_list, uoms in move_line_data:
+                        quantity = sum(ml_uom._compute_quantity(float(qty), product.uom_id) for qty, ml_uom in zip(quantity_list, uoms))
+                        qty_by_location[location_dest.id] += quantity
 
             if additional_qty:
                 for location_id, qty in additional_qty.items():
@@ -379,8 +378,8 @@ class Location(models.Model):
             # check if enough space
             if package and package.package_type_id:
                 # check weight
-                package_smls = self.env['stock.move.line'].search([('result_package_id', '=', package.id)])
-                if self.storage_category_id.max_weight < self.forecast_weight + sum(package_smls.mapped(lambda sml: sml.reserved_qty * sml.product_id.weight)):
+                package_smls = self.env['stock.move.line'].search([('result_package_id', '=', package.id), ('state', 'not in', ['done', 'cancel'])])
+                if self.storage_category_id.max_weight < self.forecast_weight + sum(package_smls.mapped(lambda sml: sml.quantity_product_uom * sml.product_id.weight)):
                     return False
                 # check if enough space
                 package_capacity = self.storage_category_id.package_capacity_ids.filtered(lambda pc: pc.package_type_id == package.package_type_id)

--- a/addons/stock/models/stock_move.py
+++ b/addons/stock/models/stock_move.py
@@ -106,6 +106,9 @@ class StockMove(models.Model):
              "* Waiting Availability: The stock move is confirmed but the product can't be reserved.\n"
              "* Available: The product of the stock move is reserved.\n"
              "* Done: The product has been transferred and the transfer has been confirmed.")
+    picked = fields.Boolean(
+        'Picked', compute='_compute_picked', inverse='_inverse_picked',
+        store=True, readonly=False, copy=False, default=False)
 
     # used to record the product cost set by the user during a picking confirmation (when costing
     # method used is 'average price' or 'real'). Value given in company currency and in product uom.
@@ -134,15 +137,10 @@ class StockMove(models.Model):
     picking_type_id = fields.Many2one('stock.picking.type', 'Operation Type', compute='_compute_picking_type_id', store=True, readonly=False, check_company=True)
     is_inventory = fields.Boolean('Inventory')
     move_line_ids = fields.One2many('stock.move.line', 'move_id')
-    move_line_nosuggest_ids = fields.One2many('stock.move.line', 'move_id', domain=['|', ('reserved_qty', '=', 0.0), ('qty_done', '!=', 0.0)])
     origin_returned_move_id = fields.Many2one(
         'stock.move', 'Origin return move', copy=False, index=True,
         help='Move that created the return move', check_company=True)
     returned_move_ids = fields.One2many('stock.move', 'origin_returned_move_id', 'All returned moves', help='Optional: all returned moves created from this move')
-    reserved_availability = fields.Float(
-        'Quantity Reserved', compute='_compute_reserved_availability',
-        digits='Product Unit of Measure',
-        readonly=True, help='Quantity that has already been reserved for this move')
     availability = fields.Float(
         'Forecasted Quantity', compute='_compute_product_availability',
         readonly=True, help='Quantity in stock that can still be reserved for this move')
@@ -154,13 +152,11 @@ class StockMove(models.Model):
         check_company=True)
     warehouse_id = fields.Many2one('stock.warehouse', 'Warehouse', help="the warehouse to consider for the route selection on the next procurement (if any).")
     has_tracking = fields.Selection(related='product_id.tracking', string='Product with Tracking')
-    quantity_done = fields.Float(
-        'Quantity Done', compute='_quantity_done_compute', digits='Product Unit of Measure',
-        inverse='_quantity_done_set', store=True)
+    quantity = fields.Float(
+        'Quantity', compute='_compute_quantity', digits='Product Unit of Measure', inverse='_set_quantity', store=True)
     show_operations = fields.Boolean(related='picking_id.picking_type_id.show_operations')
     picking_code = fields.Selection(related='picking_id.picking_type_id.code', readonly=True)
     show_details_visible = fields.Boolean('Details Visible', compute='_compute_show_details_visible')
-    show_reserved_availability = fields.Boolean('From Supplier', compute='_compute_show_reserved_availability')
     product_type = fields.Selection(related='product_id.detailed_type', readonly=True)
     additional = fields.Boolean("Whether the move was added after the picking's confirmation", default=False)
     is_locked = fields.Boolean(compute='_compute_is_locked', readonly=True)
@@ -178,16 +174,11 @@ class StockMove(models.Model):
     forecast_availability = fields.Float('Forecast Availability', compute='_compute_forecast_information', digits='Product Unit of Measure', compute_sudo=True)
     forecast_expected_date = fields.Datetime('Forecasted Expected date', compute='_compute_forecast_information', compute_sudo=True)
     lot_ids = fields.Many2many('stock.lot', compute='_compute_lot_ids', inverse='_set_lot_ids', string='Serial Numbers', readonly=False)
-    reservation_date = fields.Date('Date to Reserve', compute='_compute_reservation_date', store=True,
-        help="Computes when a move should be reserved")
+    reservation_date = fields.Date('Date to Reserve', compute='_compute_reservation_date', store=True, help="Computes when a move should be reserved")
     product_packaging_id = fields.Many2one('product.packaging', 'Packaging', domain="[('product_id', '=', product_id)]", check_company=True)
-    product_packaging_qty = fields.Float(
-            string="Reserved Packaging Quantity",
-            compute='_compute_product_packaging_qty')
-    product_packaging_qty_done = fields.Float(
-            string="Done Packaging Quantity",
-            compute='_compute_product_packaging_qty_done')
-    from_immediate_transfer = fields.Boolean(related="picking_id.immediate_transfer")
+    product_packaging_qty = fields.Float(string="Reserved Packaging Quantity", compute='_compute_product_packaging_qty')
+    product_packaging_quantity = fields.Float(
+        string="Done Packaging Quantity", compute='_compute_product_packaging_quantity')
     show_reserved = fields.Boolean(compute='_compute_show_reserved')
     show_quant = fields.Boolean("Show Quant", compute="_compute_show_info")
     show_lots_m2o = fields.Boolean("Show lot_id", compute="_compute_show_info")
@@ -209,6 +200,16 @@ class StockMove(models.Model):
             )
             move.display_assign_serial = move.has_tracking == 'serial' and move.display_import_lot
 
+    @api.depends('move_line_ids.picked', 'state')
+    def _compute_picked(self):
+        for move in self:
+            if move.state == 'done' or any(ml.picked for ml in move.move_line_ids):
+                move.picked = True
+
+    def _inverse_picked(self):
+        for move in self:
+            move.move_line_ids.picked = move.picked
+
     @api.depends('picking_id.priority')
     def _compute_priority(self):
         for move in self:
@@ -242,36 +243,20 @@ class StockMove(models.Model):
         for move in self:
             if not move.product_id:
                 move.show_details_visible = False
-            elif len(move._get_move_lines()) > 1:
+            elif len(move.move_line_ids) > 1:
                 move.show_details_visible = True
             else:
                 move.show_details_visible = show_details_visible or move.has_tracking != 'none'
 
-    def _compute_show_reserved_availability(self):
-        """ This field is only of use in an attrs in the picking view, in order to hide the
-        "available" column if the move is coming from a supplier.
-        """
-        for move in self:
-            move.show_reserved_availability = not move.location_id.usage == 'supplier'
-
-    @api.depends('state', 'picking_id.is_locked', 'picking_id.immediate_transfer')
+    @api.depends('state', 'picking_id.is_locked')
     def _compute_is_initial_demand_editable(self):
-        self.is_initial_demand_editable = False
         for move in self:
-            if move.state == 'done' and move.picking_id.is_locked:
-                move.is_initial_demand_editable = True
-            elif move.state not in ('done', 'cancel') and move.picking_id.immediate_transfer:
-                move.is_initial_demand_editable = True
-            elif move.state == 'draft':
-                move.is_initial_demand_editable = True
-
-    @api.depends('state', 'picking_id', 'product_id')
+            move.is_initial_demand_editable = not move.picking_id.is_locked or move.state == 'draft'
+
+    @api.depends('product_id')
     def _compute_is_quantity_done_editable(self):
         for move in self:
-            if not move.product_id:
-                move.is_quantity_done_editable = False
-            else:
-                move.is_quantity_done_editable = True
+            move.is_quantity_done_editable = move.product_id
 
     @api.depends('picking_id', 'name')
     def _compute_reference(self):
@@ -283,15 +268,11 @@ class StockMove(models.Model):
         for move in self:
             move.move_lines_count = len(move.move_line_ids)
 
-    @api.depends('product_id', 'product_uom', 'product_uom_qty', 'quantity_done', 'state')
+    @api.depends('product_id', 'product_uom', 'product_uom_qty', 'state')
     def _compute_product_qty(self):
         for move in self:
-            if move.state != 'done':
-                move.product_qty = move.product_uom._compute_quantity(
-                    move.product_uom_qty, move.product_id.uom_id, rounding_method='HALF-UP')
-            else:
-                move.product_qty = move.product_uom._compute_quantity(
-                    move.quantity_done, move.product_id.uom_id, rounding_method='HALF-UP')
+            move.product_qty = move.product_uom._compute_quantity(
+                move.product_uom_qty, move.product_id.uom_id, rounding_method='HALF-UP')
 
     @api.depends('picking_id.partner_id')
     def _compute_partner_id(self):
@@ -306,21 +287,13 @@ class StockMove(models.Model):
                 continue
             move.product_packaging_qty = move.product_packaging_id._compute_qty(move.product_qty)
 
-    @api.depends('product_packaging_id', 'product_uom', 'quantity_done')
-    def _compute_product_packaging_qty_done(self):
-        self.product_packaging_qty_done = False
+    @api.depends('product_packaging_id', 'product_uom', 'quantity')
+    def _compute_product_packaging_quantity(self):
+        self.product_packaging_quantity = False
         for move in self:
             if not move.product_packaging_id:
                 continue
-            move.product_packaging_qty_done = move.product_packaging_id._compute_qty(move.quantity_done, move.product_uom)
-
-    def _get_move_lines(self):
-        """ This will return the move lines to consider when applying _quantity_done_compute on a stock.move.
-        In some context, such as MRP, it is necessary to compute quantity_done on filtered sock.move.line."""
-        self.ensure_one()
-        if not self.show_reserved:
-            return self.move_line_nosuggest_ids
-        return self.move_line_ids
+            move.product_packaging_quantity = move.product_packaging_id._compute_qty(move.quantity, move.product_uom)
 
     @api.depends('move_orig_ids.date', 'move_orig_ids.state', 'state', 'date')
     def _compute_delay_alert_date(self):
@@ -340,16 +313,16 @@ class StockMove(models.Model):
         for move in self:
             move.show_reserved = move.picking_type_id.show_reserved or move.origin_returned_move_id
 
-    def _quantity_done_sml(self):
+    def _quantity_sml(self):
         self.ensure_one()
         quantity = 0
-        for move_line in self._get_move_lines():
-            quantity += move_line.product_uom_id._compute_quantity(move_line.qty_done, self.product_uom, round=False)
+        for move_line in self.move_line_ids:
+            quantity += move_line.product_uom_id._compute_quantity(move_line.quantity, self.product_uom, round=False)
         return quantity
 
-    @api.depends('move_line_ids.qty_done', 'move_line_ids.product_uom_id', 'move_line_nosuggest_ids.qty_done')
-    def _quantity_done_compute(self):
-        """ This field represents the sum of the move lines `qty_done`. It allows the user to know
+    @api.depends('move_line_ids.quantity', 'move_line_ids.product_uom_id')
+    def _compute_quantity(self):
+        """ This field represents the sum of the move lines `quantity`. It allows the user to know
         if there is still work to do.
 
         We take care of rounding this value at the general decimal precision and not the rounding
@@ -360,73 +333,55 @@ class StockMove(models.Model):
         if not any(self._ids):
             # onchange
             for move in self:
-                move.quantity_done = move._quantity_done_sml()
+                move.quantity = move._quantity_sml()
         else:
             # compute
             move_lines_ids = set()
             for move in self:
-                move_lines_ids |= set(move._get_move_lines().ids)
+                move_lines_ids |= set(move.move_line_ids.ids)
 
             data = self.env['stock.move.line']._read_group(
                 [('id', 'in', list(move_lines_ids))],
-                ['move_id', 'product_uom_id'], ['qty_done:sum']
+                ['move_id', 'product_uom_id'], ['quantity:sum']
             )
-            sum_qty_done = defaultdict(float)
-            for move, product_uom, qty_done_sum in data:
+            sum_qty = defaultdict(float)
+            for move, product_uom, qty_sum in data:
                 uom = move.product_uom
-                sum_qty_done[move.id] += product_uom._compute_quantity(qty_done_sum, uom, round=False)
+                sum_qty[move.id] += product_uom._compute_quantity(qty_sum, uom, round=False)
 
             for move in self:
-                move.quantity_done = sum_qty_done[move.id]
+                move.quantity = sum_qty[move.id]
 
-    def _quantity_done_set(self):
+    def _set_quantity(self):
         def _process_decrease(move, quantity):
-            """Prioritize decrease the ml without reserved qty"""
-            res_mls = move._get_move_lines().sorted(lambda ml: float_is_zero(ml.reserved_uom_qty, precision_rounding=ml.product_uom_id.rounding), reverse=True)
-            qty_to_unreserve = move.reserved_availability - move.product_uom_qty
-            for ml in res_mls:
+            for ml in move.move_line_ids:
                 if float_is_zero(quantity, precision_rounding=move.product_uom.rounding):
                     break
-                qty_ml_dec = min(ml.qty_done, ml.product_uom_id._compute_quantity(quantity, ml.product_uom_id, round=False))
+                qty_ml_dec = min(ml.quantity, ml.product_uom_id._compute_quantity(quantity, ml.product_uom_id, round=False))
                 if float_is_zero(qty_ml_dec, precision_rounding=ml.product_uom_id.rounding):
                     continue
-                ml.qty_done -= qty_ml_dec
+                if float_compare(ml.quantity, qty_ml_dec, precision_rounding=ml.product_uom_id.rounding) == 0 and ml.state not in ['done', 'cancel']:
+                    ml.unlink()
+                else:
+                    ml.quantity -= qty_ml_dec
                 quantity -= move.product_uom._compute_quantity(qty_ml_dec, move.product_uom, round=False)
-                # Unreserve
-                if (not move.picking_id.immediate_transfer and move.reserved_availability < move.product_uom_qty):
-                    continue
-                if float_compare(ml.reserved_uom_qty, ml.qty_done, precision_rounding=ml.product_uom_id.rounding) <= 0:
-                    continue
-                if move.picking_id.immediate_transfer:
-                    ml.reserved_uom_qty = ml.qty_done
-                elif float_compare(qty_to_unreserve, 0, precision_rounding=move.product_uom.rounding) > 0:
-                    qty_unreserved = min(qty_to_unreserve, ml.reserved_qty - ml.qty_done)
-                    ml.reserved_uom_qty = ml.reserved_qty - qty_unreserved
-                    qty_to_unreserve -= qty_unreserved
 
         def _process_increase(move, quantity):
-            moves = move
-            if move.picking_id and move.picking_id.immediate_transfer:
-                moves = move._action_confirm(merge=False)
-            # Kits, already handle in action_explode, should be clean in master
-            if len(moves) > 1:
-                return
-            if move.reserved_availability < move.quantity_done and move.state not in ['done', 'cancel']:
-                move._action_assign(force_qty=move.quantity_done)
-            move._set_quantity_done(quantity)
+            # move._action_assign(quantity)
+            move._set_quantity_done(move.quantity)
 
         err = []
         for move in self:
-            uom_qty = float_round(move.quantity_done, precision_rounding=move.product_uom.rounding, rounding_method='HALF-UP')
+            uom_qty = float_round(move.quantity, precision_rounding=move.product_uom.rounding, rounding_method='HALF-UP')
             precision_digits = self.env['decimal.precision'].precision_get('Product Unit of Measure')
-            qty = float_round(move.quantity_done, precision_digits=precision_digits, rounding_method='HALF-UP')
+            qty = float_round(move.quantity, precision_digits=precision_digits, rounding_method='HALF-UP')
             if float_compare(uom_qty, qty, precision_digits=precision_digits) != 0:
                 err.append(_("""
 The quantity done for the product %s doesn't respect the rounding precision defined on the unit of measure %s.
 Please change the quantity done or the rounding precision of your unit of measure.""",
                              move.product_id.display_name, move.product_uom.display_name))
                 continue
-            delta_qty = move.quantity_done - move._quantity_done_sml()
+            delta_qty = move.quantity - move._quantity_sml()
             if float_compare(delta_qty, 0, precision_rounding=move.product_uom.rounding) > 0:
                 _process_increase(move, delta_qty)
             elif float_compare(delta_qty, 0, precision_rounding=move.product_uom.rounding) < 0:
@@ -441,26 +396,6 @@ Please change the quantity done or the rounding precision of your unit of measur
         detect errors. """
         raise UserError(_('The requested operation cannot be processed because of a programming error setting the `product_qty` field instead of the `product_uom_qty`.'))
 
-    @api.depends('move_line_ids.reserved_qty')
-    def _compute_reserved_availability(self):
-        """ Fill the `availability` field on a stock move, which is the actual reserved quantity
-        and is represented by the aggregated `product_qty` on the linked move lines. If the move
-        is force assigned, the value will be 0.
-        """
-        if not any(self._ids):
-            # onchange
-            for move in self:
-                reserved_availability = sum(move.move_line_ids.mapped('reserved_qty'))
-                move.reserved_availability = move.product_id.uom_id._compute_quantity(
-                    reserved_availability, move.product_uom, rounding_method='HALF-UP')
-        else:
-            # compute
-            result = {move.id: reserved_qty for move, reserved_qty in
-                      self.env['stock.move.line']._read_group([('move_id', 'in', self.ids)], ['move_id'], ['reserved_qty:sum'])}
-            for move in self:
-                move.reserved_availability = move.product_id.uom_id._compute_quantity(
-                    result.get(move.id, 0.0), move.product_uom, rounding_method='HALF-UP')
-
     @api.depends('state', 'product_id', 'product_qty', 'location_id')
     def _compute_product_availability(self):
         """ Fill the `availability` field on a stock move, which is the quantity to potentially
@@ -474,7 +409,7 @@ Please change the quantity done or the rounding precision of your unit of measur
                 total_availability = self.env['stock.quant']._get_available_quantity(move.product_id, move.location_id) if move.product_id else 0.0
                 move.availability = min(move.product_qty, total_availability)
 
-    @api.depends('product_id', 'product_qty', 'picking_type_id', 'reserved_availability', 'priority', 'state', 'product_uom_qty', 'location_id')
+    @api.depends('product_id', 'product_qty', 'picking_type_id', 'quantity', 'priority', 'state', 'product_uom_qty', 'location_id')
     def _compute_forecast_information(self):
         """ Compute forecasted information of the related product by warehouse."""
         self.forecast_availability = False
@@ -512,7 +447,7 @@ Please change the quantity done or the rounding precision of your unit of measur
             if move._is_consuming():
                 if move.state == 'assigned':
                     move.forecast_availability = move.product_uom._compute_quantity(
-                        move.reserved_availability, move.product_id.uom_id, rounding_method='HALF-UP')
+                        move.quantity, move.product_id.uom_id, rounding_method='HALF-UP')
                 elif move.state == 'draft':
                     # for move _is_consuming and in draft -> the forecast_availability > 0 if in stock
                     move.forecast_availability = virtual_available_dict[key_virtual_available(move)][move.product_id.id] - move.product_qty
@@ -552,33 +487,27 @@ Please change the quantity done or the rounding precision of your unit of measur
                 else:
                     move_update.date_deadline = new_deadline
 
-    @api.depends('move_line_ids.lot_id', 'move_line_ids.qty_done')
+    @api.depends('move_line_ids.lot_id', 'move_line_ids.quantity')
     def _compute_lot_ids(self):
-        domain_nosuggest = [('move_id', 'in', self.ids), ('lot_id', '!=', False), '|', ('qty_done', '!=', 0.0), ('reserved_qty', '=', 0.0)]
-        domain_suggest = [('move_id', 'in', self.ids), ('lot_id', '!=', False), ('qty_done', '!=', 0.0)]
-        lots_by_move_id_list = []
-        for domain in [domain_nosuggest, domain_suggest]:
-            lots_by_move_id = self.env['stock.move.line']._read_group(
-                domain,
-                ['move_id'], ['lot_id:array_agg'],
-            )
-            lots_by_move_id_list.append({move.id: lot_ids for move, lot_ids in lots_by_move_id})
+        domain = [('move_id', 'in', self.ids), ('lot_id', '!=', False), ('quantity', '!=', 0.0)]
+        lots_by_move_id = self.env['stock.move.line']._read_group(
+            domain,
+            ['move_id'], ['lot_id:array_agg'],
+        )
+        lots_by_move_id = {move.id: lot_ids for move, lot_ids in lots_by_move_id}
         for move in self:
-            move.lot_ids = lots_by_move_id_list[0 if move.show_reserved else 1].get(move._origin.id, [])
+            move.lot_ids = lots_by_move_id.get(move._origin.id, [])
 
     def _set_lot_ids(self):
         for move in self:
             if move.product_id.tracking != 'serial':
                 continue
             move_lines_commands = []
-            if not move.show_reserved:
-                mls = move.move_line_nosuggest_ids
-            else:
-                mls = move.move_line_ids
+            mls = move.move_line_ids
             mls_with_lots = mls.filtered(lambda ml: ml.lot_id)
             mls_without_lots = (mls - mls_with_lots)
             for ml in mls_with_lots:
-                if ml.qty_done and ml.lot_id not in move.lot_ids:
+                if ml.quantity and ml.lot_id not in move.lot_ids:
                     move_lines_commands.append((2, ml.id))
             ls = move.move_line_ids.lot_id
             for lot in move.lot_ids:
@@ -589,7 +518,7 @@ Please change the quantity done or the rounding precision of your unit of measur
                             'lot_name': lot.name,
                             'lot_id': lot.id,
                             'product_uom_id': move.product_id.uom_id.id,
-                            'qty_done': 1,
+                            'quantity': 1,
                         }))
                         mls_without_lots -= move_line
                     else:  # No line without serial number, creates a new one.
@@ -597,11 +526,11 @@ Please change the quantity done or the rounding precision of your unit of measur
                         move_line_vals['lot_id'] = lot.id
                         move_line_vals['lot_name'] = lot.name
                         move_line_vals['product_uom_id'] = move.product_id.uom_id.id
-                        move_line_vals['qty_done'] = 1
+                        move_line_vals['quantity'] = 1
                         move_lines_commands.append((0, 0, move_line_vals))
                 else:
                     move_line = move.move_line_ids.filtered(lambda line: line.lot_id.id == lot.id)
-                    move_line.qty_done = 1
+                    move_line.quantity = 1
             move.write({'move_line_ids': move_lines_commands})
 
     @api.depends('picking_type_id', 'date', 'priority', 'state')
@@ -657,12 +586,8 @@ Please change the quantity done or the rounding precision of your unit of measur
             picking_id = self.env['stock.picking'].browse(self.env.context['default_picking_id'])
             if picking_id.state == 'done':
                 defaults['state'] = 'done'
-                defaults['product_uom_qty'] = 0.0
                 defaults['additional'] = True
             elif picking_id.state not in ['cancel', 'draft', 'done']:
-                if picking_id.immediate_transfer:
-                    defaults['state'] = 'assigned'
-                defaults['product_uom_qty'] = 0.0
                 defaults['additional'] = True  # to trigger `_autoconfirm_picking`
         return defaults
 
@@ -677,11 +602,8 @@ Please change the quantity done or the rounding precision of your unit of measur
     @api.model_create_multi
     def create(self, vals_list):
         for vals in vals_list:
-            if (vals.get('quantity_done') or vals.get('move_line_ids')) and 'lot_ids' in vals:
+            if (vals.get('quantity') or vals.get('move_line_ids')) and 'lot_ids' in vals:
                 vals.pop('lot_ids')
-            picking_id = self.env['stock.picking'].browse(vals.get('picking_id'))
-            if picking_id and picking_id.immediate_transfer and not vals.get('qty_done'):
-                vals['state'] = 'assigned'
         return super().create(vals_list)
 
     def write(self, vals):
@@ -689,8 +611,10 @@ Please change the quantity done or the rounding precision of your unit of measur
         # messages according to the state of the stock.move records.
         receipt_moves_to_reassign = self.env['stock.move']
         move_to_recompute_state = self.env['stock.move']
-        if 'quantity_done' in vals and any(move.state == 'cancel' for move in self):
-            raise UserError(_('You cannot change a cancelled stock move, create a new line instead.'))
+        move_to_confirm = self.env['stock.move']
+        if 'quantity' in vals:
+            if any(move.state == 'cancel' for move in self):
+                raise UserError(_('You cannot change a cancelled stock move, create a new line instead.'))
         if 'product_uom' in vals and any(move.state == 'done' for move in self):
             raise UserError(_('You cannot change the UoM for a stock move that has been set to \'Done\'.'))
         if 'product_uom_qty' in vals:
@@ -700,16 +624,17 @@ Please change the quantity done or the rounding precision of your unit of measur
                     self.env['stock.move.line']._log_message(move.picking_id, move, 'stock.track_move_template', vals)
             if self.env.context.get('do_not_unreserve') is None:
                 move_to_unreserve = self.filtered(
-                    lambda m: m.state not in ['draft', 'done', 'cancel'] and float_compare(m.reserved_availability, vals.get('product_uom_qty'), precision_rounding=m.product_uom.rounding) == 1
+                    lambda m: m.state not in ['draft', 'done', 'cancel'] and float_compare(m.quantity, vals.get('product_uom_qty'), precision_rounding=m.product_uom.rounding) == 1
                 )
                 move_to_unreserve._do_unreserve()
                 (self - move_to_unreserve).filtered(lambda m: m.state == 'assigned').write({'state': 'partially_available'})
                 # When editing the initial demand, directly run again action assign on receipt moves.
                 receipt_moves_to_reassign |= move_to_unreserve.filtered(lambda m: m.location_id.usage == 'supplier')
-                receipt_moves_to_reassign |= (self - move_to_unreserve).filtered(lambda m:
-                     m.location_id.usage == 'supplier'
-                     and m.state in ('partially_available', 'assigned')
-                     and not m.picking_id.immediate_transfer)
+                receipt_moves_to_reassign |= (self - move_to_unreserve).filtered(
+                    lambda m:
+                        m.location_id.usage == 'supplier' and
+                        m.state in ('partially_available', 'assigned')
+                )
                 move_to_recompute_state |= self - move_to_unreserve - receipt_moves_to_reassign
         # propagate product_packaging_id changes in the stock move chain
         if 'product_packaging_id' in vals:
@@ -717,10 +642,13 @@ Please change the quantity done or the rounding precision of your unit of measur
         if 'date_deadline' in vals:
             self._set_date_deadline(vals.get('date_deadline'))
         if 'move_orig_ids' in vals:
-            move_to_recompute_state |= self
+            move_to_recompute_state |= self.filtered(lambda m: m.state not in ['draft', 'cance', 'done'])
+
         res = super(StockMove, self).write(vals)
         if move_to_recompute_state:
             move_to_recompute_state._recompute_state()
+        if move_to_confirm:
+            move_to_confirm._action_assign()
         if receipt_moves_to_reassign:
             receipt_moves_to_reassign._action_assign()
         return res
@@ -784,14 +712,7 @@ Please change the quantity done or the rounding precision of your unit of measur
         checked on the picking type.
         """
         self.ensure_one()
-        # If "show suggestions" is not checked on the picking type, we have to filter out the
-        # reserved move lines. We do this by displaying `move_line_nosuggest_ids`. We use
-        # different views to display one field or another so that the webclient doesn't have to
-        # fetch both.
-        if self.from_immediate_transfer:
-            view = self.env.ref('stock.view_stock_move_operations_immediate')
-        else:
-            view = self.env.ref('stock.view_stock_move_operations')
+        view = self.env.ref('stock.view_stock_move_operations')
 
         return {
             'name': _('Detailed Operations'),
@@ -823,11 +744,7 @@ Please change the quantity done or the rounding precision of your unit of measur
         since there's no way to undo the action.
         """
         self.ensure_one()
-        if self.show_reserved:
-            move_lines = self.move_line_ids
-        else:
-            move_lines = self.move_line_nosuggest_ids
-        move_lines.unlink()
+        self.move_line_ids.unlink()
         return self.action_show_details()
 
     def action_assign_serial(self):
@@ -870,18 +787,16 @@ Please change the quantity done or the rounding precision of your unit of measur
             moves_to_unreserve.add(move.id)
         moves_to_unreserve = self.env['stock.move'].browse(moves_to_unreserve)
 
-        ml_to_update, ml_to_unlink = OrderedSet(), OrderedSet()
+        ml_to_unlink = OrderedSet()
         moves_not_to_recompute = OrderedSet()
         for ml in moves_to_unreserve.move_line_ids:
-            if ml.qty_done:
-                ml_to_update.add(ml.id)
-            else:
-                ml_to_unlink.add(ml.id)
+            if ml.picked:
                 moves_not_to_recompute.add(ml.move_id.id)
-        ml_to_update, ml_to_unlink = self.env['stock.move.line'].browse(ml_to_update), self.env['stock.move.line'].browse(ml_to_unlink)
+                continue
+            ml_to_unlink.add(ml.id)
+        ml_to_unlink = self.env['stock.move.line'].browse(ml_to_unlink)
         moves_not_to_recompute = self.env['stock.move'].browse(moves_not_to_recompute)
 
-        ml_to_update.write({'reserved_uom_qty': 0})
         ml_to_unlink.unlink()
         # `write` on `stock.move.line` doesn't call `_recompute_state` (unlike to `unlink`),
         # so it must be called for each move where no move line has been deleted.
@@ -895,14 +810,10 @@ Please change the quantity done or the rounding precision of your unit of measur
         self.ensure_one()
         if not location_id:
             location_id = self.location_dest_id
-
         lot_names = self.env['stock.lot'].generate_lot_names(next_serial, next_serial_count or self.next_serial_count)
-        field_data = [{'lot_name': lot_name['lot_name'], 'qty_done': lot_name.get('qty_done', 1)} for lot_name in lot_names]
+        field_data = [{'lot_name': lot_name['lot_name'], 'quantity': 1} for lot_name in lot_names]
         move_lines_commands = self._generate_serial_move_line_commands(field_data)
-        if self.show_reserved:
-            self.move_line_ids = move_lines_commands
-        else:
-            self.move_line_nosuggest_ids = move_lines_commands
+        self.move_line_ids = move_lines_commands
         return True
 
     @api.model
@@ -921,7 +832,7 @@ Please change the quantity done or the rounding precision of your unit of measur
         for lot_text in split_lines:
             move_line_vals = {
                 'lot_name': lot_text,
-                'qty_done': 1,
+                'quantity': 1,
             }
             # Semicolons are also used for separation but for convenience we
             # replace them to work only with tabs.
@@ -961,11 +872,11 @@ Please change the quantity done or the rounding precision of your unit of measur
         elif mode == 'import':
             lot_names = self.split_lots(lot_text)
         for lot in lot_names:
-            if not lot.get('qty_done'):
-                lot['qty_done'] = 1
+            if not lot.get('quantity'):
+                lot['quantity'] = 1
             loc_dest = self.env['stock.location'].browse(default_vals['location_dest_id'])
             product = self.env['product.product'].browse(default_vals['product_id'])
-            loc_dest = loc_dest._get_putaway_strategy(product, lot['qty_done'])
+            loc_dest = loc_dest._get_putaway_strategy(product, lot['quantity'])
             vals_list.append({**default_vals,
                              **lot,
                              'location_dest_id': loc_dest.id,
@@ -1122,7 +1033,7 @@ Please change the quantity done or the rounding precision of your unit of measur
             moves_to_unlink.sudo().unlink()
 
         if moves_to_cancel:
-            moves_to_cancel.filtered(lambda m: float_is_zero(m.quantity_done, precision_rounding=m.product_uom.rounding))._action_cancel()
+            moves_to_cancel.filtered(lambda m: not m.picked)._action_cancel()
 
         return (self | merged_moves) - moves_to_unlink
 
@@ -1184,9 +1095,9 @@ Please change the quantity done or the rounding precision of your unit of measur
 
     @api.onchange('lot_ids')
     def _onchange_lot_ids(self):
-        quantity_done = sum(ml.product_uom_id._compute_quantity(ml.qty_done, self.product_uom) for ml in self.move_line_ids.filtered(lambda ml: not ml.lot_id and ml.lot_name))
-        quantity_done += self.product_id.uom_id._compute_quantity(len(self.lot_ids), self.product_uom)
-        self.update({'quantity_done': quantity_done})
+        quantity = sum(ml.quantity_product_uom for ml in self.move_line_ids.filtered(lambda ml: not ml.lot_id and ml.lot_name))
+        quantity += self.product_id.uom_id._compute_quantity(len(self.lot_ids), self.product_uom)
+        self.update({'quantity': quantity})
 
         quants = self.env['stock.quant'].search([('product_id', '=', self.product_id.id),
                                                  ('lot_id', 'in', self.lot_ids.ids),
@@ -1286,7 +1197,7 @@ Please change the quantity done or the rounding precision of your unit of measur
         Called when user want to create and assign multiple serial numbers in
         one time (using the button/wizard or copy-paste a list in the field).
 
-        :param field_data: A list containing dict with at least `lot_name` and `qty_done`
+        :param field_data: A list containing dict with at least `lot_name` and `quantity`
         :type field_data: list
         :param origin_move_line: A move line to duplicate the value from, empty record by default
         :type origin_move_line: record of :class:`stock.move.line`
@@ -1303,8 +1214,7 @@ Please change the quantity done or the rounding precision of your unit of measur
             'product_uom_id': self.product_id.uom_id.id,
         }
         # Select the right move lines depending of the picking type's configuration.
-        move_lines = self['move_line_ids' if self.show_reserved else 'move_line_nosuggest_ids']
-        move_lines = move_lines.filtered(lambda ml: not ml.lot_id and not ml.lot_name)
+        move_lines = self.move_line_ids.filtered(lambda ml: not ml.lot_id and not ml.lot_name)
 
         if origin_move_line:
             # Copies `owner_id` and `package_id` if new move lines are created from an existing one.
@@ -1316,22 +1226,22 @@ Please change the quantity done or the rounding precision of your unit of measur
         move_lines_commands = []
         qty_by_location = defaultdict(float)
         for command_vals in field_data:
-            qty_done = command_vals['qty_done']
+            quantity = command_vals['quantity']
             # We write the lot name on an existing move line (if we have still one)...
             if move_lines:
                 move_lines_commands.append(Command.update(move_lines[0].id, command_vals))
-                qty_by_location[move_lines[0].location_dest_id.id] += qty_done
+                qty_by_location[move_lines[0].location_dest_id.id] += quantity
                 move_lines = move_lines[1:]
             # ... or create a new move line with the serial name.
             else:
-                loc = loc_dest or self.location_dest_id._get_putaway_strategy(self.product_id, quantity=qty_done, packaging=self.product_packaging_id, additional_qty=qty_by_location)
+                loc = loc_dest or self.location_dest_id._get_putaway_strategy(self.product_id, quantity=quantity, packaging=self.product_packaging_id, additional_qty=qty_by_location)
                 new_move_line_vals = {
                     **move_line_vals,
                     **command_vals,
                     'location_dest_id': loc.id
                 }
                 move_lines_commands.append(Command.create(new_move_line_vals))
-                qty_by_location[loc.id] += qty_done
+                qty_by_location[loc.id] += quantity
         return move_lines_commands
 
     def _get_formating_options(self, strings):
@@ -1362,8 +1272,6 @@ Please change the quantity done or the rounding precision of your unit of measur
             'picking_type_id': self.mapped('picking_type_id').id,
             'location_id': self.mapped('location_id').id,
             'location_dest_id': self.mapped('location_dest_id').id,
-            'state': 'draft',
-            'immediate_transfer': False,
         }
 
     def _should_be_assigned(self):
@@ -1415,7 +1323,7 @@ Please change the quantity done or the rounding precision of your unit of measur
         # assign picking in batch for all confirmed move that share the same details
         for moves_ids in to_assign.values():
             self.browse(moves_ids).with_context(clean_context(self.env.context))._assign_picking()
-        new_push_moves = self.filtered(lambda m: not m.picking_id.immediate_transfer)._push_apply()
+        new_push_moves = self._push_apply()
         self._check_company()
         moves = self
         if merge:
@@ -1511,9 +1419,9 @@ Please change the quantity done or the rounding precision of your unit of measur
             uom_quantity = float_round(uom_quantity, precision_digits=rounding)
             uom_quantity_back_to_product_uom = self.product_uom._compute_quantity(uom_quantity, self.product_id.uom_id, rounding_method='HALF-UP')
             if float_compare(quantity, uom_quantity_back_to_product_uom, precision_digits=rounding) == 0:
-                vals = dict(vals, reserved_uom_qty=uom_quantity)
+                vals = dict(vals, quantity=uom_quantity)
             else:
-                vals = dict(vals, reserved_uom_qty=quantity, product_uom_id=self.product_id.uom_id.id)
+                vals = dict(vals, quantity=quantity, product_uom_id=self.product_id.uom_id.id)
         package = None
         if reserved_quant:
             package = reserved_quant.package_id
@@ -1557,7 +1465,7 @@ Please change the quantity done or the rounding precision of your unit of measur
                 uom_quantity = float_round(uom_quantity, precision_digits=rounding)
                 uom_quantity_back_to_product_uom = to_update.product_uom_id._compute_quantity(uom_quantity, self.product_id.uom_id, rounding_method='HALF-UP')
             if to_update and float_compare(quantity, uom_quantity_back_to_product_uom, precision_digits=rounding) == 0:
-                to_update.with_context(reserved_quant=reserved_quant).reserved_uom_qty += uom_quantity
+                to_update.with_context(reserved_quant=reserved_quant).quantity += uom_quantity
             else:
                 if self.product_id.tracking == 'serial':
                     vals_list = self._add_serial_move_line_to_vals_list(reserved_quant, quantity)
@@ -1590,10 +1498,10 @@ Please change the quantity done or the rounding precision of your unit of measur
 
         grouped_move_lines_in = {}
         for k, g in groupby(move_lines_in, key=_keys_in_groupby):
-            qty_done = 0
+            quantity = 0
             for ml in g:
-                qty_done += ml.product_uom_id._compute_quantity(ml.qty_done, ml.product_id.uom_id)
-            grouped_move_lines_in[k] = qty_done
+                quantity += ml.product_uom_id._compute_quantity(ml.quantity, ml.product_id.uom_id)
+            grouped_move_lines_in[k] = quantity
 
         return grouped_move_lines_in
 
@@ -1614,12 +1522,12 @@ Please change the quantity done or the rounding precision of your unit of measur
 
         grouped_move_lines_out = {}
         for k, g in groupby(move_lines_out_done, key=_keys_out_groupby):
-            qty_done = 0
+            quantity = 0
             for ml in g:
-                qty_done += ml.product_uom_id._compute_quantity(ml.qty_done, ml.product_id.uom_id)
-            grouped_move_lines_out[k] = qty_done
+                quantity += ml.product_uom_id._compute_quantity(ml.quantity, ml.product_id.uom_id)
+            grouped_move_lines_out[k] = quantity
         for k, g in groupby(move_lines_out_reserved, key=_keys_out_groupby):
-            grouped_move_lines_out[k] = sum(self.env['stock.move.line'].concat(*list(g)).mapped('reserved_qty'))
+            grouped_move_lines_out[k] = sum(self.env['stock.move.line'].concat(*list(g)).mapped('quantity'))
 
         return grouped_move_lines_out
 
@@ -1642,7 +1550,8 @@ Please change the quantity done or the rounding precision of your unit of measur
         partially_available_moves_ids = OrderedSet()
         # Read the `reserved_availability` field of the moves out of the loop to prevent unwanted
         # cache invalidation when actually reserving the move.
-        reserved_availability = {move: move.reserved_availability for move in self}
+        reserved_availability = {move: move.quantity for move in self}
+
         roundings = {move: move.product_id.uom_id.rounding for move in self}
         move_line_vals_list = []
         # Once the quantities are assigned, we want to find a better destination location thanks
@@ -1650,17 +1559,21 @@ Please change the quantity done or the rounding precision of your unit of measur
         moves_to_redirect = OrderedSet()
         moves_to_assign = self
         if not force_qty:
-            moves_to_assign = self.filtered(lambda m: m.state in ['confirmed', 'waiting', 'partially_available'])
+            moves_to_assign = moves_to_assign.filtered(
+                lambda m: not m.picked and m.state in ['confirmed', 'waiting', 'partially_available']
+            )
         moves_to_reserve = moves_to_assign.filtered(lambda m: not m._should_bypass_reservation())
         quants_by_product = self.env['stock.quant']._get_quants_by_products_locations(moves_to_reserve.product_id, moves_to_reserve.location_id)
 
         for move in moves_to_assign:
             rounding = roundings[move]
             if not force_qty:
-                missing_reserved_uom_quantity = move.product_uom_qty
+                missing_reserved_uom_quantity = move.product_uom_qty - reserved_availability[move]
             else:
                 missing_reserved_uom_quantity = force_qty
-            missing_reserved_uom_quantity -= reserved_availability[move]
+            if float_compare(missing_reserved_uom_quantity, 0, precision_rounding=rounding) <= 0:
+                assigned_moves_ids.add(move.id)
+                continue
             missing_reserved_quantity = move.product_uom._compute_quantity(missing_reserved_uom_quantity, move.product_id.uom_id, rounding_method='HALF-UP')
             quants = quants_by_product[move.product_id.id]
             if move._should_bypass_reservation():
@@ -1690,11 +1603,13 @@ Please change the quantity done or the rounding precision of your unit of measur
                                                             ml.location_id == move.location_id and
                                                             ml.location_dest_id == move.location_dest_id and
                                                             ml.picking_id == move.picking_id and
+                                                            not ml.picked and
                                                             not ml.lot_id and
+                                                            not ml.result_package_id and
                                                             not ml.package_id and
                                                             not ml.owner_id)
                     if to_update:
-                        to_update[0].reserved_uom_qty += move.product_id.uom_id._compute_quantity(
+                        to_update[0].quantity += move.product_id.uom_id._compute_quantity(
                             missing_reserved_quantity, move.product_uom, rounding_method='HALF-UP')
                     else:
                         move_line_vals_list.append(move._prepare_move_line_vals(quantity=missing_reserved_quantity))
@@ -1724,17 +1639,17 @@ Please change the quantity done or the rounding precision of your unit of measur
                 else:
                     # Check what our parents brought and what our siblings took in order to
                     # determine what we can distribute.
-                    # `qty_done` is in `ml.product_uom_id` and, as we will later increase
+                    # `quantity` is in `ml.product_uom_id` and, as we will later increase
                     # the reserved quantity on the quants, convert it here in
                     # `product_id.uom_id` (the UOM of the quants is the UOM of the product).
                     available_move_lines = move._get_available_move_lines(assigned_moves_ids, partially_available_moves_ids)
                     if not available_move_lines:
                         continue
-                    for move_line in move.move_line_ids.filtered(lambda m: m.reserved_qty):
+                    for move_line in move.move_line_ids.filtered(lambda m: m.quantity):
                         if available_move_lines.get((move_line.location_id, move_line.lot_id, move_line.result_package_id, move_line.owner_id)):
-                            available_move_lines[(move_line.location_id, move_line.lot_id, move_line.result_package_id, move_line.owner_id)] -= move_line.reserved_qty
+                            available_move_lines[(move_line.location_id, move_line.lot_id, move_line.result_package_id, move_line.owner_id)] -= move_line.quantity
                     for (location_id, lot_id, package_id, owner_id), quantity in available_move_lines.items():
-                        need = move.product_qty - sum(move.move_line_ids.mapped('reserved_qty'))
+                        need = move.product_qty - sum(move.move_line_ids.mapped('quantity'))
                         # `quantity` is what is brought by chained done move lines. We double check
                         # here this quantity is available on the quants themselves. If not, this
                         # could be the result of an inventory adjustment that removed totally of
@@ -1764,6 +1679,7 @@ Please change the quantity done or the rounding precision of your unit of measur
         if any(move.state == 'done' and not move.scrapped for move in self):
             raise UserError(_('You cannot cancel a stock move that has been set to \'Done\'. Create a return in order to reverse the moves which took place.'))
         moves_to_cancel = self.filtered(lambda m: m.state != 'cancel' and not (m.state == 'done' and m.scrapped))
+        moves_to_cancel.picked = False
         # self cannot contain moves that are either cancelled or done, therefore we can safely
         # unlink all associated move_line_ids
         moves_to_cancel._do_unreserve()
@@ -1809,16 +1725,18 @@ Please change the quantity done or the rounding precision of your unit of measur
         """
         extra_move = self
         rounding = self.product_uom.rounding
+        if float_is_zero(self.product_uom_qty, precision_rounding=rounding):
+            return self
         # moves created after the picking is assigned do not have `product_uom_qty`, but we shouldn't create extra moves for them
-        if float_compare(self.quantity_done, self.product_uom_qty, precision_rounding=rounding) > 0:
+        if float_compare(self.quantity, self.product_uom_qty, precision_rounding=rounding) > 0:
             # create the extra moves
             extra_move_quantity = float_round(
-                self.quantity_done - self.product_uom_qty,
+                self.quantity - self.product_uom_qty,
                 precision_rounding=rounding,
                 rounding_method='HALF-UP')
             extra_move_vals = self._prepare_extra_move_vals(extra_move_quantity)
             extra_move = self.copy(default=extra_move_vals).with_context(avoid_putaway_rules=True)
-            return extra_move.with_context(merge_extra=True)._action_confirm(merge_into=self)
+            return extra_move.with_context(merge_extra=True, do_not_unreserve=True)._action_confirm(merge_into=self)
         return self
 
     def _check_unlink_move_dest(self):
@@ -1843,22 +1761,26 @@ Please change the quantity done or the rounding precision of your unit of measur
             new_push_moves._action_confirm()
 
     def _action_done(self, cancel_backorder=False):
-        moves = self.filtered(lambda move: move.state == 'draft' or move.state == 'assigned' and move.from_immediate_transfer)._action_confirm()  # MRP allows scrapping draft moves
+        moves = self.filtered(
+            lambda move: move.state == 'draft'
+            or float_is_zero(move.product_uom_qty, precision_digits=move.product_uom.rounding)
+        )._action_confirm(merge=False)  # MRP allows scrapping draft moves
         moves = (self | moves).exists().filtered(lambda x: x.state not in ('done', 'cancel'))
         moves_ids_todo = OrderedSet()
 
         # Cancel moves where necessary ; we should do it before creating the extra moves because
         # this operation could trigger a merge of moves.
         for move in moves:
-            if move.quantity_done <= 0 and not move.is_inventory:
+            if (move.quantity <= 0 or not move.picked) and not move.is_inventory:
                 if float_compare(move.product_uom_qty, 0.0, precision_rounding=move.product_uom.rounding) == 0 or cancel_backorder:
                     move._action_cancel()
 
         # Create extra moves where necessary
         for move in moves:
-            if move.state == 'cancel' or (move.quantity_done <= 0 and not move.is_inventory):
+            if move.state == 'cancel' or (move.quantity <= 0 and not move.is_inventory):
+                continue
+            if not move.picked:
                 continue
-
             moves_ids_todo |= move._create_extra_move().ids
 
         moves_todo = self.browse(moves_ids_todo)
@@ -1870,9 +1792,9 @@ Please change the quantity done or the rounding precision of your unit of measur
                 # To know whether we need to create a backorder or not, round to the general product's
                 # decimal precision and not the product's UOM.
                 rounding = self.env['decimal.precision'].precision_get('Product Unit of Measure')
-                if float_compare(move.quantity_done, move.product_uom_qty, precision_digits=rounding) < 0:
+                if float_compare(move.quantity, move.product_uom_qty, precision_digits=rounding) < 0:
                     # Need to do some kind of conversion here
-                    qty_split = move.product_uom._compute_quantity(move.product_uom_qty - move.quantity_done, move.product_id.uom_id, rounding_method='HALF-UP')
+                    qty_split = move.product_uom._compute_quantity(move.product_uom_qty - move.quantity, move.product_id.uom_id, rounding_method='HALF-UP')
                     new_move_vals = move._split(qty_split)
                     backorder_moves_vals += new_move_vals
             backorder_moves = self.env['stock.move'].create(backorder_moves_vals)
@@ -1883,7 +1805,7 @@ Please change the quantity done or the rounding precision of your unit of measur
         # Check the consistency of the result packages; there should be an unique location across
         # the contained quants.
         for result_package in moves_todo\
-                .mapped('move_line_ids.result_package_id')\
+                .move_line_ids.filtered(lambda ml: ml.picked).mapped('result_package_id')\
                 .filtered(lambda p: p.quant_ids and len(p.quant_ids) > 1):
             if len(result_package.quant_ids.filtered(lambda q: not float_is_zero(abs(q.quantity) + abs(q.reserved_quantity), precision_rounding=q.product_uom_id.rounding)).mapped('location_id')) > 1:
                 raise UserError(_('You cannot move the same package content more than once in the same transfer or split the same package into two location.'))
@@ -1892,9 +1814,6 @@ Please change the quantity done or the rounding precision of your unit of measur
         picking = moves_todo.mapped('picking_id')
         moves_todo.write({'state': 'done', 'date': fields.Datetime.now()})
 
-        new_push_moves = moves_todo.filtered(lambda m: m.picking_id.immediate_transfer)._push_apply()
-        if new_push_moves:
-            new_push_moves._action_confirm()
         move_dests_per_company = defaultdict(lambda: self.env['stock.move'])
 
         # Break move dest link if move dest and move_dest source are not the same,
@@ -1914,7 +1833,7 @@ Please change the quantity done or the rounding precision of your unit of measur
         if picking and not cancel_backorder:
             backorder = picking._create_backorder()
             if any([m.state == 'assigned' for m in backorder.move_ids]):
-               backorder._check_entire_pack()
+                backorder._check_entire_pack()
         return moves_todo
 
     @api.ondelete(at_uninstall=False)
@@ -1954,8 +1873,8 @@ Please change the quantity done or the rounding precision of your unit of measur
             # we restrict the split of a draft move because if not confirmed yet, it may be replaced by several other moves in
             # case of phantom bom (with mrp module). And we don't want to deal with this complexity by copying the product that will explode.
             raise UserError(_('You cannot split a draft move. It needs to be confirmed first.'))
-        # exclude immediate transfer in case we want to add a move line in a wave picking
-        if float_is_zero(qty, precision_rounding=self.product_id.uom_id.rounding) or self.product_qty <= qty and not self.from_immediate_transfer:
+
+        if float_is_zero(qty, precision_rounding=self.product_id.uom_id.rounding):
             return []
 
         decimal_precision = self.env['decimal.precision'].precision_get('Product Unit of Measure')
@@ -1990,11 +1909,11 @@ Please change the quantity done or the rounding precision of your unit of measur
         moves_state_to_write = defaultdict(set)
         for move in self:
             rounding = move.product_uom.rounding
-            if move.state in ('cancel', 'done', 'draft'):
+            if move.state in ('cancel', 'done'):
                 continue
-            elif float_compare(move.reserved_availability, move.product_uom_qty, precision_rounding=rounding) >= 0:
+            elif float_compare(move.quantity, move.product_uom_qty, precision_rounding=rounding) >= 0:
                 moves_state_to_write['assigned'].add(move.id)
-            elif move.reserved_availability and float_compare(move.reserved_availability, move.product_uom_qty, precision_rounding=rounding) <= 0:
+            elif move.quantity and float_compare(move.quantity, move.product_uom_qty, precision_rounding=rounding) <= 0:
                 moves_state_to_write['partially_available'].add(move.id)
             elif move.procure_method == 'make_to_order' and not move.move_orig_ids:
                 moves_state_to_write['waiting'].add(move.id)
@@ -2037,7 +1956,10 @@ Please change the quantity done or the rounding precision of your unit of measur
     def _set_quantity_done_prepare_vals(self, qty):
         res = []
         for ml in self.move_line_ids:
-            ml_qty = ml.reserved_uom_qty - ml.qty_done
+            ml_qty = ml.quantity
+            if float_is_zero(qty, precision_rounding=self.product_uom.rounding):
+                res.append((2, ml.id))
+                continue
             if float_compare(ml_qty, 0, precision_rounding=ml.product_uom_id.rounding) <= 0:
                 continue
             # Convert move line qty into move uom
@@ -2052,28 +1974,21 @@ Please change the quantity done or the rounding precision of your unit of measur
             # Assign qty_done and explicitly round to make sure there is no inconsistency between
             # ml.qty_done and qty.
             taken_qty = float_round(taken_qty, precision_rounding=ml.product_uom_id.rounding)
-            res.append((1, ml.id, {'qty_done': ml.qty_done + taken_qty}))
+            res.append((1, ml.id, {'quantity': taken_qty}))
             if ml.product_uom_id != self.product_uom:
                 taken_qty = ml.product_uom_id._compute_quantity(ml_qty, self.product_uom, round=False)
             qty -= taken_qty
 
-            if float_compare(qty, 0.0, precision_rounding=self.product_uom.rounding) <= 0:
-                break
-
-        for ml in self.move_line_ids:
-            if float_is_zero(ml.reserved_uom_qty, precision_rounding=ml.product_uom_id.rounding) and float_is_zero(ml.qty_done, precision_rounding=ml.product_uom_id.rounding):
-                res.append((2, ml.id))
-
         if float_compare(qty, 0.0, precision_rounding=self.product_uom.rounding) > 0:
             if self.product_id.tracking != 'serial':
                 vals = self._prepare_move_line_vals(quantity=0)
-                vals['qty_done'] = qty
+                vals['quantity'] = qty
                 res.append((0, 0, vals))
             else:
                 uom_qty = self.product_uom._compute_quantity(qty, self.product_id.uom_id)
                 for i in range(0, int(uom_qty)):
                     vals = self._prepare_move_line_vals(quantity=0)
-                    vals['qty_done'] = 1
+                    vals['quantity'] = 1
                     vals['product_uom_id'] = self.product_id.uom_id.id
                     res.append((0, 0, vals))
         return res
@@ -2091,20 +2006,6 @@ Please change the quantity done or the rounding precision of your unit of measur
         # These new SMLs need to be redirected thanks to putaway rules
         (self.move_line_ids - existing_smls)._apply_putaway_strategy()
 
-    def _set_quantities_to_reservation(self):
-        for move in self:
-            if move.state not in ('partially_available', 'assigned'):
-                continue
-            for move_line in move.move_line_ids:
-                if move.has_tracking == 'none' or\
-                    (move.picking_type_id.use_existing_lots and move_line.lot_id) or\
-                    (move.picking_type_id.use_create_lots and move_line.lot_name) or\
-                    (not move.picking_type_id.use_existing_lots and not move.picking_type_id.use_create_lots):
-                    move_line.qty_done = move_line.reserved_uom_qty
-
-    def _clear_quantities_to_zero(self):
-        self.filtered(lambda m: m.state in ('partially_available', 'assigned')).move_line_ids.qty_done = 0
-
     def _adjust_procure_method(self):
         """ This method will try to apply the procure method MTO on some moves if
         a compatible MTO route is found. Else the procure method will be set to MTS
@@ -2290,7 +2191,7 @@ Please change the quantity done or the rounding precision of your unit of measur
             product_rounding = product.uom_id.rounding
             for out in reserved_outs_per_product.get(product, []):
                 # Reconcile with reserved stock.
-                reserved = out.product_uom._compute_quantity(out.reserved_availability, product.uom_id)
+                reserved = out.product_uom._compute_quantity(out.quantity, product.uom_id)
                 currents[product.id] -= reserved
                 if out.id in ids_in_self:
                     result[out] = (result[out][0] + reserved, False)
@@ -2300,7 +2201,7 @@ Please change the quantity done or the rounding precision of your unit of measur
                 # Reconcile with the current stock.
                 reserved = 0.0
                 if out.state in ('partially_available', 'assigned'):
-                    reserved = out.product_uom._compute_quantity(out.reserved_availability, product.uom_id)
+                    reserved = out.product_uom._compute_quantity(out.quantity, product.uom_id)
                 demand = out.product_qty - reserved
 
                 if float_is_zero(demand, precision_rounding=product_rounding):
@@ -2349,5 +2250,5 @@ Please change the quantity done or the rounding precision of your unit of measur
     def _convert_string_into_field_data(self, string, options):
         string = string.replace(',', '.')  # Parsing string as float works only with dot, not comma.
         if regex_findall(r'^([0-9]+\.?[0-9]*|\.[0-9]+)$', string):  # Number => Quantity.
-            return {'qty_done': float(string)}
+            return {'quantity': float(string)}
         return False

--- a/addons/stock/models/stock_move_line.py
+++ b/addons/stock/models/stock_move_line.py
@@ -32,14 +32,13 @@ class StockMoveLine(models.Model):
     )
     product_uom_category_id = fields.Many2one(related='product_id.uom_id.category_id')
     product_category_name = fields.Char(related="product_id.categ_id.complete_name", store=True, string="Product Category")
-    reserved_qty = fields.Float(
-        'Real Reserved Quantity', digits=0, copy=False,
-        compute='_compute_reserved_qty', inverse='_set_reserved_qty', store=True)
-    reserved_uom_qty = fields.Float(
-        'Reserved', default=0.0, digits='Product Unit of Measure',
-        required=True, copy=False, compute='_compute_qty_reserved', store=True, readonly=False)
-    qty_done = fields.Float('Done', digits='Product Unit of Measure', copy=False,
-        compute='_compute_qty_done', store=True, readonly=False)
+    quantity = fields.Float(
+        'Quantity', digits='Product Unit of Measure', copy=False, store=True,
+        compute='_compute_quantity', readonly=False)
+    quantity_product_uom = fields.Float(
+        'Quantity in Product UoM', digits='Product Unit of Measure',
+        copy=False, compute='_compute_quantity_product_uom', store=True)
+    picked = fields.Boolean('Picked', compute='_compute_picked', store=True, readonly=False, copy=False)
     package_id = fields.Many2one(
         'stock.quant.package', 'Source Package', ondelete='restrict',
         check_company=True,
@@ -75,7 +74,6 @@ class StockMoveLine(models.Model):
     picking_type_use_existing_lots = fields.Boolean(related='picking_type_id.use_existing_lots', readonly=True)
     picking_type_entire_packs = fields.Boolean(related='picking_id.picking_type_id.show_entire_packs', readonly=True)
     state = fields.Selection(related='move_id.state', store=True, related_sudo=False)
-    is_initial_demand_editable = fields.Boolean(related='move_id.is_initial_demand_editable')
     is_inventory = fields.Boolean(related='move_id.is_inventory')
     is_locked = fields.Boolean(related='move_id.is_locked', readonly=True)
     consume_line_ids = fields.Many2many('stock.move.line', 'stock_move_line_consume_rel', 'consume_line_id', 'produce_line_id')
@@ -85,12 +83,7 @@ class StockMoveLine(models.Model):
     origin = fields.Char(related='move_id.origin', string='Source')
     description_picking = fields.Text(string="Description picking")
     quant_id = fields.Many2one('stock.quant', "Pick From", store=False)  # Dummy field for the detailed operation view
-    product_packaging_qty = fields.Float(
-            string="Reserved Packaging Quantity",
-            compute='_compute_product_packaging_qty')
-    product_packaging_qty_done = fields.Float(
-            string="Done Packaging Quantity",
-            compute='_compute_product_packaging_qty_done')
+    product_packaging_qty = fields.Float(string="Reserved Packaging Quantity", compute='_compute_product_packaging_qty')
 
     @api.depends('product_uom_id.category_id', 'product_id.uom_id.category_id', 'move_id.product_uom', 'product_id.uom_id')
     def _compute_product_uom_id(self):
@@ -110,6 +103,12 @@ class StockMoveLine(models.Model):
             else:
                 line.lots_visible = line.product_id.tracking != 'none'
 
+    @api.depends('state')
+    def _compute_picked(self):
+        for line in self:
+            if line.move_id.state == 'done':
+                line.picked = True
+
     @api.depends('picking_id')
     def _compute_picking_type_id(self):
         self.picking_type_id = False
@@ -125,55 +124,31 @@ class StockMoveLine(models.Model):
             if not line.location_dest_id:
                 line.location_dest_id = line.move_id.location_dest_id or line.picking_id.location_dest_id
 
-    @api.depends('move_id.product_packaging_id', 'product_uom_id', 'reserved_qty')
+    @api.depends('move_id.product_packaging_id', 'product_uom_id', 'quantity')
     def _compute_product_packaging_qty(self):
         self.product_packaging_qty = 0
         for line in self:
             if not line.move_id.product_packaging_id:
                 continue
-            line.product_packaging_qty = line.move_id.product_packaging_id._compute_qty(line.reserved_qty)
-
-    @api.depends('move_id.product_packaging_id', 'product_uom_id', 'qty_done')
-    def _compute_product_packaging_qty_done(self):
-        self.product_packaging_qty_done = 0
-        for line in self:
-            if not line.move_id.product_packaging_id:
-                continue
-            line.product_packaging_qty_done = line.move_id.product_packaging_id._compute_qty(line.qty_done, line.product_uom_id)
+            line.product_packaging_qty = line.move_id.product_packaging_id._compute_qty(line.quantity, line.product_uom_id)
 
     def _search_picking_type_id(self, operator, value):
         return [('picking_id.picking_type_id', operator, value)]
 
-    @api.depends('product_id', 'product_uom_id', 'reserved_uom_qty')
-    def _compute_reserved_qty(self):
-        for line in self:
-            line.reserved_qty = line.product_uom_id._compute_quantity(line.reserved_uom_qty, line.product_id.uom_id, rounding_method='HALF-UP')
-
-    def _set_reserved_qty(self):
-        """ The meaning of reserved_qty field changed lately and is now a functional field computing the quantity
-        in the default product UoM. This code has been added to raise an error if a write is made given a value
-        for `reserved_qty`, where the same write should set the `reserved_uom_qty` field instead, in order to
-        detect errors. """
-        raise UserError(_('The requested operation cannot be processed because of a programming error setting the `reserved_qty` field instead of the `reserved_uom_qty`.'))
-
-    @api.depends('quant_id')
-    def _compute_qty_done(self):
-        for record in self:
-            if not record.qty_done:
-                if (record.move_id.product_qty - record.move_id.quantity_done):
-                    record.qty_done = max(0, min(record.quant_id.available_quantity, record.move_id.product_qty - record.move_id.quantity_done))
-                else:
-                    record.qty_done = max(0, record.quant_id.available_quantity)
-
     @api.depends('quant_id')
-    def _compute_qty_reserved(self):
+    def _compute_quantity(self):
         for record in self:
-            if not record.reserved_uom_qty:
-                if (record.move_id.product_qty - record.move_id.quantity_done):
-                    record.reserved_uom_qty = max(0, min(record.quant_id.available_quantity, record.move_id.product_qty - record.move_id.quantity_done))
-                else:
-                    record.reserved_uom_qty = max(0, record.quant_id.available_quantity)
+            if not record.quant_id or record.quantity:
+                continue
+            if float_compare(record.move_id.product_qty, record.move_id.quantity, record.move_id.product_uom.rounding) > 0:
+                record.quantity = max(0, min(record.quant_id.available_quantity, record.move_id.product_qty - record.move_id.quantity))
+            else:
+                record.quantity = max(0, record.quant_id.available_quantity)
 
+    @api.depends('quantity', 'product_uom_id')
+    def _compute_quantity_product_uom(self):
+        for line in self:
+            line.quantity_product_uom = line.product_uom_id._compute_quantity(line.quantity, line.product_id.uom_id, rounding_method='HALF-UP')
 
     @api.constrains('lot_id', 'product_id')
     def _check_lot_product(self):
@@ -185,15 +160,9 @@ class StockMoveLine(models.Model):
                     product_name=line.product_id.display_name
                 ))
 
-    @api.constrains('reserved_uom_qty')
-    def _check_reserved_done_quantity(self):
-        for move_line in self:
-            if move_line.state == 'done' and not float_is_zero(move_line.reserved_uom_qty, precision_digits=self.env['decimal.precision'].precision_get('Product Unit of Measure')):
-                raise ValidationError(_('A done move line should never have a reserved quantity.'))
-
-    @api.constrains('qty_done')
-    def _check_positive_qty_done(self):
-        if any(ml.qty_done < 0 for ml in self):
+    @api.constrains('quantity')
+    def _check_positive_quantity(self):
+        if any(ml.quantity < 0 for ml in self):
             raise ValidationError(_('You can not enter negative quantities.'))
 
     @api.onchange('product_id', 'product_uom_id')
@@ -208,14 +177,14 @@ class StockMoveLine(models.Model):
     def _onchange_serial_number(self):
         """ When the user is encoding a move line for a tracked product, we apply some logic to
         help him. This includes:
-            - automatically switch `qty_done` to 1.0
+            - automatically switch `quantity` to 1.0
             - warn if he has already encoded `lot_name` in another move line
             - warn (and update if appropriate) if the SN is in a different source location than selected
         """
         res = {}
         if self.product_id.tracking == 'serial':
-            if not self.qty_done:
-                self.qty_done = 1
+            if not self.quantity:
+                self.quantity = 1
 
             message = None
             if self.lot_name or self.lot_id:
@@ -226,8 +195,8 @@ class StockMoveLine(models.Model):
                         message = _('You cannot use the same serial number twice. Please correct the serial numbers encoded.')
                     elif not self.lot_id:
                         lots = self.env['stock.lot'].search([('product_id', '=', self.product_id.id),
-                                                                        ('name', '=', self.lot_name),
-                                                                        ('company_id', '=', self.company_id.id)])
+                                                             ('name', '=', self.lot_name),
+                                                             ('company_id', '=', self.company_id.id)])
                         quants = lots.quant_ids.filtered(lambda q: q.quantity != 0 and q.location_id.usage in ['customer', 'internal', 'transit'])
                         if quants:
                             message = _('Serial number (%s) already exists in location(s): %s. Please correct the serial number encoded.', self.lot_name, ', '.join(quants.location_id.mapped('display_name')))
@@ -237,37 +206,33 @@ class StockMoveLine(models.Model):
                         message = _('You cannot use the same serial number twice. Please correct the serial numbers encoded.')
                     else:
                         # check if in correct source location
-                        message, recommended_location = self.env['stock.quant'].sudo()._check_serial_number(self.product_id,
-                                                                                                     self.lot_id,
-                                                                                                     self.company_id,
-                                                                                                     self.location_id,
-                                                                                                     self.picking_id.location_id)
+                        message, recommended_location = self.env['stock.quant'].sudo()._check_serial_number(
+                            self.product_id, self.lot_id, self.company_id, self.location_id, self.picking_id.location_id)
                         if recommended_location:
                             self.location_id = recommended_location
             if message:
                 res['warning'] = {'title': _('Warning'), 'message': message}
         return res
 
-    @api.onchange('qty_done', 'product_uom_id')
-    def _onchange_qty_done(self):
+    @api.onchange('quantity', 'product_uom_id')
+    def _onchange_quantity(self):
         """ When the user is encoding a move line for a tracked product, we apply some logic to
-        help him. This onchange will warn him if he set `qty_done` to a non-supported value.
+        help him. This onchange will warn him if he set `quantity` to a non-supported value.
         """
         res = {}
-        if self.qty_done and self.product_id.tracking == 'serial':
-            qty_done = self.product_uom_id._compute_quantity(self.qty_done, self.product_id.uom_id)
-            if float_compare(qty_done, 1.0, precision_rounding=self.product_id.uom_id.rounding) != 0:
+        if self.quantity and self.product_id.tracking == 'serial':
+            if float_compare(self.quantity_product_uom, 1.0, precision_rounding=self.product_id.uom_id.rounding) != 0:
                 message = _('You can only process 1.0 %s of products with unique serial number.', self.product_id.uom_id.name)
                 res['warning'] = {'title': _('Warning'), 'message': message}
         return res
 
-    @api.onchange('result_package_id', 'product_id', 'product_uom_id', 'qty_done')
+    @api.onchange('result_package_id', 'product_id', 'product_uom_id', 'quantity')
     def _onchange_putaway_location(self):
-        if not self.id and self.user_has_groups('stock.group_stock_multi_locations') and self.product_id and self.qty_done:
-            qty_done = self.product_uom_id._compute_quantity(self.qty_done, self.product_id.uom_id)
+        if not self.id and self.user_has_groups('stock.group_stock_multi_locations') and self.product_id and self.quantity_product_uom:
             default_dest_location = self._get_default_dest_location()
+            quantity = self.quantity_product_uom
             self.location_dest_id = default_dest_location.with_context(exclude_sml_ids=self.ids)._get_putaway_strategy(
-                self.product_id, quantity=qty_done, package=self.result_package_id,
+                self.product_id, quantity=quantity, package=self.result_package_id,
                 packaging=self.move_id.product_packaging_id)
 
     def _apply_putaway_strategy(self):
@@ -285,7 +250,7 @@ class StockMoveLine(models.Model):
                 for sml in smls:
                     if len(used_locations) > 1:
                         break
-                    sml.location_dest_id = sml.move_id.location_dest_id.with_context(exclude_sml_ids=excluded_smls.ids)._get_putaway_strategy(sml.product_id, quantity=sml.reserved_uom_qty)
+                    sml.location_dest_id = sml.move_id.location_dest_id.with_context(exclude_sml_ids=excluded_smls.ids)._get_putaway_strategy(sml.product_id, quantity=sml.quantity)
                     excluded_smls -= sml
                     used_locations.add(sml.location_dest_id)
                 if len(used_locations) > 1:
@@ -294,9 +259,8 @@ class StockMoveLine(models.Model):
                     smls.package_level_id.location_dest_id = smls.location_dest_id
             else:
                 for sml in smls:
-                    qty = max(sml.reserved_uom_qty, sml.qty_done)
                     putaway_loc_id = sml.move_id.location_dest_id.with_context(exclude_sml_ids=excluded_smls.ids)._get_putaway_strategy(
-                        sml.product_id, quantity=qty, packaging=sml.move_id.product_packaging_id,
+                        sml.product_id, quantity=sml.quantity, packaging=sml.move_id.product_packaging_id,
                     )
                     if putaway_loc_id != sml.location_dest_id:
                         sml.location_dest_id = putaway_loc_id
@@ -312,7 +276,7 @@ class StockMoveLine(models.Model):
     def _get_putaway_additional_qty(self):
         addtional_qty = {}
         for ml in self._origin:
-            qty = max(ml.product_uom_id._compute_quantity(ml.qty_done, ml.product_id.uom_id), ml.reserved_uom_qty)
+            qty = ml.product_uom_id._compute_quantity(ml.quantity, ml.product_id.uom_id)
             addtional_qty[ml.location_dest_id.id] = addtional_qty.get(ml.location_dest_id.id, 0) - qty
         return addtional_qty
 
@@ -323,7 +287,7 @@ class StockMoveLine(models.Model):
                 ON
                     stock_move_line (id, company_id, product_id, lot_id, location_id, owner_id, package_id)
                 WHERE
-                    (state IS NULL OR state NOT IN ('cancel', 'done')) AND reserved_qty > 0""")
+                    (state IS NULL OR state NOT IN ('cancel', 'done')) AND quantity > 0 AND not picked""")
 
     @api.model_create_multi
     def create(self, vals_list):
@@ -332,6 +296,8 @@ class StockMoveLine(models.Model):
                 vals['company_id'] = self.env['stock.move'].browse(vals['move_id']).company_id.id
             elif vals.get('picking_id'):
                 vals['company_id'] = self.env['stock.picking'].browse(vals['picking_id']).company_id.id
+            if vals.get('move_id') and 'picked' not in vals:
+                vals['picked'] = self.env['stock.move'].browse(vals['move_id']).picked
             if vals.get('quant_id'):
                 vals.update(self._copy_quant_info(vals))
 
@@ -349,7 +315,7 @@ class StockMoveLine(models.Model):
                 continue
             if move_line.picking_id.state != 'done':
                 moves = move_line.picking_id.move_ids.filtered(lambda x: x.product_id == move_line.product_id)
-                moves = sorted(moves, key=lambda m: m.quantity_done < m.product_qty, reverse=True)
+                moves = sorted(moves, key=lambda m: m.quantity < m.product_qty, reverse=True)
                 if moves:
                     move_line.write({
                         'move_id': moves[0].id,
@@ -362,42 +328,26 @@ class StockMoveLine(models.Model):
 
         move_to_recompute_state = self.env['stock.move']
         for move_line in mls:
-            reserved_uom_qty = move_line.reserved_uom_qty
             location = move_line.location_id
             product = move_line.product_id
             move = move_line.move_id
             if move:
-                bypass_reservation = not move._should_bypass_reservation()
+                reservation = not move._should_bypass_reservation()
             else:
-                bypass_reservation = product.type == 'product' and not location.should_bypass_reservation()
-            if reserved_uom_qty and not self.env.context.get('bypass_reservation_update') and bypass_reservation:
-                ml_uom = move_line.product_uom_id
-
-                reserved_qty = ml_uom._compute_quantity(reserved_uom_qty, product.uom_id, rounding_method='HALF-UP')
-                reserved_quants = self.env.context.get('reserved_quant', self.env['stock.quant'])._update_reserved_quantity(
-                    product, location, reserved_qty, lot_id=move_line.lot_id, package_id=move_line.package_id, owner_id=move_line.owner_id, strict=True)
+                reservation = product.type == 'product' and not location.should_bypass_reservation()
+            if move_line.quantity and reservation:
+                self.env.context.get('reserved_quant', self.env['stock.quant'])._update_reserved_quantity(
+                    product, location, move_line.quantity_product_uom, lot_id=move_line.lot_id, package_id=move_line.package_id, owner_id=move_line.owner_id)
 
-                if not reserved_quants or float_compare(reserved_qty, sum(map(lambda q: q[1], reserved_quants)), product.uom_id.rounding) != 0:
-                    reserved_uom_qty = product.uom_id._compute_quantity(reserved_qty, ml_uom, rounding_method='HALF-UP')
-                    move_line.with_context(bypass_reservation=True).reserved_uom_qty = reserved_uom_qty
                 if move:
                     move_to_recompute_state |= move
         move_to_recompute_state._recompute_state()
 
-        moves_to_update = mls.filtered(
-            lambda ml:
-            ml.move_id and
-            ml.qty_done and
-            ml.move_id.state == 'done'
-        ).move_id
-        for move in moves_to_update:
-            move.with_context(avoid_putaway_rules=True).product_uom_qty = move.quantity_done
-
         for ml, vals in zip(mls, vals_list):
             if ml.state == 'done':
-                if ml.product_id.type == 'product' and not self.env.context.get('bypass_reservation_update'):
+                if ml.product_id.type == 'product':
                     Quant = self.env['stock.quant']
-                    quantity = ml.product_uom_id._compute_quantity(ml.qty_done, ml.move_id.product_id.uom_id,rounding_method='HALF-UP')
+                    quantity = ml.product_uom_id._compute_quantity(ml.quantity, ml.move_id.product_id.uom_id, rounding_method='HALF-UP')
                     in_date = None
                     available_qty, in_date = Quant._update_available_quantity(ml.product_id, ml.location_id, -quantity, lot_id=ml.lot_id, package_id=ml.package_id, owner_id=ml.owner_id)
                     if available_qty < 0 and ml.lot_id:
@@ -414,16 +364,10 @@ class StockMoveLine(models.Model):
         return mls
 
     def write(self, vals):
-        # Very dangerous key. It could create some desynchronization between `stock.move.line` and `stock.quant`.
-        # It exists for performances purposes. Only use it if you handle `stock.quant` reservation manualy.
-        if self.env.context.get('bypass_reservation_update'):
-            return super().write(vals)
         if 'product_id' in vals and any(vals.get('state', ml.state) != 'draft' and vals['product_id'] != ml.product_id.id for ml in self):
             raise UserError(_("Changing the product is only allowed in 'Draft' state."))
 
         moves_to_recompute_state = self.env['stock.move']
-        Quant = self.env['stock.quant']
-        precision = self.env['decimal.precision'].precision_get('Product Unit of Measure')
         triggers = [
             ('location_id', 'stock.location'),
             ('location_dest_id', 'stock.location'),
@@ -451,84 +395,50 @@ class StockMoveLine(models.Model):
                     # Only need to unlink the package level if it's empty. Otherwise will unlink it to still valid move lines.
                     if not package_level.move_line_ids:
                         package_level.unlink()
-
         # When we try to write on a reserved move line any fields from `triggers` or directly
         # `reserved_uom_qty` (the actual reserved quantity), we need to make sure the associated
         # quants are correctly updated in order to not make them out of sync (i.e. the sum of the
         # move lines `reserved_uom_qty` should always be equal to the sum of `reserved_quantity` on
         # the quants). If the new charateristics are not available on the quants, we chose to
         # reserve the maximum possible.
-        if updates or 'reserved_uom_qty' in vals:
+        if updates or 'quantity' in vals:
             for ml in self:
-                if ml.product_id.type != 'product':
+                if ml.product_id.type != 'product' or ml.state == 'done':
                     continue
-                if 'reserved_uom_qty' in vals:
+                if 'quantity' in vals:
                     new_reserved_qty = ml.product_uom_id._compute_quantity(
-                        vals['reserved_uom_qty'], ml.product_id.uom_id, rounding_method='HALF-UP')
+                        vals['quantity'], ml.product_id.uom_id, rounding_method='HALF-UP')
                     # Make sure `reserved_uom_qty` is not negative.
                     if float_compare(new_reserved_qty, 0, precision_rounding=ml.product_id.uom_id.rounding) < 0:
                         raise UserError(_('Reserving a negative quantity is not allowed.'))
                 else:
-                    new_reserved_qty = ml.reserved_qty
+                    new_reserved_qty = ml.quantity_product_uom
 
                 # Unreserve the old charateristics of the move line.
-                if not float_is_zero(ml.reserved_qty, precision_rounding=ml.product_uom_id.rounding):
-                    if not ml.move_id._should_bypass_reservation(ml.location_id):
-                        Quant._update_reserved_quantity(ml.product_id, ml.location_id, -ml.reserved_qty, lot_id=ml.lot_id, package_id=ml.package_id, owner_id=ml.owner_id, strict=True)
+                if not float_is_zero(ml.quantity_product_uom, precision_rounding=ml.product_uom_id.rounding):
+                    ml._synchronize_quant(-ml.quantity_product_uom, ml.location_id, action="reserved")
 
                 # Reserve the maximum available of the new charateristics of the move line.
-                reserved_qty = new_reserved_qty
                 if not ml.move_id._should_bypass_reservation(updates.get('location_id', ml.location_id)):
-                    q = Quant._update_reserved_quantity(ml.product_id, updates.get('location_id', ml.location_id), new_reserved_qty, lot_id=updates.get('lot_id', ml.lot_id),
-                                                        package_id=updates.get('package_id', ml.package_id), owner_id=updates.get('owner_id', ml.owner_id), strict=True)
-                    reserved_qty = sum([x[1] for x in q])
+                    ml._synchronize_quant(
+                        new_reserved_qty, updates.get('location_id', ml.location_id), action="reserved",
+                        lot=updates.get('lot_id', ml.lot_id), package=updates.get('package_id', ml.package_id),
+                        owner=updates.get('owner_id', ml.owner_id))
 
-                if reserved_qty != new_reserved_qty:
-                    reserved_uom_qty = ml.product_id.uom_id._compute_quantity(reserved_qty, ml.product_uom_id, rounding_method='HALF-UP')
-                    vals['reserved_uom_qty'] = reserved_uom_qty
-
-                if 'reserved_uom_qty' in vals and vals['reserved_uom_qty'] != ml.reserved_uom_qty:
+                if 'quantity' in vals and vals['quantity'] != ml.quantity:
                     moves_to_recompute_state |= ml.move_id
 
         # When editing a done move line, the reserved availability of a potential chained move is impacted. Take care of running again `_action_assign` on the concerned moves.
-        if updates or 'qty_done' in vals:
+        mls = self.env['stock.move.line']
+        if updates or 'quantity' in vals:
             next_moves = self.env['stock.move']
             mls = self.filtered(lambda ml: ml.move_id.state == 'done' and ml.product_id.type == 'product')
-            if not updates:  # we can skip those where qty_done is already good up to UoM rounding
-                mls = mls.filtered(lambda ml: not float_is_zero(ml.qty_done - vals['qty_done'], precision_rounding=ml.product_uom_id.rounding))
+            if not updates:  # we can skip those where quantity is already good up to UoM rounding
+                mls = mls.filtered(lambda ml: not float_is_zero(ml.quantity - vals['quantity'], precision_rounding=ml.product_uom_id.rounding))
             for ml in mls:
                 # undo the original move line
-                qty_done_orig = ml.product_uom_id._compute_quantity(ml.qty_done, ml.move_id.product_id.uom_id, rounding_method='HALF-UP')
-                in_date = Quant._update_available_quantity(ml.product_id, ml.location_dest_id, -qty_done_orig, lot_id=ml.lot_id,
-                                                      package_id=ml.result_package_id, owner_id=ml.owner_id)[1]
-                Quant._update_available_quantity(ml.product_id, ml.location_id, qty_done_orig, lot_id=ml.lot_id,
-                                                      package_id=ml.package_id, owner_id=ml.owner_id, in_date=in_date)
-
-                # move what's been actually done
-                product_id = ml.product_id
-                location_id = updates.get('location_id', ml.location_id)
-                location_dest_id = updates.get('location_dest_id', ml.location_dest_id)
-                qty_done = vals.get('qty_done', ml.qty_done)
-                lot_id = updates.get('lot_id', ml.lot_id)
-                package_id = updates.get('package_id', ml.package_id)
-                result_package_id = updates.get('result_package_id', ml.result_package_id)
-                owner_id = updates.get('owner_id', ml.owner_id)
-                product_uom_id = updates.get('product_uom_id', ml.product_uom_id)
-                quantity = product_uom_id._compute_quantity(qty_done, ml.move_id.product_id.uom_id, rounding_method='HALF-UP')
-                if not ml.move_id._should_bypass_reservation(location_id):
-                    ml._free_reservation(product_id, location_id, quantity, lot_id=lot_id, package_id=package_id, owner_id=owner_id)
-                if not float_is_zero(quantity, precision_digits=precision):
-                    available_qty, in_date = Quant._update_available_quantity(product_id, location_id, -quantity, lot_id=lot_id, package_id=package_id, owner_id=owner_id)
-                    if available_qty < 0 and lot_id:
-                        # see if we can compensate the negative quants with some untracked quants
-                        untracked_qty = Quant._get_available_quantity(product_id, location_id, lot_id=False, package_id=package_id, owner_id=owner_id, strict=True)
-                        if untracked_qty:
-                            taken_from_untracked_qty = min(untracked_qty, abs(available_qty))
-                            Quant._update_available_quantity(product_id, location_id, -taken_from_untracked_qty, lot_id=False, package_id=package_id, owner_id=owner_id)
-                            Quant._update_available_quantity(product_id, location_id, taken_from_untracked_qty, lot_id=lot_id, package_id=package_id, owner_id=owner_id)
-                            if not ml.move_id._should_bypass_reservation(location_id):
-                                ml._free_reservation(ml.product_id, location_id, untracked_qty, lot_id=False, package_id=package_id, owner_id=owner_id)
-                    Quant._update_available_quantity(product_id, location_dest_id, quantity, lot_id=lot_id, package_id=result_package_id, owner_id=owner_id, in_date=in_date)
+                in_date = ml._synchronize_quant(-ml.quantity_product_uom, ml.location_dest_id, package=ml.result_package_id)[1]
+                ml._synchronize_quant(ml.quantity_product_uom, ml.location_id, in_date=in_date)
 
                 # Unreserve and reserve following move in order to have the real reserved quantity on move_line.
                 next_moves |= ml.move_id.move_dest_ids.filtered(lambda move: move.state not in ('done', 'cancel'))
@@ -539,13 +449,19 @@ class StockMoveLine(models.Model):
 
         res = super(StockMoveLine, self).write(vals)
 
+        for ml in mls:
+            available_qty, dummy = ml._synchronize_quant(-ml.quantity_product_uom, ml.location_id)
+            ml._synchronize_quant(ml.quantity_product_uom, ml.location_dest_id, package=ml.result_package_id)
+            if available_qty < 0:
+                ml._free_reservation(
+                    ml.product_id, ml.location_id,
+                    abs(available_qty), lot_id=ml.lot_id, package_id=ml.package_id,
+                    owner_id=ml.owner_id)
+
         # As stock_account values according to a move's `product_uom_qty`, we consider that any
         # done stock move should have its `quantity_done` equals to its `product_uom_qty`, and
         # this is what move's `action_done` will do. So, we replicate the behavior here.
-        if updates or 'qty_done' in vals:
-            moves = self.filtered(lambda ml: ml.move_id.state == 'done').mapped('move_id')
-            for move in moves:
-                move.product_uom_qty = move.quantity_done
+        if updates or 'quantity' in vals:
             next_moves._do_unreserve()
             next_moves._action_assign()
 
@@ -565,11 +481,11 @@ class StockMoveLine(models.Model):
         quants_by_product = self.env['stock.quant']._get_quants_by_products_locations(self.product_id, self.location_id)
         for ml in self:
             # Unlinking a move line should unreserve.
-            if not float_is_zero(ml.reserved_qty, precision_digits=precision) and ml.move_id and not ml.move_id._should_bypass_reservation(ml.location_id):
+            if not float_is_zero(ml.quantity, precision_digits=precision) and ml.move_id and not ml.move_id._should_bypass_reservation(ml.location_id):
                 quants = quants_by_product[ml.product_id.id]
-                quants._update_reserved_quantity(ml.product_id, ml.location_id, -ml.reserved_qty, lot_id=ml.lot_id, package_id=ml.package_id, owner_id=ml.owner_id, strict=True)
+                quants._update_reserved_quantity(ml.product_id, ml.location_id, -ml.quantity, lot_id=ml.lot_id, package_id=ml.package_id, owner_id=ml.owner_id, strict=True)
         moves = self.mapped('move_id')
-        res = super(StockMoveLine, self).unlink()
+        res = super().unlink()
         if moves:
             # Add with_prefetch() to set the _prefecht_ids = _ids
             # because _prefecht_ids generator look lazily on the cache of move_id
@@ -586,29 +502,28 @@ class StockMoveLine(models.Model):
         intended to be called when editing a `done` move (that's what the override of `write` here
         is done.
         """
-        Quant = self.env['stock.quant']
 
-        # First, we loop over all the move lines to do a preliminary check: `qty_done` should not
+        # First, we loop over all the move lines to do a preliminary check: `quantity` should not
         # be negative and, according to the presence of a picking type or a linked inventory
-        # adjustment, enforce some rules on the `lot_id` field. If `qty_done` is null, we unlink
+        # adjustment, enforce some rules on the `lot_id` field. If `quantity` is null, we unlink
         # the line. It is mandatory in order to free the reservation and correctly apply
         # `action_done` on the next move lines.
         ml_ids_tracked_without_lot = OrderedSet()
         ml_ids_to_delete = OrderedSet()
         ml_ids_to_create_lot = OrderedSet()
         for ml in self:
-            # Check here if `ml.qty_done` respects the rounding of `ml.product_uom_id`.
-            uom_qty = float_round(ml.qty_done, precision_rounding=ml.product_uom_id.rounding, rounding_method='HALF-UP')
+            # Check here if `ml.quantity` respects the rounding of `ml.product_uom_id`.
+            uom_qty = float_round(ml.quantity, precision_rounding=ml.product_uom_id.rounding, rounding_method='HALF-UP')
             precision_digits = self.env['decimal.precision'].precision_get('Product Unit of Measure')
-            qty_done = float_round(ml.qty_done, precision_digits=precision_digits, rounding_method='HALF-UP')
-            if float_compare(uom_qty, qty_done, precision_digits=precision_digits) != 0:
+            quantity = float_round(ml.quantity, precision_digits=precision_digits, rounding_method='HALF-UP')
+            if float_compare(uom_qty, quantity, precision_digits=precision_digits) != 0:
                 raise UserError(_('The quantity done for the product "%s" doesn\'t respect the rounding precision '
                                   'defined on the unit of measure "%s". Please change the quantity done or the '
                                   'rounding precision of your unit of measure.',
                                   ml.product_id.display_name, ml.product_uom_id.name))
 
-            qty_done_float_compared = float_compare(ml.qty_done, 0, precision_rounding=ml.product_uom_id.rounding)
-            if qty_done_float_compared > 0:
+            quantity_float_compared = float_compare(ml.quantity, 0, precision_rounding=ml.product_uom_id.rounding)
+            if quantity_float_compared > 0:
                 if ml.product_id.tracking != 'none':
                     picking_type_id = ml.move_id.picking_type_id
                     if picking_type_id:
@@ -638,7 +553,7 @@ class StockMoveLine(models.Model):
 
                     if not ml.lot_id and ml.id not in ml_ids_to_create_lot:
                         ml_ids_tracked_without_lot.add(ml.id)
-            elif qty_done_float_compared < 0:
+            elif quantity_float_compared < 0:
                 raise UserError(_('No negative quantities allowed'))
             elif not ml.is_inventory:
                 ml_ids_to_delete.add(ml.id)
@@ -648,7 +563,7 @@ class StockMoveLine(models.Model):
             raise UserError(_('You need to supply a Lot/Serial Number for product: \n - ') +
                               '\n - '.join(mls_tracked_without_lot.mapped('product_id.display_name')))
         ml_to_create_lot = self.env['stock.move.line'].browse(ml_ids_to_create_lot)
-        ml_to_create_lot.with_context(bypass_reservation_update=True)._create_and_assign_production_lot()
+        ml_to_create_lot._create_and_assign_production_lot()
 
         mls_to_delete = self.env['stock.move.line'].browse(ml_ids_to_delete)
         mls_to_delete.unlink()
@@ -658,34 +573,45 @@ class StockMoveLine(models.Model):
 
         # Now, we can actually move the quant.
         ml_ids_to_ignore = OrderedSet()
+
         for ml in mls_todo:
-            if ml.product_id.type == 'product':
-                rounding = ml.product_uom_id.rounding
-
-                # if this move line is force assigned, unreserve elsewhere if needed
-                if not ml.move_id._should_bypass_reservation(ml.location_id) and float_compare(ml.qty_done, ml.reserved_uom_qty, precision_rounding=rounding) > 0:
-                    qty_done_product_uom = ml.product_uom_id._compute_quantity(ml.qty_done, ml.product_id.uom_id, rounding_method='HALF-UP')
-                    extra_qty = qty_done_product_uom - ml.reserved_qty
-                    ml._free_reservation(ml.product_id, ml.location_id, extra_qty, lot_id=ml.lot_id, package_id=ml.package_id, owner_id=ml.owner_id, ml_ids_to_ignore=ml_ids_to_ignore)
-
-                # move what's been actually done
-                quantity = ml.product_uom_id._compute_quantity(ml.qty_done, ml.move_id.product_id.uom_id, rounding_method='HALF-UP')
-                available_qty, in_date = Quant._update_available_quantity(ml.product_id, ml.location_id, -quantity, lot_id=ml.lot_id, package_id=ml.package_id, owner_id=ml.owner_id)
-                if available_qty < 0 and ml.lot_id:
-                    # see if we can compensate the negative quants with some untracked quants
-                    untracked_qty = Quant._get_available_quantity(ml.product_id, ml.location_id, lot_id=False, package_id=ml.package_id, owner_id=ml.owner_id, strict=True)
-                    if untracked_qty:
-                        taken_from_untracked_qty = min(untracked_qty, abs(quantity))
-                        Quant._update_available_quantity(ml.product_id, ml.location_id, -taken_from_untracked_qty, lot_id=False, package_id=ml.package_id, owner_id=ml.owner_id)
-                        Quant._update_available_quantity(ml.product_id, ml.location_id, taken_from_untracked_qty, lot_id=ml.lot_id, package_id=ml.package_id, owner_id=ml.owner_id)
-                Quant._update_available_quantity(ml.product_id, ml.location_dest_id, quantity, lot_id=ml.lot_id, package_id=ml.result_package_id, owner_id=ml.owner_id, in_date=in_date)
+            # if this move line is force assigned, unreserve elsewhere if needed
+            ml._synchronize_quant(-ml.quantity_product_uom, ml.location_id, action="reserved")
+            available_qty, in_date = ml._synchronize_quant(-ml.quantity_product_uom, ml.location_id)
+            ml._synchronize_quant(ml.quantity_product_uom, ml.location_dest_id, package=ml.result_package_id, in_date=in_date)
+            if available_qty < 0:
+                ml._free_reservation(
+                    ml.product_id, ml.location_id,
+                    abs(available_qty), lot_id=ml.lot_id, package_id=ml.package_id,
+                    owner_id=ml.owner_id, ml_ids_to_ignore=ml_ids_to_ignore)
             ml_ids_to_ignore.add(ml.id)
         # Reset the reserved quantity as we just moved it to the destination location.
         mls_todo.write({
-            'reserved_uom_qty': 0.00,
             'date': fields.Datetime.now(),
         })
 
+    def _synchronize_quant(self, quantity, location, action="available", in_date=False, **quants_value):
+        """ quantity should be express in product's UoM"""
+        lot = quants_value.get('lot', self.lot_id)
+        package = quants_value.get('package', self.package_id)
+        owner = quants_value.get('owner', self.owner_id)
+        available_qty = 0
+        if self.product_id.type != 'product' or float_is_zero(quantity, precision_rounding=self.product_uom_id.rounding):
+            return 0, False
+        if action == "available":
+            available_qty, in_date = self.env['stock.quant']._update_available_quantity(self.product_id, location, quantity, lot_id=lot, package_id=package, owner_id=owner, in_date=in_date)
+        elif action == "reserved" and not self.move_id._should_bypass_reservation():
+            self.env['stock.quant']._update_reserved_quantity(self.product_id, location, quantity, lot_id=lot, package_id=package, owner_id=owner)
+        if available_qty < 0 and lot:
+            # see if we can compensate the negative quants with some untracked quants
+            untracked_qty = self.env['stock.quant']._get_available_quantity(self.product_id, location, lot_id=False, package_id=package, owner_id=owner, strict=True)
+            if not untracked_qty:
+                return available_qty, in_date
+            taken_from_untracked_qty = min(untracked_qty, abs(quantity))
+            self.env['stock.quant']._update_available_quantity(self.product_id, location, -taken_from_untracked_qty, lot_id=False, package_id=package, owner_id=owner, in_date=in_date)
+            self.env['stock.quant']._update_available_quantity(self.product_id, location, taken_from_untracked_qty, lot_id=lot, package_id=package, owner_id=owner, in_date=in_date)
+        return available_qty, in_date
+
     def _get_similar_move_lines(self):
         self.ensure_one()
         lines = self.env['stock.move.line']
@@ -727,7 +653,8 @@ class StockMoveLine(models.Model):
                 self.location_id.id == reserved_quant.location_id.id and
                 self.lot_id.id == reserved_quant.lot_id.id and
                 self.package_id.id == reserved_quant.package_id.id and
-                self.owner_id.id == reserved_quant.owner_id.id):
+                self.owner_id.id == reserved_quant.owner_id.id and
+                not self.result_package_id):
             return True
         return False
 
@@ -759,67 +686,56 @@ class StockMoveLine(models.Model):
         :param ml_ids_to_ignore: OrderedSet of `stock.move.line` ids that should NOT be unreserved
         """
         self.ensure_one()
-
         if ml_ids_to_ignore is None:
             ml_ids_to_ignore = OrderedSet()
         ml_ids_to_ignore |= self.ids
 
-        # Check the available quantity, with the `strict` kw set to `True`. If the available
-        # quantity is greater than the quantity now unavailable, there is nothing to do.
-        available_quantity = self.env['stock.quant']._get_available_quantity(
-            product_id, location_id, lot_id=lot_id, package_id=package_id, owner_id=owner_id, strict=True
-        )
-        if quantity > available_quantity:
-            quantity = quantity - available_quantity
-            # We now have to find the move lines that reserved our now unavailable quantity. We
-            # take care to exclude ourselves and the move lines were work had already been done.
-            outdated_move_lines_domain = [
-                ('state', 'not in', ['done', 'cancel']),
-                ('product_id', '=', product_id.id),
-                ('lot_id', '=', lot_id.id if lot_id else False),
-                ('location_id', '=', location_id.id),
-                ('owner_id', '=', owner_id.id if owner_id else False),
-                ('package_id', '=', package_id.id if package_id else False),
-                ('reserved_qty', '>', 0.0),
-                ('id', 'not in', tuple(ml_ids_to_ignore)),
-            ]
-
-            # We take the current picking first, then the pickings with the latest scheduled date
-            current_picking_first = lambda cand: (
+        if self.move_id._should_bypass_reservation(location_id):
+            return
+
+        # We now have to find the move lines that reserved our now unavailable quantity. We
+        # take care to exclude ourselves and the move lines were work had already been done.
+        outdated_move_lines_domain = [
+            ('state', 'not in', ['done', 'cancel']),
+            ('product_id', '=', product_id.id),
+            ('lot_id', '=', lot_id.id if lot_id else False),
+            ('location_id', '=', location_id.id),
+            ('owner_id', '=', owner_id.id if owner_id else False),
+            ('package_id', '=', package_id.id if package_id else False),
+            ('quantity', '>', 0.0),
+            ('picked', '=', False),
+            ('id', 'not in', tuple(ml_ids_to_ignore)),
+        ]
+
+        # We take the current picking first, then the pickings with the latest scheduled date
+        def current_picking_first(cand):
+            return (
                 cand.picking_id != self.move_id.picking_id,
                 -(cand.picking_id.scheduled_date or cand.move_id.date).timestamp()
                 if cand.picking_id or cand.move_id
-                else -cand.id,
-            )
-            outdated_candidates = self.env['stock.move.line'].search(outdated_move_lines_domain).sorted(current_picking_first)
-
-            # As the move's state is not computed over the move lines, we'll have to manually
-            # recompute the moves which we adapted their lines.
-            move_to_recompute_state = self.env['stock.move']
-            to_unlink_candidate_ids = set()
-
-            rounding = self.product_uom_id.rounding
-            for candidate in outdated_candidates:
-                if float_compare(candidate.reserved_qty, quantity, precision_rounding=rounding) <= 0:
-                    quantity -= candidate.reserved_qty
-                    if candidate.qty_done:
-                        move_to_recompute_state |= candidate.move_id
-                        candidate.reserved_uom_qty = 0.0
-                    else:
-                        to_unlink_candidate_ids.add(candidate.id)
-                    if float_is_zero(quantity, precision_rounding=rounding):
-                        break
-                else:
-                    # split this move line and assign the new part to our extra move
-                    quantity_split = float_round(
-                        candidate.reserved_qty - quantity,
-                        precision_rounding=self.product_uom_id.rounding,
-                        rounding_method='UP')
-                    candidate.reserved_uom_qty = self.product_id.uom_id._compute_quantity(quantity_split, candidate.product_uom_id, rounding_method='HALF-UP')
-                    move_to_recompute_state |= candidate.move_id
+                else -cand.id)
+
+        outdated_candidates = self.env['stock.move.line'].search(outdated_move_lines_domain).sorted(current_picking_first)
+
+        # As the move's state is not computed over the move lines, we'll have to manually
+        # recompute the moves which we adapted their lines.
+        move_to_reassign = self.env['stock.move']
+        to_unlink_candidate_ids = set()
+
+        rounding = self.product_uom_id.rounding
+        for candidate in outdated_candidates:
+            move_to_reassign |= candidate.move_id
+            if float_compare(candidate.quantity_product_uom, quantity, precision_rounding=rounding) <= 0:
+                quantity -= candidate.quantity_product_uom
+                to_unlink_candidate_ids.add(candidate.id)
+                if float_is_zero(quantity, precision_rounding=rounding):
                     break
-            self.env['stock.move.line'].browse(to_unlink_candidate_ids).unlink()
-            move_to_recompute_state._recompute_state()
+            else:
+                candidate.quantity -= candidate.product_id.uom_id._compute_quantity(quantity, candidate.product_uom_id, rounding_method='HALF-UP')
+                break
+
+        self.env['stock.move.line'].browse(to_unlink_candidate_ids).unlink()
+        move_to_reassign._action_assign()
 
     def _get_aggregated_product_quantities(self, **kwargs):
         """ Returns a dictionary of products (key = id+name+description+uom+packaging) and corresponding values of interest.
@@ -829,7 +745,7 @@ class StockMoveLine(models.Model):
         the products by (i.e. so data is not lost). This function purposely ignores lots/SNs because these are
         expected to already be properly grouped by line.
 
-        returns: dictionary {product_id+name+description+uom+packaging: {product, name, description, qty_done, product_uom, packaging}, ...}
+        returns: dictionary {product_id+name+description+uom+packaging: {product, name, description, quantity, product_uom, packaging}, ...}
         """
         aggregated_move_lines = {}
 
@@ -849,7 +765,7 @@ class StockMoveLine(models.Model):
             for line in aggregated_move_lines.values():
                 if line['packaging']:
                     line['packaging_qty'] = line['packaging']._compute_qty(line['qty_ordered'], line['product_uom'])
-                    line['packaging_qty_done'] = line['packaging']._compute_qty(line['qty_done'], line['product_uom'])
+                    line['packaging_quantity'] = line['packaging']._compute_qty(line['quantity'], line['product_uom'])
             return aggregated_move_lines
 
         # Loops to get backorders, backorders' backorders, and so and so...
@@ -863,7 +779,7 @@ class StockMoveLine(models.Model):
             if kwargs.get('except_package') and move_line.result_package_id:
                 continue
             line_key, name, description, uom, packaging = get_aggregated_properties(move_line=move_line)
-            qty_done = move_line.product_uom_id._compute_quantity(move_line.qty_done, uom)
+            quantity = move_line.product_uom_id._compute_quantity(move_line.quantity, uom)
             if line_key not in aggregated_move_lines:
                 qty_ordered = None
                 if backorders and not kwargs.get('strict'):
@@ -878,19 +794,19 @@ class StockMoveLine(models.Model):
                     previous_move_lines = move_line.move_id.move_line_ids.filtered(
                         lambda ml: get_aggregated_properties(move=ml.move_id)[0] == line_key and ml.id != move_line.id
                     )
-                    qty_ordered -= sum(map(lambda m: m.product_uom_id._compute_quantity(m.qty_done, uom), previous_move_lines))
+                    qty_ordered -= sum([m.product_uom_id._compute_quantity(m.quantity, uom) for m in previous_move_lines])
                 aggregated_move_lines[line_key] = {
                     'name': name,
                     'description': description,
-                    'qty_done': qty_done,
-                    'qty_ordered': qty_ordered or qty_done,
+                    'quantity': quantity,
+                    'qty_ordered': qty_ordered or quantity,
                     'product_uom': uom,
                     'product': move_line.product_id,
                     'packaging': packaging,
                 }
             else:
-                aggregated_move_lines[line_key]['qty_ordered'] += qty_done
-                aggregated_move_lines[line_key]['qty_done'] += qty_done
+                aggregated_move_lines[line_key]['qty_ordered'] += quantity
+                aggregated_move_lines[line_key]['quantity'] += quantity
 
         # Does the same for empty move line to retrieve the ordered qty. for partially done moves
         # (as they are splitted when the transfer is done and empty moves don't have move lines).
@@ -899,7 +815,7 @@ class StockMoveLine(models.Model):
         pickings = (self.picking_id | backorders)
         for empty_move in pickings.move_ids:
             if not (empty_move.state == "cancel" and empty_move.product_uom_qty
-                    and float_is_zero(empty_move.quantity_done, precision_rounding=empty_move.product_uom.rounding)):
+                    and float_is_zero(empty_move.quantity, precision_rounding=empty_move.product_uom.rounding)):
                 continue
             line_key, name, description, uom, packaging = get_aggregated_properties(move=empty_move)
 
@@ -908,7 +824,7 @@ class StockMoveLine(models.Model):
                 aggregated_move_lines[line_key] = {
                     'name': name,
                     'description': description,
-                    'qty_done': False,
+                    'quantity': False,
                     'qty_ordered': qty_ordered,
                     'product_uom': uom,
                     'product': empty_move.product_id,
@@ -929,11 +845,12 @@ class StockMoveLine(models.Model):
         return {
             'name': _('New Move:') + self.product_id.display_name,
             'product_id': self.product_id.id,
-            'product_uom_qty': 0 if self.picking_id and self.picking_id.state != 'done' else self.qty_done,
+            'product_uom_qty': 0 if self.picking_id and self.picking_id.state != 'done' else self.quantity,
             'product_uom': self.product_uom_id.id,
             'description_picking': self.description_picking,
             'location_id': self.picking_id.location_id.id,
             'location_dest_id': self.picking_id.location_dest_id.id,
+            'picked': self.picked,
             'picking_id': self.picking_id.id,
             'state': self.picking_id.state,
             'picking_type_id': self.picking_id.picking_type_id.id,
@@ -945,12 +862,6 @@ class StockMoveLine(models.Model):
 
     def _copy_quant_info(self, vals):
         quant = self.env['stock.quant'].browse(vals.get('quant_id', 0))
-        if self:
-            uom = self.product_uom_id
-        elif vals.get('product_uom_id'):
-            uom = self.env['uom.uom'].browse(vals.get('product_uom_id'))
-        else:
-            uom = quant.product_uom_id
         line_data = {
             'product_id': quant.product_id.id,
             'lot_id': quant.lot_id.id,
@@ -979,16 +890,17 @@ class StockMoveLine(models.Model):
             'name':_('%s [reverted]', self.reference),
             'product_id': self.product_id.id,
             'product_uom': self.product_uom_id.id,
-            'product_uom_qty': self.qty_done,
+            'product_uom_qty': self.quantity,
             'company_id': self.company_id.id or self.env.company.id,
             'state': 'confirmed',
             'location_id': self.location_dest_id.id,
             'location_dest_id': self.location_id.id,
             'is_inventory': True,
+            'picked': True,
             'move_line_ids': [(0, 0, {
                 'product_id': self.product_id.id,
                 'product_uom_id': self.product_uom_id.id,
-                'qty_done': self.qty_done,
+                'quantity': self.quantity,
                 'location_id': self.location_dest_id.id,
                 'location_dest_id': self.location_id.id,
                 'company_id': self.company_id.id or self.env.company.id,
@@ -1005,7 +917,7 @@ class StockMoveLine(models.Model):
         self = self.with_context(inventory_mode=False)
         processed_move_line = self.env['stock.move.line']
         for move_line in self:
-            if move_line.is_inventory and not float_is_zero(move_line.qty_done, precision_digits=move_line.product_uom_id.rounding):
+            if move_line.is_inventory and not float_is_zero(move_line.quantity, precision_digits=move_line.product_uom_id.rounding):
                 processed_move_line += move_line
                 move_vals.append(move_line._get_revert_inventory_move_values())
         if not processed_move_line:

--- a/addons/stock/models/stock_package_level.py
+++ b/addons/stock/models/stock_package_level.py
@@ -39,20 +39,23 @@ class StockPackageLevel(models.Model):
     show_lots_text = fields.Boolean(compute='_compute_show_lot')
     company_id = fields.Many2one('res.company', 'Company', required=True, index=True)
 
-    @api.depends('move_line_ids', 'move_line_ids.qty_done')
+    @api.depends('move_line_ids', 'move_line_ids.quantity')
     def _compute_is_done(self):
         for package_level in self:
             # If it is an existing package
             if package_level.is_fresh_package:
                 package_level.is_done = True
             else:
-                package_level.is_done = package_level._check_move_lines_map_quant_package(package_level.package_id, 'qty_done')
+                package_level.is_done = package_level._check_move_lines_map_quant_package(package_level.package_id, only_picked=True)
 
     def _set_is_done(self):
         for package_level in self:
             if package_level.is_done:
                 if not package_level.is_fresh_package:
                     ml_update_dict = defaultdict(float)
+                    package_level.picking_id.move_line_ids.filtered(
+                        lambda ml: not ml.package_level_id and ml.package_id == package_level.package_id
+                    ).unlink()
                     for quant in package_level.package_id.quant_ids:
                         corresponding_mls = package_level.move_line_ids.filtered(lambda ml: ml.product_id == quant.product_id and ml.lot_id == quant.lot_id)
                         to_dispatch = quant.quantity
@@ -70,7 +73,7 @@ class StockPackageLevel(models.Model):
                                 'location_dest_id': package_level.location_dest_id.id,
                                 'picking_id': package_level.picking_id.id,
                                 'product_id': quant.product_id.id,
-                                'qty_done': quant.quantity,
+                                'quantity': quant.quantity,
                                 'product_uom_id': quant.product_id.uom_id.id,
                                 'lot_id': quant.lot_id.id,
                                 'package_id': package_level.package_id.id,
@@ -78,12 +81,13 @@ class StockPackageLevel(models.Model):
                                 'package_level_id': package_level.id,
                                 'move_id': corresponding_move.id,
                                 'owner_id': quant.owner_id.id,
+                                'picked': True,
                             })
                     for rec, quant in ml_update_dict.items():
-                        rec.qty_done = quant
+                        rec.quantity = quant
+                        rec.picked = True
             else:
-                package_level.move_line_ids.filtered(lambda ml: ml.reserved_qty == 0).unlink()
-                package_level.move_line_ids.filtered(lambda ml: ml.reserved_qty != 0).write({'qty_done': 0})
+                package_level.move_line_ids.unlink()
 
     @api.depends('move_line_ids', 'move_line_ids.package_id', 'move_line_ids.result_package_id')
     def _compute_fresh_pack(self):
@@ -103,7 +107,7 @@ class StockPackageLevel(models.Model):
             elif package_level.move_line_ids and not package_level.move_line_ids.filtered(lambda ml: ml.state in ('done', 'cancel')):
                 if package_level.is_fresh_package:
                     package_level.state = 'new'
-                elif package_level._check_move_lines_map_quant_package(package_level.package_id, 'reserved_uom_qty'):
+                elif package_level._check_move_lines_map_quant_package(package_level.package_id):
                     package_level.state = 'assigned'
                 else:
                     package_level.state = 'confirmed'
@@ -168,8 +172,11 @@ class StockPackageLevel(models.Model):
         self.mapped('move_line_ids').write({'result_package_id': False})
         return super(StockPackageLevel, self).unlink()
 
-    def _check_move_lines_map_quant_package(self, package, field):
-        return package._check_move_lines_map_quant(self.move_line_ids, field)
+    def _check_move_lines_map_quant_package(self, package, only_picked=False):
+        mls = self.move_line_ids
+        if only_picked:
+            mls = mls.filtered(lambda ml: ml.picked)
+        return package._check_move_lines_map_quant(mls)
 
     @api.depends('package_id', 'state', 'is_fresh_package', 'move_ids', 'move_line_ids')
     def _compute_location_id(self):

--- a/addons/stock/models/stock_picking.py
+++ b/addons/stock/models/stock_picking.py
@@ -322,14 +322,9 @@ class PickingType(models.Model):
         if self:
             action['display_name'] = self.display_name
 
-        default_immediate_tranfer = True
-        if self.env['ir.config_parameter'].sudo().get_param('stock.no_default_immediate_tranfer'):
-            default_immediate_tranfer = False
-
         context = {
             'search_default_picking_type_id': [self.id],
             'default_picking_type_id': self.id,
-            'default_immediate_transfer': default_immediate_tranfer,
             'default_company_id': self.company_id.id,
         }
 
@@ -416,7 +411,7 @@ class Picking(models.Model):
         ('assigned', 'Ready'),
         ('done', 'Done'),
         ('cancel', 'Cancelled'),
-    ], string='Status', compute='_compute_state', default='assigned',
+    ], string='Status', compute='_compute_state',
         copy=False, index=True, readonly=True, store=True, tracking=True,
         help=" * Draft: The transfer is not confirmed yet. Reservation doesn't apply.\n"
              " * Waiting another operation: This transfer is waiting for another operation before being ready.\n"
@@ -483,9 +478,6 @@ class Picking(models.Model):
         default=lambda self: self.env.user)
     move_line_ids = fields.One2many('stock.move.line', 'picking_id', 'Operations')
     move_line_ids_without_package = fields.One2many('stock.move.line', 'picking_id', 'Operations without package', domain=['|',('package_level_id', '=', False), ('picking_type_entire_packs', '=', False)])
-    move_line_nosuggest_ids = fields.One2many(
-        'stock.move.line', 'picking_id',
-        domain=['|', ('reserved_qty', '=', 0.0), '&', ('reserved_qty', '!=', 0.0), ('qty_done', '!=', 0.0)])
     move_line_exist = fields.Boolean(
         'Has Pack Operations', compute='_compute_move_line_exist',
         help='Check the existence of pack operation on the picking')
@@ -495,9 +487,6 @@ class Picking(models.Model):
     show_check_availability = fields.Boolean(
         compute='_compute_show_check_availability',
         help='Technical field used to compute whether the button "Check Availability" should be displayed.')
-    show_validate = fields.Boolean(
-        compute='_compute_show_validate',
-        help='Technical field used to decide whether the button "Validate" should be displayed.')
     show_allocation = fields.Boolean(
         compute='_compute_show_allocation',
         help='Technical Field used to decide whether the button "Allocation" should be displayed.')
@@ -519,7 +508,6 @@ class Picking(models.Model):
     show_reserved = fields.Boolean(related='picking_type_id.show_reserved')
     show_lots_text = fields.Boolean(compute='_compute_show_lots_text')
     has_tracking = fields.Boolean(compute='_compute_has_tracking')
-    immediate_transfer = fields.Boolean(default=True)
     package_level_ids = fields.One2many('stock.package_level', 'picking_id')
     package_level_ids_details = fields.One2many('stock.package_level', 'picking_id')
     products_availability = fields.Char(
@@ -541,18 +529,16 @@ class Picking(models.Model):
         ('name_uniq', 'unique(name, company_id)', 'Reference must be unique per company!'),
     ]
 
-    @api.depends('show_validate',
-                 'move_ids.reserved_availability',
-                 'move_ids.quantity_done')
+    @api.depends('move_ids.product_uom_qty', 'move_ids.quantity')
     def _compute_show_qty_button(self):
         self.show_set_qty_button = False
         self.show_clear_qty_button = False
         for picking in self:
-            if not picking.show_validate:
+            if picking.state in ['draft', 'done', 'cancel']:
                 continue
-            if any(float_is_zero(m.quantity_done, precision_rounding=m.product_uom.rounding) and not float_is_zero(m.reserved_availability, precision_rounding=m.product_uom.rounding) for m in picking.move_ids):
+            if any(float_is_zero(m.quantity, precision_rounding=m.product_uom.rounding) and not float_is_zero(m.product_uom_qty, precision_rounding=m.product_uom.rounding) for m in picking.move_ids):
                 picking.show_set_qty_button = True
-            elif any(not float_is_zero(m.quantity_done, precision_rounding=m.product_uom.rounding) and float_compare(m.quantity_done, m.reserved_availability, precision_rounding=m.product_uom.rounding) == 0 for m in picking.move_ids):
+            elif any(not float_is_zero(m.quantity, precision_rounding=m.product_uom.rounding) for m in picking.move_ids):
                 picking.show_clear_qty_button = True
 
     def _compute_has_tracking(self):
@@ -673,11 +659,7 @@ class Picking(models.Model):
             picking_move_lines[picking_id.id].add(move.id)
         for picking in self:
             picking_id = (picking.ids and picking.ids[0]) or picking.id
-            if not picking_moves_state_map[picking_id] and picking.immediate_transfer:
-                continue
-            elif not picking_moves_state_map[picking_id]:
-                picking.state = 'draft'
-            elif picking_moves_state_map[picking_id]['any_draft']:
+            if not picking_moves_state_map[picking_id] or picking_moves_state_map[picking_id]['any_draft']:
                 picking.state = 'draft'
             elif picking_moves_state_map[picking_id]['all_cancel']:
                 picking.state = 'cancel'
@@ -688,9 +670,7 @@ class Picking(models.Model):
                     picking.state = 'done'
             else:
                 relevant_move_state = self.env['stock.move'].browse(picking_move_lines[picking_id])._get_relevant_state_among_moves()
-                if picking.immediate_transfer and relevant_move_state not in ('draft', 'cancel', 'done'):
-                    picking.state = 'assigned'
-                elif relevant_move_state == 'partially_available':
+                if relevant_move_state == 'partially_available':
                     picking.state = 'assigned'
                 else:
                     picking.state = relevant_move_state
@@ -740,10 +720,10 @@ class Picking(models.Model):
         displayed in the form view of a picking.
         """
         for picking in self:
-            if picking.immediate_transfer and picking.picking_type_code == 'incoming':
+            if picking.state not in ('confirmed', 'waiting', 'assigned'):
                 picking.show_check_availability = False
                 continue
-            if picking.state not in ('confirmed', 'waiting', 'assigned'):
+            if all(m.picked for m in picking.move_ids):
                 picking.show_check_availability = False
                 continue
             picking.show_check_availability = any(
@@ -752,15 +732,6 @@ class Picking(models.Model):
                 for move in picking.move_ids
             )
 
-    @api.depends('state')
-    def _compute_show_validate(self):
-        for picking in self:
-            if picking.state == 'draft':
-                picking.show_validate = False
-            elif picking.state not in ('draft', 'waiting', 'confirmed', 'assigned'):
-                picking.show_validate = False
-            else:
-                picking.show_validate = True
     @api.depends('state', 'move_ids', 'picking_type_id')
     def _compute_show_allocation(self):
         self.show_allocation = False
@@ -857,7 +828,7 @@ class Picking(models.Model):
             "location_id": self.location_id,
             "location_dest_id": self.location_dest_id
         })
-        if any(line.reserved_qty or line.qty_done for line in self.move_ids.move_line_ids):
+        if any(line.quantity for line in self.move_ids.move_line_ids):
             return {'warning': {
                     'title': 'Locations to update',
                     'message': _("You might want to update the locations of this transfer's operations")
@@ -878,11 +849,6 @@ class Picking(models.Model):
             # order to get a determinist execution of `_set_scheduled_date`
             scheduled_dates.append(vals.pop('scheduled_date', False))
 
-            # immediate transfer is a default value allow in specific cases (interface only)
-            if vals.get('state', 'assigned') != 'assigned':
-                vals['immediate_transfer'] = False
-            if self.env['ir.config_parameter'].sudo().get_param('stock.no_default_immediate_tranfer'):
-                vals['immediate_transfer'] = False
         pickings = super().create(vals_list)
 
         for picking, scheduled_date in zip(pickings, scheduled_dates):
@@ -949,8 +915,6 @@ class Picking(models.Model):
 
     def action_confirm(self):
         self._check_company()
-        if not self.env.context.get('skip_draft'):
-            self.filtered(lambda p: p.state in ['assigned', 'draft'] and p.immediate_transfer).action_reset_draft()
         self.mapped('package_level_ids').filtered(lambda pl: pl.state == 'draft' and not pl.move_ids)._generate_moves()
         # call `_action_confirm` on every draft move
         self.move_ids.filtered(lambda move: move.state == 'draft')._action_confirm()
@@ -987,17 +951,6 @@ class Picking(models.Model):
         self.filtered(lambda x: not x.move_ids).state = 'cancel'
         return True
 
-    def action_reset_draft(self):
-        picking_to_reset = self.filtered(lambda p: p.state not in ('done', 'cancel'))
-        picking_to_reset.do_unreserve()
-        picking_to_reset.immediate_transfer = False
-        if picking_to_reset.move_ids:
-            picking_to_reset.move_ids.quantity_done = 0
-            picking_to_reset.move_ids.move_line_ids.unlink()
-            picking_to_reset.move_ids.state = 'draft'
-        else:
-            picking_to_reset.state = 'draft'
-
     def _action_done(self):
         """Call `_action_done` on the `stock.move` of the `stock.picking` in `self`.
         This method makes sure every `stock.move.line` is linked to a `stock.move` by either
@@ -1036,7 +989,7 @@ class Picking(models.Model):
             )
 
     def _check_move_lines_map_quant_package(self, package):
-        return package._check_move_lines_map_quant(self.move_line_ids.filtered(lambda ml: ml.package_id == package), 'reserved_qty')
+        return package._check_move_lines_map_quant(self.move_line_ids.filtered(lambda ml: ml.package_id == package))
 
     def _get_entire_pack_location_dest(self, move_line_ids):
         location_dest_ids = move_line_ids.mapped('location_dest_id')
@@ -1054,9 +1007,7 @@ class Picking(models.Model):
                     move_lines_to_pack = picking.move_line_ids.filtered(lambda ml: ml.package_id == pack and not ml.result_package_id and ml.state not in ('done', 'cancel'))
                     if not package_level_ids:
                         package_location = self._get_entire_pack_location_dest(move_lines_to_pack) or picking.location_dest_id.id
-                        self.env['stock.package_level'].with_context(
-                            bypass_reservation_update=package_location
-                        ).create({
+                        self.env['stock.package_level'].create({
                             'picking_id': picking.id,
                             'package_id': pack.id,
                             'location_id': pack.location_id.id,
@@ -1066,9 +1017,7 @@ class Picking(models.Model):
                         })
                         # Propagate the result package in the next move for disposable packages only.
                         if pack.package_use == 'disposable':
-                            move_lines_to_pack.with_context(
-                                bypass_reservation_update=package_location
-                            ).write({'result_package_id': pack.id})
+                            move_lines_to_pack.write({'result_package_id': pack.id})
                     else:
                         move_lines_in_package_level = move_lines_to_pack.filtered(lambda ml: ml.move_id.package_level_id)
                         move_lines_without_package_level = move_lines_to_pack - move_lines_in_package_level
@@ -1090,25 +1039,25 @@ class Picking(models.Model):
 
     def _get_lot_move_lines_for_sanity_check(self, none_done_picking_ids, separate_pickings=True):
         """ Get all move_lines with tracked products that need to be checked over in the sanity check.
-            :param none_done_picking_ids: Set of all pickings ids that have no qty_done set on any move_line.
+            :param none_done_picking_ids: Set of all pickings ids that have no quantity set on any move_line.
             :param separate_pickings: Indicates if pickings should be checked independently for lot/serial numbers or not.
         """
         def get_relevant_move_line_ids(none_done_picking_ids, picking):
-            # Get all move_lines if picking has no qty_done set, otherwise only get the move_lines with some qty_done set.
+            # Get all move_lines if picking has no quantity set, otherwise only get the move_lines with some quantity set.
             if picking.id in none_done_picking_ids:
                 return picking.move_line_ids.filtered(lambda ml: ml.product_id and ml.product_id.tracking != 'none').ids
             else:
                 return get_line_with_done_qty_ids(picking.move_line_ids)
 
         def get_line_with_done_qty_ids(move_lines):
-            # Get only move_lines that has some qty_done set.
-            return move_lines.filtered(lambda ml: ml.product_id and ml.product_id.tracking != 'none' and float_compare(ml.qty_done, 0, precision_rounding=ml.product_uom_id.rounding)).ids
+            # Get only move_lines that has some quantity set.
+            return move_lines.filtered(lambda ml: ml.product_id and ml.product_id.tracking != 'none' and float_compare(ml.quantity, 0, precision_rounding=ml.product_uom_id.rounding)).ids
 
         if separate_pickings:
-            # If pickings are checked independently, get full/partial move_lines depending if each picking has no qty_done set.
+            # If pickings are checked independently, get full/partial move_lines depending if each picking has no quantity set.
             lines_to_check_ids = [line_id for picking in self for line_id in get_relevant_move_line_ids(none_done_picking_ids, picking)]
         else:
-            # If pickings are checked as one (like in a batch), then get only the move_lines with qty_done across all pickings if there is at least one.
+            # If pickings are checked as one (like in a batch), then get only the move_lines with quantity across all pickings if there is at least one.
             if any(picking.id not in none_done_picking_ids for picking in self):
                 lines_to_check_ids = get_line_with_done_qty_ids(self.move_line_ids)
             else:
@@ -1126,13 +1075,10 @@ class Picking(models.Model):
         precision_digits = self.env['decimal.precision'].precision_get('Product Unit of Measure')
 
         no_quantities_done_ids = set()
-        no_reserved_quantities_ids = set()
+        pickings_without_quantities = self.env['stock.picking']
         for picking in self:
-            if all(float_is_zero(move_line.qty_done, precision_digits=precision_digits) for move_line in picking.move_line_ids.filtered(lambda m: m.state not in ('done', 'cancel'))):
-                no_quantities_done_ids.add(picking.id)
-            if all(float_is_zero(move_line.reserved_qty, precision_rounding=move_line.product_uom_id.rounding) for move_line in picking.move_line_ids):
-                no_reserved_quantities_ids.add(picking.id)
-        pickings_without_quantities = self.filtered(lambda p: p.id in no_quantities_done_ids and p.id in no_reserved_quantities_ids and not p.immediate_transfer)
+            if all(float_is_zero(move.quantity, precision_digits=precision_digits) for move in picking.move_ids.filtered(lambda m: m.state not in ('done', 'cancel'))):
+                pickings_without_quantities |= picking
 
         pickings_using_lots = self.filtered(lambda p: p.picking_type_id.use_create_lots or p.picking_type_id.use_existing_lots)
         if pickings_using_lots:
@@ -1153,8 +1099,6 @@ class Picking(models.Model):
             message = ""
             if pickings_without_moves:
                 message += _('Transfers %s: Please add some items to move.', ', '.join(pickings_without_moves.mapped('name')))
-            if pickings_without_quantities:
-                message += _('\n\nTransfers %s: You cannot validate these transfers if no quantities are reserved nor done. To force these transfers, switch in edit more and encode the done quantities.', ', '.join(pickings_without_quantities.mapped('name')))
             if pickings_without_lots:
                 message += _('\n\nTransfers %s: You need to supply a Lot/Serial number for products %s.', ', '.join(pickings_without_lots.mapped('name')), ', '.join(products_without_lots.mapped('display_name')))
             if message:
@@ -1165,16 +1109,9 @@ class Picking(models.Model):
         self.package_level_ids.filtered(lambda p: not p.move_ids).unlink()
 
     def button_validate(self):
-        # Clean-up the context key at validation to avoid forcing the creation of immediate
-        # transfers.
-        ctx = dict(self.env.context)
-        ctx.pop('default_immediate_transfer', None)
-        self = self.with_context(ctx)
-
         # Sanity checks.
         if not self.env.context.get('skip_sanity_check', False):
             self._sanity_check()
-
         self.message_subscribe([self.env.user.partner_id.id])
 
         # Run the pre-validation wizards. Processing a pre-validation wizard should work on the
@@ -1198,7 +1135,7 @@ class Picking(models.Model):
         another_action = False
         if self.user_has_groups('stock.group_reception_report'):
             pickings_show_report = self.filtered(lambda p: p.picking_type_id.auto_show_reception_report)
-            lines = pickings_show_report.move_ids.filtered(lambda m: m.product_id.type == 'product' and m.state != 'cancel' and m.quantity_done and not m.move_dest_ids)
+            lines = pickings_show_report.move_ids.filtered(lambda m: m.product_id.type == 'product' and m.state != 'cancel' and m.quantity and not m.move_dest_ids)
             if lines:
                 # don't show reception report if all already assigned/nothing to assign
                 wh_location_ids = self.env['stock.location']._search([('id', 'child_of', pickings_show_report.picking_type_id.warehouse_id.view_location_id.ids), ('usage', '!=', 'supplier')])
@@ -1225,34 +1162,17 @@ class Picking(models.Model):
             }
         return True
 
-    def action_set_quantities_to_reservation(self):
-        self.move_ids.filtered(lambda m: float_is_zero(m.quantity_done, precision_rounding=m.product_uom.rounding))._set_quantities_to_reservation()
-
     def action_clear_quantities_to_zero(self):
-        self.move_ids.filtered(lambda m: float_compare(m.quantity_done, m.reserved_availability, precision_rounding=m.product_uom.rounding) == 0)._clear_quantities_to_zero()
+        self.move_ids.filtered(lambda m: not m.picked)._do_unreserve()
 
     def _pre_action_done_hook(self):
-        if not self.env.context.get('skip_immediate'):
-            pickings_to_immediate = self._check_immediate()
-            if pickings_to_immediate:
-                return pickings_to_immediate._action_generate_immediate_wizard(show_transfers=self._should_show_transfers())
-
+        for picking in self:
+            if all(not move.picked for move in picking.move_ids):
+                picking.move_ids.picked = True
         if not self.env.context.get('skip_backorder'):
             pickings_to_backorder = self._check_backorder()
             if pickings_to_backorder:
                 return pickings_to_backorder._action_generate_backorder_wizard(show_transfers=self._should_show_transfers())
-
-        message = ''
-        for move in self.move_ids:
-            if float_compare(move.quantity_done, move.product_uom_qty, precision_rounding=move.product_uom.rounding) > 0 \
-                    and not float_is_zero(move.product_uom_qty, precision_rounding=move.product_uom.rounding) \
-                    and move.from_immediate_transfer:
-                message += _('%(name)s has a quantity of %(initial_qty)s %(uom)s done, but %(done_qty)s %(uom)s reserved\n', name=move.product_id.display_name, initial_qty=move.product_uom_qty, done_qty=move.quantity_done, uom=move.product_uom.name)
-            if move.from_immediate_transfer and float_compare(move.product_qty, move.quantity_done, precision_rounding=move.product_uom.rounding) > 0:
-                move.quantity_done = move.product_qty
-        if message:
-            message = _('The product(s)\n') + message + _('Update quantities of those products.')
-            raise UserError(message)
         return True
 
     def _should_show_transfers(self):
@@ -1260,14 +1180,14 @@ class Picking(models.Model):
         return len(self) > 1
 
     def _get_without_quantities_error_message(self):
-        """ Returns the error message raised in validation if no quantities are reserved or done.
+        """ Returns the error message raised in validation if no quantities are reserved.
         The purpose of this method is to be overridden in case we want to adapt this message.
 
         :return: Translated error message
         :rtype: str
         """
         return _(
-            'You cannot validate a transfer if no quantities are reserved nor done. '
+            'You cannot validate a transfer if no quantities are reserved. '
             'To force the transfer, switch in edit mode and encode the done quantities.'
         )
 
@@ -1284,19 +1204,6 @@ class Picking(models.Model):
             'context': dict(self.env.context, default_show_transfers=show_transfers, default_pick_ids=[(4, p.id) for p in self]),
         }
 
-    def _action_generate_immediate_wizard(self, show_transfers=False):
-        view = self.env.ref('stock.view_immediate_transfer')
-        return {
-            'name': _('Immediate Transfer?'),
-            'type': 'ir.actions.act_window',
-            'view_mode': 'form',
-            'res_model': 'stock.immediate.transfer',
-            'views': [(view.id, 'form')],
-            'view_id': view.id,
-            'target': 'new',
-            'context': dict(self.env.context, default_show_transfers=show_transfers, default_pick_ids=[(4, p.id) for p in self]),
-        }
-
     def action_toggle_is_locked(self):
         self.ensure_one()
         self.is_locked = not self.is_locked
@@ -1309,41 +1216,28 @@ class Picking(models.Model):
             if picking.picking_type_id.create_backorder != 'ask':
                 continue
             if any(
-                    float_compare(move.quantity_done, move.product_uom_qty, precision_digits=prec) < 0
+                    float_compare(move.quantity, move.product_uom_qty, precision_digits=prec) < 0 or
+                    (move.product_uom_qty and not move.picked)
                     for move in picking.move_ids
                     if move.state != 'cancel'
             ):
                 backorder_pickings |= picking
         return backorder_pickings
 
-    def _check_immediate(self):
-        immediate_pickings = self.browse()
-        precision_digits = self.env['decimal.precision'].precision_get('Product Unit of Measure')
-        for picking in self:
-            if picking.immediate_transfer:
-                continue
-            if all(float_is_zero(move_line.qty_done, precision_digits=precision_digits) for move_line in picking.move_line_ids.filtered(lambda m: m.state not in ('done', 'cancel'))):
-                immediate_pickings |= picking
-        return immediate_pickings
-
     def _autoconfirm_picking(self):
-        """ Automatically run `action_confirm` on `self` if the picking is an immediate transfer or
-        if the picking is a planned transfer and one of its move was added after the initial
+        """ Automatically run `action_confirm` on `self` if one of the
+        picking's move was added after the initial
         call to `action_confirm`. Note that `action_confirm` will only work on draft moves.
         """
-        # Clean-up the context key to avoid forcing the creation of immediate transfers.
-        ctx = dict(self.env.context)
-        ctx.pop('default_immediate_transfer', None)
-        self = self.with_context(ctx)
         for picking in self:
             if picking.state in ('done', 'cancel'):
                 continue
             if not picking.move_ids and not picking.package_level_ids:
                 continue
             if any(move.additional for move in picking.move_ids):
-                picking.with_context(skip_draft=picking.immediate_transfer).action_confirm()
-                if picking.immediate_transfer:
-                    picking.move_ids.write({'state': 'assigned'})
+                picking.action_confirm()
+        to_confirm = self.move_ids.filtered(lambda m: m.state == 'draft' and not m.product_uom_qty and m.quantity)
+        to_confirm._action_confirm()
 
     def _create_backorder(self):
         """ This method is called when the user chose to create a backorder. It will create a new
@@ -1365,7 +1259,8 @@ class Picking(models.Model):
                     body=_('The backorder %s has been created.', backorder_picking._get_html_link())
                 )
                 moves_to_backorder.write({'picking_id': backorder_picking.id})
-                moves_to_backorder.move_line_ids.package_level_id.write({'picking_id':backorder_picking.id})
+                moves_to_backorder.move_line_ids.package_level_id.write({'picking_id': backorder_picking.id})
+                # moves_to_backorder._do_unreserve()
                 moves_to_backorder.mapped('move_line_ids').write({'picking_id': backorder_picking.id})
                 backorders |= backorder_picking
                 if backorder_picking.picking_type_id.reservation_method == 'at_confirm':
@@ -1555,43 +1450,19 @@ class Picking(models.Model):
 
     def _put_in_pack(self, move_line_ids, create_package_level=True):
         self.ensure_one()
-        move_lines_to_pack = self.env['stock.move.line']
         package = self.env['stock.quant.package'].create({})
-        precision_digits = self.env['decimal.precision'].precision_get('Product Unit of Measure')
-        if float_is_zero(move_line_ids[0].qty_done, precision_digits=precision_digits):
-            for line in move_line_ids:
-                line.qty_done = line.reserved_uom_qty
 
-        for ml in move_line_ids:
-            if float_compare(ml.qty_done, ml.reserved_uom_qty, precision_rounding=ml.product_uom_id.rounding) >= 0:
-                move_lines_to_pack |= ml
-            else:
-                quantity_left_todo = float_round(
-                    ml.reserved_uom_qty - ml.qty_done,
-                    precision_rounding=ml.product_uom_id.rounding,
-                    rounding_method='HALF-UP')
-                done_to_keep = ml.qty_done
-                new_move_line = ml.copy(
-                    default={'reserved_uom_qty': 0, 'qty_done': ml.qty_done})
-                vals = {'reserved_uom_qty': quantity_left_todo, 'qty_done': 0.0}
-                if self.picking_type_id.code == 'incoming':
-                    if ml.lot_id:
-                        vals['lot_id'] = False
-                    if ml.lot_name:
-                        vals['lot_name'] = False
-                ml.write(vals)
-                new_move_line.write({'reserved_uom_qty': done_to_keep})
-                move_lines_to_pack |= new_move_line
-        package_type = move_lines_to_pack.move_id.product_packaging_id.package_type_id
-        if len(package_type) == 1:
-            package.package_type_id = package_type
-        if len(move_lines_to_pack) == 1:
-            default_dest_location = move_lines_to_pack._get_default_dest_location()
-            move_lines_to_pack.location_dest_id = default_dest_location._get_putaway_strategy(
-                product=move_lines_to_pack.product_id,
-                quantity=move_lines_to_pack.reserved_uom_qty,
+        if not package.package_type_id:
+            package_type = move_line_ids.move_id.product_packaging_id.package_type_id
+            if len(package_type) == 1:
+                package.package_type_id = package_type
+        if len(move_line_ids) == 1:
+            default_dest_location = move_line_ids._get_default_dest_location()
+            move_line_ids.location_dest_id = default_dest_location._get_putaway_strategy(
+                product=move_line_ids.product_id,
+                quantity=move_line_ids.quantity,
                 package=package)
-        move_lines_to_pack.write({
+        move_line_ids.write({
             'result_package_id': package.id,
         })
         if create_package_level:
@@ -1599,8 +1470,8 @@ class Picking(models.Model):
                 'package_id': package.id,
                 'picking_id': self.id,
                 'location_id': False,
-                'location_dest_id': move_lines_to_pack.mapped('location_dest_id').id,
-                'move_line_ids': [Command.set(move_lines_to_pack.ids)],
+                'location_dest_id': move_line_ids.mapped('location_dest_id').id,
+                'move_line_ids': [(6, 0, move_line_ids.ids)],
                 'company_id': self.company_id.id,
             })
         return package
@@ -1620,33 +1491,23 @@ class Picking(models.Model):
     def action_put_in_pack(self):
         self.ensure_one()
         if self.state not in ('done', 'cancel'):
-            if self.immediate_transfer:
-                for move in self.move_ids:
-                    if float_is_zero(move.quantity_done, precision_rounding=move.product_uom.rounding):
-                        move.quantity_done = move.product_qty
-            picking_move_lines = self.move_line_ids
-            if (
-                not self.picking_type_id.show_reserved
-                and not self.env.context.get('barcode_view')
-            ):
-                picking_move_lines = self.move_line_nosuggest_ids
 
-            move_line_ids = picking_move_lines.filtered(lambda ml:
-                float_compare(ml.qty_done, 0.0, precision_rounding=ml.product_uom_id.rounding) > 0
-                and not ml.result_package_id
+            quantity_move_line_ids = self.move_line_ids.filtered(
+                lambda ml:
+                    float_compare(ml.quantity, 0.0, precision_rounding=ml.product_uom_id.rounding) > 0 and
+                    not ml.result_package_id
             )
+            move_line_ids = quantity_move_line_ids.filtered(lambda ml: ml.picked)
             if not move_line_ids:
-                move_line_ids = picking_move_lines.filtered(lambda ml: float_compare(ml.reserved_uom_qty, 0.0,
-                                     precision_rounding=ml.product_uom_id.rounding) > 0 and float_compare(ml.qty_done, 0.0,
-                                     precision_rounding=ml.product_uom_id.rounding) == 0)
+                move_line_ids = quantity_move_line_ids
             if move_line_ids:
                 res = self._pre_put_in_pack_hook(move_line_ids)
                 if not res:
                     package = self._put_in_pack(move_line_ids)
+                    self.action_assign()
                     return self._post_put_in_pack_hook(package)
                 return res
-            else:
-                raise UserError(_("Please add 'Done' quantities to the picking to create a new pack."))
+            raise UserError(_("Please add 'Done' quantities to the picking to create a new pack."))
 
     def button_scrap(self):
         self.ensure_one()

--- a/addons/stock/models/stock_quant.py
+++ b/addons/stock/models/stock_quant.py
@@ -223,9 +223,13 @@ class StockQuant(models.Model):
         """
         if not self._is_inventory_mode():
             return
+        quant_to_inventory = self.env['stock.quant']
         for quant in self:
+            if quant.quantity == quant.inventory_quantity_auto_apply:
+                continue
             quant.inventory_quantity = quant.inventory_quantity_auto_apply
-        self.action_apply_inventory()
+            quant_to_inventory |= quant
+        quant_to_inventory.action_apply_inventory()
 
     def _search_on_hand(self, operator, value):
         """Handle the "on_hand" filter, indirectly calling `_get_domain_locations`."""
@@ -598,6 +602,8 @@ class StockQuant(models.Model):
 
     @api.model
     def _get_removal_strategy(self, product_id, location_id):
+        product_id = product_id.sudo()
+        location_id = location_id.sudo()
         if product_id.categ_id.removal_strategy_id:
             return product_id.categ_id.removal_strategy_id.method
         loc = location_id
@@ -991,8 +997,8 @@ class StockQuant(models.Model):
         return quants_by_product
 
     @api.model
-    def _update_available_quantity(self, product_id, location_id, quantity, lot_id=None, package_id=None, owner_id=None, in_date=None):
-        """ Increase or decrease `reserved_quantity` of a set of quants for a given set of
+    def _update_available_quantity(self, product_id, location_id, quantity=False, reserved_quantity=False, lot_id=None, package_id=None, owner_id=None, in_date=None):
+        """ Increase or decrease `quantity` or 'reserved quantity' of a set of quants for a given set of
         product_id/location_id/lot_id/package_id/owner_id.
 
         :param product_id:
@@ -1006,6 +1012,8 @@ class StockQuant(models.Model):
                                  current datetime will be used.
         :return: tuple (available_quantity, in_date as a datetime)
         """
+        if not (quantity or reserved_quantity):
+            raise ValidationError(_('Quantity or Reserved Quantity should be set.'))
         self = self.sudo()
         quants = self._gather(product_id, location_id, lot_id=lot_id, package_id=package_id, owner_id=owner_id, strict=True)
         if lot_id and quantity > 0:
@@ -1034,39 +1042,42 @@ class StockQuant(models.Model):
                 quant = self.browse(stock_quant_result[0])
 
         if quant:
-            quant.write({
-                'quantity': quant.quantity + quantity,
-                'in_date': in_date,
-            })
+            vals = {'in_date': in_date}
+            if quantity:
+                vals['quantity'] = quant.quantity + quantity
+            if reserved_quantity:
+                vals['reserved_quantity'] = quant.reserved_quantity + reserved_quantity
+            quant.write(vals)
         else:
-            self.create({
+            vals = {
                 'product_id': product_id.id,
                 'location_id': location_id.id,
-                'quantity': quantity,
                 'lot_id': lot_id and lot_id.id,
                 'package_id': package_id and package_id.id,
                 'owner_id': owner_id and owner_id.id,
                 'in_date': in_date,
-            })
+            }
+            if quantity:
+                vals['quantity'] = quantity
+            if reserved_quantity:
+                vals['reserved_quantity'] = reserved_quantity
+            self.create(vals)
         return self._get_available_quantity(product_id, location_id, lot_id=lot_id, package_id=package_id, owner_id=owner_id, strict=False, allow_negative=True), in_date
 
-    def _update_reserved_quantity(self, product_id, location_id, quantity, lot_id=None, package_id=None, owner_id=None, strict=False):
-        """ Increase the reserved quantity, i.e. increase `reserved_quantity` for the set of quants
-        sharing the combination of `product_id, location_id` if `strict` is set to False or sharing
-        the *exact same characteristics* otherwise. Typically, this method is called when reserving
-        a move or updating a reserved move line. When reserving a chained move, the strict flag
-        should be enabled (to reserve exactly what was brought). When the move is MTS,it could take
-        anything from the stock, so we disable the flag. When editing a move line, we naturally
-        enable the flag, to reflect the reservation according to the edition.
+    @api.model
+    def _update_reserved_quantity(self, product_id, location_id, quantity, lot_id=None, package_id=None, owner_id=None, strict=True):
+        """ Increase or decrease `reserved_quantity` of a set of quants for a given set of
+        product_id/location_id/lot_id/package_id/owner_id.
 
-        :return: a list of tuples (quant, quantity_reserved) showing on which quant the reservation
-            was done and how much the system was able to reserve on it
+        :param product_id:
+        :param location_id:
+        :param quantity:
+        :param lot_id:
+        :param package_id:
+        :param owner_id:
+        :return: available_quantity
         """
-        self = self.sudo()
-        quants_to_reserve = self._get_reserve_quantity(product_id, location_id, quantity, lot_id=lot_id, package_id=package_id, owner_id=owner_id, strict=strict)
-        for quant, qty_to_reserve in quants_to_reserve:
-            quant.reserved_quantity += qty_to_reserve
-        return quants_to_reserve
+        self._update_available_quantity(product_id, location_id, reserved_quantity=quantity, lot_id=lot_id, package_id=package_id, owner_id=owner_id)
 
     @api.model
     def _unlink_zero_quants(self):
@@ -1192,10 +1203,11 @@ class StockQuant(models.Model):
             'location_id': location_id.id,
             'location_dest_id': location_dest_id.id,
             'is_inventory': True,
+            'picked': True,
             'move_line_ids': [(0, 0, {
                 'product_id': self.product_id.id,
                 'product_uom_id': self.product_uom_id.id,
-                'qty_done': qty,
+                'quantity': qty,
                 'location_id': location_id.id,
                 'location_dest_id': location_dest_id.id,
                 'company_id': self.company_id.id or self.env.company.id,
@@ -1361,6 +1373,7 @@ class StockQuant(models.Model):
         moves = self.env['stock.move'].create(move_vals)
         moves._action_done()
 
+
 class QuantPackage(models.Model):
     """ Packages containing quants and/or other packages """
     _name = "stock.quant.package"
@@ -1441,7 +1454,7 @@ class QuantPackage(models.Model):
         action['domain'] = [('id', 'in', pickings.ids)]
         return action
 
-    def _check_move_lines_map_quant(self, move_lines, field):
+    def _check_move_lines_map_quant(self, move_lines):
         """ This method checks that all product (quants) of self (package) are well present in the `move_line_ids`. """
         precision_digits = self.env['decimal.precision'].precision_get('Product Unit of Measure')
 
@@ -1454,7 +1467,7 @@ class QuantPackage(models.Model):
 
         grouped_ops = {}
         for k, g in groupby(move_lines, key=_keys_groupby):
-            grouped_ops[k] = sum(self.env['stock.move.line'].concat(*g).mapped(field))
+            grouped_ops[k] = sum(self.env['stock.move.line'].concat(*g).mapped('quantity'))
 
         if any(not float_is_zero(grouped_quants.get(key, 0) - grouped_ops.get(key, 0), precision_digits=precision_digits) for key in grouped_quants) \
                 or any(not float_is_zero(grouped_ops.get(key, 0) - grouped_quants.get(key, 0), precision_digits=precision_digits) for key in grouped_ops):

--- a/addons/stock/models/stock_scrap.py
+++ b/addons/stock/models/stock_scrap.py
@@ -84,12 +84,12 @@ class StockScrap(models.Model):
         for scrap in self:
             scrap.scrap_location_id = locations_per_company[scrap.company_id.id]
 
-    @api.depends('move_ids', 'move_ids.move_line_ids.qty_done', 'product_id')
+    @api.depends('move_ids', 'move_ids.move_line_ids.quantity', 'product_id')
     def _compute_scrap_qty(self):
         self.scrap_qty = 1
         for scrap in self:
             if scrap.move_ids:
-                scrap.scrap_qty = scrap.move_ids[0].quantity_done
+                scrap.scrap_qty = scrap.move_ids[0].quantity
 
     @api.onchange('lot_id')
     def _onchange_serial_number(self):
@@ -123,15 +123,18 @@ class StockScrap(models.Model):
             'scrapped': True,
             'scrap_id': self.id,
             'location_dest_id': self.scrap_location_id.id,
-            'move_line_ids': [(0, 0, {'product_id': self.product_id.id,
-                                           'product_uom_id': self.product_uom_id.id,
-                                           'qty_done': self.scrap_qty,
-                                           'location_id': self.location_id.id,
-                                           'location_dest_id': self.scrap_location_id.id,
-                                           'package_id': self.package_id.id,
-                                           'owner_id': self.owner_id.id,
-                                           'lot_id': self.lot_id.id, })],
-#             'restrict_partner_id': self.owner_id.id,
+            'move_line_ids': [(0, 0, {
+                'product_id': self.product_id.id,
+                'product_uom_id': self.product_uom_id.id,
+                'quantity': self.scrap_qty,
+                'location_id': self.location_id.id,
+                'location_dest_id': self.scrap_location_id.id,
+                'package_id': self.package_id.id,
+                'owner_id': self.owner_id.id,
+                'lot_id': self.lot_id.id,
+            })],
+            # 'restrict_partner_id': self.owner_id.id,
+            'picked': True,
             'picking_id': self.picking_id.id
         }
 
