PR: https://github.com/odoo/odoo/pull/130632

From: 1af84e28ee8c59ff62cde1750cca5db132028d90
From: Thibault Delavall√©e
Date: 2023-08-09 15:04:26

Structural Changes: 3
Total Changes: 248

[IMP] mail: introduce 'mail.alias.mixin.optional' with optional aliases

Some models would like to use the 'mail.alias.mixin' but it creates an alias
for each record in the parent model. This leads to a lot of unused aliases
if only a subset of those records really use aliases i.e. a lot of aliases
with 'alias_name' being 'False'.

In this commit we introduce a new mixin 'mail.alias.mixin.optional' that
behaves like the old 'mail.alias.mixin' but without having the 'alias_id'
field required i.e. without the "inherits". When creating a record without
giving an 'alias_name' no alias is created.

In future commit, we plan to use it notably to remove custom code in account
journal model and make it more standard. Using it in more models will be done
later, but it is a candidate to cleanup unused aliases related to discuss
channel model.

Task-3453343 (Mail: Cleanup Alias Usage)
Prepares Task-36879 (Mail: Support MultiCompany Aliases)

Part-of: odoo/odoo#130632

================================= pseudo patch: =================================

--- a/addons/mail/models/__init__.py
+++ b/addons/mail/models/__init__.py
@@ -7,6 +7,7 @@ from . import models
 
 # mixin
 from . import mail_activity_mixin
+from . import mail_alias_mixin_optional
 from . import mail_alias_mixin
 from . import mail_render_mixin
 from . import mail_composer_mixin

--- a/addons/mail/models/mail_alias_mixin.py
+++ b/addons/mail/models/mail_alias_mixin.py
@@ -3,89 +3,30 @@
 
 import logging
 
-from odoo import api, fields, models
+from odoo import fields, models
 
 _logger = logging.getLogger(__name__)
 
 
 class AliasMixin(models.AbstractModel):
-    """ A mixin for models that inherits mail.alias. This mixin initializes the
-        alias_id column in database, and manages the expected one-to-one
-        relation between your model and mail aliases.
-    """
+    """ A mixin for models that inherits mail.alias to have a one-to-one relation
+    between the model and its alias. """
     _name = 'mail.alias.mixin'
+    _inherit = 'mail.alias.mixin.optional'
     _inherits = {'mail.alias': 'alias_id'}
     _description = 'Email Aliases Mixin'
-    ALIAS_WRITEABLE_FIELDS = ['alias_name', 'alias_contact', 'alias_defaults', 'alias_bounced_content']
 
-    alias_id = fields.Many2one('mail.alias', string='Alias', ondelete="restrict", required=True)
+    alias_id = fields.Many2one(required=True)
+    alias_name = fields.Char(inherited=True)
+    alias_defaults = fields.Text(inherited=True)
 
     # --------------------------------------------------
     # CRUD
     # --------------------------------------------------
 
-    @api.model_create_multi
-    def create(self, vals_list):
-        """ Create a record with each ``vals`` or ``vals_list`` and create a corresponding alias. """
-        # prepare all alias values
-        alias_vals_list, record_vals_list = [], []
-        for vals in vals_list:
-            new_alias = not vals.get('alias_id')
-            if new_alias:
-                alias_vals, record_vals = self._alias_filter_fields(vals)
-                alias_vals.update(self._alias_get_creation_values())
-                alias_vals_list.append(alias_vals)
-                record_vals_list.append(record_vals)
-
-        # create all aliases
-        alias_ids = []
-        if alias_vals_list:
-            alias_ids = iter(self.env['mail.alias'].sudo().create(alias_vals_list).ids)
-
-        # update alias values in create vals directly
-        valid_vals_list = []
-        record_vals_iter = iter(record_vals_list)
-        for vals in vals_list:
-            new_alias = not vals.get('alias_id')
-            if new_alias:
-                record_vals = next(record_vals_iter)
-                record_vals['alias_id'] = next(alias_ids)
-                valid_vals_list.append(record_vals)
-            else:
-                valid_vals_list.append(vals)
-
-        records = super().create(valid_vals_list)
-
-        for record in records:
-            record.alias_id.sudo().write(record._alias_get_creation_values())
-
-        return records
-
-    def write(self, vals):
-        """ Split writable fields of mail.alias and other fields alias fields will
-        write with sudo and the other normally """
-        alias_vals, record_vals = self._alias_filter_fields(vals, filters=self.ALIAS_WRITEABLE_FIELDS)
-        if record_vals:
-            super().write(record_vals)
-        if alias_vals and (record_vals or self.check_access_rights('write', raise_exception=False)):
-            self.mapped('alias_id').sudo().write(alias_vals)
-
-        return True
-
-    def unlink(self):
-        """ Delete the given records, and cascade-delete their corresponding alias. """
-        aliases = self.mapped('alias_id')
-        res = super().unlink()
-        aliases.sudo().unlink()
-        return res
-
-    @api.returns(None, lambda value: value[0])
-    def copy_data(self, default=None):
-        data = super().copy_data(default)[0]
-        for fields_not_writable in set(self.env['mail.alias']._fields.keys()) - set(self.ALIAS_WRITEABLE_FIELDS):
-            if fields_not_writable in data:
-                del data[fields_not_writable]
-        return [data]
+    def _require_new_alias(self, record_vals):
+        """ alias_id field is always required, due to inherits """
+        return not record_vals.get('alias_id')
 
     def _init_column(self, name):
         """ Create aliases for existing rows. """
@@ -109,29 +50,3 @@ class AliasMixin(models.AbstractModel):
             record.with_context(mail_notrack=True).alias_id = alias
             _logger.info('Mail alias created for %s %s (id %s)',
                          record._name, record.display_name, record.id)
-
-    # --------------------------------------------------
-    # MIXIN TOOL OVERRIDE METHODS
-    # --------------------------------------------------
-
-    def _alias_get_creation_values(self):
-        """ Return values to create an alias, or to write on the alias after its
-            creation.
-        """
-        return {
-            'alias_parent_thread_id': self.id if self.id else False,
-            'alias_parent_model_id': self.env['ir.model']._get_id(self._name),
-        }
-
-    def _alias_filter_fields(self, values, filters=False):
-        """ Split the vals dict into two dictionnary of vals, one for alias
-        field and the other for other fields """
-        if not filters:
-            filters = self.env['mail.alias']._fields.keys()
-        alias_values, record_values = {}, {}
-        for fname in values.keys():
-            if fname in filters:
-                alias_values[fname] = values.get(fname)
-            else:
-                record_values[fname] = values.get(fname)
-        return alias_values, record_values

--- a/None
+++ b/addons/mail/models/mail_alias_mixin_optional.py
@@ -0,0 +1,142 @@
+# -*- coding: utf-8 -*-
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+import logging
+
+from odoo import api, fields, models
+
+_logger = logging.getLogger(__name__)
+
+
+class AliasMixinOptional(models.AbstractModel):
+    """ A mixin for models that handles underlying 'mail.alias' records to use
+    the mail gateway. Field is not mandatory and its creation is done dynamically
+    based on given 'alias_name', allowing to gradually populate the alias table
+    without having void aliases as when used with an inherits-like implementation.
+    """
+    _name = 'mail.alias.mixin.optional'
+    _description = 'Email Aliases Mixin (light)'
+    ALIAS_WRITEABLE_FIELDS = ['alias_name', 'alias_contact', 'alias_defaults', 'alias_bounced_content']
+
+    alias_id = fields.Many2one('mail.alias', string='Alias', ondelete="restrict", required=False)
+    alias_name = fields.Char(related='alias_id.alias_name', readonly=False)
+    alias_domain = fields.Char('Alias domain', compute='_compute_alias_domain')
+    alias_defaults = fields.Text(related='alias_id.alias_defaults')
+
+    @api.depends('alias_name')
+    def _compute_alias_domain(self):
+        self.alias_domain = self.env["ir.config_parameter"].sudo().get_param("mail.catchall.domain")
+
+    # --------------------------------------------------
+    # CRUD
+    # --------------------------------------------------
+
+    @api.model_create_multi
+    def create(self, vals_list):
+        """ Create aliases using sudo if an alias is required, notably if its
+        name is given. """
+        # prepare all alias values
+        alias_vals_list, record_vals_list = [], []
+        for vals in vals_list:
+            if vals.get('alias_name'):
+                vals['alias_name'] = self.env['mail.alias']._sanitize_alias_name(vals['alias_name'])
+            if self._require_new_alias(vals):
+                alias_vals, record_vals = self._alias_filter_fields(vals)
+                alias_vals.update(self._alias_get_creation_values())
+                alias_vals_list.append(alias_vals)
+                record_vals_list.append(record_vals)
+
+        # create all aliases
+        alias_ids = []
+        if alias_vals_list:
+            alias_ids = iter(self.env['mail.alias'].sudo().create(alias_vals_list).ids)
+
+        # update alias values in create vals directly
+        valid_vals_list = []
+        record_vals_iter = iter(record_vals_list)
+        for vals in vals_list:
+            if self._require_new_alias(vals):
+                record_vals = next(record_vals_iter)
+                record_vals['alias_id'] = next(alias_ids)
+                valid_vals_list.append(record_vals)
+            else:
+                valid_vals_list.append(vals)
+
+        records = super().create(valid_vals_list)
+
+        for record in records.filtered('alias_id'):
+            record.alias_id.sudo().write(record._alias_get_creation_values())
+
+        return records
+
+    def write(self, vals):
+        """ Split writable fields of mail.alias and other fields alias fields will
+        write with sudo and the other normally. If alias does not exist and we
+        try to set a name, create the alias automatically. """
+        # create missing aliases
+        if vals.get('alias_name'):
+            alias_create_values = [
+                dict(
+                    record._alias_get_creation_values(),
+                    alias_name=self.env['mail.alias']._sanitize_alias_name(vals['alias_name']),
+                )
+                for record in self.filtered(lambda rec: not rec.alias_id)
+            ]
+            if alias_create_values:
+                aliases = self.env['mail.alias'].sudo().create(alias_create_values)
+                for record, alias in zip(self.filtered(lambda rec: not rec.alias_id), aliases):
+                    record.alias_id = alias.id
+
+        alias_vals, record_vals = self._alias_filter_fields(vals, filters=self.ALIAS_WRITEABLE_FIELDS)
+        if record_vals:
+            super().write(record_vals)
+        if alias_vals and (record_vals or self.check_access_rights('write', raise_exception=False)):
+            self.mapped('alias_id').sudo().write(alias_vals)
+
+        return True
+
+    def unlink(self):
+        """ Delete the given records, and cascade-delete their corresponding alias. """
+        aliases = self.mapped('alias_id')
+        res = super().unlink()
+        aliases.sudo().unlink()
+        return res
+
+    @api.returns(None, lambda value: value[0])
+    def copy_data(self, default=None):
+        data = super().copy_data(default)[0]
+        for fields_not_writable in set(self.env['mail.alias']._fields.keys()) - set(self.ALIAS_WRITEABLE_FIELDS):
+            if fields_not_writable in data:
+                del data[fields_not_writable]
+        return [data]
+
+    def _require_new_alias(self, record_vals):
+        """ Create only if no existing alias, and if a name is given, to avoid
+        creating inactive aliases (falsy name). """
+        return not record_vals.get('alias_id') and record_vals.get('alias_name')
+
+    # --------------------------------------------------
+    # MIXIN TOOL OVERRIDE METHODS
+    # --------------------------------------------------
+
+    def _alias_get_creation_values(self):
+        """ Return values to create an alias, or to write on the alias after its
+            creation.
+        """
+        return {
+            'alias_parent_thread_id': self.id if self.id else False,
+            'alias_parent_model_id': self.env['ir.model']._get_id(self._name),
+        }
+
+    def _alias_filter_fields(self, values, filters=False):
+        """ Split the vals dict into two dictionnary of vals, one for alias
+        field and the other for other fields """
+        if not filters:
+            filters = self.env['mail.alias']._fields.keys()
+        alias_values, record_values = {}, {}
+        for fname in values.keys():
+            if fname in filters:
+                alias_values[fname] = values.get(fname)
+            else:
+                record_values[fname] = values.get(fname)
+        return alias_values, record_values
