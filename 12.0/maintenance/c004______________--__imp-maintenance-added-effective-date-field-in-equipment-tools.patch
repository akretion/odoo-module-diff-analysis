PR: https://github.com/odoo/odoo/pull/

From: 2407b4d457ec9a36477e6bf330b0a3eaffc8b07d
From: Akash Bhavsar
Date: 2018-08-22 08:48:13

Structural Changes: 7
Total Changes: 24

[IMP] maintenance: added effective date field in equipment & tools

Add effective date on maintenance equipement. The purpose is to define
when the equipment is put into service.
Adapt next preventive maintenance according to effective date

Task id: 33188

================================= pseudo patch: =================================

--- a/addons/maintenance/models/maintenance.py
+++ b/addons/maintenance/models/maintenance.py
@@ -135,6 +135,7 @@ class MaintenanceEquipment(models.Model):
     model = fields.Char('Model')
     serial_no = fields.Char('Serial Number', copy=False)
     assign_date = fields.Date('Assigned Date', track_visibility='onchange')
+    effective_date = fields.Date('Effective Date', default=fields.Date.context_today, required=True, help="Date at which the equipment became effective. This date will be used to compute the Mean Time Between Failure.")
     cost = fields.Float('Cost')
     note = fields.Text('Note')
     warranty_date = fields.Date('Warranty Expiration Date', oldname='warranty')
@@ -148,9 +149,8 @@ class MaintenanceEquipment(models.Model):
     maintenance_team_id = fields.Many2one('maintenance.team', string='Maintenance Team')
     maintenance_duration = fields.Float(help="Maintenance Duration in hours.")
 
-    @api.depends('period', 'maintenance_ids.request_date', 'maintenance_ids.close_date')
+    @api.depends('effective_date', 'period', 'maintenance_ids.request_date', 'maintenance_ids.close_date')
     def _compute_next_maintenance(self):
-
         date_now = fields.Date.context_today(self)
         for equipment in self.filtered(lambda x: x.period > 0):
             next_maintenance_todo = self.env['maintenance.request'].search([
@@ -165,31 +165,31 @@ class MaintenanceEquipment(models.Model):
                 ('close_date', '!=', False)], order="close_date desc", limit=1)
             if next_maintenance_todo and last_maintenance_done:
                 next_date = next_maintenance_todo.request_date
-                date_gap = fields.Date.from_string(next_maintenance_todo.request_date) - fields.Date.from_string(last_maintenance_done.close_date)
+                date_gap = next_maintenance_todo.request_date - last_maintenance_done.close_date
                 # If the gap between the last_maintenance_done and the next_maintenance_todo one is bigger than 2 times the period and next request is in the future
                 # We use 2 times the period to avoid creation too closed request from a manually one created
-                if date_gap > timedelta(0) and date_gap > timedelta(days=equipment.period) * 2 and fields.Date.from_string(next_maintenance_todo.request_date) > fields.Date.from_string(date_now):
+                if date_gap > timedelta(0) and date_gap > timedelta(days=equipment.period) * 2 and next_maintenance_todo.request_date > date_now:
                     # If the new date still in the past, we set it for today
-                    if fields.Date.from_string(last_maintenance_done.close_date) + timedelta(days=equipment.period) < fields.Date.from_string(date_now):
+                    if last_maintenance_done.close_date + timedelta(days=equipment.period) < date_now:
                         next_date = date_now
                     else:
-                        next_date = fields.Date.to_string(fields.Date.from_string(last_maintenance_done.close_date) + timedelta(days=equipment.period))
+                        next_date = last_maintenance_done.close_date + timedelta(days=equipment.period)
             elif next_maintenance_todo:
                 next_date = next_maintenance_todo.request_date
-                date_gap = fields.Date.from_string(next_maintenance_todo.request_date) - fields.Date.from_string(date_now)
+                date_gap = next_maintenance_todo.request_date - date_now
                 # If next maintenance to do is in the future, and in more than 2 times the period, we insert an new request
                 # We use 2 times the period to avoid creation too closed request from a manually one created
                 if date_gap > timedelta(0) and date_gap > timedelta(days=equipment.period) * 2:
-                    next_date = fields.Date.to_string(fields.Date.from_string(date_now)+timedelta(days=equipment.period))
+                    next_date = date_now + timedelta(days=equipment.period)
             elif last_maintenance_done:
-                next_date = fields.Date.from_string(last_maintenance_done.close_date)+timedelta(days=equipment.period)
+                next_date = last_maintenance_done.close_date + timedelta(days=equipment.period)
                 # If when we add the period to the last maintenance done and we still in past, we plan it for today
-                if next_date < fields.Date.from_string(date_now):
+                if next_date < date_now:
                     next_date = date_now
             else:
-                next_date = fields.Date.to_string(fields.Date.from_string(date_now) + timedelta(days=equipment.period))
-
+                next_date = self.effective_date + timedelta(days=equipment.period)
             equipment.next_action_date = next_date
+
     @api.one
     @api.depends('maintenance_ids.stage_id.done')
     def _compute_maintenance_count(self):
