PR: https://github.com/odoo/odoo/pull/114964

From: 3d5273c400bf8ba2dd013938186168a5a8a37350
From: MÃ©lanie Peyrat (mepe)
Date: 2024-06-11 12:30:17

Structural Changes: 4
Total Changes: 181

[IMP] * : Working hours appears in Calendar application

* = calendar, hr, hr_contract

Before this commit, working hours don't appear in Calendar application.

If in Calendar app, you load the calendar of an toher employee or your own calendar, their working hours will appear.
If you selected more than one calendar, the working hours displayed is the intersection of all working hours.

task :  3169246

Part-of: odoo/odoo#114964
Signed-off-by: Sofie Gvaladze (sgv) <sgv@odoo.com>

================================= pseudo patch: =================================

--- a/None
+++ b/addons/hr_calendar/models/__init__.py
@@ -0,0 +1,4 @@
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from . import calendar_event
+from . import res_partner

--- a/None
+++ b/addons/hr_calendar/models/calendar_event.py
@@ -0,0 +1,64 @@
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+from pytz import UTC
+
+from odoo import api, fields, models
+
+from odoo.addons.resource.models.utils import Intervals, sum_intervals, timezone_datetime
+
+
+class CalendarEvent(models.Model):
+    _inherit = "calendar.event"
+
+    unavailable_partner_ids = fields.Many2many('res.partner', compute='_compute_unavailable_partner_ids')
+
+    @api.depends('partner_ids', 'start', 'stop', 'allday')
+    def _compute_unavailable_partner_ids(self):
+        event_intervals = self._get_events_interval()
+
+        # Event without start and stop are skipped, except all day event: their interval is computed
+        # based on company calendar's interval.
+        for event, event_interval in event_intervals.items():
+            start = event_interval._items[0][0]
+            stop = event_interval._items[0][1]
+            if not event.partner_ids:
+                event.unavailable_partner_ids = []
+                continue
+            schedule_by_partner = event.partner_ids._get_schedule(start, stop, merge=False)
+            event.unavailable_partner_ids = event._check_employees_availability_for_event(
+                schedule_by_partner, event_interval)
+
+    @api.model
+    def get_unusual_days(self, date_from, date_to=None):
+        return self.env.user.employee_id._get_unusual_days(date_from, date_to)
+
+    def _get_events_interval(self):
+        """
+        Calculate the interval of an event based on its start, stop, and allday values. If an event is scheduled for the
+        entire day, its interval will correspond to the work interval defined by the company's calendar.
+        """
+        start = min(self.mapped('start')).replace(hour=0, minute=0, second=0, tzinfo=UTC)
+        stop = max(self.mapped('stop')).replace(hour=23, minute=59, second=59, tzinfo=UTC)
+        if not start or not stop:
+            return {}
+        company_calendar = self.env.company.resource_calendar_id
+        global_interval = company_calendar._work_intervals_batch(start, stop)[False]
+        interval_by_event = {}
+        for event in self:
+            event_interval = Intervals([(
+                timezone_datetime(event.start),
+                timezone_datetime(event.stop),
+                self.env['resource.calendar']
+            )])
+            if event.allday:
+                interval_by_event[event] = event_interval & global_interval
+            elif event.start and event.stop:
+                interval_by_event[event] = event_interval
+        return interval_by_event
+
+    def _check_employees_availability_for_event(self, schedule_by_partner, event_interval):
+        unavailable_partners = []
+        for partner, schedule in schedule_by_partner.items():
+            common_interval = schedule & event_interval
+            if sum_intervals(common_interval) != sum_intervals(event_interval):
+                unavailable_partners.append(partner.id)
+        return unavailable_partners

--- a/None
+++ b/addons/hr_calendar/models/res_partner.py
@@ -0,0 +1,113 @@
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
+
+from pytz import UTC, timezone
+from datetime import datetime
+from collections import defaultdict
+from functools import reduce
+
+from odoo import api, models
+
+from odoo.osv import expression
+from odoo.addons.resource.models.utils import Intervals
+
+
+class Partner(models.Model):
+    _inherit = ['res.partner']
+
+    def _get_employees_from_attendees(self, everybody=False):
+        domain = [
+            ('company_id', 'in', self.env.companies.ids),
+            ('work_contact_id', '!=', False),
+        ]
+        if not everybody:
+            domain = expression.AND([
+                domain,
+                [('work_contact_id', 'in', self.ids)]
+            ])
+        return dict(self.env['hr.employee'].sudo()._read_group(domain, groupby=['work_contact_id'], aggregates=['id:recordset']))
+
+    def _get_schedule(self, start_period, stop_period, everybody=False, merge=True):
+        """
+        This method implements the general case where employees might have different resource calendars at different
+        times, even though this is not the case with only this module installed.
+        This way it will work with these other modules by just overriding
+        `_get_calendar_periods`.
+
+        :param datetime start_period: the start of the period
+        :param datetime stop_period: the stop of the period
+        :param boolean everybody: represents the "everybody" filter on calendar
+        :param boolean merge: specifies if calendar's work_intervals needs to be merged
+        :return: schedule (merged or not) by partner
+        :rtype: defaultdict
+        """
+        employees_by_partner = self._get_employees_from_attendees(everybody)
+        if not employees_by_partner:
+            return {}
+        interval_by_calendar = defaultdict()
+        calendar_periods_by_employee = defaultdict(list)
+        employees_by_calendar = defaultdict(list)
+
+        # Compute employee's calendars's period and order employee by his involved calendars
+        employees = sum(employees_by_partner.values(), start=self.env['hr.employee'])
+        calendar_periods_by_employee = employees._get_calendar_periods(start_period, stop_period)
+        for employee, calendar_periods in calendar_periods_by_employee.items():
+            for (start, stop, calendar) in calendar_periods:
+                employees_by_calendar[calendar].append(employee)
+
+        # Compute all work intervals per calendar
+        for calendar, employees in employees_by_calendar.items():
+            work_intervals = calendar._work_intervals_batch(start_period, stop_period, resources=employees, tz=timezone(calendar.tz))
+            del work_intervals[False]
+            # Merge all employees intervals to avoid to compute it multiples times
+            if merge:
+                interval_by_calendar[calendar] = reduce(Intervals.__and__, work_intervals.values())
+            else:
+                interval_by_calendar[calendar] = work_intervals
+
+        # Compute employee's schedule based own his calendar's periods
+        schedule_by_employee = defaultdict(list)
+        for employee, calendar_periods in calendar_periods_by_employee.items():
+            employee_interval = Intervals([])
+            for (start, stop, calendar) in calendar_periods:
+                interval = Intervals([(start, stop, self.env['resource.calendar'])])
+                if merge:
+                    calendar_interval = interval_by_calendar[calendar]
+                else:
+                    calendar_interval = interval_by_calendar[calendar][employee.id]
+                employee_interval = employee_interval | (calendar_interval & interval)
+            schedule_by_employee[employee] = employee_interval
+
+        # Compute partner's schedule equals to the union between his employees's schedule
+        schedules = defaultdict()
+        for partner, employees in employees_by_partner.items():
+            partner_schedule = Intervals([])
+            for employee in employees:
+                if schedule_by_employee[employee]:
+                    partner_schedule = partner_schedule | schedule_by_employee[employee]
+            schedules[partner] = partner_schedule
+        return schedules
+
+    @api.model
+    def get_working_hours_for_all_attendees(self, attendee_ids, date_from, date_to, everybody=False):
+
+        start_period = datetime.fromisoformat(date_from).replace(hour=0, minute=0, second=0, tzinfo=UTC)
+        stop_period = datetime.fromisoformat(date_to).replace(hour=23, minute=59, second=59, tzinfo=UTC)
+
+        schedule_by_partner = self.env['res.partner'].browse(attendee_ids)._get_schedule(start_period, stop_period, everybody)
+        if not schedule_by_partner:
+            return []
+        return self._interval_to_business_hours(reduce(Intervals.__and__, schedule_by_partner.values()))
+
+    def _interval_to_business_hours(self, working_intervals):
+        # This is the format expected by the fullcalendar library to do the overlay
+        return [{
+            "daysOfWeek": [interval[0].weekday() + 1],
+            "startTime":  interval[0].astimezone(timezone(self.env.user.tz)).strftime("%H:%M"),
+            "endTime": interval[1].astimezone(timezone(self.env.user.tz)).strftime("%H:%M"),
+        } for interval in working_intervals] if working_intervals else [{
+            # 7 is used a dummy value to gray the full week
+            # Returning an empty list would leave the week uncolored
+            "daysOfWeek": [7],
+            "startTime":  datetime.today().strftime("00:00"),
+            "endTime": datetime.today().strftime("00:00"),
+        }]
